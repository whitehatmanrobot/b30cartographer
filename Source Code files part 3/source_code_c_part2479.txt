KernelString entry, bool __far & value) {return ReadDirect(entry, value, value);}

		virtual Error ReadDirect(KernelString entry, long __far & value, long deflt) = 0;
		Error ReadDirect(KernelString entry, long __far & value) {return ReadDirect(entry, value, value);}

		// the base parameter determines the base (2, 8, 10, 16..) of the argument that
		// is about to be read or written.
		// This is required because e.g. when writing binary data to text-based profiles
		// (like under Win16), the data has to be encoded in a textual format (ASCII).
		virtual Error WriteDirect(KernelString entry, WORD value, int base) = 0;
		virtual Error ReadDirect(KernelString entry, WORD __far & value, int base, WORD deflt) = 0;
		Error ReadDirect(KernelString entry, WORD __far & value, int base) {return ReadDirect(entry, value, base, value);}

		virtual Error WriteDirect(KernelString entry, DWORD value, int base) = 0;
		virtual Error ReadDirect(KernelString entry, DWORD __far & value, int base, DWORD deflt) = 0;
		Error ReadDirect(KernelString entry, DWORD __far & value, int base) {return ReadDirect(entry, value, base, value);}

		virtual Error WriteDirect(KernelString entry, KernelString value) = 0;
		virtual Error ReadDirect(KernelString entry, KernelString & value, KernelString deflt) = 0;
		Error ReadDirect(KernelString entry, KernelString & value) {return ReadDirect(entry, value, value);}

		// These Write/Read functions use "section" as relative path, starting at
		// the location of "this" object.
		virtual Error Write(KernelString section, KernelString entry, int value);
		virtual Error Read(KernelString section, KernelString entry, int __far & value, int deflt);
		Error Read(KernelString section, KernelString entry, int __far & value) {return Read(section, entry, value, value);}

		virtual Error Write(KernelString section, KernelString entry, bool value);
		virtual Error Read(KernelString section, KernelString entry, bool __far & value, bool deflt);
		Error Read(KernelString section, KernelString entry, bool __far & value) {return Read(section, entry, value, value);}

		virtual Error Read(KernelString section, KernelString entry, long __far & value, long deflt);
		Error Read(KernelString section, KernelString entry, long __far & value) {return Read(section, entry, value, value);}

		virtual Error Write(KernelString section, KernelString entry, DWORD value, int base = 10);
		virtual Error Read(KernelString section, KernelString entry, DWORD __far & value, int base, DWORD deflt);
		Error Read(KernelString section, KernelString entry, DWORD __far & value, int base) {return Read(section, entry, value, base, value);}

		virtual Error Write(KernelString section, KernelString entry, WORD value, int base);
		virtual Error Read(KernelString section, KernelString entry, WORD __far & value, int base, WORD deflt);
		Error Read(KernelString section, KernelString entry, WORD __far & value, int base) {return Read(section, entry, value, base, value);}

		virtual Error Write(KernelString section, KernelString entry, KernelString value);
		virtual Error Read(KernelString section, KernelString entry, KernelString & value, KernelString deflt);
		Error Read(KernelString section, KernelString entry, KernelString & value) {return Read(section, entry, value, value);}
	};


//
// Entry for the static profile
// The location of keys in a static profile is found by
// calculating a hash value from their name.
//

struct ProfileEntry
	{
	DWORD id;
	DWORD	value;
	};

class StaticProfile : public GenericProfile
	{
	private:
		ProfileEntry	*	entries;

	protected:
		BOOL	protect;

		virtual Error WriteDW(KernelString entry, DWORD value);
		virtual Error ReadDW(KernelString entry, DWORD __far & value);

		virtual Error FindValue(KernelString entryName, ProfileEntry * __far & entry);
		virtual Error FindSection(KernelString section, ProfileEntry * __far & entry);

	public:
		// ProfileEntry array must be initialized (formatted).
		StaticProfile(ProfileEntry * entries);
		StaticProfile(const ProfileEntry * entries);	// Read only profile
		// Start with a subsection.
		StaticProfile(ProfileEntry * entries, KernelString section);
		StaticProfile(StaticProfile * parent, KernelString section);

		virtual void SetWriteProtection(BOOL protect) {this->protect = protect;}	// Default is ON!

		GenericProfile * CreateSection(KernelString section); // creates a new subsection (folder)

		BOOL IsValid(void);

		Error CalculateByteSize (int & size);   // of the valid ProfileEntry array

		// XXXDirect methods write directly to the absolute location given in "entry".
		Error WriteDirect(KernelString entry, int value);
		Error ReadDirect(KernelString entry, int __far & value, int deflt);

		Error WriteDirect(KernelString entry, long value);
		Error ReadDirect(KernelString entry, long __far & value, long deflt);

		Error WriteDirect(KernelString entry, WORD value, int base);
		Error ReadDirect(KernelString entry, WORD __far & value, int base, WORD deflt);

		Error WriteDirect(KernelString entry, DWORD value, int base);
		Error ReadDirect(KernelString entry, DWORD __far & value, int base, DWORD deflt);

		Error WriteDirect(KernelString entry, KernelString value);
		Error ReadDirect(KernelString entry, KernelString & value, KernelString deflt);

		Error WriteDirect(KernelString entry, bool value);
		Error ReadDirect(KernelString entry, bool __far & value, bool deflt);
	};

//
// Entry for the most-used standard profile
// When compiling for Win16, profiles get written to .ini files
// When compiling a standard Win32 app, a VxD or for NT, profiles
// get written into the registry.
//

class NullProfile : public GenericProfile
	{
	public:
		GenericProfile * CreateSection(KernelString section) {return this;}

		BOOL IsValid(void) {return true;}

		Error WriteDirect(KernelString entry, int value) {GNRAISE_OK;}
		Error ReadDirect(KernelString entry, int __far & value, int deflt) {value = deflt; GNRAISE_OK;}

		Error WriteDirect(KernelString entry, bool value)  {GNRAISE_OK;}
		Error ReadDirect(KernelString entry, bool __far & value, bool deflt)  {value = deflt; GNRAISE_OK;}

		Error ReadDirect(KernelString entry, long __far & value, long deflt)  {value = deflt; GNRAISE_OK;}

		Error WriteDirect(KernelString entry, WORD value, int base)  {GNRAISE_OK;}
		Error ReadDirect(KernelString entry, WORD __far & value, int base, WORD deflt)  {value = deflt; GNRAISE_OK;}

		Error WriteDirect(KernelString entry, DWORD value, int base)  {GNRAISE_OK;}
		Error ReadDirect(KernelString entry, DWORD __far & value, int base, DWORD deflt)  {value = deflt; GNRAISE_OK;}

		Error WriteDirect(KernelString entry, KernelString value)  {GNRAISE_OK;}
		Error ReadDirect(KernelString entry, KernelString & value, KernelString deflt)  {value = deflt; GNRAISE_OK;}
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\Tags.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


// FILE:      library\common\tags.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   24.03.95
//
// PURPOSE: The tag processing module.
//
// HISTORY:

#ifndef TAGS_H
#define TAGS_H

#include "library/common/prelude.h"
#include "library/common/gnerrors.h"



// In order to be flexible, we use tags for setting and getting data and query
// module capabilities. Tag pairs consist of the tag itself and a data item.
// The tag tells which variable shall be set or retrieved. The data item is
// the value written to the variable or a pointer to the location where the
// retrieved value is to be stored.
// Tags have 32 bits and are built the following way:
//
// iccc uuuu uuuu uuuu rsss ssss ssss ssss
//
// "cc" is the tag command get, set or query. The tagging unit follows. The
// tag specifier itself is contained in the lowest 15 bits.
// Internal tags are marked with an i=1, external tags marked with an i=0.
// The difference between internal and external tagunits is, that external
// units have a type bit each, internal units only have numbers.
// Tags are type checked. Tags are constructed by the MKTAG_* macros and
// terminated by TAGDONE. The inline functions below do the type checking and
// are optimized to NOPs.  The r bit is used for reference tags.  These tags
// do not carry a value, but a reference to a more extendet structure;
//

#define TAG_VAL  0x00000000
#define TAG_GET  0x10000000
#define TAG_SET  0x20000000
#define TAG_QRY  0x30000000

#define TAG_REF  0x00008000

#define TAG_TYPE(x)	(x & 0x30000000)

#define ANYUNIT	0x4fff0000
#define MAIN_UNIT	0x00000000

#define MKTAGUNIT(unit, id)	\
	static const WORD unit##_ID	=	id;	\
	static const DWORD unit =  MKFLAG(16 + id);

#define GETTAGUNITS(tag)   XTBF(16, 12, tag)
#define USESTAGUNIT(tag, id) XTBF(16+id, tag)

#define MKITAGUNIT(unit, id)	\
	static const DWORD unit = 0x80000000L | (id << 16);

#if WDM_VERSION
struct __far TAG {
	DWORD	id;
	DWORD_PTR	data;
	TAG (DWORD _id, DWORD_PTR _data) { data = _data; id = _id; };
	TAG() {};
	~TAG() {}
	};
#else
struct __far TAG {
	DWORD	id;
	DWORD	data;
	TAG (DWORD _id, DWORD _data) { data = _data; id = _id; };
	TAG() {};
#if !__EDG__ || __EDG_VERSION__<240
	~TAG() {}	// This is mainly used as a workaround for a certain C++ frontend compiler bug.
#endif
	};
#endif

inline BOOL __far & QRY_TAG(TAG __far * tag) {return *((BOOL __far *)(tag->data));}

	//
	// TAG terminator
	//
#define TAGDONE TAG(0,0)

#if WDM_VERSION
DWORD_PTR FilterTags(TAG __far * tags, DWORD id, DWORD_PTR def);
#else
DWORD FilterTags(TAG __far * tags, DWORD id, DWORD def);
#endif

#if WDM_VERSION

#define MKTAG(name, unit, val, type)	\
	inline TAG SET_##name(type x) {return TAG(val | unit | TAG_SET, (DWORD_PTR)(x));}	\
	inline TAG GET_##name(type __far &x) {return TAG(val | unit | TAG_GET, (DWORD_PTR)(&x));}	\
	inline TAG QRY_##name(BOOL __far &x) {return TAG(val | unit | TAG_QRY, (DWORD_PTR)(&x));}	\
	inline type VAL_##name(TAG __far * tag) {return (type)(tag->data);}	\
	inline type FVAL_##name(TAG __far * tags, type def) {return (type)(FilterTags(tags, val | unit | TAG_GET, (DWORD_PTR)def));}	\
	inline type __far & REF_##name(TAG __far * tag) {return *(type __far *)(tag->data);}	\
	typedef type TTYPE_##name;	\
	static const DWORD CSET_##name = val | unit | TAG_SET;	\
	static const DWORD CGET_##name = val | unit | TAG_GET;	\
	static const DWORD CQRY_##name = val | unit | TAG_QRY;

#define MKRTG(name, unit, val, type)	\
	inline TAG SET_##name(type __far &x) {return TAG(val | unit | TAG_SET | TAG_REF, (DWORD_PTR)(FPTR)(&x));}	\
	inline TAG GET_##name(type __far &x) {return TAG(val | unit | TAG_GET | TAG_REF, (DWORD_PTR)(FPTR)(&x));}	\
	inline TAG QRY_##name(BOOL __far &x) {return TAG(val | unit | TAG_QRY | TAG_REF, (DWORD_PTR)(&x));}	\
	inline type VAL_##name(TAG __far * tag) {return *(type __far *)(tag->data);}	\
	inline type __far & REF_##name(TAG __far * tag) {return *(type __far *)(tag->data);}	\
	typedef type TTYPE_##name;	\
	static const DWORD CSET_##name = val | unit | TAG_SET | TAG_REF;	\
	static const DWORD CGET_##name = val | unit | TAG_GET | TAG_REF;	\
	static const DWORD CQRY_##name = val | unit | TAG_QRY | TAG_REF;

#else

#define MKTAG(name, unit, val, type)	\
	inline TAG SET_##name(type x) {return TAG(val | unit | TAG_SET, (DWORD)(x));}	\
	inline TAG GET_##name(type __far &x) {return TAG(val | unit | TAG_GET, (DWORD)(&x));}	\
	inline TAG QRY_##name(BOOL __far &x) {return TAG(val | unit | TAG_QRY, (DWORD)(&x));}	\
	inline type VAL_##name(TAG __far * tag) {return (type)(tag->data);}	\
	inline type FVAL_##name(TAG __far * tags, type def) {return (type)(FilterTags(tags, val | unit | TAG_GET, (DWORD)def));}	\
	inline type __far & REF_##name(TAG __far * tag) {return *(type __far *)(tag->data);}	\
	typedef type TTYPE_##name;	\
	static const DWORD CSET_##name = val | unit | TAG_SET;	\
	static const DWORD CGET_##name = val | unit | TAG_GET;	\
	static const DWORD CQRY_##name = val | unit | TAG_QRY;

#define MKRTG(name, unit, val, type)	\
	inline TAG SET_##name(type __far &x) {return TAG(val | unit | TAG_SET | TAG_REF, (DWORD)(FPTR)(&x));}	\
	inline TAG GET_##name(type __far &x) {return TAG(val | unit | TAG_GET | TAG_REF, (DWORD)(FPTR)(&x));}	\
	inline TAG QRY_##name(BOOL __far &x) {return TAG(val | unit | TAG_QRY | TAG_REF, (DWORD)(&x));}	\
	inline type VAL_##name(TAG __far * tag) {return *(type __far *)(tag->data);}	\
	inline type __far & REF_##name(TAG __far * tag) {return *(type __far *)(tag->data);}	\
	typedef type TTYPE_##name;	\
	static const DWORD CSET_##name = val | unit | TAG_SET | TAG_REF;	\
	static const DWORD CGET_##name = val | unit | TAG_GET | TAG_REF;	\
	static const DWORD CQRY_##name = val | unit | TAG_QRY | TAG_REF;

#endif

#if UNICODE

struct BoardVersionInfo
	{
	char	boardName[100];
	DWORD	boardVersion;
	};

struct UnicodeBoardVersionInfo
	{
	TCHAR boardName[100];
	DWORD boardVersion;
	};

MKRTG(BOARD_VERSION_UNICODE, MAIN_UNIT, 2, UnicodeBoardVersionInfo)

#else

struct BoardVersionInfo
	{
	char	boardName[100];
	DWORD	boardVersion;
	};

#endif

MKRTG(BOARD_VERSION,						MAIN_UNIT, 1,		BoardVersionInfo)
// 2 is used above!

MKRTG(BOARD_REGION_CODE,				MAIN_UNIT,	0x10,	BYTE)
MKRTG(BOARD_REGION_COUNT,				MAIN_UNIT,	0x11,	WORD)

MKRTG(BOARD_SPLIT_STREAM_SUPPORT,	MAIN_UNIT,	0x20, BOOL)

#if BOARD_HAS_AUTOMOTIVE_DRIVE
MKRTG(DRIVE_HAS_HIGH_TEMPERATURE,	MAIN_UNIT,	0x21, BOOL)
#endif

struct SoftwareVersionInfo
	{
	DWORD softwareVersion, softwareRevision;
	DWORD buildNumber;
	};

MKRTG(SOFTWARE_VERSION,		MAIN_UNIT,	0x30, SoftwareVersionInfo)

//
// Macros for easy access to TAG lists during parsing
//
// GETSET     : Simple get and set of a variable
// GETSETV    : Calls a function when the variable is changed
// GETSETVC   : Like GETSETV, but only calls on real changes
// GETSETC    : Sets a variable "changed" to TRUE when a variable is changed
// GETSETP    : Allows changing only when the virtual unit is passivated
// GETSETCF   : Ors a variable "changed" with a flag when the variable is changed
// GETONLY    : Allows only reading of a value
// GETINQUIRE : Calls an inquire function, the result is to be placed
//              in the pseudo variable "data".
//
// A typical TAG parsing routine will look like this
//
//	Error VirtualMPEGDecoder::Configure(TAG *tags)
//		{
//		PARSE_TAGS_START(tags)
//			GETSETP(MPEG_AUDIO_BITRATE,  params.audioBitRate);
//			GETSETP(MPEG_AUDIO_STREAMID, params.audioStreamID);
//			GETSETP(MPEG_VIDEO_STREAMID, params.videoStreamID);
//			GETSETP(MPEG_VIDEO_WIDTH,    params.videoWidth);
//			GETSETP(MPEG_VIDEO_HEIGHT,   params.videoHeight);
//			GETSETP(MPEG_VIDEO_FPS,      params.videoFPS);
//			GETSETP(MPEG_STREAM_TYPE,    params.streamType);
//
//			GETSET(MPEG_STREAM_HOOK, streamHook);
//
//			GETSETV(MPEG_LEFT_VOLUME,  leftVolume,  GNREASSERT(decoder->SetLeftVolume(leftVolume)));
//			GETSETV(MPEG_RIGHT_VOLUME, rightVolume, GNREASSERT(decoder->SetRightVolume(rightVolume)));
//			GETSETV(MPEG_AUDIO_MUTE,   audioMute,   GNREASSERT(decoder->MuteAudio(audioMute)));
//		PARSE_TAGS_END
//
//		GNRAISE_OK;
//		}
//

#ifndef ONLY_EXTERNAL_VISIBLE

#define PARSE_TAGS_START(tags) \
	TAG __far * tp = tags; \
	while (tp->id) { \
		switch (tp->id) {

#define PARSE_TAGS_END } tp++; }


#define GETSET(tagid, variable)	\
	case CSET_##tagid:	\
		variable = VAL_##tagid(tp);	\
		break;	\
	case CGET_##tagid:	\
		REF_##tagid(tp) = variable; \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define GETSETV(tagid, variable, call) \
	case CSET_##tagid:	\
		variable = VAL_##tagid(tp);	\
		if (GetState() == current) {call;} \
		break;	\
	case CGET_##tagid:	\
		REF_##tagid(tp) = variable; \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define GETSETVD(tagid, variable1, variable2, call) \
	case CSET_##tagid:	\
		variable1 = VAL_##tagid(tp);	\
		variable2 = VAL_##tagid(tp);	\
		if (GetState() == current) {call;} \
		break;	\
	case CGET_##tagid:	\
		GNRAISE(GNR_OBJECT_WRITE_ONLY); \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define SETD(tagid, call) \
	case CSET_##tagid:	\
		GNREASSERT(call(VAL_##tagid(tp))); \
		break;	\
	case CGET_##tagid:	\
		GNRAISE(GNR_OBJECT_WRITE_ONLY); \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define GETD(tagid, call) \
	case CSET_##tagid:	\
		GNRAISE(GNR_OBJECT_READ_ONLY); \
		break;	\
	case CGET_##tagid:	\
		GNREASSERT(call(REF_##tagid(tp))); \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define GETDSETD(tagid, getcall, setcall) \
	case CSET_##tagid:	\
		setcall(VAL_##tagid(tp)); \
		break;	\
	case CGET_##tagid:	\
		getcall(REF_##tagid(tp)); \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break


#define GETSETDV(tagid, variable, call) \
	case CSET_##tagid:	\
		variable = VAL_##tagid(tp);	\
		call; \
		break;	\
	case CGET_##tagid:	\
		REF_##tagid(tp) = variable; \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define SETDVGETDP(tagid, variable, call, puVar) \
	case CSET_##tagid:	\
		variable = VAL_##tagid(tp);	\
		GNREASSERT(call); \
		break;	\
	case CGET_##tagid:	\
		REF_##tagid(tp) = puVar; \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define SETDV(tagid, variable, call) \
	case CSET_##tagid:	\
		variable = VAL_##tagid(tp);    \
		call; \
		break;	\
	case CGET_##tagid:	\
		GNRAISE(GNR_OBJECT_WRITE_ONLY); \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define SETDDV(tagid, variable1, variable2, call) \
	case CSET_##tagid:	\
		variable1 = VAL_##tagid(tp);    \
		variable2 = VAL_##tagid(tp);    \
		call; \
		break;	\
	case CGET_##tagid:	\
		GNRAISE(GNR_OBJECT_WRITE_ONLY); \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define GETSETVC(tagid, variable, call) \
	case CSET_##tagid:	\
		if (variable != VAL_##tagid(tp)) {	\
			variable = VAL_##tagid(tp);	\
			if (GetState() == current) {call;} }	\
		break;	\
	case CGET_##tagid:	\
		REF_##tagid(tp) = variable; \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define GETSETC(tagid, variable) \
	case CSET_##tagid:	\
		if (VAL_##tagid(tp) != variable) { \
			variable = VAL_##tagid(tp);	\
			changed = TRUE; } \
		break;	\
	case CGET_##tagid:	\
		REF_##tagid(tp) = variable; \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define GETSETCF(tagid, variable, flag) \
	case CSET_##tagid:	\
		if (VAL_##tagid(tp) != variable) { \
			variable = VAL_##tagid(tp);	\
			changed |= flag; } \
		break;	\
	case CGET_##tagid:	\
		REF_##tagid(tp) = variable; \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define GETSETP(tagid, variable)	\
	case CSET_##tagid:	\
		if (GetState() != passive) GNRAISE(GNR_INVALID_CONFIGURE_STATE); \
		variable = VAL_##tagid(tp);	\
		break;	\
	case CGET_##tagid:	\
		REF_##tagid(tp) = variable; \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define GETONLY(tagid, variable) \
	case CSET_##tagid:	\
		GNRAISE(GNR_OBJECT_READ_ONLY);	\
		break;	\
	case CGET_##tagid:	\
		REF_##tagid(tp) = variable;	\
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define GETC(tagid, call) \
	case CSET_##tagid:	\
		GNRAISE(GNR_OBJECT_READ_ONLY);	\
		break;	\
	case CGET_##tagid:	\
		if (GetState() == current) \
			GNREASSERT(call(REF_##tagid(tp))); \
		else	\
			GNRAISE(GNR_INVALID_CONFIGURE_STATE); \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define GETINQUIRE(tagid, inquire)	\
	case CSET_##tagid:	\
		GNRAISE(GNR_OBJECT_READ_ONLY);	\
	case CGET_##tagid:	\
		{	\
		TTYPE_##tagid __far &data = REF_##tagid(tp);	\
		inquire	\
		}	\
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define BUILD_TAGS_START(num)	\
	{TAG list[num]; TAG __far * ntp = list;

#define BUILD_TAGS_ADD(tag)	\
	*ntp++ = tag;

#define BUILD_TAGS_END(callee)	\
	*ntp++ = TAGDONE;	\
	GNREASSERT(callee->Configure(list));}

#define FILTER_TAGS_ADD(tagid)	\
	case CSET_##tagid:	\
	case CGET_##tagid:	\
	case CQRY_##tagid:	\
		*ntp++ = *tp;	\
		break;

#define FILTER_TAGS_IF(condition, tagid)	\
	case CSET_##tagid:	\
	case CGET_##tagid:	\
	case CQRY_##tagid:	\
		if (condition)	\
			*ntp++ = *tp;	\
		break;

// This macro short-cuts the typical case of setting and getting a simple
// variable via tags in the implementation of Configure() functions. Note
// that it sets a BOOL variable "changed" when a parameter is set.

#define TAG_CASE(name, var)  \
	case CSET_##name:  var = VAL_##name(tp);  changed = TRUE;  break;  \
	case CGET_##name:  REF_##name(tp) = var;  break;  \
	case CQRY_##name:  QRY_TAG(tp) = TRUE;    break;

#endif

#ifndef ONLY_EXTERNAL_VISIBLE

class TagClass {
	public:
		virtual Error Configure(TAG __far * tags) {GNRAISE_OK;}
		Error __cdecl ConfigureTags (TAG tag, ...);
	};

class TagFilter {
	protected:
		TAG	*	list;
		TAG	*  ntp;

		int 		size;
		int		num;

		virtual Error InternalStart(int size)
			{
			if (!list)
				{
				this->size = size;
				list = new TAG[size];
				}
			else if (this->size < size)
				{
				delete[] list;
				this->size = size;
				list = new TAG[size];
				}

			this->num = 0;
			ntp = list;

			GNRAISE_OK;
			}

		virtual Error InternalAdd(TAG tag) {*ntp++ = tag; GNRAISE_OK;}
		virtual Error InternalDone(void) {return InternalAdd(TAGDONE);}
	public:
		virtual Error Start(int size = 100) {return InternalStart(size);}
		virtual Error Add(TAG tag) {return InternalAdd(tag);}
		virtual Error Done(void) {return InternalDone();}

		operator TAG * (void) {return list;}
	};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\pspages.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:      library\common\pspages.h
// AUTHOR:    S. Herr
// COPYRIGHT: (c) 1996 VIONA Development GmbH.  All Rights Reserved.
// CREATED:   07.11.96
//
// PURPOSE:   Class for common Property Sheet Pages and such for use in Device Manager (Control Panel)
//
// HISTORY:


// Remarks:
//
// You need to add two include paths: 1) to the "inc16" directory of the Windows 95 DDK
//                                    2) to the "include" directory of the Win32 SDK (in that order)
//
// Do not use the standard MSVC include paths!
//
// You also must link the following two lib files from the Windows 95 DDK (or add them to the linker settings):
//
//     setupx.lib
//     commctrl.lib
//
// The constructors need not only the resource ID of the dialog template, but also a special "titleResID".
// For property sheet pages of "PropertySheetPage" type, it is the ID of the small (16x16) icon to appear in
// the page's title.
// For "DevManPropertySheetPage"s it is the first of three consecutive resource IDs:
//
//     1) IDI_TITLE (like for "PropertySheetPage")
//     2) IDI_CLASS_ICON = IDI_TITLE + 1 (ID of icon in the dialog template that identifies the class type)
//     3) IDC_DEVICE_NAME = IDI_TITLE + 2 (ID of device name text in the dialog template).


#ifndef PSPAGES_H
#define PSPAGES_H

#define STRICT

#define WINVER 0x0400

#include <windows.h>
#include <windowsx.h>
#include <winerror.h>		// Comes from the Win32SDK!
extern "C"						// Necessary to correctly link setupx functions.
{
#include <setupx.h>
}

// Prevents inclusion of <stdlib.h>
#include "library\common\gnerrors.h"

class PropertySheetPage
	{
	private:
		friend BOOL FAR PASCAL __loadds DialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
		friend UINT FAR PASCAL __loadds PageCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE page);
	protected:
		HINSTANCE		hinst;
		HPROPSHEETPAGE	hPage;
		int				count;
		int				resourceID;
		int				titleResID;
		HWND				hDlg;				// Handle that is sent with the DialogProc(), should be accessed in the message
												// and notification handlers only.

		virtual BOOL	DialogProc (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

		// Message handlers
		virtual LRESULT OnInitDialog(void) {return 0;}
		virtual LRESULT OnCommand(int idItem, HWND hWndCtrl, WORD notifyCode) {return 0;}
		virtual LRESULT OnNotify(int idFrom, LPNMHDR lpnmhdr);
		virtual LRESULT OnClose() {return 0;}
		virtual LRESULT OnDestroy() {return 0;}
		virtual LRESULT OnVScroll(WORD code, HWND hWndCtrl, int pos) {return 0;}
		virtual LRESULT OnHScroll(WORD code, HWND hWndCtrl, int pos) {return 0;}

		// Property Sheet Page Notification handlers
		virtual LRESULT OnPSNSetActive(LPNMHDR lpnmhdr) {return 0;}
		virtual LRESULT OnPSNKillActive(LPNMHDR lpnmhdr) {return 0;}
		virtual LRESULT OnPSNQueryCancel(LPNMHDR lpnmhdr) {return FALSE;}
		virtual LRESULT OnPSNApply(LPNMHDR lpnmhdr) {return PSNRET_NOERROR;}
		virtual LRESULT OnPSNReset(LPNMHDR lpnmhdr) {return FALSE;}
		virtual LRESULT OnPSNHelp(LPNMHDR lpnmhdr) {return FALSE;}

	public:
		PropertySheetPage(HINSTANCE hinst, int resourceID, int titleResID)
			{this->hinst = hinst; this->resourceID = resourceID; this->titleResID = titleResID; hPage = NULL; count = 0;}

      virtual ~PropertySheetPage(void) {}

		Error CreatePage(void);
		Error DestroyPage(void);
	};

class DevManPropertySheetPage : public PropertySheetPage
	{
	private:
		LPFNADDPROPSHEETPAGE	AddPageProc;
		LPARAM 					lParam;

		HICON						classIcon;

	protected:
		LPDEVICE_INFO			deviceInfo;

		LRESULT OnInitDialog(void);						// Call this from any successor if you want to get the class icon
																	// and device name automatically (IDI_CLASS_ICON and IDC_DEVICE_NAME).
	public:
		DevManPropertySheetPage(HINSTANCE				hinst,
										int 						resourceID,
										int						titleResID,
										LPDEVICE_INFO			deviceInfo,
		 								LPFNADDPROPSHEETPAGE	AddPageProc,
		 								LPARAM					lParam);

		Error AddPage(void);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\viddebug.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\viddebug.h
// AUTHOR:    Martin Stephan
// COPYRIGHT: (c) 1999 VIONA Development GmbH. All Rights Reserved.
// CREATED:   28.07.99
//
// PURPOSE:   Debug related definitions for video miniport drivers and display drivers
//
// HISTORY:
//

#ifndef VIDDEBUG_H
#define VIDDEBUG_H

#if DBG!=0
#ifndef _DEBUG
#define _DEBUG
#endif
#endif

#if _DEBUG

#if DISPLAY_DRIVER
#define DP(arg) EngDebugPrint(0, arg, 0)
#elif VIDEO_MINIPORT_DRIVER
#define DP(arg) VideoDebugPrint(arg)
#endif

#else

#define DP(arg)

#endif


#endif //VIDDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\vddebug.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\vddebug.h
// AUTHOR:    Viona
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   04.12.96
//
// PURPOSE:
//
// HISTORY:
//
#ifndef _VDDEBUG_
#define _VDDEBUG_

#include "library/common/gnerrors.h"


#if LINUX
#include <stdio.h>
#include "library/common/prelude.h"
#define _export    /* FN: should be corrected in prelude.h.. */
#endif

void __cdecl MDebugPrint(const TCHAR * szFormat, ...);
#define RDP MDebugPrint

#if _DEBUG
	#ifdef _PROPTEST
		extern Error Print(const TCHAR __far * szFormat, ...);
		#define DP Print
	#elif NT_KERNEL
		#define DP DbgPrint("\n"), DbgPrint
	#elif VXD_VERSION
		void _cdecl DebugPrint(char * szFormat, ...);
		#define DP DebugPrint
	#elif LINUX
		void DebugPrint (const TCHAR * szFormat, ...);	// standard prototype for debug output
		#define DP DebugPrint
		#define DPF printf
		void DebugPrintRecord (const TCHAR * szFormat, ...);	// standard prototype for debug output
		#define DPR DebugPrintRecord
		void InitializeDebugRecording (void);
		void GetDebugRecordingParameters (BYTE * & array, int & size);
	#elif _DOS
		#define DP printf   // note: output should really go to stderr instead of stdout
#else
		void FAR __cdecl DebugPrint(const TCHAR __far * szFormat, ...);	// standard prototype for debug output
		#define DP DebugPrint
		#define DPF DebugPrint
	#endif
#else
	#ifdef _PROPTEST
		extern Error Print(const TCHAR __far * szFormat, ...);
		#define DP Print
	#elif NT_KERNEL
		inline void __cdecl DebugPrintEmpty(const char __far * szFormat, ...) {}		// empty function (optimized to nothing)
		#define DP while(0) DebugPrintEmpty
	#elif LINUX
		inline void DebugPrintEmpty(const TCHAR * szFormat, ...) {}		// empty function (optimized to nothing)
		#define DP while(0) DebugPrintEmpty
		#define DPF while(0) DebugPrintEmpty
		#define DPR while(0) DebugPrintEmpty
		inline void InitializeDebugRecording (void) {}
		inline void GetDebugRecordingParameters (BYTE * & array, int & size) {array=NULL; size=0;}
#else
		inline void __cdecl DebugPrintEmpty(const TCHAR __far * szFormat, ...) {}		// empty function (optimized to nothing)
		#define DP while(0) DebugPrintEmpty
		#define DPF DP
	#endif
#endif

//
//  Define breakpoint
//

#ifdef _DEBUG

#if NT_KERNEL
#define BREAKPOINT		DbgBreakPoint();
#else
#define BREAKPOINT		__asm int 3
#endif

#else

#define BREAKPOINT		while (0)

#endif // _DEBUG


#if !UPDATE_UTILITY_BUILD
#define DEBUG__(x)		x
#else
#define DEBUG__(x)
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\TagUnits.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


// FILE:      library\common\tagunits.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   24.03.95
//
// PURPOSE: The tag units.
//
// HISTORY:

#ifndef TAGUNITS_H
#define TAGUNITS_H

#include "Tags.h"

MKTAGUNIT(PIP_UNIT,            0)
MKTAGUNIT(VIDEO_ENCODER_UNIT,  1)
MKTAGUNIT(VIDEO_DECODER_UNIT,  2)
MKTAGUNIT(MPEG_DECODER_UNIT,   3)
MKTAGUNIT(TV_TUNER_UNIT,       4)
MKTAGUNIT(AUDIO_MIXER_UNIT,    5)
MKTAGUNIT(AUDIO_DECODER_UNIT,  6)
MKTAGUNIT(AUDIO_ENCODER_UNIT,  7)
MKTAGUNIT(JPEG_CODEC_UNIT,     8)
MKTAGUNIT(OSD_UNIT,				 9)
MKTAGUNIT(PANEL_UNIT,         10)
MKTAGUNIT(COMMUNICATION_UNIT, 11)
// DO NOT USE 12 or 13 due to contention with tag type
MKTAGUNIT(MPEG_ENCODER_UNIT,  14)

#define VIDEO_CHIP_UNIT			(VIDEO_ENCODER_UNIT | VIDEO_DECODER_UNIT)
#define AUDIO_STREAMDEV_UNIT	(AUDIO_ENCODER_UNIT | AUDIO_DECODER_UNIT)

#define NUM_UNITS		12

#ifndef ONLY_EXTERNAL_VISIBLE

// Only internally used tag units
MKITAGUNIT(AUDIO_DAC_UNIT,			1)
MKITAGUNIT(STEREO_DECODER_UNIT,	2)
MKITAGUNIT(VIDEO_DEVICE_UNIT,		3)
MKITAGUNIT(PLL_UNIT,				   4)


#endif // external visible

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\vddebug.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\vddebug.cpp
// AUTHOR:    Viona
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   04.12.96
//
// PURPOSE:
//
// HISTORY:
//
#include <xtl.h>

#include "vddebug.h"

#if LINUX
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#endif



#if   LINUX

void DebugPrint(const TCHAR * szFormat, ...)
	{
	TCHAR buff[256];
	int fd;

  	sprintf(buff,szFormat,(&szFormat)[1], (&szFormat)[2], (&szFormat)[3], (&szFormat)[4]);
  	strcat(buff, "\n");
	/* FN: my hack to get debug output to something sort-of fast - the ttys */
	/* are rather low-overhead, me thinks.. */
	fd = open("/tmp/CINELOG", O_CREAT | O_RDWR | O_APPEND, S_IRWXU);
	write(fd, buff, strlen(buff));
	close(fd);
	}



#elif !VXD_VERSION

// Print debug string to DebugWin. Formatted output is possible.
void __cdecl DebugPrint(const TCHAR __far * szFormat, ...)
	{
	TCHAR buff[256];

  	wvsprintf(buff,szFormat,(char __far *)(&szFormat+1));
  	_fstrcat(buff, __TEXT("\r\n"));
  	::OutputDebugString(buff);
	}

void __cdecl MDebugPrint(const TCHAR * szFormat, ...)
	{
	TCHAR buff[256];

  	::wvsprintf(buff,szFormat,(char __far *)(&szFormat+1));
  	_fstrcat(buff, __TEXT("\r\n"));
  	::OutputDebugString(buff);
	}



#else

void _cdecl DebugPrint(char * szFormat, ...)
	{
	static char buff[256];

	_Sprintf(buff, szFormat, (&szFormat)[1], (&szFormat)[2], (&szFormat)[3], (&szFormat)[4] );
	Out_Debug_String(buff);
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\VirtUnit.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\virtunit.h
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   30.03.95
//
// PURPOSE:   Virtual and physical units
//
// A physical unit represents a shared physical hardware or software
// resource.  Several virtual units try to use the same resource at a time,
// but only one gets access.
//
// When a virtual unit requests access, but the physical unit is currently
// busy by an other virtual unit, the previous unit gets preempted.  The
// virtual units are responsible for storing the current state of the
// physical unit, so it can be reactivated, when the virtual unit gets in
// charge again.
//
// A virtual unit may prevent preemption by two means, first by locking
// the physical unit or second by returning FALSE to inquisitive calls.
//
// A virtual unit may be in any of (3/2) states:
//
//    Generalstate: passive  P the virtual unit does not compete
//                  active   A the virtual unit is currently preempted
//                  current  C the virtual unit owns the physical unit
//
//    Lockstate:    unlocked U the physical unit is not locked by this
//                             virtual unit
//                  locked   L the physical unit is currently locked
//                             by this virtual unit
//
//
// State transition:
// none or (s) : success, (f) : failed
//
// Initial Transition    Final   Actions performed
// State                 state
// ---------------------------------------------------------------------------
// PU      Lock(s)       PL      current->PreparePreempt() -> OK
//         Lock(f)       PU      current->PreparePreempt() -> FAIL
//         Activate(s)   CU      current->MayPreempt() -> OK
//                               current->IsPreempted()
//                               IsActivated()
//                               IsScheduled()
//                               Preempt(current)
//         Activate(f)   AU      current->MayPreempt() -> FAIL
//                               IsActivated()
//
// PL      Lock          PL
//         Unlock        PU      current->UnpreparePreempt()
//         Activate      CL      current->IsPreempted()
//                               IsActivated()
//                               IsScheduled()
//                               Preempt(current)
//
// AU      Lock(s)       AL      current->PreparePreempt() -> OK
//         Lock(f)       AU      current->PreparePreempt() -> FAIL
//         Activate(s)   CU      current->MayPreempt() -> OK
//                               current->IsPreempted()
//                               IsScheduled()
//                               Preempt(current)
//         Activate(f)   AU      current->MayPreempt() -> FAIL
//         Passivate     PU      IsPassivated()
//
// AL      Lock          AL
//         Unlock        AU      current->UnpreparePreempt()
//         Activate      CL      current->IsPreempted()
//                               IsScheduled()
//                               Preempt(current)
//         Passivate     PL      IsPassivated()
//
// CU      Lock(s)       CL
//         Lock(f)       CU
//         Passivate     PU      IsPreempted()
//                               IsPassivated()
//                               new->IsScheduled()
//                               new->Preempt(this)
//
// CL      Unlock        CU
//         Passivate     PL      IsPreempted()
//                               IsPassivated()
//                               new->IsScheduled()
//                               new->Preempt(this)
//
//
// Activation/Passivation sequence for preemptable use:
//
//   Activate()
//   ....
//   Passivate()
//
// Activation/Passivation sequence for nonpreemptable use:
//
//   Lock()
//   Activate()
//   ....
//   Unlock()
//   Passivate()
//
// To nonpreemptably lock a sequence of units, you need a two phase protocol:
//
//   if (!IS_ERROR(unit1->Lock()))
//     if (!IS_ERROR(unit2->Lock()))
//        if (!IS_ERROR(unit3->Lock()))
//          {
//          unit1->Activate(); // must succeed
//          unit2->Activate();
//          unit3->Activate();
//          ...
//          unit1->Unlock();
//          unit2->Unlock();
//          unit3->Unlock();
//          unit1->Passivate();
//          unit2->Passivate();
//          unit3->Passivate();
//          }
//        else
//          {
//          unit2->Unlock();
//          unit1->Unlock();
//          }
//      else
//        unit1->Unlock;
//
//
// HISTORY:
//
//

#ifndef VIRTUNIT_H
#define VIRTUNIT_H

#include "prelude.h"
#include "gnerrors.h"
#include "Tags.h"
#ifndef ONLY_EXTERNAL_VISIBLE
#include "library/general/Lists.h"
#endif

#define GNR_CAN_NOT_PASSIVATE_IDLE_UNIT			MKERR(ERROR,	UNITS,	OBJECT,	0x01)

#define GNR_OBJECT_NOT_CURRENT						MKERR(ERROR,	UNITS,	OBJECT,	0x02)

#define GNR_OBJECT_ALREADY_JOINED					MKERR(ERROR,	UNITS,	OBJECT,	0x03)

#define GNR_UNITS_BUSY									MKERR(ERROR,	UNITS,	BUSY,		0x04)

#define GNR_INVALID_UNITS								MKERR(ERROR,	UNITS,	PARAMS,	0x05)

#ifndef ONLY_EXTERNAL_VISIBLE

class VirtualUnit;

class PhysicalUnit : public TagClass
	{
	friend class VirtualUnit;
	private:
		VirtualUnit *	current;
		VirtualUnit	*	lockedBy;
		VirtualUnit *	old, * rep;

		enum {preemptNone, preemptInitial, preemptStopped, preemptChanged, preemptComplete} preemptState;

		List				preempted;
		int				lockCnt;

		Error InternalActivate(VirtualUnit * unit);
		BOOL InternalMayPreempt(VirtualUnit * unit);

		Error InternalPreemptBegin(VirtualUnit * unit);

		Error InternalPreemptStopPrevious(void);
		Error InternalPreemptChange(void);
		Error InternalPreemptStartNew(void);

		Error InternalPreemptComplete(void);

		void InternalPreemptFail(void);

		Error InternalPassivate(VirtualUnit * unit);
	public:
		PhysicalUnit(void);
		virtual ~PhysicalUnit(void);

		//
		// A successful lock implies no problem with the
		// current unit during a later activation.
		//
		virtual Error Lock(VirtualUnit * unit);
		virtual Error Unlock(VirtualUnit * unit);

		virtual Error Activate(VirtualUnit * unit);
		virtual Error Passivate(VirtualUnit * unit);

		virtual VirtualUnit * CreateVirtual(void) = 0;

		virtual Error Initialize(void) {GNRAISE_OK;}
		virtual Error ReInitialize(void) {GNRAISE_OK;}

		VirtualUnit * GetCurrent(void) {return current;}
	};

class VirtualUnit : public TagClass, Node
	{
	friend class PhysicalUnit;
	public:
		enum State {passive, active, current};
	private:
		PhysicalUnit *	physical;
		State			 	state;

		BOOL				preemptVisited;

		VirtualUnit	 * predLink, * succLink;

		int				useCount;
	protected:
		//
		// the one for parameter only devices
		//
		virtual Error Preempt(VirtualUnit * previous);

      virtual Error PreemptStopPrevious(VirtualUnit * previous) {GNRAISE_OK;}
      virtual Error PreemptChange(VirtualUnit * previous) {return Preempt(previous);}
      virtual Error PreemptStartNew(VirtualUnit * previous) {GNRAISE_OK;}

		//
		// Positive response to PreparePreempt implies
		// positive response on may preempt at any time
		// until Preempt or UnpreparePreempt.
		//
		virtual BOOL PreparePreempt(void) {return TRUE;}
		virtual void UnpreparePreempt(void) {;}

      virtual BOOL MayPreempt(void) {return TRUE;}
		virtual Error IsPreempted(void) {GNRAISE_OK;}
		virtual Error IsScheduled(void) {GNRAISE_OK;}
		virtual Error IsActivated(void) {GNRAISE_OK;}
		virtual Error IsPassivated(void) {GNRAISE_OK;}

	public:
		VirtualUnit(PhysicalUnit *	physical);
		virtual ~VirtualUnit(void);

		PhysicalUnit *	GetPhysical (void) {return physical;}

		Error Activate(void);
		Error Passivate(void);

		Error Lock(void);
		Error Unlock(void);

		Error Join(VirtualUnit * unit);
		Error Split(VirtualUnit * unit);

		State GetState(void) {return state;}

		void Obtain() {useCount++;}
		void Release() {useCount--;if (!useCount) {Passivate(); delete this;}}
	};


#define PREEMPT_START(type)	\
	{ type *	p = (type *)previous;	\

#define PREEMPT_END	}

#define PREEMPT_UPDATE(param, update)	\
	if (!p || p->param != param) update;

#endif // External visible

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\WINPORTS.H ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\winports.h
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   22.03.95
//
// PURPOSE:   Class for windows as ports.
//
// HISTORY:
//

#ifndef WINPORTS_H
#define WINPORTS_H

#include "library\common\prelude.h"

////////////////////////////////////////////////////////////////////
//
//  Some defines
//
////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////
//
//  Generic Message Port Class
//
////////////////////////////////////////////////////////////////////

class GenericMsgPort
	{
	public:
		// Send a message to the port and return immediately. The result is TRUE for success.
		virtual BOOL SendMessage (WPARAM wParam, LPARAM lParam) = 0;
		virtual BOOL SendMessageIfQueueEmpty (WPARAM wParam, LPARAM lParam) = 0;

		// Send a message to the port and wait until it has been processed.
		virtual void DoMessage (WPARAM wParam, LPARAM dParam) = 0;

		// Schedule a message to be posted after some delay. The call returns immediately.
		// Note that you cannot call this during interrupt.
		virtual void ScheduleTimer (WPARAM wParam, DWORD millisecondDelay) = 0;

		// Cancel any delayed message.
		virtual void CancelTimer (void) = 0;

		// Remove all messages from the queue.
		virtual void FlushMessages (void) = 0;
	};

#ifndef ONLY_EXTERNAL_VISIBLE

#include "library\common\krnlsync.h"

////////////////////////////////////////////////////////////////////
//
//  ST20 WinPort Classes
//
////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////
//
//  Windows WinPorts
//
////////////////////////////////////////////////////////////////////



//
//  WinPortServer
//

class EventPortMessage;
class EventPort;

class WinPortServer
	{
	friend class EventPort;
	friend class EventPortWorkerThread;
	protected:
		EventPortMessage	*	messages;
		EventPortMessage	*	timeMessages;
		HANDLE					event;
		VDLocalMutex			lock;
		bool						terminate;

		void EnterQueueHead(EventPortMessage * & queue, EventPortMessage * message);
		void EnterQueueTime(EventPortMessage * & queue, EventPortMessage * message);
		EventPortMessage * GetQueuePort(EventPortMessage * & queue, EventPort * port);
		EventPortMessage * PeekQueueHead(EventPortMessage * queue);
		EventPortMessage * GetQueueHead(EventPortMessage * & queue);

	public:
		WinPortServer(void);
		~WinPortServer(void);

		BOOL ProcessMessages(void);

		BOOL SendMessage(EventPort * port, WPARAM wParam, LPARAM lParam, HANDLE event = NULL);
		void ScheduleTimer(EventPort * port, WPARAM wParam, DWORD delay);
		void CancelTimer(EventPort * port);

		void FlushMessages(EventPort * port);
	};




//
//  WinPortWorkerThread
//

class EventPort : public GenericMsgPort
	{
	protected:
		WinPortServer *	server;
		VDLocalMutex		lock;
		HANDLE				event;
		void InternalMessage(WPARAM wParam, LPARAM lParam);
	public:
		EventPort(WinPortServer * server);
		virtual ~EventPort(void);

		//
		// Send a message to the port.
		//
		BOOL SendMessage(WPARAM wParam, LPARAM lParam);
		BOOL SendMessageIfQueueEmpty (WPARAM wParam, LPARAM lParam);
		void DoMessage(WPARAM wParam, LPARAM dParam);

		void ScheduleTimer(WPARAM wParam, DWORD delay);
		void CancelTimer(void);

		//
		// Method, that receives incoming messages asynchronously.
		//
		virtual void Message(WPARAM wParam, LPARAM lParam) = 0;

		void FlushMessages(void);

		void ClosePort(void);

		HWND GetHWND(void) {return NULL;}
	};

class EventPortWorkerThread : protected WinPortServer
	{
	friend class WorkerThreadEventPort;
	friend DWORD WINAPI EventWorkerThreadEntry(void * param);
	protected:
		EventPort	*	port;
		HANDLE			workerThread;

		void ThreadEntry(void);
	public:
		EventPortWorkerThread(WinPortServer * server, int priority);
		virtual ~EventPortWorkerThread(void);

		BOOL SendWorkMessage(WPARAM wParam, LPARAM lParam) {return port->SendMessage(wParam, lParam);}
		void DoWorkMessage(WPARAM wParam, LPARAM lParam) {port->DoMessage(wParam, lParam);}

		virtual void WorkMessage(WPARAM wParam, LPARAM lParam) = 0;

		void FlushWorkMessages(void) {port->FlushMessages();}

		void TerminateWorker(void);

		HWND GetHWND(void) {return NULL;}

		GenericMsgPort * GetPort(void) {return port;}
	};



typedef EventPort						WinPort;
typedef EventPortWorkerThread		WinPortWorkerThread;


#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\WinPorts.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\winports.h
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   22.03.95
//
// PURPOSE:   Class for windows as ports
//
// HISTORY:
//
//

#include "winports.h"
#include "library/common/prelude.h"
#include "library/common/vddebug.h"
#include "library/lowlevel/timer.h"

////////////////////////////////////////////////////////////////////
//
//  ST20LITE WinPort Classes
//
////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////
//
//  Windows WinPort Classes
//
////////////////////////////////////////////////////////////////////



//
// Class name
//

static TCHAR PWClassName[] = __TEXT("VDWinPort");

//
// Static class variables, represent the window class
//

////////////////////////////////////////////////////////////////////
//
//  WorkerThreadWinPort Class
//
////////////////////////////////////////////////////////////////////


class EventPortMessage
	{
	public:
		EventPortMessage	*	succ;
		EventPort			*	port;
		WPARAM					wParam;
		LPARAM					lParam;
		DWORD						time;
		HANDLE					event;

		EventPortMessage(EventPort * port, WPARAM wParam, LPARAM lParam, DWORD time, HANDLE event)
			{
			this->port = port;
			this->wParam = wParam;
			this->lParam = lParam;
			this->time = time;
			this->event = event;
			this->succ = NULL;
			}
	};

WinPortServer::WinPortServer(void)
	{
	messages = NULL;
	timeMessages = NULL;
	event = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	terminate = false;
	}

WinPortServer::~WinPortServer(void)
	{
	::CloseHandle(event);
	}

void WinPortServer::EnterQueueHead(EventPortMessage * & queue, EventPortMessage * message)
	{
	if (queue)
		{
		message->succ = queue->succ;
		queue->succ = message;
		queue = message;
		}
	else
		{
		message->succ = message;
		queue = message;
		}
	}

EventPortMessage * WinPortServer::GetQueuePort(EventPortMessage * & queue, EventPort * port)
	{
	EventPortMessage * msg, * rmsg;

	if (queue)
		{
		msg = queue;
		while (msg->succ != queue && msg->succ->port != port)
			{
			msg = msg->succ;
			}
		if (msg->succ->port == port)
			{
			rmsg = msg->succ;
			if (msg->succ == queue)
				{
				if (queue == queue->succ)
					queue = NULL;
				else
					{
					queue = msg;
					msg->succ = msg->succ->succ;
					}
				}
			else
				msg->succ = msg->succ->succ;

			return rmsg;
			}
		else
			return NULL;
		}
	else
		return NULL;
	}

void WinPortServer::EnterQueueTime(EventPortMessage * & queue, EventPortMessage * message)
	{
	EventPortMessage * mq;

	if (queue)
		{
		mq = queue;
		while (mq->succ != queue && mq->succ->time < message->time)
			mq = mq->succ;

		if (mq->succ->time < message->time)
			{
			message->succ = mq->succ;
			mq->succ = message;
			}
		else
			{
			message->succ = queue->succ;
			queue->succ = message;
			queue = queue->succ;
			}
		}
	else
		{
		message->succ = message;
		queue = message;
		}
	}

EventPortMessage * WinPortServer::PeekQueueHead(EventPortMessage * queue)
	{
	if (queue)
		{
		return queue->succ;
		}
	else
		return NULL;
	}

EventPortMessage * WinPortServer::GetQueueHead(EventPortMessage * & queue)
	{
	EventPortMessage * message;

	if (queue)
		{
		message = queue->succ;

		if (queue->succ != queue)
			{
			queue->succ = queue->succ->succ;
			}
		else
			{
			queue = NULL;
			}

		return message;
		}
	else
		return NULL;
	}

BOOL WinPortServer::ProcessMessages(void)
	{
	HANDLE	events[1];
	DWORD		result;
	DWORD		time;
	EventPortMessage *	message;

	events[0] = event;
	while (!terminate)
		{
		lock.Enter();
		time = Timer.GetMilliTicks();
		message = PeekQueueHead(timeMessages);
		while (message && time >= message->time)
			{
			GetQueueHead(timeMessages);
			lock.Leave();
			message->port->Message(message->wParam, message->lParam);
			delete message;
			lock.Enter();
			time = Timer.GetMilliTicks();
			message = PeekQueueHead(timeMessages);
			}

		if (message)
			time = message->time - time;
		else
			time = INFINITE;

		message = PeekQueueHead(messages);
		while (message)
			{
			GetQueueHead(messages);
			lock.Leave();
			message->port->Message(message->wParam, message->lParam);
			if (message->event) ::SetEvent(message->event);
			delete message;
			lock.Enter();
			message = PeekQueueHead(messages);
			}
		lock.Leave();
		result = WaitForMultipleObjects(1, events, FALSE, time);
		}

	return TRUE;
	}

BOOL WinPortServer::SendMessage(EventPort * port, WPARAM wParam, LPARAM lParam, HANDLE event)
	{
	lock.Enter();
	EnterQueueHead(messages, new EventPortMessage(port, wParam, lParam, 0, event));
	::SetEvent(this->event);
	lock.Leave();

	return TRUE;
	}

void WinPortServer::ScheduleTimer(EventPort * port, WPARAM wParam, DWORD delay)
	{
	lock.Enter();
	CancelTimer(port);
	EnterQueueTime(timeMessages, new EventPortMessage(port, wParam, 0, Timer.GetMilliTicks() + delay, NULL));
	::SetEvent(this->event);
	lock.Leave();
	}

void WinPortServer::CancelTimer(EventPort * port)
	{
	EventPortMessage * message;

	lock.Enter();
	while (message = GetQueuePort(timeMessages, port))
		delete message;
	lock.Leave();
	}


void WinPortServer::FlushMessages(EventPort * port)
	{
	EventPortMessage * message;

	lock.Enter();
	while (message = GetQueuePort(timeMessages, port))
		delete message;
	while (message = GetQueuePort(messages, port))
		delete message;
	lock.Leave();
	}

void EventPort::InternalMessage(WPARAM wParam, LPARAM lParam)
	{
	Message(wParam, lParam);
	}

EventPort::EventPort(WinPortServer * server)
	{
	this->server = server;
	event = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	}

EventPort::~EventPort(void)
	{
	FlushMessages();
	CloseHandle(event);
	}

BOOL EventPort::SendMessage(WPARAM wParam, LPARAM lParam)
	{
	return server->SendMessage(this, wParam, lParam);
	}

BOOL EventPort::SendMessageIfQueueEmpty (WPARAM wParam, LPARAM lParam)
	{
	return server->SendMessage(this, wParam, lParam);
	}

void EventPort::DoMessage(WPARAM wParam, LPARAM lParam)
	{
	lock.Enter();
	if (server->SendMessage(this, wParam, lParam, event))
		::WaitForSingleObject(event, INFINITE);
	lock.Leave();
	}

void EventPort::ScheduleTimer(WPARAM wParam, DWORD delay)
	{
	server->ScheduleTimer(this, wParam, delay);
	}

void EventPort::CancelTimer(void)
	{
	server->CancelTimer(this);
	}

void EventPort::FlushMessages(void)
	{
	server->FlushMessages(this);
	}

void EventPort::ClosePort(void)
	{
	FlushMessages();
	}

//////////////////////////////////////////////////////////////

class WorkerThreadEventPort : public EventPort
	{
	protected:
		EventPortWorkerThread	*	thread;
	public:
		WorkerThreadEventPort(EventPortWorkerThread * thread)
			: EventPort(thread)
			{
			this->thread = thread;
			}

		void Message(WPARAM wParam, LPARAM lParam)
			{
			thread->WorkMessage(wParam, lParam);
			}
	};

static DWORD WINAPI EventWorkerThreadEntry(void * param)
	{
	((EventPortWorkerThread *)param)->ThreadEntry();

	return 0;
	}


void EventPortWorkerThread::ThreadEntry(void)
	{
	ProcessMessages();
	}

EventPortWorkerThread::EventPortWorkerThread(WinPortServer * server, int priority)
	{
	DWORD id;

	port = new WorkerThreadEventPort(this);

	workerThread = CreateThread(NULL, 100000, EventWorkerThreadEntry, this, 0, &id);
	SetThreadPriority(workerThread, priority);
	}

EventPortWorkerThread::~EventPortWorkerThread(void)
	{
	TerminateWorker();
	}

void EventPortWorkerThread::TerminateWorker(void)
	{
	if (port)
		{
		terminate = true;
		::SetEvent(event);
		WaitForSingleObject(workerThread, INFINITE);
		CloseHandle(workerThread);
		workerThread = NULL;
		delete port;
		port = NULL;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\generic\ac3mix.h ===
// FILE:			library\hardware\audio\generic\ac3mix.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1996 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		20.11.1996
//
// PURPOSE:		Defintions for common Dolby-AC3 capable mixers.
//
// HISTORY:

#ifndef AC3MIX_H
#define AC3MIX_H

#include "audmix.h"
#include "ac3setup.h"

// Additional flags for Direct Tag Change Hook Messages
#define DTCM_CHANGED_GENERAL_AC3				0x01000000		// General AC3 settings were changed

// Input specific flags for DTC Hook Messages
#define DTCM_CHANGED_INPUTS_GENERAL_AC3	0x10000000		// General AC3 settings for input were changed

//
// Extended AC3 / ProLogic input Capabilities
//

#define INPUT_AC3						0x01000000		// The input can carry AC3 surround sound.
#define INPUT_PROLOGIC				0x02000000		// The input can carry ProLogic surround sound.

//
// Tags to control the AC3 setup. Direct tags, only to be called from mixing applications.
//

MKTAG (AUDMIX_D_AC3_SPEAKER_CONFIG,					AUDIO_MIXER_UNIT, 0x1000, AC3SpeakerConfig)
MKTAG (AUDMIX_D_AC3_BASS_CONFIG,						AUDIO_MIXER_UNIT, 0x1001, AC3BassConfig)
MKTAG (AUDMIX_D_AC3_SPEAKER_DELAY_CENTER,			AUDIO_MIXER_UNIT, 0x1002, WORD)
MKTAG (AUDMIX_D_AC3_SPEAKER_DELAY_SURROUND,		AUDIO_MIXER_UNIT, 0x1003, WORD)

// AC3 setup tags for individual inputs.

MKTAG (AUDMIX_D_INPUT_AC3_SPEAKER_CONFIG,				AUDIO_MIXER_UNIT, 0x1010, AC3SpeakerConfig)
MKTAG (AUDMIX_D_INPUT_AC3_BASS_CONFIG,					AUDIO_MIXER_UNIT, 0x1011, AC3BassConfig)
MKTAG (AUDMIX_D_INPUT_AC3_SPEAKER_DELAY_CENTER,		AUDIO_MIXER_UNIT, 0x1012, WORD)
MKTAG (AUDMIX_D_INPUT_AC3_SPEAKER_DELAY_SURROUND,	AUDIO_MIXER_UNIT, 0x1013, WORD)

//
// Additional volume tags to control AC3 channels
//

MKTAG (AUDMIX_VOLUME_CENTER,							AUDIO_MIXER_UNIT, 0x1020, WORD)
MKTAG (AUDMIX_VOLUME_SURROUND_LEFT,					AUDIO_MIXER_UNIT, 0x1021, WORD)
MKTAG (AUDMIX_VOLUME_SURROUND_RIGHT,				AUDIO_MIXER_UNIT, 0x1022, WORD)
MKTAG (AUDMIX_VOLUME_SUBWOOFER,						AUDIO_MIXER_UNIT, 0x1023, WORD)

// Direct access versions of the additional volume tags.

MKTAG (AUDMIX_D_VOLUME_CENTER,						AUDIO_MIXER_UNIT, 0x1030, WORD)
MKTAG (AUDMIX_D_VOLUME_SURROUND_LEFT,				AUDIO_MIXER_UNIT, 0x1031, WORD)
MKTAG (AUDMIX_D_VOLUME_SURROUND_RIGHT,				AUDIO_MIXER_UNIT, 0x1032, WORD)
MKTAG (AUDMIX_D_VOLUME_SUBWOOFER,					AUDIO_MIXER_UNIT, 0x1033, WORD)

// The same as above, but for a specific input set with AUDMIX_D_INPUT_SELECT
MKTAG (AUDMIX_D_INPUT_VOLUME_CENTER,				AUDIO_MIXER_UNIT, 0x1034, WORD)
MKTAG (AUDMIX_D_INPUT_VOLUME_SURROUND_LEFT,		AUDIO_MIXER_UNIT, 0x1035, WORD)
MKTAG (AUDMIX_D_INPUT_VOLUME_SURROUND_RIGHT,		AUDIO_MIXER_UNIT, 0x1036, WORD)
MKTAG (AUDMIX_D_INPUT_VOLUME_SUBWOOFER,			AUDIO_MIXER_UNIT, 0x1037, WORD)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\winfix.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000 Ravisent Technologies, Inc.  All Rights Reserved.           //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of Ravisent Technologies, Inc.    //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between Ravisent and Microsoft.  This            //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by Ravisent.  THE ONLY PERSONS   //
// WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS                     //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO RAVISENT, IN THE FORM                 //
// PRESCRIBED BY RAVISENT.                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


// FILE:      library\common\winfix.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1997 Viona Development.  All Rights Reserved.
// CREATED:   29.07.97
//
// PURPOSE: Fixes Windows problems.
//
// HISTORY:

#ifndef WINFIX_H
#define WINFIX_H

#include <windows.h>



// Fixes Rectangle() problem of not working with width or height less than 3.

void FixedRectangle (HDC hdc, int left, int top, int right, int bottom);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\common\xbwarning.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#pragma warning(3:4092)   // sizeof returns 'unsigned long'
#pragma warning(4:4121)   // structure is sensitive to alignment
#pragma warning(3:4125)   // decimal digit in octal sequence
#pragma warning(3:4130)   // logical operation on address of string constant
#pragma warning(3:4132)   // const object should be initialized
#pragma warning(4:4206)   // Source File is empty
#pragma warning(4:4101)   // Unreferenced local variable
#pragma warning(4:4208)   // delete[exp] - exp evaluated but ignored
#pragma warning(3:4212)   // function declaration used ellipsis
#pragma warning(3:4242)   // convertion possible loss of data
#pragma warning(4:4267)   // convertion from size_t to smaller type
#pragma warning(4:4312)   // conversion to type of greater size
#pragma warning(error:4700)    // Local used w/o being initialized
//#pragma warning(3:4700)    // Local used w/o being initialized
#pragma warning(error:4259)    // pure virtual function was not defined
#pragma warning(error:4071)    // no function prototype given
#pragma warning(error:4072)    // no function prototype given (fastcall)
#pragma warning(error:4171)    // no function prototype given (old style)
#pragma warning(error:4013)    // 'function' undefined - assuming extern returning int
#pragma warning(error:4551)    // Function call missing argument list
#pragma warning(error:4806)    // unsafe operation involving type 'bool'
#pragma warning(4:4509)   // use of SEH with destructor
#pragma warning(4:4177)   // pragma data_seg s/b at global scope
#pragma warning(disable:4274)  // #ident ignored
#pragma warning(disable:4786)  // identifier was truncated to 255 chararcers in debug information.
#pragma warning(disable:4503)  // decorated name length exceeded, name was truncated.
#pragma warning(disable:4263)  // Derived override doesn't match base - who cares...
#pragma warning(disable:4264)  // base function is hidden - again who cares.
#pragma warning(disable:4710)  // Function marked as inline - wasn't
#pragma warning(disable:4917)  // A GUID can only be associated with a class, interface or namespace
#pragma warning(error:4552)    // <<, >> ops used to no effect (probably missing an = sign)
#pragma warning(error:4553)    // == op used w/o effect (probably s/b an = sign)


#if _MSC_VER>=1300
// Fix these new warnings post NT5 RTM.
#pragma warning(4:4532)   // jump out of __finally block
#pragma warning(4:4288)   // nonstandard extension used (loop counter)
#endif

#ifndef __cplusplus
#undef try
#undef except
#undef finally
#undef leave
#define try                         __try
#define except                      __except
#define finally                     __finally
#define leave                       __leave
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\generic\ac3setup.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:			library\hardware\audio\generic\ac3setup.h
// AUTHOR:		U. Sigmund
// COPYRIGHT:	(c) 1996 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		20.11.1996
//
// PURPOSE:		Definitions for AC3 decoder setups
//
// HISTORY:

#ifndef AC3SETUP_H
#define AC3SETUP_H

enum AC3BassConfig
	{
	AC3BC_NO_REDIRECTION,
	AC3BC_REDIRECT_CENTER_BASS_TO_LEFT_AND_RIGHT,
	AC3BC_REDIRECT_LEFT_RIGHT_CENTER_BASS_TO_SUBWOOFER,
	AC3BC_REDIRECT_CENTER_BASS_TO_SUBWOOFER
	};

enum AC3SpeakerConfig
	{
	AC3SC_20_SURROUND_COMPATIBLE,
	AC3SC_10,
	AC3SC_20_NORMAL,
	AC3SC_30,
	AC3SC_21,
	AC3SC_31,
	AC3SC_22,
	AC3SC_32,
	AC3SC_KARAOKE		// This may only be available for MPEG-2 audio, but it is
							// added to the AC3 settings to avoid introducing new tags
	};

enum AC3DualModeConfig
	{
	AC3DMDM_DEFAULT,	// default is stereo
	AC3DMDM_STEREO = AC3DMDM_DEFAULT,
	AC3DMDM_CHANNEL1,	// channel 1 on both L/R
	AC3DMDM_CHANNEL2, // channel 2 on both L/R
	AC3DMDM_MIX			// mix channel 1 and 2 to mono, output on both L/R
	};

enum AC3KaraokeConfig
	{
	AC3KARA_AWARE,
	AC3KARA_DEFAULT,
	AC3KARA_OFF = AC3KARA_DEFAULT,
	AC3KARA_MULTICHANNEL	= 3,
	AC3KARA_CAPABLE_NO_VOCAL,
	AC3KARA_CAPABLE_V1,
	AC3KARA_CAPABLE_V2,
	AC3KARA_CAPABLE_BOTH_VOCAL
	};

enum DolbyProLogicConfig
	{
	DPLCFG_OFF,
	DPLCFG_DEFAULT = DPLCFG_OFF,
	DPLCFG_3_0 = 3,	// LCR three stereo
	DPLCFG_2_1,			// LRS phantom (= center not used)
	DPLCFG_3_1,			// LCRS
	DPLCFG_2_2,			// LRSS phantom
	DPLCFG_3_2			// LCRSS
	};

enum DolbyProLogicMode
	{
	DPLMODE_AUTOMATIC,	// Decoding depends on input fed into the PL decoder
	DPLMODE_DEFAULT = DPLMODE_AUTOMATIC,
	DPLMODE_ON,				// force it always on
	DPLMODE_OFF				// always off
	};

enum AC3DynamicRange
	{
	AC3DYNRG_DEFAULT,
	AC3DYNRG_COMPRESSED = AC3DYNRG_DEFAULT,	// Dynamic range sclae factor taken from MPEG-2 AC3 stream
	AC3DYNRG_MAXIMUM,									// Always use full dynamic range
	AC3DYNRG_MINIMUM,
	AC3DYNRG_TV
	};

// AC3 "acmod" property
enum AC3AudioCodingMode
	{
	AC3ACMOD_DUALMONO,
	AC3ACMOD_1_0,
	AC3ACMOD_2_0,
	AC3ACMOD_3_0,
	AC3ACMOD_2_1,
	AC3ACMOD_3_1,
	AC3ACMOD_2_2,
	AC3ACMOD_3_2,
	AC3ACMOD_UNKNOWN
	};

enum AC3DialogNorm
    {
	AC3DNORM_DEFAULT,
	AC3DNORM_ON = AC3DNORM_DEFAULT,
	AC3DNORM_OFF
	};

enum AC3OperationalMode
	{
	AC3OPMODE_DEFAULT,
	AC3OPMODE_LINE = AC3OPMODE_DEFAULT,
	AC3OPMODE_RF,
	AC3OPMODE_CUSTOM_0,
	AC3OPMODE_CUSTOM_1
	};





#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\Files\FileErrors.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  File Error Declarations
//
////////////////////////////////////////////////////////////////////

#ifndef FILEERRORS_H
#define FILEERRORS_H

#include "library\common\gnerrors.h"

#define GNR_PATH_NOT_FOUND							MKERR(ERROR,	FILE,			OBJECT,			0x00)
// The path specified was not found

#define GNR_INVALID_PATH							MKERR(ERROR,	FILE,			OBJECT,			0x01)
// The path specified was invalid (e.g. contained invalid letters)

#define GNR_NO_FILE_SYSTEM							MKERR(ERROR,	FILE,			OBJECT,			0x02)
// There is no file system to execute operation

#define GNR_NO_VOLUME								MKERR(ERROR,	FILE,			OBJECT,			0x03)
// There is no volume to execute operation

#define GNR_VOLUME_INVALID							MKERR(ERROR,	FILE,			OBJECT,			0x04)
// Volume is invalid for some reason, e.g. not supported

#define GNR_ITEM_NOT_FOUND							MKERR(ERROR,	FILE,			OBJECT,			0x05)
// The item was not found or there is no more file in the directory

#define GNR_NOT_A_DIRECTORY						MKERR(ERROR,	FILE,			OBJECT,			0x06)
// Disk item is not a directory

#define GNR_ITEM_INVALID							MKERR(ERROR,	FILE,			OBJECT,			0x07)
// Item is invalid (e.g. for an operation)

#define GNR_FILE_READ_ONLY							MKERR(ERROR,	FILE,			OPERATION,		0x00)
// The file is read only

//#define GNR_FILE_IN_USE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\generic\adstcodc.h ===
// FILE:			library\hardware\audio\generic\adstcodc.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		30.11.95
//
// PURPOSE:		Class for Analog Devices 1846 compatible stereo codecs. 
//
// HISTORY:

#ifndef ADSTCODC_H
#define ADSTCID_H

#include "..\common\gnerrors.h"
#include "audtypes.h"

enum ADInputSource {AD_LINE, AD_AUX1, AD_MICROPHONE, AD_POSTMIXED_DAC};

enum ADAuxInputs {AD_AUX2 = AD_POSTMIXED_DAC};


class ADStereoCodec {
	protected:
		ByteIndexedInOutPort *	port;
	public:
	   ADStereoCodec(ByteIndexedInOutPort * port);

	   virtual ResetADStereoCodec();

		virtual Error Playback(BOOL run);
		virtual Error InstallPlaybackHook();
		
		virtual Error Capture(BOOL run);
		virtual Error InstallCaptureHook();
		
		virtual Error SetSources  		(SoundChannel channel, ADInputSource src);
		virtual Error SetInputGain		(SoundChannel channel, WORD gain);
		virtual Error SetMikeGain 		(SoundChannel channel, BOOL mikeGain);
		virtual Error SetAuxAttenuate	(SoundChannel channel, ADAuxInputs input, WORD att);
		virtual Error SetAuxMute		(SoundChannel channel, ADAuxInputs input, BOOL mute);
		virtual Error SetDACAttenuate	(SoundChannel channel, WORD att);
		virtual Error SetDACMute		(SoundChannel channel, BOOL mute);
		virtual Error SetSampleRate	(WORD rate);
		virtual Error SetFormat			(AudioDataFormat format, AudioDataEndianess endianess, AudioMode mode);
		virtual Error SetAutoCalibrate(BOOL calibrate);
		
		virtual Error GetOverrange		(SoundChannel channel, WORD __far & rangeLevel);
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\generic\auddec.h ===
// FILE:		   library\hardware\audio\generic\auddec.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		30.11.95
//
// PURPOSE:		Base class for audio decoders.
//
// HISTORY:

#ifndef AUDDEC_H
#define AUDDEC_H

#include "austrdev.h"

#ifndef ONLY_EXTERNAL_VISIBLE

class AudioDecoder : public AudioStreamDevice {
	protected:
	public:
	};

class VirtualAudioDecoder : public VirtualAudioStreamDevice {
	private:
		AudioDecoder	*	unit;	
	protected:
		Error Preempt(VirtualUnit *previous);
	public:
		VirtualAudioDecoder(AudioDecoder *physical) : VirtualAudioStreamDevice(physical) {this->unit = physical;}
		Error Configure(TAG __far * tags);
	};

#endif // ONLY_EXTERNAL_VISIBLE


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\generic\aucodecs.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:			library\hardware\audio\generic\aucodecs.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1996 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		25.06.96
//
// PURPOSE:		Base class definition for audio codecs.
//
// HISTORY:

#ifndef AUCODECS_H
#define AUCODECS_H

#include "library/common/prelude.h"
#include "library/common/gnerrors.h"

// Error definition
#define GNR_AUD_CODEC_HALTED	MKERR(ERROR, AUDIO, GENERAL, 0x0666)

#define GNR_NO_AUDIO_HARDWARE	MKERR(ERROR, AUDIO, GENERAL, 0x0667)

class AudioCodec
	{
	protected:
		BOOL	playback;
		BOOL	capture;

		BOOL	playbackResume;
		BOOL	captureResume;

		int	haltCount;

	public:
		AudioCodec();

		virtual Error InitPlayback		(void);
		virtual Error EndPlayback		(void);

		virtual Error InitCapture		(void);
		virtual Error EndCapture		(void);

		virtual Error HaltTransfers	(void);			// Stop all transfers (capture & playback).
		virtual Error ResumeTransfers	(void);			// Resume all transfers.
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\generic\auddevs.h ===
// FILE:       library\hardware\audio\generic\auddevs.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1996 Viona Development GmbH.  All Rights Reserved.
// CREATED:		24.01.1996
//
// PURPOSE: 	Base Classes for Windows Sound System Device Drivers
//
// HISTORY:
//
//

#ifndef AUDDEVS_H
#define AUDDEVS_H

#include "library\common\prelude.h"
#include "library\general\lists.h"

///////////////////////////////////////////////////////////////////////////////
// Audio Device Base Class
///////////////////////////////////////////////////////////////////////////////

class ClientList;

class AudioDevice {
	protected:
		ClientList	*	clients;
		
		DWORD				enableCount;
		BOOL				enabled;

		HINSTANCE		instance;		
	public:
		AudioDevice(HINSTANCE instance);
		virtual ~AudioDevice();
		
		virtual DWORD Enable(void);
		virtual DWORD Disable(void);
	};


///////////////////////////////////////////////////////////////////////////////
// Device Client Base Class
///////////////////////////////////////////////////////////////////////////////

class DeviceClient : public Node {
	public:
		AudioDevice	*		owner;					// Audio Device of which this node is client. 
															// Initialized with NULL when created.
	
		DWORD					openFlags;                                     
		DWORD					procCallback;			// function callback
#if WIN32
		DWORD					callbackType;
#else
		UINT					callbackType;			// callback
#endif
		DWORD					instance;				// app's private instance information
//	PHARDWAREINSTANCE	phwi;							// speicher spter die Hardware-Instanz... PHARDWAREINSTANCE muss noch als Klasse
															// definiert werden.

		DeviceClient() {owner = NULL;}

#if WIN32	
		virtual void Notify(DWORD message, DWORD param) = 0;
#else
		virtual void Notify(WORD message, DWORD param) = 0;
#endif
	};

///////////////////////////////////////////////////////////////////////////////
// Device Client List Class
///////////////////////////////////////////////////////////////////////////////

class ClientList : public List {
	public:
		~ClientList();
		DeviceClient* FindClient(DeviceClient* client);	// Looks for the given client. Returns FALSE when not in list.
		
#if WIN32	
		virtual void NotifyClients(DWORD message, DWORD param);		
#else
		virtual void NotifyClients(WORD message, DWORD param);		
#endif
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\generic\audenc.h ===
// FILE:			library\hardware\audio\generic\audenc.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		30.11.95
//
// PURPOSE:		Base class for audio encoders.
//
// HISTORY:

#ifndef AUDENC_H
#define AUDENC_H

#include "austrdev.h"

#ifndef ONLY_EXTERNAL_VISIBLE

class AudioEncoder : public AudioStreamDevice {
	protected:
	public:
	};

class VirtualAudioEncoder : public VirtualAudioStreamDevice {
	private:
		AudioEncoder	*	unit;	
	protected:
		Error Preempt(VirtualUnit *previous);
	public:
		VirtualAudioEncoder(AudioEncoder *physical) : VirtualAudioStreamDevice(physical) {this->unit = physical;}
		Error Configure(TAG __far * tags);
	};

#endif // ONLY_EXTERNAL_VISIBLE


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\generic\audfifos.h ===
// FILE:			library\hardware\audio\generic\audfifos.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		12.12.95
//
// PURPOSE:		Classes for custom audio FIFOs
//
// HISTORY:

#ifndef AUDFIFOS_H
#define AUDFIFOS_H

#include "library\common\gnerrors.h"

//
// Full size of FIFO. Change here, if size of FIFO on board changes.
//
#define DEFAULT_FIFO_SIZE 2048L		// Minimal FIFO size as default

//
// Errors for audio FIFO
//
// Transfer is already running though it should be halted.
#define GNR_FIFO_TRANSFER_RUNNING	MKERR(ERROR, AUDIO, GENERAL, 0x0101)
// Transfer is halted though it should be running
#define GNR_FIFO_TRANSFER_HALTED		MKERR(ERROR, AUDIO, GENERAL, 0x0102)
// FIFO is already full.
#define GNR_FIFO_FULL					MKERR(ERROR, AUDIO, GENERAL, 0x0103)
// FIFO is already empty.
#define GNR_FIFO_EMPTY					MKERR(ERROR, AUDIO, GENERAL, 0x0104)
// FIFO size could not be detected. Possibly there is none...
#define GNR_FIFO_SIZE_UNDETERMINED	MKERR(ERROR, AUDIO, GENERAL, 0x0105)

#ifndef ONLY_EXTERNAL_VISIBLE

#include "library\lowlevel\hardwrio.h"
#include "library\lowlevel\intrctrl.h"
#include "library\common\virtunit.h"

class AudioFIFOEventRequest {
	public:
		virtual void FIFOEvent(BOOL read, DWORD bytesAvailable) = 0;
	};

class AudioFIFO {
	private:
		ByteIndexedInOutPort		*	fifoPort;
	protected:
		BOOL	read;
		
		AudioFIFOEventRequest	*	request;
	public:
		AudioFIFO(ByteIndexedInOutPort * fifoPort) {this->fifoPort = fifoPort; request = NULL;}

		// Initialize a transfer. Install request callback class. 
		virtual Error InitTransfer(BOOL read, AudioFIFOEventRequest * request);	
		virtual Error StartTransfer(void) = 0;
		virtual Error HaltTransfer(void) = 0;
		virtual Error ResumeTransfer(void) = 0;
		virtual Error EndTransfer(void) = 0;

		virtual DWORD GetSize(void) = 0;								// Get the full size of the FIFO.

		virtual DWORD AvailBytes(void) = 0;

		virtual Error Fill(FPTR data, DWORD bytes) = 0;			// Fill the FIFO with num bytes.
		virtual Error Get(FPTR data, DWORD bytes) = 0;			// Get num bytes from the FIFO
	};


enum StatusType {FIFO_STATUS_FIELD_ERROR,
					  FIFO_STATUS_RUNNING = FIFO_STATUS_FIELD_ERROR,
					  FIFO_STATUS_EMPTY,
					  FIFO_STATUS_FULL,
					  FIFO_STATUS_HALFFULL
					 };

class H22AudioFIFO : public AudioFIFO {
	private:
		ByteIndexedInOutPort		*	fifoPort;
		BitInputPort				*	statusPort;
      InterruptServer 			*	fifoIntServer;
      InterruptHandler			*	fifoIntHandler;
	      
		BOOL	transferRunning;
		DWORD	availableBytes;
		DWORD	haltCount;
		BOOL	manualStart;

		DWORD	fifoSize;
		
		BOOL	read;
	protected:
		Error	GetStatus(StatusType type, BOOL __far & status);	// Get status of a certain type.
		Error WriteBytes(DWORD numBytes);
		Error DetermineSize(DWORD __far & size);
	public:
		H22AudioFIFO(ByteIndexedInOutPort	* fifoPort,
						 BitInputPort				* statusPort,
						 InterruptServer			* fifoIntServer);
						 
		~H22AudioFIFO();

		virtual Error Reset(void);

		virtual Error SetManualStart(BOOL manualStart);

		Error InitTransfer(BOOL read, AudioFIFOEventRequest * request);
		Error StartTransfer(void);
		Error HaltTransfer(void);
		Error ResumeTransfer(void);
		Error EndTransfer(void);

		DWORD	GetSize(void) {return fifoSize;}
		DWORD	AvailBytes(void);
		
		Error Fill(FPTR data, DWORD bytes);
		Error Get(FPTR data, DWORD bytes);

		void 	Interrupt(void);									// Interrupt handling routine
	}; 

#endif	

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\generic\audtimer.h ===
// FILE:			library\hardware\audio\generic\audtimer.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		30.11.95
//
// PURPOSE:		Base class for timers integrated in audio codecs.
//
// HISTORY:

#ifndef AUDTIMER_H
#define AUDTIMER_H

#include "..\common\gnerrors.h"
#include "..\common\tags.h"
#include "..\common\tagunits.h"
#include "..\common\virtunit.h"

MKTAG (AUDMIX_INPUT_NUMBER, AUDIO_TIMER_UNIT, 0x0001001, WORD)

#ifndef ONLY_EXTERNAL_VISIBLE

class AudioTimer : public PhysicalUnit {
	public:
		AudioTimer() {;}
	};

class VirtualAudioTimer : public VirtualUnit {
	private:
		AudioTimer		*	timer;	
	protected:
		Error Preempt(VirtualUnit *previous);
	public:
		VirtualAudioTimer(AudioTimer *physical) {this->timer = physical};
		Error Configure(TAG __far * tags);
	};

#endif // ONLY_EXTERNAL_VISIBLE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\generic\audstrms.h ===
// FILE:			library\hardware\audio\generic\audstrms.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		30.11.95
//
// PURPOSE:		Classes for audio streams going over this FIFO
//
// HISTORY:

#ifndef AUDSTRMS_H
#define AUDSTRMS_H

#include "library\general\asncstrm.h"
#include "audfifos.h"

#ifndef ONLY_EXTERNAL_VISIBLE

#define GNR_AUDSTRM_TRANSFER_HALTED		MKERR(ERROR, AUDIO, GENERAL, 0x0301)

/////////////////////////////////////////////////////////////////////////////////
// Asynchronous FIFO audio output stream
/////////////////////////////////////////////////////////////////////////////////

class FIFOOutStream : public ASyncOutStream, protected AudioFIFOEventRequest {
	private:
		AudioFIFO				*	fifo;
		
		DWORD position;
		
		BOOL	transferRunning;
		BOOL	transferStarted;
	public:
		FIFOOutStream(AudioFIFO * fifo); 
		~FIFOOutStream(void) {};

		Error WriteData(HPTR data, DWORD size, DWORD __far &done);

		DWORD AvailSpace(void);
		DWORD AvailData(void);

		DWORD GetTransferLocation(void);
		void  SetTransferLocation(DWORD pos);

		Error RecoverData(HPTR buffer, DWORD size, DWORD __far &done);

		Error StartTransfer();
		Error StopTransfer(void);

		Error SuspendTransfer(void);
		Error ResumeTransfer(void);

		Error SyncTransfer(void);
		Error CompleteTransfer(void);
      
      Error FlushBuffer(void);		
		
		void FIFOEvent(BOOL read, DWORD bytesAvailable);
	};

/////////////////////////////////////////////////////////////////////////////////
// Asynchronous FIFO audio input stream
/////////////////////////////////////////////////////////////////////////////////

class FIFOInStream : public ASyncInStream, protected AudioFIFOEventRequest {
	private:
		AudioFIFO	*	fifo;

		DWORD position;
		
		BOOL	transferRunning;
		BOOL	transferStarted;
	public:
		FIFOInStream(AudioFIFO * fifo);
		~FIFOInStream(void) {};

		Error ReadData(HPTR data, DWORD size, DWORD __far &done);

		DWORD AvailSpace(void);
		DWORD AvailData(void);

		DWORD GetTransferLocation(void);
		void	SetTransferLocation(DWORD pos);
		
		Error StartTransfer(void);
		Error StopTransfer(void);

		Error SuspendTransfer(void);
		Error ResumeTransfer(void);

		Error SyncTransfer(void);

		Error FlushBuffer(void);

		void FIFOEvent(BOOL read, DWORD bytesAvailable);
	};

#endif // ONLY_EXTERNAL_VISIBLE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\generic\audmix.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:			library\hardware\audio\generic\audmix.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		30.11.95
//
// PURPOSE:		Base class for audio mixers.
//
// HISTORY:

#ifndef AUDMIX_H
#define AUDMIX_H

#include "library\common\gnerrors.h"
#include "library\common\tags.h"
#include "library\common\tagunits.h"
#include "library\common\virtunit.h"
#include "library\common\hooks.h"
#include "audtypes.h"

/////////////////////////////////////////////////////////////////////////////////////////////
// Input capabilities
/////////////////////////////////////////////////////////////////////////////////////////////

#define INPUT_NO_CAPTURE			0x00000001		// This input cannot be captured (digitized).
#define INPUT_STEREO					0x00000002		// This is a stereo input.
#define INPUT_CAPTURE_LOOPBACK	0x00000004		// Capture is only possible via loopback mode.
#define INPUT_MIXABLE				0x00000008		// Input may be mixed to output (i.e. gain/att. may be set).
#define INPUT_MUTABLE				0x00000010		// Input may be muted (concerns mix with output).

/////////////////////////////////////////////////////////////////////////////////////////////
// Definition of input types.
/////////////////////////////////////////////////////////////////////////////////////////////

enum MixerInputType {IN_MIC, IN_LINE, IN_AUX, IN_MONO, IN_OTHER, IN_NOT_CONNECTED};

/////////////////////////////////////////////////////////////////////////////////////////////
// Description structure for each input.
/////////////////////////////////////////////////////////////////////////////////////////////

struct MixerInput {
	MixerInputType	type;			// Type of mixer input.
	DWORD				caps;			// Capabilities (see above).
	char				name[50];	// Name for this input.
	};


typedef MixerInput __far * MixerInputArrayPtr;

/////////////////////////////////////////////////////////////////////////////////////////////
// Definition of callback hook for Direct Tag changes
/////////////////////////////////////////////////////////////////////////////////////////////


struct DirectTagChangeMsg
	{
	DWORD		flags;		// See definitions above
	DWORD		inputs;		// If DTCM_AFFECTS_INPUT is contained in flags, this tells which
								// inputs have been affected (see specific mixer implementations).
	};

// Flag definitions for Direct Tag Change Message "flags" field
#define DTCM_CHANGED_GENERAL			0x00000001		// The general Direct Tags have been changed
																// General means: Not specifically for a certain
																// input.
#define DTCM_CHANGED_INPUTS			0x00000002		// The Direct Tag values were changed for
																// specific inputs.
// Flags specific for inputs
#define DTCM_CHANGED_INPUTS_GENERAL	0x00001000	// Changed general settings for an input


MKHOOK(DirectTagChange, DirectTagChangeMsg)

typedef DirectTagChangeHook __far * DirectTagChangeHookPtr;



struct NotificationMsg
	{
	DWORD	senderID;
	DWORD	id;
	DWORD	type;
	DWORD	msg;
	DWORD	data;
	};

MKHOOK(Notification, NotificationMsg)

typedef NotificationHook * NotificationHookPtr;

// Use this for notifications that have to be transferred to different process instances
// through the kernel mode driver. As it may happen that there is only one virtual unit
// for all process instances (like for a High Level Windows Mixer), we need to identify
// the hook, which we do by using "id".
// To remove the hook, set "hook" to NULL, but keep "id" valid.
struct IdentifiedNotification
	{
	NotificationHookPtr	hook;
	DWORD						id;
	};

typedef IdentifiedNotification __far * IdentifiedNotificationPtr;

#define NOTIFY_MIXER	MKFLAG(0)



/////////////////////////////////////////////////////////////////////////////////////////////
// Tag Definitions
/////////////////////////////////////////////////////////////////////////////////////////////

// General tags for Audio Mixer
//
MKTAG (AUDMIX_CAPTURE_SELECT,					AUDIO_MIXER_UNIT, 0x0001, WORD)	// Selects input to capture.
MKTAG (AUDMIX_CAPTURE_SELECT_LEFT,			AUDIO_MIXER_UNIT, 0x0002, WORD)	//   dto. for left channel only.
MKTAG (AUDMIX_CAPTURE_SELECT_RIGHT,			AUDIO_MIXER_UNIT, 0x0003, WORD)	//   dto. for right channel only.
MKTAG (AUDMIX_GAIN,								AUDIO_MIXER_UNIT, 0x0004, WORD)	// Sets ADC gain.
MKTAG (AUDMIX_GAIN_LEFT,						AUDIO_MIXER_UNIT, 0x0005, WORD)
MKTAG (AUDMIX_GAIN_RIGHT,						AUDIO_MIXER_UNIT, 0x0006, WORD)
MKTAG (AUDMIX_GAIN_ENABLE_LEFT,				AUDIO_MIXER_UNIT, 0x0007, BOOL)	// Enables ADC extra gain for mic.
MKTAG (AUDMIX_GAIN_ENABLE_RIGHT,				AUDIO_MIXER_UNIT, 0x0008, BOOL)
MKTAG (AUDMIX_ATTENUATE,						AUDIO_MIXER_UNIT, 0x0009, WORD)	// Sets DAC attenuation.
MKTAG (AUDMIX_ATTENUATE_LEFT,					AUDIO_MIXER_UNIT, 0x000a, WORD)
MKTAG (AUDMIX_ATTENUATE_RIGHT,				AUDIO_MIXER_UNIT, 0x000b, WORD)
MKTAG (AUDMIX_MUTE,								AUDIO_MIXER_UNIT, 0x000c, BOOL)	// Sets DAC mute.
MKTAG (AUDMIX_MUTE_LEFT,						AUDIO_MIXER_UNIT, 0x000d, BOOL)
MKTAG (AUDMIX_MUTE_RIGHT,						AUDIO_MIXER_UNIT, 0x000e, BOOL)

// Tags for input properties/selection
//
MKTAG (AUDMIX_INPUT_NUMBER, 					AUDIO_MIXER_UNIT, 0x000f, WORD)	// Delivers total number of inputs.
MKTAG (AUDMIX_MIXER_DESCRIPTION,				AUDIO_MIXER_UNIT, 0x0010, MixerInputArrayPtr)
// The next tag selects one of the inputs, for which the following tags can then be applied.
MKTAG (AUDMIX_INPUT_SELECT,					AUDIO_MIXER_UNIT, 0x0000011, WORD)
//
// The following tags are used to set the properties of an input.
// Use QUERY_... to find out the capabilities for a certain input. If tags like AUDMIX_INPUT_GAIN
// deliver FALSE (i.e. input is stereo), then you MUST check AUDMIX_INPUT_GAIN_LEFT/_RIGHT.
// If it is TRUE, then this is not necessary.
//
MKTAG (AUDMIX_INPUT_GAIN,						AUDIO_MIXER_UNIT, 0x0012, WORD)	// Gain (to the ADC) is changeable (mono).
MKTAG (AUDMIX_INPUT_GAIN_LEFT,				AUDIO_MIXER_UNIT, 0x0013, WORD)	// Gain is independently changeable for
MKTAG (AUDMIX_INPUT_GAIN_RIGHT,				AUDIO_MIXER_UNIT, 0x0014, WORD)	// left/right channels.
MKTAG (AUDMIX_INPUT_MIX_GAIN,					AUDIO_MIXER_UNIT, 0x0015, WORD)	// Analog output mix gain for the input.
MKTAG (AUDMIX_INPUT_MIX_GAIN_LEFT,			AUDIO_MIXER_UNIT, 0x0016, WORD)
MKTAG (AUDMIX_INPUT_MIX_GAIN_RIGHT,			AUDIO_MIXER_UNIT, 0x0017, WORD)
MKTAG (AUDMIX_INPUT_MIX_ATTENUATE,			AUDIO_MIXER_UNIT, 0x0018, WORD)	// Analog output mix attenuation.
MKTAG (AUDMIX_INPUT_MIX_ATTENUATE_LEFT,	AUDIO_MIXER_UNIT, 0x0019, WORD)
MKTAG (AUDMIX_INPUT_MIX_ATTENUATE_RIGHT,	AUDIO_MIXER_UNIT, 0x001a, WORD)
MKTAG (AUDMIX_INPUT_GAIN_ENABLE,				AUDIO_MIXER_UNIT, 0x001b, BOOL)	// Enables extra gain for input.
MKTAG (AUDMIX_INPUT_GAIN_ENABLE_LEFT,		AUDIO_MIXER_UNIT, 0x0001c, BOOL)
MKTAG (AUDMIX_INPUT_GAIN_ENABLE_RIGHT,		AUDIO_MIXER_UNIT, 0x001d, BOOL)
MKTAG (AUDMIX_INPUT_MUTE,						AUDIO_MIXER_UNIT, 0x001e, BOOL)	// Mutes input for the analog output mix.
MKTAG (AUDMIX_INPUT_MUTE_LEFT,				AUDIO_MIXER_UNIT, 0x001f, BOOL)
MKTAG (AUDMIX_INPUT_MUTE_RIGHT,				AUDIO_MIXER_UNIT, 0x0020, BOOL)

// Special tags for more advanced mixers.
//
MKTAG (AUDMIX_LOOPBACK,							AUDIO_MIXER_UNIT, 0x0021, BOOL)	// Enables digital loopback (ADC->DAC)
MKTAG (AUDMIX_LOOPBACK_ATTENUATION, 		AUDIO_MIXER_UNIT, 0x0022, WORD)	// Sets digital attenuation.

MKTAG (AUDMIX_MONOOUT_MUTE, 					AUDIO_MIXER_UNIT, 0x0023, BOOL)	// Mutes mono output.
MKTAG (AUDMIX_MONOIN_MUTE, 					AUDIO_MIXER_UNIT, 0x0024, BOOL)	// Mutes mono input.
MKTAG (AUDMIX_MONO_ATTENUATION, 				AUDIO_MIXER_UNIT, 0x0025, BOOL)	// Mono output attenuation.

// General tags for Audio Fader
//
MKTAG (AUDMIX_LOUDNESS,							AUDIO_MIXER_UNIT, 0x2001, BOOL)
MKTAG (AUDMIX_ZERO_CROSSING,					AUDIO_MIXER_UNIT, 0x2002, BOOL)

// Affect both front and rear fader in the right proportion as necessary for Buster
MKTAG (AUDMIX_FADER_LEFT,						AUDIO_MIXER_UNIT, 0x2003, WORD)
MKTAG (AUDMIX_FADER_RIGHT,						AUDIO_MIXER_UNIT, 0x2004, WORD)

MKTAG (AUDMIX_BASS,								AUDIO_MIXER_UNIT, 0x2007, int)
MKTAG (AUDMIX_TREBLE,							AUDIO_MIXER_UNIT, 0x2008, int)

//
// Special tags for Microsoft Sound System Audio Mixer Device
// Their execution will directly affect the physical unit.
//
//          -- DO NOT USE EXCEPT FOR THIS PURPOSE!! --
//
MKTAG (AUDMIX_D_GAIN,								AUDIO_MIXER_UNIT, 0x0026, WORD)
MKTAG (AUDMIX_D_GAIN_LEFT,							AUDIO_MIXER_UNIT, 0x0027, WORD)
MKTAG (AUDMIX_D_GAIN_RIGHT,						AUDIO_MIXER_UNIT, 0x0028, WORD)
MKTAG (AUDMIX_D_ATTENUATE,							AUDIO_MIXER_UNIT, 0x0029, WORD)
MKTAG (AUDMIX_D_ATTENUATE_LEFT,					AUDIO_MIXER_UNIT, 0x002a, WORD)
MKTAG (AUDMIX_D_ATTENUATE_RIGHT,					AUDIO_MIXER_UNIT, 0x002b, WORD)
MKTAG (AUDMIX_D_MUTE,								AUDIO_MIXER_UNIT, 0x002c, BOOL)
MKTAG (AUDMIX_D_MUTE_LEFT,							AUDIO_MIXER_UNIT, 0x002d, BOOL)
MKTAG (AUDMIX_D_MUTE_RIGHT,						AUDIO_MIXER_UNIT, 0x002e, BOOL)
MKTAG	(AUDMIX_D_INPUT_SELECT,						AUDIO_MIXER_UNIT, 0x002f, int)	// Selects the affected input (see above)
MKTAG (AUDMIX_D_INPUT_MUTE,						AUDIO_MIXER_UNIT, 0x0030, BOOL)
MKTAG (AUDMIX_D_INPUT_MUTE_LEFT,					AUDIO_MIXER_UNIT, 0x0031, BOOL)
MKTAG (AUDMIX_D_INPUT_MUTE_RIGHT,				AUDIO_MIXER_UNIT, 0x0032, BOOL)
MKTAG (AUDMIX_D_LOUDNESS,							AUDIO_MIXER_UNIT, 0x200b, BOOL)
MKTAG (AUDMIX_D_FADER_LEFT,						AUDIO_MIXER_UNIT, 0x200c, WORD)
MKTAG (AUDMIX_D_FADER_RIGHT,						AUDIO_MIXER_UNIT, 0x200d, WORD)
MKTAG (AUDMIX_D_BASS,								AUDIO_MIXER_UNIT, 0x200e, WORD)
MKTAG (AUDMIX_D_TREBLE,								AUDIO_MIXER_UNIT, 0x200f, WORD)
MKTAG (AUDMIX_D_INPUT,								AUDIO_MIXER_UNIT, 0x2010, WORD)
MKTAG (AUDMIX_D_INPUT_FADER_LEFT,				AUDIO_MIXER_UNIT, 0x2011, WORD)
MKTAG (AUDMIX_D_INPUT_FADER_RIGHT,				AUDIO_MIXER_UNIT, 0x2012, WORD)
MKTAG (AUDMIX_D_INPUT_FADER_FRONT_LEFT,		AUDIO_MIXER_UNIT, 0x2013, WORD)
MKTAG (AUDMIX_D_INPUT_FADER_FRONT_RIGHT,		AUDIO_MIXER_UNIT, 0x2014, WORD)
MKTAG (AUDMIX_D_INPUT_FADER_REAR_LEFT,			AUDIO_MIXER_UNIT, 0x2015, WORD)
MKTAG (AUDMIX_D_INPUT_FADER_REAR_RIGHT,		AUDIO_MIXER_UNIT, 0x2016, WORD)

// Additional tags for faders and/or mixers.
//

// New additional fader properties
MKTAG (AUDMIX_FADER_FRONT_LEFT,					AUDIO_MIXER_UNIT, 0x2030, WORD)
MKTAG (AUDMIX_FADER_FRONT_RIGHT,					AUDIO_MIXER_UNIT, 0x2031, WORD)
MKTAG (AUDMIX_FADER_REAR_LEFT,					AUDIO_MIXER_UNIT, 0x2032, WORD)
MKTAG (AUDMIX_FADER_REAR_RIGHT,					AUDIO_MIXER_UNIT, 0x2033, WORD)

MKTAG (AUDMIX_VOLUME,								AUDIO_MIXER_UNIT, 0x2050, WORD)
MKTAG (AUDMIX_VOLUME_LEFT,							AUDIO_MIXER_UNIT, 0x2003, WORD)	// Note: same as FADER_LEFT
MKTAG (AUDMIX_VOLUME_RIGHT,						AUDIO_MIXER_UNIT, 0x2004, WORD)

MKTAG (AUDMIX_FADER_FRONT,							AUDIO_MIXER_UNIT, 0x2053, WORD)
MKTAG (AUDMIX_FADER_REAR,							AUDIO_MIXER_UNIT, 0x2054, WORD)
MKTAG (AUDMIX_FADER_FRONT_MUTE,					AUDIO_MIXER_UNIT, 0x2055, WORD)
MKTAG (AUDMIX_FADER_REAR_MUTE,					AUDIO_MIXER_UNIT, 0x2056, WORD)

// Additional Direct Tags for faders and/or mixers
MKTAG (AUDMIX_D_INPUT_VOLUME,						AUDIO_MIXER_UNIT, 0x2057, WORD)
MKTAG (AUDMIX_D_INPUT_VOLUME_LEFT,				AUDIO_MIXER_UNIT, 0x2058, WORD)
MKTAG (AUDMIX_D_INPUT_VOLUME_RIGHT,				AUDIO_MIXER_UNIT, 0x2059, WORD)
MKTAG (AUDMIX_D_VOLUME,								AUDIO_MIXER_UNIT, 0x205a, WORD)
MKTAG (AUDMIX_D_VOLUME_LEFT,						AUDIO_MIXER_UNIT, 0x205b, WORD)
MKTAG (AUDMIX_D_VOLUME_RIGHT,						AUDIO_MIXER_UNIT, 0x205c, WORD)

// Tag for Installation of a Direct-Tag-Change-Hook
// Set to NULL to remove the hook.
MKTAG (AUDMIX_D_DTAG_CHANGE_HOOK,				AUDIO_MIXER_UNIT, 0x205d, DirectTagChangeHookPtr)

// Identified change hook
MKTAG (AUDMIX_D_ID_NOTIFICATION,					AUDIO_MIXER_UNIT, 0x205d, IdentifiedNotificationPtr)


#ifndef ONLY_EXTERNAL_VISIBLE

#if NT_KERNEL

class IDNotification : public Node
	{
	public:
		DWORD							id;
		NotificationHookHandle	hookHandle;

		IDNotification(DWORD id, NotificationHookHandle hookHandle) {this->id = id; this->hookHandle = hookHandle;}
	};

typedef IDNotification * IDNotificationPtr;

class IDNotificationList : public List
	{
	public:
		~IDNotificationList();
		IDNotificationPtr FindByID(DWORD id);
	};

#endif

class AudioMixer : public PhysicalUnit {
	friend class VirtualAudioMixer;
	protected:
		WORD							numInputs;
		MixerInputArrayPtr		inputs;
		int							currentInput;

		virtual Error SetCurrentInput(int currentInput);
		virtual Error ProcessChanges() = 0;

#if NT_KERNEL
		IDNotificationList	*notificationList;

		virtual Error SetIdentifiedNotification(IdentifiedNotificationPtr notification);
		virtual Error SendNotifications(DWORD senderID, DWORD type, DWORD msg, DWORD data);
#endif
	public:
		AudioMixer();
		~AudioMixer();

		virtual Error RetrieveINIValues(void) {GNRAISE_OK;}

		virtual VirtualAudioMixer * CreateVirtualAudioMixer(void) {return NULL;}
		VirtualUnit * CreateVirtual(void);
	};

class VirtualAudioMixer : public VirtualUnit {
	private:
		AudioMixer			*	mixer;
	protected:
		WORD	curInput;

		Error Preempt(VirtualUnit *previous);
	public:
		VirtualAudioMixer(AudioMixer *physical) : VirtualUnit(physical) {this->mixer = physical;}
		Error Configure(TAG __far * tags);

#if NT_KERNEL
		virtual Error SendNotifications(DWORD senderID, DWORD type, DWORD msg, DWORD data);
#endif
	};

inline VirtualUnit * AudioMixer::CreateVirtual(void) {return CreateVirtualAudioMixer();}

#endif // ONLY_EXTERNAL_VISIBLE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\generic\audiodac.h ===
// FILE:			library\hardware\audio\generic\audiodac.h
// AUTHOR:		Viona
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		04.12.96
//
// PURPOSE:		
//
// HISTORY:
#ifndef AUDIODAC_H
#define AUDIODAC_H

#include "..\..\..\common\prelude.h"
#include "..\..\..\common\gnerrors.h"
#include "..\..\..\common\virtunit.h"
#include "..\..\..\common\tagunits.h"

//
// Audio (PCM)DAC configuration parameter, esp. input and
// output format.
//
#define AUDIODAC_INPUT_MODE_I2S		MKFLAG(0)
#define AUDIODAC_INPUT_MODE_NORMAL	0L

#define AUDIODAC_INPUT_CLOCK_HLLR   MKFLAG(1)
#define AUDIODAC_INPUT_CLOCK_HLRL	0L

#define AUDIODAC_INPUT_LENGTH_18		MKFLAG(2)
#define AUDIODAC_INPUT_LENGTH_16		0L

#define AUDIODAC_INPUT_RESOLUTION	3, 2
#define AUDIODAC_INPUT_RES_16			MKBF(AUDIODAC_INPUT_RESOLUTION, 0)
#define AUDIODAC_INPUT_RES_20			MKBF(AUDIODAC_INPUT_RESOLUTION, 1)
#define AUDIODAC_INPUT_RES_24			MKBF(AUDIODAC_INPUT_RESOLUTION, 2)

#define AUDIODAC_OUTPUT_MONO			0
#define AUDIODAC_OUTPUT_REVERSE		1
#define AUDIODAC_OUTPUT_STEREO		2
#define AUDIODAC_OUTPUT_MUTE			3

//
// Audio (PCM)DAC specific tags
//
MKTAG(AUDIODAC_LEFT_VOLUME,		AUDIO_DAC_UNIT,	0x0001,	WORD)
MKTAG(AUDIODAC_RIGHT_VOLUME,		AUDIO_DAC_UNIT,	0x0002,	WORD)
MKTAG(AUDIODAC_MUTE,					AUDIO_DAC_UNIT,	0x0003,	BOOL)
MKTAG(AUDIODAC_INPUT_FORMAT,		AUDIO_DAC_UNIT,	0x0004,	DWORD)
MKTAG(AUDIODAC_OUTPUT_FORMAT,		AUDIO_DAC_UNIT,	0x0005,	DWORD)

//
// Abstract audio (PCM)DAC, straight physical/virtual unit
// implementation.
//
class AudioDAC : public PhysicalUnit
	{
	friend class VirtualAudioDAC;
	protected:
		virtual Error SetLeftVolume(WORD volume) = 0;
		virtual Error SetRightVolume(WORD volume) = 0;
		virtual Error SetMute(BOOL mute) = 0;
		virtual Error SetInputFormat(DWORD format) = 0;
		virtual Error SetOutputFormat(DWORD format) = 0;
		
	public:
		VirtualUnit * CreateVirtual(void);
		virtual VirtualAudioDAC * CreateVirtualAudioDAC(void) = 0;
	};
	
class VirtualAudioDAC : public VirtualUnit
	{
	private:
		AudioDAC	*	device;
	protected:
		WORD leftVolume;
		WORD rightVolume;
		BOOL mute;		
		DWORD inputFormat;
		DWORD outputFormat;
	public:
		VirtualAudioDAC(AudioDAC * device);
		Error Configure(TAG __far * tags);
		Error Preempt(VirtualUnit * previous);
	};

inline VirtualUnit * AudioDAC::CreateVirtual(void) {return CreateVirtualAudioDAC();}

MKTAG(AUDIODAC_AC3_CENTER_VOLUME,			AUDIO_DAC_UNIT,	0x1001,	WORD)
MKTAG(AUDIODAC_AC3_LEFT_SURROUND_VOLUME,  AUDIO_DAC_UNIT,	0x1002,	WORD)
MKTAG(AUDIODAC_AC3_RIGHT_SURROUND_VOLUME,	AUDIO_DAC_UNIT,	0x1003,	WORD)
MKTAG(AUDIODAC_AC3_SUBWOOFER_VOLUME,		AUDIO_DAC_UNIT,	0x1004,	WORD)

class AC3AudioDAC : public AudioDAC
	{
	friend class VirtualAC3AudioDAC;
	protected:
		virtual Error SetCenterVolume(WORD volume) = 0;
		virtual Error SetLeftSurroundVolume(WORD volume) = 0;
		virtual Error SetRightSurroundVolume(WORD volume) = 0;
		virtual Error SetSubwooferVolume(WORD volume) = 0;
	public:
		VirtualAudioDAC * CreateVirtualAudioDAC(void);
		virtual VirtualAC3AudioDAC * CreateVirtualAC3AudioDAC(void) = 0;
	};

class VirtualAC3AudioDAC : public VirtualAudioDAC
	{
	private:
		AC3AudioDAC	*	device;
	protected:
		WORD	centerVolume;
		WORD	leftSurroundVolume;
		WORD	rightSurroundVolume;
		WORD	subwooferVolume;
	public:
		VirtualAC3AudioDAC(AC3AudioDAC * device);
		Error Configure(TAG __far * tags);
		Error Preempt(VirtualUnit * previous);		
	};
	
inline VirtualAudioDAC * AC3AudioDAC::CreateVirtualAudioDAC(void) {return CreateVirtualAC3AudioDAC();}

class EmulatedAC3AudioDAC : public AC3AudioDAC
	{
	friend class VirtualEmulatedAC3AudioDAC;
	protected:
		VirtualAudioDAC		*	front;
		VirtualAudioDAC		*	surround;
		VirtualAudioDAC		*	effect;
	
		Error SetLeftVolume(WORD volume);
		Error SetRightVolume(WORD volume);
		Error SetMute(BOOL mute);
		Error SetInputFormat(DWORD format);
		Error SetOutputFormat(DWORD format);
		Error SetCenterVolume(WORD volume);
		Error SetLeftSurroundVolume(WORD volume);
		Error SetRightSurroundVolume(WORD volume);
		Error SetSubwooferVolume(WORD volume);
	
	public:
		EmulatedAC3AudioDAC(VirtualAudioDAC * front, VirtualAudioDAC * surround, VirtualAudioDAC * effect);	

		Error Configure(TAG __far * tags);

		VirtualAC3AudioDAC * CreateVirtualAC3AudioDAC(void);
	};
	
class VirtualEmulatedAC3AudioDAC : public VirtualAC3AudioDAC
	{
	private:
		EmulatedAC3AudioDAC	*	device;
	protected:
		BOOL	idle;
	public:
		VirtualEmulatedAC3AudioDAC(EmulatedAC3AudioDAC * device, BOOL idle = FALSE) : VirtualAC3AudioDAC(device) 
			{this->device = device; this->idle = idle;}
		Error Preempt(VirtualUnit * previous);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\generic\audtypes.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:			library\hardware\audio\generic\audtypes.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		30.11.95
//
// PURPOSE:		Common audio data types.
//
// HISTORY:

#ifndef AUDTYPES_H
#define AUDTYPES_H


//
// Supported sample rates for codecs
//
enum AudioSampleRate		{
									RATE_11_025,				// 11.025 kHz
									RATE_22_05,					// 22.050 kHz
									RATE_44_10,					// 44.100 kHz
									RATE_8,						//  8.000 kHz
									RATE_32_0,					// 32.000 kHz
									RATE_48_0					// 48.000 kHz
								};

//
// Supported data formats for codecs
//
enum AudioDataFormat		{
									UNSIGNED_8 		= 0,		// 8 bit Unsigned
									ULAW_8,						// 8 bit u-Law encoded
									SIGNED_16_LE,				// 16 bit Signed Little Endian
									ALAW_8,						// 8 bit a-Law encoded
									ADPCM_4 			= 5,		// 4 bit ADPCM
									SIGNED_16_BE				// 16 bit Signed Big Endian
								};
//
// Distinction between stereo and mono for all audio devices
//
enum AudioMode 			{
									AUDIO_MONO,
									AUDIO_STEREO
								};

//
// Distinction between channels for all audio devices
//
enum AudioChannel 		{
									CHANNEL_LEFT,
									CHANNEL_RIGHT,
									CHANNEL_BOTH,					// Both left & right channel affected
									CHANNEL_CENTER,
									CHANNEL_SURROUND_LEFT,
									CHANNEL_SURROUND_RIGHT,
									CHANNEL_SUBWOOFER,
									CHANNEL_ALL_SURROUND			// All channels affected
								};

//
// Defines if front or rear fader
//
enum FaderType {FADER_FRONT, FADER_REAR};

//
// Possible values for Overrange Detection
//
enum AudioOverrange		{
									LESS_MINUS_1_DB,
									MINUS_1_TO_ZERO_DB,
									ZERO_TO_1_DB,
									GREATER_1_DB
								};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\generic\encdec.h ===
// FILE:			library\hardware\audio\generic\encdec.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		12.01.95
//
// PURPOSE:		Base class for audio encoders/decoders/codecs.
//
// HISTORY:

#ifndef ENCDEC_H
#define ENCDEC_H

#include "austrdev.h"
#include "bufstrms.h"

//
// Special tags common for audio encoders and decoders
//
MKTAG (AUDIO_CALIBRATE,			AUDIO_STREAMDEV_UNIT, 0x0010, BOOL)

//
// Special audio encoder tags
//
MKTAG (AUDIO_ENCODER_HOOK,		AUDIO_ENCODER_UNIT, 0x0101, AudioBufferHookPtr)
MKTAG (AUDIO_OVERRANGE_LEFT,	AUDIO_ENCODER_UNIT, 0x0102, AudioOverrange)
MKTAG (AUDIO_OVERRANGE_RIGHT,	AUDIO_ENCODER_UNIT, 0x0103, AudioOverrange)

//
// Organization in this DWORD: (in big endian) MINL MINR MAXL MAXR
//
MKTAG (AUDIO_ENCODER_DATA_PEAK_INFO,	AUDIO_ENCODER_UNIT, 0x0104, DWORD)


// Special audio decoder tags
MKTAG (AUDIO_DECODER_HOOK,		AUDIO_DECODER_UNIT, 0x00000201, AudioBufferHookPtr)

MKTAG (AUDIO_DECODER_DATA_PEAK_INFO,	AUDIO_DECODER_UNIT, 0x0202, DWORD)


//
// Error definitions for encoder
//
#define GNR_AUDENC_CAPTURE_ENABLED	MKERR(ERROR, AUDIO, GENERAL, 0x0300)
#define GNR_AUDENC_CAPTURE_DISABLED	MKERR(ERROR, AUDIO, GENERAL, 0x0301)

//
// Error definitions for decoder
//
#define GNR_AUDEC_PLAYBACK_ENABLED	MKERR(ERROR, AUDIO, GENERAL, 0x0302)
#define GNR_AUDEC_PLAYBACK_DISABLED	MKERR(ERROR, AUDIO, GENERAL, 0x0303)


// 
// Commands for Audio Capture
//
enum AudioCaptureCommand {CAPTURE_START,
								  CAPTURE_STOP,
								  CAPTURE_PAUSE,
								  CAPTURE_RESUME,
								  CAPTURE_SET_POSITION,
								  CAPTURE_GET_POSITION,
								  CAPTURE_BEGIN,
								  CAPTURE_COMPLETE,
								  CAPTURE_END,
								  CAPTURE_FLUSH
								 };

//
// Commands for Audio Playback
//
enum AudioPlaybackCommand {PLAYBACK_START,
									PLAYBACK_STOP,
									PLAYBACK_PAUSE,
									PLAYBACK_RESUME,
									PLAYBACK_SET_POSITION,
									PLAYBACK_GET_POSITION,
									PLAYBACK_BEGIN,
									PLAYBACK_COMPLETE,
									PLAYBACK_END,
									PLAYBACK_FLUSH
									};



#ifndef ONLY_EXTERNAL_VISIBLE


/////////////////////////////////////////////////////////////////////////////////
// Audio Encoder Device Classes (encodes from analog to digital)
/////////////////////////////////////////////////////////////////////////////////


class AudioEncoder : public AudioStreamDevice
	{
	friend class VirtualAudioEncoder;
	protected:
		virtual Error StartCapture() = 0;
		virtual Error StopCapture() = 0;
		virtual Error PauseCapture() = 0;
		virtual Error ResumeCapture() = 0;
		virtual Error BeginCapture() {GNRAISE_OK;}
		virtual Error CompleteCapture() {GNRAISE_OK;}
		virtual Error EndCapture() {GNRAISE_OK;}
		virtual Error Flush() {GNRAISE_OK;}

		virtual Error GetDataPeak(DWORD __far & info) {info = 0L; GNRAISE_OK;}
	};


class ASyncStreamAudioEncoder : public AudioEncoder, protected ASyncEmptyRequest 
	{
	private:
		ASyncInStream	*	stream;
	public:
		ASyncStreamAudioEncoder(ASyncInStream * stream) : AudioEncoder() {this->stream = stream;}
	};


class BufferStreamAudioEncoder : public AudioEncoder, protected BufferStreamCompletionRequest
	{
	private:
		BufferInputStream	*	stream;
	protected:
		DWORD bufferSize;		
	public:
		BufferStreamAudioEncoder(BufferInputStream * stream, DWORD bufferSize) : AudioEncoder()
			{this->stream = stream; this->bufferSize = bufferSize;}
	};


class VirtualAudioEncoder : public VirtualAudioStreamDevice
	{
	private:
		AudioEncoder	*	encoder;
	public:
		VirtualAudioEncoder(AudioEncoder * encoder) : VirtualAudioStreamDevice(encoder) 
			{this->encoder = encoder;}

		virtual Error DoCommand(AudioCaptureCommand com, DWORD param);
	};



/////////////////////////////////////////////////////////////////////////////////
// Audio Decoder Device Classes (decodes from digital to analog)
/////////////////////////////////////////////////////////////////////////////////

class AudioDecoder : public AudioStreamDevice
	{
	friend class VirtualAudioDecoder;
	protected:
		virtual Error StartPlayback() = 0;
		virtual Error StopPlayback() = 0;
		virtual Error PausePlayback() = 0;
		virtual Error ResumePlayback() = 0;
		virtual Error BeginPlayback() {GNRAISE_OK;}
		virtual Error CompletePlayback() {GNRAISE_OK;}
		virtual Error EndPlayback() {GNRAISE_OK;}
		virtual Error Flush() {GNRAISE_OK;}

		virtual Error GetDataPeak(DWORD __far & info) {info = 0L; GNRAISE_OK;}
	};

class ASyncStreamAudioDecoder : public AudioDecoder, protected ASyncRefillRequest
	{
	private:
		ASyncOutStream	*	stream;
	public:
		ASyncStreamAudioDecoder(ASyncOutStream * stream) : AudioDecoder() {this->stream = stream;}
	};


class BufferStreamAudioDecoder : public AudioDecoder, protected BufferStreamCompletionRequest
	{
	private:
		BufferOutputStream	*	stream;
	protected:
		DWORD bufferSize;		
	public:
		BufferStreamAudioDecoder(BufferOutputStream * stream, DWORD bufferSize) : AudioDecoder()
			{this->stream = stream; this->bufferSize = bufferSize;}
	};


class VirtualAudioDecoder : public VirtualAudioStreamDevice {
	private:
		AudioDecoder	*	decoder;
	public:
		VirtualAudioDecoder(AudioDecoder * decoder) : VirtualAudioStreamDevice(decoder)
			{this->decoder = decoder;}

		virtual Error DoCommand(AudioPlaybackCommand com, DWORD param);
	};

#endif // ONLY_EXTERNAL_VISIBLE


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\generic\bufstrms.h ===
// FILE:			library\hardware\audio\generic\bufstrms.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1997 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		10.03.97
//
// PURPOSE:		Buffer based streams classes
//
// HISTORY:

#ifndef BUFSTRMS_H
#define BUFSTRMS_H

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"

#ifndef ONLY_EXTERNAL_VISIBLE

#define NUM_STREAM_BUFFERS		32


///////////////////////////////////////////////////////////////////////////////
// StreamFIFO Base Class and related classes
///////////////////////////////////////////////////////////////////////////////


//
// Event Class called from StreamFIFO when a certain FIFO output position is reached
//
class StreamFIFOEvent
	{
	public:
		virtual void FIFOEventReached(DWORD position) = 0;
	};

//
// Request Class called from StreamFIFO when refilling/emptying of data necessary
//
class StreamFIFORequest
	{
	public:
		virtual void FIFORequest(void) = 0;
	};


//
// Base Class for FIFOs to accomplish a continuous stream of data
//
class StreamFIFO
	{ 
	protected:
		StreamFIFORequest			*	req;
		StreamFIFOEvent			*	event;
		
	public:
		virtual Error Flush(void) = 0;
		
		virtual Error BeginTransfer(StreamFIFORequest * req,
											 BOOL  encode,
											 DWORD bytesPerSecond,
											 BYTE  dummyFill,
											 DWORD format,
											 DWORD mode,
											 DWORD initialSkip) = 0;
		virtual Error CompleteTransfer(void) = 0;

		virtual Error StartTransfer(void) = 0;
		virtual Error StopTransfer(void) = 0;
		virtual Error EndTransfer(void) = 0;

		virtual Error WriteBytes(HBPTR buff, DWORD size, DWORD __far & done) = 0;
		virtual Error ReadBytes(HBPTR buff, DWORD size, DWORD __far & done) = 0;
		
		virtual Error ReadInputCounter(DWORD __far & done) = 0;
		virtual Error ReadOutputCounter(DWORD __far & done) = 0;

		virtual DWORD BytesFull(void) = 0;
		virtual DWORD BytesFree(void) = 0;
		
		virtual Error ScheduleEvent(StreamFIFOEvent * event, DWORD position) = 0;		
		
		virtual Error SuspendCallbacks(void) = 0;
		virtual Error ResumeCallbacks(void) = 0;
		
		virtual Error GetDataPeak(DWORD __far & info, BOOL encode) {info = 0L; GNRAISE_OK;}
	};



///////////////////////////////////////////////////////////////////////////////
// BufferStream Base Class and related classes
///////////////////////////////////////////////////////////////////////////////


//
// Request called from a BufferStream when processing of a Buffer is completed
//
class BufferStreamCompletionRequest
	{
	public:
		virtual void BufferCompletionRequest(HBPTR buff, DWORD size, DWORD bufferID, DWORD done) = 0;
	};


//
// Realizes FIFO based streams whose data is delivered/retrieved in chunks (buffers)
//
class BufferStream : protected StreamFIFOEvent, protected StreamFIFORequest
	{
   protected:
		StreamFIFO	*	fifo;

   	BufferStreamCompletionRequest	*	req;

		struct
			{
			HBPTR		data;
			DWORD		size;
			DWORD		bufferID;
			} buffers[NUM_STREAM_BUFFERS];

		WORD	firstBuffer, lastBuffer;

		DWORD	firstPosition;
		DWORD	basePosition;

		DWORD	currentDone;
		
		DWORD startThreshold;
		
		virtual void FIFOEventReached(DWORD position) = 0;
		virtual void FIFORequest(void) = 0;
		
	public:
   	BufferStream(StreamFIFO * fifo);

		Error SetCompletionRequest(BufferStreamCompletionRequest * req) {this->req = req; GNRAISE_OK;}		

		virtual Error BeginTransfer(DWORD bytesPerSecond) = 0;
		virtual Error StartTransfer(void) = 0;
		virtual Error CompleteTransfer(void) = 0;
		virtual Error StopTransfer(void) = 0;
		virtual Error EndTransfer(void) = 0;

		virtual Error GetPosition(DWORD __far * position) = 0;
		virtual Error SetPosition(DWORD position) = 0;

		virtual Error AddBuffer(HBPTR data, DWORD size, DWORD bufferID) = 0;
		virtual Error FlushBuffers(void) = 0;
		
		virtual Error GetDataPeak(DWORD __far & info) = 0;
	};



///////////////////////////////////////////////////////////////////////////////
// BufferOutputStream (for Playback)
///////////////////////////////////////////////////////////////////////////////

class BufferOutputStream : public BufferStream
	{
	private:
		DWORD state;
		int	suspendCount;
 		WORD	currentBuffer;
 	protected:
	   
		void FIFOEventReached(DWORD position);
		void FIFORequest(void);
	public:
		BufferOutputStream(StreamFIFO * fifo);

		virtual Error BeginTransfer(DWORD bytesPerSecond, BYTE dummyFill, DWORD format, DWORD mode);
		Error BeginTransfer(DWORD bytesPerSecond) {GNRAISE(BeginTransfer(bytesPerSecond, 0, 0L, 0L));}
		Error CompleteTransfer(void);
		Error StartTransfer(void);
		Error StopTransfer(void);
		Error EndTransfer(void);

		Error GetPosition(DWORD __far * position);
		Error SetPosition(DWORD position);

		Error AddBuffer(HBPTR data, DWORD size, DWORD bufferID);
		Error FlushBuffers(void);

		Error GetDataPeak(DWORD __far & info) {GNRAISE(fifo->GetDataPeak(info, FALSE));}
	};


///////////////////////////////////////////////////////////////////////////////
// BufferInputStream (for Capture)
///////////////////////////////////////////////////////////////////////////////

class BufferInputStream : public BufferStream
	{
	private:
		DWORD state;
		int	suspendCount;

		DWORD	initialSkip;	// Number of bytes that are skipped in the beginning
	protected:
		void FIFOEventReached(DWORD position);
		void FIFORequest(void);
	public:
		BufferInputStream(StreamFIFO * fifo);

		Error BeginTransfer(DWORD bytesPerSecond)
			{GNRAISE(BeginTransfer(bytesPerSecond, 0L, 0L, 0L));}

		virtual Error BeginTransfer(DWORD bytesPerSecond, DWORD format, DWORD mode, DWORD initialSkip = 0L);

		Error CompleteTransfer(void);
		Error StartTransfer(void);
		Error StopTransfer(void);
		Error EndTransfer(void);

		Error GetPosition(DWORD __far * position);
		Error SetPosition(DWORD position);

		Error AddBuffer(HBPTR data, DWORD size, DWORD bufferID);
		Error FlushBuffers(void);
	
		Error GetDataPeak(DWORD __far & info) {GNRAISE(fifo->GetDataPeak(info, TRUE));}
	};


#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\generic\austrdev.h ===
// FILE:			library\hardware\audio\generic\austrdev.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		30.11.95
//
// PURPOSE:		Base class for audio stream devices (encoders/decoders/codecs).
//
// HISTORY:

#ifndef AUSTRDEV_H
#define AUSTRDEV_H

#include "library\common\gnerrors.h"
#include "library\common\tags.h"
#include "library\common\tagunits.h"
#include "library\common\virtunit.h"
#include "audtypes.h"
#include "library\common\hooks.h"
#include "audstrms.h"

struct AudioBufferMsg
	{
	FPTR				buffer;
	DWORD				bufferID;
	DWORD				bytesDone;
	};
	
MKHOOK(AudioBuffer, AudioBufferMsg);

typedef AudioBufferHook __far * AudioBufferHookPtr;

//
// General tags for Audio Stream Device
//
MKTAG (AUDIO_SAMPLE_RATE,			AUDIO_STREAMDEV_UNIT, 0x00000001, AudioSampleRate)		// Audio sample rate
MKTAG (AUDIO_DATA_FORMAT,			AUDIO_STREAMDEV_UNIT, 0x00000002, AudioDataFormat)		// Format of data to encode
MKTAG (AUDIO_MODE,					AUDIO_STREAMDEV_UNIT, 0x00000003, AudioMode)				// Mono/stereo selection
// Do not use this tag when a successor defines its own hook tag:
MKTAG (AUDIO_HOOK,					AUDIO_STREAMDEV_UNIT, 0x00000004, AudioBufferHookPtr)	// Provide a hook for callbacks.
MKTAG (AUDIO_SAMPLE_FREQUENCY,	AUDIO_STREAMDEV_UNIT, 0x00000005, WORD)					// Audio sample frequency in Hz

#define GNR_AUDIO_BUFFER_SUPPLIED	MKERR(ERROR, AUDIO, GENERAL, 0x01)	
#define GNR_AUDIO_UNSUPPORTED			MKERR(ERROR, AUDIO, GENERAL, 0x02)

#ifndef ONLY_EXTERNAL_VISIBLE

/////////////////////////////////////////////////////////////////////////////////
// Audio Stream Device Classes
/////////////////////////////////////////////////////////////////////////////////

class AudioStreamDevice : public PhysicalUnit {
	friend class VirtualAudioStreamDevice;
	protected:
		AudioBufferHookHandle	hook;

		virtual 	Error SetSampleRate(AudioSampleRate sampleRate) = 0;
		virtual 	Error SetDataFormat(AudioDataFormat format) = 0;
		virtual 	Error SetMode(AudioMode mode) = 0;
		virtual 	Error SetHook(AudioBufferHookPtr hook) {this->hook = hook; GNRAISE_OK;}
		
		virtual	Error SupplyBuffer(HPTR buffer, DWORD size, DWORD bufferID) = 0;

		virtual	Error GetPosition(DWORD __far * position) = 0;
		virtual	Error SetPosition(DWORD position) = 0;

		virtual	Error ProcessChanges() = 0;
	public:
		AudioStreamDevice() {hook = NULL;}	
	};

class VirtualAudioStreamDevice : public VirtualUnit {
	private:
		AudioStreamDevice		* 		unit;	
	protected:
		AudioSampleRate				sampleRate;
		AudioDataFormat				format;
		AudioMode						mode;
		AudioBufferHookPtr			hook;
			
		Error Preempt(VirtualUnit * previous);
	public:
		VirtualAudioStreamDevice(AudioStreamDevice *physical);
		Error Configure(TAG __far * tags);

#if NT_KERNEL
		virtual Error SupplyBuffer(FPTR info, DWORD size, DWORD bufferID);
#else
		virtual Error SupplyBuffer(HPTR buffer, DWORD size, DWORD bufferID);
#endif
		
		virtual Error GetPosition(DWORD __far * position);
		virtual Error SetPosition(DWORD position);

#if NT_KERNEL
		virtual Error PrepareBuffer(FPTR buffer, DWORD size, BOOL readOnly, FPTR __far &info);
		virtual Error UnprepareBuffer(FPTR info);
#endif
	};



#endif // ONLY_EXTERNAL_VISIBLE


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\generic\karaokesetup.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:			library\hardware\audio\generic\karaokesetup.h
// AUTHOR:		Mark Spinnenweber
// COPYRIGHT:	(c) 1996 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		July 28, 2000
//
// PURPOSE:		Definitions for Karaoke data types (used by Karaoke tags)
//
// HISTORY:

#ifndef KARAOKESETUP_H
#define KARAOKESETUP_H

enum KaraokeVoiceEffectType
	{
	KARAOKE_VOICE_EFFECT_NONE = 0,
	KARAOKE_VOICE_EFFECT_ECHO = 1,
	KARAOKE_VOICE_EFFECT_CHORUS = 2,
	KARAOKE_VOICE_EFFECT_REVERB = 3
	};


enum KaraokeVoiceChannelSelection
	{
	KARAOKE_MUSIC_VOICE_TO_LR = 0,
	KARAOKE_VOICE_TO_CENTER   = 1
	};


enum KaraokeWordSizeType
	{
	KARAOKE_WORD_SIZE_16bit = 0,
	KARAOKE_WORD_SIZE_18bit = 1,
	KARAOKE_WORD_SIZE_20bit = 2,
	KARAOKE_WORD_SIZE_24bit = 3
	};

enum KaraokeJustificationType
	{
	KARAOKE_START_JUSTIFIED = 0,
	KARAOKE_END_JUSITIFIED  = 1
	};

enum KaraokePCMOutputModeType
	{
	KARAOKE_PCM_OUTPUT_MODE_2Channel = 0,
	KARAOKE_PCM_OUTPUT_MODE_6Channel = 1
	};

enum KaraokePCMByteOrderType
	{
	KARAOKE_PCM_BYTE_ORDER_LSB_FIRST = 0,
	KARAOKE_PCM_BYTE_ORDER_MSB_FIRST = 1
	};

enum KaraokeVoiceSamplingFrequencyType
	{
	KARAOKE_SAMPLING_FREQUENCY_12kHz = 0,
	KARAOKE_SAMPLING_FREQUENCY_11_025KHz = 1,
	KARAOKE_SAMPLING_FREQUENCY_10kHz = 2
	};

enum KaraokeMusicSamplingFrequencyType
	{
	KARAOKE_SAMPLING_FREQUENCY_48kHz = 0,
	KARAOKE_SAMPLING_FREQUENCY_44_1KHz = 1,
	KARAOKE_SAMPLING_FREQUENCY_32kHz = 2
	};

enum KaraokeSamplingFrequencyType
	{
	KARAOKE_SAMPLING_FREQUENCY_256Fs = 0,
	KARAOKE_SAMPLING_FREQUENCY_384Fs = 1
	};

enum KaraokeCanInputModeType
	{
	KARAOKE_16_SLOTS_MODE = 0,
	KARAOKE_16_SLOTS_MODE_LSB_FIRST = 1,
	KARAOKE_32_SLOTS_MODE_LEFT_ALIGNED = 2,
	KARAOKE_32_SLOTS_MODE_RIGHT_ALIGNED = 3,
	KARAOKE_32_SLOTS_MODE_I2S_MODE = 4,
	KARAOKE_32_SLOTS_MODE_SIGN_EXTENDED = 5,
	KARAOKE_32_SLOTS_MODE_8_BIT_DATA = 6,
	KARAOKE_32_SLOTS_MOD16_BIT_DATA = 7
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\generic\wmixer.h ===
// FILE:       library\hardware\audio\generic\wmixer.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1995 Viona Development GmbH.  All Rights Reserved.
// CREATED:		22.01.1996
//
// PURPOSE: 	Base class for Windows Sound System compatible Mixers
//
// HISTORY:

#define WINVER 0x0400

#ifndef WMIXER_H
#define WMIXER_H

#include "windows.h"
#include "mmsystem.h"
#include "mmddk.h"

#include "..\common\prelude.h"
#include "..\general\lists.h"
#include "..\common\gnerrors.h"

class MixerClient	: public Node {
	public:
		DWORD					openFlags;                                     
		HMIXER				mixerHandle;			// handle that will be used
		DWORD					procCallback;			// function callback
		UINT					callbackType;			// callback
		DWORD					instance;				// app's private instance information
//	PHARDWAREINSTANCE	phwi;							// speicher spter die Hardware-Instanz... PHARDWAREINSTANCE muss noch als Klasse
															// definiert werden.
	};

class MixerClientList : public List {
	public:
		~MixerClientList();

		MixerClient* FindClient(MixerClient* client);
		void NotifyClients(DWORD controlID);
	};

class WindowsMixer {
	private:
		MixerClientList	*	clients;
		
		UnitSet	busterUnits;
		
		DWORD		enableCount;
		BOOL		enabled;
	protected:
		DWORD ctrlValues[MAXCONTROLS][MAXCHANNELS];
	
		DWORD GetDestLineInfo(LPMIXERLINE mixerLine, DWORD destination);
		DWORD GetSourceLineInfo(LPMIXERLINE mixerLine, DWORD source);
		BOOL	RetrieveINIValues(void);
		BOOL	StoreINIValues(void);
	public:
		WindowsMixer();
		~WindowsMixer();

		DWORD Enable(void);
		DWORD Disable(void);
		DWORD GetNumDevs(void);
		DWORD Open(UINT devID, DWORD __far * user, LPMIXEROPENDESC openDesc, DWORD openFlags);
		DWORD GetDevCaps(MIXERCAPS __far * mc);	// fr PnP: MDEVICECAPSEX-Struktur!
		DWORD Close(MixerClient* client);
		DWORD GetLineInfo(MixerClient* client, LPMIXERLINE mixerLine, DWORD flags);
		DWORD GetLineControls(MixerClient* client, LPMIXERLINECONTROLS mlCtrls, DWORD flags);
		DWORD GetControlDetails(LPMIXERCONTROLDETAILS mCtrlDetails, DWORD flags);
		DWORD SetControlDetails(LPMIXERCONTROLDETAILS mCtrlDetails, DWORD flags);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\generic\stereodc.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:			library\hardware\audio\generic\stereodc.h
// AUTHOR:		Stefan Herr
// COPYRIGHT:	(c) 1996 Viona Development.  All Rights Reserved.
// CREATED:		22.08.95
//
// PURPOSE:		Base class for stereo decoders (FM/TV stereo decoders)
//
// HISTORY:

#ifndef STEREODC_H
#define STEREODC_H

enum SignalMode	{ST_MONO,					// Either TV or FM is received mono only
						 ST_STEREO,					//    "    "  "  "  "     "    stereo
						 ST_SAP,						// Second audio program (SAP) received for TV
						 ST_UNDEFINED,				// Mode could not be determined (i.e. no signal)
						 ST_AUTOMATIC,				// Only used when setting the mode.
						 ST_STEREO_SAP				// For NTSC TV: Stereo and SAP at the same time.
						 };


#ifndef ONLY_EXTERNAL_VISIBLE

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"
#include "library\common\virtunit.h"
#include "library\common\tagunits.h"
//
// Stereo Decoder tags
//
MKTAG(STEREODEC_MODESELECT,	STEREO_DECODER_UNIT,	0x0001, SignalMode)
MKTAG(STEREODEC_MODEDETECT,	STEREO_DECODER_UNIT,	0x0002, SignalMode)

class StereoDecoder : public PhysicalUnit	{
	friend class VirtualStereoDecoder;
	protected:
		virtual Error GetSignalMode(SignalMode __far & mode) = 0;
		virtual Error SetSignalMode(SignalMode mode) = 0;

		virtual Error ProcessChanges() = 0;
	public:
	};

class VirtualStereoDecoder : public VirtualUnit {
	private:
		StereoDecoder	*	decoder;
	protected:
		SignalMode		mode;
	public:
		VirtualStereoDecoder(StereoDecoder * decoder);
		Error Configure(TAG __far * tags);
		Error Preempt(VirtualUnit * previous);
	};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\ad1845.h ===
// FILE:			library\hardware\audio\specific\ad1845.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1997 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		10.03.97
//
// PURPOSE:		AD 1845 device management class.
//
// HISTORY:

#include "cs4231.h"

#ifndef AD1845_H
#define AD1845_H

// Definitions for Power Down modes of AD1845
#define ADPWRM_NO_PD		0x80000000		// No Power Down, supercedes all other flag bits

#define ADPWRM_TOTAL		0x10000000		// Total 				power down
#define ADPWRM_MIXER		0x00000001		// Mixer + DAC				"
#define ADPWRM_DAC		0x00000002		// DAC only					"
#define ADPWRM_ADC		0x00000004		// ADC 						"


class AD1845StereoCodec : public CS4231StereoCodec {
	protected:
		BOOL	outputLevelAttenuate;
		BOOL	timerEnable;
		BOOL	dacZero;

		WORD	leftMICGain, rightMICGain;
		BOOL	leftMICMixEnable, rightMICMixEnable;

		BOOL	frEnable;
		
		WORD	sourceLeft, sourceRight;
		WORD	sourceGainLeft, sourceGainRight;

		DWORD	xfs;

		Error SetClockDataFormat	(BOOL					capture,
											 AudioSampleRate	sampleRate,
											 AudioDataFormat	format,
											 AudioMode			mode);
	public:
		AD1845StereoCodec(ByteIndexedInOutPort * port, AudioFIFO * fifo, BOOL frEnable = FALSE);
		
		Error Reset						();

	   BOOL  IsThere					(void);

		Error HaltTransfers	(void);
		Error ResumeTransfers(void);
												 
		Error SetAltFeatureI			(BOOL dacZero, BOOL timerEnable, BOOL outputLevelAttenuate);
		Error SetAltFeatureII		(BOOL highPassOn) {GNRAISE_OK;}

		// AD1845 specific
		Error SetMIC					(AudioChannel channel, WORD mixGain, BOOL mixEnable);
		Error SetSampleFreq			(WORD	freq);
		Error SetPowerMode			(DWORD powerMode);

		Error SetInput					(AudioChannel channel, ADInputSource source, WORD gain, BOOL gainEnable);
		Error SetAux					(AudioChannel channel, ADAuxInputs input, WORD attenuation, BOOL mute);
		Error SetLine					(AudioChannel channel, WORD mixGain, BOOL mute);

		virtual Error TestLoopback	(BOOL __far & loopback);

		virtual Error SetXFS			(DWORD xfs);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\adec1845.h ===
// FILE:			library\hardware\audio\specific\adec1845.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1997 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		10.03.97
//
// PURPOSE:		AD 1845 audio decoder class
//
// HISTORY:

#ifndef ADEC1845_H
#define ADEC1845_H

#include "ad1845.h"
#include "..\generic\encdec.h"

#ifndef ONLY_EXTERNAL_VISIBLE


class AudioDecoder1845 : public BufferStreamAudioDecoder {
	friend class VirtualAudioDecoder1845;
	private:
		BufferOutputStream	*	stream;
		AD1845StereoCodec		*	codec;

		AudioSampleRate	sampleRate;
		AudioMode			mode;
		BOOL					calibrate;
		WORD					sampleFreq;

		int					state;

		DWORD					bytesPerSample;
		DWORD					channels;
		BYTE					dummyFill;
	protected:
		DWORD	changed;

		AudioDataFormat	format;

		Error SetSampleRate(AudioSampleRate sampleRate);
		Error SetDataFormat(AudioDataFormat format);
		Error SetMode(AudioMode mode);

		virtual Error SetCalibrate(BOOL calibrate);
		virtual Error SetSampleFrequency(WORD sampleFreq);
		
		Error SupplyBuffer(HPTR buffer, DWORD size, DWORD bufferID);

		Error GetPosition(DWORD __far * position);
		Error SetPosition(DWORD position);

		Error BeginPlayback();
		Error EndPlayback();

		Error	StartPlayback();
		Error	StopPlayback();

		Error CompletePlayback();
		Error Flush();

		Error PausePlayback();
		Error ResumePlayback();

		Error ProcessChanges();

		Error GetDataPeak(DWORD __far & info) {GNRAISE(stream->GetDataPeak(info));}
	public:
		AudioDecoder1845(BufferOutputStream	*	stream,
							  AD1845StereoCodec	*	codec,
							  DWORD bufferSize);

		VirtualUnit * CreateVirtual(void);

		void BufferCompletionRequest(HBPTR buff, DWORD size, DWORD bufferID, DWORD done);
	};

class VirtualAudioDecoder1845 : public VirtualAudioDecoder {
	private:
		AudioDecoder1845		* 		unit;	
	protected:
 		BOOL	calibrate;
		WORD	sampleFreq;
		
		Error Preempt(VirtualUnit * previous);
	public:
		VirtualAudioDecoder1845(AudioDecoder1845 * physical);

		Error Configure(TAG __far * tags);

	};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\ad1846.h ===
// FILE:			library\hardware\audio\specific\ad1846.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		30.11.95
//
// PURPOSE:		Class for Analog Devices 1846 compatible stereo codecs. 
//
// HISTORY:

#ifndef AD1846_H
#define AD1846_H

#include "library\common\gnerrors.h"
#include "library\lowlevel\hardwrio.h"
#include "library\hardware\clocks\generic\clocks.h"
#include "..\generic\audtypes.h"
#include "..\generic\aucodecs.h"
#include "..\generic\audfifos.h"

#ifndef ONLY_EXTERNAL_VISIBLE

//
// Special data types for AD1846 compatible codecs.
//
enum ADInputSource	{AD_INPUT_LINE,
							 AD_INPUT_AUX1,
							 AD_INPUT_MICROPHONE,
							 AD_INPUT_POSTMIXED_DAC,
							 AD_INPUT_AUX2 = AD_INPUT_POSTMIXED_DAC};
							 
enum ADAuxInputs 		{AD_AUX1, AD_AUX2};

enum ADClockSource	{CS_XTAL1, CS_XTAL2};

enum ADDivideFactor	{DF_3072, DF_1536, DF_896, DF_768, DF_448, DF_384, DF_512, DF_2560};


//
// Error definitions
//
#define GNR_AUDIO_MODE_CHANGE_FAILED	MKERR(ERROR, AUDIO, GENERAL, 0x0501)
#define GNR_AUDIO_ILLEGAL_DATA_FORMAT	MKERR(ERROR, AUDIO, GENERAL, 0x0502)
#define GNR_AUDIO_ILLEGAL_SAMPLE_RATE	MKERR(ERROR, AUDIO, GENERAL, 0x0503)

//
// Misc. definitions.
//
#define MODECHANGE_TIMEOUT 1000	// Should be sufficient for the lowest sample rate



class AD1846StereoCodec : public AudioCodec {
	friend class AD1846XCTLPort;
	protected:
		PLLClockGenerator		*	clock;
		ByteIndexedInOutPort *	indPort;
		ByteIndexedInOutPort *	port;
		AudioFIFO				*	fifo;

		ADClockSource				clockSource;					// Current clock source as set by SetClockDataFormat()
		BOOL							clockSrcChangeable;			// Changes of clock source allowed?

		virtual Error ModeChangeEnable(BOOL enable);
		virtual Error WaitModeChangeFinish();
		virtual Error WaitChipReprogram();

		virtual Error SetClockDataFormat		(BOOL					capture,
														 AudioSampleRate	sampleRate,
														 AudioDataFormat	format,
														 AudioMode			mode);
	public:
		BitIndexedOutputPort	*	xctlPort;

		AD1846StereoCodec(ByteIndexedInOutPort *	port, AudioFIFO * fifo);
		
		~AD1846StereoCodec();

		Error InitPlayback	(void);
		Error EndPlayback		(void);
		
		Error InitCapture		(void);
		Error EndCapture		(void);

		Error HaltTransfers	(void);
		Error ResumeTransfers(void);

		virtual Error FIFOTest					(void);				// Just for test purposes!!!!!		

	   virtual Error Reset						(void);
	   virtual BOOL  IsThere					(void) {return TRUE;}
	   
		virtual void SetClockGenerator		(PLLClockGenerator	*	clock) {this->clock = clock;}

		virtual Error InstallPlaybackHook	(void); 
		virtual Error InstallCaptureHook		(void);

		virtual Error SetTransferRequest		(BOOL enable);
		virtual Error SetInterrupt				(BOOL enable);
		virtual Error SetPlaybackDMA			(BOOL enable);
		virtual Error SetCaptureDMA			(BOOL enable);
		virtual Error SetXCTL					(BYTE xctl);
				
		virtual Error SetInput					(AudioChannel channel, ADInputSource source, WORD gain, BOOL gainEnable);
		virtual Error SetAux						(AudioChannel channel, ADAuxInputs input, WORD attenuation, BOOL mute);
		virtual Error SetDAC						(AudioChannel channel, WORD attenuation, BOOL mute);

		virtual Error SetCaptureDataFormat	(AudioSampleRate	sampleRate,
														 AudioDataFormat	format,
														 AudioMode			mode)
															{return SetClockDataFormat(TRUE, sampleRate, format, mode);}

		virtual Error SetPlaybackDataFormat	(AudioSampleRate	sampleRate,
														 AudioDataFormat	format,
														 AudioMode			mode)
															{return SetClockDataFormat(FALSE, sampleRate, format, mode);}
																			 
		virtual Error SetAutoCalibrate		(BOOL calibrate);
		virtual Error SetLoopback				(BOOL enable, WORD attenuation);
		
		virtual Error GetOverrange				(AudioChannel channel, AudioOverrange __far & rangeLevel);

		virtual Error GetStatus					(BYTE __far & status);

		// CS4231 specific, but defined here already for consistent class hierarchy
		virtual Error SetMode2					(BOOL mode2) {GNRAISE_OK;}
		virtual Error SetLine					(AudioChannel channel, WORD mixGain, BOOL mute) {GNRAISE_OK;}
		virtual Error SetMonoInOut				(WORD attenuation, BOOL outputMute, BOOL inputMute) {GNRAISE_OK;}
		virtual Error SetAltFeatureI			(BOOL dacZero, BOOL timerEnable, BOOL outputLevelAttenuate) {GNRAISE_OK;}
		virtual Error SetAltFeatureII			(BOOL highPassOn) {GNRAISE_OK;}

		// AD1845 specific
		virtual Error SetMIC						(AudioChannel channel, WORD mixGain, BOOL mixEnable) {GNRAISE_OK;}
		virtual Error SetSampleFreq			(WORD	freq) {GNRAISE_OK;}
		virtual Error SetPowerMode				(DWORD powerMode) {GNRAISE_OK;}
	};


#endif // ONLY_EXTERNAL_VISIBLE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\ad1846rg.h ===
// FILE:			library\hardware\audio\specific\ad1846rg.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1997 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		09.06.97
//
// PURPOSE:		Register definitions for AD1846 audio codec
//
// HISTORY:

#ifndef AD1846RG_H
#define AD1846RG_H

///////////////////////////////////////////////////////////////////////////////
// Definitions for AD 1846
///////////////////////////////////////////////////////////////////////////////

//
// Direct registers
//

// Index Address Register (R0)
#define AD1846REG_IDXADR	0

#define AD1846IDX_INIT		7
#define AD1846IDX_MCE		6
#define AD1846IDX_TRD		5
#define AD1846IDX_IXA		0, 5

// Indexed Data Register (R1)
#define AD1846REG_IDXDDATA	1

#define AD1846IDX_CUL		7
#define AD1846IDX_CLR		6
#define AD1846IDX_CRDY		5
#define AD1846IDX_SOUR		4
#define AD1846IDX_PUL		3
#define AD1846IDX_PLR		2
#define AD1846IDX_PRDY		1
#define AD1846IDX_INT		0

// Status Register (R2)
#define AD1846REG_STATUS	2

// Capture/Playback IO Data Register (R3)
#define AD1846REG_IODAT		3

//
// Indirect registers
// 

// Left input control register (I0)
#define AD1846REG_LIC		0

#define AD1846IDX_LSS		6, 2
#define AD1846IDX_LMGE		5
#define AD1846IDX_LIG		0, 4

// Right input control register (I1)
#define AD1846REG_RIC		1

#define AD1846IDX_RSS		6, 2
#define AD1846IDX_RMGE		5
#define AD1846IDX_RIG		0, 4

// Left auxiliary #1 input control (I2)
#define AD1846REG_LAUX1		2

#define AD1846IDX_LMX1		7
#define AD1846IDX_LX1A		0, 5

// Right auxiliary #1 input control (I3)
#define AD1846REG_RAUX1		3

#define AD1846IDX_RMX1		7
#define AD1846IDX_RX1A		0, 5

// Left auxiliary #2 input control (I4)
#define AD1846REG_LAUX2		4

#define AD1846IDX_LMX2		7
#define AD1846IDX_LX2A		0, 5

// Right auxiliary #2 input control (I5)
#define AD1846REG_RAUX2		5

#define AD1846IDX_RMX2		7
#define AD1846IDX_RX2A		0, 5

// Left DAC control (I6)
#define AD1846REG_LDAC		6

#define AD1846IDX_LDM		7
#define AD1846IDX_LDA		0, 6

// Right DAC control (I7)
#define AD1846REG_RDAC		7

#define AD1846IDX_RDM		7
#define AD1846IDX_RDA		0, 6

// Clock and data format register (I8)
#define AD1846REG_CLOCKFMT	8

#define AD1846IDX_FMT		6, 2		// MSB should be always set to 0!
#define AD1846IDX_CL			5
#define AD1846IDX_SM			4
#define AD1846IDX_CFS		1, 3
#define AD1846IDX_CSS		0

// Interface configuration register (I9)
#define AD1846REG_IFCFG		9

#define AD1846IDX_CPIO		7
#define AD1846IDX_PPIO		6
#define AD1846IDX_ACAL		3
#define AD1846IDX_SDC		2
#define AD1846IDX_CEN		1
#define AD1846IDX_PEN		0

// Pin control register (I10)
#define AD1846REG_PINCTRL	10

#define AD1846IDX_XCTL		6,2
#define AD1846IDX_IEN		1

// Test and initialization register (I11)
#define AD1846REG_TESTINI	11

#define AD1846IDX_COR		7
#define AD1846IDX_PUR		6
#define AD1846IDX_ACI		5
#define AD1846IDX_DRS		4
#define AD1846IDX_ORR		2, 2
#define AD1846IDX_ORL		0, 2

// Miscellaneous control register (I12)
#define AD1846REG_MISC		12

#define AD1846IDX_ID			0, 4

// Digital mix control register (I13)
#define AD1846REG_DMIXCTRL	13

#define AD1846IDX_DMA		2, 6
#define AD1846IDX_DME		0

// Upper Base count register (I14)
#define AD1846REG_UBCOUNT	14

// Lower Base count register (I15)
#define AD1846REG_LBCOUNT	15

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\adec1846.h ===
// FILE:			library\hardware\audio\specific\adec1846.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		07.12.95
//
// PURPOSE:		AD1846 audio decoder class
//
// HISTORY:

#ifndef ADEC1846_H
#define ADEC1846_H

#include "library\general\asncstrm.h"
#include "ad1846.h"
#include "..\generic\encdec.h"

#ifndef ONLY_EXTERNAL_VISIBLE

#define CHANGED_FORMAT			MKFLAG(0)
#define CHANGED_CALIBRATE		MKFLAG(1)

class AudioDecoder1846 : public ASyncStreamAudioDecoder {
	friend class VirtualAudioDecoder1846;
	private:
		ASyncOutStream		*	stream;
		AD1846StereoCodec *	codec;
		
		BYTE __huge	*	buffer;
		DWORD				bufferID;
		BYTE __huge *	pbuffer;
		DWORD				pbufferID;
		BYTE __huge *	ppbuffer;
		DWORD				ppbufferID;
		
		
		DWORD	bytesRemaining;
		DWORD bytesDone;

		BOOL	playbackEnabled;
		
		AudioSampleRate	sampleRate;
		AudioMode			mode;
		BOOL					calibrate;

		BOOL					paused;
	protected:
		DWORD	changed;

		AudioDataFormat	format;

		Error SetSampleRate(AudioSampleRate sampleRate);
		Error SetDataFormat(AudioDataFormat format);
		Error SetMode(AudioMode mode);

		virtual Error SetCalibrate(BOOL calibrate);
		
		Error SupplyBuffer(HPTR buffer, DWORD size, DWORD bufferID);

		Error GetPosition(DWORD __far * position);
		Error SetPosition(DWORD position);

		Error	StartPlayback();
		Error	StopPlayback();
		
		Error PausePlayback();
		Error ResumePlayback();

		Error ProcessChanges();
	public:
		AudioDecoder1846(ASyncOutStream		*	stream,
							  AD1846StereoCodec	*	codec);

		VirtualUnit * CreateVirtual(void);

		void	RefillRequest(DWORD free);
	};

class VirtualAudioDecoder1846 : public VirtualAudioDecoder {
	private:
		AudioDecoder1846		* 		unit;	
	protected:
 		BOOL	calibrate;

		Error Preempt(VirtualUnit * previous);
	public:
		VirtualAudioDecoder1846(AudioDecoder1846 * physical);
		Error Configure(TAG __far * tags);
	};

#endif // ONLY_EXTERNAL_VISIBLE


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\adec4231.h ===
// FILE:			library\hardware\audio\specific\adec4231.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1995, 1996 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		21.02.96
//
// PURPOSE:		CS4231 audio decoder class
//
// HISTORY:

#ifndef ADEC4231_H
#define ADEC4231_H

#include "adec1846.h"

class AudioDecoder4231 : public AudioDecoder1846 {
	friend class VirtualAudioDecoder4231;
	protected:
		Error SetDataFormat(AudioDataFormat format);
	public:
		AudioDecoder4231(ASyncOutStream		*	stream,
							  AD1846StereoCodec	*	codec) : AudioDecoder1846(stream, codec) {;}
	};

class VirtualAudioDecoder4231 : public VirtualAudioDecoder1846 {
	private:
		AudioDecoder4231		* 		unit;	
	public:
		VirtualAudioDecoder4231(AudioDecoder4231 * physical) : VirtualAudioDecoder1846(physical)
			{this->unit = physical;}
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\aenc1845.h ===
// FILE:			library\hardware\audio\specific\aenc1845.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1997 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		10.03.97
//
// PURPOSE:		AD 1845 audio encoder class
//
// HISTORY:

#ifndef AENC1845_H
#define AENC1845_H

#include "ad1845.h"
#include "..\generic\encdec.h"

class AudioEncoder1845 : public BufferStreamAudioEncoder {
	friend class VirtualAudioEncoder1845;
	private:
		BufferInputStream		*	stream;
		AD1845StereoCodec 	* codec;

		AudioSampleRate	sampleRate;
		AudioMode			mode;
		BOOL					calibrate;
		WORD					sampleFreq;
		
		int					state;

		DWORD					bytesPerSample;
		DWORD					channels;
	protected:
		AudioDataFormat	format;
		DWORD	changed;

		Error SetSampleRate(AudioSampleRate sampleRate);
		Error SetDataFormat(AudioDataFormat format);
		Error SetMode(AudioMode mode);

		virtual Error SetSampleFrequency(WORD sampleFreq);
		virtual Error GetOverrange(AudioChannel channel, AudioOverrange __far & overrange);
		virtual Error SetCalibrate(BOOL calibrate);

		Error SupplyBuffer(HPTR buffer, DWORD size, DWORD bufferID);

		Error GetPosition(DWORD __far * position);
		Error SetPosition(DWORD position);

		Error BeginCapture();
		Error EndCapture();

		Error	StartCapture();
		Error	StopCapture();

		Error CompleteCapture();
		Error Flush();

		Error PauseCapture();
		Error ResumeCapture();
		
		Error ProcessChanges();

		Error GetDataPeak(DWORD __far & info) {GNRAISE(stream->GetDataPeak(info));}
	public:
		AudioEncoder1845(BufferInputStream		*	stream,
							  AD1845StereoCodec		*	codec,
							  DWORD 	bufferSize);

		VirtualUnit * CreateVirtual(void);

		void BufferCompletionRequest(HBPTR buff, DWORD size, DWORD bufferID, DWORD done);
	};

class VirtualAudioEncoder1845 : public VirtualAudioEncoder {
	private:
		AudioEncoder1845		* 		unit;	
	protected:
		WORD	sampleFreq;
		BOOL	calibrate;
		
		Error Preempt(VirtualUnit * previous);		
	public:
		VirtualAudioEncoder1845(AudioEncoder1845 * physical);

		Error Configure(TAG __far * tags);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\cs4231.h ===
// FILE:			library\hardware\audio\specific\cs4231.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1995, 1996 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		30.11.95
//
// PURPOSE:		Crystal CS4231 device management class.
//
// HISTORY:

#include "ad1846.h"

#ifndef CS4231_H
#define CS4231_H

enum CSInputSource	{CS_INPUT_LINE,
							 CS_INPUT_AUX1,
							 CS_INPUT_MICROPHONE,
							 CS_INPUT_POSTMIXED_DAC,
							 CS_INPUT_AUX2 = CS_INPUT_POSTMIXED_DAC,
							 CS_INPUT_MONO
							};

class CS4231StereoCodec : public AD1846StereoCodec {
	protected:
		Error SetClockDataFormat		(BOOL					capture,
												 AudioSampleRate	sampleRate,
												 AudioDataFormat	format,
												 AudioMode			mode);
	public:
		CS4231StereoCodec(ByteIndexedInOutPort * port, AudioFIFO * fifo) : AD1846StereoCodec(port, fifo) {;}
		
		Error Reset							(void);

												 
		Error SetMode2					(BOOL mode2);
		Error SetLine					(AudioChannel channel, WORD mixGain, BOOL mute);
		Error SetMonoInOut			(WORD attenuation, BOOL outputMute, BOOL inputMute);
		Error SetAltFeatureI			(BOOL dacZero, BOOL timerEnable, BOOL outputLevelAttenuate);
		Error SetAltFeatureII		(BOOL highPassOn);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\fadr6300.h ===
// FILE:			library\hardware\audio\specific\fadr6300.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1996 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		18.09.96
//
// PURPOSE:		Class for TEA6300 audio fader devices.
//
// HISTORY:

#ifndef FADR6300_H
#define FADR6300_H

#include "library\hardware\audio\generic\audmix.h"

#ifndef ONLY_EXTERNAL_VISIBLE

#include "library\lowlevel\hardwrio.h"
#include "library\common\profiles.h"

#endif

// Inputs of TEA 6300

enum TEA6300Inputs {INPUT_IA, INPUT_IB, INPUT_IC};

// AUDMIX_D_INPUT_MUTE already defined in audmix.h!

#ifndef ONLY_EXTERNAL_VISIBLE

//
// I2C address of TEA6300
//
#define I2C_ADDRESS_TEA6300 	0x80

//
// Number of real but uncontrollable inputs of TEA6300
//
#define FADER_6300_NUM_INPUTS	3

//
// Properties for each input
//
struct TEA6300InputProperties
	{ 
	WORD	volumeLeft, volumeRight;
	BOOL	mute;
	};

class Fader6300 : public AudioMixer {
	friend class VirtualFader6300;

	private:
		DWORD				changed;

		BYTE	source;

		BOOL	mute;
		WORD	volumeLeft,			volumeRight;
		WORD 	faderFront,			faderRear;
		BOOL	faderFrontMute,	faderRearMute;
		int 	bass, treble;

		BOOL	dMute;
		WORD	dVolumeLeft, 		dVolumeRight;
		WORD	dBass, dTreble;

		int	sourceInput;
		
		int	curInput;
		TEA6300InputProperties	props[FADER_6300_NUM_INPUTS];

#if NT_KERNEL
		Profile	* profile;
#else
		HINSTANCE hinst;
#endif
	protected:
		ByteIndexedOutputPort * port;

		virtual Error SetSource(WORD source);
		virtual Error SetMute(BOOL mute);

		virtual Error SetFader(FaderType type, WORD faderValue);
		virtual Error SetFaderMute(FaderType type, BOOL mute);

		virtual Error SetVolume(AudioChannel channel, WORD volume);

		virtual Error SetBass(int bass);
		virtual Error SetTreble(int treble);

		virtual Error DirectSetMute(BOOL dMute);
		virtual Error DirectSetBass(WORD dBass);
		virtual Error DirectSetTreble(WORD dTreble);

		virtual Error DirectSetVolume(AudioChannel channel, WORD dVolume);

		virtual Error DirectSetInput(WORD input);
		virtual Error DirectSetInputVolume(AudioChannel channel, WORD dVolume);
		virtual Error DirectSetInputMute(BOOL mute);

		virtual Error ProcessChanges();
		
	public:
#if NT_KERNEL
		Fader6300(ByteIndexedOutputPort * port, Profile * profile);
#else
		Fader6300(ByteIndexedOutputPort * port, HINSTANCE hinst); 
#endif
		
		Error RetrieveINIValues();
		VirtualAudioMixer * CreateVirtualAudioMixer(void);
	};

class VirtualFader6300 : public VirtualAudioMixer {
	private:
		Fader6300			*	fader;	

		int	curInput;
		TEA6300InputProperties	props[FADER_6300_NUM_INPUTS];

		WORD	source;
		BOOL	mute;
		WORD	volumeLeft,			volumeRight;
		WORD	faderFront,			faderRear;
		BOOL	faderFrontMute,	faderRearMute;
		int 	bass, treble;
		
		WORD	dVolumeLeft, dVolumeRight;
				
		Error Preempt(VirtualUnit *previous);

	public:
		VirtualFader6300(Fader6300 *physical);
		Error Configure(TAG __far * tags);
	};

#endif // ONLY_EXTERNAL_VISIBLE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\aenc1846.h ===
// FILE:			library\hardware\audio\specific\aenc1846.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		07.12.95
//
// PURPOSE:		AD1846 audio encoder class
//
// HISTORY:

#ifndef AENC1846_H
#define AENC1846_H

#include "library\general\asncstrm.h"
#include "ad1846.h"
#include "..\generic\encdec.h"

#ifndef ONLY_EXTERNAL_VISIBLE

#define CHANGED_FORMAT			MKFLAG(0)
#define CHANGED_CALIBRATE		MKFLAG(1)

class AudioEncoder1846 : public ASyncStreamAudioEncoder {
	friend class VirtualAudioEncoder1846;
	private:
		ASyncInStream		*	stream;
		AD1846StereoCodec	*	codec;

		BYTE __huge *	buffer;
		DWORD				bufferID;

		DWORD	bytesRemaining;
		DWORD bytesDone;
		
		BOOL	captureEnabled;

		AudioSampleRate	sampleRate;
		AudioMode			mode;
		BOOL					calibrate;
	protected:
		AudioDataFormat	format;
		DWORD	changed;

		Error SetSampleRate(AudioSampleRate sampleRate);
		Error SetDataFormat(AudioDataFormat format);
		Error SetMode(AudioMode mode);

		virtual Error GetOverrange(AudioChannel channel, AudioOverrange __far & overrange);
		virtual Error SetCalibrate(BOOL calibrate);

		Error SupplyBuffer(HPTR buffer, DWORD size, DWORD bufferID);

		Error GetPosition(DWORD __far * position);
		Error SetPosition(DWORD position);

		Error	StartCapture();
		Error	StopCapture();

		Error PauseCapture();
		Error ResumeCapture();
		
		Error ProcessChanges();
	public:
		AudioEncoder1846(ASyncInStream		*	stream,
							  AD1846StereoCodec	*	codec);

		VirtualUnit * CreateVirtual(void);

		void EmptyRequest(DWORD avail);
	};

class VirtualAudioEncoder1846 : public VirtualAudioEncoder {
	private:
		AudioEncoder1846		* 		unit;	
	protected:
		BOOL	calibrate;

		Error Preempt(VirtualUnit * previous);
	public:
		VirtualAudioEncoder1846(AudioEncoder1846 * physical);
		Error Configure(TAG __far * tags);
	};

#endif // ONLY_EXTERNAL_VISIBLE


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\fadr6320.h ===
// FILE:			library\hardware\audio\specific\fadr6320.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		11.12.95
//
// PURPOSE:		Class for TEA6320 audio fader devices.
//
// HISTORY:

#ifndef FADR6320_H
#define FADR6320_H

#include "library\hardware\audio\generic\audmix.h"

#ifndef ONLY_EXTERNAL_VISIBLE

#include "library\lowlevel\hardwrio.h"
#include "library\common\krnlstr.h"
#include "library\common\profiles.h"

#endif

// Inputs of TEA 6320

enum TEA6320Inputs {INPUT_IA, INPUT_IB, INPUT_IC, INPUT_ID, INPUT_IM};

#ifndef ONLY_EXTERNAL_VISIBLE

//
// I2C address of TEA6320
//
#define I2C_ADDRESS_TEA6320 	0x80

//
// Number of real but uncontrollable inputs of TEA6320
//
#define FADER_6320_NUM_INPUTS	5

//
// Properties for each input
//
struct InputProperties
	{ 
	WORD	faderLeft, faderRight;
	BOOL	mute;
	};


struct Fader6320Config
	{
	BOOL	faderFront;
	BOOL	faderRear;

	int	gainOffset[FADER_6320_NUM_INPUTS];
	};

class Fader6320 : public AudioMixer {
	friend class VirtualFader6320;

	private:
		DWORD				changed;
   
   	Fader6320Config	config;
   
		BYTE	source;
		int 	gain;
		BOOL	mute;
		BOOL	loudness;
		BOOL	zeroCrossing;
		WORD 	faderLeft, faderRight;
		int 	bass, treble;

		WORD	dFaderLeft, dFaderRight;
		BOOL	dMute;
		BOOL	dLoudness;
		WORD	dBass, dTreble;

		int	sourceInput;
		
		int	curInput;
		InputProperties	props[FADER_6320_NUM_INPUTS];

#if !NT_KERNEL && !VXD_VERSION
		HINSTANCE hinst;
#else
		Profile*	profile;
#endif
	protected:
		ByteIndexedOutputPort * port;

		virtual Error SetSource(WORD source);
		virtual Error SetGain(int gain);
		virtual Error SetMute(BOOL mute);
		virtual Error SetLoudness(BOOL loudness);
		virtual Error SetZeroCrossing(BOOL zeroCrossing);

		virtual Error SetFader(AudioChannel channel, WORD faderValue);

		virtual Error SetBass(int bass);
		virtual Error SetTreble(int treble);

		virtual Error DirectSetMute(BOOL dMute);
		virtual Error DirectSetLoudness(BOOL dLoudness);
		virtual Error DirectSetFaderLeft(WORD dFaderLeft);
		virtual Error DirectSetFaderRight(WORD dFaderRight);
		virtual Error DirectSetBass(WORD dBass);
		virtual Error DirectSetTreble(WORD dTreble);

		virtual Error DirectSetInput(WORD input);
		virtual Error DirectSetInputFader(AudioChannel channel, WORD dFaderValue);
		virtual Error DirectSetInputMute(BOOL mute);

		virtual Error ProcessChanges();
		
	public:
#if !NT_KERNEL && !VXD_VERSION
		Fader6320(ByteIndexedOutputPort * port, HINSTANCE hinst); 
		Error RetrieveINIValues(KernelString profileName);
#else
		Fader6320(ByteIndexedOutputPort * port, Profile * profile); 
		Error RetrieveINIValues();
#endif
		Error	Configure(Fader6320Config __far & config);
		
		VirtualAudioMixer * CreateVirtualAudioMixer(void);
	};

class VirtualFader6320 : public VirtualAudioMixer {
	private:
		Fader6320			*	fader;	

		int	curInput;
		InputProperties	props[FADER_6320_NUM_INPUTS];
	protected:
		WORD	source;
		int 	gain;
		BOOL	mute;
		BOOL	loudness;
		BOOL	zeroCrossing;
		WORD	faderLeft, faderRight;
		int 	bass, treble;
				
		Error Preempt(VirtualUnit *previous);

	public:
		VirtualFader6320(Fader6320 *physical);
		Error Configure(TAG __far * tags);
	};

#endif // ONLY_EXTERNAL_VISIBLE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\aenc4231.h ===
// FILE:			library\hardware\audio\specific\aenc4231.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1995, 1996 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		21.02.96
//
// PURPOSE:		CS4231 audio encoder class
//
// HISTORY:

#ifndef AENC4231_H
#define AENC4231_H

#include "aenc1846.h"

class AudioEncoder4231 : public AudioEncoder1846 {
	friend class VirtualAudioEncoder4231;
	protected:
		Error SetDataFormat(AudioDataFormat format);
	public:
		AudioEncoder4231(ASyncInStream		*	stream,
							  AD1846StereoCodec	*	codec) : AudioEncoder1846(stream, codec) {;}
	};

class VirtualAudioEncoder4231 : public VirtualAudioEncoder1846 {
	private:
		AudioEncoder4231		* 		unit;	
	public:
		VirtualAudioEncoder4231(AudioEncoder4231 * physical) : VirtualAudioEncoder1846(physical)
			{this->unit = physical;}
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\fadr7318.h ===
// FILE:			library\hardware\audio\specific\fadr7318.h
// AUTHOR:		P.C. Straasheijm
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		10.01.97
//
// PURPOSE:		Class for TDA7318 audio fader devices. Implementation.
//
// HISTORY:


#ifndef TDA7318_H
#define TDA7318_H

#include "library\hardware\audio\generic\audmix.h"

#ifndef ONLY_EXTERNAL_VISIBLE

#include "library\lowlevel\hardwrio.h"
#include "library\common\krnlstr.h"
#include "library\common\profiles.h"

#endif

// Inputs of TDA 733

enum TDA7318Inputs {INPUT_IN2, INPUT_IN1, INPUT_IN3, INPUT_IN4};

#ifndef ONLY_EXTERNAL_VISIBLE

//
// I2C address of TDA 7318
//
#define I2C_ADDRESS_TDA7318 	0x88

//
// Number of inputs of TDA7318
//
#define TDA7318_NUM_INPUTS	4

//
// Properties for each input
//
struct InputProperties
	{ 
	WORD	faderFrontLeft, faderFrontRight;
	WORD	faderRearLeft, faderRearRight;
	BOOL	mute;
	};


struct TDA7318Config
	{
	BOOL	symBassCut;
	BOOL	extendedBassRange;
	int	gainOffset[TDA7318_NUM_INPUTS];
	};


class TDA7318 : public AudioMixer {
	friend class VirtualTDA7318;

	private:
		DWORD				changed;

   	TDA7318Config	config;

		BYTE	source;

		int 	bass, treble;

		WORD	gain;
		WORD 	faderFrontLeft,	faderFrontRight;
		WORD 	faderRearLeft,		faderRearRight;
		BOOL	faderFrontMute,	faderRearMute;
		
		WORD	dBass, dTreble;

		WORD	dGain;
		WORD 	dFaderFrontLeft,	dFaderFrontRight;
		WORD 	dFaderRearLeft,	dFaderRearRight;
		BOOL	dFaderFrontMute,	dFaderRearMute;
		
		InputProperties			dProps[TDA7318_NUM_INPUTS];
                        	
		int	sourceInput;
		int	curInput;

		Profile	* profile;
	protected:
		ByteIndexedOutputPort * port;

		virtual Error SetSource(WORD source);

		virtual Error SetGain(WORD gain);
//		virtual Error SetSymBassCut(BOOL symBassCut);
//		virtual Error SetExtendedBassRange(BOOL extendedBassRange);
		
		virtual Error SetFader(FaderType type, AudioChannel channel, WORD faderValue);
		virtual Error SetFaderMute(FaderType type, BOOL mute);


		virtual Error DirectSetMute(BOOL dMute);

		virtual Error DirectSetGain(WORD dGain);
		virtual Error DirectSetBass(WORD dBass);
		virtual Error DirectSetTreble(WORD dTreble);

		virtual Error DirectSetFader(FaderType type, AudioChannel channel, WORD dFaderValue);

		virtual Error DirectSetInput(WORD input);
		virtual Error DirectSetInputFader(FaderType type, AudioChannel channel, WORD dFaderValue);
		virtual Error DirectSetInputMute(BOOL mute);

		virtual Error ProcessChanges();
		
	public:
		TDA7318(ByteIndexedOutputPort * port, Profile * profile); 
		
		Error RetrieveINIValues();
		VirtualUnit * CreateVirtual(void);

		Error	Configure(TDA7318Config __far & config);
	};

class VirtualTDA7318 : public VirtualAudioMixer {
	private:
		TDA7318			*	fader;	

		int	curInput;

		WORD	source;

		BOOL	mute;
		WORD	gain;

		WORD 	faderFrontLeft,	faderFrontRight;
		WORD 	faderRearLeft,		faderRearRight;
		BOOL	faderFrontMute,	faderRearMute;

		WORD 	dFaderFrontLeft,	dFaderFrontRight;
		WORD 	dFaderRearLeft,	dFaderRearRight;

		int 	bass, treble;
		
		InputProperties	dProps[TDA7318_NUM_INPUTS];
				
		Error Preempt(VirtualUnit *previous);

	public:
		VirtualTDA7318(TDA7318 *physical);
		Error Configure(TAG __far * tags);
	};

#endif // ONLY_EXTERNAL_VISIBLE



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\coac3mix.h ===
// FILE:			library\hardware\audio\specific\coac3mix.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1996 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		20.11.1996
//
// PURPOSE:		Concerto AC3 Mixer
//
// HISTORY:

#ifndef COAC3MIX_H
#define COAC3MIX_H

#include "..\generic\ac3mix.h"

#ifndef ONLY_EXTERNAL_VISIBLE
#include "library\common\profiles.h"
#endif

// The different audio inputs of Concerto
enum ConcertoAudioInputs {INPUT_FM, INPUT_LINE, INPUT_CDROM, INPUT_TV, INPUT_MONO, INPUT_DVD};

// For Direct Tag Change Message's "input" member.
#define MASK_INPUT_FM			(DWORD) (1 << INPUT_FM)
#define MASK_INPUT_LINE			(DWORD) (1 << INPUT_LINE)
#define MASK_INPUT_CDROM		(DWORD) (1 << INPUT_CDROM)
#define MASK_INPUT_TV			(DWORD) (1 << INPUT_TV)
#define MASK_INPUT_MONO			(DWORD) (1 << INPUT_MONO)
#define MASK_INPUT_DVD			(DWORD) (1 << INPUT_DVD)

#ifndef ONLY_EXTERNAL_VISIBLE

struct AC3InputProperties
	{ 
	WORD	volumeLeft, volumeRight;
	BOOL	mute;
	WORD	volumeCenter;
	WORD	volumeSurroundLeft;
	WORD	volumeSurroundRight;
	WORD	volumeSubwoofer;

	WORD	delayCenter;
	WORD	delaySurround;

	AC3SpeakerConfig	speakerConfig;
	AC3BassConfig		bassConfig;
	};

enum SourceMuxSetting {SWITCH_MIXER, SWITCH_AC3};

// Total number of inputs
#define COAC3MIX_INPUTS 	6

class DTCCallback : public Node
	{
	public:
		VirtualUnit					*unit;
		DirectTagChangeHookPtr	hookPtr;
		                                
		DTCCallback(VirtualUnit * unit, DirectTagChangeHookPtr hookPtr) {this->unit = unit; this->hookPtr = hookPtr;}
	};

typedef  DTCCallback * DTCCallbackPtr;

class DTCCallbackList : public List
	{
	public:
		~DTCCallbackList();
		DTCCallbackPtr FindByUnit(VirtualUnit * unit);
	};


class ConcertoAC3Mixer : public AudioMixer {
	friend class VirtualConcertoAC3Mixer;
	private:
		DWORD				changed;
      DWORD				dChanged;
      DWORD				dChangedInputs;
      
		int	source;

		BOOL	mute;

		WORD	volumeLeft,volumeRight;
		WORD	volumeCenter;
		WORD	volumeSurroundLeft, volumeSurroundRight;
		WORD	volumeSubwoofer;

		int	sourceInput;
		int	dCurInput;
		WORD	mixerSource;
		SourceMuxSetting		sourceMux;

		VirtualUnit				*audioMux;
		VirtualUnit				*mixer;
		PhysicalUnit			*audioDAC;
		PhysicalUnit			*decoder;

		Profile					*profile;
		
		DTCCallbackList		*callbackList;

		BOOL	updateCalled;

	protected:
		BOOL	dMute;
		WORD	dVolumeLeft, dVolumeRight;
		WORD	dVolumeCenter;
		WORD	dVolumeSurroundLeft, dVolumeSurroundRight;
		WORD	dVolumeSubwoofer;

		AC3InputProperties	dProps[COAC3MIX_INPUTS];

/*
		AC3SpeakerConfig		dSpeakerConfig;
		AC3BassConfig			dBassConfig;

		WORD	dSpeakerDelayCenter;
		WORD	dSpeakerDelaySurround;
*/
	protected:
		virtual Error SetSource(WORD source);
		virtual Error SetMute(BOOL mute);
		virtual Error SetVolume(AudioChannel channel, WORD volume);

		virtual Error DirectSetMute(BOOL dMute);
		virtual Error DirectSetVolume(AudioChannel channel, WORD dVolume);

		virtual Error DirectSetInput(WORD input);
		virtual Error DirectSetInputVolume(AudioChannel channel, WORD dVolume);
		virtual Error DirectSetInputMute(BOOL mute);

		virtual Error DirectSetInputSpeakerConfig(AC3SpeakerConfig config);
		virtual Error DirectSetInputBassConfig(AC3BassConfig config);
		virtual Error DirectSetInputSpeakerDelayCenter(WORD delay);
		virtual Error DirectSetInputSpeakerDelaySurround(WORD delay);

		virtual Error SetDirectTagChangeHook(VirtualUnit * unit, DirectTagChangeHookPtr hookPtr);

		Error ProcessChanges();

		virtual Error DirectUpdate();

	public:
		ConcertoAC3Mixer(Profile * profile,
							  VirtualUnit * mixer,
							  PhysicalUnit * audioDAC); 
		~ConcertoAC3Mixer();

		void SetAudioMux(VirtualUnit * audioMux);
		void SetDecoder(PhysicalUnit * decoder);
		
		Error RetrieveConfig();
		Error StoreConfig();
      
      VirtualAudioMixer * CreateVirtualAudioMixer(void);
	};

class VirtualConcertoAC3Mixer : public VirtualAudioMixer {
	private:
		ConcertoAC3Mixer			*	mixer;

		AC3InputProperties	dProps[COAC3MIX_INPUTS];

		BOOL	mute;
		WORD	source;
   
		WORD	volumeLeft,volumeRight;
		WORD	volumeCenter;
		WORD	volumeSurroundLeft, volumeSurroundRight;
		WORD	volumeSubwoofer;
	
		BOOL	dMute;

		WORD	dVolumeLeft, dVolumeRight;
		WORD	dVolumeCenter;
		WORD	dVolumeSurroundLeft, dVolumeSurroundRight;
		WORD	dVolumeSubwoofer;
		
		int	dCurInput;

/*
		AC3SpeakerConfig		dSpeakerConfig;
		AC3BassConfig			dBassConfig;

		WORD	dSpeakerDelayCenter;
		WORD	dSpeakerDelaySurround;
*/
		DirectTagChangeHookPtr	hookPtr;
		BOOL	updateCalled;
	protected:
		Error Preempt(VirtualUnit *previous);
	public:
		VirtualConcertoAC3Mixer(ConcertoAC3Mixer *mixer);
		~VirtualConcertoAC3Mixer();
		Error Configure(TAG __far * tags);
	};

#endif // ONLY_EXTERNAL_VISIBLE



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\mix1846.h ===
// FILE:			library\hardware\audio\specific\mix1846.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		30.11.95
//
// PURPOSE:		Class for AD1846 based audio mixer.
//
// HISTORY:

#ifndef MIX1846_H
#define MIX1846_H

#include "..\generic\audmix.h"
#include "ad1846.h"

#ifndef ONLY_EXTERNAL_VISIBLE

#define MIX_1846_NUM_INPUTS 4

struct InputProperties
	{ 
	WORD	mixGainLeft,		mixGainRight;
	BOOL	muteLeft,			muteRight;
	};

class Mixer1846 : public AudioMixer {
	friend class VirtualMixer1846;
	private:
		AD1846StereoCodec	*	codec;

		DWORD	changed;

		WORD	sourceLeft, 		sourceRight;
		WORD	gainLeft, 			gainRight;
		BOOL	gainEnableLeft,	gainEnableRight;
		WORD	attLeft, 			attRight;
		BOOL	muteLeft, 			muteRight;

		WORD	dGainLeft,			dGainRight;
		WORD	dAttLeft,			dAttRight;
		BOOL	dMuteLeft,			dMuteRight;

		WORD	loopBackAtt;
		BOOL	loopBack;

		BOOL	directMute;

		InputProperties			props[MIX_1846_NUM_INPUTS];
		InputProperties			dProps[MIX_1846_NUM_INPUTS];
	protected:
		int	currentDirectInput;
		
		virtual Error SetCurrentDirectInput	(int currentDirectInput);

		virtual Error SetSource			(AudioChannel ch, WORD src);
		virtual Error SetGain			(AudioChannel ch, WORD gain);
		virtual Error SetGainEnable	(AudioChannel ch, WORD gainEnable);
		virtual Error SetAttenuation	(AudioChannel ch, WORD att);
		virtual Error SetMute			(AudioChannel ch, BOOL mute);

		virtual Error SetDirectGain	(AudioChannel ch, WORD gain);
		virtual Error SetDirectAtt		(AudioChannel ch, WORD att);
		virtual Error SetDirectMute	(AudioChannel ch, BOOL mute);
		virtual Error SetDirectInputMute(AudioChannel ch, BOOL mute);
                                    
		virtual Error SetInputMixGain	(AudioChannel ch, WORD mixGain);
		virtual Error SetInputMute		(AudioChannel ch, BOOL mute);
                                    
		virtual Error SetLoopback		(BOOL loopBack);
		virtual Error SetLoopbackAttenuation(WORD att);

		Error ProcessChanges();		
	public:
		Mixer1846(AD1846StereoCodec	*	codec); 

		VirtualUnit * CreateVirtual(void);
	};


class VirtualMixer1846 : public VirtualAudioMixer {
	private:
		Mixer1846			*	mixer;	

		InputProperties	props[MIX_1846_NUM_INPUTS];
	protected:
		WORD	sourceLeft, 		sourceRight;
		WORD	gainLeft, 			gainRight;
		BOOL	gainEnableLeft,	gainEnableRight;
		WORD	attLeft, 			attRight;
		BOOL	muteLeft, 			muteRight;

		WORD	loopBackAtt;
		BOOL	loopBack;

		WORD	dGainLeft,			dGainRight;
		WORD	dAttLeft,			dAttRight;
		BOOL	dMuteLeft,			dMuteRight;
		
		BOOL	dInputMuteLeft,	dInputMuteRight;

		int	curDirectInput;
		
		Error Preempt(VirtualUnit *previous);
	public:
		VirtualMixer1846(Mixer1846 *physical);
		Error Configure(TAG __far * tags);
	};

#endif // ONLY_EXTERNAL_VISIBLE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\pcm1717.h ===
// FILE:			library\hardware\audio\specific\pcm1717.h
// AUTHOR:		Viona
// COPYRIGHT:	(c) 1995, 1996 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		05.12.1996
//
// PURPOSE:		
//
// HISTORY: 
#ifndef PCM1717_H
#define PCM1717_H

#include "..\generic\audiodac.h"
#include "..\..\..\lowlevel\hardwrio.h"
#include "pcm17xx.h"

//
// Concrete implementation of an audio DAC, Burr Brown 1717
//
class PCM1717 : public PCM17XX
	{
	private:
	protected:
		Error SetInputFormat(DWORD format);
		Error SetOutputFormat(DWORD format);

	public:
		PCM1717(BitOutputPort * md,
		        BitOutputPort * mc,
		        BitOutputPort * ml);
		        
		Error Initialize(void);
	};

typedef VirtualPCM17XX VirtualPCM1717;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\pcm1716.h ===
// FILE:			library\hardware\audio\specific\pcm1716.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1999 VIONA Development GmbH & Co. KG.  All Rights Reserved.
// CREATED:		08.09.1999
//
// PURPOSE:		
//
// HISTORY: 

#ifndef PCM1716_H
#define PCM1716_H

#include "..\generic\audiodac.h"
#include "..\..\..\lowlevel\hardwrio.h"
#include "pcm17xx.h"

class PCM1716 : public PCM17XX
	{
	private:
	protected:
		Error SetInputFormat(DWORD format);
		Error SetOutputFormat(DWORD format);

	public:
		PCM1716(BitOutputPort * md,
		        BitOutputPort * mc,
		        BitOutputPort * ml);
		        
		Error Initialize(void);
	};

typedef VirtualPCM17XX VirtualPCM1716;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\mix4231.h ===
// FILE:			library\hardware\audio\specific\mix4231.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1995, 1996 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		07.02.1996
//
// PURPOSE:		Class for audio mixers based on the CS4231 codec.
//					Adds additional control over line and mono inputs.
//
// HISTORY:

#ifndef MIX4231_H
#define MIX4231_H

#include "mix1846.h"
#include "cs4231.h"

#define MIX_4231_NUM_INPUTS 5

class Mixer4231 : public Mixer1846 {
	friend class VirtualMixer4231;
	private:
		CS4231StereoCodec	*	codec;

		DWORD	changed;

		WORD	lineGainLeft,		lineGainRight;
		BOOL	lineMuteLeft,		lineMuteRight;

		BOOL	dLineMuteLeft, dLineMuteRight;
		BOOL	dMonoInMute;
		
		WORD	monoAttenuation;
		BOOL	monoInMute;
		BOOL	monoOutMute;

	protected:   
		Error SetInputMixGain	(AudioChannel ch, WORD mixGain);
		Error SetInputMute		(AudioChannel ch, BOOL mute);
		Error SetDirectInputMute(AudioChannel ch, BOOL mute);

		virtual Error SetMonoAttenuation	(WORD);
		virtual Error SetMonoInputMute	(BOOL mute);
		virtual Error SetMonoOutputMute	(BOOL mute);
                                    
		Error ProcessChanges();		
	public:
		Mixer4231(CS4231StereoCodec	*	codec); 

		VirtualUnit * CreateVirtual(void);
	};


class VirtualMixer4231: public VirtualMixer1846 {
	private:
		Mixer4231			*	mixer;	
	protected:
		WORD	monoAttenuation;
		BOOL	monoInMute;
		BOOL	monoOutMute;
		
		Error Preempt(VirtualUnit *previous);
	public:
		VirtualMixer4231(Mixer4231 * physical);
		Error Configure(TAG __far * tags);
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\mix1845.h ===
// FILE:			library\hardware\audio\specific\mix1845.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1997 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		10.03.1997
//
// PURPOSE:		Class for audio mixers based on the AD1845 codec.
//					Adds additional control over MIC input.
//
// HISTORY:

#ifndef MIX1845_H
#define MIX1845_H

#ifndef ONLY_EXTERNAL_VISIBLE

#include "mix4231.h"
#include "ad1845.h"

class Mixer1845 : public Mixer4231 {
	friend class VirtualMixer1845;
	private:
		AD1845StereoCodec	*	codec;

		DWORD	changed;

		WORD	micGainLeft,		micGainRight;
		BOOL	micMixMuteLeft,	micMixMuteRight;

		BOOL	dMicMixMuteLeft,	dMicMixMuteRight;

	protected:   
		Error SetInputMixGain	(AudioChannel ch, WORD mixGain);
		Error SetInputMute		(AudioChannel ch, BOOL mute);
		Error SetDirectInputMute(AudioChannel ch, BOOL mute);

		Error ProcessChanges();		
	public:
		Mixer1845(AD1845StereoCodec	*	codec); 

		VirtualUnit * CreateVirtual(void);
	};


class VirtualMixer1845: public VirtualMixer4231 {
	public:
		VirtualMixer1845(Mixer1845 * physical) : VirtualMixer4231(physical) {;}
	};

#endif // of ONLY_EXTERNAL_VISIBLE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\pcm1721.h ===
#ifndef PCM1721_H
#define PCM1721_H


#include "pcm17xx.h"

#include "library\lowlevel\hardwrio.h"
#include "library\hardware\audio\generic\audiodac.h"
#include "library\hardware\clocks\generic\clocks.h"
#include "pcm17xx.h"

//
// Concrete implementation of an audio DAC, Burr Brown 1717
//
class PCM1721 : public PCM17XX, public ProgrammableClockGenerator
	{
	private:
	protected:
		Error SetInputFormat(DWORD format);
		Error SetOutputFormat(DWORD format);

		Error ProgramFrequency(DWORD freq);
	public:
		PCM1721(BitOutputPort * md,
		        BitOutputPort * mc,
		        BitOutputPort * ml);
	};

typedef VirtualPCM17XX VirtualPCM1721;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\pcm1720.h ===
#ifndef PCM1720_H
#define PCM1720_H

#include "library\lowlevel\hardwrio.h"
#include "library\hardware\audio\generic\audiodac.h"
#include "pcm17xx.h"

//
// Concrete implementation of an audio DAC, Burr Brown 1717
//
class PCM1720 : public PCM17XX
	{
	private:
	protected:
		Error SetInputFormat(DWORD format);
		Error SetOutputFormat(DWORD format);
	public:
		PCM1720(BitOutputPort * md,
		        BitOutputPort * mc,
		        BitOutputPort * ml);
	};

typedef VirtualPCM17XX VirtualPCM1720;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\pcm1725.h ===
#ifndef PCM1725_H
#define PCM1725_H

#include "..\generic\audiodac.h"
#include "..\..\..\lowlevel\hardwrio.h"

//
// PCM1725
//
class PCM1725 : public AudioDAC
	{
	friend class VirtualPCM1725;
	protected:
		BitOutputPort	*	emphasis;

		Error SetLeftVolume(WORD volume) {GNRAISE_OK;}
		Error SetRightVolume(WORD volume) {GNRAISE_OK;}
		Error SetMute(BOOL mute) {GNRAISE_OK;}
		Error SetInputFormat(DWORD format) {GNRAISE_OK;}
		Error SetOutputFormat(DWORD format) {GNRAISE_OK;}

		//
		// Update the dac control words
		//
		Error Update(void)  {GNRAISE_OK;}
	public:
		PCM1725(BitOutputPort * emphasis);
		        
		Error Configure(TAG __far * tags);
		
		virtual Error Initialize(void);

		Error	ReInitialize(void);
		
		VirtualAudioDAC * CreateVirtualAudioDAC(void); 
	};


class VirtualPCM1725 : public VirtualAudioDAC
	{
	private:
		PCM1725	*	device;
	public:
		VirtualPCM1725(PCM1725 * device) : VirtualAudioDAC(device) {this->device = device;}
		Error Configure(TAG __far * tags);
		Error Preempt(VirtualUnit * previous);		
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\Pcm17xx.h ===
#ifndef PCM17XX_H
#define PCM17XX_H

#include "..\generic\audiodac.h"
#include "..\..\..\lowlevel\hardwrio.h"

//
// Concrete implementation of an audio DAC, Burr Brown 1717
//
class PCM17XX : public AudioDAC
	{
	friend class VirtualPCM17XX;
	protected:
		// Cached control words
		//
		WORD	cw[4];
		//
		// Changed control words (flag set)
		//
		WORD	cc;
		//		
		// Serial control lines
		//
		BitOutputPort	*	md;
		BitOutputPort	*	mc;
		BitOutputPort	*	ml;		 


		BOOL	mute,dMute;
		WORD	volumeLeft,	volumeRight;
		WORD	dVolumeLeft, dVolumeRight;
		
		//
		// Write a control word to the chip
		//
		Error WriteControlWord(WORD cw);
	protected:
		Error SetLeftVolume(WORD volume);
		Error SetRightVolume(WORD volume);
		Error SetMute(BOOL mute);
		
		//
		// Update the dac control words
		//
		Error Update(void);
	public:
		PCM17XX(BitOutputPort * md,
		        BitOutputPort * mc,
		        BitOutputPort * ml);
		        
		Error Configure(TAG __far * tags);
		
		virtual Error Initialize(void);

		Error ReInitialize(void);
		
		VirtualAudioDAC * CreateVirtualAudioDAC(void); 
	};


class VirtualPCM17XX : public VirtualAudioDAC
	{
	private:
		PCM17XX	*	device;
	public:
		VirtualPCM17XX(PCM17XX * device) : VirtualAudioDAC(device) {this->device = device;}
		Error Configure(TAG __far * tags);
		Error Preempt(VirtualUnit * previous);		
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\tda9850.h ===
// FILE:			library\hardware\audio\specific\tda9850.h
// AUTHOR:		Stefan Herr
// COPYRIGHT:	(c) 1996 Viona Development.  All Rights Reserved.
// CREATED:		22.08.95
//
// PURPOSE:		Class for Philips TDA9850 TV stereo decoders
//
// HISTORY:

#ifndef TDA9850_H
#define TDA9850_H

#include "library\lowlevel\hardwrio.h"
#include "library\hardware\audio\generic\stereodc.h"

#define I2C_TDA9850	0xb4

enum ADJBitSetting {MODE_STEREO_DECODER, MODE_AUTO_ADJUST};
enum STSBitSetting {STON_LT_30MV, STON_LT_35MV};

MKTAG(STEREODEC_LEVEL,							STEREO_DECODER_UNIT,	0x101, WORD)
MKTAG(STEREODEC_STEREO_NOISE_THRESHOLD,	STEREO_DECODER_UNIT,	0x102, WORD)
MKTAG(STEREODEC_SAP_NOISE_THRESHOLD,		STEREO_DECODER_UNIT,	0x103, WORD)
MKTAG(STEREODEC_TIMING_CURRENT,				STEREO_DECODER_UNIT,	0x104, WORD)
MKTAG(STEREODEC_ADJ,								STEREO_DECODER_UNIT,	0x105, ADJBitSetting)
MKTAG(STEREODEC_STS,								STEREO_DECODER_UNIT,	0x106, STSBitSetting)
MKTAG(STEREODEC_MUTE,							STEREO_DECODER_UNIT,	0x107, BOOL)
MKTAG(STEREODEC_ALIGNMENT_1,					STEREO_DECODER_UNIT, 0x108, WORD)
MKTAG(STEREODEC_ALIGNMENT_2,					STEREO_DECODER_UNIT, 0x109, WORD)

class TDA9850 : public StereoDecoder	{
	friend class VirtualTDA9850;
	protected:
		ByteIndexedInOutPort * port;

		DWORD	changed;
	
		BOOL	sap;
		BOOL	stereo;
		
		ADJBitSetting	adj;
		STSBitSetting	sts;

		WORD	level, stereoNoiseThreshold, sapNoiseThreshold, timingCurrent;
		BOOL	mute;
		WORD	alignment1, alignment2;

		Error GetSignalMode(SignalMode __far & mode);
		Error SetSignalMode(SignalMode mode);

		virtual Error SetLevel(WORD level);
		virtual Error SetStereoNoiseThreshold(WORD stereoNoiseThreshold);
		virtual Error SetSAPNoiseThreshold(WORD sapNoiseThreshold);
		virtual Error SetTimingCurrent(WORD timingCurrent);
		virtual Error SetADJ(ADJBitSetting adj);
		virtual Error SetSTS(STSBitSetting sts);
		virtual Error SetMute(BOOL mute);
		virtual Error SetAlignment1(WORD alignment1);
		virtual Error SetAlignment2(WORD alignment2);

		Error ProcessChanges();
	public:
		TDA9850(ByteIndexedInOutPort * port);
		
		VirtualUnit * CreateVirtual(void); 
	};
	
class VirtualTDA9850 : public VirtualStereoDecoder {
	private:
		TDA9850	*	decoder;
	protected:
		ADJBitSetting	adj;
		STSBitSetting	sts;

		WORD	level, stereoNoiseThreshold, sapNoiseThreshold, timingCurrent;
		BOOL	mute;
		WORD	alignment1, alignment2;
		
	public:
		VirtualTDA9850(TDA9850 * decoder);
		Error Configure(TAG __far * tags);
		Error Preempt(VirtualUnit * previous);
	};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\q22fifo.h ===
// FILE:			library\hardware\audio\specific\q22fifo.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1997 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		18.03.97
//
// PURPOSE:		Class for Q22 audio FIFO
//
// HISTORY:

#ifndef Q22FIFO_H
#define Q22FIFO_H

#ifndef ONLY_EXTERNAL_VISIBLE

#include "library\lowlevel\hardwrio.h"
#include "library\lowlevel\intrctrl.h"
#include "library\common\krnlsync.h"
#include "library\common\profiles.h"
#include	"library\hardware\audio\generic\audtypes.h"

#include "..\generic\bufstrms.h"

class Q22AudioFIFO : public StreamFIFO, protected VDCriticalSection
	{ 
	friend class Q22FIFOIntHandler;
	private:
		ByteIndexedInOutPort		*	fifoPort;
      InterruptServer 			*	fifoIntServer;
      InterruptHandler			*	fifoIntHandler;
      
		BitIndexedByteSplitOutputPort	*	controlPort;
		
		long bufferSize;
		
		long	threshold;
		long	minIRQDistance;
		
		long	inCount;
		long	dummyCount;
		long irqCount;
		long finalCount;

		long	eventPosition;
		
		DWORD	state;
		
		BOOL	encode;
		
		Profile	* profile;
		
		DWORD		baseMaxIRQLatency;
		DWORD		baseMinIRQDistance;
		
		BOOL		dmaEnable;
		BOOL		inIRQ;
		BOOL		bufferNotEmpty;

		BYTE		dummyData[32];
		
		BYTE		peakLeft, peakRight;
		WORD		oldPeakLeft, oldPeakRight;
		DWORD		offsetLeft, offsetRight;
		DWORD		realCount;
		
		AudioDataFormat	format;
		AudioMode			mode;
		
		BOOL		peakMeasure;
		
		DWORD		initialSkip;
		DWORD		skipCount;
	protected:
		Error	CheckThreshold(void);

		Error FillDummyBytes(void);
		Error ReadDummyBytes(void);
		
		Error ReadInternalInputCounter(long __far & done);
		Error ReadInternalOutputCounter(long __far & done);
		
		void CriticalSection(void);

		Error CalculatePeaks(HBPTR buff, DWORD curCount, DWORD done);
	public:
		Q22AudioFIFO(ByteIndexedInOutPort				* fifoPort,
						 BitIndexedByteSplitOutputPort	* controlPort,
						 InterruptServer						* fifoIntServer,
						 DWORD bufferSize,
						 Profile 								* profile);
						 
		~Q22AudioFIFO();
	
		Error Flush(void);
		
		Error BeginTransfer(StreamFIFORequest * req,
							 	  BOOL  encode,
							 	  DWORD bytesPerSecond,
							 	  BYTE  dummyFill,
							 	  DWORD format,
							 	  DWORD mode,
							 	  DWORD initialSkip);
		Error CompleteTransfer(void);
		Error StartTransfer(void);
		Error StopTransfer(void);
		Error	EndTransfer(void);

		Error WriteBytes(HBPTR buff, DWORD size, DWORD __far & done);		
		Error ReadBytes(HBPTR buff, DWORD size, DWORD __far & done);

		Error ReadInputCounter(DWORD __far & done);
		Error ReadOutputCounter(DWORD __far & done);

		DWORD BytesFull(void);
		DWORD BytesFree(void);
		
		Error ScheduleEvent(StreamFIFOEvent * event, DWORD position);
	
		Error SuspendCallbacks(void);
		Error ResumeCallbacks(void);

		Error GetDataPeak(DWORD __far & info, BOOL encode);
	};

#endif // of ONLY_EXTERNAL_VISIBLE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\tda1593.h ===
// FILE:			library\hardware\audio\specific\tda1593.h
// AUTHOR:		Stefan Herr
// COPYRIGHT:	(c) 1996 Viona Development.  All Rights Reserved.
// CREATED:		23.08.95
//
// PURPOSE:		Class for Philips TDA1593 FM stereo decoders
//
// HISTORY:

#ifndef TDA1593_H
#define TDA1593_H

#include "library\lowlevel\hardwrio.h"
#include "library\hardware\audio\generic\stereodc.h"

class TDA1593 : public StereoDecoder	{
	friend class VirtualTDA1593;
	protected:
		BitInputPort 	*	stereoDetectPort;
		BitOutputPort	*	forceMonoPort;

		BOOL	forceMono;
		
		BOOL	changed;
	
		Error GetSignalMode(SignalMode __far & mode);
		Error SetSignalMode(SignalMode mode);

		Error ProcessChanges();
	public:
		TDA1593(BitInputPort * stereoDetectPort, BitOutputPort * forceMonoPort);

		VirtualUnit * CreateVirtual(void); 
	};
	
class VirtualTDA1593 : public VirtualStereoDecoder {
	private:
		TDA1593	*	decoder;
	public:
		VirtualTDA1593(TDA1593 * decoder);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\clocks\generic\clckport.h ===
// FILE:			library\hardware\clocks\generic\clckport.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1997 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		04.04.97
//
// PURPOSE:		Port for access to clock PLLs
//
// HISTORY:

#ifndef CLCKPORT_H
#define CLCKPORT_H

#include "library\common\prelude.h"
#include "library\lowlevel\hardwrio.h"

#define T_SU		1 // Setup time
#define T_HD		1 // Hold time
#define T_LDCMD	1 // Load command time


class ClockPort : public DWordIndexedOutputPort {
	private:
		BitOutputPort * dataPort;
		BitOutputPort * clkPort;
	protected:
		Error Unlock();
		Error Start();
		Error Stop();
		Error SetData(BIT data) {return dataPort->OutBit(data);}
		Error SetClock(BIT data) {return clkPort->OutBit(data);}
	public:
		ClockPort(BitOutputPort * dataPort, BitOutputPort * clkPort)
			{this->dataPort = dataPort; this->clkPort = clkPort;}
		Error OutDWord(int at, DWORD data);
	};


// MicroWire (BurrBrown) type of Port to clock

class MWClockPort : public WordOutputPort
	{
	private:
		BitOutputPort	*	ml;
		BitOutputPort	*	mc;
		BitOutputPort	*	md;
	public:
		MWClockPort(BitOutputPort * ml, BitOutputPort * mc, BitOutputPort * md);

		Error OutWord(WORD data);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\clocks\generic\clocks.h ===
// FILE:			library\hardware\clock\generic\clocks.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		15.01.95
//
// PURPOSE:		Base classes for clock generators.
//
// HISTORY:

#ifndef CLOCKS_H
#define CLOCKS_H

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"

#ifndef ONLY_EXTERNAL_VISIBLE


// Elementary clock generator
class ClockGenerator {
	public:
		virtual Error GetFrequency(DWORD __far & freq) = 0;				// freq unit is Hz
	};
	
// Programmable clock generator (output frequency programmable)
class ProgrammableClockGenerator : public ClockGenerator {
	protected:
		DWORD	desiredFrequency;
		DWORD	actualFrequency;
		
		virtual Error ProgramFrequency(DWORD freq) = 0;
	public:
		ProgrammableClockGenerator() {desiredFrequency = 0; actualFrequency = 0;}
		
		virtual Error GetFrequency(DWORD __far & freq) {freq = actualFrequency; GNRAISE_OK;}
		virtual Error SetFrequency(DWORD freq);
		virtual Error GetError(DWORD __far & error);		// Get error of frequency.
	};

// Programmable clock generator with variable base frequency
class PLLClockGenerator : public ProgrammableClockGenerator {
	public:
		virtual Error SetBaseFrequency(DWORD freq) = 0;
	};

inline Error ProgrammableClockGenerator::GetError(DWORD __far & error)
	{
	long diff;
	
	diff = desiredFrequency - actualFrequency; 
	error = (DWORD) max(diff, -diff);
	
	GNRAISE_OK;	
	}

inline Error ProgrammableClockGenerator::SetFrequency(DWORD freq)
	{
	desiredFrequency = freq;
	GNREASSERT(ProgramFrequency(freq));
	
	GNRAISE_OK;
	}

#endif // of ONLY_EXTERNAL_VISIBLE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\audio\specific\tda7433.h ===
// FILE:			library\hardware\audio\specific\tda7433.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1997 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		08.02.97
//
// PURPOSE:		Class for TDA7433 Basic Function Audio Processor
//
// HISTORY:

#ifndef TDA7433_H
#define TDA7433_H

#include "library\hardware\audio\generic\audmix.h"

#ifndef ONLY_EXTERNAL_VISIBLE

#include "library\lowlevel\hardwrio.h"
#include "library\common\krnlstr.h"
#include "library\common\profiles.h"

#endif

// Inputs of TDA 733

enum TDA7433Inputs {INPUT_IN1, INPUT_IN2, INPUT_MONO};

#ifndef ONLY_EXTERNAL_VISIBLE

//
// I2C address of TDA 7433
//
#define I2C_ADDRESS_TDA7433 	0x8a

//
// Number of inputs of TDA7433
//
#define TDA7433_NUM_INPUTS	3

//
// Properties for each input
//
struct TDA7433InputProperties
	{ 
	WORD	volumeLeft, volumeRight;
	BOOL	mute;
	};


struct TDA7433Config
	{
	BOOL	symBassCut;
	BOOL	extendedBassRange;
	int	gainOffset[TDA7433_NUM_INPUTS];
	};


class TDA7433 : public AudioMixer {
	friend class VirtualTDA7433;

	private:
		DWORD				changed;

   	TDA7433Config	config;

		BYTE	source;

		WORD	gain;
		WORD	volumeLeft,			volumeRight;
		BOOL	faderFrontMute,	faderRearMute;
		
		WORD	dBass, dTreble;

		WORD	dVolumeLeft, dVolumeRight;
		BOOL	dFaderFrontMute,	dFaderRearMute;
		
		TDA7433InputProperties			dProps[TDA7433_NUM_INPUTS];
                        	
		int	sourceInput;
		int	curInput;

		Profile	* profile;
	protected:
		ByteIndexedOutputPort * port;

		virtual Error SetSource(WORD source);

		virtual Error SetVolume(AudioChannel channel, WORD volumeValue);
		virtual Error SetFaderMute(FaderType type, BOOL mute);

		virtual Error DirectSetMute(BOOL dMute);
		virtual Error DirectSetBass(WORD dBass);
		virtual Error DirectSetTreble(WORD dTreble);
		virtual Error DirectSetVolume(AudioChannel channel, WORD dVolumeValue);
		virtual Error DirectSetInput(WORD input);
		virtual Error DirectSetInputVolume(AudioChannel channel, WORD dVolumeValue);
		virtual Error DirectSetInputMute(BOOL mute);

		virtual Error ProgramVolume();

		virtual Error ProcessChanges();
		
	public:
		TDA7433(ByteIndexedOutputPort * port, Profile * profile); 
		
		Error ReInitialize(void);

		Error RetrieveINIValues();
		VirtualAudioMixer * CreateVirtualAudioMixer(void);

		Error	ConfigureMixer(TDA7433Config __far & config);
	};

class VirtualTDA7433 : public VirtualAudioMixer {
	private:
		TDA7433			*	fader;	

		int	curInput;

		WORD	source;

		BOOL	mute;
		WORD	gain;

		WORD	volumeLeft, volumeRight;

		BOOL	faderFrontMute,	faderRearMute;

		WORD	dVolumeLeft, dVolumeRight;

		int 	bass, treble;
		
		TDA7433InputProperties	dProps[TDA7433_NUM_INPUTS];
				
		Error Preempt(VirtualUnit *previous);

	public:
		VirtualTDA7433(TDA7433 *physical);
		Error Configure(TAG __far * tags);
	};

#endif // ONLY_EXTERNAL_VISIBLE



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\clocks\specific\h22clock.h ===
// FILE:			library\hardware\clock\specific\h22clock.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		17.01.95
//
// PURPOSE:		H22 specific audio clock generator
//
// HISTORY:

#ifndef H22CLOCK_H
#define H22CLOCK_H

#include "library\hardware\clocks\generic\clocks.h"
#include "library\lowlevel\hardwrio.h"

// Definition of possible base frequencies (for SetBaseFrequency())

#define BASE_FREQ_14_75	14750000
#define BASE_FREQ_12_27 12270000
#define BASE_FREQ_13_50 13500000

// Definition of possible destination frequencies (for SetFrequency())

#define DEST_FREQ_16_9344 16934400
#define DEST_FREQ_24_576  24576000


#ifndef ONLY_EXTERNAL_VISIBLE	


///////////////////////////////////////////////////////////////////////////////
// Audio clock generator
///////////////////////////////////////////////////////////////////////////////

enum H22ClockBaseFrequencies {IDX_BASE_FREQ_14_75,   IDX_BASE_FREQ_12_27, IDX_BASE_FREQ_13_50};
enum H22ClockDestFrequencies {IDX_DEST_FREQ_16_9344, IDX_DEST_FREQ_24_576};

class H22AudioClockGenerator : public PLLClockGenerator { 
	private:
		DWordIndexedOutputPort	*	dataPort;
		BitIndexedOutputPort		*	selPort;

		H22ClockBaseFrequencies	baseFreqIndex;
		H22ClockDestFrequencies destFreqIndex;
		
		DWORD	baseFrequency;
	protected:
		Error ProgramFrequency(DWORD freq);
		virtual Error WriteFrequency();
	public:
		H22AudioClockGenerator(BitIndexedOutputPort	* selPort);

		virtual Error Reset();

		Error SetBaseFrequency(DWORD freq);
	};


#endif // of ONLY_EXTERNAL_VISIBLE	

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\clocks\specific\mk2744.h ===
// FILE:			library\hardware\clock\specific\mk2744.h
// AUTHOR:		Viona
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		05.12.95
//
// PURPOSE:		
//
// HISTORY:
#ifndef MK2744_H
#define MK2744_H

#include "library\common\prelude.h"
#include "..\generic\clocks.h"          
#include "library\lowlevel\hardwrio.h"

class ClockGeneratorMK2744 : public ProgrammableClockGenerator
	{
	private:
		BitOutputPort	*	as0;
		BitOutputPort	*	as1;
		BitOutputPort	*	as2;
	protected:
		Error ProgramFrequency(DWORD freq);
	public:
		ClockGeneratorMK2744(BitOutputPort * as0, BitOutputPort * as1, BitOutputPort * as2);				
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\clocks\specific\icd2036.h ===
// FILE:			library\hardware\clocks\specific\icd2036.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1997 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		04.04.97
//
// PURPOSE:		Definitions and structures for PLLs of ICD2036 type
//
// HISTORY:

#ifndef ICD2036_H
#define ICD2036_H

struct FrequencyParameters
	{
	DWORD	mClkP,
			mClkQ,
			mClkPre,
			mClkPost,
			vClkP,
			vClkQ,
			vClkPre,
			vClkPost;
	};
	

//
// Registers for ICD2036 PLL
//
#define ICD2036REG_FVCLKF1	0
#define ICD2036REG_FVCLKF2	1
#define ICD2036REG_VREG0	2
#define ICD2036REG_MREG0	3
#define ICD2036REG_PWRDWN	4
#define ICD2036REG_VREG1	5
#define ICD2036REG_CNTL		6
#define ICD2036REG_MREG1	7

//
// Bits for MREGx/VREGx
//
#define ICD2036IDX_Q			0, 7
#define ICD2036IDX_M			7, 3
#define ICD2036IDX_P			10, 7
#define ICD2036IDX_I			17, 4

//
// Bits for control register CNTL
//
#define ICD2036IDX_PM0		11
#define ICD2036IDX_PM1		12
#define ICD2036IDX_PV0		13
#define ICD2036IDX_PV1		14
#define ICD2036IDX_C0		15
#define ICD2036IDX_C1		16
#define ICD2036IDX_C2		17
#define ICD2036IDX_C3		18
#define ICD2036IDX_C4		19
#define ICD2036IDX_C5		20

//
// Bits for powerdown register PWRDWN
//
#define ICD2036IDX_P0		17
#define ICD2036IDX_P1		18
#define ICD2036IDX_P2		19
#define ICD2036IDX_P3		20

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\clocks\specific\icd2061.h ===
// FILE:			library\hardware\clocks\specific\icd2061.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1997 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		04.04.97
//
// PURPOSE:		Definitions and structures for PLLs of ICD2061 type
//
// HISTORY:

#ifndef ICD2061_H
#define ICD2061_H

//
// Registers for ICD2061 PLL
//
#define ICD2061REG_REG0			0
#define ICD2061REG_REG1			1
#define ICD2061REG_REG2			2
#define ICD2061REG_MREG			3
#define ICD2061REG_PWRDWN		4
#define ICD2061REG_RESERVED	5
#define ICD2061REG_CNTL			6

//
// Bits for MREGx/VREGx
//
#define ICD2061IDX_Q			0, 7
#define ICD2061IDX_M			7, 3
#define ICD2061IDX_P			10, 7
#define ICD2061IDX_I			17, 4

//
// Bits for control register CNTL
//
#define ICD2061IDX_PS0		12
#define ICD2061IDX_PS1		13
#define ICD2061IDX_PS2		14
#define ICD2061IDX_C0		15
#define ICD2061IDX_C1		16
#define ICD2061IDX_C2		17
#define ICD2061IDX_C3		18
#define ICD2061IDX_C4		19
#define ICD2061IDX_C5		20


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\clocks\specific\q22clock.h ===
// FILE:			library\hardware\clock\specific\h22clock.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1997 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		04.04.97
//
// PURPOSE:		Q22 specific audio clock generator
//
// HISTORY:

#ifndef H22CLOCK_H
#define H22CLOCK_H

#include "library\hardware\clocks\generic\clocks.h"
#include "library\lowlevel\hardwrio.h"

// Definition of possible base frequencies (for SetBaseFrequency())

#define BASE_FREQ_14_75	14750000
#define BASE_FREQ_12_27 12270000
#define BASE_FREQ_13_50 13500000

// Definition of possible destination frequencies (for SetFrequency())

#define DEST_FREQ_16_9344	16934400
#define DEST_FREQ_24_576	24576000
#define DEST_FREQ_25  		25000000


#ifndef ONLY_EXTERNAL_VISIBLE	


///////////////////////////////////////////////////////////////////////////////
// Audio clock generator
///////////////////////////////////////////////////////////////////////////////

enum H22ClockBaseFrequencies {IDX_BASE_FREQ_14_75,   IDX_BASE_FREQ_12_27, IDX_BASE_FREQ_13_50};
enum H22ClockDestFrequencies {IDX_DEST_FREQ_16_9344, IDX_DEST_FREQ_24_576, IDX_DEST_FREQ_25};

class Q22AudioClockGenerator : public ProgrammableClockGenerator { 
	private:
		BitOutputPort				*	opModeSelPort;
		BitOutputPort				*	regSelPort;
		BitOutputPort				*	sel1Port;
		BitOutputPort				*	sel0Port;
		BitInputPort				*	pllErrorPort;

		DWordIndexedOutputPort	*	dataPort;
		
		H22ClockBaseFrequencies	baseFreqIndex[4];
		H22ClockDestFrequencies destFreqIndex;
		
		DWORD	baseFrequency[4];
		
		BOOL	use2061;
		BOOL	mclkRef;
		BOOL	ccir;
	protected:
		Error ProgramFrequency(DWORD freq);
		virtual Error WriteFrequency();
	public:
		Q22AudioClockGenerator(BitOutputPort * opModeSelPort,	// Port to select operation mode
									  BitOutputPort * regSelPort,		// Port to select which register set to use
									  BitOutputPort * sel1Port,		// Port connected to SEL1 of PLL
									  BitOutputPort * sel0Port,		// Port connected to SEL0 of PLL
									  BitInputPort  * pllErrorPort,  // if TRUE then PLL error
									  BOOL				use2061 = FALSE
									  );

		virtual Error Reset();
		
		virtual Error SetBaseFrequency(int index, DWORD freq);
		
		virtual Error SetCCIR(BOOL ccir);
	};


#endif // of ONLY_EXTERNAL_VISIBLE	

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\clocks\specific\pll1700.h ===
// FILE:			library\hardware\clock\specific\pll1700.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1999 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		29.07.1999
//
// PURPOSE:		BurrBrown PLL1700 Multi-Clock Generator class
//
// HISTORY:

#ifndef PLL1700_H
#define PLL1700_H

#include "..\generic\clocks.h"
#include "..\generic\clckport.h"
#include "library\lowlevel\hardwrio.h"

// Programmable clock generator (output frequency programmable)
class PLL1700ClockGenerator : public ProgrammableClockGenerator {
	private:
		WordOutputPort		*	port;
		WORD						outputEnableMask;
		BOOL						mClockEnable;
		BOOL						invMClockEnable;
		WORD						controlWord;
	protected:
		Error ProgramFrequency(DWORD freq);
	public:
		PLL1700ClockGenerator(WordOutputPort * port, WORD outputEnableMask);

		Error SetMasterClock(BOOL enable, BOOL enableInverse);
		Error Reset();
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\communic\generic\communication.h ===
#ifndef COMMUNICATION_H
#define COMMUNICATION_H

#include "library\common\virtunit.h"
#include "library\common\tags.h"
#include "library\common\tagunits.h"
#include "library\common\krnlsync.h"

#define COPR_RS232			MKFLAG(0)
#define COPR_I2C				MKFLAG(1)

MKTAG(COMM_PROTOCOL_SUPPORTED,		COMMUNICATION_UNIT, 0x0001, DWORD)
MKTAG(COMM_PROTOCOL,						COMMUNICATION_UNIT, 0x0002, DWORD)
MKTAG(COMM_BAUD_RATE,					COMMUNICATION_UNIT, 0x0003, DWORD)
MKTAG(COMM_PORT_AFFINITY,				COMMUNICATION_UNIT, 0x0004, DWORD)
MKTAG(COMM_INPUT_BUFFER_SIZE,			COMMUNICATION_UNIT, 0x0005, DWORD)
MKTAG(COMM_OUTPUT_BUFFER_SIZE,		COMMUNICATION_UNIT, 0x0006, DWORD)

#define COUN_INFINITE		0xffffffff

class CommunicationBuffer
	{
	protected:
		BYTE				*	buffer;
		DWORD					bufferSize, bufferMask, bufferStart, bufferStop;

		DWORD					waitForDataSize, waitForSpaceSize;
		BOOL					waitForDataAbort, waitForSpaceAbort;
		VDTimedSemaphore	waitForDataEvent, waitForSpaceEvent;

	public:
		CommunicationBuffer(void);
		~CommunicationBuffer(void);

		Error AllocateBuffer(DWORD size);
		Error FlushBuffer(void);

		DWORD AvailData(void);
		DWORD AvailSpace(void);

		Error WriteByte(BYTE b);
		Error ReadByte(BYTE & b);
		Error WriteBytes(BYTE * p, DWORD num);
		Error ReadBytes(BYTE * p, DWORD num);

		Error WaitForData(DWORD num, DWORD timeout);
		Error WaitForSpace(DWORD num, DWORD timeout);

		Error AbortWaitForData(void);
		Error AbortWaitForSpace(void);
	};

class CommunicationStreamInterface
	{
	public:
		virtual DWORD AvailableInputData(void) = 0;
		virtual Error ReadData(BYTE * buffer, DWORD num, DWORD & done) = 0;
		virtual Error WaitForInputData(DWORD num, DWORD timeout) = 0;
		virtual Error AbortWaitForInputData(void) = 0;

		virtual DWORD AvailableOutputBuffer(void) = 0;
		virtual Error WriteData(BYTE * buffer, DWORD num, DWORD & done) = 0;
		virtual Error WaitForOutputBuffer(DWORD num, DWORD timeout) = 0;
		virtual Error AbortWaitForOutputBuffer(void) = 0;

		virtual Error InitializeConnection(void) = 0;
		virtual Error AbortConnection(void) = 0;

		virtual Error SetBufferSize(DWORD input, DWORD output) = 0;
	};

class CommunicationPort : public PhysicalUnit, virtual public CommunicationStreamInterface
	{
	friend class VirtualCommunicationUnit;
	public:
		CommunicationPort(void);
		~CommunicationPort(void);

		virtual Error SetProtocol(DWORD protocol) = 0;
		virtual Error SetBaudRate(DWORD rate) = 0;
	};

class BufferedCommunicationStream : virtual public CommunicationStreamInterface
	{
	protected:
		CommunicationBuffer	inputBuffer, outputBuffer;
		BOOL						abortConnection;

		virtual void NotifyOutputDataAvailable(void) = 0;
		virtual void NotifyInputSpaceAvailable(void) = 0;

	public:
		BufferedCommunicationStream(void);
		virtual ~BufferedCommunicationStream(void);

		// Functions of CommunicationStreamInterface.
		DWORD AvailableInputData(void);
		Error ReadData(BYTE * buffer, DWORD num, DWORD & done);
		Error WaitForInputData(DWORD num, DWORD timeout);
		Error AbortWaitForInputData(void);

		DWORD AvailableOutputBuffer(void);
		Error WriteData(BYTE * buffer, DWORD num, DWORD & done);
		Error WaitForOutputBuffer(DWORD num, DWORD timeout);
		Error AbortWaitForOutputBuffer(void);

		Error InitializeConnection(void);
		Error AbortConnection(void);

		Error SetBufferSize(DWORD input, DWORD output);
	};

class BufferedByteCommunicationStream : public BufferedCommunicationStream
	{
	protected:
		Error GetOutputByte(BYTE & b) {return outputBuffer.ReadByte(b);}
		BOOL IsOutputDataAvailable(void) {return outputBuffer.AvailData() >= 1;}
		Error PutInputByte(BYTE b) {return inputBuffer.WriteByte(b);}
		BOOL IsInputSpaceAvailable(void) {return inputBuffer.AvailSpace() >= 1;}
	};


class VirtualCommunicationPort : public VirtualUnit
	{
	protected:
		virtual DWORD ProtocolsSupported(void) = 0;

		CommunicationPort * physical;

		DWORD protocol;
		DWORD baudRate;
		DWORD affinity;
		DWORD inputBufferSize, outputBufferSize;

		Error PreemptStopPrevious(VirtualUnit * previous);
		Error PreemptChange(VirtualUnit * previous);
		Error PreemptStartNew(VirtualUnit * previous);

	public:
		VirtualCommunicationPort(CommunicationPort * physical);
		virtual ~VirtualCommunicationPort(void);

		Error Configure (TAG __far *tags);

		DWORD AvailableInputData(void);
		Error ReadData(BYTE * buffer, DWORD num, DWORD & done);
		Error WaitForInputData(DWORD num, DWORD timeout);
		Error AbortWaitForInputData(void);

		DWORD AvailableOutputBuffer(void);
		Error WriteData(BYTE * buffer, DWORD num, DWORD & done);
		Error WaitForOutputBuffer(DWORD num, DWORD timeout);
		Error AbortWaitForOutputBuffer(void);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\communic\specific\UART5505.h ===
#ifndef UART5505_H
#define UART5505_H

#include "library\lowlevel\memmpdio.h"
#include "library\hardware\communic\generic\RS232Communication.h"
#include "library\lowlevel\intrctrl.h"

class UART5505CommunicationPort : public RS232CommunicationPort, 
                                  public BufferedByteCommunicationStream, 
                                  protected InterruptHandler
	{
	protected:
		MemoryMappedIO		*	port;
		InterruptServer	*	irqServer;

		DWORD controlShadow;
		DWORD intEnableShadow;

		void NotifyOutputDataAvailable(void);
		void NotifyInputSpaceAvailable(void);

		Error SetProtocol(DWORD protocol);
		Error SetBaudRate(DWORD rate);
		Error SetRS232Parameters(DWORD dataBits, DWORD stopBits, RS232CommParity parity, RS232CommHandshake handshake);

		Error InitializeConnection(void);
		Error AbortConnection(void);

	public:
		UART5505CommunicationPort(MemoryMappedIO * port, InterruptServer * irqServer);
		virtual ~UART5505CommunicationPort(void);

		virtual VirtualUnit * CreateVirtual(void);

		void Interrupt(void);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\communic\generic\RS232Communication.h ===
#ifndef RS232COMMUNICATION_H
#define RS232COMMUNICATION_H

#include "library\hardware\communic\generic\Communication.h"

enum RS232CommParity
	{
	RSCP_PARITY_NONE,
	RSCP_PARITY_EVEN,
	RSCP_PARITY_ODD
	};

enum RS232CommHandshake
	{
	RSCH_HANDSHAKE_NONE,
	RSCH_HANDSHAKE_xONxOFF,
	RSCH_HANDSHAKE_CTSDTS
	};

MKTAG(COMM_RS232_DATA_BITS,				COMMUNICATION_UNIT, 0x0101, DWORD)
MKTAG(COMM_RS232_STOP_BITS,				COMMUNICATION_UNIT, 0x0102, DWORD)
MKTAG(COMM_RS232_PARITY,					COMMUNICATION_UNIT, 0x0103, RS232CommParity)
MKTAG(COMM_RS232_HANDSHAKE,				COMMUNICATION_UNIT, 0x0104, RS232CommHandshake)


class RS232CommunicationPort : public CommunicationPort
	{
	public:
		virtual Error SetRS232Parameters(DWORD dataBits, DWORD stopBits, RS232CommParity parity, RS232CommHandshake handshake) = 0;
	};

class VirtualRS232CommunicationPort : public VirtualCommunicationPort
	{
	protected:
		DWORD ProtocolsSupported(void);

		RS232CommunicationPort * physical;

		DWORD dataBits, stopBits;
		RS232CommParity parity;
		RS232CommHandshake handshake;

		Error PreemptChange(VirtualUnit * previous);

	public:
		VirtualRS232CommunicationPort(RS232CommunicationPort * physical);
		~VirtualRS232CommunicationPort(void);

		Error Configure (TAG __far *tags);
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\drives\specific\dvdatapi.h ===
// FILE:      library\hardware\drives\specific\dvdatapi.h
// AUTHOR:    D. Heidrich
// COPYRIGHT: (c) 1999 Viona Development.  All Rights Reserved.
// CREATED:   04.02.99
//
// PURPOSE:   General ATAPI DVD drive for CE.
//
// HISTORY:

#ifndef DVDATAPI_H
#define DVDATAPI_H

#include "library\lowlevel\hwbusio.h"
#include "library\lowlevel\memmpdio.h"
#include "library\common\krnlsync.h"
#include "library\common\winports.h"
#include "library\hardware\drives\generic\cdvddrv.h"
#include "library\hardware\mpeg2dec\generic\mp2dcryp.h"
#include "library\hardware\uproc\specific\st55xx\frnt5505.h"

#include <semaphor.h>



class DVDAtapiDrive : public GenericCDVDDrive, public MPEG2DVDDecryption
	{
	friend void DVDAtapi_HandlerTask (void *drive);

	private:
		BYTE lastModeClose;   // for Sanyo door open/close 

		MemoryMappedIO *port;
		MemoryMappedIO *controlPort;
		MemoryMappedIO *dataPort;
		MemoryMappedIO *epldPort;
		STi5505FrontEnd *frontEnd;
		WinPort *winPort;

		VDMutex monitorMutex;

		BOOL firstBlockWasRead;

		enum TrayStatus
			{
			TRAY_UNKNOWN, TRAY_CLOSING, TRAY_CLOSED, TRAY_OPENING, TRAY_OPEN
			} trayStatus;
		BOOL diskIsIdentified;
		BOOL traySuddenlyOpened;
		clock_t loadMediaTimeOut;

		semaphore_t irqSema;
		int diskTrayLocked;
		int currentSlotNumber;
		BOOL dataHold;
		BYTE status[6];
		BYTE sector[3];
		BYTE layer;
		BYTE playMode;
		int servoState;

		// Additional disk information, valid if LOAD_MEDIA succeeds.
		BOOL dvdMode;
		int agid;

		BOOL dualLayer;
		BOOL oppositeTrack;
		BOOL encryptedDisk;
		int regionCode;
		DWORD dataStartSector;		// usually 0x30000
		DWORD dataEndSector;
		DWORD layerZeroEndSector;
		int firstTOC, lastTOC;   // for CD mode only
		int leadOutMin, leadOutSec, leadOutFrm;   // for CD mode only

		Error CheckDriveReady (void);
		Error RequestSense (void);
		Error WaitForIRQ (void);
		Error ReadStatus (void);


		DWORD packetArray[3];
		Error DoPacket (void *buffer, int length, BOOL write = FALSE, BOOL useDMA = FALSE);


		enum Command
			{
			CMD_ILLEGAL,				// internal command
			CMD_TICK,					// internal command
			CMD_WAKEUPDRIVE,			// internal command
			CMD_GET_COPY_INFO,		// internal command
			CMD_START_AUTHENTICATION,		// internal command
			CMD_CANCEL_AUTHENTICATION,		// internal command
			CMD_GET_BUSKEY,			// internal command
			CMD_SEND_BUSKEY,			// internal command
			CMD_GET_CHALLENGEKEY,	// internal command
			CMD_SEND_CHALLENGEKEY,	// internal command
			CMD_GET_DISKKEY,			// internal command
			CMD_GET_TITLEKEY,			// internal command
			CMD_WRITE_DISKKEY,		// internal command
			CMD_WRITE_TITLEKEY,		// internal command
			CMD_UNLOCK_BUFFERS,		// internal command
			CMD_READ_TOC,				// internal command
			CMD_SET_READMODE,			// internal command
			CMD_SEEKBLOCK,				// internal command
			CMD_READBLOCKS,
			CMD_READFORCED,
			CMD_LOCK,
			CMD_UNLOCK,
			CMD_LOADMEDIA,
			CMD_UNLOADMEDIA,
			CMD_STOP,
			CMD_PAUSE
			};

		Error HandlerCommand (Command command);


		// Access to any sector on the disk.
		Error InternalReadBlocks (DWORD sector, DWORD num, void __far * buffer, DriveStreamBlockBuffer * blockBuffer,
		                          BYTE *subChannels, CDSectorType type = CST_CD_DA);


		// Track buffer.
		BYTE *trackBufferPtr;
		BYTE *dataOverflowPtr;   // overflow area for FEC DMA
		int sectorSize;
		int sectorOffset;
		int totalSectors;

		struct BufferInfo {
			DWORD sectorNumber;
			DWORD lockCount;
			BYTE *dataPtr;
			DWORD dummy;   // align struct size to 16 bytes
			};
		BufferInfo *bufferInfoMap;
		FrontEnd5505BufferStatus *bufferStatusMap;   // for buffer locking


		// Handler task related.
		void HandlerTask (void);
		void StopTransfer (void);
		void FlushTrackbuffer (void);
		BOOL handlerTaskRunning;
		int startReadCount;
		CDSectorType currentCDSectorType;
		BOOL currentIsStreamingData;

		Error HandlerLoadMedia (int slotNumber, BOOL wait);
		Error HandlerUnloadMedia (BOOL wait);
		Error HandlerReadBlocks (DWORD sector, DWORD num, BYTE *buffer);

		semaphore_t newRequest;
		semaphore_t requestDone;
		struct {
			// input
			Command command;
			DWORD sector;
			BYTE *buffer;
			int num;
			CDSectorType sectorType;
			BOOL isStreamingData;
			DWORD numberOfSectors;
			DriveStreamBlockBuffer *blockBuffer;
			// output
			Error error;
			} request;
		DWORD timeOutOneSecond;
		DWORD timeOutOneMilliSecond;

		// These variables are used by both consumer and producer. They are sampled so they
		// don't have to be protected by a mutex.
		//VDMutex trackMutex;
		int validStart;
		int readStart;
		DWORD lockedEnteringFreeArea;
		DWORD lockedLeavingFreeArea;


		volatile BOOL insideReadRequest, terminateReadRequest;


	public:
		void DisplayDebugRecord (void);   // only for internal debugging!


	public:
		DVDAtapiDrive (MemoryMappedIO *port, MemoryMappedIO *controlPort, MemoryMappedIO *dataPort, MemoryMappedIO *epldPort,
		               STi5505FrontEnd *frontEnd, WinPort *winPort = NULL);
		virtual ~DVDAtapiDrive (void);

		virtual Error Initialize (void);

		virtual Error ReadDVDBlocks (DWORD block, DWORD num, void __far * buffer, BOOL streaming);
		virtual Error ReadDVDForced (DWORD block, DWORD num, void __far * buffer, BOOL streaming);
		virtual Error ReadAndLockStreamBlocks (DWORD block, DWORD num, DriveStreamBlockBuffer * blocks, BOOL streaming);
		virtual Error UnlockStreamBlocks (DWORD num, DriveStreamBlockBuffer * blocks);
		virtual BOOL PrefersStreamBlocks (void);

		virtual Error SeekDVDBlock (DWORD block, BOOL streaming);

		virtual Error TerminateRead (void);

		virtual Error Stop (void);
		virtual Error Pause (void);

		virtual Error StartAuthentication (void);
		virtual Error SendChallengeKey (BYTE __far * key);
		virtual Error GetBusKey (BYTE __far * key);
		virtual Error GetChallengeKey (BYTE __far * key);
		virtual Error SendBusKey (BYTE __far * key);
		virtual Error GetDiskKey (BYTE __far * key);
		virtual Error CompleteAuthentication (void);
		virtual Error CancelAuthentication (void);
		virtual Error GetTitleKey (DWORD block, BYTE __far * key);

		virtual BOOL IsEncrypted (void);
		virtual BOOL IsDVDDrive (void);

		virtual Error DVDInquiry (BOOL __far & removable, BYTE __far & deviceType);

		virtual Error Lock (void);
		virtual Error Unlock (void);
		virtual Error LoadMedia (int slotNumber, BOOL wait);
		virtual Error UnloadMedia (BOOL wait);
		virtual Error GetDriveStatus (GenericTrayStatus &status);

		virtual Error WakeUpDrive (void);

		virtual Error ReadCDBlocks (DWORD block, DWORD num, void __far * buffer, CDSectorType type, void __far * subChannels, BOOL streaming);
		virtual Error ReadTOC (CDATocEntry *toc, int &tocEntryNum);

		virtual Error SeekCDBlock (DWORD block, CDSectorType type, BOOL streaming);

		// Decryption cell programming.
		virtual Error DoAuthenticationCommand (MPEG2DVDAuthenticationCommand com, DWORD sector, BYTE __far * key);

		virtual GenericIRQTrigger GetInterruptTrigger (void);

		virtual Error GetCopyManagementInfo (DWORD block, GenericCopyManagementInfo __far & copyManagementInfo);

		virtual void Interrupt (void);
		virtual void InterruptFrontEnd (void);
		virtual void InterruptPushSense (void);
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\drives\specific\piopd4995.h ===
// FILE:      library\hardware\drives\specific\piopd4995.h
// AUTHOR:    D. Heidrich
// COPYRIGHT: (c) 1999 Ravisent Technologies. All Rights Reserved.
// CREATED:   21.09.99
//
// PURPOSE:   Pioneer DVD drive for CE.
//
// HISTORY:

#ifndef PIOPD4995_H
#define PIOPD4995_H

#include "library\lowlevel\hwbusio.h"
#include "library\lowlevel\memmpdio.h"
#include "library\common\krnlsync.h"
#include "library\common\winports.h"
#include "library\hardware\drives\generic\cdvddrv.h"
#include "library\hardware\mpeg2dec\generic\mp2dcryp.h"
#include "library\hardware\uproc\specific\st55xx\frnt5505.h"
#include "library\hardware\uproc\specific\pd4995\pd4995r.h"

#include <semaphor.h>



class PioneerPD4995 : public GenericCDVDDrive, public MPEG2DVDDecryption
	{
	friend void PioneerPD4995_HandlerTask (void *drive);

	private:
		MemoryMappedIO *port;
		STi5505FrontEnd *frontEnd;
		int irqLevel;
		WinPort *winPort;

		VDMutex monitorMutex;

		BOOL firstBlockWasRead;

		enum TrayStatus
			{
			TRAY_UNKNOWN, TRAY_CLOSING, TRAY_CLOSED, TRAY_OPENING, TRAY_OPEN
			} trayStatus;
		BOOL diskIsIdentified;
		clock_t loadMediaTimeOut;

		semaphore_t irqSema;
		int diskTrayLocked;
		int currentSlotNumber;
		BOOL dataHold;
		BYTE status[6];
		BYTE sector[3];
		BYTE layer;
		BYTE playMode;
		int servoState;

		// Additional disk information, valid if LOAD_MEDIA succeeds.
		BOOL dvdMode;
		BOOL dualLayer;
		BOOL oppositeTrack;
		BOOL encryptedDisk;
		int regionCode;
		DWORD dataStartSector;		// usually 0x30000
		DWORD dataEndSector;
		DWORD layerZeroEndSector;
		int firstTOC, lastTOC;   // for CD mode only
		int leadOutMin, leadOutSec, leadOutFrm;   // for CD mode only

		int ReadQChannel (BYTE *start, int nbits);

		Error CheckDriveReady (void);
		Error RequestSense (void);
		Error WaitForIRQ (void);
		Error ReadStatus (void);

		Error StartDiskTransfer (int vbrBlockindex, int numBlocks);
		void StopDiskTransfer (void);

		BYTE packetArray[8];
		BYTE statusArray[8];

		Error DoPacket (BYTE *buffer, int length, BOOL waitForCompletion = FALSE);

		enum Command
			{
			CMD_ILLEGAL,				// internal command
			CMD_TICK,					// internal command
			CMD_WAKEUPDRIVE,			// internal command
			CMD_GET_COPY_INFO,		// internal command
			CMD_WRITE_DISKKEY,		// internal command
			CMD_WRITE_TITLEKEY,		// internal command
			CMD_READ_TOC,				// internal command
			CMD_SET_READMODE,			// internal command
			CMD_SEEKBLOCK,				// internal command
			CMD_READBLOCKS,
			CMD_READFORCED,
			CMD_LOCK,
			CMD_UNLOCK,
			CMD_LOADMEDIA,
			CMD_UNLOADMEDIA,
			CMD_STOP,
			CMD_PAUSE,
			CMD_SEND_CONTROL_DATA
			};

		Error HandlerCommand (Command command);


		// Access to any sector on the disk.
		Error InternalReadBlocks (DWORD sector, DWORD num, void __far * buffer, CDSectorType type = CST_CD_DA, BOOL rawRead = FALSE);


		// Track buffer.
		BYTE *trackBufferPtr;
		int sectorSize;
		int sectorOffset;
		int sectorsPerBlock;
		int totalVBRBuffers, totalVBRBlocks;
		BYTE **bufferMap;
		DWORD *sectorNumberMap;
		struct SectorHeader {
			BYTE headerbytes[8];   // contains IED and CPR_MAI for DVD or Q subcodes for CD
			int blockIndex;   // index of the block that the sector belongs to
			int dataIndex;   // index of the corresponding data inside that block
			};
		SectorHeader *sectorHeaderMap;
		BOOL *sectorHasErrors;
		VDMutex byteAccessMutex;


		// Handler task related.
		void HandlerTask (void);
		BOOL handlerTaskRunning;
		int startReadCount;
		BOOL spinningStopped;
		CDSectorType currentCDSectorType;
		BOOL currentIsStreamingData;

		semaphore_t newRequest;
		semaphore_t requestDone;
		struct {
			Command command;					// input
			DWORD sector;						// input
			int num;								// input
			BYTE *buffer;						// input
			CDSectorType sectorType;		// input
			BOOL isStreamingData;			// input
			Error error;						// output
			} request;
		DWORD timeOutOneSecond;

		// For disk to VBR transfer.
		int nextTransferBlock, nextTransferSector;
		int sectorsToTransfer, sectorsTransferred;
		enum {
			DISKTRANSFER_STOPPED, DISKTRANSFER_STREAMING, DISKTRANSFER_LASTBLOCK
			} transferState;

		// DMA from VBR to memory.
		int nextDMASector;
		int sectorsToDMA, sectorsDMADone;

		// The following members are protected by trackControlMutex.
		VDMutex trackControlMutex;
		int validBuffers;   // number of valid buffers in the track buffer
		int validStart;
		// these variables for TVM501_TASK_TWOSTAGED only
		DWORD knownAreaStart;   // inclusive value, first sector number in known area
		DWORD knownAreaEnd;   // inclusive value, last sector number in known area

		volatile BOOL insideReadRequest, terminateReadRequest;

		Error HandlerLoadMedia (int slotNumber, BOOL wait);
		Error HandlerUnloadMedia (BOOL wait);


	public:
		void DisplayDebugRecord (void);   // only for internal debugging!


	public:
		PioneerPD4995 (MemoryMappedIO *port, STi5505FrontEnd *frontEnd, int irqLevel, WinPort *winPort = NULL);
		virtual ~PioneerPD4995 (void);

		virtual Error Initialize (void);

		virtual Error ReadDVDBlocks (DWORD sector, DWORD num, void __far * buffer, BOOL streaming);
		virtual Error ReadDVDForced (DWORD sector, DWORD num, void __far * buffer, BOOL streaming);

		virtual Error SeekDVDBlock (DWORD sector, BOOL streaming);

		virtual Error TerminateRead (void);

		virtual Error Stop (void);
		virtual Error Pause (void);

		virtual Error StartAuthentication (void);
		virtual Error SendChallengeKey (BYTE __far * key);
		virtual Error GetBusKey (BYTE __far * key);
		virtual Error GetChallengeKey (BYTE __far * key);
		virtual Error SendBusKey (BYTE __far * key);
		virtual Error GetDiskKey (BYTE __far * key);
		virtual Error CompleteAuthentication (void);
		virtual Error CancelAuthentication (void);
		virtual Error GetTitleKey (DWORD sector, BYTE __far * key);

		virtual BOOL IsEncrypted (void);
		virtual BOOL IsDVDDrive (void);

		virtual Error DVDInquiry (BOOL __far & removable, BYTE __far & deviceType);

		virtual Error Lock (void);
		virtual Error Unlock (void);
		virtual Error LoadMedia (int slotNumber, BOOL wait);
		virtual Error UnloadMedia (BOOL wait);
		virtual Error GetDriveStatus (GenericTrayStatus &status);

		virtual Error WakeUpDrive (void);

		virtual Error ReadCDBlocks (DWORD sector, DWORD num, void __far * buffer, CDSectorType type, void __far * subChannels, BOOL streaming);
		virtual Error ReadTOC (CDATocEntry *toc, int &tocEntryNum);

		virtual Error SeekCDBlock (DWORD sector, CDSectorType type, BOOL streaming);

		// Decryption cell programming.
		virtual Error DoAuthenticationCommand (MPEG2DVDAuthenticationCommand com, DWORD sector, BYTE __far * key);

		virtual GenericIRQTrigger GetInterruptTrigger (void);

		virtual Error GetCopyManagementInfo (DWORD sector, GenericCopyManagementInfo __far & copyManagementInfo);

		virtual void Interrupt (void);
		virtual void InterruptFrontEnd (void);
		virtual void InterruptPushSense (void);
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\drives\specific\PCDVDrive.h ===
////////////////////////////////////////////////////////////////////
//
//  PC CDVD Drive Implementation
//
////////////////////////////////////////////////////////////////////

#ifndef PCDVDRIVE_H
#define PCDVDRIVE_H

#include "CDVDDrive.h"
#include "library\support\aspi32\wnaspi32.h"
#include "library\common\vddebug.h"
#include "y:\winntddk\src\storage\inc\ntddscsi.h"

//////////////////////////////////////////////////////////////////////
//
//  Small Form Factor Drive Commands
//
//////////////////////////////////////////////////////////////////////

#define SFF_REQUEST_SENSE				0x03
#define SFF_MODE_SENSE					0x5a
#define SFF_MODE_SELECT					0x55
#define SFF_READ_CD_MSF					0xb9
#define SFF_READ_CD						0xbe
#define SFF_READ_DISC_INFO				0x51
#define SFF_READ_DVD_STRUCTURE		0xad
#define SFF_READ_TOC						0x43
#define SFF_DVD_READ						0xa8
#define SFF_START_STOP_UNIT			0x1b
#define SFF_MEDIA_REMOVAL				0x1e
#define SFF_SEND_KEY						0xa3
#define SFF_REPORT_KEY					0xa4
#define SFF_INQUIRY						0x12

//////////////////////////////////////////////////////////////////////
//
//  Small Form Factor CDVD Drive
//
//////////////////////////////////////////////////////////////////////

class SFFCDVDDrive : public CDVDDrive
	{
	protected:
		BYTE					agid;
		int					lockCount;
		BYTE				*	flagsPtr;
		PVOID				*	buffPtr;
		DWORD				*	buffLenPtr;
		BYTE				*	cdbLenPtr;
		BYTE				*	cdbPtr;
		BOOL					isStreaming;
		CRITICAL_SECTION	lock;

		PCDriveBlockBuffer blockBuffer;

		BOOL IsDVDDrive(void);		// Check if this is really a DVD drive

		//
		//  DVD Authentication
		//

		virtual Error StartAuthentication(void);
		virtual Error CompleteAuthentication(void);
		virtual Error CancelAuthentication(void);
		virtual Error GetChallengeKey(BYTE * key);
		virtual Error SendChallengeKey(BYTE * key);
		virtual Error GetBusKey(BYTE * key);
		virtual Error SendBusKey(BYTE * key);
		virtual Error GetDiskKey(BYTE * key);
		virtual Error GetTitleKey(DWORD block, BYTE * key);

		virtual Error ReadDVDBlocks(DWORD block, DWORD num, void * buffer);
		virtual Error ReadDVDForced(DWORD block, DWORD num, void * buffer);
		virtual Error ReadCDBlocks(DWORD block, DWORD num, DiskSectorType sectorType, void * buffer);

		//
		//  Internal helper functions
		//

		void TranslateSenseInformation(BYTE * senseArea, Error & err, BOOL & retry);
		virtual void SetStreamingMode(BOOL streaming) {isStreaming = streaming;}
		virtual void SetSubChannelDefaultValues(BYTE * subChannelInfo, CDATime start, CDATime length);


		//
		//  Internal functions to be implemented specifically
		//

		virtual void EnterSection(void) = 0;
		virtual void LeaveSection(void) = 0;
		virtual Error DoCommand(void) = 0;

	public:
		SFFCDVDDrive(void);
		SFFCDVDDrive(const KernelString & driveName, DWORD conFlags);
		virtual ~SFFCDVDDrive(void);

		virtual Error Init(const KernelString & driveName, DWORD conFlags);
		virtual Error Cleanup(void);

		//
		//  Inquiry & config functions
		//

		virtual Error GetDriveCaps(GenericDriveType & type, DWORD & caps, DWORD & slots);
		virtual Error Configure(DWORD conFlags);

		//
		//  Basic Drive Functions
		//

		virtual Error SpinUp(void);												// Spin up drive
		virtual Error SpinDown(void);												// Spin down drive
		virtual Error TerminateRequest(DWORD reqID);							// Terminate the current request (read/write)
		virtual Error Flush(void);													// Make sure all commands are executed
		virtual Error Detach(void);												// Release drive and never access it again

		//
		//  Media handling
		//

		virtual Error LoadMedia(int slotNumber = 0, BOOL wait = TRUE);	// Close Tray, load media in slot slotNumber
		virtual Error UnloadMedia(BOOL wait = TRUE);							// Open Tray, remove current media

		virtual Error GetTrayStatus(GenericTrayStatus & status);			// Get Tray Status, was: GetDriveStatus
		virtual Error LockTray(void);												// Lock Tray
		virtual Error UnlockTray(void);											// Unlock Tray

		virtual GenericDiskType GetDiskType(void);							// DVD, CD Rom, Audio CD, ...
		virtual Error GetCopyManagementInfo(DWORD block, GenericCopyManagementInfo & copyManagementInfo);

		//
		//  Data Access Functions
		//

		virtual Error SeekBlock(DWORD block, DWORD flags, DWORD & reqID);
		virtual Error LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, DWORD & reqID);
		virtual Error UnlockBlocks(DWORD block, DWORD num, DWORD flags, DWORD & reqID);

		virtual Error GetDriveBlockSize(DWORD & currentSize, DWORD & minSize, DWORD & maxSize, DWORD & step);
		virtual Error SetDriveBlockSize(DWORD size);

		virtual Error GetNumberOfDriveBlocks(DWORD & num);
		virtual Error SetNumberOfDriveBlocks(DWORD num);

		//
		//  DVD Authentication
		//

		virtual BOOL  DVDIsEncrypted(void);
		virtual Error DoAuthenticationCommand(DVDAuthenticationCommand com, DWORD sector, BYTE * key)
		virtual Error GetRPCData(BYTE & regionCode, BYTE & availSets, BOOL & isRPC2);
		virtual Error SetRegionCode(BYTE region);

		//
		//  CD Access Methods
		//

		virtual WORD  GetNumberOfSessions(void);
		virtual Error ReadCDTOC(WORD session, CDTocEntry * toc, int & tocEntryNum, DWORD & reqID);

	};

//////////////////////////////////////////////////////////////////////
//
//  PCDVDrive Class
//
//////////////////////////////////////////////////////////////////////

class PCDVDrive : public CDVDDrive
	{
	protected:
		BYTE					agid;
		int					lockCount;
		BYTE				*	flagsPtr;
		PVOID				*	buffPtr;
		DWORD				*	buffLenPtr;
		BYTE				*	cdbLenPtr;
		BYTE				*	cdbPtr;
		BOOL					isStreaming;
		CRITICAL_SECTION	lock;

		PCDriveBlockBuffer blockBuffer;

		BOOL IsDVDDrive(void);		// Check if this is really a DVD drive

		//
		//  DVD Authentication
		//

		virtual Error StartAuthentication(void);
		virtual Error CompleteAuthentication(void);
		virtual Error CancelAuthentication(void);
		virtual Error GetChallengeKey(BYTE * key);
		virtual Error SendChallengeKey(BYTE * key);
		virtual Error GetBusKey(BYTE * key);
		virtual Error SendBusKey(BYTE * key);
		virtual Error GetDiskKey(BYTE * key);
		virtual Error GetTitleKey(DWORD block, BYTE * key);

		virtual Error DoCommand(void) = 0;
		void TranslateSenseInformation(BYTE * senseArea, Error & err, BOOL & retry);

		virtual Error ReadDVDBlocks(DWORD block, DWORD num, void * buffer);
		virtual Error ReadDVDForced(DWORD block, DWORD num, void * buffer);
		virtual Error ReadCDBlocks(DWORD block, DWORD num, DiskSectorType sectorType, void * buffer);

		virtual void SetStreamingMode(BOOL streaming) {isStreaming = streaming;}

		virtual void SetSubChannelDefaultValues(BYTE * subChannelInfo, CDATime start, CDATime length);

		void EnterSection(void);
		void LeaveSection(void);

	public:
		PCDVDrive(void);
		PCDVDrive(const KernelString & driveName, DWORD conFlags);
		virtual ~PCDVDrive(void);

		virtual Error Init(const KernelString & driveName, DWORD conFlags);
		virtual Error Cleanup(void);

		//
		//  Inquiry & config functions
		//

		virtual Error GetDriveCaps(GenericDriveType & type, DWORD & caps, DWORD & slots);
		virtual Error Configure(DWORD conFlags);

		//
		//  Basic Drive Functions
		//

		virtual Error SpinUp(void);												// Spin up drive
		virtual Error SpinDown(void);												// Spin down drive
		virtual Error TerminateRequest(DWORD reqID);							// Terminate the current request (read/write)
		virtual Error Flush(void);													// Make sure all commands are executed
		virtual Error Detach(void);												// Release drive and never access it again

		//
		//  Media handling
		//

		virtual Error LoadMedia(int slotNumber = 0, BOOL wait = TRUE);	// Close Tray, load media in slot slotNumber
		virtual Error UnloadMedia(BOOL wait = TRUE);							// Open Tray, remove current media

		virtual Error GetTrayStatus(GenericTrayStatus & status);			// Get Tray Status, was: GetDriveStatus
		virtual Error LockTray(void);												// Lock Tray
		virtual Error UnlockTray(void);											// Unlock Tray

		virtual GenericDiskType GetDiskType(void);							// DVD, CD Rom, Audio CD, ...
		virtual Error GetCopyManagementInfo(DWORD block, GenericCopyManagementInfo & copyManagementInfo);

		//
		//  Data Access Functions
		//

		virtual Error SeekBlock(DWORD block, DWORD flags, DWORD & reqID);
		virtual Error LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, DWORD & reqID);
		virtual Error UnlockBlocks(DWORD block, DWORD num, DWORD flags, DWORD & reqID);

		virtual Error GetDriveBlockSize(DWORD & currentSize, DWORD & minSize, DWORD & maxSize, DWORD & step);
		virtual Error SetDriveBlockSize(DWORD size);

		virtual Error GetNumberOfDriveBlocks(DWORD & num);
		virtual Error SetNumberOfDriveBlocks(DWORD num);

		//
		//  DVD Authentication
		//

		virtual BOOL  DVDIsEncrypted(void);
		virtual Error DoAuthenticationCommand(DVDAuthenticationCommand com, DWORD sector, BYTE * key)
		virtual Error GetRPCData(BYTE & regionCode, BYTE & availSets, BOOL & isRPC2);
		virtual Error SetRegionCode(BYTE region);

		//
		//  CD Access Methods
		//

		virtual WORD  GetNumberOfSessions(void);
		virtual Error ReadCDTOC(WORD session, CDTocEntry * toc, int & tocEntryNum, DWORD & reqID);
	};

//////////////////////////////////////////////////////////////////////
//
//  ASPI CDVD Drive Class
//
//////////////////////////////////////////////////////////////////////


#define VWIN32_DIOC_DOS_IOCTL 1 

typedef struct _DEVIOCTL_REGISTERS
	{
	DWORD reg_EBX; 
	DWORD reg_EDX; 
	DWORD reg_ECX; 
	DWORD reg_EAX; 
	DWORD reg_EDI; 
	DWORD reg_ESI; 
	DWORD reg_Flags; 
	} DEVIOCTL_REGISTERS, *PDEVIOCTL_REGISTERS; 

class ASPICDVDDrive : public PCDVDrive
	{
	protected:
		SRB_ExecSCSICmd	cmd;

		HANDLE				aspiCompletionEvent;

		DWORD					driveNumber;

		void *				cdaBuffer;			// Place to store mixed audio/subchannel data

		CDATime				cdaBufferLength;	// Size of the buffer

		BYTE	*				tocBuffer;			// Place for CD TOC information
		DWORD					tocBufferSize;		// Size of the TOC buffer
		WORD					numSessions;		// Number of sessions on CD

		//
		//  Internal functions
		//

		BOOL DoIOCTL(PDEVIOCTL_REGISTERS preg);

		virtual void EnterSection(void);
		virtual void LeaveSection(void);
		virtual Error DoCommand(void);

		void SetStreamingMode(BOOL streaming);

	public:
		ASOICDVDDrive(void);
		ASPICDVDDrive(WORD adapter, WORD id, DWORD driveNumber);
		virtual ~ASPICDVDDrive(void);

		virtual Error Init(const KernelString & driveName, DWORD conFlags);
		virtual Error Cleanup(void);

		virtual Error Inquiry(BOOL & removable, BYTE & deviceType)
			{removable = TRUE; deviceType = 0x5; return TRUE;}

		virtual Error LockTray(void);
		virtual Error UnlockTray(void);
		virtual Error UnloadMedia(BOOL wait = TRUE);

		virtual Error SeekBlock(DWORD block, DWORD flags, DWORD & reqID);
		virtual Error LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, DWORD & reqID);
		virtual Error UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, DWORD & reqID);

		virtual WORD  GetNumberOfSessions(void);
		virtual Error ReadCDTOC(WORD session, CDTocEntry * toc, int & tocEntryNum, DWORD & reqID);
	};

//////////////////////////////////////////////////////////////////////
//
//   NT4 CDVD Drive Class
//
//////////////////////////////////////////////////////////////////////

//
//  Some defines
//

typedef struct _SCSI_PASS_THROUGH_WITH_BUFFERS
	{
	SCSI_PASS_THROUGH spt;
	ULONG             Filler;      // realign buffers to double word boundary
	UCHAR             ucSenseBuf[32];
	UCHAR             ucDataBuf[2352];
	} SCSI_PASS_THROUGH_WITH_BUFFERS, *PSCSI_PASS_THROUGH_WITH_BUFFERS;

typedef struct _SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER
	{
	SCSI_PASS_THROUGH_DIRECT sptd;
	ULONG             Filler;      // realign buffer to double word boundary
	UCHAR             ucSenseBuf[32];
	} SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER, *PSCSI_PASS_THROUGH_DIRECT_WITH_BUFFER;

//
//  NT4 CDVD Drive
//

class NT4CDVDDrive : public PCDVDrive
	{
	protected:
		HANDLE	hDevice;

		BYTE		dummyFlag;
		LPVOID	bufferPtr;
	
		SCSI_PASS_THROUGH_WITH_BUFFERS	sptdwb;

		TCHAR		deviceName[16];

		BOOL rpc2Check;

		//
		//  Internal functions
		//

		virtual Error OpenDevice(bool closeFirst = FALSE);

		virtual void EnterSection(void);
		virtual void LeaveSection(void);
		virtual Error DoCommand(void);

		void SetStreamingMode(BOOL streaming);

	public:
		NT4CDVDDrive(KernelString devName);
		virtual ~NT4CDVDDrive(void);
		
		virtual Error ReadBlocks(DWORD block, DWORD num, void * buffer, BOOL streaming);
		virtual Error ReadForced(DWORD block, DWORD num, void * buffer, BOOL streaming);
		virtual Error ReadCDABlocks(CDATime start, CDATime length, void * buffer, void * subChannels);
		virtual Error ReadCDAToc(CDATocEntry * toc, int & tocEntryNum);
		virtual Error ReadCDBlocks(DWORD block, DWORD num, void * buffer, CDSectorType type, BOOL streaming = FALSE);

		virtual Error GetRPCData(BYTE & regionCode, BYTE & availResets, BOOL & isRPC2);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\drives\generic\driveerrors.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  Error Declaration for Drive Classes
//
////////////////////////////////////////////////////////////////////


#ifndef DRIVEERRORS_H
#define DRIVEERRORS_H

#include "library\common\gnerrors.h"

#define GNR_DRIVE_FAILURE							MKERR(ERROR,	DISK,			HARDWARE,			0x00)
// General drive failure

#define GNR_DRIVE_FATAL_ERROR						MKERR(ERROR,	DISK,			HARDWARE,			0x01)
// Drive firmware is not responding any more

#define GNR_NO_VALID_DISK							MKERR(ERROR,	DISK,			OBJECT,				0x00)
// No valid/known disk was found

#define GNR_NO_DRIVE									MKERR(ERROR,	DISK,			OBJECT,				0x02)
// Drive does not exist/could not be found

#define GNR_DRIVE_DETACHED							MKERR(ERROR,	DISK,			OBJECT,				0x03)
// The drive has been detached -> is not available for playback

#define GNR_NO_DVD_DRIVE							MKERR(ERROR,	DISK,			OBJECT,				0x04)
// The drive is not a DVD drive (used on PCs)

#define GNR_BLOCK_ALREADY_LOCKED					MKERR(ERROR,	DISK,			OBJECT,				0x05)
// A block was already locked in a different mode (read/write)

#define GNR_BLOCK_NOT_LOCKED						MKERR(ERROR,	DISK,			OBJECT,				0x06)
// The block not be unlocked is not locked

#define GNR_DISK_IS_NOT_PRESENT					MKERR(ERROR,	DISK,			OBJECT,				0x07)
// The disk is not present in the drive

#define GNR_INVALID_DRIVE_LETTER					MKERR(ERROR,	DISK,			BOUNDS,				0x01)
// The drive letter specified was not correct/out of range

#define GNR_DISK_READ_ONLY							MKERR(ERROR,	DISK,			FILEIO,				0x00)
// The disk is read-only

#define GNR_DRIVE_LOCK_FAILED						MKERR(ERROR,	DISK,			OPERATION,			0x00)
// Unable to lock/unlock the drive

#define GNR_DRIVE_ALREADY_LOCKED					MKERR(WARNING,	DISK,			OPERATION,			0x01)
// The drive was already locked

#define GNR_DRIVE_LOAD_FAILED						MKERR(ERROR,	DISK,			OPERATION,			0x02)
// Could not load/unload the drive

#define GNR_DRIVE_NOT_LOADABLE					MKERR(ERROR,	DISK,			OPERATION,			0x03)
// Drive does not support loading/unloading the disk

#define GNR_READ_ERROR								MKERR(ERROR,	DISK,			OPERATION,			0x04)
// Some read error occurred

#define GNR_WRITE_ERROR								MKERR(ERROR,	DISK,			OPERATION,			0x05)
// Some write error occurred

#define GNR_HIGH_TEMPERATURE						MKERR(ERROR,	DISK,			OPERATION,			0x06)
// Drive reported that is is unable to work properly due to high temperature

#define GNR_COPY_PROTECTION_VIOLATION			MKERR(ERROR,	DISK,			COPYPROTECTION,	0x00)

#define GNR_COPY_PROTECTION_FAILED				MKERR(ERROR,	DISK,			COPYPROTECTION,	0x01)

#define GNR_READ_ERROR_SECTOR_ENCRYPTED		MKERR(ERROR,	DISK,			COPYPROTECTION,	0x02)
// A sector was requested which happened to be encrypted, but the authentication process was not completed

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\drives\specific\W2KCDVDDrive.h ===
////////////////////////////////////////////////////////////////////
//
//  NT5 CDVD Drive Class
//
////////////////////////////////////////////////////////////////////

#ifndef W2KCDVDRVIVE_H
#define W2KCDVDRVIVE_H

#include "cdvddrive.h"
#include <devioctl.h>
#include <ntddstor.h>
#pragma warning(disable : 4200)
#include "y:\w2000ddk\src\storage\inc\ntddcdvd.h"
#pragma warning(default : 4200)
#include "library\common\krnlsync.h"


class W2KCDVDDrive : public CDVDDrive
	{
	protected:
		DVD_SESSION_ID sessionId;
		TCHAR				deviceName[16];
		int				lockCount;
		HANDLE			hDevice;		
		VDLocalMutex	mutex;

		//
		//  DVD authentication
		//

		virtual Error StartAuthentication(void);
		virtual Error SendChallengeKey(BYTE * key);
		virtual Error GetBusKey(BYTE * key);
		virtual Error GetChallengeKey(BYTE * key);
		virtual Error SendBusKey(BYTE * key);
		virtual Error GetDiskKey(BYTE * key);
		virtual Error CompleteAuthentication(void);
		virtual Error CancelAuthentication(void);
		virtual Error GetTitleKey(DWORD block, BYTE * key);

		Error				GetDevice(BOOL forced=false);
		Error				ReadCDASubchannel(void __far * subchannel);

	public:
		W2KCDVDDrive(KernelString devName);
		~W2KCDVDDrive();

		virtual Error ReadBlocks(DWORD block, DWORD num, void * buffer, BOOL streaming);
		virtual Error ReadForced(DWORD block, DWORD num, void * buffer, BOOL streaming);
		virtual Error ReadCDABlocks(CDATime start, CDATime length, void * buffer, void * subChannel);
		virtual Error ReadCDAToc(CDATocEntry * toc, int & tocEntryNum);
		virtual Error ReadCDBlocks(DWORD block, DWORD num, void * buffer, CDSectorType type, BOOL streaming = FALSE);

		virtual BOOL  IsEncrypted(void);
		virtual BOOL  IsDVDDrive(void);
		virtual Error DoAuthenticationCommand(DVDAuthenticationCommand com, DWORD sector, BYTE * key);

		virtual Error Inquiry(BOOL & removable, BYTE & deviceType);
		virtual Error WakeUpDrive(void) {GNRAISE_OK;}

		virtual Error Lock(void);
		virtual Error Unlock(void);
		virtual Error LoadMedia(int slotNumber = 0, BOOL wait = FALSE);
		virtual Error UnloadMedia(BOOL wait = FALSE);
		virtual Error GetDriveStatus(GenericTrayStatus & status);
		
		virtual Error GetRPCData(BYTE & regionCode, BYTE & availResets, BOOL & isRPC2);
		virtual Error SetRegion(BYTE regionCode);

		virtual Error GetCopyManagementInfo(DWORD block, GenericCopyManagementInfo & gcmi);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\jpeg\generic\Jcoder.h ===
// FILE:      library\hardware\jpeg\generic\jcoder.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1996 Viona Development.  All Rights Reserved.
// CREATED:   12.01.96
//
// PURPOSE: JPEG coder class.
//
// HISTORY:

#ifndef JCODER_H
#define JCODER_H

#include "library\common\prelude.h"
#include "library\common\virtunit.h"
#include "library\hardware\video\generic\vidtypes.h"
#include "library\hardware\jpeg\generic\jpegdefs.h"



#ifndef ONLY_EXTERNAL_VISIBLE



class JCoder : public PhysicalUnit
	{
	public:
		// These must be BYTEs, even for Unicode !
		static BYTE DefaultAPPStringSingle[];
		static BYTE DefaultAPPStringOdd[];
		static BYTE DefaultAPPStringEven[];
	};



class VirtualJCoder : public VirtualUnit
	{
	public:
		VirtualJCoder (JCoder *physical);

		virtual Error Configure (TAG __far *tags);

		// These are allowed only after locking and activating the unit.
		virtual Error InitOperation (void) = 0;
		virtual void Start (void) = 0;
		virtual void Stop  (void) = 0;

		Error GetFieldOrder (FPTR field, DWORD size, VideoField __far &fieldOrder);
		Error GetSizes (FPTR frame, DWORD size, WORD __far &width, WORD __far &height);
		Error MarkFirstField (FPTR frame, DWORD size, VideoField fieldOrder);

	protected:
		virtual Error Preempt (VirtualUnit *previous);

		// Find a marker and return its position, zero for not found.
		DWORD FindMarker (FPTR buffer, DWORD bufferSize, BYTE marker);

		BOOL compress;             // compression or expansion ?
		BOOL stillMode;            // still or motion mode ?
		WORD width, height;
		VideoField fieldOrder;
	};



#endif // ONLY_EXTERNAL_VISIBILE



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\drives\specific\tvm501.h ===
// FILE:      library\hardware\drives\specific\tvm501.h
// AUTHOR:    D. Heidrich, H. Horak
// COPYRIGHT: (c) 1998 Viona Development.  All Rights Reserved.
// CREATED:   10.07.98
//
// PURPOSE:   Thomson TVM501 DVD drive.
//
// HISTORY:

#ifndef TVM501_H
#define TVM501_H

#include "library\lowlevel\hwbusio.h"
#include "library\lowlevel\memmpdio.h"
#include "library\common\krnlsync.h"
#include "library\common\profiles.h"
#include "library\common\winports.h"
#include "library\hardware\drives\generic\cdvddrv.h"
#include "library\hardware\mpeg2dec\generic\mp2dcryp.h"
#include "library\hardware\uproc\specific\st55xx\frnt5505.h"

#include <semaphor.h>
#include <time.h>



#define TVM501_I2C_ADDRESS  0x30



class TVM501Drive : public GenericCDVDDrive, public MPEG2DVDDecryption
	{
	friend void TVM501_HandlerTask (void *drive);

	private:
		AsyncByteInOutBus *port;
		STi5505FrontEnd *frontEnd;
		GenericProfile *profile;
		MemoryMappedIO *pio1;
		MemoryMappedIO *pio2;
		MemoryMappedIO *pio3;
		WinPort *winPort;

		// Configurable parameters.
		DWORD handlerTimeout;
		int maxHandlerRetries;
		DWORD defaultRequestTimeout;
		DWORD cdRequestTimeout;
		DWORD cddaRequestTimeout;
		DWORD longLatencyDistance;

		// Drive information.
		BOOL driveIs501;
		BOOL swapCDDABytes;

		VDMutex monitorMutex;

		BOOL pushSensed, pushSenseAllowed;
		clock_t trayOpenedTime;

		semaphore_t irqSema;
		int diskTrayLocked;
		BOOL dataHold;
		BYTE status[6];
		BYTE sector[3];
		BYTE layer;
		BYTE playMode;
		int servoState;

		enum Command
			{
			CMD501_ILLEGAL,			// internal command
			CMD501_TICK,				// internal command
			CMD501_SPIN_UP,			// internal command
			CMD501_WRITE_DISKKEY,	// internal command
			CMD501_WRITE_TITLEKEY,	// internal command
			CMD501_UNLOCK_BUFFERS,	// internal command
			CMD501_READ_TOC,			// internal command
			CMD501_SET_READMODE,		// internal command
			CMD501_SEEKBLOCK,			// internal command
			CMD501_READBLOCKS,
			CMD501_READFORCED,
			CMD501_LOCK,
			CMD501_UNLOCK,
			CMD501_LOADMEDIA,
			CMD501_UNLOADMEDIA,
			CMD501_STOP,
			CMD501_PAUSE
			};

		VDMutex trayMutex;
		BOOL emergencyEject;
		enum TrayStatus
			{
			TRAY501_UNKNOWN, TRAY501_CLOSING, TRAY501_CLOSED, TRAY501_OPENING, TRAY501_OPEN
			} trayStatus;

		Error CheckForEmergencyEject (void);

		enum DriveCommand
			{
			DC501_none		= 0x00,
			DC501_stop		= 0x80,
			DC501_ndisc		= 0x01,
			DC501_plsn		= 0x02,
			DC501_sdisc		= 0x83,
			DC501_plmsf		= 0x85,
			DC501_gloc		= 0x86,
			DC501_pause		= 0x07,
			DC501_pmod		= 0x89,
			DC501_sskst		= 0x8a,
			DC501_ssken		= 0x0b,
			DC501_noskip	= 0x8c,
			DC501_bca		= 0x0d,
			DC501_gmod		= 0x0e	// TVM502
			};

		// Additional disk information, valid if LOAD_MEDIA succeeds.
		BOOL diskIsIdentified;
		BOOL dvdMode;
		BOOL dualLayer;
		BOOL oppositeTrack;
		BOOL encryptedDisk;
		int regionCode;
		DWORD dataStartSector;		// usually 0x30000
		DWORD dataEndSector;
		DWORD layerZeroEndSector;
		int firstTOC, lastTOC;   // for CD mode only
		int leadOutMin, leadOutSec, leadOutFrm;   // for CD mode only

		Error MoveTray (BOOL close);
		Error ProgramDrive (DriveCommand command);
		Error Execute (Command command);
		Error WaitForState (int wantedState);
		Error WaitForIRQ (void);
		Error ReadStatus (void);

		Error UploadPatchCode (BYTE *data, int size);

		// Access to any sector on the disk.
		Error InternalReadBlocks (DWORD block, DWORD num, void __far * buffer, DriveStreamBlockBuffer * blockBuffer,
		                          BYTE *subChannels, BOOL streaming, CDSectorType type = CST_CD_DA, BOOL rawRead = FALSE);

		int ReadQChannel (BYTE *start, int nbits);
		Error FindCDSectorNumber (BYTE *source, DWORD &sectorNumber, int &offset, int &bytesLeftInRow);
		BOOL DescrambleAndCopyCD (BYTE *src1, int bytesLeftInRow, int bytesLeftInPart1,
		                          BYTE *src2, int bytesLeftInPart2,
		                          BYTE *dst);


		// Track buffer.
		BYTE *trackBufferPtr;
		int sectorSize;
		int sectorOffset;
		int totalSectors;


		// Handler task related.
		void HandlerTask (void);
		void StopTransfer (void);
		void FlushTrackbuffer (void);
		BOOL handlerTaskRunning;
		BYTE **bufferMap;
		DWORD *sectorNumberMap;
		int startReadCount;
		BOOL spinningStopped;
		CDSectorType currentCDSectorType;
		BOOL currentIsStreamingData;

		semaphore_t newRequest;
		semaphore_t requestDone;
		struct {
			Command command;	// input
			DWORD sector;		// input
			BYTE *key;			// input
			CDSectorType sectorType;	// input
			BOOL isStreamingData;		// input
			DWORD numberOfSectors;		// input
			DriveStreamBlockBuffer *blockBuffer;	// input
			Error error;		// output
			} request;
		DWORD timeOutOneSecond;

		// Buffer-locking related.
		FrontEnd5505BufferStatus *bufferStatusMap;
		DWORD *bufferLockCount;

		// The following members are protected by trackControlMutex.
		VDMutex trackControlMutex;
		int validBuffers;   // number of valid buffers in the track buffer
		int validStart;
		int lockedBuffers;   // number of locked buffers outside of the valid area
		// these variables for TVM501_TASK_TWOSTAGED only
		DWORD knownAreaStart;   // inclusive value, first sector number in known area
		DWORD knownAreaEnd;   // inclusive value, last sector number in known area

		// The following members are protected by syncPatternMutex.
		VDMutex syncPatternMutex;
		int syncLocationOffset, syncLocationBytesLeftInRow;   // for CD mode only


		volatile BOOL insideReadRequest, terminateReadRequest;


	public:
		void DisplayDebugRecord (void);   // only for internal debugging!


	public:
		TVM501Drive (AsyncByteInOutBus *port, STi5505FrontEnd *frontEnd, GenericProfile *profile,
		             MemoryMappedIO *pio1, MemoryMappedIO *pio2, MemoryMappedIO *pio3, WinPort *winPort = NULL);
		virtual ~TVM501Drive (void);

		virtual Error Initialize(void);

		virtual Error ReadDVDBlocks(DWORD block, DWORD num, void __far * buffer, BOOL streaming);
		virtual Error ReadDVDForced(DWORD block, DWORD num, void __far * buffer, BOOL streaming);
		virtual Error ReadAndLockStreamBlocks (DWORD block, DWORD num, DriveStreamBlockBuffer * blocks, BOOL streaming);
		virtual Error UnlockStreamBlocks (DWORD num, DriveStreamBlockBuffer * blocks);
		virtual BOOL PrefersStreamBlocks (void);

		virtual Error SeekDVDBlock (DWORD block, BOOL streaming);

		virtual Error TerminateRead (void);

		virtual Error Stop(void);
		virtual Error Pause(void);

		virtual Error StartAuthentication(void);
		virtual Error SendChallengeKey(BYTE __far * key);
		virtual Error GetBusKey(BYTE __far * key);
		virtual Error GetChallengeKey(BYTE __far * key);
		virtual Error SendBusKey(BYTE __far * key);
		virtual Error GetDiskKey(BYTE __far * key);
		virtual Error CompleteAuthentication(void);
		virtual Error CancelAuthentication(void);
		virtual Error GetTitleKey(DWORD block, BYTE __far * key);

		virtual BOOL IsEncrypted(void);
		virtual BOOL IsDVDDrive(void);

		virtual Error DVDInquiry(BOOL __far & removable, BYTE __far & deviceType);

		virtual Error Lock (void);
		virtual Error Unlock (void);
		virtual Error LoadMedia (int slotNumber, BOOL wait);
		virtual Error UnloadMedia (BOOL wait);
		virtual Error GetDriveStatus (GenericTrayStatus &status);

		virtual Error WakeUpDrive (void);

		virtual Error ReadCDBlocks (DWORD block, DWORD num, void __far * buffer, CDSectorType type, void __far * subChannels, BOOL streaming);
		virtual Error ReadTOC (CDATocEntry *toc, int &tocEntryNum);

		virtual Error SeekCDBlock (DWORD block, CDSectorType type, BOOL streaming);

		// Decryption cell programming.
		virtual Error DoAuthenticationCommand (MPEG2DVDAuthenticationCommand com, DWORD sector, BYTE __far * key);

		virtual GenericIRQTrigger GetInterruptTrigger (void);

		virtual Error GetCopyManagementInfo (DWORD block, GenericCopyManagementInfo __far & copyManagementInfo);

		virtual void Interrupt (void);
		virtual void InterruptFrontEnd (void);
		virtual void InterruptPushSense (void);
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\drives\specific\SFFCDVDDrive.h ===
////////////////////////////////////////////////////////////////////
//
//  Small Form Factor CDVD Drive Class
//
////////////////////////////////////////////////////////////////////

#ifndef SFFCDVDDRIVE_H
#define SFFCDVDDRIVE_H

#include "CDVDDrive.h"
#include "library\common\vddebug.h"

//////////////////////////////////////////////////////////////////////
//
//  Small Form Factor Drive Commands
//
//////////////////////////////////////////////////////////////////////

#define SFF_REQUEST_SENSE				0x03
#define SFF_MODE_SENSE					0x5a
#define SFF_MODE_SELECT					0x55
#define SFF_READ_CD_MSF					0xb9
#define SFF_READ_CD						0xbe
#define SFF_READ_DISC_INFO				0x51
#define SFF_READ_DVD_STRUCTURE		0xad
#define SFF_READ_TOC						0x43
#define SFF_DVD_READ						0xa8
#define SFF_START_STOP_UNIT			0x1b
#define SFF_MEDIA_REMOVAL				0x1e
#define SFF_SEND_KEY						0xa3
#define SFF_REPORT_KEY					0xa4
#define SFF_INQUIRY						0x12

//////////////////////////////////////////////////////////////////////
//
//  Small Form Factor CDVD Drive
//
//////////////////////////////////////////////////////////////////////

class SFFCDVDDrive : public CDVDDrive
	{
	protected:
		BYTE					agid;					// For DVD authentication
		int					lockCount;			// Number of times tray was locked

		BYTE				*	flagsPtr;			// SFF comand pointer
		PVOID				*	buffPtr;				// SFF comand pointer
		DWORD				*	buffLenPtr;			// SFF comand pointer
		BYTE				*	cdbLenPtr;			// SFF comand pointer
		BYTE				*	cdbPtr;				// SFF comand pointer

		BOOL					isStreaming;

		DriveBlockBuffer	*	blockBuffer;	// Data storage

		//
		//  DVD Authentication
		//

		virtual Error StartAuthentication(void);
		virtual Error CompleteAuthentication(void);
		virtual Error CancelAuthentication(void);
		virtual Error GetChallengeKey(BYTE * key);
		virtual Error SendChallengeKey(BYTE * key);
		virtual Error GetBusKey(BYTE * key);
		virtual Error SendBusKey(BYTE * key);
		virtual Error GetDiskKey(BYTE * key);
		virtual Error GetTitleKey(DWORD block, BYTE * key);

		//
		//  Data Access
		//

		virtual Error ReadDVDBlocks(DWORD block, DWORD num, void * buffer, DWORD flags);
		virtual Error ReadDVDForced(DWORD block, DWORD num, void * buffer, DWORD flags);
		virtual Error ReadCDBlocks(DWORD block, DWORD num, DiskSectorType sectorType, void * buffer);

		//
		//  Internal helper functions
		//

				  void  TranslateSenseInformation(BYTE * senseArea, Error & err, BOOL & retry);
		virtual void  SetStreamingMode(BOOL streaming) {isStreaming = streaming;}
		virtual void  SetSubChannelDefaultValues(BYTE * subChannelInfo, CDATime start, CDATime length);
		virtual Error Inquiry(BOOL & removable, BYTE & deviceType);

		//
		//  Internal functions to be implemented specifically
		//

		virtual void  EnterSection(void) = 0;
		virtual void  LeaveSection(void) = 0;
		virtual Error DoCommand(void) = 0;

	public:
		SFFCDVDDrive(void);
		SFFCDVDDrive(const KernelString & driveName, DWORD conFlags);
		virtual ~SFFCDVDDrive(void);

		virtual Error Init(const KernelString & driveName, DWORD conFlags);
		virtual Error Cleanup(void);

		//
		//  Inquiry & config functions
		//

		virtual Error GetDriveCaps(GenericDriveType & type, DWORD & caps, DWORD & slots);
		virtual Error Configure(DWORD conFlags);

		//
		//  Basic Drive Functions
		//

		virtual Error SpinUp(void);												// Spin up drive
		virtual Error SpinDown(void);												// Spin down drive
		virtual Error TerminateRequest(DWORD reqID);							// Terminate the current request (read/write)
		virtual Error Flush(void) = 0;											// Make sure all commands are executed
		virtual Error Detach(void) = 0;											// Release drive and never access it again

		//
		//  Media handling
		//

		virtual Error LoadMedia(int slotNumber = 0, BOOL wait = TRUE);	// Close Tray, load media in slot slotNumber
		virtual Error UnloadMedia(BOOL wait = TRUE);							// Open Tray, remove current media

		virtual Error GetTrayStatus(GenericTrayStatus & status);			// Get Tray Status, was: GetDriveStatus
		virtual Error LockTray(void);												// Lock Tray
		virtual Error UnlockTray(void);											// Unlock Tray

		virtual GenericDiskType GetDiskType(void);							// DVD, CD Rom, Audio CD, ...
		virtual Error GetCopyManagementInfo(DWORD block, GenericCopyManagementInfo & copyManagementInfo);

		//
		//  Data access functions
		//

		virtual Error SeekBlock(DWORD block, DWORD flags, DWORD & reqID);
		virtual Error LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, DWORD & reqID);
		virtual Error UnlockBlocks(DWORD block, DWORD num, DWORD flags, DWORD & reqID);

		virtual Error GetDriveBlockSize(DWORD & currentSize, DWORD & minSize, DWORD & maxSize, DWORD & step);
		virtual Error SetDriveBlockSize(DWORD size);

		virtual Error GetNumberOfDriveBlocks(DWORD & num);
		virtual Error SetNumberOfDriveBlocks(DWORD num);

		//
		//  DVD authentication and region coding
		//

		virtual BOOL  DVDIsEncrypted(void);
		virtual Error DoAuthenticationCommand(DVDAuthenticationCommand com, DWORD sector, BYTE * key)
		virtual Error GetRPCData(BYTE & regionCode, BYTE & availSets, BOOL & isRPC2);
		virtual Error SetRegionCode(BYTE region);

		//
		//  CD Access Methods
		//

		virtual WORD  GetNumberOfSessions(void);
		virtual Error ReadCDTOC(WORD session, CDTocEntry * toc, int & tocEntryNum, DWORD & reqID);
	};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\jpeg\generic\Rgb2yuv.h ===
// FILE:      library\hardware\jpeg\generic\yuv2rgb.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1996 Viona Development. All Rights Reserved.
// CREATED:   09.02.96
//
// PURPOSE: Functions to convert RGB to YUV.
//
// HISTORY:

#ifndef RGB2YUV_H
#define RGB2YUV_H

#include "library\common\prelude.h"


extern "C"
	{
#if NT_KERNEL
	WORD __stdcall mapRGB24toYUV422Blocks (FPTR src, FPTR dst,
	                                          WORD width, WORD height,
	                                          BOOL singleField);
	
	WORD __stdcall mapRGB32toYUV422Blocks (FPTR src, FPTR dst,
	                                          WORD width, WORD height,
	                                          BOOL singleField);
#else
	WORD __far PASCAL mapRGB24toYUV422Blocks (FPTR src, FPTR dst,
	                                          WORD width, WORD height,
	                                          BOOL singleField);
	
	WORD __far PASCAL mapRGB32toYUV422Blocks (FPTR src, FPTR dst,
	                                          WORD width, WORD height,
	                                          BOOL singleField);
#endif
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\jpeg\generic\Jcodrate.h ===
// FILE:      library\hardware\jpeg\generic\jcodrate.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1996 Viona Development.  All Rights Reserved.
// CREATED:   12.01.96
//
// PURPOSE: JPEG coder with bit rate control class.
//
// HISTORY:

#ifndef JCODRATE_H
#define JCODRATE_H

#include "jcoder.h"



#ifndef ONLY_EXTERNAL_VISIBLE



class JCoderRated : public JCoder
	{
	protected:
		virtual WORD GetLastScaleFactor (void) = 0;
	};



class VirtualJCoderRated : public VirtualJCoder
	{
	public:
		VirtualJCoderRated (JCoderRated *physical);

		virtual Error Configure (TAG __far *tags);

		virtual WORD GetLastScaleFactor (void) = 0;

	protected:
		DWORD totalCodeVolume;   // in bytes
		WORD  maxBlockCodeVolume;
		WORD  scaleFactor;
		BOOL  enableDRI;
		WORD  dri;
	};



#endif // ONLY_EXTERNAL_VISIBILE



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\jpeg\generic\Jpegdefs.h ===
// FILE:      library\hardware\jpeg\generic\jpegdefs.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1996 Viona Development.  All Rights Reserved.
// CREATED:   12.01.96
//
// PURPOSE: Common JPEG definitions.
//
// HISTORY:

#ifndef JPEGDEFS_H
#define JPEGDEFS_H

#include "library\common\prelude.h"
#include "library\common\tags.h"
#include "library\common\tagunits.h"
#include "library\common\hooks.h"
#include "library\common\gnerrors.h"
#include "library\hardware\video\generic\vidtypes.h"



typedef struct JPEGCaptureMsgStruct
	{
	FPTR info;
	FPTR userData;
	DWORD frameNum;
	DWORD byteSize;   // of compressed data or buffer byte size
	DWORD captureTime;
	} JPEGCaptureMsg;

MKHOOK(JPEGCapture, JPEGCaptureMsg);



typedef struct JPEGPlaybackMsgStruct
	{
	FPTR userData;
	DWORD nowTime;   // system time for frame in milliseconds
	DWORD baseTime;  // base system time for first IRQ
	} JPEGPlaybackMsg;

MKHOOK(JPEGPlayback, JPEGPlaybackMsg);



typedef struct JPEGMsgStruct
	{
	FPTR userData;
	} JPEGMsg;

MKHOOK(JPEGMessage, JPEGMsg);



// Allowed compression video standards.

enum AllowedJPEGVStandard
	{
	AVSTD_NTSC_ONLY, AVSTD_PAL_ONLY, AVSTD_NTSC_PAL_BOTH
	};



#define GNR_JPEG_PIPE_FULL	MKERR(WARNING, JPEG, GENERAL, 0x01)   // cannot store more buffers

#define GNR_JPEG_BOUNDS		MKERR(ERROR, JPEG, BOUNDS,   0x10)
#define GNR_JPEG_ERROR		MKERR(ERROR, JPEG, GENERAL,  0x11)   // very general error type
#define GNR_JPEG_TIMEOUT	MKERR(ERROR, JPEG, TIMEOUT,  0x12)



// All parameters are accessible via tag calls.

MKTAG (JPG_VIDEO_STANDARD, JPEG_CODEC_UNIT, 0x0000001, VideoStandard)
MKTAG (JPG_VIDEO_FORMAT,   JPEG_CODEC_UNIT, 0x0000002, VideoFormat)
MKTAG (JPG_VIDEO_FMT_LIST, JPEG_CODEC_UNIT, 0x0000003, DWORD)
MKTAG (JPG_COMPRESS,       JPEG_CODEC_UNIT, 0x0000004, BOOL)
MKTAG (JPG_STILLMODE,      JPEG_CODEC_UNIT, 0x0000005, BOOL)
MKTAG (JPG_TOP,            JPEG_CODEC_UNIT, 0x0000006, int)
MKTAG (JPG_LEFT,           JPEG_CODEC_UNIT, 0x0000007, int)
MKTAG (JPG_WIDTH,          JPEG_CODEC_UNIT, 0x0000008, WORD)
MKTAG (JPG_HEIGHT,         JPEG_CODEC_UNIT, 0x0000009, WORD)
MKTAG (JPG_THUMBNAIL,      JPEG_CODEC_UNIT, 0x000000A, BOOL)
MKTAG (JPG_FIELD_ORDER,    JPEG_CODEC_UNIT, 0x000000B, VideoField)
MKTAG (JPG_QTABLE,         JPEG_CODEC_UNIT, 0x000000C, BYTE __far *)
MKTAG (JPG_HUFFTABLE,      JPEG_CODEC_UNIT, 0x000000D, BYTE __far *)
MKTAG (JPG_MSEC_PER_FRAME, JPEG_CODEC_UNIT, 0x000000E, DWORD)
MKTAG (JPG_SINGLEFRAME,    JPEG_CODEC_UNIT, 0x000000F, BOOL)   // it's single frame grab

MKTAG (JPG_TOTALCODEVOL,   JPEG_CODEC_UNIT, 0x0000010, DWORD)
MKTAG (JPG_MAXBLOCKVOL,    JPEG_CODEC_UNIT, 0x0000011, WORD)
MKTAG (JPG_SCALEFACTOR,    JPEG_CODEC_UNIT, 0x0000012, WORD)
MKTAG (JPG_ENABLE_DRI,     JPEG_CODEC_UNIT, 0x0000013, BOOL)
MKTAG (JPG_DRI,            JPEG_CODEC_UNIT, 0x0000014, WORD)

MKTAG (JPG_FILTERS_ON,     JPEG_CODEC_UNIT, 0x0000020, BOOL)
MKTAG (JPG_USE_DMA,        JPEG_CODEC_UNIT, 0x0000021, BOOL)
MKTAG (JPG_HAS_CODEMEMORY, JPEG_CODEC_UNIT, 0x0000022, BOOL)  // read-only; do we have on-board code buffers ?
MKTAG (JPG_HOFFSET,        JPEG_CODEC_UNIT, 0x0000023, int)   // operation-dependent horizontal offset, read-only
MKTAG (JPG_VOFFSET,        JPEG_CODEC_UNIT, 0x0000024, int)   // operation-dependent horizontal offset, read-only
MKTAG (JPG_WANTS_EXT_FI,   JPEG_CODEC_UNIT, 0x0000025, BOOL)  // operation-dependent external field indication, read-only
MKTAG (JPG_ALLOWED_VSTD,   JPEG_CODEC_UNIT, 0x0000026, AllowedJPEGVStandard)  // read-only
MKTAG (JPG_MAX_FIELDSIZE,  JPEG_CODEC_UNIT, 0x0000027, DWORD) // read-only; maximum field size

MKTAG (JPG_PREEMPT_HOOK,   JPEG_CODEC_UNIT, 0x0000030, JPEGMessageHook __far *)
MKTAG (JPG_CCIR_LEVELS,    JPEG_CODEC_UNIT, 0x0000031, BOOL)

MKTAG (JPG_VBUS_WIDTH,     JPEG_CODEC_UNIT, 0x0000040, WORD)   // read only, video bus image width
MKTAG (JPG_VBUS_HEIGHT,    JPEG_CODEC_UNIT, 0x0000041, WORD)   // read only, video bus image height



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\jpeg\generic\Jcore.h ===
// FILE:      library\hardware\jpeg\generic\jcore.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1996 Viona Development.  All Rights Reserved.
// CREATED:   15.01.96
//
// PURPOSE: The virtualized JPEG core.
//
// HISTORY:

#ifndef JPEGCORE_H
#define JPEGCORE_H

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"
#include "library\common\tags.h"
#include "library\common\hooks.h"
#include "library\common\virtunit.h"
#include "jpegdefs.h"
#include "jcoder.h"



#ifndef ONLY_EXTERNAL_VISIBLE



class JPEGManager : public PhysicalUnit
	{
	public:
		virtual void Start (void) = 0;
		virtual void Stop  (void) = 0;
	};



class VirtualJPEGUnit : public VirtualUnit
	{
	public:
		VirtualJPEGUnit (JPEGManager *physical, VirtualJCoder *coder);
		virtual ~VirtualJPEGUnit (void);

		virtual Error Configure (TAG __far *tags);

		virtual Error PrepareBuffer (FPTR buffer, DWORD size, FPTR __far &info) = 0;
		virtual Error UnprepareBuffer (FPTR info) = 0;

#if VIONA_VERSION
		virtual Error ExpandToRGB (FPTR src, DWORD size, FPTR dst, WORD dstWidth, WORD dstHeight, GrabFormat bitFormat) = 0;
		virtual BOOL IsValidExpansionScaling (WORD srcWidth, WORD srcHeight, WORD dstWidth, WORD dstHeight, GrabFormat bitFormat) = 0;
		virtual Error CompressFromRGB (FPTR src, FPTR dst, DWORD maxSize, DWORD __far &size, BOOL bits32) = 0;
		virtual BOOL IsValidCompression (WORD width, WORD height, BOOL bits32) = 0;
#else
		virtual Error ExpandToRGB (FPTR src, DWORD size, FPTR dst) = 0;
		virtual Error CompressFromRGB (FPTR src, FPTR dst, DWORD maxSize, DWORD __far &size) = 0;
#endif

		// These are allowed only after locking and activating the unit.
		virtual Error InitCapture (JPEGCaptureHook __far *hook) = 0;
		virtual Error FinishCapture (void) = 0;
		virtual Error AddVideoBuffer (FPTR info, FPTR userData, DWORD size) = 0;
		virtual Error Start (void);
		virtual Error Stop  (void);
		virtual Error AllocateVideoBuffer (DWORD size, FPTR __far &info, FPTR __far &data) = 0;
		virtual Error FreeVideoBuffer (FPTR info) = 0;
		virtual Error InitPlayback (JPEGPlaybackHook __far *hook) = 0;
		virtual Error FinishPlayback (void) = 0;
		virtual Error FlushPlayback (DWORD bufferSize) = 0;
		virtual Error PlayBuffer (FPTR info, DWORD size) = 0;

	protected:
		virtual Error Preempt (VirtualUnit *previous) = 0;

		VirtualJCoder *coder;

		BOOL changed;      // TRUE if Configure() changed a variable
		BOOL compress;
		BOOL stillMode;
		int top, left;
		WORD width, height;

		BOOL ccirLevels;

#if LOW_PIPELINE

#define NUM_BUFFERS     17
#define MAX_BUFFERS     16   // must be power of two !
#define WANTED_BUFFERS  7

		struct PlayingBuffer
			{
			FPTR data;
			DWORD size;
			LONG sampleNumber;
			};

		struct PlayPipe
			{
			DWORD maxBufferSize;
			DWORD rate, scale;
			PlayingBuffer __far *lastBufferPtr;
			BOOL buffersAllocated;
			BOOL identicalFrameNumberPassed;
			int volatile nBuffers;
			int volatile firstBuffer;
			int volatile lastBuffer;
			FPTR bufferInfo[NUM_BUFFERS];
			FPTR bufferData[NUM_BUFFERS];
			DWORD bufferSize[NUM_BUFFERS];
			PlayingBuffer buffers[NUM_BUFFERS];
			long startTime;
			int initBuffersAdded;
			};
		PlayPipe playPipe;

	public:
		Error AllocPlayPipe (DWORD maxBufferSize);
		Error FreePlayPipe (void);
		Error FlushPlayPipe (void);

		BOOL InsertPlayBuffer (PlayingBuffer __far *buffer);
		void RemoveBuffer (void);
		FPTR GetPlayBufferInfo (void) {return playPipe.bufferInfo[playPipe.firstBuffer];}
		PlayingBuffer __far *GetPlayBuffer (void)
			{
			if (playPipe.nBuffers > 0)
				return &playPipe.buffers[playPipe.firstBuffer];
			else
				return NULL;
			}
#endif // LOW_PIPELINE
	};



#endif // ONLY_EXTERNAL_VISIBLE



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\jpeg\generic\Yuv2rgb.h ===
// FILE:      library\hardware\jpeg\generic\yuv2rgb.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1996 Viona Development. All Rights Reserved.
// CREATED:   09.02.96
//
// PURPOSE: Functions to convert YUV to RGB.
//
// HISTORY:

#ifndef YUV2RGB_H
#define YUV2RGB_H

#include "library\common\prelude.h"


extern "C"
	{
#if NT_KERNEL
	WORD __stdcall mapYUV422BlockstoBGR24 (FPTR src, FPTR dst, WORD width, WORD height, WORD fieldOrder);
	WORD __stdcall mapYUV422BlockstoRGB16 (FPTR src, FPTR dst, WORD width, WORD height, WORD fieldOrder);
	WORD __stdcall mapYUV422BlockstoBGR32 (FPTR src, FPTR dst, WORD width, WORD height, WORD fieldOrder);
	
	WORD __stdcall mapYUV422BlockstoBGR32Scale (FPTR src, FPTR dst, WORD width, WORD height, WORD dstWidth, WORD dstHeight);
#else
	WORD __far PASCAL mapYUV422BlockstoBGR24 (FPTR src, FPTR dst, WORD width, WORD height, WORD fieldOrder);
	WORD __far PASCAL mapYUV422BlockstoRGB16 (FPTR src, FPTR dst, WORD width, WORD height, WORD fieldOrder);
	WORD __far PASCAL mapYUV422BlockstoBGR32 (FPTR src, FPTR dst, WORD width, WORD height, WORD fieldOrder);
	
	WORD __far PASCAL mapYUV422BlockstoBGR24Scale (FPTR src, FPTR dst, WORD width, WORD height, WORD dstWidth, WORD dstHeight);
	WORD __far PASCAL mapYUV422BlockstoBGR32Scale (FPTR src, FPTR dst, WORD width, WORD height, WORD dstWidth, WORD dstHeight);
#endif
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\jpeg\specific\Jcod050.h ===
// FILE:      library\hardware\jpeg\generic\jcod050.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1996 Viona Development.  All Rights Reserved.
// CREATED:   12.01.96
//
// PURPOSE: Implementation of JPEG coder with bit rate control using the ZR36050.
//
// HISTORY:

#ifndef JCOD050_H
#define JCOD050_H

#include "library\common\prelude.h"
#include "library\lowlevel\hardwrio.h"
#include "library\hardware\video\generic\vidtypes.h"
#include "library\hardware\jpeg\generic\jcodrate.h"



#ifndef ONLY_EXTERNAL_VISIBLE


#define APP_LENGTH  64

class VirtualJCoder050;



class JCoder050 : public JCoderRated
	{
	friend class VirtualJCoder050;

	private:
		ByteIndexedInOutPort *port;
		int cfisExpansion;

		DWORD SOFMarkerSize;
		DWORD SOSMarkerSize;
		DWORD APPMarkerSize;
		DWORD COMMarkerSize;
		DWORD DRIMarkerSize;
		DWORD DQTMarkerSize;
		DWORD DHTMarkerSize;
		DWORD DNLMarkerSize;
		DWORD DQTIMarkerSize;
		DWORD DHTIMarkerSize;

	public:
		// cfisExpansion must be 0..7.
		JCoder050 (ByteIndexedInOutPort *port, int cfisExpansion)
			{this->port = port;  this->cfisExpansion = cfisExpansion;}

		virtual VirtualUnit *CreateVirtual (void);

		void Start (void);
		BOOL Check050End (void);
		void PrepareGO (void);

	protected:
		BOOL ConfigureCompression (void);
		BOOL ConfigureExpansion (void);
		virtual WORD GetLastScaleFactor (void);

		VirtualJCoder050 *GetCurrent (void) {return (VirtualJCoder050 *)(JCoderRated::GetCurrent());}

		BYTE HSampRatio[8];
		BYTE VSampRatio[8];

		void MakeMarkerSegments (void);
		DWORD MakeSOFMarker (void);
		DWORD MakeSOS1Marker (void);
		DWORD MakeDRIMarker (void);
		DWORD MakeQTable (void);
		DWORD MakeHuffTable (void);
		DWORD MakeAPPString (void);
		DWORD MakeCOMString (void);
	};



class VirtualJCoder050 : public VirtualJCoderRated
	{
	friend class JCoder050;

	protected:
		JCoder050 *jcoder;

	public:
		VirtualJCoder050 (JCoder050 *physical);
		virtual ~VirtualJCoder050 (void);

		virtual Error Configure (TAG __far *tags);

		virtual Error InitOperation (void);

		virtual void Start (void) {jcoder->Start();}
		virtual void Stop  (void);

		WORD GetLastScaleFactor (void) {return jcoder->GetLastScaleFactor ();}

	protected:
		void SetDefaultAPP (void);

		VideoFormat format;
		BOOL thumbnail;     // Fast Preview mode ?
		BOOL twoPassMode;   // use Auto Bit Rate Control ?
		BYTE __far *qTable;
		BYTE __far *huffTable;
		BYTE __far *comString;

		BYTE appMarker[APP_LENGTH+1];
	};



#endif // ONLY_EXTERNAL_VISIBILE



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\jpeg\specific\Jcod050.cpp ===
// FILE:      library\hardware\jpeg\generic\jcod050.cpp
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1996 Viona Development.  All Rights Reserved.
// CREATED:   12.01.96
//
// PURPOSE: Implementation of JPEG coder with bit rate control using the ZR36050.
//
// HISTORY:

#include "jcod050.h"
#include "library\lowlevel\timer.h"

#include "library\support\gfxdebug\gfxdebug.h"





#define TABLE_PRELOAD_TIMEOUT  200





// This is the bit field that represents the video formats we support.

static DWORD VideoFormatBitField = (1 << VFMT_YUV_422) | (1 << VFMT_YUV_411) | (1 << VFMT_YUV_420);





// Definitions of quantities for baseline JPEG. This section can be modified
// if another compression scheme is needed.

#define NO_OF_COMPONENTS          3   // Y, U and V
#define BASELINE_PRECISION        8
#define NO_OF_SCAN1_COMPONENTS    3   // Y, U and V



// Indexes of 050 internal registers and of functional locations in the 050's
// internal memory.

#define GO                  0x000
// NOT USED                 0x001
#define HARDWARE            0x002
#define MODE                0x003
#define OPTIONS             0x004
#define MBCV_050            0x005
#define MARKERS_EN          0x006
#define INT_REQ_0           0x007
#define INT_REQ_1           0x008
#define TCV_NET_HI          0x009
#define TCV_NET_MH          0x00a
#define TCV_NET_ML          0x00b
#define TCV_NET_LO          0x00c
#define TCV_DATA_HI         0x00d
#define TCV_DATA_MH         0x00e
#define TCV_DATA_ML         0x00f
#define TCV_DATA_LO         0x010
#define SF_HI               0x011
#define SF_LO               0x012
#define AF_HI               0x013
#define AF_M                0x014
#define AF_LO               0x015
#define ACV_HI              0x016
#define ACV_MH              0x017
#define ACV_ML              0x018
#define ACV_LO              0x019
#define ACT_HI              0x01a
#define ACT_MH              0x01b
#define ACT_ML              0x01c
#define ACT_LO              0x01d
#define ACV_TRUN_HI         0x01e
#define ACV_TRUN_MH         0x01f
#define ACV_TRUN_ML         0x020
#define ACV_TRUN_LO         0x021
#define STATUS_0            0x02e
#define STATUS_1            0x02f



// Indexes of JPEG baseline markers segment in the 050's internal memory.

#define SOF_INDX            0x040
#define SOS1_INDX           0x07a
#define SOS2_INDX           0x08a
#define SOS3_INDX           0x09a
#define SOS4_INDX           0x0aa
#define DRI_INDX            0x0c0
#define DNL_INDX            0x0c6
#define DQT_INDX            0x0cc
#define DHT_INDX            0x1d4
#define APP_INDX            0x380
#define COM_INDX            0x3c0



// Values of JPEG baseline markers.

#define SOI_MARKER          0xD8
#define EOI_MARKER          0xD9
#define SOS_MARKER          0xDA
#define DQT_MARKER          0xDB
#define DNL_MARKER          0xDC
#define DRI_MARKER          0xDD
#define SOF0_MARKER         0xC0
#define DHT_MARKER          0xC4
#define APP_MARKER          0xE0
#define COM_MARKER          0xFE



// Bit masks in the 050's HARDWARE register.

#define BSWD_MASK           0x80
#define BSWD                0x80
#define NO_BSWD             0x00

#define MSTR_MASK           0x40
#define MSTR                0x40
#define NO_MSTR             0x00

#define DMA_MASK            0x20
#define DMA                 0x20
#define NO_DMA              0x00

#define CFIS_MASK           0x1C
#define CFIS_1_CLK          0x00
#define CFIS_2_CLK          0x04
#define CFIS_3_CLK          0x08
#define CFIS_4_CLK          0x0C
#define CFIS_5_CLK          0x10
#define CFIS_6_CLK          0x14
#define CFIS_7_CLK          0x18
#define CFIS_8_CLK          0x1C

#define BELE_MASK           0x01
#define BELE                0x01
#define NO_BELE             0x00



// Bit masks in the 050's MODE register.

#define COMP_MASK           0x80
#define COMP                0x80
#define NO_COMP             0x00

#define ATP_MASK            0x40
#define ATP                 0x40
#define NO_ATP              0x00

#define PASS2_MASK          0x20
#define PASS2               0x20
#define NO_PASS2            0x00

#define TLM_MASK            0x10
#define TLM                 0x10
#define NO_TLM              0x00

#define DCONLY_MASK         0x08
#define DCONLY              0x08
#define NO_DCONLY           0x00

#define BRC_MASK            0x04
#define BRC                 0x04
#define NO_BRC              0x00



// Bit masks in the 050's OPTIONS register.

#define NSCN_MASK           0xE0
#define NSCN_1              0x00
#define NSCN_2              0x20
#define NSCN_3              0x40
#define NSCN_4              0x60
#define NSCN_5              0x80
#define NSCN_6              0xA0
#define NSCN_7              0xC0
#define NSCN_8              0xE0

#define OVF_MASK            0x10
#define OVF                 0x10
#define NO_OVF              0x00



// Bit masks in the 050's MARKERS_EN register.

#define APP_MASK            0x80
#define APP_ON              0x80
#define APP_OFF             0x00

#define COM_MASK            0x40
#define COM_ON              0x40
#define COM_OFF             0x00

#define DRI_MASK            0x20
#define DRI_ON              0x20
#define DRI_OFF             0x00

#define DQT_MASK            0x10
#define DQT_ON              0x10
#define DQT_OFF             0x00

#define DHT_MASK            0x08
#define DHT_ON              0x08
#define DHT_OFF             0x00

#define DNL_MASK            0x04
#define DNL_ON              0x04
#define DNL_OFF             0x00

#define DQTI_MASK           0x02
#define DQTI_ON             0x02
#define DQTI_OFF            0x00

#define DHTI_MASK           0x01
#define DHTI_ON             0x01
#define DHTI_OFF            0x00



// Bit masks in 050's STATUS_0 and INT_REQ_0 registers.
//
// Note: Bit mapping in this register is identical to MARKERS_EN register
//       except the last two bits. Therefore the same masks are used.

#define RST_MASK            DRI_MASK   // two functions for this bit
#define SOF_MASK            0x02
#define SOS_MASK            0x02



// Bit masks in 050's STATUS_1 and INT_REQ_1 registers.

#define DATRDY_MASK         0x80
#define MRKDET_MASK         0x40
#define RFM_MASK            0x10
#define RFD_MASK            0x08
#define END_MASK            0x04
#define TCVOVF_MASK         0x02
#define DATOVF_MASK         0x01



// Sizes of marker segments.

#define QTABLE_SIZE         0x40
#define HUFF_AC_SIZE        0xB2   // 178 !!
#define HUFF_DC_SIZE        0x1C   // 28 !!
#define APP_SIZE            0x3C   // 60 - NET length !!
#define COM_SIZE            0x3C   // 60 - NET length !!



// Pixel components indexes.

#define Y_COMPONENT         0
#define U_COMPONENT         1
#define V_COMPONENT         2





// Assignment of Q and H tables to components. Max. NO_OF_COMPONENTS is 8.

static BYTE QTid[8] = { 0, 1, 1, 0, 0, 0, 0, 0 };

static BYTE SCAN1_HDCid[8] = { 0, 1, 1, 0, 0, 0, 0, 0 };
static BYTE SCAN1_HACid[8] = { 0, 1, 1, 0, 0, 0, 0, 0 };





// Sampling ratios for different video formats.

static BYTE HSampRatio422[8] = { 2,1,1,0,0,0,0,0 };
static BYTE VSampRatio422[8] = { 1,1,1,0,0,0,0,0 };

static BYTE HSampRatio411[8] = { 4,1,1,0,0,0,0,0 };
static BYTE VSampRatio411[8] = { 1,1,1,0,0,0,0,0 };

static BYTE HSampRatio411H2V2[8] = { 2,1,1,0,0,0,0,0 };
static BYTE VSampRatio411H2V2[8] = { 2,1,1,0,0,0,0,0 };





// Default DQT tables in zigzag order.

BYTE DefaultQTables[130] = {
	0x00,                                           // Pq,Tq of first table
	0x10, 0x0b, 0x0c, 0x0e, 0x0c, 0x0a, 0x10, 0x0e,
	0x0d, 0x0e, 0x12, 0x11, 0x10, 0x13, 0x18, 0x28,
	0x1a, 0x18, 0x16, 0x16, 0x18, 0x31, 0x23, 0x25,
	0x1d, 0x28, 0x3a, 0x33, 0x3d, 0x3c, 0x39, 0x33,
	0x38, 0x37, 0x40, 0x48, 0x5c, 0x4e, 0x40, 0x44,
	0x57, 0x45, 0x37, 0x38, 0x50, 0x6d, 0x51, 0x57,
	0x5f, 0x62, 0x67, 0x68, 0x67, 0x3e, 0x4d, 0x71,
	0x79, 0x70, 0x64, 0x78, 0x5c, 0x65, 0x67, 0x63,
	0x01,                                           // Pq,Tq of second table
	0x11, 0x12, 0x12, 0x18, 0x15, 0x18, 0x2f, 0x1a,
	0x1a, 0x2f, 0x63, 0x42, 0x38, 0x42, 0x63, 0x63,
	0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
	0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
	0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
	0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
	0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
	0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63
	};



// Default DHT segment.

BYTE DefaultHuffTables[0x1A0] = {
	// JPEG DHT Segment for YCrCb omitted from MJPG data.
	0x00,
	// DC0 length specifications
	0x00,0x01,0x05,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	// DC0 symbol definitions
	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,

	0x01,
	// DC1 length specifications
	0x00,0x03,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,
	// DC1 symbol definitions
	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,

	0x10,
	// AC0 length specifications
	0x00,0x02,0x01,0x03,0x03,0x02,0x04,0x03,0x05,0x05,0x04,0x04,0x00,0x00,0x01,0x7D,
	// AC0 symbol definitions
	0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,
	0x22,0x71,0x14,0x32,0x81,0x91,0xA1,0x08,0x23,0x42,0xB1,0xC1,0x15,0x52,0xD1,0xF0,
	0x24,0x33,0x62,0x72,0x82,0x09,0x0A,0x16,0x17,0x18,0x19,0x1A,0x25,0x26,0x27,0x28,
	0x29,0x2A,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x43,0x44,0x45,0x46,0x47,0x48,0x49,
	0x4A,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,0x63,0x64,0x65,0x66,0x67,0x68,0x69,
	0x6A,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x83,0x84,0x85,0x86,0x87,0x88,0x89,
	0x8A,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,
	0xA8,0xA9,0xAA,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xC2,0xC3,0xC4,0xC5,
	0xC6,0xC7,0xC8,0xC9,0xCA,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xE1,0xE2,
	0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,
	0xF9,0xFA,

	0x11,
	// AC1 length specifications
	0x00,0x02,0x01,0x02,0x04,0x04,0x03,0x04,0x07,0x05,0x04,0x04,0x00,0x01,0x02,0x77,
	// AC1 symbol definitions
	0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,
	0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,0xA1,0xB1,0xC1,0x09,0x23,0x33,0x52,0xF0,
	0x15,0x62,0x72,0xD1,0x0A,0x16,0x24,0x34,0xE1,0x25,0xF1,0x17,0x18,0x19,0x1A,0x26,
	0x27,0x28,0x29,0x2A,0x35,0x36,0x37,0x38,0x39,0x3A,0x43,0x44,0x45,0x46,0x47,0x48,
	0x49,0x4A,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,0x63,0x64,0x65,0x66,0x67,0x68,
	0x69,0x6A,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x82,0x83,0x84,0x85,0x86,0x87,
	0x88,0x89,0x8A,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0xA2,0xA3,0xA4,0xA5,
	0xA6,0xA7,0xA8,0xA9,0xAA,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xC2,0xC3,
	0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,
	0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,
	0xF9,0xFA
	};










//************************************************************************
// Physical unit.
//************************************************************************



VirtualUnit *JCoder050::CreateVirtual (void)
	{
	return NULL;   // NOT USED YET
	}





// Check if the 050 coder has ASSERTED the END signal.

BOOL JCoder050::Check050End (void)
	{
	BYTE status;

	port->InByte (STATUS_1, status);
	return (status & END_MASK) != 0;
	}





// Prepare the soft GO.

void JCoder050::PrepareGO (void)
	{
	BYTE tmp;

	// Preset 050 addressing so that logic holds GO register address.
	port->InByte (GO, tmp);
	}





// Create the SOF marker segment for a given compression/expansion configuration
// and return its size.

DWORD JCoder050::MakeSOFMarker (void)
	{
	WORD org = SOF_INDX;
	DWORD mlen = 8 + NO_OF_COMPONENTS * 3 + 2;
	int j;
	VirtualJCoder050 *jpeg = GetCurrent ();
	WORD height;


	port->OutByte (org, 0xff);
	port->OutByte (org+1, SOF0_MARKER);

	port->OutByte (org+2, HIBYTE(mlen-2));
	port->OutByte (org+3, LOBYTE(mlen-2));

	port->OutByte (org+4, BASELINE_PRECISION);   // P [8]

	if (jpeg->fieldOrder != VFLD_SINGLE)
		height = jpeg->height / 2;
	else
		height = jpeg->height;
	port->OutByte (org+5, HIBYTE(height));
	port->OutByte (org+6, LOBYTE(height));

	port->OutByte (org+7, HIBYTE(jpeg->width));
	port->OutByte (org+8, LOBYTE(jpeg->width));

	port->OutByte (org+9, NO_OF_COMPONENTS);   // YUV - 3 components

	for (j = 0;  j < NO_OF_COMPONENTS;  j++)
		{
		port->OutByte (org+10+j*3, j);   // C1 - id 0
		port->OutByte (org+11+j*3, HSampRatio[j] * 16 + VSampRatio[j]);   // H and V
		port->OutByte (org+12+j*3, QTid[j]);   // Qtbl
		}

	return mlen;
	}





// Create the SOS1 marker segment for a given compression/expansion configuration
// and return its size.

DWORD JCoder050::MakeSOS1Marker (void)
	{
	WORD org = SOS1_INDX;
	WORD len = 3 + NO_OF_SCAN1_COMPONENTS * 2 + 3;
	DWORD mlen = len + 2;
	int j;


	port->OutByte (org, 0xff);
	port->OutByte (org+1, SOS_MARKER);

	port->OutByte (org+2, HIBYTE(len));
	port->OutByte (org+3, LOBYTE(len));

	port->OutByte (org+4, NO_OF_SCAN1_COMPONENTS);   // YUV - 3 components

	for (j = 0;  j < NO_OF_SCAN1_COMPONENTS;  j++)
		{
		port->OutByte (org+5+j*2, j);   // C1 - id 0
		port->OutByte (org+6+j*2, SCAN1_HDCid[j] * 16 + SCAN1_HACid[j]);   // AC, DC tables
		}

	port->OutByte (org + len - 1, 0x00);
	port->OutByte (org + len    , 0x3f);
	port->OutByte (org + len + 1, 0x00);

	return mlen;
	}





// Create the DRI marker segment for a given compression/expansion configuration
// and return its size.

DWORD JCoder050::MakeDRIMarker (void)
	{
	WORD org = DRI_INDX;
	VirtualJCoder050 *jpeg = GetCurrent ();


	port->OutByte (org, 0xff);
	port->OutByte (org+1, DRI_MARKER);

	port->OutByte (org+2, 0);
	port->OutByte (org+3, 4);   // fixed length

	port->OutByte (org+4, HIBYTE(jpeg->dri));
	port->OutByte (org+5, LOBYTE(jpeg->dri));

	return 6;   // fixed len
	}





// Create the quantization tables and return their total size.
// Q tables are given as a pointer to an array of 130 chars, which contains
// two contiguous Q tables including the Pq, Tq byte before each table. The
// organization of the Q tables array is expected to be as follows:
//    [0]      - Pq,Tq       Precision and identifier of first table
//    [1:64]   - Qk          64 elements of first table
//    [65]     - Pq,Tq       Precision and identifier of second table
//    [66:129] - Qk          64 elements of second table

DWORD JCoder050::MakeQTable (void)
	{
	WORD org = DQT_INDX;
	WORD len = (QTABLE_SIZE + 1) * 2 + 2;
	DWORD mlen = len + 2;
	int j;
	VirtualJCoder050 *jpeg = GetCurrent ();
	BYTE __far *qTable = jpeg->qTable;


	if (qTable == NULL)
		qTable = DefaultQTables;

	port->OutByte (org, 0xff);
	port->OutByte (org+1, DQT_MARKER);

	port->OutByte (org+2, HIBYTE(len));
	port->OutByte (org+3, LOBYTE(len));

	for (j = 0;  j < (QTABLE_SIZE + 1) * 2;  j++)
		{
		port->OutByte (org+4+j, (BYTE)qTable[j]);
		}

	return mlen;
	};





// Create the huffman tables and return their total size.
// Huff tables are given as a pointer to an array of 420 chars, which is
// expected to contain two AC and two DC tables including the ID byte for each
// table. The organization of each table is expected to be as follows:
//    DC table:
//    [0]      - 0,Th        DC indicator (0) and identifier of
//                           the DC table
//    [1:28]   - DCk         28 elements of DC table
//    AC table:
//    [0]      - 1,Th        AC indicator (1) and identifier of
//                           the AC table
//    [1:178]  - ACk         178 elements of AC table
// The tables can come in any order, DC,DC,AC,AC or AC,DC,AC,DC or whatever.

DWORD JCoder050::MakeHuffTable (void)
	{
	WORD org = DHT_INDX;
	WORD len = (HUFF_AC_SIZE+1 + HUFF_DC_SIZE+1) * 2 + 2;
	DWORD mlen = len + 2;
	int j;
	VirtualJCoder050 *jpeg = GetCurrent ();
	BYTE __far *huffTable = jpeg->huffTable;


	if (huffTable == NULL)
		huffTable = DefaultHuffTables;

	port->OutByte (org, 0xff);
	port->OutByte (org+1, DHT_MARKER);

	port->OutByte (org+2, HIBYTE(len));
	port->OutByte (org+3, LOBYTE(len));

	for (j = 0;  j < (HUFF_AC_SIZE+1 + HUFF_DC_SIZE+1) * 2;  j++)
		{
		port->OutByte (org+4+j, (BYTE)huffTable[j]);
		}

	return mlen;
	};





// Create the APP segment and return its size. The APP string is given as a
// pointer to an array of 64 chars. Only 64 chars are supported now.

DWORD JCoder050::MakeAPPString (void)
	{
	WORD org = APP_INDX;
	int j;
	VirtualJCoder050 *jpeg = GetCurrent ();
	BYTE __far *appString = jpeg->appMarker;


	if (appString == NULL)
		return 0;

	port->OutByte (org, 0xff);
	port->OutByte (org+1, APP_MARKER);

	port->OutByte (org+2, HIBYTE(APP_SIZE+2));
	port->OutByte (org+3, LOBYTE(APP_SIZE+2));

	for (j = 0;  j < APP_SIZE;  j++)
		{
		port->OutByte (org+4+j, (BYTE)appString[j]);
		}

	return APP_SIZE + 4;
	};





// Create the COM segment and return its size. The COM string is given as a
// pointer to an array of 64 chars. Only 64 chars are supported now.

DWORD JCoder050::MakeCOMString (void)
	{
	WORD org = COM_INDX;
	int j;
	VirtualJCoder050 *jpeg = GetCurrent ();
	BYTE __far *comString = jpeg->comString;


	if (comString == NULL)
		return 0;

	port->OutByte (org, 0xff);
	port->OutByte (org+1, COM_MARKER);

	port->OutByte (org+2, HIBYTE(COM_SIZE + 2));
	port->OutByte (org+3, LOBYTE(COM_SIZE + 2));

	for (j = 0;  j < COM_SIZE;  j++)
		{
		port->OutByte (org+4+j, (BYTE)comString[j]);
		}

	return COM_SIZE + 4;
	};





// Create the marker segments for a given configuration of
// compression/expansion.

void JCoder050::MakeMarkerSegments (void)
	{
	SOFMarkerSize  = MakeSOFMarker ();
	SOSMarkerSize  = MakeSOS1Marker ();
	DRIMarkerSize  = MakeDRIMarker ();
	DQTMarkerSize  = MakeQTable ();
	DHTMarkerSize  = MakeHuffTable ();
	APPMarkerSize  = MakeAPPString ();
	COMMarkerSize  = MakeCOMString ();
	DHTIMarkerSize = 0;
	DQTIMarkerSize = 0;
	DNLMarkerSize  = 0;
	};





// Start the coder operation.

void JCoder050::Start (void)
	{
	port->OutByte (GO, 0);
	};





// Configure the coder's internal registers and marker segments to baseline
// JPEG compression, either two pass mode or not. Return success.

BOOL JCoder050::ConfigureCompression (void)
	{
	BYTE tmp;
	WORD wtmp;
	DWORD dtmp;
	DWORD totalMarkers;
	DWORD timeout;
	int i;
	BYTE *hs, *vs;
	VirtualJCoder050 *jpeg = GetCurrent ();


	switch (jpeg->format)
		{
		case VFMT_YUV_411:
			hs = HSampRatio411;
			vs = VSampRatio411;
			break;
		case VFMT_YUV_420:
			hs = HSampRatio411H2V2;
			vs = VSampRatio411H2V2;
			break;
		default:
		case VFMT_YUV_422:
			hs = HSampRatio422;
			vs = VSampRatio422;
			break;
		}
	for (i = 0;  i < 8;  i++)
		{
		HSampRatio[i] = *hs++;
		VSampRatio[i] = *vs++;
		}

	tmp = MSTR | NO_DMA | CFIS_1_CLK | NO_BELE;
	port->OutByte (HARDWARE, tmp);

	tmp = COMP | NO_ATP | NO_PASS2 | TLM | NO_DCONLY | NO_BRC;
	port->OutByte (MODE, tmp);

	tmp = NSCN_1 | NO_OVF;
	port->OutByte (OPTIONS, tmp);

	tmp = (BYTE) (jpeg->maxBlockCodeVolume / 2);
	port->OutByte (MBCV_050, tmp);

	tmp = 0;
	port->OutByte (INT_REQ_0, tmp);   // no interrupts on markers

	tmp = 3;                          // two LSBs must be one
	port->OutByte (INT_REQ_1, tmp);   // no interrupt enabled

	wtmp = jpeg->scaleFactor;
	port->OutByte (SF_HI, HIBYTE(wtmp));
	port->OutByte (SF_LO, LOBYTE(wtmp));

	port->OutByte (AF_HI, 0xff);
	port->OutByte (AF_M,  0xff);
	port->OutByte (AF_LO, 0xff);

	MakeMarkerSegments ();   // sets the MarkerSize variables

	tmp = APP_OFF | COM_OFF | DRI_OFF  | DQT_OFF | DHT_OFF | DNL_OFF | DQTI_OFF | DHTI_ON;
	port->OutByte (MARKERS_EN, tmp);

	Start ();   // start the coder for Huffman table preload

	// Wait for end of table preload.
	timeout = Timer.GetMilliTicks () + TABLE_PRELOAD_TIMEOUT;
	while (! Check050End ())
		{
		if (timeout < Timer.GetMilliTicks ())
			return FALSE;   // timeout
		}

	// Now the 050 is in idle mode like after a reset and waits for GO.

	if (jpeg->twoPassMode)
		tmp = COMP | ATP | NO_PASS2 | NO_TLM | NO_DCONLY | BRC;
	else
		tmp = COMP | NO_ATP | PASS2 | NO_TLM | NO_DCONLY | BRC;
	port->OutByte (MODE, tmp);

	if (jpeg->stillMode)
		tmp = APP_ON | COM_OFF | DRI_OFF | DQT_ON | DHT_ON | DNL_OFF | DQTI_OFF | DHTI_OFF;
	else
		tmp = APP_ON | COM_OFF | DRI_OFF | DQT_ON | DHT_OFF | DNL_OFF | DQTI_OFF | DHTI_OFF;
	port->OutByte (MARKERS_EN, tmp);

	totalMarkers = SOFMarkerSize + SOSMarkerSize + 4;   // SOF, SOS, SOI, EOI always exist
	if (tmp & APP_MASK) totalMarkers += APPMarkerSize;
	if (tmp & COM_MASK) totalMarkers += COMMarkerSize;
	if (tmp & DRI_MASK) totalMarkers += DRIMarkerSize;
	if (tmp & DQT_MASK) totalMarkers += DQTMarkerSize;
	if (tmp & DHT_MASK) totalMarkers += DHTMarkerSize;
	if (tmp & DNL_MASK) totalMarkers += DNLMarkerSize;
	if (tmp & DQTI_MASK) totalMarkers += DQTIMarkerSize;
	if (tmp & DHTI_MASK) totalMarkers += DHTIMarkerSize;

	dtmp = 8 * (jpeg->totalCodeVolume - totalMarkers);   // bit size !
	port->OutByte (TCV_NET_HI, LBYTE3(dtmp));
	port->OutByte (TCV_NET_MH, LBYTE2(dtmp));
	port->OutByte (TCV_NET_ML, LBYTE1(dtmp));
	port->OutByte (TCV_NET_LO, LBYTE0(dtmp));

	dtmp -= (dtmp / 128);        // minus STUFFING
	dtmp -= ((dtmp * 5) / 64);   // minus EOB
	port->OutByte (TCV_DATA_HI, LBYTE3(dtmp));
	port->OutByte (TCV_DATA_MH, LBYTE2(dtmp));
	port->OutByte (TCV_DATA_ML, LBYTE1(dtmp));
	port->OutByte (TCV_DATA_LO, LBYTE0(dtmp));

	// Preset 050 addressing so that logic holds GO register address.
	port->InByte (GO, tmp);

	return TRUE;
	};





// Configure the coder's internal registers and marker segments to BASELINE
// JPEG expansion. Return success.

BOOL JCoder050::ConfigureExpansion (void)
	{
	BYTE tmp;
	DWORD timeout;
	VirtualJCoder050 *jpeg = GetCurrent ();


	tmp = (cfisExpansion << 2) & CFIS_MASK;
	tmp |= NO_BSWD | MSTR | NO_DMA | NO_BELE;
	port->OutByte (HARDWARE, tmp);

	tmp = NO_COMP | TLM;
	port->OutByte (MODE, tmp);   // table preload mode

	tmp = 0;
	port->OutByte (INT_REQ_0, tmp);   // no interrupts on markers

	tmp = 3;                          // two LSBs must be one
	port->OutByte (INT_REQ_1, tmp);   // no interrupt enabled

	MakeHuffTable ();   // only DHT relevant !!

	tmp = DHTI_ON;
	port->OutByte (MARKERS_EN, tmp);

	Start ();   // start the coder for Huffman table preload

	// Wait for end of table preload.
	timeout = Timer.GetMilliTicks () + TABLE_PRELOAD_TIMEOUT;
	while (! Check050End ())
		{
		if (timeout < Timer.GetMilliTicks ())
			return FALSE;   // timeout
		}

	// Now the 050 is in idle mode like after a reset and waits for GO.

	if (jpeg->thumbnail)
		tmp = NO_COMP | DCONLY;
	else
		tmp = NO_COMP | NO_DCONLY;
	port->OutByte (MODE, tmp);   // expansion

	tmp = APP_OFF | COM_OFF;   // don't accept APP, COM
	port->OutByte (MARKERS_EN, tmp);   // into markers segment

	// Preset 050 addressing so that logic holds GO register address.
	port->InByte (GO, tmp);

	return TRUE;
	};





// Return the scale factor used to compress the last frame.

WORD JCoder050::GetLastScaleFactor (void)
	{
	BYTE lo, hi;
	WORD result;

	port->InByte (SF_LO, lo);
	port->InByte (SF_HI, hi);
	result = ((WORD)hi << 8) + (WORD)lo;
	GetCurrent()->scaleFactor = result;
	return result;
	}










//************************************************************************
// Virtual unit.
//************************************************************************



VirtualJCoder050::VirtualJCoder050 (JCoder050 *physical)
	: VirtualJCoderRated (physical)
	{
	jcoder = physical;

	// Set defaults.
	format     = VFMT_YUV_422;
	fieldOrder = VFLD_SINGLE;
	thumbnail  = FALSE;
	qTable     = NULL;
	huffTable  = NULL;
	comString  = NULL;

	SetDefaultAPP ();
	}





VirtualJCoder050::~VirtualJCoder050 (void)
	{
	}





// Default APP is any non-empty string of 64 bytes length including zero byte.

void VirtualJCoder050::SetDefaultAPP (void)
	{
	int i;

	for (i = 0;  i < APP_LENGTH;  i++)
		appMarker[i] = ' ';
	appMarker[APP_LENGTH-1] = '\0';
	}





Error VirtualJCoder050::Configure (TAG __far *tags)
	{
	int len;
	BYTE __far *src;
	BYTE __far *dst;


	GNREASSERT( VirtualJCoderRated::Configure (tags) );

	PARSE_TAGS_START(tags)
		GETSET (JPG_VIDEO_FORMAT, format);
		GETSET (JPG_THUMBNAIL,    thumbnail);
		GETSET (JPG_QTABLE,       qTable);
		GETSET (JPG_HUFFTABLE,    huffTable);

		GETONLY (JPG_VIDEO_FMT_LIST, VideoFormatBitField);

/*		case CSET_JPG_DEF_APPSTRING:
			src = VAL_JPG_DEF_APPSTRING(tp);
			
			len = 0;
			dst = src;
			while (*dst++) len++;
			
			if (len >= APP_LENGTH)
				GNRAISE(GNR_RANGE_VIOLATION);
			
			SetDefaultAPP ();
			dst = appMarker;
			for (;  len > 0;  len--)
				*dst++ = *src++;
			break;
		case CGET_JPG_DEF_APPSTRING:
			REF_JPG_DEF_APPSTRING(tp) = appMarker;
			break;
		case CQRY_JPG_DEF_APPSTRING:
			QRY_TAG(tp) = TRUE;
			break;
*/
	PARSE_TAGS_END

	GNRAISE_OK;
	}





Error VirtualJCoder050::InitOperation (void)
	{
	BYTE __far *src;
	BYTE __far *dst;
	int i;


	if (compress)
		{
		// Compression.
		twoPassMode = FALSE;
		SetDefaultAPP ();
#if 1
		// Automatically select the field order.
		switch (fieldOrder)
			{
			default:
			case VFLD_SINGLE:	src = JCoder::DefaultAPPStringSingle;	break;
			case VFLD_ODD:		src = JCoder::DefaultAPPStringOdd;		break;
			case VFLD_EVEN:	src = JCoder::DefaultAPPStringEven;	break;
			}
		dst = appMarker;
		while ((*dst++ = *src++) != 0) ;
#endif

		// Estimate a starting value for the scale factor. The formula is
		// sf = (256.0 * ( 1.770625 + x * ( - 0.09240625 + x * (0.001625 - 0.0000090725 * x) ) ) );
//		float x = (float)totalCodeVolume / 1000.0;
//		usedScaleFactor = (long)(453.28 + x * ( -23.656 + x * ( 0.416 - 0.00232256 * x )));
		if (! stillMode)
			{
			long x = (long)totalCodeVolume / 1000L;
			if (x < 10)
				scaleFactor = 1 * 256;
			else if (x > 90)
				scaleFactor = 2;   // 0.01 * 256
			else
				scaleFactor = (WORD)( 453L + ScaleLong (x, 100000L, (-2365600L + x * (41600L - 232L * x))) );
			}

		i = 0;
		while (! jcoder->ConfigureCompression ())
			{
			if (i++ >= 2)
				GNRAISE(GNR_RANGE_VIOLATION);
			}
		}
	else
		{
		// Expansion.
		i = 0;
		while (! jcoder->ConfigureExpansion ())
			{
			if (i++ >= 2)
				GNRAISE(GNR_RANGE_VIOLATION);
			}
		}
	GNRAISE_OK;
	}





void VirtualJCoder050::Stop (void)
	{
	// Actually, you cannot stop the 050 via register. We rely on the JPEG
	// manager class to stop us by resetting via a hardware reset line.
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\jpeg\specific\Z016.CPP ===
// FILE:      library\hardware\jpeg\generic\z016.cpp
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   05.04.95
//
// PURPOSE: The class for the Zoran ZR36016 Motion JPEG controller.
//
// HISTORY:

#include "z016.h"
#include "library\support\gfxdebug\gfxdebug.h"





// Constructor for Z016_CONFIG.

Z016_CONFIG::Z016_CONFIG (void)
	{
	compress    = FALSE;
	stillMode   = FALSE;
	thumbnail   = FALSE;
	colFiltersOn = FALSE;
	horFilterOn = FALSE;
	hDecimation = TRUE;
	vDecimation = TRUE;
	doubleClock = FALSE;
	ccirLevels  = FALSE;
	syen        = 0;
	vbusFormat  = VFMT_YUV_422;
	coderFormat = VFMT_YUV_422;
	pxoutFormat = VFMT_YUV_422;
	top    = 0;
	left   = 0;
	width  = 320;
	height = 240;
	}





	// Construct Mode register. We don't support all in/out combinations.
	// If there is an illegal combination, we do YUV 4:2:2 for in and out.

	static BYTE makeModeRegister (LP_Z016_CONFIG cfg)
		{
		BYTE mode;

		switch (cfg->coderFormat)
			{
			case VFMT_YUV_444:  mode = 0x00;  break;
			default:
			case VFMT_YUV_422:  mode = 0x01;  break;
			case VFMT_YUV_420:  mode = 0x02;  break;
			case VFMT_RGB_444:  mode = 0x04;  break;
			}
		switch (cfg->vbusFormat)
			{
			case VFMT_RGB_444:
				mode |= 0x00;
				break;
			case VFMT_YUV_444:
				mode |= 0x08;
				break;
			case VFMT_YUV_422:
				if (cfg->coderFormat == VFMT_YUV_422  ||  
				    cfg->coderFormat == VFMT_YUV_420)
					mode |= 0x10;
				else
					mode = 0x11;   // default is YUV 4:2:2
				break;
			default:
				mode = 0x11;   // default is YUV 4:2:2
				break;
			}
		switch (cfg->pxoutFormat)
			{
			case VFMT_RGB_444:  mode |= 0x00;  break;
			case VFMT_YUV_444:  mode |= 0x20;  break;
			default:
			case VFMT_YUV_422:  mode |= 0x40;  break;
			}
		if (cfg->compress)
			mode |= 0x80;   // do compression
		return mode;
		}



	// Construct Setup 1 register.

	static BYTE makeSetup1Register (LP_Z016_CONFIG cfg)
		{
		BYTE s;

		s = cfg->stillMode ? 0x00 : 0x01;
		if (cfg->thumbnail)  s |= 0x02;
		if (cfg->colFiltersOn)  s |= 0x0C;

		if (cfg->hDecimation)
			{
			s |= 0x20;
			if (cfg->horFilterOn)  s |= 0x10;
			if (cfg->doubleClock)  s |= 0x80;
			}
		if (cfg->vDecimation)  s |= 0x40;
		return s;
		}



	// Construct Setup 2 register.

	static BYTE makeSetup2Register (LP_Z016_CONFIG cfg)
		{
		BYTE s;

		// YMCS always zero.
		// We are connected to a Z050, so always unsigned data.
		s = cfg->ccirLevels ? 0x04 : 0x00;
		if (cfg->syen)  s |= 0x40;
		return s;
		}





// Write a configuration into the chip. Return success.

BOOL Z016Class::Configure (LP_Z016_CONFIG cfg)
	{
	Stop ();

	port->OutByte (1, makeModeRegister (cfg));

	// Write all indirect registers in one sequence.
	port->OutByte (2, 0x00);
	port->OutByte (3, makeSetup1Register (cfg));
	port->OutByte (3, makeSetup2Register (cfg));
	// NAX
	port->OutByte (3, LOBYTE(cfg->left));
	port->OutByte (3, HIBYTE(cfg->left) & 0x1F);
	// PAX
	port->OutByte (3, LOBYTE(cfg->width));
	port->OutByte (3, HIBYTE(cfg->width));
	// NAY
	port->OutByte (3, LOBYTE(cfg->top));
	port->OutByte (3, HIBYTE(cfg->top) & 0x1F);
	// PAY
	port->OutByte (3, LOBYTE(cfg->height));
	port->OutByte (3, HIBYTE(cfg->height));

	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\jpeg\specific\Jcor22.h ===
// FILE:      library\hardware\jpeg\generic\jcor22.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1996 Viona Development.  All Rights Reserved.
// CREATED:   15.01.96
//
// PURPOSE: The virtualized JPEG core implemented as combination of 022/016 chips.
//
// HISTORY:

#ifndef JPEGCORE22_H
#define JPEGCORE22_H

#include "library\hardware\jpeg\generic\jcore.h"
#include "library\lowlevel\hardwrio.h"
#include "library\lowlevel\memmpdio.h"
#include "library\lowlevel\dmabuffr.h"
#include "library\lowlevel\intrctrl.h"
#include "library\hardware\videodma\specific\i22pip.h"
#include "library\common\krnlsync.h"
#include "library\common\krnllog.h"



#ifndef ONLY_EXTERNAL_VISIBLE



class VirtualJPEGUnit022;
class JPEGCodeIntHandler;
class Z016Class;



class JPEGManager022 : public JPEGManager
	{
	friend class VirtualJPEGUnit022;

	public:
		JPEGManager022 (MemoryMappedIO *io,
		                InterruptServer *jpegCodeIntServer,
		                Profile *profile,
		                Z016Class *z016,
		                BitOutputPort *pxoe016Bit,    // bit to disable 016 PXOUT bus
		                BitOutputPort *resetJPEGBit,  // bit to reset 050 and 016
		                BitOutputPort *clken050Bit,   // bit to enable 050 clock
#if VIONA_VERSION
		                ByteOutputPort *syncSelection,    // 2 bit selection
		                BitOutputPort *decoderSyncEnable, // bit to enable video decoder sync in JPEG core
		                BitOutputPort *frontEndEnable,    // bit to enable video bus front end in JPEG core
		                BitOutputPort *videoBusDecode,    // bit to set encode/ecode state
		                VirtualUnit *blankUnit,
		                BOOL fixPlaybackLongBursts,
		                KernelLogger *log = NULL,
		                BOOL ccirMode = FALSE,
		                AllowedJPEGVStandard allowedStandard = AVSTD_NTSC_PAL_BOTH);
#else
		                BitOutputPort *syncMUX,
		                BOOL fixPlaybackLongBursts);      // bit to switch sync MUX
#endif
		virtual ~JPEGManager022 (void);

		virtual VirtualUnit *CreateVirtual (void);

		virtual void Start (void);
		virtual void Stop  (void);
		virtual void Reset (void);

		void JPEGCodeInterrupt (void);

	protected:
		VirtualJPEGUnit022 *GetCurrent (void) {return (VirtualJPEGUnit022 *)(JPEGManager::GetCurrent());}

		Error InitOperation (DWORD statCom);
		Error StartIRQs (void);
		Error StopIRQs  (void);

		Error WriteStillPixels24 (FPTR src, WORD width, WORD height, VideoField fieldOrder);
#if VIONA_VERSION
		Error WriteStillPixels32 (FPTR src, WORD width, WORD height, VideoField fieldOrder);
		Error ReadStillPixels24 (FPTR dst, WORD width, WORD height, DWORD stride, VideoField fieldOrder);
#endif

		MemoryMappedIO *io;
		InterruptServer *jpegCodeIntServer;
		JPEGCodeIntHandler *jpegCodeIntHandler;
		Profile *profile;
		Z016Class *z016;
		BitOutputPort *pxoe016Bit;
		BitOutputPort *resetJPEGBit;
		BitOutputPort *clken050Bit;
#if VIONA_VERSION
		ByteOutputPort *syncSelection;
		BitOutputPort *decoderSyncEnable;
		BitOutputPort *frontEndEnable;
		BitOutputPort *videoBusDecode;
		VirtualUnit *blankUnit;
		KernelLogger *log;
		BOOL ccirMode;
		AllowedJPEGVStandard allowedStandard;
#else
		BitOutputPort *syncMUX;
#endif

		BOOL fixPlaybackLongBursts;

		// code thresholds for various operation modes
		WORD playbackCodeThreshold, captureCodeThreshold;
		WORD expandCodeThreshold, compressCodeThreshold;

		BOOL handlerEnabled;
		BOOL jpegCoreRunning;
	};



class VirtualJPEGUnit022 : public VirtualJPEGUnit
	{
	friend class JPEGManager022;

	public:
		VirtualJPEGUnit022 (JPEGManager022 *physical, VirtualJCoder *coder, VirtualI22PIP *pip);
		virtual ~VirtualJPEGUnit022 (void);

		virtual Error Configure (TAG __far *tags);

		virtual Error PrepareBuffer (FPTR buffer, DWORD size, FPTR __far &info);
		virtual Error UnprepareBuffer (FPTR info);

#if VIONA_VERSION
		virtual Error ExpandToRGB (FPTR src, DWORD size, FPTR dst, WORD dstWidth, WORD dstHeight, GrabFormat bitFormat);
		virtual BOOL IsValidExpansionScaling (WORD srcWidth, WORD srcHeight, WORD dstWidth, WORD dstHeight, GrabFormat bitFormat);
		virtual Error CompressFromRGB (FPTR src, FPTR dst, DWORD maxSize, DWORD __far &size, BOOL bits32);
		virtual BOOL IsValidCompression (WORD width, WORD height, BOOL bits32);
#else
		virtual Error ExpandToRGB (FPTR src, DWORD size, FPTR dst);
		virtual Error CompressFromRGB (FPTR src, FPTR dst, DWORD maxSize, DWORD __far &size);
#endif

		// These are allowed only after locking and activating the unit.
		virtual Error InitCapture (JPEGCaptureHook __far *hook);
		virtual Error FinishCapture (void);
		virtual Error AddVideoBuffer (FPTR info, FPTR userData, DWORD size);
		virtual Error Start (void);
		virtual Error Stop  (void);

		virtual Error AllocateVideoBuffer (DWORD size, FPTR __far &info, FPTR __far &data);
		virtual Error FreeVideoBuffer (FPTR info);
		virtual Error InitPlayback (JPEGPlaybackHook __far *hook);
		virtual Error FinishPlayback (void);
		virtual Error FlushPlayback (DWORD bufferSize);
		virtual Error PlayBuffer (FPTR info, DWORD size);

	protected:
		virtual Error Preempt (VirtualUnit *previous);

		void JPEGCodeInterrupt (void);

		void CalcVideoParameters (void);

		virtual Error InternalAddVideoBuffer (FPTR info, FPTR userData, DWORD size);

		JPEGManager022 *manager;
		VirtualI22PIP *pip;

		ContinuousDMABuffer statComTable;   // DMA table
		DWORD statComPhysical;
		DWORD volatile __far *statCom;

		FPTR dummyCaptureData;
		FPTR dummyCaptureInfo;
		DWORD dummyCapSize;

		FPTR playBackupData;
		FPTR playBackupInfo;
		DWORD playBackupSize;

		IRQMutex	irqMutex;
		JPEGCaptureHookHandle capHook;
		JPEGPlaybackHookHandle playHook;
		JPEGMessageHookHandle preemptHook;
		volatile int nextBuffer;   // already processed by the I22
		int lastBuffer;   // entry for providing new buffer
		int nBuffers;
		DWORD frameNum;
		WORD lastFieldCnt;
		JPEGCaptureMsg buffers[8];
		volatile int stoppingCapture;
		BOOL running;
		BOOL playAddAllowed;
		// Valid only if pipeline deeper than STATCOM table.
		int nStatBuffers;
		volatile int statNextBuffer;
		int statLastBuffer;

		DWORD nextFrameTime;
		DWORD milliSecPerFrame;

		VideoStandard vStandard;
		VideoFormat vFormat;
		VideoField fieldOrder;
		BOOL thumbnail;
		BOOL filtersOn;

		DWORD totalCodeVolume;

		BOOL stillExpansion;
		BOOL singleFrame;

		// Video parameters.
		BOOL syncMaster;
		WORD opWidth, opHeight;
		WORD vSyncSize, frameTotal, hSyncStart, lineTotal, nax, pax, nay, pay;   // of I22
		int hOffset, vOffset;
		BOOL horDecimation;
		DWORD jpgMode;
	};



#endif // ONLY_EXTERNAL_VISIBLE



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\jpeg\specific\Jcoram55.cpp ===
// FILE:      library\hardware\jpeg\generic\jcoram55.cpp
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1996 Viona Development.  All Rights Reserved.
// CREATED:   02.02.96
//
// PURPOSE: The virtualized JPEG core implemented as combination of S5933/055/050 chips.
//
// HISTORY:

#include "jcoram55.h"
#include "library\hardware\jpeg\generic\jcodrate.h"

#include "library\common\prelude.h"
#include "library\lowlevel\memmpdio.h"
#include "library\lowlevel\dmachanl.h"
#include "library\lowlevel\timer.h"
#include "library\general\parse.h"
#include "library\lowlevel\kernlmem.h"
#include "library\hardware\jpeg\generic\yuv2rgb.h"
#include "library\hardware\jpeg\generic\rgb2yuv.h"
#include "library\hardware\jpeg\specific\z055.h"
#include "library\common\vddebug.h"

#if NT_KERNEL
#include "msgfile.h"
#endif

#define NO_MORE_GLOBAL_ALLOC_IN_LOW_LEVEL_DRIVERS	1

#if NO_MORE_GLOBAL_ALLOC_IN_LOW_LEVEL_DRIVERS
#define KMEM(x)	(((KernelMemory *)(x))->KernelSpace())
#else
#define KMEM(x)	x
#endif

// #include <mmsystem.h>

#include "library\support\gfxdebug\gfxdebug.h"





#define MAX_BLOCKS_IN_STRIP  128

#define MAX_COMPRESS_TRIES   5

#define MAX_FIELDSIZE  60000   // as we have an 055

#define DO_TIMING  1





// These arrays define the video window processing parameters for the 055 as
// the sync master. They are indexed by the video standard (NTSC, PAL, SECAM
// in that order).

static int VLineStart [VIDEOSTANDARD_MAX+1] = { 10, 22, 22 };
static int HPixelStart[VIDEOSTANDARD_MAX+1] = { 122, 132, 132 };

static int VSyncSize [VIDEOSTANDARD_MAX+1] = { 6, 6, 6 };
static int HSyncStart[VIDEOSTANDARD_MAX+1] = { 640, 768, 768 };





// This is the bit field that represents the video formats we support.

static DWORD VideoFormatBitField = (1 << VFMT_YUV_411) | (1 << VFMT_YUV_422);





static DWORD FirstLen, FirstNum;










//************************************************************************
// The interrupt handler for JPEG end interrupt.

class JPEGEndIntHandler : public InterruptHandler
	{
	private:
		JPEGManager055 *jpegManager;

		void Interrupt (void) {jpegManager->JPEGEndInterrupt();}

	public:
		JPEGEndIntHandler (JPEGManager055 *jpegManager)
			{this->jpegManager = jpegManager;}
	};










//************************************************************************
// DMA request for our transfer purposes.

class JPEGTransferRequest : public ContinuousDMARequest
	{
	protected:
		VirtualJPEGUnit055 *unit;

	public:
		JPEGTransferRequest (ContinuousDMABuffer *buffer);
		virtual ~JPEGTransferRequest (void);

		void SetUnit (VirtualJPEGUnit055 *unit) {this->unit = unit;}

		virtual void RequestCompleted (void);
	};



JPEGTransferRequest::JPEGTransferRequest (ContinuousDMABuffer *buffer)
	: ContinuousDMARequest (buffer)
	{
	start = 0;
	unit = NULL;
	}



JPEGTransferRequest::~JPEGTransferRequest (void)
	{
	// We got the buffer passed down, so it should not be destroyed by us.
	buffer = NULL;
	}



void JPEGTransferRequest::RequestCompleted (void)
	{
	unit->DMATransferDone ();
	}










//************************************************************************
// The JPEG core manager, i.e. the PhysicalUnit.
//************************************************************************


JPEGManager055::JPEGManager055 (Z055 *z055, VirtualUnit *blankUnit, InterruptServer *jpegIRQ,
                                DataInOutPort *codePort, DataInOutPort *stripPort,
                                DMAChannel *readChannel, DMAChannel *writeChannel,
										  KernelLogger *log)
	{
	this->z055 = z055;
	this->blankUnit = blankUnit;
	this->jpegIRQ     = jpegIRQ;
	this->codePort  = codePort;
	this->stripPort = stripPort;
	this->readChannel  = readChannel;
	this->writeChannel = writeChannel;
	this->log = log;

	jpegEndIntHandler = new JPEGEndIntHandler (this);
	handlerEnabled = FALSE;
	dmaBuffer = NULL;
	dmaRequest = NULL;

#if PCI_VERSION
	if (readChannel)  readChannel->StartRequest ();
	if (writeChannel) writeChannel->StartRequest ();
#endif
	}





JPEGManager055::~JPEGManager055 (void)
	{
	delete jpegEndIntHandler;
	jpegEndIntHandler = NULL;
	delete dmaBuffer;
	delete dmaRequest;
	}





VirtualUnit *JPEGManager055::CreateVirtual (void)
	{
	return NULL;   // NOT USED YET
	}





// JPEG end interrupt.

void JPEGManager055::JPEGEndInterrupt (void)
	{
	GetCurrent()->JPEGEndInterrupt();
	}





// Start or stop the JPEG core operation.

void JPEGManager055::Start (void)
	{
	GetCurrent()->irqSecondField = TRUE;
	z055->StartActivity ();
	// Don't start the 050. The 050 will be started by the 055.
	}


void JPEGManager055::Stop (void)
	{
	z055->StopActivity ();
	}





void JPEGManager055::Reset (void)
	{
	z055->Reset ();
	}





Error JPEGManager055::InitOperation (void)
	{
	VirtualJPEGUnit055 *jpeg = GetCurrent ();
	int i;


#if PCI_VERSION
	// Allocate DMA buffer if needed.
	if ((readChannel || writeChannel)  &&  dmaBuffer == NULL)
		{
		dmaBuffer = new ContinuousDMABuffer;
		if (!IS_ERROR(dmaBuffer->AllocateBuffer (128*1024L) ) &&
			 !IS_ERROR(dmaBuffer->GetBuffer (dmaDataPtr, dmaSize) ))
			dmaRequest = new JPEGTransferRequest (dmaBuffer);
		else
			{
#if NT_KERNEL | WIN32
			if (log) log->LogEvent (LOG_MSG_NO_DMA_BUFFER);
#endif

			readChannel = NULL;
			writeChannel = NULL;
			delete dmaBuffer;
			dmaBuffer = NULL;
			}			
		}
	if (dmaRequest)
		dmaRequest->SetUnit (jpeg);
#endif

	// Configure the 055 and 050 due to compression or changes.
	if (jpeg->changed  ||  jpeg->compress)
		{
		// Stop all other JPEG operations.
		Stop ();
		Reset ();

		// Reconfigure.
		if (! z055->InitOperation (jpeg->compress, jpeg->stillMode, jpeg->vStandard,
		                           jpeg->vFormat, jpeg->fieldOrder, TRUE,
		                           jpeg->width, jpeg->height))
			{
			GDP("055 init operation failed\n");
			GNRAISE(GNR_RANGE_VIOLATION);
			}

		GNREASSERT( jpeg->coder->InitOperation () );
		z055->ReadStatus ();   // to clear RDY resulting from 050's table preload end

		currentPage = 0;
		for (i = 0;  i < H55_N_BUFFERS;  i++)
			pageAvailable[i] = TRUE;
		}

	jpeg->changed = FALSE;

	GNRAISE_OK;
	}





Error JPEGManager055::StartIRQs (void)
	{
	if (! handlerEnabled)
		{
		jpegEndIntServer = jpegIRQ;
		GNREASSERT( jpegEndIntServer->InstallHandler (jpegEndIntHandler) );
		GNREASSERT( jpegEndIntHandler->Enable () );
		handlerEnabled = TRUE;
		}
	GNRAISE_OK;
	}



Error JPEGManager055::StopIRQs (void)
	{
	if (handlerEnabled)
		{
		handlerEnabled = FALSE;
		GNREASSERT( jpegEndIntHandler->Disable () );
		GNREASSERT( jpegEndIntServer->RemoveHandler (jpegEndIntHandler) );
		}
	GNRAISE_OK;
	}





Error JPEGManager055::ExpandIntoOverlayFrame (FPTR frame, DWORD size)
	{
	DWORD timeOut;


	if (size == 0)
		GNRAISE(GNR_RANGE_VIOLATION);

	if (size >= 128*1024L)
		size = 128*1024L - 4;

	// Wait until the expected page becomes available.
	while (! pageAvailable[currentPage])
		{
		timeOut = Timer.GetMilliTicks () + 200;
		while (! z055->NewStatusReady ())
			{
			if (timeOut < Timer.GetMilliTicks())
				GNRAISE(GNR_JPEG_TIMEOUT);
			}
		z055->ReadStatus();   // clear ready bit
		pageAvailable[currentPage] = TRUE;
		}

	codePort->WriteData (frame, size);
	ExpandStop ();
	GNRAISE_OK;
	}



Error JPEGManager055::ExpandStart (DWORD size)
	{
	DWORD timeOut;


	if (size == 0)
		GNRAISE(GNR_RANGE_VIOLATION);

	if (size >= 128*1024L)
		size = 128*1024L - 4;

	// Wait until the expected page becomes available.
	while (! pageAvailable[currentPage])
		{
		timeOut = Timer.GetMilliTicks () + 200;
		while (! z055->NewStatusReady ())
			{
			if (timeOut < Timer.GetMilliTicks())
				GNRAISE(GNR_JPEG_TIMEOUT);
			}
		z055->ReadStatus();   // clear ready bit
		pageAvailable[currentPage] = TRUE;
		}

	dmaRequest->size = size;
	writeChannel->PostRequest (dmaRequest);

	GNRAISE_OK;
	}



void JPEGManager055::ExpandStop (void)
	{
	pageAvailable[currentPage] = FALSE;
	currentPage++;
	currentPage %= H55_N_BUFFERS / 2;
	z055->SetPageNum (currentPage);

	// Status ready indicates (in most cases) that the 055 started to expand the
	// last page once again. To prevent the host from writing to the page which
	// is being expanded, clear the RDY bit.
	z055->ReadStatus();
	}





Error JPEGManager055::ReadCompressedField (FPTR field, BYTE pageNum, DWORD size)
	{
	// Prevent reads of lengthes ending with 511 or 512 - chip bug.
	DWORD paddedLen = size;
	if ((paddedLen & 0xff) == 0xfe  ||  (paddedLen & 0xff) == 0xfd)
		paddedLen += 8;

	z055->SetPageNum (pageNum);

	// For erroneous sizes - quit without reading !
	if (size == 0)
		GNRAISE(GNR_RANGE_VIOLATION);

#if PCI_VERSION
	paddedLen = (paddedLen+3) & ~3;   // round up to DWORD boundary
	if ((paddedLen & 0xff) == 0xfe  ||  (paddedLen & 0xff) == 0xfd)
		paddedLen += 8;
#endif
	codePort->ReadData (field, paddedLen);

	// Check correctness of compressed field.
	BYTE __huge *fieldHPtr = (BYTE __huge *)field;
	if ((unsigned char)fieldHPtr[0] != (unsigned char)0xff  ||
	    (unsigned char)fieldHPtr[1] != (unsigned char)0xd8)
		GNRAISE(GNR_JPEG_ERROR);

	if ((unsigned char)fieldHPtr[size-2] != (unsigned char)0xff  ||
	    (unsigned char)fieldHPtr[size-1] != (unsigned char)0xd9)
		GNRAISE(GNR_JPEG_ERROR);

	GNRAISE_OK;
	}



Error JPEGManager055::CompressStart (BYTE pageNum, DWORD size)
	{
	// Prevent reads of lengthes ending with 511 or 512 - chip bug.
	DWORD paddedLen = size;
	if ((paddedLen & 0xff) == 0xfe  ||  (paddedLen & 0xff) == 0xfd)
		paddedLen += 8;

	z055->SetPageNum (pageNum);

	// For erroneous sizes - quit without reading !
	if (size == 0)
		GNRAISE(GNR_RANGE_VIOLATION);

#if PCI_VERSION
	paddedLen = (paddedLen+3) & ~3;   // round up to DWORD boundary
	if ((paddedLen & 0xff) == 0xfe  ||  (paddedLen & 0xff) == 0xfd)
		paddedLen += 8;
#endif

	dmaRequest->size = paddedLen;
	readChannel->PostRequest (dmaRequest);

	GNRAISE_OK;
	}



Error JPEGManager055::CompressStop (DWORD size)
	{
	// Check correctness of compressed field.
	BYTE __huge *fieldHPtr = (BYTE __huge *)dmaDataPtr;
	if ((unsigned char)fieldHPtr[0] != (unsigned char)0xff  ||
	    (unsigned char)fieldHPtr[1] != (unsigned char)0xd8)
		GNRAISE(GNR_JPEG_ERROR);

	if ((unsigned char)fieldHPtr[size-2] != (unsigned char)0xff  ||
	    (unsigned char)fieldHPtr[size-1] != (unsigned char)0xd9)
		GNRAISE(GNR_JPEG_ERROR);

	GNRAISE_OK;
	}










//************************************************************************
// The JPEG unit class.
//************************************************************************



// Constructor.

VirtualJPEGUnit055::VirtualJPEGUnit055 (JPEGManager055 *physical, VirtualJCoder *coder)
	: VirtualJPEGUnit (physical, coder)
	{
	manager = physical;

	preemptHook = NULL;

	// Set defaults.
	vStandard  = VSTD_NTSC;
	vFormat    = VFMT_YUV_422;
	fieldOrder = VFLD_SINGLE;
	thumbnail  = FALSE;
	filtersOn  = TRUE;
	}



// Destructor.

VirtualJPEGUnit055::~VirtualJPEGUnit055 (void)
	{
	}





// The function responsible for the tag processing.

Error VirtualJPEGUnit055::Configure (TAG __far *tags)
	{
	GNREASSERT( VirtualJPEGUnit::Configure (tags) );
	GNREASSERT( coder->Configure (tags) );

	// Width must be a multiple of 16 and height a multiple of 8.
	if (width & 0x0f  ||  height & 0x07)
		GNRAISE(GNR_RANGE_VIOLATION);

	PARSE_TAGS_START(tags)
		GETSETC (JPG_VIDEO_STANDARD, vStandard);
		GETSETC (JPG_VIDEO_FORMAT,   vFormat);
		GETSETC (JPG_FIELD_ORDER,    fieldOrder);
		GETSETC (JPG_THUMBNAIL,      thumbnail);
		GETSETC (JPG_MSEC_PER_FRAME, milliSecPerFrame);
		GETSETC (JPG_SINGLEFRAME,    singleFrame);
		GETSETC (JPG_FILTERS_ON,     filtersOn);
		GETSETC (JPG_TOTALCODEVOL,   totalCodeVolume);
		GETSET  (JPG_PREEMPT_HOOK,   preemptHook);
		GETONLY (JPG_HAS_CODEMEMORY, TRUE);
		GETONLY (JPG_HOFFSET,        0);
		GETONLY (JPG_VOFFSET,        0);
		GETONLY (JPG_WANTS_EXT_FI,   TRUE);
		GETONLY (JPG_MAX_FIELDSIZE,  MAX_FIELDSIZE);
		GETONLY (JPG_VBUS_WIDTH,     width);
		GETONLY (JPG_VBUS_HEIGHT,    height);
		GETINQUIRE (JPG_VIDEO_FMT_LIST, data &= VideoFormatBitField;);
	PARSE_TAGS_END

	// We want the coder to use the second field marker for both field.
	// The first field is marked correctly after the grab.
	VideoField order;
	if (vStandard == VSTD_NTSC)
		order = fieldOrder;
	else
		{
		switch (fieldOrder)
			{
			case VFLD_SINGLE:  order = VFLD_SINGLE;  break;
			case VFLD_ODD:     order = VFLD_EVEN;    break;
			case VFLD_EVEN:    order = VFLD_ODD;     break;
			}
		}
	GNREASSERT( coder->ConfigureTags (SET_JPG_FIELD_ORDER(order), TAGDONE) );

	GNRAISE_OK;
	}





Error VirtualJPEGUnit055::PrepareBuffer (FPTR buffer, DWORD size, FPTR __far &info)
	{
	// Note that the buffers are used during interrupt.
#if NO_MORE_GLOBAL_ALLOC_IN_LOW_LEVEL_DRIVERS
	FPTR dummy;
	KernelMemory * kernelMem = new KernelMemory();

	kernelMem->MapMemory(buffer, size, dummy);
	info = kernelMem;
#else
	GlobalPageLock (FP_SEG(buffer));
	info = buffer;
#endif

	GNRAISE_OK;
	}





Error VirtualJPEGUnit055::UnprepareBuffer (FPTR info)
	{
#if NO_MORE_GLOBAL_ALLOC_IN_LOW_LEVEL_DRIVERS
	delete (KernelMemory *)info;
#else
	GlobalPageUnlock (FP_SEG(info));
#endif
	GNRAISE_OK;
	}





#if ! VIONA_VERSION
	// The next line will produce a compiler error.
	The Q-Motion board must have VIONA_VERSION=1.
#endif





// Is a scaling valid ?  We need 24 or 32 bits per pixel, srcWidth <= 768,
// the dst sizes must be <= half the src sizes, and we need an even
// number of MCUs (i.e. srcWidth must be multiple of 16).

BOOL VirtualJPEGUnit055::IsValidExpansionScaling (WORD srcWidth, WORD srcHeight,
                                                  WORD dstWidth, WORD dstHeight,
                                                  GrabFormat bitFormat)
	{
	// We support 32, 24 and 16 bit formats.
	if (bitFormat != VGRB_RGB_888x  &&  bitFormat != VGRB_RGB_888  &&  bitFormat != VGRB_RGB_565)
		return FALSE;

	// No scaling is valid.
	if (dstWidth == srcWidth  &&  dstHeight == srcHeight)
		return TRUE;

	// Check restricted scaling capability.
	if ((bitFormat != VGRB_RGB_888x  &&  bitFormat != VGRB_RGB_888)  ||  srcWidth > 768)
		return FALSE;
	if (dstWidth * 2 > srcWidth  ||  dstHeight * 2 > srcHeight)
		return FALSE;
	if ((srcWidth & 0x0f) != 0)
		return FALSE;
	return TRUE;
	}





// Expand a compressed frame into packed RGB data.

Error VirtualJPEGUnit055::ExpandToRGB (FPTR src, DWORD size, FPTR dst, WORD dstWidth, WORD dstHeight, GrabFormat bitFormat)
	{
	char __huge *blocksBuff;
	WORD hmcuSize, vmcuSize;
	WORD blocksInStrip, blocksInFrame, blocksInField, remainBlocks, fldCnt;
#if !NO_MORE_GLOBAL_ALLOC_IN_LOW_LEVEL_DRIVERS
	HANDLE hBlk;
#endif
	DWORD timeOut;
	DWORD imageSizeInBytes;
	BOOL expansionOK = TRUE;
	char __huge *tmpBlocksBuff;
	WORD width  = this->width;
	WORD height = this->height;
	BOOL scaling;
	Error err;
#if DO_TIMING
	DWORD start = Timer.GetMilliTicks ();
#endif


	// Check unit state.
	if (GetState() != current)
		GNRAISE(GNR_OBJECT_NOT_CURRENT);
	if (compress  ||  ! stillMode)
		GNRAISE(GNR_INVALID_CONFIGURE_STATE);

	// Is scaling valid ?
	if (! IsValidExpansionScaling (width, height, dstWidth, dstHeight, bitFormat))
		GNRAISE(GNR_RANGE_VIOLATION);
	scaling = (dstWidth != width  ||  dstHeight != height);

	changed = TRUE;   // reprogram chip parameters
	GNREASSERT( manager->InitOperation () );

	// Round up source sizes to MCU block size boundaries.
	switch (vFormat)
		{
		case VFMT_YUV_422:  hmcuSize = 16;  vmcuSize =  8;  break;
		case VFMT_YUV_411:  hmcuSize = 32;  vmcuSize =  8;  break;
		case VFMT_YUV_420:  hmcuSize = 16;  vmcuSize = 16;  break;
		default:
			GNRAISE(GNR_RANGE_VIOLATION);
		}
	width += hmcuSize - 1;      // we modify a local copy of the member variable !
	width -= width % hmcuSize;  // we modify a local copy of the member variable !
	height += vmcuSize - 1;
	height -= height % vmcuSize;
	blocksInFrame = (width / 8) * (height / 8) * 2;   // 2 bytes in YUV format

	// Allocate temporary buffer.
	imageSizeInBytes = (DWORD)blocksInFrame * 64L;

#if NO_MORE_GLOBAL_ALLOC_IN_LOW_LEVEL_DRIVERS
#if WIN32
	blocksBuff = new __huge (PagedPool) char[imageSizeInBytes];
#else
	blocksBuff = (char __huge *) _halloc (imageSizeInBytes, sizeof(char));   // MSVC bug in "new __huge"
#endif
	if (! blocksBuff)
		{
		GDP("temp buffer not allocated");
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
		}
#else
	hBlk = GlobalAlloc (GMEM_MOVEABLE, imageSizeInBytes);
	if (! hBlk)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	blocksBuff = (char __huge *) GlobalLock (hBlk);
	if (! blocksBuff)
		{
		GDP("temp buffer not allocated");
		GlobalFree (hBlk);
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
		}
#endif

	tmpBlocksBuff = blocksBuff;

	manager->z055->SetBlocksInStrip (MAX_BLOCKS_IN_STRIP - 1, FALSE);

	// Start expansion.
	GNREASSERT( Start () );
	err = manager->ExpandIntoOverlayFrame (src, size);
	if (IS_ERROR(err))
		{
		Stop ();
#if NO_MORE_GLOBAL_ALLOC_IN_LOW_LEVEL_DRIVERS
#if WIN32
		delete[] blocksBuff;
#else
		_hfree (blocksBuff);
#endif
#else
		GlobalUnlock (hBlk);
		GlobalFree (hBlk);
#endif
		return err;
		}
	manager->z055->ReadStatus ();   // to clear RDY bit
	if (fieldOrder != VFLD_SINGLE)
		{
		blocksInField = blocksInFrame / 2;
		if (scaling)
			fldCnt = 1;   // transfer only one field, ignore second
		else
			fldCnt = 2;
		}
	else
		{
		blocksInField = blocksInFrame;
		fldCnt = 1;
		}

	// Get the strip buffer contents.
	while (fldCnt != 0)
		{
		remainBlocks = blocksInField;
		while (remainBlocks != 0)
			{
			timeOut = Timer.GetMilliTicks () + 200;
			while (! manager->z055->StripReady ())
				{
				if (timeOut < Timer.GetMilliTicks())
					{
					Stop ();
#if NO_MORE_GLOBAL_ALLOC_IN_LOW_LEVEL_DRIVERS
#if WIN32
					delete[] blocksBuff;
#else
					_hfree (blocksBuff);
#endif
#else
					GlobalUnlock (hBlk);
					GlobalFree (hBlk);
#endif
					GNRAISE(GNR_JPEG_TIMEOUT);
					}
				}
			if (remainBlocks > MAX_BLOCKS_IN_STRIP)
				{
				blocksInStrip = MAX_BLOCKS_IN_STRIP;
				// if (remainBlocks > (MAX_BLOCKS_IN_STRIP * 2))
				if (manager->z055->NewStatusReady ())
					expansionOK = FALSE;
				}
			else
				blocksInStrip = remainBlocks;
			remainBlocks -= blocksInStrip;
			manager->stripPort->ReadData (tmpBlocksBuff, blocksInStrip * 64);
			tmpBlocksBuff += blocksInStrip * 64;
			}
		fldCnt--;
		}

	// Convert from blocks to raster and from YUV to RGB.
#if DO_TIMING
	DWORD yuvStart = Timer.GetMilliTicks ();
#endif
	if (scaling)
		{
		if (fieldOrder != VFLD_SINGLE)
			height /= 2;
		switch (bitFormat)
			{
			case VGRB_RGB_888x:  mapYUV422BlockstoBGR32Scale (blocksBuff, dst, width, height, dstWidth, dstHeight);  break;
#if !NT_KERNEL
			case VGRB_RGB_888:   mapYUV422BlockstoBGR24Scale (blocksBuff, dst, width, height, dstWidth, dstHeight);  break;
#endif
			default:
				GNRAISE(GNR_RANGE_VIOLATION);
			}
		}
	else
		{
		switch (bitFormat)
			{
			case VGRB_RGB_888x:  mapYUV422BlockstoBGR32 (blocksBuff, dst, width, height, fieldOrder);  break;
			case VGRB_RGB_888:   mapYUV422BlockstoBGR24 (blocksBuff, dst, width, height, fieldOrder);  break;
			case VGRB_RGB_565:   mapYUV422BlockstoRGB16 (blocksBuff, dst, width, height, fieldOrder);  break;
			default:
				GNRAISE(GNR_RANGE_VIOLATION);
			}
		}
#if DO_TIMING
	GDP("yuv time %ld", Timer.GetMilliTicks() - yuvStart);
#endif

	// Deallocate temporary buffer.
	Stop ();
#if NO_MORE_GLOBAL_ALLOC_IN_LOW_LEVEL_DRIVERS
#if WIN32
	delete[] blocksBuff;
#else
	_hfree (blocksBuff);
#endif
#else
	GlobalUnlock (hBlk);
	GlobalFree (hBlk);
#endif

#if DO_TIMING
	GDP("total expansion time %ld", Timer.GetMilliTicks() - start);
#endif
	GNRAISE_OK;
	}





// Compress RGB data into a frame.

Error VirtualJPEGUnit055::CompressFromRGB (FPTR src, FPTR dst, DWORD maxSize, DWORD __far &size, BOOL bits32)
	{
	DWORD imageSizeInBytes;
	WORD numberOfBlocks;
#if !NO_MORE_GLOBAL_ALLOC_IN_LOW_LEVEL_DRIVERS
	HANDLE hBlk;
#endif
	char __huge *blocksBuff;
	FPTR oddField, oddBlocks;
	DWORD evenSize, oddSize;
	Error err;
#if DO_TIMING
	DWORD start = Timer.GetMilliTicks ();
#endif


	// Check unit state.
	if (GetState() != current)
		GNRAISE(GNR_OBJECT_NOT_CURRENT);
	if (! compress  ||  ! stillMode)
		GNRAISE(GNR_INVALID_CONFIGURE_STATE);

	GNREASSERT( manager->InitOperation () );

	imageSizeInBytes = (DWORD)width * (DWORD)height * 3L;
	if (fieldOrder != VFLD_SINGLE)
		maxSize /= 2;

	// Allocate temporary buffer.
#if NO_MORE_GLOBAL_ALLOC_IN_LOW_LEVEL_DRIVERS
#if WIN32
	blocksBuff = new __huge (PagedPool) char[imageSizeInBytes];
#else
	blocksBuff = (char __huge *) _halloc (imageSizeInBytes, sizeof(char));   // MSVC bug in "new __huge"
#endif
	if (! blocksBuff)
		{
		GDP("temp buffer not allocated");
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
		}
#else
	hBlk = GlobalAlloc (GMEM_MOVEABLE, imageSizeInBytes);
	if (! hBlk)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	blocksBuff = (FPTR) GlobalLock (hBlk);
	if (! blocksBuff)
		{
		GDP("temp buffer not allocated");
		GlobalFree (hBlk);
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
		}
#endif

#if DO_TIMING
	DWORD yuvStart = Timer.GetMilliTicks ();
#endif
	if (bits32)
		{
		GDP("using 32 bits");
		numberOfBlocks = mapRGB32toYUV422Blocks (src, blocksBuff, width, height, (fieldOrder == VFLD_SINGLE));
		// for an interlaced image, numberOfBlocks is the number of blocks
		// in EACH of the fields !!!
		}
	else
		{
		GDP("using 24 bits");
		numberOfBlocks = mapRGB24toYUV422Blocks (src, blocksBuff, width, height, (fieldOrder == VFLD_SINGLE));
		// for an interlaced image, numberOfBlocks is the number of blocks
		// in EACH of the fields !!!
		}
#if DO_TIMING
	GDP("yuv time %ld", Timer.GetMilliTicks() - yuvStart);
#endif

	// Compress the first field.
	GNREASSERT( Start () );
	err = CompressField (blocksBuff, numberOfBlocks, dst, maxSize, evenSize);
	if (! IS_ERROR(err))
		{
		size = evenSize;
		if (fieldOrder != VFLD_SINGLE)
			{
			// Compress the second field.
			oddField  = (FPTR)((char __huge *)dst + evenSize);
			oddBlocks = (FPTR)((char __huge *)blocksBuff + (DWORD)numberOfBlocks * 64L);

			err = CompressField (oddBlocks, numberOfBlocks, oddField, maxSize, oddSize);
			size += oddSize;
			}
		}

	Stop ();
	if (! IS_ERROR(err))
		{
		((VirtualJCoderRated *)(coder))->GetLastScaleFactor ();

		// Mark the first field correctly.
		VideoField order;
		if (vStandard == VSTD_NTSC)
			{
			switch (fieldOrder)
				{
				case VFLD_SINGLE:  order = VFLD_SINGLE;  break;
				case VFLD_ODD:     order = VFLD_EVEN;    break;
				case VFLD_EVEN:    order = VFLD_ODD;     break;
				}
			}
		else
			order = fieldOrder;
		coder->MarkFirstField (dst, size, order);
		}
#if NO_MORE_GLOBAL_ALLOC_IN_LOW_LEVEL_DRIVERS
#if WIN32
	delete[] blocksBuff;
#else
	_hfree (blocksBuff);
#endif
#else
	GlobalUnlock (hBlk);
	GlobalFree (hBlk);
#endif

#if DO_TIMING
	GDP("total compression time %ld", Timer.GetMilliTicks() - start);
#endif
	return err;
	}





	Error VirtualJPEGUnit055::CompressField (FPTR src, WORD numberOfBlocks, FPTR dst, DWORD maxSize, DWORD __far &size)
		{
		BYTE __huge *blocksPtr;
		BYTE pageNum;
		WORD blocksInStrip;
		DWORD timeOut;
		DWORD minSize = totalCodeVolume * 5 / 8;
		DWORD compressedSize = 0;
		WORD numOfBlocks = numberOfBlocks;
		WORD tries = 0;
		BOOL accept = FALSE;
		BOOL remainBlocksDivided, lastStrip;


		while (! accept)
			{
			remainBlocksDivided = FALSE;   // to ident split of last strip
			numberOfBlocks = numOfBlocks;
			blocksPtr = (BYTE __huge *)src;   // update in case of fail to compress
			while (numberOfBlocks != 0)
				{
				timeOut = Timer.GetMilliTicks () + 200;
				while (! manager->z055->StripReady ())
					{
					if (timeOut < Timer.GetMilliTicks())
						{
						GDP("timeout waiting for StripReady");
						GNRAISE(GNR_JPEG_TIMEOUT);
						}
					}

				if (numberOfBlocks > MAX_BLOCKS_IN_STRIP)
					{
					blocksInStrip = MAX_BLOCKS_IN_STRIP;
					lastStrip = FALSE;
					}
				else if (! remainBlocksDivided)
					{
					remainBlocksDivided = TRUE;
					blocksInStrip = numberOfBlocks / 2;
					lastStrip = FALSE;
					}
				else
					{
					blocksInStrip = numberOfBlocks;
					lastStrip = TRUE;
					}
				manager->z055->SetBlocksInStrip (blocksInStrip - 1, lastStrip);
				manager->stripPort->WriteData (blocksPtr, blocksInStrip * 64);
				numberOfBlocks -= blocksInStrip;
				blocksPtr += blocksInStrip * 64;   // due to 64 bytes per block
				}

			timeOut = Timer.GetMilliTicks () + 200;
			while (! manager->z055->NewStatusReady ())
				{
				if (timeOut < Timer.GetMilliTicks())
					{
					GDP("timeout waiting for NewStatusReady");
					GNRAISE(GNR_JPEG_TIMEOUT);
					}
				}

			manager->z055->ReadStatus ();
			pageNum = manager->z055->GetPageNum ();
			compressedSize = manager->z055->GetFieldLength ();

			if (compressedSize <= maxSize  &&  compressedSize >= minSize)
				accept = TRUE;
			else
				{
				GDP("one more: %ld in range %ld - %ld", compressedSize, minSize, maxSize);
				if (++tries >= MAX_COMPRESS_TRIES)
					{
					if (compressedSize < minSize)
						accept = TRUE;   // we cannot get more code, so accept this compression
					else
						{
						GDP("too many tries");
						GNRAISE(GNR_JPEG_TIMEOUT);
						}
					}
				}
			} // while

		GNREASSERT( manager->ReadCompressedField (dst, pageNum, compressedSize) );

		size = compressedSize;
		GNRAISE_OK;
		}





Error VirtualJPEGUnit055::InitCapture (JPEGCaptureHook __far *hook)
	{
	int i;


	// Check unit state.
	if (GetState() != current)
		GNRAISE(GNR_OBJECT_NOT_CURRENT);
	if (! compress  ||  stillMode)
		GNRAISE(GNR_INVALID_CONFIGURE_STATE);

	for (i = 0;  i < N_DLL_BUFFERS;  i++)
		{
		buffers[i].info     = NULL;
		buffers[i].userData = NULL;
		}
	nextBuffer = 0;
	lastBuffer = 0;
	nBuffers   = 0;
	fieldNum   = 0;
	lastFieldCnt = 255;

	nextFrameTime = 0;

	// Prevent starting on second field for single field capture.
	FirstLen = 100;   // must not be zero
	transferRunning = FALSE;
	capState = CAP_NONE;

	// Initialize the operation.
	GNREASSERT( manager->InitOperation () );
	capHook = hook;
	GNRAISE( manager->StartIRQs () );
	}





Error VirtualJPEGUnit055::FinishCapture (void)
	{
#if NT_KERNEL
	irqMutex.Enter();
	capHook = NULL;
	irqMutex.Leave();
#else
	capHook = NULL;
#endif
	return manager->StopIRQs ();
	}





void VirtualJPEGUnit055::PassUpBuffer (void)
	{
	DWORD nextFrameNum, timeStream;
	Error err;


	buffers[nextBuffer].info = NULL;   // buffer available for adding another buffer
	nBuffers--;
	capMsg.repeatIfEmpty = FALSE; //(nBuffers == 0);

	if (! singleFrame  &&  fieldOrder == VFLD_SINGLE)
		{
		if ((capMsg.frameNum & 1) == 1)
			{
			// Drop second field in single field mode.
			GDP("Dropping second field");
			buffers[nextBuffer].info = NULL;   // buffer available for adding another buffer
			capMsg.byteSize = 0;
			}
		capMsg.frameNum >>= 1;
		}

	// Drop the very first two frames of a sequence to let the bit rate control
	// process stabilize.
	if (capMsg.byteSize > 0  &&  (capMsg.frameNum >= 2L  ||  singleFrame))
		{
		// Mark the first field correctly.
		VideoField order;
		if (vStandard == VSTD_NTSC)
			{
			switch (fieldOrder)
				{
				case VFLD_SINGLE:  order = VFLD_SINGLE;  break;
				case VFLD_ODD:     order = VFLD_EVEN;    break;
				case VFLD_EVEN:    order = VFLD_ODD;     break;
				}
			}
		else
			order = fieldOrder;
		err = coder->MarkFirstField (KMEM(capMsg.info), capMsg.byteSize, order);
		if (IS_ERROR(err))
			{
			GDP("marking first field %08lx", err);
			}

		if (singleFrame)
			nextFrameNum = capMsg.frameNum;
		else
			nextFrameNum = capMsg.frameNum - 2L;

		// Compute the time of the frame.
		if (VSTD_NTSC == vStandard)
			// nextFrameNum * 780 * 525 * 1000 / 12 272 727.
			timeStream = ScaleDWord (nextFrameNum, 4090909L, 136500000);
		else
			timeStream = 40 * nextFrameNum;

		// If it's time for a new frame, process it.
		if (timeStream >= nextFrameTime)
			{
			// Capture OK.
			nextFrameTime += milliSecPerFrame;
			capMsg.captureTime = timeStream;
			}
		else
			{
			GDP("not yet time\n");
			capMsg.byteSize = 0;
			}
		}
	else
		capMsg.byteSize = 0;

	capHook.Call (capMsg);
	nextBuffer = (nextBuffer+1) & (N_DLL_BUFFERS-1);
	}





void VirtualJPEGUnit055::DMATransferDone (void)
	{
#if PCI_VERSION
#if NT_KERNEL
	irqMutex.EnterAtIRQLevel();
#endif

	if (compress  &&  transferRunning)
		{
		transferRunning = FALSE;
		manager->CompressStop (capMsg.byteSize);

		BOOL doCallback = FALSE;

		switch (capState)
			{
			case CAP_NONE:
				break;

			case CAP_SINGLE_FIRST_BAD:
			case CAP_SINGLE_FIRST:
				_hmemcpy (KMEM(capMsg.info), manager->dmaDataPtr, capMsg.byteSize);
				doCallback = TRUE;
				break;

			case CAP_FIRST:
				_hmemcpy (KMEM(capMsg.info), manager->dmaDataPtr, capMsg.byteSize);
				break;

			case CAP_FIRST_BAD:
				_hmemcpy (KMEM(capMsg.info), manager->dmaDataPtr, capMsg.byteSize);
				GDP("Duplicate second");
				_hmemcpy ((char __huge *)KMEM(capMsg.info) + capMsg.byteSize, KMEM(capMsg.info), capMsg.byteSize);
				capMsg.byteSize *= 2;
				doCallback = TRUE;
				break;

			case CAP_SECOND:
				char __huge *p = (char __huge *)KMEM(capMsg.info) + FirstLen;
				_hmemcpy (p, manager->dmaDataPtr, capMsg.byteSize);
				capMsg.byteSize += FirstLen;
				doCallback = TRUE;
				break;
			}

		if (doCallback)
			{
GDP("finDMA %d", nextBuffer);
			PassUpBuffer ();
			}
		}


	if (! compress  &&  transferRunning)
		{
		transferRunning = FALSE;
		manager->ExpandStop ();

GDP("finish %ld", (long)nextBuffer);
		nBuffers--;
		buffers[nextBuffer].info = NULL;   // buffer available for adding another buffer
		nextBuffer = (nextBuffer+1) & (N_DLL_BUFFERS-1);
		}

#if NT_KERNEL
	irqMutex.LeaveAtIRQLevel();
#endif
#endif
	}





void VirtualJPEGUnit055::JPEGEndInterrupt (void)
	{
	class Z055 *z055 = manager->z055;
	DWORD fieldCnt;
	BYTE page;
	DWORD firstFieldBit;
	Error err;

	JPEGPlaybackMsg pmsg;
	FPTR src;
	DWORD size;

#if NT_KERNEL
	irqMutex.EnterAtIRQLevel();
#endif

	// Motion compression.
	if (compress)
		{
		if (transferRunning)
			{
			GDP("transfer running");
#if NT_KERNEL
			irqMutex.LeaveAtIRQLevel();
#endif
			return;
			}

		if (capHook == NULL)
			{
			GDP("No capHook");
			z055->ReadStatus ();
#if NT_KERNEL
			irqMutex.LeaveAtIRQLevel();
#endif
			return;
			}

		if (! manager->readChannel)
			transferRunning = TRUE;
		do {
			z055->ReadStatus ();

			if (buffers[nextBuffer].info == NULL)
				{
				// No buffer available.
				GDP("no buffer available");
				// Call the capture driver so it can pass down new buffers.
				page = z055->GetPageNum ();
				manager->ReadCompressedField (NULL, page, 0);   // dummy read
				capMsg.info     = NULL;
				capMsg.userData = NULL;
				capMsg.byteSize = 0;
				capHook.Call (capMsg);
				}
			else
				{
				// Get field parameters from the 055.
				page = z055->GetPageNum ();
				fieldCnt = (DWORD) z055->GetFieldCount ();

				if ((fieldNum & 0xff) > fieldCnt)
					fieldNum += 256;
				fieldNum = (fieldNum & 0xffffff00) | fieldCnt;
				capMsg.info     = buffers[nextBuffer].info;
				capMsg.userData = buffers[nextBuffer].userData;
				capMsg.frameNum = fieldNum;
				capMsg.byteSize = z055->GetFieldLength ();

#if 0
					{
					static int lastPageNum;
					static DWORD lastFieldNum;

					if (page != (lastPageNum + 1) % 4)
						DP("Page num wrong %d -> %d", page, lastPageNum);
					if (fieldNum != lastFieldNum + 1)
						DP("Field num wrong %ld -> %ld", fieldNum, lastFieldNum);

					lastFieldNum = fieldNum;
					lastPageNum = page;
					}
#endif

				capState = CAP_NONE;

				if (fieldOrder == VFLD_SINGLE)
					{
					// Single field capture.
					if (1 == (fieldNum & 1))
						{
						if (FirstLen != 0)
							// First field was captured. Drop second field.
							manager->ReadCompressedField (KMEM(capMsg.info), page, 0);   // dummy read
						else
							{
							// First field was bad. We can save the frame from being dropped by
							// using the second field.
							if (capMsg.byteSize > buffers[nextBuffer].byteSize)
								{
								GDP("Single second field too large");
								manager->ReadCompressedField (KMEM(capMsg.info), page, 0);   // dummy read
								}
							else
								{
								// Get the second field data.
								if (manager->readChannel)
									{
									GDP("single first bad");
									err = manager->CompressStart (page, capMsg.byteSize);   // use DMA
									}
								else
									err = manager->ReadCompressedField (KMEM(capMsg.info), page, capMsg.byteSize);

								if (IS_ERROR(err))
									GDP("Single second field bad");
								else
									{
									GDP("Using second");
									capMsg.frameNum = FirstNum;
									capState = CAP_SINGLE_FIRST_BAD;   // pass data to capture driver
									if (manager->readChannel)
										{
										transferRunning = TRUE;
#if NT_KERNEL
										irqMutex.LeaveAtIRQLevel();
#endif
										return;
										}
									}
								}
							}
						}
					else
						{
						// Get the data of the first field. Take care of maximum buffer size.
GDP("cnt %ld ", fieldNum);
						FirstNum = fieldNum;
						FirstLen = 0;
						if (capMsg.byteSize > buffers[nextBuffer].byteSize)
							{
							GDP("Single field too large");
							manager->ReadCompressedField (KMEM(capMsg.info), page, 0);   // dummy read
							}
						else
							{
							if (manager->readChannel)
								{
								GDP("single first");
								err = manager->CompressStart (page, capMsg.byteSize);   // use DMA
								}
							else
								err = manager->ReadCompressedField (KMEM(capMsg.info), page, capMsg.byteSize);

							if (IS_ERROR(err))
								{
								GDP("Bad single field");
								}
							else
								{
								FirstLen = capMsg.byteSize;   // first field OK
								capState = CAP_SINGLE_FIRST;   // pass data to capture driver
								if (manager->readChannel)
									{
									transferRunning = TRUE;
#if NT_KERNEL
									irqMutex.LeaveAtIRQLevel();
#endif
									return;
									}
								}
							}
						}
					}
				else
					{
					// Two field capture. Join first and second field.
					if (vStandard == VSTD_NTSC)
						firstFieldBit = (fieldOrder != VFLD_EVEN ? 1UL : 0UL);
					else
						firstFieldBit = (fieldOrder != VFLD_ODD ? 1UL : 0UL);
					if (firstFieldBit == (fieldNum & 1))
						{
						// First field. Remember its parameters and get it. Take care of maximum buffer size.
						FirstNum = fieldNum;
						FirstLen = 0;
						if (capMsg.byteSize > buffers[nextBuffer].byteSize)
							{
							GDP("First field too large");
							manager->ReadCompressedField (KMEM(capMsg.info), page, 0);   // dummy read
							}
						else
							{
							if (manager->readChannel)
								err = manager->CompressStart (page, capMsg.byteSize);   // use DMA
							else
								err = manager->ReadCompressedField (KMEM(capMsg.info), page, capMsg.byteSize);

							if (IS_ERROR(err))
								{
								GDP("Bad first field");
								}
							else
								{
								FirstLen = capMsg.byteSize;   // first field OK
								capState = CAP_FIRST;
								if (manager->readChannel)
									{
									transferRunning = TRUE;
#if NT_KERNEL
									irqMutex.LeaveAtIRQLevel();
#endif
									return;
									}
								}
							}
						}
					else
						{
						// Second field.
						capMsg.frameNum = FirstNum >> 1;
						if (FirstLen == 0)
							{
							// First field was bad. We can save the frame from being dropped by duplicating
							// the second field.
							if (2 * capMsg.byteSize > buffers[nextBuffer].byteSize)
								{
								GDP("First bad, second too large");
								manager->ReadCompressedField (KMEM(capMsg.info), page, 0);   // dummy read
								}
							else
								{
								if (manager->readChannel)
									err = manager->CompressStart (page, capMsg.byteSize);   // use DMA
								else
									err = manager->ReadCompressedField (KMEM(capMsg.info), page, capMsg.byteSize);

								if (IS_ERROR(err))
									{
									GDP("First and second bad");
									}
								else
									{
									capState = CAP_FIRST_BAD;   // pass data to capture driver
									if (manager->readChannel)
										{
										transferRunning = TRUE;
#if NT_KERNEL
										irqMutex.LeaveAtIRQLevel();
#endif
										return;
										}
									// Duplicate second field.
									GDP("Duplicate second");
									_hmemcpy ((char __huge *)KMEM(capMsg.info) + capMsg.byteSize, KMEM(capMsg.info), capMsg.byteSize);
									capMsg.byteSize *= 2;
									}
								}
							}
						else if (FirstNum + 1 != fieldNum)
							{
							// Fields don't belong together.
							GDP("Field %ld and %ld not joined", FirstNum, fieldNum);
							manager->ReadCompressedField (KMEM(capMsg.info), page, 0);   // dummy read
							}
						else
							{
							// Read the second field data behind the first field data. Take care of maximum buffer size.
GDP("cnt %ld ", fieldNum);
							char __huge *p = (char __huge *)KMEM(capMsg.info) + FirstLen;
							if (capMsg.byteSize+FirstLen > buffers[nextBuffer].byteSize)
								{
								GDP("Second field too large");
								manager->ReadCompressedField (KMEM(capMsg.info), page, 0);   // dummy read
								}
							else
								{
								if (manager->readChannel)
									err = manager->CompressStart (page, capMsg.byteSize);   // use DMA
								else
									err = manager->ReadCompressedField ((FPTR)p, page, capMsg.byteSize);

								if (IS_ERROR(err))
									{
									GDP("Bad second field");
									}
								else
									{
									capState = CAP_SECOND;   // pass data to capture driver
									if (manager->readChannel)
										{
										transferRunning = TRUE;
#if NT_KERNEL
										irqMutex.LeaveAtIRQLevel();
#endif
										return;
										}
									capMsg.byteSize += FirstLen;
									}
								}
							// If the second field is bad or too large, duplicate the first.
							if (capState != CAP_SECOND)
								{
								if (2 * FirstLen > buffers[nextBuffer].byteSize)
									{
									GDP("First not duplicated, too large");
									}
								else
									{
									GDP("Duplicate first");
									_hmemcpy ((FPTR)p, KMEM(capMsg.info), FirstLen);
									capMsg.byteSize = 2 * FirstLen;
									capState = CAP_SECOND;   // pass data to capture driver
									}
								}
							}
						}
					}

				if (capState != CAP_NONE  &&  capState != CAP_FIRST)
					{
GDP("finish %d", nextBuffer);
					PassUpBuffer ();
					}
				}

			} while (buffers[nextBuffer].info != NULL  &&  z055->NewStatusReady ());
		if (! manager->readChannel)
			transferRunning = FALSE;
		}


	// Motion playback.
	if (! compress)
		{
		if (transferRunning)
			{
			// We are still copying data via port, so lose this frame.
			GDP("transfer overlap");
#if NT_KERNEL
			irqMutex.LeaveAtIRQLevel();
#endif
			return;
			}

		if (fieldOrder == VFLD_SINGLE  &&  irqSecondField)
			{
			// Interrupt for the second field.
			irqSecondField = ! irqSecondField;
			manager->z055->ReadStatus ();
#if NT_KERNEL
			irqMutex.LeaveAtIRQLevel();
#endif
			return;
			}

		// Interrupt for the first field.
		irqSecondField = ! irqSecondField;

		pmsg.nowTime = Timer.GetMilliTicks ();
		if (playHook != NULL)
			{
			playHook.Call (pmsg);
			}
#if 0
			{
			static int x;
			static DWORD now;
			static DWORD pred;

			now = Timer.GetMilliTicks();

			DP("<%ld>", now-pred);
			if (x++ == 32)
				{
				x = 0;
				DP("\n");
				}

			pred = now;
			}
#endif

		if (nBuffers <= 1)
			{
			// No new buffer was supplied.
			manager->z055->ReadStatus ();
			}
		else
			{
			src  = KMEM(buffers[nextBuffer].info);
			size = buffers[nextBuffer].byteSize;
			if (size != 0  &&  nBuffers > 1)
				{
				if (manager->writeChannel)
					{
					// Write the data via DMA.
					_hmemcpy (manager->dmaDataPtr, src, size);
					if (IS_ERROR( manager->ExpandStart (size) ))
						{
						GDP("ExpandStart failed");
						manager->z055->ReadStatus ();
						}
					else
						{
						transferRunning = TRUE;
						}
#if NT_KERNEL
					irqMutex.LeaveAtIRQLevel();
#endif
					return;
					}
				else
					{
					// No DMA used.
					transferRunning = TRUE;
					if (IS_ERROR( manager->ExpandIntoOverlayFrame (src, size) ))
						manager->z055->ReadStatus ();
					transferRunning = FALSE;
					}
				}
			else
				{
				GDP("size is zero");
				manager->z055->ReadStatus ();
				}
			// If we had overlapping interrupts and the intermediate
			// interrupt terminated itself, ExpandIntoOverlayFrame()
			// or the code above will have called ReadStatus() to
			// maintain interrupts.
//GDP("finish %ld", (long)nextBuffer);
			if (nBuffers > 1)
				{
				nBuffers--;
				buffers[nextBuffer].info = NULL;   // buffer available for adding another buffer
				nextBuffer = (nextBuffer+1) & (N_DLL_BUFFERS-1);
				}
			}
		}

#if NT_KERNEL
	irqMutex.LeaveAtIRQLevel();
#endif
	}





Error VirtualJPEGUnit055::AddVideoBuffer (FPTR info, FPTR userData, DWORD size)
	{
	if (buffers[lastBuffer].info != NULL)
		{
//		GDP("Pipe full");
		GNRAISE(GNR_JPEG_PIPE_FULL);
		}

//GDP("filling %d", lastBuffer);
	buffers[lastBuffer].info     = info;
	buffers[lastBuffer].userData = userData;
	buffers[lastBuffer].byteSize = size;
	lastBuffer = (lastBuffer+1) & (N_DLL_BUFFERS-1);
	nBuffers++;
	GNRAISE_OK;
	}





Error VirtualJPEGUnit055::AllocateVideoBuffer (DWORD size, FPTR __far &info, FPTR __far &data)
	{
	size = (size + 3) & ~3;

#if NO_MORE_GLOBAL_ALLOC_IN_LOW_LEVEL_DRIVERS
	FPTR userSpace, kernelSpace;

	KernelMemory * kernelMem = new KernelMemory();
	kernelMem->AllocMemory(size, userSpace, kernelSpace);

	info = kernelMem;
	data = userSpace;

	GNRAISE_OK;
#else
	HGLOBAL handle;
	char __far *ptr;

	handle = GlobalAlloc (GMEM_FIXED, size);
	if (handle == NULL)
		{
		GDP("AllocateVideoBuffer: no alloc size %ld", size);
		}
	else
		{
		if (0 == GlobalPageLock (handle))
			{
			GDP("AllocateVideoBuffer: can't lock handle %ld", (DWORD)handle);
			}
		else
			{
			ptr = GlobalLock (handle);
			if (ptr == NULL)
				{
				GDP("AllocateVideoBuffer: no ptr for handle %ld", (DWORD)handle);
				}
			else
				{
				data = ptr;
				return PrepareBuffer (data, size, info);
				}
			GlobalPageUnlock (handle);
			}
		GlobalFree (handle);
		}
	GNRAISE(GNR_NOT_ENOUGH_MEMORY);
#endif
	}





Error VirtualJPEGUnit055::FreeVideoBuffer (FPTR info)
	{
#if NO_MORE_GLOBAL_ALLOC_IN_LOW_LEVEL_DRIVERS
	if (info)
		{
		delete (KernelMemory *)info;
		}
	else
		GNRAISE(GNR_MEM_NOT_ALLOCATED);

	GNRAISE_OK;
#else
	HGLOBAL handle;
	Error err;

	if (info == NULL)
		{
		GDP("FreeVideoBuffer: NULL frag ptr");
		GNRAISE(GNR_MEM_NOT_ALLOCATED);
		}
	err = UnprepareBuffer (info);
	if (IS_ERROR(err))
		{
		GDP("FreeVideoBuffer: can't unprepare, error %08lx", err);
		}
	handle = FP_SEG(info);
	GlobalUnlock (handle);
	GlobalPageUnlock (handle);
	GlobalFree (handle);
#endif
	GNRAISE_OK;
	}





Error VirtualJPEGUnit055::InitPlayback (JPEGPlaybackHook __far *hook)
	{
	int i;


	// Check unit state.
	if (GetState() != current)
		GNRAISE(GNR_OBJECT_NOT_CURRENT);
	if (compress  ||  stillMode)
		GNRAISE(GNR_INVALID_CONFIGURE_STATE);

	if (changed)
		{
		for (i = 0;  i < N_DLL_BUFFERS;  i++)
			{
			buffers[i].info     = NULL;
			buffers[i].userData = NULL;
			}
		nextBuffer = 0;
		lastBuffer = 0;
		nBuffers   = 0;
		fieldNum   = 0;
		lastFieldCnt = 255;
		}

	// Initialize the operation.
	GNREASSERT( manager->InitOperation () );
	transferRunning = FALSE;
	playHook = hook;
	GNRAISE_OK;
	}





Error VirtualJPEGUnit055::FinishPlayback (void)
	{
	if (playHook)
		{
#if NT_KERNEL
		irqMutex.Enter();
#endif
		int wait = (nBuffers > N_DLL_BUFFERS) ? N_DLL_BUFFERS : nBuffers;
		playHook = NULL;
#if NT_KERNEL
		irqMutex.Leave();
#endif
		Timer.WaitMilliSecs (wait*40);   // wait until the last passed buffer has been played
		return manager->StopIRQs ();
		}
	GNRAISE_OK;
	}





Error VirtualJPEGUnit055::PlayBuffer (FPTR info, DWORD size)
	{
	Error err;

	if (manager->writeChannel == NULL  ||  playHook == NULL)
		{
		// No DMA used.
		if (nBuffers > 0) //  &&  buffers[nextBuffer].info == info)
			{
			GDP("removing %ld", (long)nextBuffer);
			nBuffers--;
			buffers[nextBuffer].info = NULL;   // buffer available for adding another buffer
			nextBuffer = (nextBuffer+1) & (N_DLL_BUFFERS-1);
			}
		transferRunning = TRUE;
		err = manager->ExpandIntoOverlayFrame (info, size);
		transferRunning = FALSE;
		}
	else
		{
		// Write the data via DMA.
		_hmemcpy (manager->dmaDataPtr, info, size);
		err = manager->ExpandStart (size);
		if (IS_ERROR(err))
			{
			GDP("ExpandStart failed");
			manager->z055->ReadStatus ();
			}
		else
			{
			transferRunning = TRUE;
			}
		}
	return err;
	}





Error VirtualJPEGUnit055::Start (void)
	{
	if (GetState() != current)
		GNRAISE(GNR_OBJECT_NOT_CURRENT);
	else
		{
		if (compress  ||  playHook)
			GNREASSERT( manager->StartIRQs () );
		manager->Start ();
		GNRAISE_OK;
		}
	}





// Preempt the other virtual unit and program our state into the chips.
// We must be the current unit before this call.

Error VirtualJPEGUnit055::Preempt (VirtualUnit *previous)
	{
	VirtualJPEGUnit055 *prev = (VirtualJPEGUnit055 *)previous;
	JPEGMsg msg;


	if (this != previous  &&  GetState() == current)
		{
		GNREASSERT( coder->Activate () );
		if (prev != NULL)
			{
			// Inform the preempted user that his operation is suspended. He also
			// must switch his video units to pattern mode.
			if (prev->preemptHook)
				{
				msg.userData = NULL;
				prev->preemptHook.Call (msg);
				}
			else
				{
				// Switching from playback to still operation blanks the video output.
				if (stillMode  &&  ! prev->stillMode  &&  ! prev->compress  &&  manager->blankUnit != NULL)
					manager->blankUnit->Activate ();
				}
			}
		}
	GNRAISE_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\jpeg\specific\Z055.cpp ===
// FILE:      library\hardware\jpeg\generic\z055.cpp
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1996 Viona Development.  All Rights Reserved.
// CREATED:   02.02.96
//
// PURPOSE: The ZR36055 motion JPEG controller class.
//
// HISTORY:

#include "z055.h"
#include "library\lowlevel\timer.h"
#include "library\lowlevel\timer.h"





#define H55_IDENTIFIER  0x15

#define H55_DIMENSION_MASK  0x07FF

#define H55_HIMG_STRT       0x0000
#define H55_HIMG_END        0x1000
#define H55_HIMG_TOTAL      0x2000
#define H55_VIMG_STRT       0x8000
#define H55_VIMG_END        0x9000
#define H55_VIMG_TOTAL      0xA000
#define H55_HSYNC_STRT      0x3000
#define H55_HSYNC_END       0x4000
#define H55_ABLANK          0x5000
#define H55_MCUS_IN_LINE    0xC000
#define H55_BLOCKS_IN_STRIP 0xD000
#define H55_LAST_STRIP      0xD800
#define H55_BACK_COLOUR_Y   0xE000
#define H55_BACK_COLOUR_UV  0xE800





// These arrays define the video window processing parameters for the 055 as
// the sync master. They are indexed by the video standard (NTSC, PAL, SECAM
// in that order).

WORD FULL_HEIGHT[VIDEOSTANDARD_MAX+1] = { 480, 576, 576 };
WORD HALF_HEIGHT[VIDEOSTANDARD_MAX+1] = { 240, 288, 288 };
WORD FULL_WIDTH[VIDEOSTANDARD_MAX+1]  = { 640, 768, 768 };
WORD HALF_WIDTH[VIDEOSTANDARD_MAX+1]  = { 320, 384, 384 };
WORD VTOTAL[VIDEOSTANDARD_MAX+1]      = { 525, 625, 625 };
WORD HTOTAL[VIDEOSTANDARD_MAX+1]      = { 780, 944, 944 };
WORD BLANK[VIDEOSTANDARD_MAX+1]       = { 140, 176, 176 };
WORD SKIP[VIDEOSTANDARD_MAX+1]        = {  14,  18,  18 };
WORD HSYNC_START[VIDEOSTANDARD_MAX+1] = { 659, 795, 795 };
WORD HSYNC_END[VIDEOSTANDARD_MAX+1]   = { 723, 859, 859 };
WORD ABLANK[VIDEOSTANDARD_MAX+1]      = { 640, 768, 768 };





Z055::Z055 (IndexedInOutPort *io, BOOL fastClock, BOOL codeBuf256K, BOOL stripBuf32K)
	{
	this->io = io;
	this->fastClock   = fastClock;
	this->codeBuf256K = codeBuf256K;
	this->stripBuf32K = stripBuf32K;
	defCmd0 = (BYTE) MKBF(H55IDX_FAST, fastClock);
	defCmd1 = (BYTE) MKBF(H55IDX_CBUF_SIZE, codeBuf256K);
	defCmd2 = (BYTE) MKBF(H55IDX_STRP_SIZE, stripBuf32K);
	}





BOOL Z055::IsPresent (void)
	{
	BYTE id;
	io->InByte (H55REG_CMD2, id);
	return XTBF(H55IDX_ID, id) == H55_IDENTIFIER;
	}





void Z055::Reset (void)
	{
	cmd1 = WRBF(cmd1, H55IDX_CLK_EN, HIGH);
	io->OutByte (H55REG_CMD1, (BYTE)cmd1);
	cmd0 = WRBF(cmd0, H55IDX_GRESET, LOW);
	io->OutByte (H55REG_CMD0, (BYTE)cmd0);
	Timer.WaitMicroSecs (1);   // 050 needs reset for at least four CLK_INs
	cmd0 = WRBF(cmd0, H55IDX_GRESET, HIGH);
	io->OutByte (H55REG_CMD0, (BYTE)cmd0);
	}





void Z055::StartActivity (void)
	{
	cmd1 = WRBF(cmd1, H55IDX_INT_EN, (stillMode ? LOW : HIGH));
	cmd1 = WRBF(cmd1, H55IDX_ACTIVE_N, LOW);
	io->OutByte (H55REG_CMD1, (BYTE)cmd1);
	}





void Z055::StopActivity (void)
	{
	// Disable interrupts.
	cmd1 = WRBF(cmd1, H55IDX_INT_EN, LOW);
	io->OutByte (H55REG_CMD1, (BYTE)cmd1);
	// Switch to compression mode to disable video bus drivers.
	cmd0 = WRBF(cmd0, H55IDX_EXP, LOW);
	io->OutByte (H55REG_CMD0, (BYTE)cmd0);
	}





void Z055::ReadStatus (void)
	{
	BYTE len0, len1;

	// Note that the read order has the 055 generate the next interrupt.
	// STATUS0 must be read first, LEN1 must be read last.
	io->InByte (H55REG_STATUS0, status);
	io->InByte (H55REG_FCNT, fieldCount);
	io->InByte (H55REG_LEN0, len0);
	io->InByte (H55REG_LEN1, len1);
	*((BYTE *)(&length))   = len0;
	*((BYTE *)(&length)+1) = len1;
	if (XTBF(H55IDX_FNV, status) != 0)
		length = 0;   // invalid field: set length to zero
	}





void Z055::SetPageNum (BYTE num)
	{
	cmd0 = WRBF(cmd0, H55IDX_PAGE, num);
	io->OutByte (H55REG_CMD0, (BYTE)cmd0);
	}





void Z055::SetBlocksInStrip (WORD blocks, BOOL lastStrip)
	{
	SetImageDimension (H55_BLOCKS_IN_STRIP | (lastStrip ? H55_LAST_STRIP : 0), blocks);
	}





	inline void Z055::SetImageDimension (WORD mask, WORD dimension)
		{
		WORD w = dimension;
		w &= H55_DIMENSION_MASK;
		w |= mask;
		io->OutWord (H55REG_IMAGE_SIZE, w);
		}





// Initialize for an operation. Return success.

BOOL Z055::InitOperation (BOOL compress, BOOL stillMode, VideoStandard vStd,
                          VideoFormat vFormat, VideoField fieldOrder,
                          BOOL filtering, WORD width, WORD height)
	{
	WORD activePages, activeWidth, activeHeight, activeHTotal, activeVTotal;
	WORD activeBlank, activeSkip, activeSyncStart, activeSyncEnd, activeMCUSize;


	this->stillMode = stillMode;
	cmd0 = defCmd0;
	cmd1 = defCmd1;
	cmd2 = defCmd2;

	// For full width, we need the fast 055 version.
	if (width > HALF_WIDTH[vStd]  &&  ! fastClock)
		return FALSE;

	// Set reset, be not active and disable coder clock.
	cmd0 = WRBF(cmd0, H55IDX_GRESET, LOW);
	io->OutByte (H55REG_CMD0, (BYTE)cmd0);
	cmd1 = WRBF(cmd1, H55IDX_ACTIVE_N, HIGH);
	cmd1 = WRBF(cmd1, H55IDX_CLK_EN, LOW);
	io->OutByte (H55REG_CMD1, (BYTE)cmd1);

	cmd0 = WRBF(cmd0, H55IDX_VID422, (vFormat == VFMT_YUV_422));
	cmd1 = WRBF(cmd1, H55IDX_VID_FORMAT, (vStd == VSTD_NTSC));
	if (width > HALF_WIDTH[vStd])
		{
		cmd1 = WRBF(cmd1, H55IDX_HOR_DEC, LOW);
		activeWidth = width;
		}
	else
		{
		cmd1 = WRBF(cmd1, H55IDX_HOR_DEC, HIGH);
		activeWidth = width * 2;
		}
	cmd2 = WRBF(cmd2, H55IDX_VID_FILT, filtering);
	if (fieldOrder != VFLD_SINGLE)
		height /= 2;

	if (compress)
		{
		// Compression.
		cmd0 = WRBF(cmd0, H55IDX_EXP, LOW);
		activePages = H55_N_BUFFERS;
		cmd0 = WRBF(cmd0, H55IDX_PAGE, H55_N_BUFFERS-1);   // select page 3
		cmd1 = WRBF(cmd1, H55IDX_VER_DEC, (fieldOrder != VFLD_SINGLE));
		}
	else
		{
		// Expansion.
		cmd0 = WRBF(cmd0, H55IDX_EXP, HIGH);
		activePages = 2;
		cmd0 = WRBF(cmd0, H55IDX_PAGE, 0);   // select page 0
		switch (fieldOrder)
			{
			case VFLD_EVEN:
				cmd1 = WRBF(cmd1, H55IDX_VER_DEC, LOW);
				cmd0 = WRBF(cmd0, H55IDX_FFI, HIGH);
				break;
			case VFLD_ODD:
				cmd1 = WRBF(cmd1, H55IDX_VER_DEC, LOW);
				cmd0 = WRBF(cmd0, H55IDX_FFI, LOW);
				break;
			case VFLD_SINGLE:
			default:
				cmd1 = WRBF(cmd1, H55IDX_VER_DEC, HIGH);
				break;
			}
		cmd1 = WRBF(cmd1, H55IDX_SNC_SRC, LOW);
		}

	activeMCUSize = (vFormat == VFMT_YUV_422) ? 16 : 8;
	cmd0 = WRBF(cmd0, H55IDX_STILL, stillMode);
	cmd1 = WRBF(cmd1, H55IDX_INT_EN, LOW);

	io->OutByte (H55REG_CMD0, (BYTE)cmd0);
	io->OutByte (H55REG_CMD1, (BYTE)cmd1);
	io->OutByte (H55REG_CMD2, (BYTE)cmd2);

	activeHeight = height;
	activeVTotal = VTOTAL[vStd];
	activeHTotal = HTOTAL[vStd];
	activeBlank = BLANK[vStd];
	activeSkip = SKIP[vStd];
	activeSyncStart = HSYNC_START[vStd];
	activeSyncEnd = HSYNC_END[vStd];

	WORD hCenter = FULL_WIDTH[vStd] / 2;
	WORD hStart = hCenter - (activeWidth / 2);
	WORD hEnd = hCenter + (activeWidth / 2);

	SetImageDimension (H55_HIMG_STRT, hStart);
	SetImageDimension (H55_HIMG_END, (hEnd - 1));
	SetImageDimension (H55_HIMG_TOTAL, activeHTotal);

	WORD vCenter = (HALF_HEIGHT[vStd] / 2) + activeSkip;
	WORD vStart = vCenter - (activeHeight / 2);
	WORD vEnd = vCenter + (activeHeight / 2);

	SetImageDimension (H55_VIMG_STRT, vStart);
	SetImageDimension (H55_VIMG_END, vEnd - 1);
	SetImageDimension (H55_VIMG_TOTAL, activeVTotal);

	SetImageDimension (H55_HSYNC_STRT, activeSyncStart);
	SetImageDimension (H55_HSYNC_END, activeSyncEnd);

	SetImageDimension (H55_MCUS_IN_LINE, ((hEnd - hStart) / activeMCUSize) - 1);
	SetImageDimension (H55_ABLANK, ABLANK[vStd]);

	cmd1 = WRBF(cmd1, H55IDX_CLK_EN, HIGH);
	io->OutByte (H55REG_CMD1, (BYTE)cmd1);

	// Delay (at least) 5000 coder clocks to allow PLL to stabilize.
	Timer.WaitMicroSecs (250);

	cmd0 = WRBF(cmd0, H55IDX_GRESET, HIGH);
	io->OutByte (H55REG_CMD0, (BYTE)cmd0);

	// Note that background colour cannot be changed during reset.
	SetImageDimension (H55_BACK_COLOUR_Y,  0);   // black background
	SetImageDimension (H55_BACK_COLOUR_UV, 128);

	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\jpeg\specific\Jcoram55.h ===
// FILE:      library\hardware\jpeg\generic\jcoram55.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1996 Viona Development.  All Rights Reserved.
// CREATED:   02.02.96
//
// PURPOSE: The virtualized JPEG core implemented as combination of S5933/055/050 chips.
//
// HISTORY:

#ifndef JPEGCORE_AMCC55_H
#define JPEGCORE_AMCC55_H

#include "library\hardware\jpeg\generic\jcore.h"
#include "library\lowlevel\hardwrio.h"
#include "library\lowlevel\memmpdio.h"
#include "library\lowlevel\dmabuffr.h"
#include "library\lowlevel\dmachanl.h"
#include "library\lowlevel\intrctrl.h"
#include "library\hardware\jpeg\specific\z055.h"
#include "library\common\krnlsync.h"
#include "library\common\krnllog.h"

#ifndef ONLY_EXTERNAL_VISIBLE



#define N_DLL_BUFFERS  4   // number of buffers possible in the DLL pipeline, must be power of 2



class VirtualJPEGUnit055;
class JPEGEndIntHandler;



class JPEGManager055 : public JPEGManager
	{
	friend class VirtualJPEGUnit055;

	public:
		JPEGManager055 (Z055 *z055, VirtualUnit *blankUnit, InterruptServer *jpegIRQ,
		                DataInOutPort *codePort, DataInOutPort *stripPort,
		                DMAChannel *readChannel, DMAChannel *writeChannel,
							 KernelLogger *log = NULL);
		virtual ~JPEGManager055 (void);

		virtual VirtualUnit *CreateVirtual (void);

		virtual void Start (void);
		virtual void Stop  (void);
		virtual void Reset (void);

		void JPEGEndInterrupt (void);

	protected:
		VirtualJPEGUnit055 *GetCurrent (void) {return (VirtualJPEGUnit055 *)(JPEGManager::GetCurrent());}

		Error InitOperation (void);
		Error StartIRQs (void);
		Error StopIRQs  (void);

		Error ExpandIntoOverlayFrame (FPTR frame, DWORD size);
		Error ExpandStart (DWORD size);
		void ExpandStop (void);

		Error ReadCompressedField (FPTR field, BYTE pageNum, DWORD size);
		Error CompressStart (BYTE pageNum, DWORD size);
		Error CompressStop (DWORD size);

		KernelLogger *log;
		Z055 *z055;
		VirtualUnit *blankUnit;
		InterruptServer *jpegIRQ;
		DataInOutPort *codePort, *stripPort;
		DMAChannel *readChannel, *writeChannel;
		InterruptServer *jpegEndIntServer;
		JPEGEndIntHandler *jpegEndIntHandler;

		ContinuousDMABuffer *dmaBuffer;
		DWORD dmaSize;
		FPTR dmaDataPtr;
		class JPEGTransferRequest *dmaRequest;

		BOOL pageAvailable[H55_N_BUFFERS];
		int currentPage;

		BOOL handlerEnabled;
	};



class VirtualJPEGUnit055 : public VirtualJPEGUnit
	{
	friend class JPEGManager055;

	public:
		VirtualJPEGUnit055 (JPEGManager055 *physical, VirtualJCoder *coder);
		virtual ~VirtualJPEGUnit055 (void);

		virtual Error Configure (TAG __far *tags);

		virtual Error PrepareBuffer (FPTR buffer, DWORD size, FPTR __far &info);
		virtual Error UnprepareBuffer (FPTR info);

#if VIONA_VERSION
		virtual Error ExpandToRGB (FPTR src, DWORD size, FPTR dst, WORD dstWidth, WORD dstHeight, GrabFormat bitFormat);
		virtual BOOL IsValidExpansionScaling (WORD srcWidth, WORD srcHeight, WORD dstWidth, WORD dstHeight, GrabFormat bitFormat);
		virtual Error CompressFromRGB (FPTR src, FPTR dst, DWORD maxSize, DWORD __far &size, BOOL bits32);
#else
		virtual Error ExpandToRGB (FPTR src, DWORD size, FPTR dst);
		virtual Error CompressFromRGB (FPTR src, FPTR dst, DWORD maxSize, DWORD __far &size);
#endif

		// These are allowed only after locking and activating the unit.
		virtual Error InitCapture (JPEGCaptureHook __far *hook);
		virtual Error FinishCapture (void);
		virtual Error AddVideoBuffer (FPTR info, FPTR userData, DWORD size);
		virtual Error Start (void);

		virtual Error AllocateVideoBuffer (DWORD size, FPTR __far &info, FPTR __far &data);
		virtual Error FreeVideoBuffer (FPTR info);
		virtual Error InitPlayback (JPEGPlaybackHook __far *hook);
		virtual Error FinishPlayback (void);
		virtual Error PlayBuffer (FPTR info, DWORD size);

		void DMATransferDone (void);

	protected:
		virtual Error Preempt (VirtualUnit *previous);

		Error CompressField (FPTR src, WORD numberOfBlocks, FPTR dst, DWORD maxSize, DWORD __far &size);

		void JPEGEndInterrupt (void);

		JPEGManager055 *manager;

		IRQMutex	irqMutex;
		JPEGCaptureHookHandle capHook;
		JPEGPlaybackHookHandle playHook;
		JPEGMessageHookHandle preemptHook;
		volatile int nextBuffer;   // already processed buffer
		int lastBuffer;   // entry for providing new buffer
		volatile int nBuffers;

		enum CaptureState { CAP_NONE, CAP_SINGLE_FIRST_BAD, CAP_SINGLE_FIRST, CAP_FIRST, CAP_FIRST_BAD, CAP_SECOND };
		CaptureState capState;
		JPEGCaptureMsg capMsg;
		DWORD fieldNum;
		WORD lastFieldCnt;
		JPEGCaptureMsg buffers[N_DLL_BUFFERS];
		void PassUpBuffer (void);

		volatile BOOL irqSecondField;   // only for playback
		volatile BOOL transferRunning;

		DWORD nextFrameTime;
		DWORD milliSecPerFrame;
		BOOL singleFrame;

		VideoStandard vStandard;
		VideoFormat vFormat;
		VideoField fieldOrder;
		BOOL thumbnail;
		BOOL filtersOn;

		DWORD totalCodeVolume;
	};



#endif // ONLY_EXTERNAL_VISIBLE



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\jpeg\specific\Jcor22.cpp ===
// FILE:      library\hardware\jpeg\generic\jcor22.cpp
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1996 Viona Development.  All Rights Reserved.
// CREATED:   15.01.96
//
// PURPOSE: The virtualized JPEG core implemented as combination of 022/016 chips.
//
// HISTORY:

#include "jcor22.h"

#include "library\common\prelude.h"
#include "library\lowlevel\memmpdio.h"
#include "library\lowlevel\timer.h"
#include "library\general\parse.h"
#include "library\lowlevel\kernlmem.h"
#include "library\hardware\pcibrdge\specific\i22\i22regs.h"
#include "library\hardware\pcibrdge\specific\i22\fragtab.h"
#include "library\hardware\videodma\specific\i20pip.h"
#include "library\hardware\jpeg\specific\z016.h"

#if NT_KERNEL
#include "msgfile.h"
#endif

#define NO_MORE_GLOBAL_ALLOC_IN_LOW_LEVEL_DRIVERS	1

#if NO_MORE_GLOBAL_ALLOC_IN_LOW_LEVEL_DRIVERS
#define KMEM(x)	(((KernelMemory *)(x))->KernelSpace())
#else
#define KMEM(x)	x
#endif

#include "library\support\gfxdebug\gfxdebug.h"
#include "library\common\vddebug.h"

//#include <mmsystem.h>



#define N_DLL_BUFFERS  4   // number of buffers possible in the DLL pipeline, must be power of 2

#define N_FRAGTABLES  4   // Fragment tables per STATCOM table

#define MAX_FIELDSIZE  200000



// Compile switches

#define PIP_EXPAND  1   // use PIP for still expansion ?

#define COMPRESS_POLL_EIGHTH_LINE  0   // poll every eighth line completely for still compress ?

#define EXPAND_ONE_FRAGMENT  1   // use one fragment for decompression (I22 chip bug) ?

#define PLAYBACK_ONE_FRAGMENT  1   // enable one fragment for playback (I22 chip bug) ?

#define DO_TIMING  1   // print time needed for operation ?

#define DUMMY_CAPBUFFER  1

#define STARTCAP_DROPFRAMES  0L

#define NT_DEBUGOUTPUT  (NT_KERNEL && 1)

#define DEEP_PIPELINE  0   // make pipeline deeper than N_DLL_BUFFERS ?
#if DEEP_PIPELINE
#undef N_DLL_BUFFERS
#define N_DLL_BUFFERS  8
#endif

#if VIONA_VERSION
#define DO_THUMBNAIL  0

#define SYNCSEL_DECODER  0
#define SYNCSEL_NONE     1
#define SYNCSEL_016      2
#define SYNCSEL_I22      3
#endif





static BOOL InPlayInterrupt;

#if PLAYBACK_ONE_FRAGMENT
static PoolContDMABuffer *PlayBuffers[N_DLL_BUFFERS];
static FragmentTableClass *PlayBufferFrags[N_DLL_BUFFERS];
static FPTR PlayBufferPtr[N_DLL_BUFFERS];
static DWORD PlaySize;
#endif





// This is the bit field that represents the video formats we support.

static DWORD VideoFormatBitField = (1 << VFMT_YUV_411) | (1 << VFMT_YUV_422);










//************************************************************************
// A class that serves as the info structure for prepared video buffers.

class PrepareInfo
	{
	protected:
		FPTR userSpace, kernelSpace;

	public:
		KernelMemory *kernelMem;
		FragmentTableClass *frag;

		PrepareInfo (void) { kernelMem = NULL; frag = NULL; userSpace = kernelSpace = NULL; }
		~PrepareInfo (void) { FreeMemory (); }

		Error PrepareMemory (FPTR buffer, DWORD size);
		Error AllocMemory (DWORD size, FPTR __far &data);
		Error FreeMemory (void);

		FPTR KernelSpace(void) {return kernelSpace;}
	};


Error PrepareInfo::PrepareMemory (FPTR buffer, DWORD size)
	{
	kernelMem = new KernelMemory;
	frag = new FragmentTableClass;
	if (kernelMem == NULL  ||  frag == NULL)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	GNREASSERT( kernelMem->MapMemory (buffer, size, kernelSpace) );
	GNREASSERT( frag->CreateFragmentBuffer (kernelSpace, size) );
	GNRAISE_OK;
	}


Error PrepareInfo::AllocMemory (DWORD size, FPTR __far &data)
	{
	FreeMemory ();
	kernelMem = new KernelMemory;
	frag = new FragmentTableClass;
	if (kernelMem == NULL  ||  frag == NULL)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	GNREASSERT( kernelMem->AllocMemory (size, userSpace, kernelSpace) );
	data = userSpace;
	GNREASSERT( frag->CreateFragmentBuffer (kernelSpace, size) );
	GNRAISE_OK;
	}


Error PrepareInfo::FreeMemory (void)
	{
	delete frag;
	frag = NULL;
	delete kernelMem;
	kernelMem = NULL;
	userSpace = kernelSpace = NULL;
	GNRAISE_OK;
	}





//************************************************************************
// The interrupt handler for JPEG code interrupt.

class JPEGCodeIntHandler : public InterruptHandler
	{
	private:
		JPEGManager022 *jpegManager;

		void Interrupt (void) {jpegManager->JPEGCodeInterrupt();}

	public:
		JPEGCodeIntHandler (JPEGManager022 *jpegManager)
			{
			this->jpegManager = jpegManager;
			}
	};










//************************************************************************
// The JPEG core manager, i.e. the PhysicalUnit.
//************************************************************************


JPEGManager022::JPEGManager022 (MemoryMappedIO *io,
                                InterruptServer *jpegCodeIntServer,
                                Profile *profile,
                                Z016Class *z016,
                                BitOutputPort *pxoe016Bit,
                                BitOutputPort *resetJPEGBit,
                                BitOutputPort *clken050Bit,
#if VIONA_VERSION
                                ByteOutputPort *syncSelection,
                                BitOutputPort *decoderSyncEnable,
                                BitOutputPort *frontEndEnable,
                                BitOutputPort *videoBusDecode,
                                VirtualUnit *blankUnit,
                                BOOL fixPlaybackLongBursts,
                                KernelLogger *log,
                                BOOL ccirMode,
                                AllowedJPEGVStandard allowedStandard)
#else
                                BitOutputPort *syncMUX,
                                BOOL fixPlaybackLongBursts)
#endif
	{
	Error err;
	int i;


	this->io = io;
	this->jpegCodeIntServer = jpegCodeIntServer;
	this->profile = profile;
	this->z016 = z016;
	this->pxoe016Bit  = pxoe016Bit;
	this->resetJPEGBit = resetJPEGBit;
	this->clken050Bit = clken050Bit;
#if VIONA_VERSION
	this->syncSelection = syncSelection;
	this->decoderSyncEnable = decoderSyncEnable;
	this->frontEndEnable = frontEndEnable;
	this->videoBusDecode = videoBusDecode;
	this->blankUnit = blankUnit;
	this->log = log;
	this->ccirMode = ccirMode;
	this->allowedStandard = allowedStandard;
#else
	this->syncMUX = syncMUX;
#endif

	this->fixPlaybackLongBursts = fixPlaybackLongBursts;

	jpegCodeIntHandler = new JPEGCodeIntHandler (this);
	handlerEnabled = FALSE;

	jpegCoreRunning = FALSE;

	// Read code thresholds.
#if VIONA_VERSION
	profile->Read (__TEXT("Q22DRV"), __TEXT("PlaybackCodeThreshold"), playbackCodeThreshold, 10,  20);
	profile->Read (__TEXT("Q22DRV"), __TEXT("CaptureCodeThreshold"),  captureCodeThreshold,  10,  80);
	profile->Read (__TEXT("Q22DRV"), __TEXT("ExpandCodeThreshold"),   expandCodeThreshold,   10, 120);
	profile->Read (__TEXT("Q22DRV"), __TEXT("CompressCodeThreshold"), compressCodeThreshold, 10,  80);
#else
	profile->Read (__TEXT("H22DRV"), __TEXT("PlaybackCodeThreshold"), playbackCodeThreshold, 10,  20);
	profile->Read (__TEXT("H22DRV"), __TEXT("CaptureCodeThreshold"),  captureCodeThreshold,  10,  80);
	profile->Read (__TEXT("H22DRV"), __TEXT("ExpandCodeThreshold"),   expandCodeThreshold,   10, 120);
	profile->Read (__TEXT("H22DRV"), __TEXT("CompressCodeThreshold"), compressCodeThreshold, 10,  80);
#endif

#if PLAYBACK_ONE_FRAGMENT
	for (i = 0;  i < N_DLL_BUFFERS;  i++)
		{
		PlayBuffers[i] = NULL;
		PlayBufferFrags[i] = NULL;
		}
#if NT_KERNEL
	err = profile->Read (__TEXT("Q22DRV"), __TEXT("PlaybackLongBurstSize"), i, MAX_FIELDSIZE);
	PlaySize = i;
#else
	err = profile->Read (__TEXT("Q22DRV"), __TEXT("PlaybackLongBurstSize"), PlaySize, (int)10, (DWORD)MAX_FIELDSIZE);
#endif
	if (IS_ERROR(err))
		{
#if NT_DEBUGOUTPUT
		DbgPrint("Registry read err %08lx\n", err);
#endif
		PlaySize = MAX_FIELDSIZE;
		}
#endif

	Reset ();
	pxoe016Bit->OutBit (LOW);   // disable PXOUT bus
	io->ClearBit (I22REG_SYNCMSTR);
	syncSelection->OutByte (SYNCSEL_DECODER);
	decoderSyncEnable->OutBit (HIGH);
	frontEndEnable->OutBit (HIGH);
	videoBusDecode->OutBit (LOW);
	}





JPEGManager022::~JPEGManager022 (void)
	{
	delete jpegCodeIntHandler;
	jpegCodeIntHandler = NULL;

#if PLAYBACK_ONE_FRAGMENT
	for (int i = 0;  i < N_DLL_BUFFERS;  i++)
		{
		delete PlayBufferFrags[i];
		delete PlayBuffers[i];
		}
#endif
	}





VirtualUnit *JPEGManager022::CreateVirtual (void)
	{
	return NULL;   // NOT USED YET
	}





// JPEG code interrupt.

void JPEGManager022::JPEGCodeInterrupt (void)
	{
	GetCurrent()->JPEGCodeInterrupt();
	}





// Start or stop the JPEG core operation.

void JPEGManager022::Start (void)
	{
	VirtualJPEGUnit022 *jpeg = GetCurrent ();


	if (! jpeg->stillExpansion)
		io->SetBit (I22REG_P_RESET);   // release JPEG process reset

	z016->Start();

	if (jpeg->compress)
		jpeg->coder->Start ();

	io->SetBit (I22REG_COD_TRNS_EN);

	if (! jpeg->stillExpansion)
		io->SetBit (I22REG_ACTIVE);

	// Don't start the 050. The 050 will be started by the I22.

	jpegCoreRunning = TRUE;
	}



void JPEGManager022::Stop (void)
	{
	io->ClearBit (I22REG_P_RESET);   // reset JPEG process
	z016->Stop ();
	pxoe016Bit->OutBit (LOW);   // disable PXOUT bus
#if VIONA_VERSION
	// Switch to capture so that video input can reach the I22.
	if (! GetCurrent()->stillMode)
		syncSelection->OutByte (SYNCSEL_DECODER);
	decoderSyncEnable->OutBit (HIGH);
	frontEndEnable->OutBit (HIGH);
	videoBusDecode->OutBit (LOW);
#else
	syncMUX->OutBit (0);
#endif
	io->ClearBit (I22REG_ACTIVE);
	io->ClearBit (I22REG_COD_TRNS_EN);

	io->ClearBit (I22REG_SYNCMSTR);

	jpegCoreRunning = FALSE;
	}





void JPEGManager022::Reset (void)
	{
	// Reset the JPEG core (050 & 016).
	clken050Bit->OutBit (LOW);
	clken050Bit->OutBit (HIGH);   // enable 050 clock, otherwise no reset possible
	Timer.WaitMicroSecs (2500);
	resetJPEGBit->OutBit (HIGH);
	Timer.WaitMicroSecs (10);   // 050 needs reset for at least four CLK_INs
	resetJPEGBit->OutBit (LOW);
	}





// Note that "statCom" parameter is the physical address of the STATCOM table.

Error JPEGManager022::InitOperation (DWORD statCom)
	{
	VirtualJPEGUnit022 *jpeg = GetCurrent ();
	Z016_CONFIG *c16;
	DWORD reg;
	int oddEven, codeThreshold;
	Error err;
	int coreTries;


	// Configure the hardware due to compression or changes.
	if (jpeg->changed  ||  jpeg->compress)
		{
//GDP("Programming JPEG core");

		jpeg->CalcVideoParameters ();

		
		// Stop all other JPEG operations.
		Stop ();


		err = GNR_OK;
		coreTries = 5;

		do {
			Reset ();

			// Configure the Z016.
GDP("op width is %ld", (long)jpeg->opWidth);
			c16 = new Z016_CONFIG;
			if (c16 == NULL)
				GNRAISE(GNR_NOT_ENOUGH_MEMORY);
			c16->compress    = jpeg->compress;
			c16->stillMode   = FALSE; //jpeg->stillMode;
			c16->thumbnail   = FALSE;
			c16->colFiltersOn= FALSE; //jpeg->filtersOn;
			c16->horFilterOn = TRUE; //jpeg->filtersOn;
			c16->vDecimation = FALSE;
			c16->coderFormat = jpeg->vFormat;
			c16->pxoutFormat = VFMT_YUV_422;

			c16->hDecimation = jpeg->horDecimation;
			c16->width  = jpeg->opWidth;
			c16->height = jpeg->opHeight;
			c16->left   = jpeg->nax;
			c16->top    = jpeg->nay - 1;   // note that I22 starts one line later than 016
//GDP("016 %d,%d size %d,%d", c16->left, c16->top, c16->width, c16->height);

			if (jpeg->compress)
				{
				// Compression.
				if (jpeg->stillMode)
					{
					c16->vbusFormat = VFMT_RGB_444;   // still compression
					c16->ccirLevels = jpeg->ccirLevels;
					}
				else
					c16->vbusFormat = VFMT_YUV_422;   // motion compression
				// c16->pxoutFormat does not matter since PXOUT bus disabled.
				pxoe016Bit->OutBit (LOW);   // disable PXOUT bus
				}
			else
				{
				// Expansion. c16->vbusFormat does not matter.
				if (jpeg->jpgMode == I22_STILL_DECOMPRESS)
					{
					c16->pxoutFormat = VFMT_RGB_444;
					c16->thumbnail = jpeg->thumbnail;   // still expansion
					jpeg->nax += jpeg->horDecimation ? 24 : 20;
					}
				pxoe016Bit->OutBit (HIGH);   // enable PXOUT bus
				}

//GDP("016 %d,%d size %d,%d", c16->left, c16->top, c16->width, c16->height);
			// c16.doubleClock, c16.syen are always zero.
			if (! z016->Configure (c16) )
				{
#if NT_DEBUGOUTPUT
				DbgPrint ("InitOp 016 fails\n");
#endif
				err = GNR_RANGE_VIOLATION;
				}
			delete c16;


			if (! IS_ERROR(err))
				{
#if VIONA_VERSION
				BOOL playback = (jpeg->jpgMode == I22_MOTION_DECOMPRESS  &&  !jpeg->stillExpansion);
				if (! jpeg->stillMode)
					syncSelection->OutByte (playback ? SYNCSEL_016 : SYNCSEL_DECODER);
				decoderSyncEnable->OutBit (jpeg->jpgMode == I22_MOTION_COMPRESS);
				frontEndEnable->OutBit (jpeg->jpgMode == I22_MOTION_COMPRESS  ||  playback);
				videoBusDecode->OutBit (playback);
#else
				syncMUX->OutBit (jpeg->jpgMode == I22_MOTION_DECOMPRESS);
#endif


				// Configure the Z050. To switch in a (possibly new) clock, the 050 needs
				// at least 5000 clocks to stabilize PLLs.
				clken050Bit->OutBit (LOW);  // disable 050 clock
				Timer.WaitMicroSecs (20);
				clken050Bit->OutBit (HIGH);  // enable 050 clock
				Timer.WaitMicroSecs (300);
				err = jpeg->coder->InitOperation ();
				if (IS_ERROR(err))
					{
#if NT_DEBUGOUTPUT
					DbgPrint ("InitOp 050 fails %08lx\n", err);
#endif
					GDP("050 time out");
					}
				}
			} while (IS_ERROR(err)  &&  --coreTries > 0);
		if (IS_ERROR(err))
			return err;


		// Configure the I22.
		io->ClearBit (I22REG_P_RESET);   // reset JPEG process
		io->SetBit (I20REG_CODFLUSH);   // flush CFIFO

		oddEven = HIGH;
		switch (jpeg->jpgMode)
			{
			case I22_MOTION_COMPRESS:
				if (ccirMode)
					{
					if (jpeg->vStandard == VSTD_NTSC)
						oddEven = (jpeg->fieldOrder != VFLD_EVEN);
					else
						oddEven = (jpeg->fieldOrder != VFLD_EVEN);
					}
				else
					{
					if (jpeg->vStandard == VSTD_NTSC)
						oddEven = (jpeg->fieldOrder != VFLD_EVEN);
					else
						oddEven = (jpeg->fieldOrder != VFLD_ODD);
					}
				break;
			case I22_STILL_COMPRESS:
				oddEven = HIGH;
				break;
			case I22_STILL_DECOMPRESS:
				oddEven = HIGH;
				break;
			case I22_MOTION_DECOMPRESS:
				switch (jpeg->fieldOrder)
					{
					case VFLD_SINGLE:  oddEven = !jpeg->stillExpansion;  break;
					case VFLD_ODD:     oddEven = LOW;   break;
					case VFLD_EVEN:    oddEven = HIGH;  break;
					}
				break;
			}

		// Set code threshold depending on compression/expansion.
		if (jpeg->compress)
			codeThreshold = jpeg->stillMode ? compressCodeThreshold : captureCodeThreshold;
		else
			codeThreshold = jpeg->stillExpansion ? expandCodeThreshold : playbackCodeThreshold;
		io->WriteBits (I22REG_COD_THRESHOLD, codeThreshold);
//GDP("codeThreshold %d", codeThreshold);

		reg =	MKBF (I22IDX_JPG,           TRUE   ) |
				MKBF (I22IDX_JPGMODE,       jpeg->jpgMode) |
#if COMPRESS_POLL_EIGHTH_LINE
				MKBF (I22IDX_RTBSY_FB,      jpeg->stillMode) |
#else
				MKBF (I22IDX_RTBSY_FB,      jpeg->stillExpansion) |
#endif
				MKBF (I22IDX_GO_ENABLE,     LOW    ) |   // will be set after 050 is inited
				MKBF (I22IDX_SYNCMSTR,      jpeg->syncMaster) |
				MKBF (I22IDX_FLD_PER_BUFF,  (jpeg->fieldOrder == VFLD_SINGLE)) |
#if PIP_EXPAND
				MKBF (I22IDX_VFIFO_FB,      jpeg->stillExpansion) |   // only for "still like motion expansion"
#else
				MKBF (I22IDX_VFIFO_FB,      LOW    ) |
#endif
				MKBF (I22IDX_CFIFO_FB,      LOW    ) |
				MKBF (I22IDX_STILL_LENDIAN, TRUE   );
		io->WriteDWord (I22REG_JMODE, reg);
//GDP("JMODE %8lx", reg);

		reg =	MKBF (I22IDX_VSYNCSIZE, jpeg->vSyncSize) |
				MKBF (I22IDX_FRMTOT,    jpeg->frameTotal);
		io->WriteDWord (I22REG_VERTSYNC, reg);
//GDP("VERTSYNC %8lx", reg);

		reg =	MKBF (I22IDX_HSYNCSTART, jpeg->hSyncStart) |
				MKBF (I22IDX_LINETOT,    jpeg->lineTotal);
		io->WriteDWord (I22REG_HORZSYNC, reg);
//GDP("HORZSYNC %8lx", reg);

		reg =	MKBF (I22IDX_NAX, jpeg->nax) |
				MKBF (I22IDX_PAX, jpeg->pax);
		io->WriteDWord (I22REG_HORZACTIVE, reg);
//GDP("HORZACTIVE %8lx", reg);

		reg =	MKBF (I22IDX_NAY, jpeg->nay) |
				MKBF (I22IDX_PAY, jpeg->pay);
		io->WriteDWord (I22REG_VERTACTIVE, reg);
//GDP("VERTACTIVE %8lx", reg);

		reg = MKBF (I22IDX_ODD_EVEN, oddEven);
		io->WriteDWord (I22REG_FIELDPARAS, reg);
//GDP("ODDEVEN %8lx", reg);

		io->WriteDWord (I22REG_I_STAT_COM, statCom);

		io->SetBit (I22REG_GO_ENABLE);   // to enable JPEG GO cycle
		io->ClearBit (I20REG_CODFLUSH);   // ensure that CFIFO is not constantly flushed
		}


	jpeg->changed = FALSE;

	GNRAISE_OK;
	}





Error JPEGManager022::StartIRQs (void)
	{
	if (! handlerEnabled)
		{
		GNREASSERT( jpegCodeIntServer->InstallHandler (jpegCodeIntHandler) );
		GNREASSERT( jpegCodeIntHandler->Enable () );
		handlerEnabled = TRUE;
		}
	GNRAISE_OK;
	}



Error JPEGManager022::StopIRQs (void)
	{
	if (handlerEnabled)
		{
		handlerEnabled = FALSE;
		GNREASSERT( jpegCodeIntHandler->Disable () );
		}
	return jpegCodeIntServer->RemoveHandler (jpegCodeIntHandler);
	}





	static void WriteStillLinePolled (FPTR stillReg, FPTR src, WORD width, WORD totalWidth)
		{
#if NT_KERNEL || VXD_VERSION
		__asm {
				push	esi

				mov	ebx, stillReg
				mov	esi, src
				mov	cx, width
				sub	cx, 1
				jz		lastPixel
		loop1:
				// Write a pixel to the I22.
				mov	eax, [esi]
				mov	[ebx], eax
				add	esi, 3
		loop2:
				// Poll the pixel.
				mov	eax, [ebx]
				or		eax, eax
				js		loop2

				sub	cx, 1
				jnz	loop1

		lastPixel:
				// The last pixel must be read as 3 bytes, not as four (otherwise
				// selector protection can cause GPF).
				// Write the last pixel to the I22.
				xor	eax, eax
				mov	al, [esi+2]
				shl	eax, 16
				mov	ax, [esi]
				mov	[ebx], eax
		loop3:
				// Poll the pixel.
				mov	edx, [ebx]
				or		edx, edx
				js		loop3
				}
#if VIONA_VERSION
		__asm {
				// Repeat the last pixel until width is a multiple of 16.
				mov	dx, totalWidth
				mov	cx, 16
				and	dx, 15
				jz		noFill
				sub	cx, dx
		loop4:
				mov	[ebx], eax
		loop5:
				// Poll the pixel.
				mov	edx, [ebx]
				or		edx, edx
				js		loop5

				sub	cx, 1
				jnz	loop4
		noFill:
				}
#endif
		__asm {
				pop	esi
				}
#else
		__asm {
				push	ds
				_emit	0x66
				push	si   // push esi

				les	bx, stillReg
				_emit	0x66
				xor	si, si   // xor esi,esi
				lds	si, src
				mov	cx, width
				sub	cx, 1
				jz		lastPixel
		loop1:
				// Write a pixel to the I22.
				_emit	0x67
				_emit	0x66
				_emit	0x8b
				_emit	0x06   // mov eax, [esi]
				_emit	0x66
				mov	es:[bx], ax   // mov es:[bx],eax
				_emit	0x66
				add	si, 3   // add esi,3
		loop2:
				// Poll the pixel.
				_emit	0x66
				mov	ax, es:[bx]   // mov eax,es:[bx]
				_emit	0x66
				or		ax, ax   // or eax,eax
				js		loop2

				sub	cx, 1
				jnz	loop1

		lastPixel:
				// The last pixel must be read as 3 bytes, not as four (otherwise
				// selector protection can cause GPF).
				// Write the last pixel to the I22.
				_emit	0x66
				xor	ax, ax   // xor eax,eax
				_emit	0x67
				_emit	0x8A
				_emit	0x46
				_emit	0x02   // mov al,[esi+2]
				_emit	0x66
				shl	ax, 16   // shl eax,16
				_emit	0x67
				_emit	0x8B
				_emit	0x06   // mov ax, [esi]
				_emit	0x66
				mov	es:[bx], ax   // mov es:[bx],eax
		loop3:
				// Poll the pixel.
				_emit	0x66
				mov	dx, es:[bx]   // mov edx,es:[bx]
				_emit	0x66
				or		dx, dx   // or edx,edx
				js		loop3
				}
#if VIONA_VERSION
		__asm {
				// Repeat the last pixel until width is a multiple of 16.
				mov	dx, totalWidth
				mov	cx, 16
				and	dx, 15
				jz		noFill
				sub	cx, dx
		loop4:
				_emit	0x66
				mov	es:[bx], ax   // mov es:[bx],eax
		loop5:
				// Poll the pixel.
				_emit	0x66
				mov	dx, es:[bx]   // mov edx,es:[bx]
				_emit	0x66
				or		dx, dx   // or edx,edx
				js		loop5

				sub	cx, 1
				jnz	loop4
		noFill:
				}
#endif
		__asm {
				_emit	0x66
				pop	si   // pop esi
				pop	ds
				}
#endif
		}


	static void WriteStillLineNonPolled (FPTR stillReg, FPTR src, WORD width, WORD totalWidth)
		{
#if NT_KERNEL || VXD_VERSION
		__asm {
				push	esi

				mov	ebx, stillReg
				mov	esi, src
				mov	cx, width
				sub	cx, 1
				jz		lastPixel
		loop1:
				// Write a pixel to the I22.
				mov	eax, [esi]
				add	esi, 3
				sub	cx, 1
				mov	[ebx], eax   // (does not change flags)
				jnz	loop1

		lastPixel:
				// The last pixel must be read as 3 bytes, not as four (otherwise
				// selector protection can cause GPF).
				// Write the last pixel to the I22.
				xor	eax, eax
				mov	al, [esi+2]
				shl	eax, 16
				mov	ax, [esi]
				mov	[ebx], eax
				}
#if VIONA_VERSION
		__asm {
				// Repeat the last pixel until width is a multiple of 16.
				mov	dx, totalWidth
				mov	cx, 16
				and	dx, 15
				jz		noFill
				sub	cx, dx
		loop2:
				sub	cx, 1
				mov	[ebx], eax   // (does not change flags)
				jnz	loop2
		noFill:
				}
#endif
		__asm {
				pop	esi
				}
#else
		__asm {
				push	ds
				_emit	0x66
				push	si   // push esi

				les	bx, stillReg
				_emit	0x66
				xor	si, si   // xor esi,esi
				lds	si, src
				mov	cx, width
				sub	cx, 1
				jz		lastPixel
		loop1:
				// Write a pixel to the I22.
				_emit	0x67
				_emit	0x66
				_emit	0x8b
				_emit	0x06   // mov eax, [esi]
				_emit	0x66
				add	si, 3   // add esi,3
				sub	cx, 1
				_emit	0x66
				mov	es:[bx], ax   // mov es:[bx],eax (does not change flags)
				jnz	loop1

		lastPixel:
				// The last pixel must be read as 3 bytes, not as four (otherwise
				// selector protection can cause GPF).
				// Write the last pixel to the I22.
				_emit	0x66
				xor	ax, ax   // xor eax,eax
				_emit	0x67
				_emit	0x8A
				_emit	0x46
				_emit	0x02   // mov al,[esi+2]
				_emit	0x66
				shl	ax, 16   // shl eax,16
				_emit	0x67
				_emit	0x8B
				_emit	0x06   // mov ax, [esi]
				_emit	0x66
				mov	es:[bx], ax   // mov es:[bx],eax
				}
#if VIONA_VERSION
		__asm {
				// Repeat the last pixel until width is a multiple of 16.
				mov	dx, totalWidth
				mov	cx, 16
				and	dx, 15
				jz		noFill
				sub	cx, dx
		loop2:
				sub	cx, 1
				_emit	0x66
				mov	es:[bx], ax   // mov es:[bx],eax (does not change flags)
				jnz	loop2
		noFill:
				}
#endif
		__asm {
				_emit	0x66
				pop	si   // pop esi
				pop	ds
				}
#endif
		}





Error JPEGManager022::WriteStillPixels24 (FPTR src, WORD width, WORD height,
                                          VideoField fieldOrder)
	{
	VirtualJPEGUnit022 *jpeg = GetCurrent ();
	DWORD timeout;
	DWORD reg, old, stride;
	BYTE __huge *data;
	WORD fields, field, lines, line, y;
	BOOL busy;
	Error err;
	volatile DWORD __far * stillReg;


	// Configure WaitState parameter to 4.
	io->ReadDWord (I20REG_SYSCTRL, old);
	reg = WRBF (old, I20IDX_WAITSTATE, 4);
	io->WriteDWord (I20REG_SYSCTRL, reg);

	// Note: We are working with little endian here, thus assuming fixed
	// organization of the still transfer register.

	// Note that bitmaps have the lines reversed.
	if (fieldOrder == VFLD_SINGLE)
		{
		fields = 1;
		lines = height;
		stride = (3L * width + 3) & ~3;
		data = (BYTE __huge *)src + (stride * (lines-1));
		}
	else // two fields
		{
		fields = 2;
		lines = height / 2;
		stride = (2L * 3L * width + 3) & ~3;
		data = (BYTE __huge *)src + stride * lines - ((3L * width + 3) & ~3);
		}

	io->GetDWordPtr (I22REG_STILL_TRANSFER, stillReg);

	// Write the first pixel and assure it was transferred.
	io->SetBit (I22REG_P_RESET);   // release JPEG process reset
	z016->Start ();
	jpeg->coder->Start ();
	io->SetBit (I22REG_COD_TRNS_EN);
	io->WriteDWord (I22REG_STILL_TRANSFER, *((DWORD __far *)data));
	io->SetBit (I22REG_ACTIVE);
	do { io->ReadBit (I22REG_STILL_BSY, busy); } while (busy);
#if DO_TIMING
	DWORD start = Timer.GetMilliTicks ();
#endif

	// Write the rest of the first line in one run.
	WriteStillLineNonPolled ((FPTR)stillReg, data+3, width-1, width);
	data -= stride;
	y = 6;

	// Do each field.
	for (field = 0;  field < fields;  field++)
		{
		// Use wait state writing.
		for (line = 0;  line < lines;  )
			{
			line += 8;
#if VIONA_VERSION
			WORD fillLines;
			if (line > lines)
				{
				fillLines = line - lines;
				y -= fillLines - 1;
				GDP("compress repeat %ld lines", (long)fillLines);
				}
			else
				fillLines = 0;
#endif
			// The next lines can be written in one run, polling the first pixel.
			while (y > 0)
				{
				io->WriteDWord (I22REG_STILL_TRANSFER, *((DWORD __far *)data));
				do { io->ReadBit (I22REG_STILL_BSY, busy); } while (busy);
				WriteStillLineNonPolled ((FPTR)stillReg, data+3, width-1, width);
				data -= stride;
				y--;
				}
#if VIONA_VERSION
			if (fillLines > 0)
				{
				// Repeat the last line until height is a multiple of 8.
				data += stride;   // read the last line again
				y = fillLines - 1;
				while (y > 0)
					{
					io->WriteDWord (I22REG_STILL_TRANSFER, *((DWORD __far *)data));
					do { io->ReadBit (I22REG_STILL_BSY, busy); } while (busy);
					WriteStillLineNonPolled ((FPTR)stillReg, data+3, width-1, width);
					y--;
					}
				}
#endif
			y = 7;
#if COMPRESS_POLL_EIGHTH_LINE
			// Poll all pixels in every eighth line.
			WriteStillLinePolled ((FPTR)stillReg, data, width, width);
#else
			// Poll only the first pixel.
			io->WriteDWord (I22REG_STILL_TRANSFER, *((DWORD __far *)data));
			do { io->ReadBit (I22REG_STILL_BSY, busy); } while (busy);
			WriteStillLineNonPolled ((FPTR)stillReg, data+3, width-1, width);
#endif
			data -= stride;
			}
		// Prepare data pointer to next field.
		data = (BYTE __huge *)src + (stride * (lines-1));
		}

	// Write a dummy pixel to end the last field.
	io->WriteDWord (I22REG_STILL_TRANSFER, 0L);

	// Wait for end of operation.
	err = GNR_OK;
	timeout = Timer.GetMilliTicks () + 20;
	while (0 == (jpeg->statCom[0] & 0x01))
		{
		if (timeout < Timer.GetMilliTicks ())
			{
GDP("compress TIMEOUT !");
			err = GNR_JPEG_TIMEOUT;
			break;
			}
		}
#if DO_TIMING
	GDP("compression time %ld", Timer.GetMilliTicks() - start);
#endif

	Stop ();

	io->WriteDWord (I20REG_SYSCTRL, old);
	if (! IS_ERROR(err))
		{
		((VirtualJCoderRated *)(jpeg->coder))->GetLastScaleFactor ();
		}
	return err;
	}





#if VIONA_VERSION


	static void WriteStillLinePolled32 (FPTR stillReg, FPTR src, WORD width, WORD totalWidth)
		{
#if NT_KERNEL || VXD_VERSION
		__asm {
				push	esi

				mov	ebx, stillReg
				mov	esi, src
				mov	cx, width
		loop1:
				// Write a pixel to the I22.
				mov	eax, [esi]
				mov	[ebx], eax
				add	esi, 4
		loop2:
				// Poll the pixel.
				mov	edx, [ebx]
				or		edx, edx
				js		loop2

				sub	cx, 1
				jnz	loop1

				// Repeat the last pixel until width is a multiple of 16.
				mov	dx, totalWidth
				mov	cx, 16
				and	dx, 15
				jz		noFill
				sub	cx, dx
		loop4:
				mov	[ebx], eax
		loop5:
				// Poll the pixel.
				mov	edx, [ebx]
				or		edx, edx
				js		loop5

				sub	cx, 1
				jnz	loop4
		noFill:
				pop	esi
				}
#else
		__asm {
				push	ds
				_emit	0x66
				push	si   // push esi

				les	bx, stillReg
				_emit	0x66
				xor	si, si   // xor esi,esi
				lds	si, src
				mov	cx, width
		loop1:
				// Write a pixel to the I22.
				_emit	0x67
				_emit	0x66
				_emit	0x8b
				_emit	0x06   // mov eax, [esi]
				_emit	0x66
				mov	es:[bx], ax   // mov es:[bx],eax
				_emit	0x66
				add	si, 4   // add esi,4
		loop2:
				// Poll the pixel.
				_emit	0x66
				mov	dx, es:[bx]   // mov edx,es:[bx]
				_emit	0x66
				or		dx, dx   // or edx,edx
				js		loop2

				sub	cx, 1
				jnz	loop1

				// Repeat the last pixel until width is a multiple of 16.
				mov	dx, totalWidth
				mov	cx, 16
				and	dx, 15
				jz		noFill
				sub	cx, dx
		loop4:
				_emit	0x66
				mov	es:[bx], ax   // mov es:[bx],eax
		loop5:
				// Poll the pixel.
				_emit	0x66
				mov	dx, es:[bx]   // mov edx,es:[bx]
				_emit	0x66
				or		dx, dx   // or edx,edx
				js		loop5

				sub	cx, 1
				jnz	loop4
		noFill:
				_emit	0x66
				pop	si   // pop esi
				pop	ds
				}
#endif
		}


	static void WriteStillLineNonPolled32 (FPTR stillReg, FPTR src, WORD width, WORD totalWidth)
		{
#if NT_KERNEL || VXD_VERSION
		__asm {
				push	esi

				mov	ebx, stillReg
				mov	esi, src
				mov	cx, width
		loop1:
				// Write a pixel to the I22.
				mov	eax, [esi]
				add	esi, 4
				sub	cx, 1
				mov	[ebx], eax   // (does not change flags)
				jnz	loop1

				// Repeat the last pixel until width is a multiple of 16.
				mov	dx, totalWidth
				mov	cx, 16
				and	dx, 15
				jz		noFill
				sub	cx, dx
		loop2:
				sub	cx, 1
				mov	[ebx], eax   // (does not change flags)
				jnz	loop2
		noFill:
				pop	esi
				}
#else
		__asm {
				push	ds
				_emit	0x66
				push	si   // push esi

				les	bx, stillReg
				_emit	0x66
				xor	si, si   // xor esi,esi
				lds	si, src
				mov	cx, width
		loop1:
				// Write a pixel to the I22.
				_emit	0x67
				_emit	0x66
				_emit	0x8b
				_emit	0x06   // mov eax, [esi]
				_emit	0x66
				add	si, 4   // add esi,4
				sub	cx, 1
				_emit	0x66
				mov	es:[bx], ax   // mov es:[bx],eax (does not change flags)
				jnz	loop1

				// Repeat the last pixel until width is a multiple of 16.
				mov	dx, totalWidth
				mov	cx, 16
				and	dx, 15
				jz		noFill
				sub	cx, dx
		loop2:
				sub	cx, 1
				_emit	0x66
				mov	es:[bx], ax   // mov es:[bx],eax (does not change flags)
				jnz	loop2
		noFill:
				_emit	0x66
				pop	si   // pop esi
				pop	ds
				}
#endif
		}



Error JPEGManager022::WriteStillPixels32 (FPTR src, WORD width, WORD height,
                                          VideoField fieldOrder)
	{
	VirtualJPEGUnit022 *jpeg = GetCurrent ();
	DWORD timeout;
	DWORD reg, old, stride;
	BYTE __huge *data;
	WORD fields, field, lines, line, y;
	BOOL busy;
	Error err;
	volatile DWORD __far * stillReg;


	// Configure WaitState parameter to 4.
	io->ReadDWord (I20REG_SYSCTRL, old);
	reg = WRBF (old, I20IDX_WAITSTATE, 4);
	io->WriteDWord (I20REG_SYSCTRL, reg);

	// Note: We are working with little endian here, thus assuming fixed
	// organization of the still transfer register.

	// Note that bitmaps have the lines reversed.
	if (fieldOrder == VFLD_SINGLE)
		{
		fields = 1;
		lines = height;
		stride = 4L * width;
		data = (BYTE __huge *)src + (stride * (lines-1));
		}
	else // two fields
		{
		fields = 2;
		lines = height / 2;
		stride = 2L * 4L * width;
		data = (BYTE __huge *)src + stride * lines - 4L * width;
		}

	io->GetDWordPtr (I22REG_STILL_TRANSFER, stillReg);

	// Write the first pixel and assure it was transferred.
	io->SetBit (I22REG_P_RESET);   // release JPEG process reset
	z016->Start ();
	jpeg->coder->Start ();
	io->SetBit (I22REG_COD_TRNS_EN);
	io->WriteDWord (I22REG_STILL_TRANSFER, *((DWORD __far *)data));
	io->SetBit (I22REG_ACTIVE);
	do { io->ReadBit (I22REG_STILL_BSY, busy); } while (busy);
#if DO_TIMING
	DWORD start = Timer.GetMilliTicks ();
#endif

	// Write the rest of the first line in one run.
	WriteStillLineNonPolled32 ((FPTR)stillReg, data+4, width-1, width);
	data -= stride;
	y = 6;

	// Do each field.
	for (field = 0;  field < fields;  field++)
		{
		// Use wait state writing.
		for (line = 0;  line < lines;  )
			{
			line += 8;
#if VIONA_VERSION
			WORD fillLines;
			if (line > lines)
				{
				fillLines = line - lines;
				y -= fillLines - 1;
				GDP("compress repeat %ld lines", (long)fillLines);
				}
			else
				fillLines = 0;
#endif
			// The next lines can be written in one run, polling the first pixel.
			while (y > 0)
				{
				io->WriteDWord (I22REG_STILL_TRANSFER, *((DWORD __far *)data));
				do { io->ReadBit (I22REG_STILL_BSY, busy); } while (busy);
				WriteStillLineNonPolled32 ((FPTR)stillReg, data+4, width-1, width);
				data -= stride;
				y--;
				}
#if VIONA_VERSION
			if (fillLines > 0)
				{
				// Repeat the last line until height is a multiple of 8.
				data += stride;   // read the last line again
				y = fillLines - 1;
				while (y > 0)
					{
					io->WriteDWord (I22REG_STILL_TRANSFER, *((DWORD __far *)data));
					do { io->ReadBit (I22REG_STILL_BSY, busy); } while (busy);
					WriteStillLineNonPolled32 ((FPTR)stillReg, data+4, width-1, width);
					y--;
					}
				}
#endif
			y = 7;
#if COMPRESS_POLL_EIGHTH_LINE
			// Poll all pixels in every eighth line.
			WriteStillLinePolled32 ((FPTR)stillReg, data, width, width);
#else
			// Poll only the first pixel.
			io->WriteDWord (I22REG_STILL_TRANSFER, *((DWORD __far *)data));
			do { io->ReadBit (I22REG_STILL_BSY, busy); } while (busy);
			WriteStillLineNonPolled32 ((FPTR)stillReg, data+4, width-1, width);
#endif
			data -= stride;
			}
		// Prepare data pointer to next field.
		data = (BYTE __huge *)src + (stride * (lines-1));
		}

	// Write a dummy pixel to end the last field.
	io->WriteDWord (I22REG_STILL_TRANSFER, 0L);

	// Wait for end of operation.
	err = GNR_OK;
	timeout = Timer.GetMilliTicks () + 20;
	while (0 == (jpeg->statCom[0] & 0x01))
		{
		if (timeout < Timer.GetMilliTicks ())
			{
GDP("compress TIMEOUT !");
			err = GNR_JPEG_TIMEOUT;
			break;
			}
		}
#if DO_TIMING
	GDP("compression time %ld", Timer.GetMilliTicks() - start);
#endif

	Stop ();

	io->WriteDWord (I20REG_SYSCTRL, old);
	if (! IS_ERROR(err))
		{
		((VirtualJCoderRated *)(jpeg->coder))->GetLastScaleFactor ();
		}
	return err;
	}



	static void ReadStillLinePolled (FPTR stillReg, FPTR dst, WORD width)
		{
#if NT_KERNEL || VXD_VERSION
		__asm {
				push	esi

				mov	ebx, stillReg
				mov	esi, dst
				mov	cx, width
				sub	cx, 1
				jz		lastPixel
		loop1:
				// Poll the pixel from the I22.
				mov	eax, [ebx]
				or		eax, eax
				js		loop1

				// Store the pixel.
				mov	[esi], eax
				add	esi, 3
				sub	cx, 1
				jnz	loop1

		lastPixel:
				// The last pixel must be written as 3 bytes, not as four (otherwise
				// selector protection can cause GPF).
				// Poll the pixel from the I22.
				mov	eax, [ebx]
				or		eax, eax
				js		lastPixel

				// Store the pixel.
				mov	[esi], ax
				shr	eax, 16
				mov	[esi+2], al

				pop	esi
				}
#else
		__asm {
				push	ds
				_emit	0x66
				push	si   // push esi

				les	bx, stillReg
				_emit	0x66
				xor	si, si   // xor esi,esi
				lds	si, dst
				mov	cx, width
				sub	cx, 1
				jz		lastPixel
		loop1:
				// Poll the pixel from the I22.
				_emit	0x66
				mov	ax, es:[bx]   // mov eax,es:[bx]
				_emit	0x66
				or		ax, ax   // or eax,eax
				js		loop1

				// Store the pixel.
				_emit	0x67
				_emit	0x66
				_emit	0x89
				_emit	0x06   // mov [esi],eax
				_emit	0x66
				add	si, 3   // add esi,3
				sub	cx, 1
				jnz	loop1

		lastPixel:
				// The last pixel must be written as 3 bytes, not as four (otherwise
				// selector protection can cause GPF).
				// Poll the pixel from the I22.
				_emit	0x66
				mov	ax, es:[bx]   // mov eax,es:[bx]
				_emit	0x66
				or		ax, ax   // or eax,eax
				js		lastPixel

				// Store the pixel.
				_emit	0x67
				_emit	0x89
				_emit	0x06   // mov [esi],ax
				_emit	0x66
				shr	ax, 16   // shr eax,16
				_emit	0x67
				_emit	0x88
				_emit	0x46
				_emit	0x02   // mov [esi+2],al

				_emit	0x66
				pop	si   // pop esi
				pop	ds
				}
#endif
		}


	static void ReadStillLineNonPolled (FPTR stillReg, FPTR dst, WORD width)
		{
#if NT_KERNEL || VXD_VERSION
		__asm {
				push	esi

				mov	ebx, stillReg
				mov	esi, dst
				mov	cx, width
				sub	cx, 1
				jz		lastPixel
		loop1:
				// Read a pixel from the I22.
				mov	eax, [ebx]
				mov	[esi], eax
				add	esi, 3
				sub	cx, 1
				jnz	loop1

		lastPixel:
				// The last pixel must be written as 3 bytes, not as four (otherwise
				// selector protection can cause GPF).
				// Read the last pixel from the I22.
				mov	eax, [ebx]
				mov	[esi], ax
				shr	eax, 16
				mov	[esi+2], al

				pop	esi
				}
#else
		__asm {
				push	ds
				_emit	0x66
				push	si   // push esi

				les	bx, stillReg
				_emit	0x66
				xor	si, si   // xor esi,esi
				lds	si, dst
				mov	cx, width
				sub	cx, 1
				jz		lastPixel
		loop1:
				// Read a pixel from the I22.
				_emit	0x66
				mov	ax, es:[bx]   // mov eax,es:[bx]
				_emit	0x67
				_emit	0x66
				_emit	0x89
				_emit	0x06   // mov [esi],eax
				_emit	0x66
				add	si, 3   // add esi,3
				sub	cx, 1
				jnz	loop1

		lastPixel:
				// The last pixel must be written as 3 bytes, not as four (otherwise
				// selector protection can cause GPF).
				// Read the last pixel from the I22.
				_emit	0x66
				mov	ax, es:[bx]   // mov eax,es:[bx]
				_emit	0x67
				_emit	0x89
				_emit	0x06   // mov [esi],ax
				_emit	0x66
				shr	ax, 16   // shr eax,16
				_emit	0x67
				_emit	0x88
				_emit	0x46
				_emit	0x02   // mov [esi+2],al

				_emit	0x66
				pop	si   // pop esi
				pop	ds
				}
#endif
		}



Error JPEGManager022::ReadStillPixels24 (FPTR dst, WORD width, WORD height,
                                         DWORD stride, VideoField fieldOrder)
	{
	VirtualJPEGUnit022 *jpeg = GetCurrent ();
	DWORD reg, old;
	BYTE __huge *data;
	WORD fields, field, lines, line, y;
	volatile DWORD __far * stillReg;


GDP("Read still pixels");
	// Configure WaitState parameter to 6.
	io->ReadDWord (I20REG_SYSCTRL, old);
	reg = WRBF (old, I20IDX_WAITSTATE, 6);
	io->WriteDWord (I20REG_SYSCTRL, reg);

	// Note: We are working with little endian here, thus assuming fixed
	// organization of the still transfer register.

	// Note that bitmaps have the lines reversed.
	if (fieldOrder == VFLD_SINGLE)
		{
		fields = 1;
		lines = height;
		data = (BYTE __huge *)dst + (stride * (lines-1));
		}
	else // two fields
		{
		fields = 2;
		lines = height / 2;
		stride *= 2L;
		data = (BYTE __huge *)dst + stride * lines - 3L * width;
		}

	io->GetDWordPtr (I22REG_STILL_TRANSFER, stillReg);

	// Start.
	io->SetBit (I22REG_P_RESET);   // release JPEG process reset
	z016->Start ();
	io->SetBit (I22REG_COD_TRNS_EN);
	io->SetBit (I22REG_ACTIVE);
#if DO_TIMING
	DWORD start = Timer.GetMilliTicks ();
#endif


	// Do each field.
	for (field = 0;  field < fields;  field++)
		{
		for (line = 0;  line < lines;  line += 8)
			{
			// The first line is polled completely.
			ReadStillLinePolled ((FPTR)stillReg, data, width);
			data -= stride;
			if (line == 0)
				io->ClearBit (I22REG_GO_ENABLE);   // 016 bug fix
			// The next seven are not polled.
			for (y = 7;  y > 0;  y--)
				{
				ReadStillLineNonPolled ((FPTR)stillReg, data, width);
				data -= stride;
				}
			}
		// Prepare data pointer to next field.
		data = (BYTE __huge *)dst + (stride * (lines-1));
		io->SetBit (I22REG_GO_ENABLE);
		}
#if DO_TIMING
	GDP("expansion time %ld", Timer.GetMilliTicks() - start);
#endif

	Stop ();

	io->WriteDWord (I20REG_SYSCTRL, old);
	GNRAISE_OK;
	}



#endif // VIONA_VERSION










//************************************************************************
// The JPEG unit class.
//************************************************************************



// Constructor.

VirtualJPEGUnit022::VirtualJPEGUnit022 (JPEGManager022 *physical, VirtualJCoder *coder,
                                        VirtualI22PIP *pip)
	: VirtualJPEGUnit (physical, coder)
	{
	FPTR fptr;
	DWORD dummySize;


	manager = physical;
	this->pip = pip;

	statComTable.AllocateBuffer (N_FRAGTABLES * sizeof(DWORD));
	statComTable.GetBuffer (fptr, dummySize);
	statCom = (DWORD __far *)fptr;
	statComTable.GetBufferFragment (0, statComPhysical, dummySize);

	dummyCaptureData = NULL;
	dummyCaptureInfo = NULL;

	playBackupData = NULL;
	playBackupInfo = NULL;

	running = FALSE;
	playHook = NULL;
	nextBuffer = 0;
	lastBuffer = 0;
	nBuffers   = 0;

	preemptHook = NULL;
	stillExpansion = FALSE;
	singleFrame    = FALSE;
	syncMaster     = FALSE;
	horDecimation  = FALSE;
	jpgMode        = I22_MOTION_COMPRESS;

	// Set defaults.
	vStandard  = VSTD_NTSC;
	vFormat    = VFMT_YUV_422;
	fieldOrder = VFLD_SINGLE;
	thumbnail  = FALSE;
	filtersOn  = TRUE;
	}



// Destructor.

VirtualJPEGUnit022::~VirtualJPEGUnit022 (void)
	{
	FlushPlayback (0);
	delete pip;
	pip = NULL;
	statComTable.FreeBuffer ();
	statComPhysical = NULL;
	statCom = NULL;
	}





// The function responsible for the tag processing.

Error VirtualJPEGUnit022::Configure (TAG __far *tags)
	{
	GNREASSERT( VirtualJPEGUnit::Configure (tags) );
	GNREASSERT( coder->Configure (tags) );

	{
	PARSE_TAGS_START(tags)
		GETSETC (JPG_VIDEO_STANDARD, vStandard);
	PARSE_TAGS_END
	}

	// Calculate the video offsets according to the current operation mode.
	CalcVideoParameters ();

	PARSE_TAGS_START(tags)
		GETSETC (JPG_VIDEO_FORMAT,   vFormat);
		GETSETC (JPG_FIELD_ORDER,    fieldOrder);
		GETSETC (JPG_THUMBNAIL,      thumbnail);
		GETSETC (JPG_MSEC_PER_FRAME, milliSecPerFrame);
		GETSETC (JPG_SINGLEFRAME,    singleFrame);
		GETSETC (JPG_TOTALCODEVOL,   totalCodeVolume);
		GETSETC (JPG_FILTERS_ON,     filtersOn);
		GETSET  (JPG_PREEMPT_HOOK,   preemptHook);
		GETONLY (JPG_HAS_CODEMEMORY, FALSE);
		GETONLY (JPG_HOFFSET,        hOffset);
		GETONLY (JPG_VOFFSET,        vOffset);
		GETONLY (JPG_WANTS_EXT_FI,   ! syncMaster);
		GETONLY (JPG_ALLOWED_VSTD,   manager->allowedStandard);
		GETONLY (JPG_MAX_FIELDSIZE,  MAX_FIELDSIZE);
		GETONLY (JPG_VBUS_WIDTH,     opWidth);
		GETONLY (JPG_VBUS_HEIGHT,    2*opHeight);
		GETINQUIRE (JPG_VIDEO_FMT_LIST, data &= VideoFormatBitField;);
	PARSE_TAGS_END

	GNRAISE_OK;
	}





Error VirtualJPEGUnit022::PrepareBuffer (FPTR buffer, DWORD size, FPTR __far &info)
	{
	PrepareInfo *prep = new PrepareInfo;
	if (prep == NULL)
		{
		GDP("PrepareBuffer: not enough memory");
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
		}
	GNREASSERT( prep->PrepareMemory (buffer, size) );
	info = prep;
	GNRAISE_OK;
	}





Error VirtualJPEGUnit022::UnprepareBuffer (FPTR info)
	{
	PrepareInfo *prep = (PrepareInfo *)info;
	if (prep == NULL)
		{
		GDP("UnprepareBuffer: NULL ptr");
		GNRAISE(GNR_MEM_NOT_ALLOCATED);
		}
	delete prep;
	GNRAISE_OK;
	}





Error VirtualJPEGUnit022::AllocateVideoBuffer (DWORD size, FPTR __far &info, FPTR __far &data)
	{
	size = (size + 3) & ~3;

	PrepareInfo *prep = new PrepareInfo;
	if (prep == NULL)
		{
		GDP("AllocateVideoBuffer: not enough memory");
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
		}
	GNREASSERT( prep->AllocMemory (size, data) );
	info = prep;
	GNRAISE_OK;
	}





Error VirtualJPEGUnit022::FreeVideoBuffer (FPTR info)
	{
	PrepareInfo *prep = (PrepareInfo *)info;
	if (prep == NULL)
		{
		GDP("FreeVideoBuffer: NULL ptr");
		GNRAISE(GNR_MEM_NOT_ALLOCATED);
		}
	delete prep;
	GNRAISE_OK;
	}





#if VIONA_VERSION


// Is a scaling valid ?  We need srcWidth <= 768 (720 for CCIR) and an even number of MCUs
// (i.e. srcWidth must be multiple of 16). We also cannot scale up.

BOOL VirtualJPEGUnit022::IsValidExpansionScaling (WORD srcWidth, WORD srcHeight,
                                                  WORD dstWidth, WORD dstHeight,
                                                  GrabFormat bitFormat)
	{
	// We support 32, 24 and 16 bit formats.
	if (bitFormat != VGRB_RGB_888x  &&  bitFormat != VGRB_RGB_888  &&  bitFormat != VGRB_RGB_565
	    &&  bitFormat != VGRB_YUV_422)
		return FALSE;

	// No scaling is valid.
	if (dstWidth == srcWidth  &&  dstHeight == srcHeight)
		return TRUE;

	// Check restricted scaling capability.
	if (srcWidth > 768  ||  (manager->ccirMode  &&  srcWidth > 720)  ||  (srcWidth & 0x0f) != 0)
		return FALSE;
	if (dstWidth > srcWidth  ||  dstHeight > srcHeight)
		return FALSE;
	return TRUE;
	}



Error VirtualJPEGUnit022::ExpandToRGB (FPTR src, DWORD size, FPTR dst, WORD dstWidth, WORD dstHeight, GrabFormat bitFormat)
	{
	FragmentTableClass *frag = new FragmentTableClass;
	DWORD physical, dummySize, oldSize;
	Error err;
	int i;
	int retries;
	WORD jpegWidth, jpegHeight;
#if EXPAND_ONE_FRAGMENT
	PoolContDMABuffer *codeBuffer;
	FPTR fptr;
#endif


#if DO_TIMING
	DWORD start = Timer.GetMilliTicks ();
#endif


	// Check unit state.
	if (GetState() != current)
		GNRAISE(GNR_OBJECT_NOT_CURRENT);
	if (compress  ||  ! stillMode)
		GNRAISE(GNR_INVALID_CONFIGURE_STATE);

	jpegWidth  = width;
	jpegHeight = height;
#if 1
	// Cope with irregular sizes.
	width = (width + 15) & ~15;
	i = (fieldOrder == VFLD_SINGLE ? 7 : 15);
	height = (height + i) & ~i;
#else
	// Width must be a multiple of 16 and height a multiple of 8.
	if (width & 0x0f  ||  height & 0x07)
		GNRAISE(GNR_RANGE_VIOLATION);
#endif

	oldSize = size;

	stillExpansion = TRUE;
	size = (size + 3) & ~3;   // round up to DWORD boundary

	// Allocate JPEG source buffer.
#if EXPAND_ONE_FRAGMENT
	// If the I22 FIFO is completely full and a new fragment is started, the I22
	// chokes on the code. Fix this bug by either lowering the CodeThreshold for
	// expansion such that a burst filling the FIFO completely is highly unlikely
	// or by using only one code fragment. We choose the latter here.
	codeBuffer = new PoolContDMABuffer;
	if (codeBuffer == NULL)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	err = codeBuffer->AllocateBuffer (size);
	if (IS_ERROR(err))
		{
		delete codeBuffer;
		GNRAISE(err);
		}
	err = codeBuffer->GetBuffer (fptr, dummySize);
	if (IS_ERROR(err))
		{
		codeBuffer->FreeBuffer ();
		delete codeBuffer;
		GNRAISE(err);
		}
#if NT_KERNEL || VXD_VERSION
	memcpy (fptr, src, oldSize);
#else
	hmemcpy (fptr, src, oldSize);
#endif
	src = fptr;
#else
	Check if CreateFragmentBuffer works with byte-precise source segment.
#endif

	// For expanding a single frame, we only need one fragment table.
	if (frag == NULL)
		err = GNR_NOT_ENOUGH_MEMORY;
	else
		{
		err = frag->CreateFragmentBuffer (src, size);
		if (! IS_ERROR(err))
			{
			// Get physical address of the fragment and write it to the STATCOM table.
			if (! frag->GetBufferFragment (0, physical, dummySize))
				err = GNR_OBJECT_NOT_FOUND;   // will never occur
			else
				{
				// Try several times until timeout.
				err = GNR_JPEG_TIMEOUT;
				for (retries = 5;  retries > 0 && (err == GNR_JPEG_TIMEOUT || err == GNR_GRAB_TIMEOUT);  retries--)
					{
					statCom[0] = physical;
					// The other fragment entries are declared "status" so only one
					// fragment is expanded.
					for (i = 1;  i < N_FRAGTABLES;  i++)
						statCom[i] = 0x01;

#if DO_THUMBNAIL
					thumbnail = TRUE;
//					width /= 8;
					height /= 8;

					// Initialize the operation.
					changed = TRUE;   // reprogram chip parameters
					err = manager->InitOperation (statComPhysical);
					if (! IS_ERROR(err))
						{
						err = manager->ReadStillPixels24 (dst, width/8, height, 3L*dstWidth, fieldOrder);
						}
#else
					// Initialize the operation.
					changed = TRUE;   // reprogram chip parameters
					err = manager->InitOperation (statComPhysical);
					if (! IS_ERROR(err))
						{
#if ! PIP_EXPAND
						err = manager->ReadStillPixels24 (dst, dstWidth, dstHeight, 3L*dstWidth, fieldOrder);
#else
						err = pip->ConfigureTags (SET_PIP_VIDEOSTANDARD(vStandard),
						                          SET_PIP_SAMPLEMODE(VSAMOD_SQP),
						                          SET_PIP_HOFFSET(hOffset),
						                          SET_PIP_VOFFSET(vOffset),
						                          SET_PIP_EXT_FIELD_IND(! syncMaster),
						                          SET_PIP_TOP_FIELD(HIGH),
						                          SET_PIP_SOURCE_LEFT(0),
						                          SET_PIP_SOURCE_TOP(0),
						                          SET_PIP_SOURCE_WIDTH(opWidth),
						                          SET_PIP_SOURCE_HEIGHT(jpegHeight),
						                          SET_PIP_DEST_LEFT(0),
						                          SET_PIP_DEST_TOP(0),
						                          SET_PIP_DEST_WIDTH(width),
						                          SET_PIP_DEST_HEIGHT(height),
						                          SET_PIP_ADAPT_CLIENT_SIZE(FALSE),
						                          SET_PIP_ADAPT_SOURCE_SIZE(FALSE),
						                          TAGDONE);
						if (! IS_ERROR(err))
							{
							err = pip->Activate ();
							if (! IS_ERROR(err))
								{
								if (opWidth != width)
									jpegWidth *= 2;
								if (opHeight == height)
									jpegHeight *= 2;
								Start ();
								err = pip->GrabExpandFrame (dst, jpegWidth, jpegHeight, dstWidth, dstHeight, 0, bitFormat);
//								err = pip->GrabExpandFrame (dst, opWidth, 2 * opHeight, dstWidth, dstHeight, 0, bitFormat);
								Stop ();
								}
							}
#endif
						}
#endif // DO_THUMBNAIL
					}
				}
			frag->DeleteFragmentBuffer ();
			}
		}

	pip->Passivate ();
	delete frag;
#if EXPAND_ONE_FRAGMENT
	codeBuffer->FreeBuffer ();
	delete codeBuffer;
#endif

	if (IS_ERROR(err))
		{
		GDP("expand failed %lx", err);
		}
	stillExpansion = FALSE;
#if DO_TIMING
	GDP("total expansion time %ld", Timer.GetMilliTicks()-start);
#endif
	return err;
	}



#else // not VIONA_VERSION



// Expand a compressed frame into packed RGB data.

Error VirtualJPEGUnit022::ExpandToRGB (FPTR src, DWORD size, FPTR dst)
	{
	FragmentTableClass *frag = new FragmentTableClass;
	DWORD physical, dummySize, oldSize;
	Error err;
	int i;
	int retries;
#if EXPAND_ONE_FRAGMENT
	ContinuousDMABuffer *codeBuffer;
	FPTR fptr;
#else
	HGLOBAL handle;
	char __far *ptr;
#endif


#if DO_TIMING
	DWORD start = Timer.GetMilliTicks ();
#endif


_asm int 3
	// Check unit state.
	if (GetState() != current)
		GNRAISE(GNR_OBJECT_NOT_CURRENT);
	if (compress  ||  ! stillMode)
		GNRAISE(GNR_INVALID_CONFIGURE_STATE);

	// Width must be a multiple of 16 and height a multiple of 8.
	if (width & 0x0f  ||  height & 0x07)
		GNRAISE(GNR_RANGE_VIOLATION);

	oldSize = size;

	stillExpansion = TRUE;
	size = (size + 3) & ~3;   // round up to DWORD boundary

	// Allocate JPEG source buffer.
#if EXPAND_ONE_FRAGMENT
	// If the I22 FIFO is completely full and a new fragment is started, the I22
	// chokes on the code. Fix this bug by either lowering the CodeThreshold for
	// expansion such that a burst filling the FIFO completely is highly unlikely
	// or by using only one code fragment. We choose the latter here.
	codeBuffer = new ContinuousDMABuffer;
	if (codeBuffer == NULL)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	err = codeBuffer->AllocateBuffer (size);
	if (IS_ERROR(err))
		{
		delete codeBuffer;
		GNRAISE(err);
		}
	err = codeBuffer->GetBuffer (fptr, dummySize);
	if (IS_ERROR(err))
		{
		codeBuffer->FreeBuffer ();
		delete codeBuffer;
		GNRAISE(err);
		}
	hmemcpy (fptr, src, oldSize);
	src = fptr;
#else
	handle = GlobalAlloc (GMEM_FIXED, size);
	if (handle == NULL)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	if (0 == GlobalPageLock (handle))
		{
		GlobalFree (handle);
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
		}
	ptr = GlobalLock (handle);
	if (ptr == NULL)
		{
		GlobalPageUnlock (handle);
		GlobalFree (handle);
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
		}
	hmemcpy (ptr, src, oldSize);
	src = ptr;
#endif

	// For expanding a single frame, we only need one fragment table.
	if (frag == NULL)
		err = GNR_NOT_ENOUGH_MEMORY;
	else
		{
		err = frag->CreateFragmentBuffer (src, size);
		if (! IS_ERROR(err))
			{
			// Get physical address of the fragment and write it to the STATCOM table.
			if (! frag->GetBufferFragment (0, physical, dummySize))
				err = GNR_OBJECT_NOT_FOUND;   // will never occur
			else
				{
				// Try several times until timeout.
				err = GNR_JPEG_TIMEOUT;
				for (retries = 5;  retries > 0 && (err == GNR_JPEG_TIMEOUT || err == GNR_GRAB_TIMEOUT);  retries--)
					{
					statCom[0] = physical;
					// The other fragment entries are declared "status" so only one
					// fragment is expanded.
					for (i = 1;  i < N_FRAGTABLES;  i++)
						statCom[i] = 0x01;

					// Initialize the operation.
					changed = TRUE;   // reprogram chip parameters
					err = manager->InitOperation (statComPhysical);
					if (! IS_ERROR(err))
						{
						err = pip->ConfigureTags (SET_PIP_VIDEOSTANDARD(vStandard),
						                          SET_PIP_SAMPLEMODE(VSAMOD_SQP),
						                          SET_PIP_HOFFSET(hOffset),
						                          SET_PIP_VOFFSET(vOffset),
						                          SET_PIP_EXT_FIELD_IND(! syncMaster),
						                          SET_PIP_TOP_FIELD(HIGH),
						                          SET_PIP_SOURCE_LEFT(0),
						                          SET_PIP_SOURCE_TOP(0),
						                          SET_PIP_SOURCE_WIDTH(opWidth),
						                          SET_PIP_SOURCE_HEIGHT(height),
						                          SET_PIP_DEST_LEFT(0),
						                          SET_PIP_DEST_TOP(0),
						                          SET_PIP_DEST_WIDTH(width),
						                          SET_PIP_DEST_HEIGHT(height),
						                          SET_PIP_ADAPT_CLIENT_SIZE(FALSE),
						                          SET_PIP_ADAPT_SOURCE_SIZE(FALSE),
						                          TAGDONE);
						if (! IS_ERROR(err))
							{
							err = pip->Activate ();
							if (! IS_ERROR(err))
								{
								Start ();
								err = pip->GrabExpandFrame (dst, opWidth, 2 * opHeight, width, height, 0, VGRB_RGB_888);
								Stop ();
								}
							}
						}
					}
				}
			frag->DeleteFragmentBuffer ();
			}
		}

	pip->Passivate ();
	delete frag;
#if EXPAND_ONE_FRAGMENT
	codeBuffer->FreeBuffer ();
	delete codeBuffer;
#else
	GlobalUnlock (handle);
	GlobalPageUnlock (handle);
	GlobalFree (handle);
#endif

	if (IS_ERROR(err))
		{
		GDP("expand failed %lx", err);
		}
	stillExpansion = FALSE;
#if DO_TIMING
	GDP("total expansion time %ld", Timer.GetMilliTicks()-start);
#endif
	return err;
	}



#endif // VIONA_VERSION





// Compress RGB data into a frame.

#if VIONA_VERSION

BOOL VirtualJPEGUnit022::IsValidCompression (WORD width, WORD height, BOOL bits32)
	{
	if (height > 288  &&  (height & 1))
		return FALSE;
	return (width >= 16  &&  height >= 8);
	}

Error VirtualJPEGUnit022::CompressFromRGB (FPTR src, FPTR dst, DWORD maxSize, DWORD __far &size, BOOL bits32)
#else
Error VirtualJPEGUnit022::CompressFromRGB (FPTR src, FPTR dst, DWORD maxSize, DWORD __far &size)
#endif
	{
	FragmentTableClass *frag;
	DWORD physical, dummySize;
	Error err;
	int i;
	int retries;
#if !NO_MORE_GLOBAL_ALLOC_IN_LOW_LEVEL_DRIVERS
	HGLOBAL handle;
#endif
	char __far *ptr;
#if DO_TIMING
	DWORD start = Timer.GetMilliTicks ();
#endif


	// Check unit state.
	if (GetState() != current)
		GNRAISE(GNR_OBJECT_NOT_CURRENT);
	if (! compress  ||  ! stillMode)
		GNRAISE(GNR_INVALID_CONFIGURE_STATE);

#if VIONA_VERSION
	// Size must be valid. For two fields, height must be even.
	if (! IsValidCompression (width, height, bits32))
		GNRAISE(GNR_RANGE_VIOLATION);
	if (fieldOrder != VFLD_SINGLE  &&  (height & 1))
		GNRAISE(GNR_RANGE_VIOLATION);

	// Cope with irregular sizes.
	WORD bitmapWidth  = width;
	WORD bitmapHeight = height;
	width = (width + 15) & ~15;
	i = (fieldOrder == VFLD_SINGLE ? 7 : 15);
	height = (height + i) & ~i;

	// We could directly create the fragment table from "dst", but timing shows
	// that this is a bit slower than using a temporary buffer (about 204/186).
#else
	// Width must be a multiple of 16 and height a multiple of 8.
	if (width & 0x0f  ||  height & 0x07)
		GNRAISE(GNR_RANGE_VIOLATION);
#endif
	// Allocate JPEG code target buffer.
#if NO_MORE_GLOBAL_ALLOC_IN_LOW_LEVEL_DRIVERS
#if WIN32
	ptr = new __huge (PagedPool) char[maxSize];
#else
	ptr = (char __far *) _halloc (maxSize, sizeof(char));   // MSVC bug in "new __huge"
#endif
	if (ptr == NULL)
		{
		GDP("temp buffer not allocated");
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
		}
#else
	handle = GlobalAlloc (GMEM_FIXED, maxSize);
	if (handle == NULL)
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	if (0 == GlobalPageLock (handle))
		{
		GlobalFree (handle);
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
		}
	ptr = GlobalLock (handle);
	if (ptr == NULL)
		{
		GlobalPageUnlock (handle);
		GlobalFree (handle);
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
		}
#endif

	// For compressing a single frame, we only need one fragment table.
	frag = new FragmentTableClass;
	err = frag->CreateFragmentBuffer (ptr, maxSize);
	if (! IS_ERROR(err))
		{
		// Get physical address of the fragment and write it to the STATCOM table.
		if (! frag->GetBufferFragment (0, physical, dummySize))
			err = GNR_OBJECT_NOT_FOUND;   // will never occur
		else
			{
			// Try several times until timeout.
			err = GNR_JPEG_TIMEOUT;
			for (retries = 5;  retries > 0 && err == GNR_JPEG_TIMEOUT;  retries--)
				{
				statCom[0] = physical;
				// The other fragment entries are declared "status" so only one
				// fragment is compressed.
				for (i = 1;  i < N_FRAGTABLES;  i++)
					statCom[i] = 0x01;

				// Initialize the operation.
#if VIONA_VERSION
				err = manager->InitOperation (statComPhysical);
				if (! IS_ERROR(err))
					{
					if (bits32)
						err = manager->WriteStillPixels32 (src, bitmapWidth, bitmapHeight, fieldOrder);
					else
						err = manager->WriteStillPixels24 (src, bitmapWidth, bitmapHeight, fieldOrder);
					if (! IS_ERROR(err))
						{
						size = XTBF (1, 22, statCom[0]);
#if NT_KERNEL || VXD_VERSION
						memcpy (dst, ptr, size);
#else
						hmemcpy (dst, ptr, size);
#endif

						// Mark the first field correctly.
						coder->MarkFirstField (dst, size, (fieldOrder == VFLD_SINGLE ? VFLD_SINGLE : VFLD_ODD));
						}
					}
#else
				err = manager->InitOperation (statComPhysical);
				if (! IS_ERROR(err))
					{
					err = manager->WriteStillPixels24 (src, width, height, fieldOrder);
					if (! IS_ERROR(err))
						{
						size = XTBF (1, 22, statCom[0]);
						hmemcpy (dst, ptr, size);
						}
					}
#endif
				}
			}
		frag->DeleteFragmentBuffer ();
		}
	delete frag;
#if NO_MORE_GLOBAL_ALLOC_IN_LOW_LEVEL_DRIVERS
#if WIN32
	delete[] ptr;
#else
	_hfree (ptr);
#endif
#else
	GlobalUnlock (handle);
	GlobalPageUnlock (handle);
	GlobalFree (handle);
#endif

#if DO_TIMING
	GDP("total compression time %ld", Timer.GetMilliTicks()-start);
#endif
	return err;
	}





Error VirtualJPEGUnit022::InitCapture (JPEGCaptureHook __far *hook)
	{
	int i;
	Error err;


	// Mark all fragments as "status".
	for (i = 0;  i < N_FRAGTABLES;  i++)
		statCom[i] = 0x01;
	for (i = 0;  i < N_DLL_BUFFERS;  i++)
		{
		buffers[i].info     = NULL;
		buffers[i].userData = NULL;
		}
	nextBuffer = 0;
	lastBuffer = 0;
	nBuffers   = 0;
	nStatBuffers = 0;
	frameNum   = 0;
	lastFieldCnt = 255;

	nextFrameTime = 0;
	stoppingCapture = 0;
	playAddAllowed = TRUE;

	// Check unit state.
	if (GetState() != current)
		GNRAISE(GNR_OBJECT_NOT_CURRENT);
	if (! compress  ||  stillMode)
		GNRAISE(GNR_INVALID_CONFIGURE_STATE);

	// Width must be a multiple of 16 and height a multiple of 8.
	if (width & 0x0f  ||  height & 0x07)
		{
#if NT_DEBUGOUTPUT
		DbgPrint ("InitCapture size %ld,%ld\n", (long)width, (long)height);
#endif
		GNRAISE(GNR_RANGE_VIOLATION);
		}

	if (fieldOrder == VFLD_SINGLE)
		{
		dummyCapSize = 2L * totalCodeVolume;
		GDP("InitCap: allocating %ld", dummyCapSize);
		GNREASSERT( AllocateVideoBuffer (dummyCapSize, dummyCaptureInfo, dummyCaptureData) );
		}

	// Initialize the operation.
	err = manager->InitOperation (statComPhysical);
	if (! IS_ERROR(err))
		{
		capHook = hook;
#if NT_DEBUGOUTPUT
		DbgPrint ("InitCapture OK\n");
#endif
		err = manager->StartIRQs ();
		if (! IS_ERROR(err))
			{
			GNRAISE_OK;
			}		
		}
	if (dummyCaptureInfo != NULL)
		{
		FreeVideoBuffer (dummyCaptureInfo);
		dummyCaptureInfo = NULL;
		}
#if NT_DEBUGOUTPUT
	DbgPrint ("InitCapture error %08lx\n", err);
#endif
	GNRAISE(err);
	}





Error VirtualJPEGUnit022::FinishCapture (void)
	{
	Error err;


#if NT_KERNEL
	irqMutex.Enter();
	playAddAllowed = FALSE;
	capHook = NULL;
	irqMutex.Leave();
#else
	playAddAllowed = FALSE;
	capHook = NULL;
#endif
	err = manager->StopIRQs ();

	if (dummyCaptureInfo != NULL)
		{
		FreeVideoBuffer (dummyCaptureInfo);
		dummyCaptureInfo = NULL;
		}

	GNRAISE(err);
	}





void VirtualJPEGUnit022::JPEGCodeInterrupt (void)
	{
	DWORD status;
	WORD fieldCnt;
	JPEGCaptureMsg msg;
	JPEGPlaybackMsg pmsg;


#if NT_KERNEL
	irqMutex.EnterAtIRQLevel();
#endif


	if (compress)
		{
		PrepareInfo *prep;
		DWORD nextFrameNum, timeStream;

		// Process all filled capture buffers.
		while (nBuffers > 0  &&  ((status = statCom[nextBuffer]) & 0x01))
			{
			nBuffers--;
			msg.info     = buffers[nextBuffer].info;
			msg.userData = buffers[nextBuffer].userData;
			msg.byteSize = XTBF(1, 22, status);

			// If there is no further entry in the STATCOM table, this buffer will
			// be the last I22 interrupt processed. If the high level driver does
			// not supply another buffer, we must repeat this one to have a buffer
			// in the low level DLL that triggers interrupts. If this is not done,
			// capture process can stop completely under conditions where the
			// capture application cannot supply unfilled buffers fast enough.
			// Note that for successful single frame capture, this is acceptable.
			if (nBuffers == 0  &&  ! singleFrame)
				{
				// We MUST fill this buffer again.
//				GDP("MUST refill buffer");
				buffers[nextBuffer].info = NULL;   // buffer available for adding another buffer
				InternalAddVideoBuffer (msg.info, msg.userData, buffers[nextBuffer].byteSize);
				msg.info = NULL;
				msg.userData = NULL;
				msg.byteSize = 0;
				}
			else
				{
				// We can step to the next buffer.
				fieldCnt = (WORD)(XTBF(24, 8, status));
				if (lastFieldCnt >= fieldCnt)
					frameNum += (256 + fieldCnt) - lastFieldCnt;
				else
					frameNum += fieldCnt - lastFieldCnt;
//GDP("stat %ld:  %ld %ld %ld %ld", (long)fieldCnt, statCom[0] & 1, statCom[1] & 1, statCom[2] & 1, statCom[3] & 1);
#if NT_DEBUGOUTPUT
	if (frameNum <= 2  ||  frameNum == 20  ||  frameNum == 60  ||  frameNum == 100)
		DbgPrint ("irq22\n");
#endif
GDP("Cap %ld, size %ld, cnt %ld", frameNum, (long)msg.byteSize, (long)fieldCnt);
				lastFieldCnt = fieldCnt;
				msg.frameNum = frameNum;

				if (! singleFrame  &&  fieldOrder == VFLD_SINGLE)
					{
#if DUMMY_CAPBUFFER
					if (buffers[nextBuffer].userData == NULL)
						{
						// Drop second field in single field mode.
//						GDP("Dropping second field");
//						if ((fieldCnt & 1) != 1)
//							GDP("got even field cnt");
						buffers[nextBuffer].info = NULL;   // buffer available for adding another buffer
						msg.byteSize = 0;
						}
#else
					if ((fieldCnt & 1) == 1)
						{
						// Drop second field in single field mode.
//						GDP("Dropping second field");
						buffers[nextBuffer].info = NULL;   // buffer available for adding another buffer
						msg.byteSize = 0;
						}
#endif
					msg.frameNum >>= 1;
					}

				// Drop the very first two frames of a sequence to let the bit rate control
				// process stabilize.
				if (msg.byteSize > 0  &&  (msg.frameNum >= STARTCAP_DROPFRAMES  ||  singleFrame))
					{
					// Mark the first field correctly.
					VideoField order;
					switch (fieldOrder)
						{
						case VFLD_SINGLE:  order = VFLD_SINGLE;  break;
						case VFLD_ODD:     order = VFLD_EVEN;    break;
						case VFLD_EVEN:    order = VFLD_ODD;     break;
						}
					prep = (PrepareInfo *)buffers[nextBuffer].info;
					coder->MarkFirstField (prep->KernelSpace(), msg.byteSize, order);

					buffers[nextBuffer].info = NULL;   // buffer available for adding another buffer

					if (singleFrame)
						nextFrameNum = msg.frameNum;
					else
						nextFrameNum = msg.frameNum - STARTCAP_DROPFRAMES;

					// Compute the time of the frame.
					if (VSTD_NTSC == vStandard)
						// nextFrameNum * 780 * 525 * 1000 / 12 272 727.
						timeStream = ScaleDWord (nextFrameNum, 4090909L, 136500000);
					else
						timeStream = 40 * nextFrameNum;

					// If it's time for a new frame, process it.
					if (timeStream >= nextFrameTime)
						{
						// Capture OK.
						nextFrameTime += milliSecPerFrame;
						msg.captureTime = timeStream;
						}
					else
						{
						GDP("not yet time\n");
						msg.byteSize = 0;
						}
					}
				else
					msg.byteSize = 0;
				}
			// Do a callback to give the high level driver opportunity to pass down buffers.
#if DUMMY_CAPBUFFER
			if (fieldOrder != VFLD_SINGLE  ||  buffers[nextBuffer].userData != NULL)
#endif
				{
				if (capHook)
					capHook.Call (msg);
				else
					{
					GDP("No capHook");
					}
				if (stoppingCapture == 1)
					stoppingCapture++;
				}
			nextBuffer = (nextBuffer+1) & (N_DLL_BUFFERS-1);
			}
		}


	if (! compress)
		{
		InPlayInterrupt = TRUE;
		// Playback interrupt.
//GDP("stat:  %ld %ld %ld %ld", statCom[0] & 1, statCom[1] & 1, statCom[2] & 1, statCom[3] & 1);
		BOOL called = FALSE;

		while (nBuffers > 0  &&  ((status = statCom[nextBuffer]) & 0x01))
			{
			nBuffers--;
//GDP("finish %ld, stat: %ld %ld %ld %ld", (long)nextBuffer, statCom[0] & 1, statCom[1] & 1, statCom[2] & 1, statCom[3] & 1);
			buffers[nextBuffer].info = NULL;   // buffer available for adding another buffer

			if (frameNum <= 0)
				{
				GDP("irq base time");
				nextFrameTime = Timer.GetMilliTicks ();   // set base start time
				}
			pmsg.nowTime = (fieldOrder == VFLD_SINGLE) ? frameNum/2 : frameNum;
			if (VSTD_NTSC == vStandard)
				// nextFrameNum * 780 * 525 * 1000 / 12 272 727.
				pmsg.nowTime = ScaleDWord (pmsg.nowTime, 4090909L, 136500000);
			else
				pmsg.nowTime = 40 * pmsg.nowTime;
if (pmsg.nowTime == 0)
	GDP("irq nowtime zero, nft %ld", nextFrameTime);
			pmsg.nowTime += nextFrameTime;
			pmsg.baseTime = nextFrameTime;

			if (playHook)
				{
				pmsg.userData = buffers[nextBuffer].userData;
//				pmsg.nowTime = Timer.GetMilliTicks ();
				called = TRUE;
				playHook.Call (pmsg);
				}

#if 1
			nextBuffer = (nextBuffer+1) & (N_DLL_BUFFERS-1);
#else
			if (buffers[nextBuffer].info != NULL)
				nextBuffer = (nextBuffer+1) & (N_DLL_BUFFERS-1);
			else
				{
				nBuffers++;
				GDP("Buffer skipped");
				frameNum++;
				break;
				}
#endif
			frameNum++;
			}
		if (! called  &&  playHook)
			{
			if (frameNum <= 0)
				{
				GDP("irq base time");
				nextFrameTime = Timer.GetMilliTicks ();   // set base start time
				}
			pmsg.nowTime = (fieldOrder == VFLD_SINGLE) ? frameNum/2 : frameNum;
			if (VSTD_NTSC == vStandard)
				// nextFrameNum * 780 * 525 * 1000 / 12 272 727.
				pmsg.nowTime = ScaleDWord (pmsg.nowTime, 4090909L, 136500000);
			else
				pmsg.nowTime = 40 * pmsg.nowTime;
if (pmsg.nowTime == 0)
	GDP("irq nowtime zero, nft %ld", nextFrameTime);
			pmsg.nowTime += nextFrameTime;
			pmsg.baseTime = nextFrameTime;

			GDP("extra call, nbufs %ld", (long)nBuffers);
			pmsg.userData = NULL;
//			pmsg.nowTime = Timer.GetMilliTicks ();
			playHook.Call (pmsg);
			frameNum++;
			}

/*if (frameNum > 10)
	{
	int k, m;
	for (m = 0, k = 0;  k < 4;  k++)
		{
		if (statCom[k] & 1)
			m++;
		}
	if (m > 2)
		{
		DP("stat:  %ld %ld %ld %ld\n", statCom[0] & 1, statCom[1] & 1, statCom[2] & 1, statCom[3] & 1);
		}
	if (nBuffers <= 2)
		{
		DP("am empty\n");
		}
	}
frameNum++;*/
		InPlayInterrupt = FALSE;
		}


#if NT_KERNEL
	irqMutex.LeaveAtIRQLevel();
#endif
	}





Error VirtualJPEGUnit022::AddVideoBuffer (FPTR info, FPTR userData, DWORD size)
	{
	Error err;

#if NT_KERNEL
	irqMutex.Enter();
	if (playAddAllowed)
		err = InternalAddVideoBuffer (info, userData, size);
	else
		err = GNR_JPEG_PIPE_FULL;
	irqMutex.Leave();
#else
	err = InternalAddVideoBuffer (info, userData, size);
#endif
	GNRAISE(err);
	}





Error VirtualJPEGUnit022::InternalAddVideoBuffer (FPTR info, FPTR userData, DWORD size)
	{
	PrepareInfo *prep = (PrepareInfo *)info;
	FragmentTableClass *frag;
	DWORD physical, dummySize;
	DWORD status;


#if NT_KERNEL
	if (info == NULL)
		{
		_asm int 3
		}
#endif
	frag = prep->frag;

	// Finish previous buffers if we're not called from interrupt.
#if NT_KERNEL
	if (! InPlayInterrupt  &&  ! compress  &&  ! manager->handlerEnabled)
#else
	if (! InPlayInterrupt  &&  ! compress)
#endif
		{
		while (nBuffers > 0  &&  ((status = statCom[nextBuffer]) & 0x01))
			{
			nBuffers--;
//GDP("finish b %ld, stat: %ld %ld %ld %ld", (long)nextBuffer, statCom[0] & 1, statCom[1] & 1, statCom[2] & 1, statCom[3] & 1);
			buffers[nextBuffer].info = NULL;   // buffer available for adding another buffer
			nextBuffer = (nextBuffer+1) & (N_DLL_BUFFERS-1);
			}
		}

	// Is the STATCOM table entry available ?
//	if (0 == (statCom[lastBuffer] & 0x01))
	if (nBuffers >= N_DLL_BUFFERS)
		GNRAISE(GNR_JPEG_PIPE_FULL);

#if PLAYBACK_ONE_FRAGMENT
	if (manager->fixPlaybackLongBursts  &&  ! compress  &&  ! stillMode)
		{
		FPTR fptr;
		DWORD dummy;
		if (size > PlaySize)
			GNRAISE(GNR_RANGE_VIOLATION);
		GNREASSERT( frag->GetBufferPointer (fptr, dummy) );
//		GDP("using one fragment");
#if NT_DEBUGOUTPUT
//		DbgPrint ("using one fragment\n");
#endif
#if NT_KERNEL || VXD_VERSION
		memcpy (PlayBufferPtr[lastBuffer], fptr, size);
#else
		hmemcpy (PlayBufferPtr[lastBuffer], fptr, size);
#endif
		frag = PlayBufferFrags[lastBuffer];
		info = frag;
		}
#endif

#if DUMMY_CAPBUFFER
	if (fieldOrder == VFLD_SINGLE  &&  compress)
		{
		if (1 == (lastBuffer & 1))
			{
			prep = (PrepareInfo *)dummyCaptureInfo;
			frag = prep->frag;
			if (! frag->GetBufferFragment (0, physical, dummySize))
				{
				GDP("AddVideoBuffer: single physical not obtained");
				GNRAISE(GNR_OBJECT_NOT_FOUND);   // will never occur
				}
//GDP("filling %ld", (long)lastBuffer);
			statCom[lastBuffer] = physical;   // note that bit zero (STAT_BIT) is cleared !

			buffers[lastBuffer].info     = info;
			buffers[lastBuffer].userData = NULL;
			buffers[lastBuffer].byteSize = dummyCapSize;
			lastBuffer = (lastBuffer+1) & (N_DLL_BUFFERS-1);
			nBuffers++;

			// Is the STATCOM table entry available ?
//			if (0 == (statCom[lastBuffer] & 0x01))
			if (nBuffers >= N_DLL_BUFFERS)
				GNRAISE(GNR_JPEG_PIPE_FULL);

			prep = (PrepareInfo *)info;
			frag = prep->frag;
			}
		}
#endif

	// Get physical address of the fragment and write it to the STATCOM table.
	if (! frag->GetBufferFragment (0, physical, dummySize))
		{
		GDP("AddVideoBuffer: physical not obtained");
		GNRAISE(GNR_OBJECT_NOT_FOUND);   // will never occur
		}
//GDP("filling %ld", (long)lastBuffer);
#if NT_DEBUGOUTPUT
//	DbgPrint ("filling %ld\n", (long)lastBuffer);
#endif

	statCom[lastBuffer] = physical;   // note that bit zero (STAT_BIT) is cleared !

	buffers[lastBuffer].info     = info;
	buffers[lastBuffer].userData = userData;
	buffers[lastBuffer].byteSize = size;
	lastBuffer = (lastBuffer+1) & (N_DLL_BUFFERS-1);
	nBuffers++;

	GNRAISE_OK;
	}





Error VirtualJPEGUnit022::InitPlayback (JPEGPlaybackHook __far *hook)
	{
	int i;
	Error err = GNR_OK;


	// Create stable object state.
	stillExpansion = FALSE;
	InPlayInterrupt = FALSE;
	frameNum = 0;
	nextFrameTime = 0;
	playAddAllowed = TRUE;

	if (changed)
		{
		// Mark all fragments as "status".
		for (i = 0;  i < N_FRAGTABLES;  i++)
			statCom[i] = 0x01;
		for (i = 0;  i < N_DLL_BUFFERS;  i++)
			{
			buffers[i].info     = NULL;
			buffers[i].userData = NULL;
			}
		nextBuffer = 0;
		lastBuffer = 0;
		nBuffers   = 0;
		lastFieldCnt = 255;
#if DEEP_PIPELINE
		statNextBuffer = 0;
		statLastBuffer = 0;
		nStatBuffers = 0;
#endif
		}

	// Check unit state.
	if (GetState() != current)
		GNRAISE(GNR_OBJECT_NOT_CURRENT);
	if (compress  ||  stillMode)
		GNRAISE(GNR_INVALID_CONFIGURE_STATE);

#if VIONA_VERSION
	// Cope with irregular sizes.
	width = (width + 15) & ~15;
	i = (fieldOrder == VFLD_SINGLE ? 7 : 15);
	height = (height + i) & ~i;
#else
	// Width must be a multiple of 16 and height a multiple of 8.
	if (width & 0x0f  ||  height & 0x07)
		GNRAISE(GNR_RANGE_VIOLATION);
#endif

	// Check size restriction.
	if (width > 768  ||  (manager->ccirMode  &&  width > 720))
		GNRAISE(GNR_INVALID_CONFIGURE_STATE);
GDP("playing size %ld,%ld", (long)width, (long)height);

#if PLAYBACK_ONE_FRAGMENT
	if (manager->fixPlaybackLongBursts)
		{
		// If the I22 FIFO is completely full and a new fragment is started, the I22
		// chokes on the code. Fix this bug by either lowering the CodeThreshold for
		// expansion such that a burst filling the FIFO completely is highly unlikely
		// or by using only one code fragment. We choose the latter here.
		DWORD dummy;
		if (PlayBuffers[0] == NULL)
			{
			dummy = PoolContDMABuffer::LargestBlocksize ();
			if (dummy > 0)
				PlaySize = dummy / N_DLL_BUFFERS;
			GDP("Allocating one-fragment-buffers size %ld", PlaySize);
#if NT_DEBUGOUTPUT
//			DbgPrint("Allocating one-fragment-buffers size %ld\n", PlaySize);
#endif
			for (int i = 0;  i < N_DLL_BUFFERS;  i++)
				{
				PlayBuffers[i] = new PoolContDMABuffer;
				if (PlayBuffers[i] == NULL)
					err = GNR_NOT_ENOUGH_MEMORY;
				else
					{
					err = PlayBuffers[i]->AllocateBuffer (PlaySize);
					if (! IS_ERROR(err))
						{
						PlayBufferFrags[i] = new FragmentTableClass;
						if (PlayBufferFrags[i] == NULL)
							err = GNR_NOT_ENOUGH_MEMORY;
						else
							{
							err = PlayBuffers[i]->GetBuffer (PlayBufferPtr[i], dummy);
							if (! IS_ERROR(err))
								err = PlayBufferFrags[i]->CreateFragmentBuffer (PlayBufferPtr[i], PlaySize);
							}
						}
					}
				if (IS_ERROR(err))
					{
					GDP("  FAILED");
#if NT_DEBUGOUTPUT
					DbgPrint("  FAILED\n");
#endif
					for (i = 0;  i < N_DLL_BUFFERS;  i++)
						{
						delete PlayBufferFrags[i];
						delete PlayBuffers[i];
						PlayBuffers[i] = NULL;
						PlayBufferFrags[i] = NULL;
						}
					GNRAISE(err);
					}
				}
			}
		}
#endif

	// Initialize the operation.
	GNREASSERT( manager->InitOperation (statComPhysical) );
	playHook = hook;
	GNRAISE_OK;
	}





Error VirtualJPEGUnit022::FinishPlayback (void)
	{
#if 1
	int buffer;
	DWORD timeout;

	if (playHook)
		{
		playAddAllowed = FALSE;
		manager->StopIRQs ();
		playHook = NULL;
		}
	if (manager->jpegCoreRunning  &&  running)
		{
		// Wait until the last passed buffer is playing.
		buffer = (lastBuffer+N_DLL_BUFFERS-2) & (N_DLL_BUFFERS-1);
		timeout = Timer.GetMilliTicks () + 400;
		while ((statCom[buffer] & 1) == 0  &&  Timer.GetMilliTicks() < timeout)
			Timer.WaitMilliSecs (5);
		// If there's a timeout, the JPEG core has probably crashed.
		}
	while (nBuffers > 1)
		{
		nBuffers--;
		buffers[nextBuffer].info = NULL;   // buffer available for adding another buffer
		nextBuffer = (nextBuffer+1) & (N_DLL_BUFFERS-1);
		}
#else
	if (playHook)
		{
#if NT_KERNEL
		irqMutex.Enter();
#endif
		int wait = (nBuffers > N_FRAGTABLES) ? N_FRAGTABLES : nBuffers;
		playHook = NULL;
#if NT_KERNEL
		irqMutex.Leave();
#endif
		Timer.WaitMilliSecs (wait*40);   // wait until the last passed buffer has been played
		return manager->StopIRQs ();
		}
#endif
	GNRAISE_OK;
	}





Error VirtualJPEGUnit022::FlushPlayback (DWORD bufferSize)
	{
	PrepareInfo *prep;
	DWORD dummy;
	DWORD copySize;
	FPTR src, dst;
	int buffer, buf2;


	if (bufferSize == 0)
		{
		if (playBackupInfo)
			{
//_asm int 3
			FreeVideoBuffer (playBackupInfo);
			}
		playBackupInfo = NULL;
		playBackupData = NULL;
		playBackupSize = 0;
		GNRAISE_OK;
		}

	if (GetState() != current)
		GDP("FLUSH NOT CURRENT");

	if (nBuffers <= 0)
		GNRAISE_OK;

	GNREASSERT( FinishPlayback () );

	buffer = (lastBuffer+N_DLL_BUFFERS-1) & (N_DLL_BUFFERS-1);
//GDP("flush a %ld, stat: %ld %ld %ld %ld", (long)buffer, statCom[0] & 1, statCom[1] & 1, statCom[2] & 1, statCom[3] & 1);
//GDP("  %lx, %lx", playBackupInfo, buffers[buffer].info);
	if (playBackupInfo == buffers[buffer].info)
		{
		GDP("flush save buffer");
		}
	else
		{
		copySize = buffers[buffer].byteSize;
		if (copySize > bufferSize)
			bufferSize = copySize;
		if (playBackupInfo != NULL  &&  bufferSize > playBackupSize)
			{
//_asm int 3
			FreeVideoBuffer (playBackupInfo);
			playBackupInfo = NULL;
			playBackupSize = 0;
			}
		if (playBackupInfo == NULL)
			{
			GNREASSERT( AllocateVideoBuffer (bufferSize, playBackupInfo, playBackupData) );
			playBackupSize = bufferSize;
			}
		// A DMA board will display one of the buffers. This buffer must be saved
		// to be able to free the playback pipeline.
		if (manager->fixPlaybackLongBursts  &&  ! compress  &&  ! stillMode)
			{
			GNREASSERT( ((FragmentTableClass *)buffers[buffer].info)->GetBufferPointer (src, dummy) );
			}
		else
			{
			prep = (PrepareInfo *)buffers[buffer].info;
			GNREASSERT( prep->frag->GetBufferPointer (src, dummy) );
			}
		prep = (PrepareInfo *)playBackupInfo;
		GNREASSERT( prep->frag->GetBufferPointer (dst, dummy) );
#if NT_KERNEL || VXD_VERSION
		memcpy (dst, src, copySize);
#else
		hmemcpy (dst, src, copySize);
#endif
//GDP("flush b %lx, stat: %ld %ld %ld %ld", playBackupInfo, statCom[0] & 1, statCom[1] & 1, statCom[2] & 1, statCom[3] & 1);
		GNREASSERT( InternalAddVideoBuffer (playBackupInfo, NULL, playBackupSize) );
//GDP("flush c %lx, stat: %ld %ld %ld %ld", playBackupInfo, statCom[0] & 1, statCom[1] & 1, statCom[2] & 1, statCom[3] & 1);
		}

	// Finish previous buffers.
#if 1
	GNREASSERT( FinishPlayback () );
#else
	if (playHook)
		GNREASSERT( FinishPlayback () );
	else
		{
		GDP("wait");
		while ((statCom[buffer] & 1) == 0)   // wait until the last passed buffer is playing
			Timer.WaitMilliSecs (5);
		}
	while (nBuffers > 1)
		{
		nBuffers--;
		buffers[nextBuffer].info = NULL;   // buffer available for adding another buffer
		nextBuffer = (nextBuffer+1) & (N_DLL_BUFFERS-1);
		}
#endif
//GDP("flush d %lx, stat: %ld %ld %ld %ld", playBackupInfo, statCom[0] & 1, statCom[1] & 1, statCom[2] & 1, statCom[3] & 1);

	GNRAISE_OK;
	}





Error VirtualJPEGUnit022::PlayBuffer (FPTR info, DWORD size)
	{
	GNRAISE_OK;
	}





Error VirtualJPEGUnit022::Start (void)
	{
	if (GetState() != current)
		GNRAISE(GNR_OBJECT_NOT_CURRENT);
	else
		{
		if (compress  ||  playHook)
			GNREASSERT( manager->StartIRQs () );
		manager->Start ();
		running = TRUE;
		GNRAISE_OK;
		}
	}





Error VirtualJPEGUnit022::Stop (void)
	{
	if (GetState() != current)
		GNRAISE(GNR_OBJECT_NOT_CURRENT);
	else
		{
		if (jpgMode == I22_MOTION_COMPRESS  &&  ! singleFrame  &&  stoppingCapture == 0)
			{
			// Wait for the next successful frame and then stop immediately.
			stoppingCapture++;
			DWORD timeout = Timer.GetMilliTicks() + 1000;
			while (stoppingCapture < 2  &&  Timer.GetMilliTicks() < timeout)
				;
			}
		manager->Stop ();
		FlushPlayback (0);
		running = FALSE;
#if PLAYBACK_ONE_FRAGMENT
		if (PlayBuffers[0] != NULL  &&  ! compress  &&  ! stillMode)
			{
			GDP("Freeing one-fragment buffers");
			for (int i = 0;  i < N_DLL_BUFFERS;  i++)
				{
				delete PlayBufferFrags[i];
				delete PlayBuffers[i];
				PlayBuffers[i] = NULL;
				PlayBufferFrags[i] = NULL;
				}
			}
#endif
		GNRAISE_OK;
		}
	}





// Preempt the other virtual unit and program our state into the chips.
// We must be the current unit before this call.

Error VirtualJPEGUnit022::Preempt (VirtualUnit *previous)
	{
	VirtualJPEGUnit022 *prev = (VirtualJPEGUnit022 *)previous;
	JPEGMsg msg;


	if (this != previous  &&  GetState() == current)
		{
		GNREASSERT( coder->Activate () );
		manager->io->ClearBit (I22REG_P_RESET);   // reset JPEG process
		manager->z016->Stop ();
		manager->pxoe016Bit->OutBit (LOW);   // disable PXOUT bus
		manager->io->ClearBit (I22REG_ACTIVE);
		manager->io->ClearBit (I22REG_COD_TRNS_EN);
#if VIONA_VERSION
		if (prev != NULL)
			{
			// Switching from playback to still operation blanks the video output.
			if (stillMode  &&  ! prev->stillMode  &&  ! prev->compress  &&  manager->blankUnit != NULL)
				manager->blankUnit->Activate ();
			// Inform the preempted user that his operation is suspended.
			if (prev->preemptHook != NULL)
				{
				msg.userData = NULL;
				prev->preemptHook.Call (msg);
				}
/*			manager->syncSelection->OutByte (SYNCSEL_DECODER);
			manager->decoderSyncEnable->OutBit (HIGH);
			manager->frontEndEnable->OutBit (HIGH);
			manager->videoBusDecode->OutBit (LOW);
*/			}
#else
		manager->syncMUX->OutBit (0);
		if (prev != NULL  &&  prev->preemptHook != NULL)
			{
			// Inform the preempted user that his operation is suspended.
			msg.userData = NULL;
			prev->preemptHook.Call (msg);
			}
#endif
		}
	GNRAISE_OK;
	}





// Calculate the video parameters according to the current state. The horizontal
// and vertical offsets are calculated in difference to the 7110 programming.

void VirtualJPEGUnit022::CalcVideoParameters (void)
	{
	// These arrays define the video window processing parameters for the 7110 as
	// the external sync master, indexed by the video standard (NTSC, PAL, SECAM
	// in that order).

	static int VLineStart [VIDEOSTANDARD_MAX+1] = { 12, 16, 16 };
	static int HPixelStart[VIDEOSTANDARD_MAX+1] = { 47, 83, 83 };

	static int VLineStartCCIR [VIDEOSTANDARD_MAX+1] = { 11, 16, 16 };
	static int HPixelStartCCIR[VIDEOSTANDARD_MAX+1] = { 61, 72, 72 };

	static int VSyncSize [VIDEOSTANDARD_MAX+1] = { 6, 6, 6 };
	static int HSyncStart[VIDEOSTANDARD_MAX+1] = { 640, 768, 768 };
	static int HSyncStartCCIR[VIDEOSTANDARD_MAX+1] = { 720, 720, 720 };
	static int HSyncStartCCIRPlay[VIDEOSTANDARD_MAX+1] = { 733, 730, 730 };

	// For I22 as internal sync master.
	static int VLineStart16 [VIDEOSTANDARD_MAX+1] = { 6, 6, 6 };
	static int HPixelStart16[VIDEOSTANDARD_MAX+1] = { 0, 0, 0 };

	const struct HardVideoParams *hard;


	// Select the JPEG mode. Note that I22_STILL_DECOMPRESS denotes the mode
	// using the still transfer register for expansion.
	if (compress)
		jpgMode = stillMode ? I22_STILL_COMPRESS : I22_MOTION_COMPRESS;
	else
#if PIP_EXPAND
		jpgMode = I22_MOTION_DECOMPRESS;
#else
		jpgMode = stillMode ? I22_STILL_DECOMPRESS : I22_MOTION_DECOMPRESS;
#endif


	if (manager->ccirMode  &&  (compress || ! stillMode))
		hard = (vStandard == VSTD_NTSC) ? &NTSCParams : &PALParams;
	else
		hard = (vStandard == VSTD_NTSC) ? &NTSCSquareParams : &PALSquareParams;


	// Which operation width do we have ?
	if (width > (WORD)hard->activeWidth / 2  ||  jpgMode == I22_STILL_COMPRESS  ||  jpgMode == I22_STILL_DECOMPRESS)
		{
		horDecimation = FALSE;
		opWidth = width;
		}
	else
		{
		horDecimation = TRUE;
		opWidth = width * 2;
		}


	// Which operation height do we have ?
	if (height > (WORD)hard->activeHeight / 2)
		opHeight = height / 2;   // two fields
	else
		opHeight = height;   // one field


	switch (jpgMode)
		{
		case I22_STILL_DECOMPRESS:
#if 0
			// These work, only the horizontal starting point is not correct.
			syncMaster = TRUE;
			vSyncSize  = 6;
			frameTotal = 2 * opHeight + 19;
			hSyncStart = opWidth + 8;
			lineTotal  = opWidth + 32;
			nax        = 1;
			pax        = opWidth;
			nay        = 1;
			pay        = opHeight;
			hOffset = nax - hard->hStart;
			vOffset = nay - hard->vStart - 1;
#else
			syncMaster = TRUE;
			vSyncSize  = 6 + 10;
			frameTotal = 2 * opHeight + 19 + 10;
			hSyncStart = opWidth;
			lineTotal  = opWidth + 32;
			nax        = 1;
			pax        = opWidth;
			nay        = 1;
			pay        = opHeight;
			hOffset = nax - hard->hStart;
			vOffset = nay - hard->vStart - 1;
#endif
			break;

		case I22_STILL_COMPRESS:
			syncMaster = TRUE;
			vSyncSize  = 6;
			frameTotal = 2 * opHeight + 19;
			hSyncStart = opWidth + 8;
			lineTotal  = opWidth + 16;
			nax        = 1;
			pax        = opWidth;
			nay        = 1;
			pay        = opHeight;
			hOffset = nax - hard->hStart;
			vOffset = nay - hard->vStart - 1;
			break;

		case I22_MOTION_DECOMPRESS:
			syncMaster = TRUE;
			if (stillExpansion)
				{
				vSyncSize  = 16;
				frameTotal = hard->totalHeight;
				hSyncStart = manager->ccirMode ? HSyncStart[vStandard] : HSyncStart[vStandard];
				lineTotal  = hard->totalWidth;
				nax        = HPixelStart16[vStandard];
				pax        = opWidth;
				nay        = VLineStart16[vStandard] + 1;
				pay        = opHeight;
				hOffset = nax - hard->hStart;
				vOffset = nay - hard->vStart - 1;
				hOffset += horDecimation ? 24 : 20;
				vOffset += 8;
				}
			else
				{
				vSyncSize  = (vStandard == VSTD_NTSC) ? 17 : 22;
				frameTotal = hard->totalHeight;
				hSyncStart = manager->ccirMode ? HSyncStartCCIRPlay[vStandard] : HSyncStart[vStandard];
				lineTotal  = hard->totalWidth;
#if VIONA_VERSION
				nax        = HPixelStart16[vStandard] + (hard->activeWidth - opWidth) / 2;
				pax        = hard->activeWidth;
				nay        = 1 + (hard->activeHeight/2 - opHeight) / 2;   // + VLineStart16[vStandard];
				pay        = hard->activeHeight / 2;
				hOffset = nax - hard->hStart;
				vOffset = 2*(nay-1) - hard->vStart;
				hOffset += horDecimation ? 24 : 20;
				vOffset += 2;
				if (manager->ccirMode)
					{
					hOffset += 0;
					vOffset += 0;
					}
				if ((hOffset & 1) == 0)
					{
					hOffset--;   // for correct PIP offset, hOffset must be odd
					}
#else
				nax        = HPixelStart16[vStandard];
				pax        = hard->activeWidth;
				nay        = VLineStart16[vStandard] + 1;
				pay        = hard->activeHeight / 2;
				hOffset = nax - hard->hStart;
				vOffset = nay - hard->vStart - 1;
				hOffset += horDecimation ? 24 : 20;
				vOffset += 8;
#endif
				}
			break;

		case I22_MOTION_COMPRESS:
		default:
			syncMaster = FALSE;
#if VIONA_VERSION
			nax        = manager->ccirMode ? HPixelStartCCIR[vStandard] : HPixelStart[vStandard];
			nay        = manager->ccirMode ? VLineStartCCIR[vStandard] : VLineStart[vStandard];
			nax       += (hard->activeWidth - opWidth) / 2;
			nay       += (hard->activeHeight/2 - opHeight) / 2 + 1;
#else
			nax        = HPixelStart[vStandard];
			nay        = VLineStart[vStandard] + 1;
#endif
			if (manager->ccirMode)
				{
				if (vStandard == VSTD_NTSC)
					{
					hOffset = -62;
					vOffset = 4;
					}
				else
					{
					hOffset = -61;
					vOffset = -12;
					}
				}
			else
				{
				hOffset = 0;   // 7110 drives video bus
				vOffset = 0;
				}
			// unimportant:
			vSyncSize  = 6;
			frameTotal = hard->totalHeight;
			hSyncStart = manager->ccirMode ? HSyncStartCCIR[vStandard] : HSyncStart[vStandard];
			lineTotal  = hard->totalWidth;
			pax        = hard->activeWidth;
			pay        = hard->activeHeight / 2;
			break;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\jpeg\specific\Z016.H ===
// FILE:      library\hardware\jpeg\generic\z016.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   05.04.95
//
// PURPOSE: The class for the Zoran ZR36016 Motion JPEG controller.
//
// HISTORY:

#ifndef Z016_H
#define Z016_H

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"
#include "library\lowlevel\hardwrio.h"
#include "library\hardware\video\generic\vidtypes.h"
#include "library\support\gfxdebug\gfxdebug.h"



// When you use the Z016 configuration, note that it has a default setting
// defined by the constructor. Change only those settings that you need.

class Z016_CONFIG
	{
	public:
		Z016_CONFIG (void);

		BOOL compress;             // compression or expansion ?
		BOOL stillMode;            // still or motion mode ?
		BOOL thumbnail;
		BOOL colFiltersOn;
		BOOL horFilterOn;
		BOOL hDecimation;          // horizontal decimation ?
		BOOL vDecimation;          // vertical decimation ?
		BOOL doubleClock;
		BOOL ccirLevels;
		BIT syen;
		VideoFormat vbusFormat;    // on video bus side
		VideoFormat coderFormat;   // on 050 side
		VideoFormat pxoutFormat;   // 016 driving video bus in expansion
		int top, left;
		int width, height;
	};

typedef Z016_CONFIG __far *LP_Z016_CONFIG;



class Z016Class
	{
	protected:
		ByteIndexedInOutPort *port;

	public:
		Z016Class (ByteIndexedInOutPort *port) {this->port = port;}

		BOOL Configure (LP_Z016_CONFIG cfg);
		void Start (void) {port->OutByte(0, 0x01);}
		void Stop  (void) {port->OutByte(0, 0x00);}
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\memory\generic\eeprom.h ===
#ifndef EEPROM_H
#define EEPROM_H

#include "library\lowlevel\hardwrio.h"


enum EEPROMOrganisation
	{
	EEPROM_ORG_8,
	EEPROM_ORG_16
	};

class EEPROM
	{
	protected:
	public:
		virtual Error Erase(int at) = 0;
		virtual Error EraseAll() = 0;
		virtual Error ProgramEnable(BOOL enable) = 0;
	};
	
class WordEEPROM : public EEPROM, public WordIndexedInOutPort
	{
	protected:
		EEPROMOrganisation org;
	public:
		WordEEPROM() {org = EEPROM_ORG_16;}

		virtual Error OutWord(int at, WORD data) = 0;
		virtual Error InWord(int at, WORD __far &data) = 0;
	};

class ByteEEPROM : public EEPROM, public ByteIndexedInOutPort
	{
	protected:
		EEPROMOrganisation org;
	public:
		ByteEEPROM() {org = EEPROM_ORG_8;}

		virtual Error OutByte(int at, BYTE data) = 0;
		virtual Error InByte(int at, BYTE __far &data) = 0;
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\jpeg\specific\Z055.h ===
// FILE:      library\hardware\jpeg\generic\z055.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1996 Viona Development.  All Rights Reserved.
// CREATED:   02.02.96
//
// PURPOSE: The ZR36055 motion JPEG controller class.
//
// HISTORY:

#ifndef Z055_H
#define Z055_H

#include "library\lowlevel\hardwrio.h"
#include "library\lowlevel\dmabuffr.h"
#include "library\lowlevel\intrctrl.h"
#include "library\hardware\video\generic\vidtypes.h"

#include "library\support\gfxdebug\gfxdebug.h"



#define H55_N_BUFFERS  4



// 055 registers

#define H55REG_CODMEM      0x0   // WORD
#define H55REG_050_ADDRESS 0x2   // WORD
#define H55REG_050_DATA    0x4

#define H55REG_STATUS0    0x5
#define H55IDX_FNV         5
#define H55REG_FNV         H55REG_STATUS0, H55IDX_FNV
#define H55IDX_STRP_AVAL   4
#define H55REG_STRP_AVAL   H55REG_STATUS0, H55IDX_STRP_AVAL
#define H55IDX_RDY         3
#define H55REG_RDY         H55REG_STATUS0, H55IDX_RDY
#define H55IDX_LASTPAGE    0, 2
#define H55REG_LASTPAGE    H55REG_STATUS0, H55IDX_LASTPAGE

#define H55REG_LEN0       0x6
#define H55REG_LEN1       0x7

#define H55REG_CMD0       0x9
#define H55IDX_FAST        7
#define H55REG_FAST        H55REG_CMD0, H55IDX_FAST
#define H55IDX_FFI         6
#define H55REG_FFI         H55REG_CMD0, H55IDX_FFI
#define H55IDX_GRESET      5
#define H55REG_GRESET      H55REG_CMD0, H55IDX_GRESET
#define H55IDX_VID422      4
#define H55REG_VID422      H55REG_CMD0, H55IDX_VID422
#define H55IDX_EXP         3
#define H55REG_EXP         H55REG_CMD0, H55IDX_EXP
#define H55IDX_STILL       2
#define H55REG_STILL       H55REG_CMD0, H55IDX_STILL
#define H55IDX_PAGE        0, 2
#define H55REG_PAGE        H55REG_CMD0, H55IDX_PAGE

#define H55REG_CMD1       0xA
#define H55IDX_VID_FORMAT  7
#define H55REG_VID_FORMAT  H55REG_CMD1, H55IDX_VID_FORMAT
#define H55IDX_INT_EN      6
#define H55REG_INT_EN      H55REG_CMD1, H55IDX_INT_EN
#define H55IDX_CLK_EN      5
#define H55REG_CLK_EN      H55REG_CMD1, H55IDX_CLK_EN
#define H55IDX_SNC_SRC     4
#define H55REG_SNC_SRC     H55REG_CMD1, H55IDX_SNC_SRC
#define H55IDX_HOR_DEC     3
#define H55REG_HOR_DEC     H55REG_CMD1, H55IDX_HOR_DEC
#define H55IDX_VER_DEC     2
#define H55REG_VER_DEC     H55REG_CMD1, H55IDX_VER_DEC
#define H55IDX_CBUF_SIZE   1
#define H55REG_CBUF_SIZE   H55REG_CMD1, H55IDX_CBUF_SIZE
#define H55IDX_ACTIVE_N    0
#define H55REG_ACTIVE_N    H55REG_CMD1, H55IDX_ACTIVE_N

#define H55REG_CMD2       0x8
#define H55IDX_STRP_SIZE   7
#define H55REG_STRP_SIZE   H55REG_CMD2, H55IDX_STRP_SIZE
#define H55IDX_VID_FILT    6
#define H55REG_VID_FILT    H55REG_CMD2, H55IDX_VID_FILT
#define H55IDX_ID          0, 6
#define H55REG_ID          H55REG_CMD2, H55IDX_ID

#define H55REG_FCNT       0xB
#define H55REG_STRIPBUFF  0xC   // WORD
#define H55REG_IMAGE_SIZE 0xE   // WORD



class Z055
	{
	private:
		IndexedInOutPort *io;
		BOOL fastClock, codeBuf256K, stripBuf32K;   // hardware restrictions
		BYTE defCmd0, defCmd1, defCmd2;

		DWORD cmd0, cmd1, cmd2;   // caching the hardware registers
		BYTE fieldCount, status;
		WORD length;

		BOOL stillMode;

		void SetImageDimension (WORD mask, WORD dimension);

	public:
		Z055 (IndexedInOutPort *io, BOOL fastClock, BOOL codeBuf256K, BOOL stripBuf32K);

		BOOL IsPresent (void);

		void Reset (void);
		void StartActivity (void);
		void StopActivity (void);

		void ReadStatus (void);
		WORD GetFieldLength (void) {return length;}
		BYTE GetFieldCount (void) {return fieldCount;}
		BYTE GetPageNum (void) {return (BYTE)XTBF(H55IDX_LASTPAGE, status);}

		void SetPageNum (BYTE num);

		void SetBlocksInStrip (WORD blocks, BOOL lastStrip);

		BOOL NewStatusReady (void)
			{ io->InByte (H55REG_STATUS0, status); return XTBF(H55IDX_RDY, status) != 0; }

		BOOL StripReady (void)
			{ io->InByte (H55REG_STATUS0, status); return XTBF(H55IDX_STRP_AVAL, status) != 0; }

		BOOL InitOperation (BOOL compress, BOOL stillMode, VideoStandard vStd,
		                    VideoFormat vFormat, VideoField fieldOrder,
		                    BOOL filtering, WORD width, WORD height);
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\memory\generic\eeprommem.h ===
// FILE:      eeprommem.h
// AUTHOR:    S. Herr
// COPYRIGHT: (c) 1999 VIONA Development GmbH & Co. KG.  All Rights Reserved.
// CREATED:   21.09.1999
//
// PURPOSE:   General EEPROM memory classes
//
// HISTORY:   

#ifndef EEPROMMEM_H
#define EEPROMMEM_H

#include "eeprom.h"

class ByteEEPROMMemory
	{
	private:
		BYTE			*	buffer;
		ByteEEPROM	*	eeprom;
		int				size;
		BOOL				dirty;

	public:
		ByteEEPROMMemory(ByteEEPROM * eeprom, int size);
		virtual	~ByteEEPROMMemory();

		void	ClearAll(BYTE value);

		Error	LoadAll();
		Error	StoreAll();
		Error	StorePartial(int from, int length);

		BOOL	CheckDirty() {return dirty;}

		BYTE	CalculateChecksum(int from, int length);

		BYTE	GetByte(int at) {return buffer[at];}
		void	PutByte(int at, BYTE data) {buffer[at] = data; dirty = TRUE;}
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\memory\specific\mweeprom.h ===
#ifndef MWEEPROM_H
#define MWEEPROM_H

#include "..\generic\eeprom.h"

class MicroWireEEPROM : public WordEEPROM
	{
	private:
		BitOutputPort * cs;
		BitOutputPort * sk;
		BitOutputPort * dw;
		BitInputPort  * dr;

		BOOL				 programEnable;
	protected:	
		Error OutBit(BIT bit);
		Error InBit(BIT __far & bit);
	public:
		MicroWireEEPROM(BitOutputPort * cs,
							 BitOutputPort * sk,
							 BitOutputPort * dw,
							 BitInputPort  * dr);

		Error ProgramEnable(BOOL enable);

		Error OutWord(int at, WORD data);
		Error InWord(int at, WORD __far &data);
	
		Error Erase(int at) {GNRAISE(GNR_UNIMPLEMENTED);}
		Error	EraseAll() {GNRAISE(GNR_UNIMPLEMENTED);}
	};


class MicroWireEEPROMMemory
	{
	private:
		WORD			*	buffer;
		WordEEPROM	*	eeprom;
		int				size;
		BOOL				dirty;
	public:
		MicroWireEEPROMMemory(WordEEPROM * eeprom, int size);
		virtual	~MicroWireEEPROMMemory();

		void	ClearAll(WORD value);

		Error	LoadAll();
		Error	StoreAll();
		Error	StorePartial(int from, int length);

		BOOL	CheckDirty() {return dirty;}

		WORD	CalculateChecksum(int from, int length);

		WORD	GetWord(int at) {return buffer[at];}
		void	PutWord(int at, WORD data) {buffer[at] = data; dirty = TRUE;}
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\generic\mp2avspd.h ===
// FILE:      library\hardware\mpeg2dec\generic\mp2avspd.h
// AUTHOR:    U. Sigmund, S. Herr
// COPYRIGHT: (c) 1999 VIONA Development GmbH.  All Rights Reserved.
// CREATED:   
//
// PURPOSE:   MPEG2 Audio/Video Split Decoder Class
//
// HISTORY:

#ifndef MP2AVSPD_H
#define MP2AVSPD_H

#include "mpeg2dec.h"

class MPEG2AVSplitDecoder : public MPEG2AVDecoder
	{               
	friend class VirtualMPEG2AVSplitDecoder;
	protected:
		MPEG2VideoDecoder 			*	videoDecoder;
		MPEG2AudioDecoder 			*	audioDecoder;
		MPEG2AC3Decoder			   *	ac3Decoder;
#if VIONA_VERSION
		GenericSPUDecoder				*	spuDecoder;
		MPEG2DVDDecryption			*	decryption;
#endif		

		MPEG2StreamDemux				*	demux;
		VirtualMPEG2VideoDecoder	*	virtualVideoDecoder;
		VirtualMPEG2AudioDecoder	*	virtualAudioDecoder;
		VirtualMPEG2AC3Decoder		*	virtualAC3Decoder;
#if WDM_VERSION
		MPEG2CCPacketHookHandle			ccPacketHook;
#endif

		Error SetAudioBitrate(DWORD rate);
		Error SetSampleRate(WORD rate); 
		Error SetBitsPerSample(WORD bits);
		Error SetChannels(WORD channels);

		Error SetLeftVolume(WORD volume);
		Error SetRightVolume(WORD volume);
		Error SetMute(BOOL mute);

		Error SetBassConfig(AC3BassConfig config);
		Error SetSpeakerConfig(AC3SpeakerConfig config);
		Error SetCenterDelay(WORD delay);
		Error SetSurroundDelay(WORD delay);      

		Error SetCenterVolume(WORD volume);
		Error SetLeftSurroundVolume(WORD volume);
		Error SetRightSurroundVolume(WORD volume);
		Error SetSubwooferVolume(WORD volume);

		Error SetVideoBitrate(DWORD videoBitrate);
		Error SetVideoWidth(WORD width);
		Error SetVideoHeight(WORD height);             
		Error SetVideoFPS(WORD fps);
		Error SetAspectRatio(WORD aspectRatio);
		Error SetVideoStandard(VideoStandard	standard);
		Error SetStreamType(MPEGStreamType streamType);
		Error SetStreamMode(MPEGStreamMode streamMode);
      Error SetVideoStreamID(BYTE id);
      Error SetAudioStreamID(BYTE id);
		Error SetAC3StreamID(BYTE id);  
#if VIONA_VERSION
		Error SetPresentationMode(MPEG2PresentationMode presentationMode);
   	Error SetDVDStreamDemux(BOOL dvdDemux);
		
		Error SetLPCMStreamID(BYTE id);
		Error SetDTSStreamID(BYTE id);
      Error SetSPUStreamID(BYTE id);
      Error SetSPUEnable(BOOL enable);

      Error SetSPUButtonState(SPUButtonState state);
      Error SetSPUButtonPosition(int x, int y, int width, int height);
      Error SetSPUButtonColors(DWORD selected, DWORD active);
      Error SetSPUPaletteEntry(int p, int y, int u, int v);
      Error SetSPUCommandHook(MPEG2SPUCommandHookHandle hook);

      Error DoAuthenticationCommand(MPEG2DVDAuthenticationCommand com, DWORD sector, BYTE __far * key);

#if WDM_VERSION
		Error	SetCCPacketHook(MPEG2CCPacketHookHandle hook);
#endif
		DWORD SendDataSplit(MPEGElementaryStreamType type, HPTR data, DWORD size, LONG time);
		void CompleteDataSplit(MPEGElementaryStreamType type);
		void RestartDataSplit(MPEGElementaryStreamType type);

#endif      
	public:
		MPEG2AVSplitDecoder(MPEG2VideoDecoder 	* videoDecoder,
		                    MPEG2AudioDecoder 	* audioDecoder,
#if VIONA_VERSION
		                    MPEG2AC3Decoder   	* ac3Decoder = NULL,
		                    GenericSPUDecoder	* spuDecoder = NULL,
		                    MPEG2DVDDecryption	* decryption = NULL);
#else
		                    MPEG2AC3Decoder   * ac3Decoder = NULL);
#endif		                    
		~MPEG2AVSplitDecoder(void);		

	   DWORD GetPTS();
	   DWORD SendData(HPTR data, DWORD size);
		DWORD SendDataMultiple (MPEGDataSizePair * data, DWORD size);

		Error GetPlaybackTime (LONG __far & time);

	   Error SendCommand(MPEGCommand com, DWORD param, DWORD __far &tag);
		BOOL CommandPending(DWORD tag);

	   void CompleteData(void);
	   DWORD CurrentLocation(void);
	   DWORD LastTransferLocation(DWORD scale);

		MPEGState CurrentState(void);
			   
	   Error SetSignalPosition(DWORD position);
	   
	   VirtualMPEG2AVDecoder * CreateVirtualMPEGDecoder(void);
		};

#define NUM_VM2AVTAGS	32

	
class VirtualMPEG2AVSplitDecoder : public VirtualMPEG2AVDecoder
	{  
	friend class VM2AVSignalHook;
	friend class VM2AVDoneHook;
	private:
		MPEG2AVSplitDecoder			*	decoder;
	protected:	
		MPEG2StreamDemux				*	demux;
		VirtualMPEG2VideoDecoder	*	videoDecoder;
		VirtualMPEG2AudioDecoder	*	audioDecoder;
		VirtualMPEG2AC3Decoder		*	ac3Decoder;

		Line21Receiver					*	line21Receiver;
		
		class VM2AVSignalHook __far * xtHook;
		class VM2AVDoneHook __far * xdHook;
		
		struct {DWORD vtag, atag;} ptags[NUM_VM2AVTAGS];
		
		int	doneCnt;
		BOOL	scanning;

		Error SignalHookRequest(void);
		Error DoneHookRequest(void);

		DWORD first, last;     
		DWORD locationOffset;
		DWORD	positionBaseScale;

		DWORD	lastSentLocationLow;
		DWORD lastSentLocation;
//		DWORD signalLocation;

		void UpdateLocations (DWORD newBytes);

		WORD	playbackSpeed;

		Error AdvanceTags(void);

		Error GetDisplaySize(WORD __far &width, WORD __far &height);	

		Error PreemptStopPrevious(VirtualUnit * previous);
		Error PreemptChange(VirtualUnit * previous);
		Error PreemptStartNew(VirtualUnit * previous);

	public:
		VirtualMPEG2AVSplitDecoder(MPEG2AVSplitDecoder * decoder, BOOL idle = FALSE);
		~VirtualMPEG2AVSplitDecoder(void);

		Error Configure(TAG __far * tags);

		Error SendCommand(MPEGCommand com, DWORD param, DWORD __far &tag);
		BOOL CommandPending(DWORD tag);
		Error CompleteCommand(DWORD tag);

		DWORD SendData(HPTR data, DWORD size);
		DWORD SendDataMultiple (MPEGDataSizePair * data, DWORD size);
		void CompleteData(void);
		DWORD SendDataSplit(MPEGElementaryStreamType type, HPTR data, DWORD size, LONG time);
		void CompleteDataSplit(MPEGElementaryStreamType type);
		void RestartDataSplit(MPEGElementaryStreamType type);
		DWORD CurrentLocation(void);
		DWORD LastTransferLocation(DWORD scale);

		MPEGState CurrentState(void);

		Error SetLine21Receiver(Line21Receiver * line21Receiver);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\memory\specific\i2ceeprom.h ===
// FILE:      i2ceeprom.h
// AUTHOR:    H.Horak
// COPYRIGHT: (c) 1998 VIONA Development GmbH.  All Rights Reserved.
// CREATED:   19.12.98
//
// PURPOSE:   I2C serial EEPROM class.
//
// HISTORY:   

#ifndef I2CEEPROM_H
#define I2CEEPROM_H

#include "library\lowlevel\hwbusio.h"
#include "..\generic\eeprom.h"

class I2CEEPROM : public ByteEEPROM
	{
	private:
		AsyncByteInOutBus	*port;
		int i2cAddress;
		BOOL extendedAddressing;
		BOOL programEnable;

	public:
		I2CEEPROM (AsyncByteInOutBus *port, int i2cAddress, BOOL extendedAddressing);
		virtual ~I2CEEPROM(void);

		Error ProgramEnable(BOOL enable);

		Error OutByte(int at, BYTE data);
		Error InByte(int at, BYTE __far &data);
	
		Error Erase(int at);
		Error	EraseAll();
	};


class I2CEEPROMMemory
	{
	private:
		BYTE			*	buffer;
		ByteEEPROM	*	eeprom;
		int				size;
		BOOL				dirty;

	public:
		I2CEEPROMMemory(ByteEEPROM * eeprom, int size);
		virtual	~I2CEEPROMMemory();

		void	ClearAll(BYTE value);

		Error	LoadAll();
		Error	StoreAll();
		Error	StorePartial(int from, int length);

		BOOL	CheckDirty() {return dirty;}

		BYTE	CalculateChecksum(int from, int length);

		BYTE	GetByte(int at) {return buffer[at];}
		void	PutByte(int at, BYTE data) {buffer[at] = data; dirty = TRUE;}
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\generic\mp2dcryp.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef MP2DCRYP_H
#define MP2DCRYP_H

#include "library/common/prelude.h"
#include "library/common/gnerrors.h"

#define GNR_CSS_NOT_SUPPORTED			MKERR(ERROR, DECRYPTION, OPERATION, 0x00)
#define GNR_AUTHENTICATION_FAILED	MKERR(ERROR, DECRYPTION, OPERATION, 0x00)

enum MPEG2DVDAuthenticationCommand
	{
	M2D_CHECK_DISK_KEY,				// 0
	M2D_CHECK_TITLE_KEY,          // 1
	M2D_START_AUTHENTICATION,     // 2
	M2D_READ_CHALLENGE_KEY,       // 3
	M2D_WRITE_BUS_KEY,            // 4
	M2D_WRITE_CHALLENGE_KEY,      // 5
	M2D_READ_BUS_KEY,             // 6
	M2D_WRITE_DISK_KEY,           // 7
	M2D_WRITE_TITLE_KEY,          // 8
	M2D_COMPLETE_AUTHENTICATION,  // 9
	M2D_CANCEL_AUTHENTICATION     // 10
	};

#ifndef ONLY_EXTERNAL_VISIBLE

#include "library/lowlevel/hardwrio.h"

class MPEG2DVDDecryption
	{
	public:
		virtual Error DoAuthenticationCommand(MPEG2DVDAuthenticationCommand com, DWORD sector, BYTE __far * key) = 0;
		virtual Error Initialize(void) {GNRAISE_OK;}
		virtual Error PacketReset(void) {GNRAISE_OK;}
	};

class PioneerDecryption : public MPEG2DVDDecryption
	{
	protected:
		BitOutputPort	*	sck;
		BitInputPort	*	mo;
		BitOutputPort	*	mi;
		BitOutputPort	*	ss;
		int					delay;

		BOOL	diskKeyValid;
		BOOL	titleKeyValid;
		DWORD	titleKeySector;

		BYTE buffer[15];

		Error StartTransfer(void);
		Error EndTransfer(void);
		Error TransferByte(BYTE data, BYTE __far & response);

		Error WriteSeq(int reg, int data, ...);
		Error WriteBytes(int reg, int num, BYTE __far * data);
		Error ReadBytes(int reg, int num, BYTE __far * data);
		Error WriteByte(int reg, BYTE data);
		Error ReadByte(int reg, BYTE __far & data);

	public:
		PioneerDecryption(BitOutputPort * sck,
		                  BitInputPort  * mo,
		                  BitOutputPort * mi,
		                  BitOutputPort * ss,
		                  int delay = 3);

		Error DoAuthenticationCommand(MPEG2DVDAuthenticationCommand com, DWORD sector, BYTE __far * key);
		Error Initialize(void);
		Error PacketReset(void);
	};

class ToshibaDecryption : public MPEG2DVDDecryption
	{
	protected:
		ByteOutputPort	*	indexPort;
		ByteInOutPort	*	dataPort;
		ByteOutputPort	*	streamPort;

 		BYTE	reqoMode;
		BYTE	enboMode;
		BOOL	freqDiv16;

		BOOL	diskKeyValid;
		BOOL	titleKeyValid;
		DWORD	titleKeySector;

		Error WriteSeq(int reg, int data, ...);
		Error WriteBytes(int reg, int num, BYTE __far * data);
		Error ReadBytes(int reg, int num, BYTE __far * data);
		Error WriteByte(int reg, BYTE data);
		Error ReadByte(int reg, BYTE __far & data);
	public:
		ToshibaDecryption(ByteOutputPort *	indexPort,
		                  ByteInOutPort 	*	dataPort,
		                  ByteOutputPort	*	streamPort,
		                  BYTE					reqoMode,
		                  BYTE					enboMode,
		                  BOOL					freqDiv16);

		Error DoAuthenticationCommand(MPEG2DVDAuthenticationCommand com, DWORD sector, BYTE __far * key);
		Error Initialize(void);
		Error PacketReset(void);
	};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\generic\mp2demux.h ===
#ifndef MP2DEMUX_H
#define MP2DEMUX_H

#include "..\..\..\common\prelude.h"
#include "..\..\..\general\asncstrm.h"
#include "mp2eldec.h"

class MPEG2StreamMuxAssoc
	{
	private:
		struct Assoc {DWORD mux, elem;} __far * assoc;
		int first;
		int last; 
		int num;
		DWORD lastMux, lastElem;
	public:
		MPEG2StreamMuxAssoc(int num);
		~MPEG2StreamMuxAssoc(void);

		void PutPosition(DWORD mux, DWORD elem);
		DWORD GetMuxPosition(DWORD elem);
		DWORD GetElemPosition(DWORD mux);
		void Reset(void);
	};
	
class MPEG2StreamDemux //: public ASyncOutStream
	{        
	protected:                             
		MPEG2StreamReceiver	*	videoDecoder;
		MPEG2StreamReceiver	*	audioDecoder;
		MPEG2StreamReceiver	*	ac3Decoder;
#if VIONA_VERSION
		MPEG2StreamReceiver	*	lpcmDecoder;
		MPEG2StreamReceiver	*	subPictureDecoder;
		MPEG2StreamReceiver	*	dtsDecoder;
#endif		
		
		BYTE	videoStreamID, audioStreamID, ac3StreamID;
#if VIONA_VERSION
		BYTE	lpcmStreamID, subPictureStreamID, dtsStreamID;
#endif		
		
		int	state;	                      
		
		DWORD	cnt;
		DWORD	length; 
		BYTE 	high, low;    
		BYTE	headerLength;
		WORD	headerRest;
		BYTE	streamID;      
		BYTE	flags, xflags;    
		BYTE	ptss[5];         
		DWORD	pts;
		BOOL	ptsValid;
		DWORD	dts;
		BOOL	dtsValid;
      
      BOOL	mpeg2;

		DWORD ptsOffset, endPTM;
      
		DWORD audioPos;
		DWORD ac3Pos;
#if VIONA_VERSION
		DWORD lpcmPos;
		DWORD	dtsPos;
#endif		
		DWORD muxPos;
	public:
		DWORD videoPos;
		BOOL	dvdDemux, scanMode;
		
		DWORD	ScalePositionToDemux(DWORD muxPos, DWORD scale) 
			{return dvdDemux ? XScaleDWord(muxPos, scale, MP2SR_SCALE_DVDPES) : muxPos;}
		DWORD	ScalePositionFromDemux(DWORD elemPos, DWORD scale) 
			{return dvdDemux ? XScaleDWord(elemPos, MP2SR_SCALE_DVDPES, scale) : elemPos;}

		MPEG2StreamMuxAssoc				*	videoPosAssoc;
		MPEG2StreamMuxAssoc				*	audioPosAssoc;
		MPEG2StreamMuxAssoc				*	ac3PosAssoc;
#if VIONA_VERSION
		MPEG2StreamMuxAssoc				*	lpcmPosAssoc;
		MPEG2StreamMuxAssoc				*	dtsPosAssoc;

		MPEG2StreamDemux(MPEG2StreamReceiver * videoDecoder,	
		                 MPEG2StreamReceiver * audioDecoder,
		                 MPEG2StreamReceiver * ac3Decoder = NULL,
		                 MPEG2StreamReceiver * lpcmDecoder = NULL,
		                 MPEG2StreamReceiver * subPictureDecoder = NULL,
							  MPEG2StreamReceiver * dtsDecoder = NULL);
		~MPEG2StreamDemux(void);
				                 
	   Error SetStreamIDs(BYTE videoStreamID, 
	                      BYTE audioStreamID, 
	                      BYTE ac3StreamID = 0xff, 
	                      BYTE lpcmStreamID = 0xff,
	                      BYTE subPictureStreamID = 0xff,
								 BYTE dtsStreamID = 0xff)
	   	{
	   	if (videoStreamID != 0xff)      this->videoStreamID      = videoStreamID;
	   	if (audioStreamID != 0xff)      this->audioStreamID      = audioStreamID;
	   	if (ac3StreamID != 0xff)        this->ac3StreamID        = ac3StreamID;
	   	if (lpcmStreamID != 0xff)		  this->lpcmStreamID			= lpcmStreamID;
      	if (subPictureStreamID != 0xff) this->subPictureStreamID = subPictureStreamID;
			if (dtsStreamID != 0xff)        this->dtsStreamID        = dtsStreamID;
	   	
	   	GNRAISE_OK;
	   	}
#else
		MPEG2StreamDemux(MPEG2StreamReceiver * videoDecoder,	
		                 MPEG2StreamReceiver * audioDecoder,
		                 MPEG2StreamReceiver * ac3Decoder = NULL);
	   Error SetStreamIDs(BYTE videoStreamID, 
	                      BYTE audioStreamID, 
	                      BYTE ac3StreamID = 0xff)
	   	{
	   	if (videoStreamID != 0xff)      this->videoStreamID      = videoStreamID;
	   	if (audioStreamID != 0xff)      this->audioStreamID      = audioStreamID;
	   	if (ac3StreamID != 0xff)        this->ac3StreamID        = ac3StreamID;
	   	
	   	GNRAISE_OK;
	   	}
#endif		
	                
		void Reset(void);
		void ResetAudio(void);
		
		DWORD SendData(HPTR data, DWORD size);
		void CompleteData(void);              
	};
	

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\specific\audpatch5505.h ===
// Audio Patch 7_8, 05/31/1999

#define AUDIO_PATCH_3_1_SIZE	9404		
#define AUDIO_PATCH_3_2_SIZE	6092

BYTE AudioPatchCut_3_1[AUDIO_PATCH_3_1_SIZE] = 
	{
	0x17, 0x01, 0x28, 0x00, 0x29, 0x00, 0x28, 0x00, 0x20, 0x36, 0x21, 0x01, 0x2a, 0x1e, 0x2a, 0x18, 
	0x28, 0x01, 0x20, 0x2b, 0x21, 0x02, 0x2a, 0x1e, 0x2a, 0x18, 0x28, 0x02, 0x20, 0xd9, 0x21, 0x13, 
	0x2a, 0x1e, 0x2a, 0x18, 0x28, 0x03, 0x20, 0x24, 0x21, 0x15, 0x2a, 0x1e, 0x2a, 0x18, 0x28, 0x04, 
	0x20, 0x5e, 0x21, 0x15, 0x2a, 0x1e, 0x2a, 0x18, 0x28, 0x05, 0x20, 0xb1, 0x21, 0x15, 0x2a, 0x1e, 
	0x2a, 0x18, 0x28, 0x06, 0x20, 0xf4, 0x21, 0x15, 0x2a, 0x1e, 0x2a, 0x18, 0x28, 0x07, 0x20, 0x6e, 
	0x21, 0x1f, 0x2a, 0x1e, 0x2a, 0x18, 0x28, 0x08, 0x20, 0x68, 0x21, 0x25, 0x2a, 0x1e, 0x2a, 0x18, 
	0x28, 0x09, 0x20, 0xd9, 0x21, 0x25, 0x2a, 0x1e, 0x2a, 0x18, 0x28, 0x0a, 0x20, 0x5a, 0x21, 0x2a, 
	0x2a, 0x1e, 0x2a, 0x18, 0x28, 0x0b, 0x20, 0xc8, 0x21, 0x2a, 0x2a, 0x1e, 0x2a, 0x18, 0x28, 0x0c, 
	0x20, 0x1b, 0x21, 0x2b, 0x2a, 0x1e, 0x2a, 0x18, 0x28, 0x0d, 0x20, 0x6a, 0x21, 0x2b, 0x2a, 0x1e, 
	0x2a, 0x18, 0x28, 0x0e, 0x20, 0xbc, 0x21, 0x2b, 0x2a, 0x1e, 0x2a, 0x18, 0x28, 0x0f, 0x20, 0x23, 
	0x21, 0x34, 0x2a, 0x1e, 0x2a, 0x18, 0x2a, 0x1d, 0x28, 0x00, 0x29, 0x00, 0x20, 0x7a, 0x21, 0x40, 
	0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x01, 0x29, 0x00, 0x20, 0x84, 
	0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x02, 0x29, 0x00, 
	0x20, 0xa2, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x03, 
	0x29, 0x00, 0x20, 0xc0, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x04, 0x29, 0x00, 0x20, 0x49, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x05, 0x29, 0x00, 0x20, 0xc6, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x06, 0x29, 0x00, 0x20, 0xcd, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x07, 0x29, 0x00, 0x20, 0x75, 0x21, 0x40, 0x22, 0x01, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x08, 0x29, 0x00, 0x20, 0x7f, 0x21, 0x41, 
	0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x09, 0x29, 0x00, 0x20, 0xf6, 
	0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x0a, 0x29, 0x00, 
	0x20, 0x5e, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x0b, 
	0x29, 0x00, 0x20, 0x53, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x0c, 0x29, 0x00, 0x20, 0x11, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x0d, 0x29, 0x00, 0x20, 0x8b, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x0e, 0x29, 0x00, 0x20, 0x91, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x0f, 0x29, 0x00, 0x20, 0x26, 0x21, 0x40, 0x22, 0x01, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x10, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x11, 0x29, 0x00, 0x20, 0x4e, 
	0x21, 0x00, 0x22, 0x4e, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x12, 0x29, 0x00, 
	0x20, 0x1c, 0x21, 0x2b, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x13, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x14, 0x29, 0x00, 0x20, 0x9e, 0x21, 0x0c, 0x22, 0x7f, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x15, 0x29, 0x00, 0x20, 0x94, 0x21, 0x0c, 0x22, 0x6b, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x16, 0x29, 0x00, 0x20, 0x01, 0x21, 0x00, 0x22, 0x6d, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x17, 0x29, 0x00, 0x20, 0x00, 0x21, 0x30, 0x22, 0x3e, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x18, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0xf7, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x19, 0x29, 0x00, 0x20, 0xf4, 
	0x21, 0x0c, 0x22, 0x63, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x1a, 0x29, 0x00, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0xe1, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x1b, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x7f, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x1c, 0x29, 0x00, 0x20, 0x22, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x1d, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x49, 0x23, 0x03, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x1e, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x39, 0x23, 0x07, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x1f, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xac, 
	0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x20, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x80, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x21, 0x29, 0x00, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0xe1, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x22, 0x29, 0x00, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0x49, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x23, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x39, 0x23, 0x07, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x24, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xe6, 0x23, 0x08, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x25, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x26, 0x29, 0x00, 0x20, 0x02, 0x21, 0x0d, 0x22, 0x26, 0x23, 0x02, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x27, 0x29, 0x00, 0x20, 0x00, 0x21, 0x78, 0x22, 0x3e, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x28, 0x29, 0x00, 0x20, 0xae, 0x21, 0x0c, 
	0x22, 0x24, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x29, 0x29, 0x00, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0xb1, 0x23, 0x05, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x2a, 0x29, 0x00, 
	0x20, 0x12, 0x21, 0x00, 0x22, 0xb9, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x2b, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x2c, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xba, 0x23, 0x04, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x2d, 0x29, 0x00, 0x20, 0x72, 0x21, 0x68, 0x22, 0x0a, 0x23, 0x05, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x2e, 0x29, 0x00, 0x20, 0xdc, 0x21, 0x0c, 0x22, 0x81, 0x23, 0x02, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x2f, 0x29, 0x00, 0x20, 0x70, 0x21, 0x30, 0x22, 0x15, 
	0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x30, 0x29, 0x00, 0x20, 0xee, 0x21, 0x0c, 
	0x22, 0x81, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x31, 0x29, 0x00, 0x20, 0x83, 
	0x21, 0x30, 0x22, 0x15, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x32, 0x29, 0x00, 
	0x20, 0xf6, 0x21, 0x0c, 0x22, 0x81, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x33, 
	0x29, 0x00, 0x20, 0xab, 0x21, 0x33, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x34, 0x29, 0x00, 0x20, 0xe2, 0x21, 0x0c, 0x22, 0x26, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x35, 0x29, 0x00, 0x20, 0xd8, 0x21, 0x0c, 0x22, 0x7f, 0x23, 0x02, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x36, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xd5, 0x23, 0x08, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x37, 0x29, 0x00, 0x20, 0xd8, 0x21, 0x0c, 0x22, 0x81, 
	0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x38, 0x29, 0x00, 0x20, 0xde, 0x21, 0x0c, 
	0x22, 0x7f, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x39, 0x29, 0x00, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0xd5, 0x23, 0x08, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x3a, 0x29, 0x00, 
	0x20, 0xde, 0x21, 0x0c, 0x22, 0x81, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x3b, 
	0x29, 0x00, 0x20, 0xfc, 0x21, 0x0c, 0x22, 0x7f, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x3c, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xd5, 0x23, 0x08, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x3d, 0x29, 0x00, 0x20, 0xfc, 0x21, 0x0c, 0x22, 0x81, 0x23, 0x02, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x3e, 0x29, 0x00, 0x20, 0xe8, 0x21, 0x0c, 0x22, 0x7f, 0x23, 0x02, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x3f, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xd5, 
	0x23, 0x08, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x40, 0x29, 0x00, 0x20, 0xe8, 0x21, 0x0c, 
	0x22, 0x81, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x41, 0x29, 0x00, 0x20, 0xf8, 
	0x21, 0x0c, 0x22, 0x7f, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x42, 0x29, 0x00, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0xd5, 0x23, 0x08, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x43, 
	0x29, 0x00, 0x20, 0xf8, 0x21, 0x0c, 0x22, 0x81, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x44, 0x29, 0x00, 0x20, 0xfe, 0x21, 0x0c, 0x22, 0x7f, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x45, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xd5, 0x23, 0x08, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x46, 0x29, 0x00, 0x20, 0xfe, 0x21, 0x0c, 0x22, 0x81, 0x23, 0x02, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x47, 0x29, 0x00, 0x20, 0x14, 0x21, 0x40, 0x22, 0x02, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x48, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x49, 0x29, 0x00, 0x20, 0x14, 
	0x21, 0x90, 0x22, 0x6a, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x4a, 0x29, 0x00, 
	0x20, 0x02, 0x21, 0x00, 0x22, 0x50, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x4b, 
	0x29, 0x00, 0x20, 0x52, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x4c, 0x29, 0x00, 0x20, 0x0e, 0x21, 0x90, 0x22, 0xa5, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x4d, 0x29, 0x00, 0x20, 0x5f, 0x21, 0xf0, 0x22, 0x97, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x4e, 0x29, 0x00, 0x20, 0x0e, 0x21, 0x90, 0x22, 0xa5, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x4f, 0x29, 0x00, 0x20, 0x0e, 0x21, 0x90, 0x22, 0xaa, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x50, 0x29, 0x00, 0x20, 0x71, 0x21, 0x0c, 
	0x22, 0x24, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x51, 0x29, 0x00, 0x20, 0x0e, 
	0x21, 0x90, 0x22, 0xa5, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x52, 0x29, 0x00, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x53, 
	0x29, 0x00, 0x20, 0x1f, 0x21, 0x00, 0x22, 0x57, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x54, 0x29, 0x00, 0x20, 0x1f, 0x21, 0x00, 0x22, 0x8f, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x55, 0x29, 0x00, 0x20, 0x5d, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x56, 0x29, 0x00, 0x20, 0x1e, 0x21, 0x00, 0x22, 0x67, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x57, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x54, 
	0x23, 0x07, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x58, 0x29, 0x00, 0x20, 0x11, 0x21, 0x00, 
	0x22, 0xd6, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x59, 0x29, 0x00, 0x20, 0x00, 
	0x21, 0x40, 0x22, 0x8d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x5a, 0x29, 0x00, 
	0x20, 0x08, 0x21, 0x00, 0x22, 0xbc, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x5b, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x36, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x5c, 0x29, 0x00, 0x20, 0x83, 0x21, 0x28, 0x22, 0x4d, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x5d, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x5e, 0x29, 0x00, 0x20, 0xd9, 0x21, 0x2a, 0x22, 0x02, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x5f, 0x29, 0x00, 0x20, 0xbc, 0x21, 0x0c, 0x22, 0xbe, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x60, 0x29, 0x00, 0x20, 0x80, 0x21, 0x00, 
	0x22, 0x8a, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x61, 0x29, 0x00, 0x20, 0x64, 
	0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x62, 0x29, 0x00, 
	0x20, 0x68, 0x21, 0x40, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x63, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x64, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xf6, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x65, 0x29, 0x00, 0x20, 0x67, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x66, 0x29, 0x00, 0x20, 0x68, 0x21, 0x40, 0x22, 0x02, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x67, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x68, 0x29, 0x00, 0x20, 0x82, 0x21, 0x28, 
	0x22, 0x09, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x69, 0x29, 0x00, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0x25, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x6a, 0x29, 0x00, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0x24, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x6b, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xb9, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x6c, 0x29, 0x00, 0x20, 0x00, 0x21, 0x18, 0x22, 0x93, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x6d, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xdd, 0x23, 0x05, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x6e, 0x29, 0x00, 0x20, 0x83, 0x21, 0x28, 0x22, 0x4f, 0x23, 0x07, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x6f, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xde, 
	0x23, 0x05, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x70, 0x29, 0x00, 0x20, 0x06, 0x21, 0x00, 
	0x22, 0xcf, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x71, 0x29, 0x00, 0x20, 0x73, 
	0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x72, 0x29, 0x00, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0x4e, 0x23, 0x07, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x73, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x4a, 0x23, 0x07, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x74, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x75, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x0c, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x76, 0x29, 0x00, 0x20, 0x76, 0x21, 0x18, 0x22, 0x02, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x77, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x18, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x78, 0x29, 0x00, 0x20, 0x6f, 0x21, 0x1f, 
	0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x79, 0x29, 0x00, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x7a, 0x29, 0x00, 
	0x20, 0x28, 0x21, 0x0c, 0x22, 0x68, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x7b, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x69, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x7c, 0x29, 0x00, 0x20, 0x83, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x7d, 0x29, 0x00, 0x20, 0x0a, 0x21, 0x00, 0x22, 0x6f, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x7e, 0x29, 0x00, 0x20, 0x83, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x7f, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x70, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x80, 0x29, 0x00, 0x20, 0x83, 0x21, 0x40, 
	0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x81, 0x29, 0x00, 0x20, 0x13, 
	0x21, 0x00, 0x22, 0x4e, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x82, 0x29, 0x00, 
	0x20, 0x55, 0x21, 0x00, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x83, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x84, 0x29, 0x00, 0x20, 0x02, 0x21, 0xc0, 0x22, 0x3b, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x85, 0x29, 0x00, 0x20, 0x04, 0x21, 0x00, 0x22, 0x02, 0x23, 0x01, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x86, 0x29, 0x00, 0x20, 0x89, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x87, 0x29, 0x00, 0x20, 0x04, 0x21, 0x00, 0x22, 0xa4, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x88, 0x29, 0x00, 0x20, 0x03, 0x21, 0x00, 
	0x22, 0x25, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x89, 0x29, 0x00, 0x20, 0x28, 
	0x21, 0x0c, 0x22, 0xa5, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x8a, 0x29, 0x00, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x8b, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x0c, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x8c, 0x29, 0x00, 0x20, 0x74, 0x21, 0x2b, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x8d, 0x29, 0x00, 0x20, 0x30, 0x21, 0x29, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x8e, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x18, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x8f, 0x29, 0x00, 0x20, 0x6c, 0x21, 0x2b, 0x22, 0x01, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x90, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x91, 0x29, 0x00, 0x20, 0x16, 
	0x21, 0x90, 0x22, 0xae, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x92, 0x29, 0x00, 
	0x20, 0x03, 0x21, 0x00, 0x22, 0x58, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x93, 
	0x29, 0x00, 0x20, 0xa1, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x94, 0x29, 0x00, 0x20, 0x0c, 0x21, 0xc0, 0x22, 0x2a, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x95, 0x29, 0x00, 0x20, 0xff, 0x21, 0xff, 0x22, 0x72, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x96, 0x29, 0x00, 0x20, 0x10, 0x21, 0xc0, 0x22, 0x2b, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x97, 0x29, 0x00, 0x20, 0x03, 0x21, 0x00, 0x22, 0x4b, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x98, 0x29, 0x00, 0x20, 0x05, 0x21, 0x00, 
	0x22, 0x4d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x99, 0x29, 0x00, 0x20, 0xa1, 
	0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x9a, 0x29, 0x00, 
	0x20, 0x39, 0x21, 0x07, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x9b, 
	0x29, 0x00, 0x20, 0x10, 0x21, 0x00, 0x22, 0x4e, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x9c, 0x29, 0x00, 0x20, 0x08, 0x21, 0xa0, 0x22, 0x1b, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x9d, 0x29, 0x00, 0x20, 0x04, 0x21, 0xa0, 0x22, 0x1c, 0x23, 0x01, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x9e, 0x29, 0x00, 0x20, 0x08, 0x21, 0x00, 0x22, 0x4e, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x9f, 0x29, 0x00, 0x20, 0x08, 0x21, 0xa0, 0x22, 0x1b, 
	0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xa0, 0x29, 0x00, 0x20, 0x04, 0x21, 0xa0, 
	0x22, 0x1c, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xa1, 0x29, 0x00, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xa2, 0x29, 0x00, 
	0x20, 0x32, 0x21, 0x01, 0x22, 0xae, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xa3, 
	0x29, 0x00, 0x20, 0x05, 0x21, 0x00, 0x22, 0x85, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xa4, 0x29, 0x00, 0x20, 0x0f, 0x21, 0x00, 0x22, 0x95, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xa5, 0x29, 0x00, 0x20, 0x02, 0x21, 0x00, 0x22, 0x6f, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xa6, 0x29, 0x00, 0x20, 0xa9, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xa7, 0x29, 0x00, 0x20, 0x0a, 0x21, 0x00, 0x22, 0x8d, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xa8, 0x29, 0x00, 0x20, 0xbe, 0x21, 0x40, 
	0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xa9, 0x29, 0x00, 0x20, 0x03, 
	0x21, 0x00, 0x22, 0x6f, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xaa, 0x29, 0x00, 
	0x20, 0xad, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xab, 
	0x29, 0x00, 0x20, 0x02, 0x21, 0x00, 0x22, 0x8d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xac, 0x29, 0x00, 0x20, 0xbe, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xad, 0x29, 0x00, 0x20, 0x07, 0x21, 0x00, 0x22, 0x6f, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xae, 0x29, 0x00, 0x20, 0xb1, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xaf, 0x29, 0x00, 0x20, 0x09, 0x21, 0x00, 0x22, 0x8d, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xb0, 0x29, 0x00, 0x20, 0xbe, 0x21, 0x40, 
	0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xb1, 0x29, 0x00, 0x20, 0x08, 
	0x21, 0x00, 0x22, 0x6f, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xb2, 0x29, 0x00, 
	0x20, 0xb5, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xb3, 
	0x29, 0x00, 0x20, 0x01, 0x21, 0x00, 0x22, 0x8d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xb4, 0x29, 0x00, 0x20, 0xbe, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xb5, 0x29, 0x00, 0x20, 0x0c, 0x21, 0x00, 0x22, 0x6f, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xb6, 0x29, 0x00, 0x20, 0xb9, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xb7, 0x29, 0x00, 0x20, 0x08, 0x21, 0x00, 0x22, 0x8d, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xb8, 0x29, 0x00, 0x20, 0xbe, 0x21, 0x40, 
	0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xb9, 0x29, 0x00, 0x20, 0x0e, 
	0x21, 0x00, 0x22, 0x6f, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xba, 0x29, 0x00, 
	0x20, 0xbd, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xbb, 
	0x29, 0x00, 0x20, 0x04, 0x21, 0x00, 0x22, 0x8d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xbc, 0x29, 0x00, 0x20, 0xbe, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xbd, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x4c, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xbe, 0x29, 0x00, 0x20, 0xae, 0x21, 0x0c, 0x22, 0x8e, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xbf, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xc0, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x00, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xc1, 0x29, 0x00, 0x20, 0x12, 
	0x21, 0x90, 0x22, 0x6e, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xc2, 0x29, 0x00, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0xb0, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xc3, 
	0x29, 0x00, 0x20, 0xc1, 0x21, 0x40, 0x22, 0x43, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xc4, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x00, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xc5, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xc6, 0x29, 0x00, 0x20, 0x4d, 0x21, 0xf0, 0x22, 0x8f, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xc7, 0x29, 0x00, 0x20, 0x05, 0x21, 0x00, 0x22, 0x9d, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xc8, 0x29, 0x00, 0x20, 0xca, 0x21, 0x40, 
	0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xc9, 0x29, 0x00, 0x20, 0xfe, 
	0x21, 0x00, 0x22, 0x51, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xca, 0x29, 0x00, 
	0x20, 0x16, 0x21, 0x90, 0x22, 0xb8, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xcb, 
	0x29, 0x00, 0x20, 0xbb, 0x21, 0x15, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xcc, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xcd, 0x29, 0x00, 0x20, 0x03, 0x21, 0x00, 0x22, 0x57, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xce, 0x29, 0x00, 0x20, 0x5e, 0x21, 0xf0, 0x22, 0x92, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xcf, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x4d, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xd0, 0x29, 0x00, 0x20, 0xd4, 0x21, 0x40, 
	0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xd1, 0x29, 0x00, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0x96, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xd2, 0x29, 0x00, 
	0x20, 0xd4, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xd3, 
	0x29, 0x00, 0x20, 0x18, 0x21, 0x90, 0x22, 0xaa, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xd4, 0x29, 0x00, 0x20, 0x02, 0x21, 0x90, 0x22, 0x3b, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xd5, 0x29, 0x00, 0x20, 0xfc, 0x21, 0x00, 0x22, 0x57, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xd6, 0x29, 0x00, 0x20, 0xf5, 0x21, 0x15, 0x22, 0x01, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xd7, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xd8, 0x29, 0x00, 0x20, 0x1d, 0x21, 0x08, 
	0x22, 0x63, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xd9, 0x29, 0x00, 0x20, 0xaa, 
	0x21, 0x63, 0x22, 0xb6, 0x23, 0x05, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xda, 0x29, 0x00, 
	0x20, 0x10, 0x21, 0x00, 0x22, 0x5f, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xdb, 
	0x29, 0x00, 0x20, 0xdd, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xdc, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xb0, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xdd, 0x29, 0x00, 0x20, 0x0f, 0x21, 0x00, 0x22, 0xa8, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xde, 0x29, 0x00, 0x20, 0x0a, 0x21, 0x00, 0x22, 0xf2, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xdf, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xac, 
	0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xe0, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0xe4, 0x23, 0x05, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xe1, 0x29, 0x00, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0x72, 0x23, 0x04, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xe2, 0x29, 0x00, 
	0x20, 0xe8, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xe3, 
	0x29, 0x00, 0x20, 0xf1, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xe4, 0x29, 0x00, 0x20, 0xf8, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xe5, 0x29, 0x00, 0x20, 0xff, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xe6, 0x29, 0x00, 0x20, 0x04, 0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xe7, 0x29, 0x00, 0x20, 0x0f, 0x21, 0x41, 0x22, 0x01, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xe8, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x73, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xe9, 0x29, 0x00, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0xd2, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xea, 0x29, 0x00, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0x21, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xeb, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x51, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xec, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xaa, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xed, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x58, 0x23, 0x03, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xee, 0x29, 0x00, 0x20, 0xaa, 0x21, 0x63, 0x22, 0xf9, 0x23, 0x06, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xef, 0x29, 0x00, 0x20, 0xaa, 0x21, 0x63, 0x22, 0x43, 
	0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xf0, 0x29, 0x00, 0x20, 0x19, 0x21, 0x41, 
	0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xf1, 0x29, 0x00, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0x73, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xf2, 0x29, 0x00, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0xd2, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xf3, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xaa, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xf4, 0x29, 0x00, 0x20, 0xaa, 0x21, 0x63, 0x22, 0x43, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xf5, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x58, 0x23, 0x03, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xf6, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xc4, 0x23, 0x04, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xf7, 0x29, 0x00, 0x20, 0x19, 0x21, 0x41, 0x22, 0x01, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xf8, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x51, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xf9, 0x29, 0x00, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0xdf, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xfa, 0x29, 0x00, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0xd2, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xfb, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xaa, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xfc, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x58, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xfd, 0x29, 0x00, 0x20, 0xaa, 0x21, 0x63, 0x22, 0xf9, 0x23, 0x06, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xfe, 0x29, 0x00, 0x20, 0x19, 0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xff, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xd2, 
	0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x00, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x95, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x01, 0x29, 0x01, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0x8e, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x02, 0x29, 0x01, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0xdf, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x03, 
	0x29, 0x01, 0x20, 0x19, 0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x04, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x73, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x05, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xd2, 0x23, 0x02, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x06, 0x29, 0x01, 0x20, 0xaa, 0x21, 0x63, 0x22, 0x43, 0x23, 0x02, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x07, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xaa, 
	0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x08, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x58, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x09, 0x29, 0x01, 0x20, 0xaa, 
	0x21, 0x63, 0x22, 0xf9, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x0a, 0x29, 0x01, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0x52, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x0b, 
	0x29, 0x01, 0x20, 0x19, 0x21, 0x41, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x0c, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xdf, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x0d, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xc4, 0x23, 0x04, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x0e, 0x29, 0x01, 0x20, 0x19, 0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x0f, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x51, 
	0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x10, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0xd2, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x11, 0x29, 0x01, 0x20, 0xaa, 
	0x21, 0x63, 0x22, 0x43, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x12, 0x29, 0x01, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0xaa, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x13, 
	0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x58, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x14, 0x29, 0x01, 0x20, 0xaa, 0x21, 0x63, 0x22, 0xf9, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x15, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x52, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x16, 0x29, 0x01, 0x20, 0x19, 0x21, 0x41, 0x22, 0x2d, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x17, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xdf, 
	0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x18, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0xc4, 0x23, 0x04, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x19, 0x29, 0x01, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0x21, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x1a, 0x29, 0x01, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x1b, 
	0x29, 0x01, 0x20, 0x1a, 0x21, 0x08, 0x22, 0x63, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x1c, 0x29, 0x01, 0x20, 0x0f, 0x21, 0x00, 0x22, 0xa8, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x1d, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xb5, 0x23, 0x04, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x1e, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x21, 0x23, 0x06, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x1f, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xde, 
	0x23, 0x04, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x20, 0x29, 0x01, 0x20, 0x26, 0x21, 0x41, 
	0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x21, 0x29, 0x01, 0x20, 0x33, 
	0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x22, 0x29, 0x01, 
	0x20, 0x40, 0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x23, 
	0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x24, 0x29, 0x01, 0x20, 0x4d, 0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x25, 0x29, 0x01, 0x20, 0x66, 0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x26, 0x29, 0x01, 0x20, 0x08, 0x21, 0x00, 0x22, 0x7f, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x27, 0x29, 0x01, 0x20, 0x7e, 0x21, 0x41, 0x22, 0x2d, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x28, 0x29, 0x01, 0x20, 0xc0, 0x21, 0x00, 
	0x22, 0x9d, 0x23, 0x07, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x29, 0x29, 0x01, 0x20, 0x60, 
	0x21, 0x1c, 0x22, 0x08, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x2a, 0x29, 0x01, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0xdd, 0x23, 0x05, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x2b, 
	0x29, 0x01, 0x20, 0x60, 0x21, 0x00, 0x22, 0x3c, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x2c, 0x29, 0x01, 0x20, 0xa1, 0x21, 0xff, 0x22, 0x3c, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x2d, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x68, 0x23, 0x08, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x2e, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x80, 0x23, 0x06, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x2f, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xe9, 
	0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x30, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x4e, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x31, 0x29, 0x01, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0xfc, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x32, 0x29, 0x01, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x33, 
	0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xd2, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x34, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x87, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x35, 0x29, 0x01, 0x20, 0xc0, 0x21, 0x00, 0x22, 0x9d, 0x23, 0x07, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x36, 0x29, 0x01, 0x20, 0x08, 0x21, 0x00, 0x22, 0x7f, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x37, 0x29, 0x01, 0x20, 0x7e, 0x21, 0x41, 0x22, 0x2d, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x38, 0x29, 0x01, 0x20, 0x60, 0x21, 0x14, 
	0x22, 0x08, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x39, 0x29, 0x01, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0xdd, 0x23, 0x05, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x3a, 0x29, 0x01, 
	0x20, 0x60, 0x21, 0x00, 0x22, 0x3c, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x3b, 
	0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x68, 0x23, 0x08, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x3c, 0x29, 0x01, 0x20, 0xa1, 0x21, 0xff, 0x22, 0x3c, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x3d, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x80, 0x23, 0x06, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x3e, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xfc, 0x23, 0x02, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x3f, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x40, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x8e, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x41, 0x29, 0x01, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0x19, 0x23, 0x08, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x42, 0x29, 0x01, 
	0x20, 0xc0, 0x21, 0x00, 0x22, 0x9d, 0x23, 0x07, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x43, 
	0x29, 0x01, 0x20, 0x08, 0x21, 0x00, 0x22, 0x7f, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x44, 0x29, 0x01, 0x20, 0x7e, 0x21, 0x41, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x45, 0x29, 0x01, 0x20, 0x60, 0x21, 0x14, 0x22, 0x08, 0x23, 0x01, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x46, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xdd, 0x23, 0x05, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x47, 0x29, 0x01, 0x20, 0x60, 0x21, 0x00, 0x22, 0x3c, 
	0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x48, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0xe9, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x49, 0x29, 0x01, 0x20, 0xa1, 
	0x21, 0xff, 0x22, 0x3c, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x4a, 0x29, 0x01, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0x80, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x4b, 
	0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xfc, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x4c, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x4d, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xd2, 0x23, 0x02, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x4e, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x87, 0x23, 0x01, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x4f, 0x29, 0x01, 0x20, 0xc0, 0x21, 0x00, 0x22, 0x9d, 
	0x23, 0x07, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x50, 0x29, 0x01, 0x20, 0x08, 0x21, 0x00, 
	0x22, 0x7f, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x51, 0x29, 0x01, 0x20, 0x5a, 
	0x21, 0x41, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x52, 0x29, 0x01, 
	0x20, 0x60, 0x21, 0x14, 0x22, 0x08, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x53, 
	0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xdd, 0x23, 0x05, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x54, 0x29, 0x01, 0x20, 0x60, 0x21, 0x00, 0x22, 0x3c, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x55, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x68, 0x23, 0x08, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x56, 0x29, 0x01, 0x20, 0xa1, 0x21, 0xff, 0x22, 0x3c, 0x23, 0x06, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x57, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x80, 
	0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x58, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0xfc, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x59, 0x29, 0x01, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x5a, 0x29, 0x01, 
	0x20, 0x0a, 0x21, 0x00, 0x22, 0x7f, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x5b, 
	0x29, 0x01, 0x20, 0x60, 0x21, 0x41, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x5c, 0x29, 0x01, 0x20, 0x60, 0x21, 0x04, 0x22, 0x08, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x5d, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x68, 0x23, 0x08, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x5e, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x87, 0x23, 0x06, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x5f, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x60, 0x29, 0x01, 0x20, 0x60, 0x21, 0x0c, 
	0x22, 0x08, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x61, 0x29, 0x01, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0x68, 0x23, 0x08, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x62, 0x29, 0x01, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0x2a, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x63, 
	0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x80, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x64, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xfc, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x65, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x66, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x8e, 0x23, 0x02, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x67, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x19, 
	0x23, 0x08, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x68, 0x29, 0x01, 0x20, 0xc0, 0x21, 0x00, 
	0x22, 0x9d, 0x23, 0x07, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x69, 0x29, 0x01, 0x20, 0x08, 
	0x21, 0x00, 0x22, 0x7f, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x6a, 0x29, 0x01, 
	0x20, 0x73, 0x21, 0x41, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x6b, 
	0x29, 0x01, 0x20, 0x60, 0x21, 0x14, 0x22, 0x08, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x6c, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xdd, 0x23, 0x05, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x6d, 0x29, 0x01, 0x20, 0x60, 0x21, 0x00, 0x22, 0x98, 0x23, 0x06, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x6e, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xe9, 0x23, 0x06, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x6f, 0x29, 0x01, 0x20, 0xa1, 0x21, 0xff, 0x22, 0x98, 
	0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x70, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x80, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x71, 0x29, 0x01, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0xfc, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x72, 0x29, 0x01, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x73, 
	0x29, 0x01, 0x20, 0x0a, 0x21, 0x00, 0x22, 0x7f, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x74, 0x29, 0x01, 0x20, 0x79, 0x21, 0x41, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x75, 0x29, 0x01, 0x20, 0x60, 0x21, 0x04, 0x22, 0x08, 0x23, 0x01, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x76, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x9e, 0x23, 0x07, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x77, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x3b, 
	0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x78, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x79, 0x29, 0x01, 0x20, 0x60, 
	0x21, 0x0c, 0x22, 0x08, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x7a, 0x29, 0x01, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0xe9, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x7b, 
	0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x2a, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x7c, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x80, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x7d, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xfc, 0x23, 0x02, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x7e, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x7f, 0x29, 0x01, 0x20, 0xaa, 0x21, 0x63, 0x22, 0x7e, 
	0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x80, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x95, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x81, 0x29, 0x01, 0x20, 0xa1, 
	0x21, 0x20, 0x22, 0x2a, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x82, 0x29, 0x01, 
	0x20, 0x89, 0x21, 0x0c, 0x22, 0x24, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x83, 
	0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x2c, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x84, 0x29, 0x01, 0x20, 0x86, 0x21, 0x41, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x85, 0x29, 0x01, 0x20, 0x40, 0x21, 0x02, 0x22, 0xa9, 0x23, 0x04, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x86, 0x29, 0x01, 0x20, 0x1a, 0x21, 0x08, 0x22, 0x8e, 0x23, 0x03, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x87, 0x29, 0x01, 0x20, 0x0f, 0x21, 0x00, 0x22, 0x57, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x88, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x12, 0x23, 0x04, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x89, 0x29, 0x01, 0x20, 0x97, 
	0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x8a, 0x29, 0x01, 
	0x20, 0x97, 0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x8b, 
	0x29, 0x01, 0x20, 0x97, 0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x8c, 0x29, 0x01, 0x20, 0x97, 0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x8d, 0x29, 0x01, 0x20, 0x97, 0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x8e, 0x29, 0x01, 0x20, 0x98, 0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x8f, 0x29, 0x01, 0x20, 0x97, 0x21, 0x41, 0x22, 0x01, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x90, 0x29, 0x01, 0x20, 0x97, 0x21, 0x41, 
	0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x91, 0x29, 0x01, 0x20, 0xa6, 
	0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x92, 0x29, 0x01, 
	0x20, 0x97, 0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x93, 
	0x29, 0x01, 0x20, 0xbf, 0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x94, 0x29, 0x01, 0x20, 0x97, 0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x95, 0x29, 0x01, 0x20, 0x97, 0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x96, 0x29, 0x01, 0x20, 0xd3, 0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x97, 0x29, 0x01, 0x20, 0xea, 0x21, 0x41, 0x22, 0x01, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x98, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x21, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x99, 0x29, 0x01, 0x20, 0x60, 
	0x21, 0x00, 0x22, 0x7d, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x9a, 0x29, 0x01, 
	0x20, 0xc0, 0x21, 0x00, 0x22, 0x81, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x9b, 
	0x29, 0x01, 0x20, 0x1d, 0x21, 0x08, 0x22, 0x63, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x9c, 0x29, 0x01, 0x20, 0x10, 0x21, 0x00, 0x22, 0x84, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x9d, 0x29, 0x01, 0x20, 0xea, 0x21, 0x41, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x9e, 0x29, 0x01, 0x20, 0xaa, 0x21, 0x63, 0x22, 0x3b, 0x23, 0x03, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x9f, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xac, 
	0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xa0, 0x29, 0x01, 0x20, 0x60, 0x21, 0x0c, 
	0x22, 0x08, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xa1, 0x29, 0x01, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0xb8, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xa2, 0x29, 0x01, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0xb9, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xa3, 
	0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x86, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xa4, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x87, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xa5, 0x29, 0x01, 0x20, 0xea, 0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xa6, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x21, 0x23, 0x06, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xa7, 0x29, 0x01, 0x20, 0x60, 0x21, 0x00, 0x22, 0x74, 
	0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xa8, 0x29, 0x01, 0x20, 0xc0, 0x21, 0x00, 
	0x22, 0x4e, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xa9, 0x29, 0x01, 0x20, 0xd8, 
	0x21, 0x40, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xaa, 0x29, 0x01, 
	0x20, 0x60, 0x21, 0x00, 0x22, 0x74, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xab, 
	0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xd4, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xac, 0x29, 0x01, 0x20, 0xbd, 0x21, 0x41, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xad, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xe9, 0x23, 0x06, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xae, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x31, 0x23, 0x02, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xaf, 0x29, 0x01, 0x20, 0x60, 0x21, 0x2c, 0x22, 0x08, 
	0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xb0, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0xba, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xb1, 0x29, 0x01, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0xe9, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xb2, 0x29, 0x01, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0x8c, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xb3, 
	0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x68, 0x23, 0x08, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xb4, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x26, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xb5, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x13, 0x23, 0x03, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xb6, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x8c, 0x23, 0x06, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xb7, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xb1, 
	0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xb8, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x13, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xb9, 0x29, 0x01, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0xe9, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xba, 0x29, 0x01, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0x31, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xbb, 
	0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xbd, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xbc, 0x29, 0x01, 0x20, 0xea, 0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xbd, 0x29, 0x01, 0x20, 0x1b, 0x21, 0x41, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xbe, 0x29, 0x01, 0x20, 0xea, 0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xbf, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x21, 
	0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xc0, 0x29, 0x01, 0x20, 0xc0, 0x21, 0x00, 
	0x22, 0x74, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xc1, 0x29, 0x01, 0x20, 0x60, 
	0x21, 0x00, 0x22, 0x7d, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xc2, 0x29, 0x01, 
	0x20, 0x80, 0x21, 0x01, 0x22, 0x4e, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xc3, 
	0x29, 0x01, 0x20, 0xd8, 0x21, 0x40, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xc4, 0x29, 0x01, 0x20, 0xc0, 0x21, 0x00, 0x22, 0x74, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xc5, 0x29, 0x01, 0x20, 0x60, 0x21, 0x20, 0x22, 0x08, 0x23, 0x01, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xc6, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x68, 0x23, 0x08, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xc7, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x26, 
	0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xc8, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0xb8, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xc9, 0x29, 0x01, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0x31, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xca, 0x29, 0x01, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0xc2, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xcb, 
	0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xe9, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xcc, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xbf, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xcd, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x86, 0x23, 0x06, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xce, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x87, 0x23, 0x06, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xcf, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x52, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xd0, 0x29, 0x01, 0x20, 0xea, 0x21, 0x41, 
	0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xd1, 0x29, 0x01, 0x20, 0x1b, 
	0x21, 0x41, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xd2, 0x29, 0x01, 
	0x20, 0xea, 0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xd3, 
	0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x21, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xd4, 0x29, 0x01, 0x20, 0x80, 0x21, 0x01, 0x22, 0x74, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xd5, 0x29, 0x01, 0x20, 0xe0, 0x21, 0x01, 0x22, 0x4e, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xd6, 0x29, 0x01, 0x20, 0xd8, 0x21, 0x40, 0x22, 0x02, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xd7, 0x29, 0x01, 0x20, 0x80, 0x21, 0x01, 0x22, 0x74, 
	0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xd8, 0x29, 0x01, 0x20, 0xc0, 0x21, 0x00, 
	0x22, 0x7d, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xd9, 0x29, 0x01, 0x20, 0x60, 
	0x21, 0x30, 0x22, 0x08, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xda, 0x29, 0x01, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0x62, 0x23, 0x09, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xdb, 
	0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xe9, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xdc, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xd8, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xdd, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x68, 0x23, 0x08, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xde, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x26, 0x23, 0x03, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xdf, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x8c, 
	0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xe0, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0xe9, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xe1, 0x29, 0x01, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0x31, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xe2, 0x29, 0x01, 
	0x20, 0x60, 0x21, 0x00, 0x22, 0xc1, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xe3, 
	0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xc2, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xe4, 0x29, 0x01, 0x20, 0xa0, 0x21, 0xff, 0x22, 0x9b, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xe5, 0x29, 0x01, 0x20, 0x60, 0x21, 0x00, 0x22, 0xc3, 0x23, 0x06, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xe6, 0x29, 0x01, 0x20, 0xa1, 0x21, 0xff, 0x22, 0x98, 0x23, 0x06, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xe7, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x52, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xe8, 0x29, 0x01, 0x20, 0xea, 0x21, 0x41, 
	0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xe9, 0x29, 0x01, 0x20, 0x1b, 
	0x21, 0x41, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xea, 0x29, 0x01, 
	0x20, 0x1d, 0x21, 0x08, 0x22, 0x8e, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xeb, 
	0x29, 0x01, 0x20, 0x03, 0x21, 0x00, 0x22, 0xac, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xec, 0x29, 0x01, 0x20, 0x10, 0x21, 0x00, 0x22, 0x02, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xed, 0x29, 0x01, 0x20, 0xef, 0x21, 0x41, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xee, 0x29, 0x01, 0x20, 0x07, 0x21, 0x00, 0x22, 0xac, 0x23, 0x01, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xef, 0x29, 0x01, 0x20, 0x99, 0x21, 0x0c, 0x22, 0x22, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xf0, 0x29, 0x01, 0x20, 0x96, 0x21, 0x0c, 
	0x22, 0x2b, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xf1, 0x29, 0x01, 0x20, 0x06, 
	0x21, 0x04, 0x22, 0x08, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xf2, 0x29, 0x01, 
	0x20, 0x01, 0x21, 0x00, 0x22, 0x7b, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xf3, 
	0x29, 0x01, 0x20, 0x01, 0x21, 0x00, 0x22, 0x7c, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xf4, 0x29, 0x01, 0x20, 0x99, 0x21, 0x0c, 0x22, 0x39, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xf5, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xf6, 0x29, 0x01, 0x20, 0x09, 0x21, 0x00, 0x22, 0x90, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xf7, 0x29, 0x01, 0x20, 0xfb, 0x21, 0x41, 0x22, 0x2d, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xf8, 0x29, 0x01, 0x20, 0x01, 0x21, 0x00, 
	0x22, 0x4e, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xf9, 0x29, 0x01, 0x20, 0x40, 
	0x21, 0x08, 0x22, 0x27, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xfa, 0x29, 0x01, 
	0x20, 0x01, 0x21, 0x00, 0x22, 0xb9, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xfb, 
	0x29, 0x01, 0x20, 0x0a, 0x21, 0x00, 0x22, 0xa7, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xfc, 0x29, 0x01, 0x20, 0xe1, 0x21, 0x25, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xfd, 0x29, 0x01, 0x20, 0x01, 0x21, 0x00, 0x22, 0x4e, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xfe, 0x29, 0x01, 0x20, 0x41, 0x21, 0x08, 0x22, 0x27, 0x23, 0x01, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xff, 0x29, 0x01, 0x20, 0xe1, 0x21, 0x25, 0x22, 0x01, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x00, 0x29, 0x02, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x10, 0x10, 0x01
	};


BYTE AudioPatchCut_3_2[AUDIO_PATCH_3_2_SIZE] = 
	{
	0x17, 0x01, 0x28, 0x00, 0x29, 0x00, 0x28, 0x00, 0x20, 0x99, 0x21, 0x06, 0x2a, 0x1e, 0x2a, 0x18, 
	0x28, 0x01, 0x20, 0xea, 0x21, 0x07, 0x2a, 0x1e, 0x2a, 0x18, 0x28, 0x02, 0x20, 0x44, 0x21, 0x14, 
	0x2a, 0x1e, 0x2a, 0x18, 0x28, 0x03, 0x20, 0x8a, 0x21, 0x14, 0x2a, 0x1e, 0x2a, 0x18, 0x28, 0x04, 
	0x20, 0x4c, 0x21, 0x15, 0x2a, 0x1e, 0x2a, 0x18, 0x28, 0x05, 0x20, 0xc1, 0x21, 0x15, 0x2a, 0x1e, 
	0x2a, 0x18, 0x28, 0x06, 0x20, 0x22, 0x21, 0x1f, 0x2a, 0x1e, 0x2a, 0x18, 0x28, 0x07, 0x20, 0x23, 
	0x21, 0x21, 0x2a, 0x1e, 0x2a, 0x18, 0x28, 0x08, 0x20, 0xbc, 0x21, 0x26, 0x2a, 0x1e, 0x2a, 0x18, 
	0x28, 0x09, 0x20, 0xf2, 0x21, 0x2c, 0x2a, 0x1e, 0x2a, 0x18, 0x28, 0x0a, 0x20, 0x7c, 0x21, 0x2d, 
	0x2a, 0x1e, 0x2a, 0x18, 0x28, 0x0b, 0x20, 0xf4, 0x21, 0x2d, 0x2a, 0x1e, 0x2a, 0x18, 0x28, 0x0c, 
	0x20, 0x24, 0x21, 0x2f, 0x2a, 0x1e, 0x2a, 0x18, 0x28, 0x0d, 0x20, 0x3a, 0x21, 0x35, 0x2a, 0x1e, 
	0x2a, 0x18, 0x28, 0x0e, 0x20, 0xab, 0x21, 0x36, 0x2a, 0x1e, 0x2a, 0x18, 0x28, 0x0f, 0x20, 0xff, 
	0x21, 0x3f, 0x2a, 0x1e, 0x2a, 0x18, 0x2a, 0x1d, 0x28, 0x00, 0x29, 0x00, 0x20, 0x3d, 0x21, 0x40, 
	0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x01, 0x29, 0x00, 0x20, 0xac, 
	0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x02, 0x29, 0x00, 
	0x20, 0xc0, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x03, 
	0x29, 0x00, 0x20, 0x44, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x04, 0x29, 0x00, 0x20, 0xb7, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x05, 0x29, 0x00, 0x20, 0x55, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x06, 0x29, 0x00, 0x20, 0x28, 0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x07, 0x29, 0x00, 0x20, 0x38, 0x21, 0x41, 0x22, 0x01, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x08, 0x29, 0x00, 0x20, 0xcf, 0x21, 0x40, 
	0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x09, 0x29, 0x00, 0x20, 0xb0, 
	0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x0a, 0x29, 0x00, 
	0x20, 0x11, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x0b, 
	0x29, 0x00, 0x20, 0xa7, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x0c, 0x29, 0x00, 0x20, 0x41, 0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x0d, 0x29, 0x00, 0x20, 0x14, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x0e, 0x29, 0x00, 0x20, 0x1c, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x0f, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x00, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x10, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x11, 0x29, 0x00, 0x20, 0x4e, 
	0x21, 0x00, 0x22, 0x4e, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x12, 0x29, 0x00, 
	0x20, 0x7d, 0x21, 0x2d, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x13, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x14, 0x29, 0x00, 0x20, 0x94, 0x21, 0x0c, 0x22, 0x6b, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x15, 0x29, 0x00, 0x20, 0x01, 0x21, 0x00, 0x22, 0xf8, 0x23, 0x08, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x16, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xf9, 0x23, 0x08, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x17, 0x29, 0x00, 0x20, 0x9e, 0x21, 0x0c, 0x22, 0x2b, 
	0x23, 0x07, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x18, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x3e, 0x23, 0x08, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x19, 0x29, 0x00, 0x20, 0x08, 
	0x21, 0x0d, 0x22, 0x81, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x1a, 0x29, 0x00, 
	0x20, 0xea, 0x21, 0x0c, 0x22, 0xf7, 0x23, 0x08, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x1b, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x1c, 0x29, 0x00, 0x20, 0x06, 0x21, 0x0d, 0x22, 0x1c, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x1d, 0x29, 0x00, 0x20, 0x00, 0x21, 0x70, 0x22, 0x32, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x1e, 0x29, 0x00, 0x20, 0xae, 0x21, 0x0c, 0x22, 0xbf, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x1f, 0x29, 0x00, 0x20, 0x12, 0x21, 0x00, 0x22, 0x67, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x20, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0xc8, 0x23, 0x04, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x21, 0x29, 0x00, 0x20, 0x74, 
	0x21, 0x68, 0x22, 0x18, 0x23, 0x05, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x22, 0x29, 0x00, 
	0x20, 0xe0, 0x21, 0x0c, 0x22, 0x81, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x23, 
	0x29, 0x00, 0x20, 0x70, 0x21, 0x30, 0x22, 0x15, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x24, 0x29, 0x00, 0x20, 0xf2, 0x21, 0x0c, 0x22, 0x81, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x25, 0x29, 0x00, 0x20, 0x83, 0x21, 0x30, 0x22, 0x15, 0x23, 0x01, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x26, 0x29, 0x00, 0x20, 0xfa, 0x21, 0x0c, 0x22, 0x81, 0x23, 0x02, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x27, 0x29, 0x00, 0x20, 0x27, 0x21, 0x36, 0x22, 0x02, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x28, 0x29, 0x00, 0x20, 0xe6, 0x21, 0x0c, 
	0x22, 0x26, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x29, 0x29, 0x00, 0x20, 0xd8, 
	0x21, 0x0c, 0x22, 0x7f, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x2a, 0x29, 0x00, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0x2b, 0x23, 0x09, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x2b, 
	0x29, 0x00, 0x20, 0xd8, 0x21, 0x0c, 0x22, 0x81, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x2c, 0x29, 0x00, 0x20, 0xe2, 0x21, 0x0c, 0x22, 0x7f, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x2d, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x2b, 0x23, 0x09, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x2e, 0x29, 0x00, 0x20, 0xe2, 0x21, 0x0c, 0x22, 0x81, 0x23, 0x02, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x2f, 0x29, 0x00, 0x20, 0x00, 0x21, 0x0d, 0x22, 0x7f, 
	0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x30, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x2b, 0x23, 0x09, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x31, 0x29, 0x00, 0x20, 0x00, 
	0x21, 0x0d, 0x22, 0x81, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x32, 0x29, 0x00, 
	0x20, 0xec, 0x21, 0x0c, 0x22, 0x7f, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x33, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x2b, 0x23, 0x09, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x34, 0x29, 0x00, 0x20, 0xec, 0x21, 0x0c, 0x22, 0x81, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x35, 0x29, 0x00, 0x20, 0xfc, 0x21, 0x0c, 0x22, 0x7f, 0x23, 0x02, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x36, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x2b, 0x23, 0x09, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x37, 0x29, 0x00, 0x20, 0xfc, 0x21, 0x0c, 0x22, 0x81, 
	0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x38, 0x29, 0x00, 0x20, 0x02, 0x21, 0x0d, 
	0x22, 0x7f, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x39, 0x29, 0x00, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0x2b, 0x23, 0x09, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x3a, 0x29, 0x00, 
	0x20, 0x02, 0x21, 0x0d, 0x22, 0x81, 0x23, 0x02, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x3b, 
	0x29, 0x00, 0x20, 0x7e, 0x21, 0x36, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x3c, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x3d, 0x29, 0x00, 0x20, 0x02, 0x21, 0x90, 0x22, 0x3b, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x3e, 0x29, 0x00, 0x20, 0x03, 0x21, 0x00, 0x22, 0x57, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x3f, 0x29, 0x00, 0x20, 0x03, 0x21, 0x00, 0x22, 0x4d, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x40, 0x29, 0x00, 0x20, 0x9d, 0x21, 0x06, 
	0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x41, 0x29, 0x00, 0x20, 0xef, 
	0x21, 0x14, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x42, 0x29, 0x00, 
	0x20, 0x9d, 0x21, 0x06, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x43, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x44, 0x29, 0x00, 0x20, 0x02, 0x21, 0x90, 0x22, 0x3b, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x45, 0x29, 0x00, 0x20, 0x03, 0x21, 0x00, 0x22, 0x57, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x46, 0x29, 0x00, 0x20, 0x03, 0x21, 0x00, 0x22, 0x4d, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x47, 0x29, 0x00, 0x20, 0x54, 0x21, 0x40, 0x22, 0x2d, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x48, 0x29, 0x00, 0x20, 0x14, 0x21, 0x90, 
	0x22, 0x6a, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x49, 0x29, 0x00, 0x20, 0x10, 
	0x21, 0x00, 0x22, 0x50, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x4a, 0x29, 0x00, 
	0x20, 0x54, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x4b, 
	0x29, 0x00, 0x20, 0xf7, 0x21, 0x00, 0x22, 0x8d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x4c, 0x29, 0x00, 0x20, 0x14, 0x21, 0x90, 0x22, 0xaf, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x4d, 0x29, 0x00, 0x20, 0x16, 0x21, 0x90, 0x22, 0x3b, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x4e, 0x29, 0x00, 0x20, 0x08, 0x21, 0x00, 0x22, 0x14, 0x23, 0x01, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x4f, 0x29, 0x00, 0x20, 0x16, 0x21, 0x90, 0x22, 0xa6, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x50, 0x29, 0x00, 0x20, 0x14, 0x21, 0x90, 
	0x22, 0x6a, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x51, 0x29, 0x00, 0x20, 0x10, 
	0x21, 0x00, 0x22, 0x50, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x52, 0x29, 0x00, 
	0x20, 0x50, 0x21, 0x40, 0x22, 0x43, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x53, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x00, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x54, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x55, 0x29, 0x00, 0x20, 0x5e, 0x21, 0xf0, 0x22, 0x76, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x56, 0x29, 0x00, 0x20, 0x02, 0x21, 0x00, 0x22, 0x7f, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x57, 0x29, 0x00, 0x20, 0x65, 0x21, 0x40, 0x22, 0x2d, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x58, 0x29, 0x00, 0x20, 0x28, 0x21, 0x01, 
	0x22, 0x30, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x59, 0x29, 0x00, 0x20, 0x2c, 
	0x21, 0x01, 0x22, 0xad, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x5a, 0x29, 0x00, 
	0x20, 0x93, 0x21, 0x00, 0x22, 0xb4, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x5b, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xb5, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x5c, 0x29, 0x00, 0x20, 0x00, 0x21, 0x04, 0x22, 0x32, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x5d, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x27, 0x23, 0x02, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x5e, 0x29, 0x00, 0x20, 0x10, 0x21, 0x90, 0x22, 0xa1, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x5f, 0x29, 0x00, 0x20, 0x28, 0x21, 0x01, 0x22, 0x06, 
	0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x60, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0xb6, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x61, 0x29, 0x00, 0x20, 0x2c, 
	0x21, 0x01, 0x22, 0x8e, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x62, 0x29, 0x00, 
	0x20, 0x93, 0x21, 0x00, 0x22, 0x7f, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x63, 
	0x29, 0x00, 0x20, 0x65, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x64, 0x29, 0x00, 0x20, 0x5e, 0x21, 0x08, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x65, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x66, 0x29, 0x00, 0x20, 0x02, 0x21, 0x90, 0x22, 0x3b, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x67, 0x29, 0x00, 0x20, 0x03, 0x21, 0x00, 0x22, 0x57, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x68, 0x29, 0x00, 0x20, 0x03, 0x21, 0x00, 
	0x22, 0x58, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x69, 0x29, 0x00, 0x20, 0x72, 
	0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x6a, 0x29, 0x00, 
	0x20, 0x7c, 0x21, 0x0c, 0x22, 0x2e, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x6b, 
	0x29, 0x00, 0x20, 0x1e, 0x21, 0x2f, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x6c, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x2c, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x6d, 0x29, 0x00, 0x20, 0x76, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x6e, 0x29, 0x00, 0x20, 0x7c, 0x21, 0x0c, 0x22, 0x55, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x6f, 0x29, 0x00, 0x20, 0x88, 0x21, 0x2e, 0x22, 0x02, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x70, 0x29, 0x00, 0x20, 0x19, 0x21, 0x2f, 
	0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x71, 0x29, 0x00, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x72, 0x29, 0x00, 
	0x20, 0x7c, 0x21, 0x0c, 0x22, 0x24, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x73, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x2c, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x74, 0x29, 0x00, 0x20, 0x76, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x75, 0x29, 0x00, 0x20, 0x88, 0x21, 0x2e, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x76, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x77, 0x29, 0x00, 0x20, 0x02, 0x21, 0x90, 0x22, 0x3b, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x78, 0x29, 0x00, 0x20, 0x03, 0x21, 0x00, 
	0x22, 0x57, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x79, 0x29, 0x00, 0x20, 0x03, 
	0x21, 0x00, 0x22, 0x58, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x7a, 0x29, 0x00, 
	0x20, 0x82, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x7b, 
	0x29, 0x00, 0x20, 0x12, 0x21, 0x2f, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x7c, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x2c, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x7d, 0x29, 0x00, 0x20, 0x89, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x7e, 0x29, 0x00, 0x20, 0x1b, 0x21, 0x2e, 0x22, 0x02, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x7f, 0x29, 0x00, 0x20, 0x80, 0x21, 0x2e, 0x22, 0x02, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x80, 0x29, 0x00, 0x20, 0x37, 0x21, 0x2e, 
	0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x81, 0x29, 0x00, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x82, 0x29, 0x00, 
	0x20, 0x6d, 0x21, 0x0c, 0x22, 0x24, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x83, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x2c, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x84, 0x29, 0x00, 0x20, 0x89, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x85, 0x29, 0x00, 0x20, 0x6d, 0x21, 0x0c, 0x22, 0x2e, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x86, 0x29, 0x00, 0x20, 0x1b, 0x21, 0x2e, 0x22, 0x02, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x87, 0x29, 0x00, 0x20, 0x80, 0x21, 0x2e, 0x22, 0x02, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x88, 0x29, 0x00, 0x20, 0x37, 0x21, 0x2e, 
	0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x89, 0x29, 0x00, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x8a, 0x29, 0x00, 
	0x20, 0x82, 0x21, 0x0c, 0x22, 0x2e, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x8b, 
	0x29, 0x00, 0x20, 0x02, 0x21, 0x90, 0x22, 0x3b, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x8c, 0x29, 0x00, 0x20, 0x03, 0x21, 0x00, 0x22, 0x57, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x8d, 0x29, 0x00, 0x20, 0x03, 0x21, 0x00, 0x22, 0x58, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x8e, 0x29, 0x00, 0x20, 0x9b, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x8f, 0x29, 0x00, 0x20, 0x0f, 0x21, 0x2f, 0x22, 0x02, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x90, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x2c, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x91, 0x29, 0x00, 0x20, 0xa6, 
	0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x92, 0x29, 0x00, 
	0x20, 0x80, 0x21, 0x2e, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x93, 
	0x29, 0x00, 0x20, 0x0f, 0x21, 0x2f, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x94, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x2c, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x95, 0x29, 0x00, 0x20, 0xa6, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x96, 0x29, 0x00, 0x20, 0x82, 0x21, 0x0c, 0x22, 0x55, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x97, 0x29, 0x00, 0x20, 0x84, 0x21, 0x2e, 0x22, 0x02, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x98, 0x29, 0x00, 0x20, 0x0f, 0x21, 0x2f, 
	0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x99, 0x29, 0x00, 0x20, 0x94, 
	0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x9a, 0x29, 0x00, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x9b, 
	0x29, 0x00, 0x20, 0x6c, 0x21, 0x0c, 0x22, 0x24, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x9c, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x2c, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x9d, 0x29, 0x00, 0x20, 0xa6, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x9e, 0x29, 0x00, 0x20, 0x80, 0x21, 0x2e, 0x22, 0x02, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x9f, 0x29, 0x00, 0x20, 0x6c, 0x21, 0x0c, 0x22, 0x24, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xa0, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x2c, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xa1, 0x29, 0x00, 0x20, 0xa6, 
	0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xa2, 0x29, 0x00, 
	0x20, 0x82, 0x21, 0x0c, 0x22, 0x55, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xa3, 
	0x29, 0x00, 0x20, 0x84, 0x21, 0x2e, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xa4, 0x29, 0x00, 0x20, 0x6c, 0x21, 0x0c, 0x22, 0x24, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xa5, 0x29, 0x00, 0x20, 0xa0, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xa6, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xa7, 0x29, 0x00, 0x20, 0x77, 0x21, 0x40, 0x22, 0x02, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xa8, 0x29, 0x00, 0x20, 0x8a, 0x21, 0x40, 
	0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xa9, 0x29, 0x00, 0x20, 0x66, 
	0x21, 0x40, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xaa, 0x29, 0x00, 
	0x20, 0xf8, 0x21, 0x2e, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xab, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xac, 0x29, 0x00, 0x20, 0x02, 0x21, 0x90, 0x22, 0x6b, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xad, 0x29, 0x00, 0x20, 0x03, 0x21, 0x00, 0x22, 0xc6, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xae, 0x29, 0x00, 0x20, 0xeb, 0x21, 0x07, 0x22, 0x01, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xaf, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xb0, 0x29, 0x00, 0x20, 0x21, 0x21, 0x00, 
	0x22, 0xa9, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xb1, 0x29, 0x00, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0xac, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xb2, 0x29, 0x00, 
	0x20, 0xf6, 0x21, 0x2c, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xb3, 
	0x29, 0x00, 0x20, 0x01, 0x21, 0x00, 0x22, 0x8d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xb4, 0x29, 0x00, 0x20, 0x79, 0x21, 0x0c, 0x22, 0x8e, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xb5, 0x29, 0x00, 0x20, 0xf6, 0x21, 0x2c, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xb6, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xb7, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xaf, 
	0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xb8, 0x29, 0x00, 0x20, 0x02, 0x21, 0x00, 
	0x22, 0xf9, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xb9, 0x29, 0x00, 0x20, 0xbb, 
	0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xba, 0x29, 0x00, 
	0x20, 0x02, 0x21, 0x00, 0x22, 0xf5, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xbb, 
	0x29, 0x00, 0x20, 0x12, 0x21, 0x90, 0x22, 0x6e, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xbc, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xb0, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xbd, 0x29, 0x00, 0x20, 0xbb, 0x21, 0x40, 0x22, 0x43, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xbe, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x00, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xbf, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xc0, 0x29, 0x00, 0x20, 0x05, 0x21, 0xf0, 
	0x22, 0x8f, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xc1, 0x29, 0x00, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0xed, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xc2, 0x29, 0x00, 
	0x20, 0xce, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xc3, 
	0x29, 0x00, 0x20, 0x4d, 0x21, 0xf0, 0x22, 0x8f, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xc4, 0x29, 0x00, 0x20, 0x02, 0x21, 0x00, 0x22, 0xa1, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xc5, 0x29, 0x00, 0x20, 0xcc, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xc6, 0x29, 0x00, 0x20, 0x06, 0x21, 0x00, 0x22, 0xfd, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xc7, 0x29, 0x00, 0x20, 0xcc, 0x21, 0x40, 0x22, 0x2d, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xc8, 0x29, 0x00, 0x20, 0x4c, 0x21, 0xf0, 
	0x22, 0x8f, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xc9, 0x29, 0x00, 0x20, 0x03, 
	0x21, 0x00, 0x22, 0x90, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xca, 0x29, 0x00, 
	0x20, 0xcc, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xcb, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xcc, 0x29, 0x00, 0x20, 0x05, 0x21, 0xf0, 0x22, 0x52, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xcd, 0x29, 0x00, 0x20, 0x08, 0x21, 0x00, 0x22, 0x98, 0x23, 0x01, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xce, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xcf, 0x29, 0x00, 0x20, 0x0f, 0x21, 0x00, 0x22, 0x57, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xd0, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x20, 0x23, 0x04, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xd1, 0x29, 0x00, 0x20, 0xdf, 
	0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xd2, 0x29, 0x00, 
	0x20, 0xdf, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xd3, 
	0x29, 0x00, 0x20, 0xdf, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xd4, 0x29, 0x00, 0x20, 0xdf, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xd5, 0x29, 0x00, 0x20, 0xdf, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xd6, 0x29, 0x00, 0x20, 0xe0, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xd7, 0x29, 0x00, 0x20, 0xdf, 0x21, 0x40, 0x22, 0x01, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xd8, 0x29, 0x00, 0x20, 0xdf, 0x21, 0x40, 
	0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xd9, 0x29, 0x00, 0x20, 0xed, 
	0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xda, 0x29, 0x00, 
	0x20, 0xdf, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xdb, 
	0x29, 0x00, 0x20, 0x01, 0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xdc, 0x29, 0x00, 0x20, 0xdf, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xdd, 0x29, 0x00, 0x20, 0xdf, 0x21, 0x40, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xde, 0x29, 0x00, 0x20, 0x13, 0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xdf, 0x29, 0x00, 0x20, 0x0a, 0x21, 0x27, 0x22, 0x01, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xe0, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x2b, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xe1, 0x29, 0x00, 0x20, 0x60, 
	0x21, 0x00, 0x22, 0x87, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xe2, 0x29, 0x00, 
	0x20, 0xc0, 0x21, 0x00, 0x22, 0x8b, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xe3, 
	0x29, 0x00, 0x20, 0x1d, 0x21, 0x08, 0x22, 0xf0, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xe4, 0x29, 0x00, 0x20, 0x10, 0x21, 0x00, 0x22, 0xf1, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xe5, 0x29, 0x00, 0x20, 0x0a, 0x21, 0x27, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xe6, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xc3, 0x23, 0x06, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xe7, 0x29, 0x00, 0x20, 0x60, 0x21, 0x0c, 0x22, 0x08, 
	0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xe8, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0xf2, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xe9, 0x29, 0x00, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0xf3, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xea, 0x29, 0x00, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0xf4, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xeb, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xf5, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xec, 0x29, 0x00, 0x20, 0x0a, 0x21, 0x27, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xed, 0x29, 0x00, 0x20, 0x60, 0x21, 0x00, 0x22, 0xf6, 0x23, 0x06, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xee, 0x29, 0x00, 0x20, 0xc0, 0x21, 0x00, 0x22, 0x54, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xef, 0x29, 0x00, 0x20, 0x24, 0x21, 0x26, 0x22, 0x02, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xf0, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x15, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xf1, 0x29, 0x00, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0x4a, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xf2, 0x29, 0x00, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0xe2, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xf3, 
	0x29, 0x00, 0x20, 0xff, 0x21, 0x40, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xf4, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xf7, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xf5, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x41, 0x23, 0x03, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xf6, 0x29, 0x00, 0x20, 0x60, 0x21, 0x18, 0x22, 0x08, 0x23, 0x01, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xf7, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xf8, 
	0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xf8, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0xf9, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xf9, 0x29, 0x00, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0x13, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xfa, 0x29, 0x00, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0x92, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xfb, 
	0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xfa, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0xfc, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x41, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0xfd, 0x29, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0xa4, 0x23, 0x06, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xfe, 0x29, 0x00, 0x20, 0x0a, 0x21, 0x27, 0x22, 0x01, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0xff, 0x29, 0x00, 0x20, 0x51, 0x21, 0x26, 0x22, 0x02, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x00, 0x29, 0x01, 0x20, 0x0a, 0x21, 0x27, 
	0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x01, 0x29, 0x01, 0x20, 0xc0, 
	0x21, 0x00, 0x22, 0xf6, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x02, 0x29, 0x01, 
	0x20, 0x60, 0x21, 0x00, 0x22, 0x87, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x03, 
	0x29, 0x01, 0x20, 0x80, 0x21, 0x01, 0x22, 0x54, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x04, 0x29, 0x01, 0x20, 0x24, 0x21, 0x26, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x05, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x15, 0x23, 0x03, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x06, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x4a, 0x23, 0x03, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x07, 0x29, 0x01, 0x20, 0x60, 0x21, 0x18, 0x22, 0x08, 
	0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x08, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0xfb, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x09, 0x29, 0x01, 0x20, 0x00, 
	0x21, 0x00, 0x22, 0xf2, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x0a, 0x29, 0x01, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0x41, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x0b, 
	0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xfc, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x0c, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xfd, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x0d, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xf4, 0x23, 0x06, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x0e, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xf5, 0x23, 0x06, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x0f, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x52, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x10, 0x29, 0x01, 0x20, 0x0a, 0x21, 0x27, 
	0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x11, 0x29, 0x01, 0x20, 0x51, 
	0x21, 0x26, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x12, 0x29, 0x01, 
	0x20, 0x0a, 0x21, 0x27, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x13, 
	0x29, 0x01, 0x20, 0x80, 0x21, 0x01, 0x22, 0xf6, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x14, 0x29, 0x01, 0x20, 0xc0, 0x21, 0x00, 0x22, 0x87, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x15, 0x29, 0x01, 0x20, 0xe0, 0x21, 0x01, 0x22, 0x54, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x16, 0x29, 0x01, 0x20, 0x24, 0x21, 0x26, 0x22, 0x02, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x17, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x15, 
	0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x18, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x4a, 0x23, 0x03, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x19, 0x29, 0x01, 0x20, 0x60, 
	0x21, 0x20, 0x22, 0x08, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x1a, 0x29, 0x01, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0xfe, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x1b, 
	0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0xff, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x1c, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x00, 0x23, 0x07, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x1d, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x41, 0x23, 0x03, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x1e, 0x29, 0x01, 0x20, 0x60, 0x21, 0x00, 0x22, 0x01, 0x23, 0x07, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x1f, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x02, 
	0x23, 0x07, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x20, 0x29, 0x01, 0x20, 0xa0, 0x21, 0xff, 
	0x22, 0xb4, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x21, 0x29, 0x01, 0x20, 0x60, 
	0x21, 0x00, 0x22, 0x03, 0x23, 0x07, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x22, 0x29, 0x01, 
	0x20, 0xa1, 0x21, 0xff, 0x22, 0xe2, 0x23, 0x06, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x23, 
	0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x52, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x24, 0x29, 0x01, 0x20, 0x0a, 0x21, 0x27, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x25, 0x29, 0x01, 0x20, 0x51, 0x21, 0x26, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x26, 0x29, 0x01, 0x20, 0x0a, 0x21, 0x27, 0x22, 0x01, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x27, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x28, 0x29, 0x01, 0x20, 0x4c, 0x21, 0xf0, 
	0x22, 0x8f, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x29, 0x29, 0x01, 0x20, 0x01, 
	0x21, 0x00, 0x22, 0x90, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x2a, 0x29, 0x01, 
	0x20, 0x32, 0x21, 0x41, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x2b, 
	0x29, 0x01, 0x20, 0x6a, 0x21, 0xf0, 0x22, 0x8f, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x2c, 0x29, 0x01, 0x20, 0x01, 0x21, 0x00, 0x22, 0x90, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x2d, 0x29, 0x01, 0x20, 0x30, 0x21, 0x41, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x2e, 0x29, 0x01, 0x20, 0x18, 0x21, 0x00, 0x22, 0x8e, 0x23, 0x03, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x2f, 0x29, 0x01, 0x20, 0x33, 0x21, 0x41, 0x22, 0x01, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x30, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x25, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x31, 0x29, 0x01, 0x20, 0x33, 
	0x21, 0x41, 0x22, 0x01, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x32, 0x29, 0x01, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0x25, 0x23, 0x01, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x33, 
	0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x2c, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x34, 0x29, 0x01, 0x20, 0x29, 0x21, 0x1f, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x35, 0x29, 0x01, 0x20, 0xde, 0x21, 0x16, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x36, 0x29, 0x01, 0x20, 0x29, 0x21, 0x1f, 0x22, 0x01, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x37, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x12, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x38, 0x29, 0x01, 0x20, 0x15, 0x21, 0x08, 
	0x22, 0x24, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x39, 0x29, 0x01, 0x20, 0x16, 
	0x21, 0x08, 0x22, 0x93, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x3a, 0x29, 0x01, 
	0x20, 0x00, 0x21, 0x00, 0x22, 0x7e, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x3b, 
	0x29, 0x01, 0x20, 0x3d, 0x21, 0x41, 0x22, 0x43, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x3c, 0x29, 0x01, 0x20, 0xc5, 0x21, 0x18, 0x22, 0x02, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x3d, 0x29, 0x01, 0x20, 0x04, 0x21, 0x00, 0x22, 0x8e, 0x23, 0x03, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x3e, 0x29, 0x01, 0x20, 0x06, 0x21, 0x00, 0x22, 0x27, 0x23, 0x01, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x3f, 0x29, 0x01, 0x20, 0x27, 0x21, 0x21, 0x22, 0x02, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x40, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x41, 0x29, 0x01, 0x20, 0x73, 
	0x21, 0xf0, 0x22, 0x97, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x42, 0x29, 0x01, 
	0x20, 0x01, 0x21, 0x00, 0x22, 0x57, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x43, 
	0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 0x22, 0x4d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 
	0x28, 0x44, 0x29, 0x01, 0x20, 0x48, 0x21, 0x41, 0x22, 0x2d, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 
	0x2a, 0x1d, 0x28, 0x45, 0x29, 0x01, 0x20, 0x73, 0x21, 0xf0, 0x22, 0x97, 0x23, 0x00, 0x2a, 0x1c, 
	0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x46, 0x29, 0x01, 0x20, 0x20, 0x21, 0x00, 0x22, 0x57, 0x23, 0x00, 
	0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x47, 0x29, 0x01, 0x20, 0x05, 0x21, 0x00, 0x22, 0x9e, 
	0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x1d, 0x28, 0x48, 0x29, 0x01, 0x20, 0x00, 0x21, 0x00, 
	0x22, 0x12, 0x23, 0x00, 0x2a, 0x1c, 0x2a, 0x1d, 0x2a, 0x10, 0x10, 0x01
	};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\generic\mp2tsdmx.h ===
// FILE:			library\hardware\mpeg2dec\generic\mp2tsdmx.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1996 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		19.12.96
//
// PURPOSE:		MPEG-2 Transport Stream Demultiplexer
//
// HISTORY:


#ifndef MP2TSDMX_H
#define MP2TSDMX_H

#include "..\..\..\common\prelude.h"
#include "..\..\..\general\lists.h"
#include "..\..\..\general\asncstrm.h"
#include "mp2eldec.h"


///////////////////////////////////////////////////////////////////////////////
// General Section Receiver
///////////////////////////////////////////////////////////////////////////////

class SectionReceiver
	{
	protected:
		DWORD	shiftReg;
	public:
		SectionReceiver() {;}
		virtual void Reset()  = 0;
		virtual DWORD SendData(HPTR data, DWORD size) = 0;
		virtual void CRCAddByte(BYTE b);
	};

///////////////////////////////////////////////////////////////////////////////
// Program Association Table Receiver
///////////////////////////////////////////////////////////////////////////////

class ProgramAssociation : public Node
	{
	public:
		WORD	number;		// Program Number
		WORD	pid;			// PID of Program Map Table
		
		ProgramAssociation(WORD number, WORD pid) {this->number = number; this->pid = pid;}
	};

class PAList : public List
	{
	public:
		PAList() {;}
		~PAList();
		
		void DeleteAll();

		void InsertPA(ProgramAssociation * pa);
		WORD FindPA(WORD number);					// Delivers PID for a certain program Number. Values > 0x1fff signal error.
	};

class PATReceiver : public SectionReceiver
	{
	protected:
		int	state;	                      
		DWORD muxPos;
		BOOL	resync;
		
		WORD	sectionLength;

		WORD	streamID;
		int	patVersion, lastVersion;
		BOOL	currentNext;
		BYTE	sectionNumber;
		BYTE	lastSectionNumber;
		WORD	entries;
		WORD	curProgNum;
		WORD	curPID;

		PAList * tempPAList;
		PAList * paList;

		void	InitTempProgramAssoc();
		void	AddTempProgramAssoc(WORD curProgramNum, WORD curPID);
		void	ValidateTempProgramAssoc();
		void	UseTempProgramAssoc();
		void	DiscardTempProgramAssoc();

	public:
		PATReceiver();
		~PATReceiver();
	   DWORD SendData(HPTR data, DWORD size);
		void	Reset(void);
		
		int	NumPrograms();		// Delivers number of programs
		PAList * GetPAList();
	};


///////////////////////////////////////////////////////////////////////////////
// Program Map Table Receiver
///////////////////////////////////////////////////////////////////////////////

class PMTReceiver : public SectionReceiver
	{
	protected:
		int	state;	                      
		DWORD muxPos;
		BOOL	resync;
		
		WORD	sectionLength;
   public:
		PMTReceiver();
	   DWORD SendData(HPTR data, DWORD size);
		void	Reset(void);
	};

///////////////////////////////////////////////////////////////////////////////
// Transport Stream Demux (Main Part)
///////////////////////////////////////////////////////////////////////////////

class MPEG2TransportStreamDemux
	{        
	protected:                             
		PATReceiver			*	patHandler;
		SectionReceiver	*	mapHandler;
		
		int	state;	                      
		
		WORD	cnt;
		DWORD	length; 
		BYTE 	high, low;    
		DWORD muxPos;

		BOOL	transportError;
		BOOL	payloadUnitStart;
		WORD	pid;
		BYTE	scramblingCtrl;
		BYTE	continuityCounter;
		BYTE	adaptionFieldCtrl;
		DWORD	packetRemain;
		DWORD	fieldRemain;
		DWORD adaptionFieldSize;

		BYTE	pointer;

		WORD	programMapPID;
	public:
		MPEG2TransportStreamDemux(PATReceiver * patHandler, SectionReceiver * mapHandler);
	                
		void Reset(void);
		
		DWORD SendData(HPTR data, DWORD size);
		void CompleteData(void);              
	};





#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\generic\mp2vsprs.h ===
#ifndef MP2VSPRS_H
#define MP2VSPRS_H

//
// MPEG 2 Video stream decoder
//

#include "..\..\..\common\prelude.h"
#include "..\..\..\common\gnerrors.h"

#define GNR_INVALID_VIDEO_START_CODE	MKERR(ERROR, MP2PARSER, FORMAT, 0x01) 

//
// potential MPEG1/2 video stream start codes
//
enum MPEG2VideoStartCode
	{
	MP2VH_PICTURE_START,
	MP2VH_USER_DATA, 
	MP2VH_SEQUENCE_HEADER, 
	MP2VH_SEQUENCE_ERROR,
	MP2VH_EXTENSION_START,
	MP2VH_SEQUENCE_END,
	MP2VH_GROUP_START,
	MP2VH_SLICE_HEADER,
	MP2VH_STUFFING,
	MP2VH_INVALID
	};


//
// potential MPEG1/2 frame/field types
//
enum MPEG2FrameType
	{
	M2FT_IFRAME, 
	M2FT_PFRAME, 
	M2FT_BFRAME,
	M2FT_UFRAME
	};         

enum MPEG2PictureStructure
	{
	M2PS_FRAME,
	M2PS_TOPFIELD,
	M2PS_BOTTOMFIELD,
	M2PS_UNKNOWNFIELD
	};

//
// potential mpeg2 chroma formats, typically only 422 used
//
enum MPEG2ChromaFormat
	{ 
	MP2CF_RESERVED,
	MP2CF_420,
	MP2CF_422,
	MP2CF_444
	};

//
// specified video output formats
//
enum MPEG2VideoFormat
	{ 
	MP2VF_COMPONENT,
	MP2VF_PAL,
	MP2VF_NTSC,
	MP2VF_SECAM,
	MP2VF_MAC,
	MP2VF_UNKNOWN
	};                
	
enum MPEG2CodingStandard
	{ 
	MP2CS_MPEG1,
	MP2CS_MPEG2
	};
	
//
// flags in changed
//
// Sequence header, sequence extension
//
#define MP2VPCHANGED_STANDARD				MKFLAG(0)
#define MP2VPCHANGED_SIZE					MKFLAG(1)
#define MP2VPCHANGED_FRAME_RATE			MKFLAG(2)
#define MP2VPCHANGED_INTRA_QUANT			MKFLAG(3)
#define MP2VPCHANGED_NON_INTRA_QUANT	MKFLAG(4)
#define MP2VPCHANGED_BIT_RATE				MKFLAG(5)
#define MP2VPCHANGED_VBV_BUFFER_SIZE	MKFLAG(6)

//
// Sequence extension
// 
#define MP2VPCHANGED_PROFILE				MKFLAG(8)
#define MP2VPCHANGED_DISPLAY_SIZE		MKFLAG(9)

//
// Picture header
//
#define MP2VPCHANGED_	MKFLAG()
#define MP2VPCHANGED_	MKFLAG()
#define MP2VPCHANGED_	MKFLAG()
#define MP2VPCHANGED_	MKFLAG()
#define MP2VPCHANGED_	MKFLAG()
#define MP2VPCHANGED_	MKFLAG()
#define MP2VPCHANGED_	MKFLAG()
#define MP2VPCHANGED_	MKFLAG()

//
// Flags determining which header types to parse
//
#define MP2VX_PICTURE_HEADER								MKFLAG(0)
#define MP2VX_USER_DATA										MKFLAG(1)
#define MP2VX_SEQUENCE_HEADER								MKFLAG(2)
#define MP2VX_EXTENSION_HEADER							MKFLAG(3)
#define MP2VX_GROUP_HEADER									MKFLAG(4)
#define MP2VX_SEQUENCE_ERROR								MKFLAG(5)
#define MP2VX_SEQUENCE_END									MKFLAG(6)

#define MP2VX_SEQUENCE_EXTENSION							MKFLAG(8)
#define MP2VX_SEQUENCE_DISPLAY_EXTENSION				MKFLAG(9)	
#define MP2VX_SEQUENCE_SCALABLE_EXTENSION				MKFLAG(10)
#define MP2VX_PICTURE_CODING_EXTENSION					MKFLAG(11)
#define MP2VX_QUANT_MATRIX_EXTENSION					MKFLAG(12)
#define MP2VX_PICTURE_DISPLAY_EXTENSION				MKFLAG(13)
#define MP2VX_PICTURE_TEMPORAL_SCALABLE_EXTENSION  MKFLAG(14)
#define MP2VX_PICTURE_SPATIAL_SCALABLE_EXTENSION	MKFLAG(15)


//
// Parser for MPEG1 and 2 video streams.
//
// The Function NextByte is a template function and has to be
// replaced with the actual function, that retrieves the next
// character from the input stream.
// 
class MPEG2VideoHeaderParser
	{
	protected:                      
		BYTE	b;
		WORD	w;
		DWORD	dw;             
		DWORD bits;
		BOOL	bit;

		BOOL	extensionHeaderPending;

		//
		// Template stream parsing functions, Begin/EndParse() may be
		// overridden, to add additional logic to the parsing.
		//
		// NextByte() is supposed to place the next byte of the
		// stream in the instance variable b. All higher level
		// parsing functions are broken into NextByte() requests.
		//
		virtual Error BeginParse(void) {GNRAISE_OK;}
		virtual Error EndParse(void) {GNRAISE_OK;}
		virtual Error NextByte(void) = 0;      
      
      //
      // Higher level parsing functions, used to simplify the
      // parser.
      //
		Error NextWord(void);
		Error NextDWord(void);
		Error NextStartCode(void);
				
		int bitsRemaining;
		
		Error NextBits(int num);
		Error NextBit();
		
		//
		// Determine the current startcode
		//
		MPEG2VideoStartCode IdentifyStartCode(BYTE code);
		
		//
		// Parsing functions for different video headers.
		// They may be overridden, to add additional parsing.
		//
		virtual Error ParsePictureHeader(void);
		virtual Error ParseUserData(void);
		virtual Error ParseSequenceHeader(void);
		virtual Error ParseExtensionHeader(void);
		
		//
		// Parsing functions for MPEG2 extended headers
		//
		virtual Error ParseSequenceExtension(void);
		virtual Error ParseSequenceDisplayExtension(void);
		virtual Error ParseSequenceScalableExtension(void);
		virtual Error ParsePictureCodingExtension(void);
		virtual Error ParseQuantMatrixExtension(void);
		virtual Error ParsePictureDisplayExtension(void);
		virtual Error ParsePictureTemporalScalableExtension(void);
		virtual Error ParsePictureSpatialScalableExtension(void);
		
		virtual Error ParseGroupHeader(void);  
		
		virtual Error ParseSequenceEnd(void);
		virtual Error ParseSequenceError(void);
		
		//
		// Dispatcher for the different header parser.
		//
		virtual Error ParseHeader(MPEG2VideoStartCode header);
	public:                                                     
		//
		// Variable determining which MPEG 2 headers to parse,
		// and which simply to skip.  This field is composed
		// out of MP2VX_ flags.
		//
		DWORD						parseHeaderFlags;
		
		//
		// Flag set, reflecting which parts of the parser information
		// changed during the last parser run.
		//
		DWORD						changed;

		//
		// Extracted fields of the MPEG 2 video stream headers,
		// see the MPEG documentation.
		//
		MPEG2CodingStandard		codingStandard;		
		WORD							width, height;            
		WORD							aspectRatioFactor;
		BYTE							aspectRatio;
		BYTE							frameRate;
		BYTE							frameRateNominator;
		BYTE							frameRateDenominator;
		DWORD							bitRate;       
		DWORD 						vbvBufferSize;                
		BYTE							intraQuantMatrix[64];
		BYTE							nonIntraQuantMatrix[64];           
		BYTE							chromaIntraQuantMatrix[64];
		BYTE							chromaNonIntraQuantMatrix[64];           
		                 	
		BYTE							profileAndLevel;  
		BOOL							progressiveSequence;
		MPEG2ChromaFormat			chromaFormat;
		
	   DWORD							timeCode;
	   BOOL							closedGop;
	   BOOL							brokenLink; 

		DWORD							totalFrameCnt;
		WORD							groupFrameCnt;
	   
		MPEG2FrameType				frameType;   
		MPEG2PictureStructure	fieldType, initialFieldType, secondaryFieldType;

		BYTE							pictureCoding;
		BYTE							backwardVector, forwardVector;
		WORD							temporalReference;		
		DWORD							totalTemporalReference;
		
		int							centerVerticalOffset;
		int							centerHorizontalOffset;
		
		BYTE							colourPrimaries;
		BYTE							transferCharacteristics;
		BYTE							matrixCoefficients;
		
		WORD							displayWidth;
		WORD							displayHeight;
		BYTE							fcode[2][2];
		BYTE							intraDCPrecision;
		BYTE							pictureStructure;
		BOOL							topFieldFirst;
		BOOL							framePredFrameDCT;
		BOOL							concealmentMotionVectors;
		BOOL							qScaleType;
		BOOL							intraVLCFormat;
		BOOL							alternateScan;
		BOOL							repeatFirstField;
		BOOL							chroma420Type;
		BOOL							progressiveFrame;
		BOOL							compositeDisplayFlag;
		BOOL							vAxis;
		BYTE							fieldSequence;
		BOOL							subCarrier;
		BYTE							burstAmplitude;
		BYTE							subCarrierPhase;
		                 	
		MPEG2VideoFormat			videoFormat;
		
		MPEG2VideoHeaderParser(void);
		virtual ~MPEG2VideoHeaderParser(void);
		
		virtual void Reset(void);
		
		//
		// Parser entry point, call this to parse the _next_ header
		//
		virtual Error Parse(MPEG2VideoStartCode __far &header);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\specific\ac3exdec.h ===
// FILE:			library\hardware\mpeg3dec\specific\ac3exdec.h
// AUTHOR:		Viona
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		05.12.95
//
// PURPOSE:		
//
// HISTORY:
#ifndef AC3EXDEC_H
#define AC3EXDEC_H

#include "..\generic\mp2eldec.h"
#include "..\..\..\common\profiles.h"

class ExternalAC3Decoder : public MPEG2AC3Decoder
	{
	friend class VirtualExternalAC3Decoder;
	protected:
		PTSAssoc		ptsAssoc;
		
		DWORD 		audioBitrate;
		MPEGState	state;
		BOOL			ac3;		
		
		WORD			leftVolume, rightVolume;
		BOOL			mute;    
		
		DWORD			transferLocation;
		
		DWORD			decoderDelay;
		
		Error SetAudioBitrate(DWORD bitrate);
		Error SetSampleRate(WORD rate);
		Error SetLeftVolume(WORD volume);
		Error SetRightVolume(WORD volume);
		Error SetMute(BOOL mute);
		Error SetAC3(BOOL ac3);
		Error SetBassConfig(AC3BassConfig config);
		Error SetSpeakerConfig(AC3SpeakerConfig config);
		Error SetDualModeConfig(AC3DualModeConfig config) {GNRAISE_OK;}
		Error SetKaraokeConfig(AC3KaraokeConfig config) {GNRAISE_OK;}
		Error SetCenterDelay(WORD delay);
		Error SetSurroundDelay(WORD delay);
		Error SetCenterVolume(WORD volume);
		Error SetLeftSurroundVolume(WORD volume);
		Error SetRightSurroundVolume(WORD volume);
		Error SetSubwooferVolume(WORD volume);
		
	   Error SendCommand(MPEGCommand com, DWORD param, DWORD __far &tag);
		BOOL CommandPending(DWORD tag);

		DWORD CurrentLocation(void);
		MPEGState CurrentState(void);
		DWORD LastTransferLocation(DWORD scale);
			   
	   DWORD GetPTS();
	   DWORD SendData(HPTR data, DWORD size);
	   void CompleteData(void);
	
	   void PutPTS(DWORD pts);
	   
		//
		// Forward the refill request
		//
		void RefillRequest(DWORD free);

	   Error SetSignalPosition(DWORD position);
	   
	   friend void __far pascal RefillCallback(DWORD idata, DWORD free);
	
	public:
		ExternalAC3Decoder(Profile * profile);
		~ExternalAC3Decoder(void);
		
		VirtualUnit * CreateVirtual(void);		
	};
	
class VirtualExternalAC3Decoder : public VirtualMPEG2AC3Decoder
	{
	private:
		ExternalAC3Decoder	*	device;
	protected:
      Error PreemptStopPrevious(VirtualUnit * previous);
      Error PreemptStartNew(VirtualUnit * previous);		
	public:
		VirtualExternalAC3Decoder(ExternalAC3Decoder * device);	
	};
	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\generic\mpeg2dec.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef MPEG2DEC_H
#define MPEG2DEC_H

#include "library/common/prelude.h"
#include "library/common/gnerrors.h"
#include "mp2eldec.h"

#include "mp2dcryp.h"

#ifndef ONLY_EXTERNAL_VISIBLE

#include "mp2spudc.h"
#include "mp2demux.h"

class MPEG2AVDecoder : public MPEG2ElementaryDecoder
   {
   friend class VirtualMPEG2AVDecoder;
   protected:
   	MPEGStreamType		streamType;
   	BOOL					ac3;
   	BOOL					mpeg2Coding;
   	BOOL					lpcm;
		MPEG2AudioType		audioType;

		virtual Error SetAudioBitrate(DWORD rate) = 0;
		virtual Error SetSampleRate(WORD rate) = 0; // in samples per second;
		virtual Error SetLeftVolume(WORD volume) = 0;
		virtual Error SetRightVolume(WORD volume) = 0;
		virtual Error SetMute(BOOL mute) = 0;

		virtual Error SetBassConfig(AC3BassConfig config) = 0;
		virtual Error SetSpeakerConfig(AC3SpeakerConfig config) = 0;
		virtual Error SetCenterDelay(WORD delay) = 0;
		virtual Error SetSurroundDelay(WORD delay) = 0;

		virtual Error SetCenterVolume(WORD volume) = 0;
		virtual Error SetLeftSurroundVolume(WORD volume) = 0;
		virtual Error SetRightSurroundVolume(WORD volume) = 0;
		virtual Error SetSubwooferVolume(WORD volume) = 0;

		virtual Error SetAC3(BOOL ac3) {this->ac3 = ac3; GNRAISE_OK;}
		virtual Error SetLPCM(BOOL lpcm) {this->lpcm = lpcm; GNRAISE_OK;}
		virtual Error SetVideoBitrate(DWORD videoBitrate) = 0;
		virtual Error SetVideoWidth(WORD width) = 0;
		virtual Error SetVideoHeight(WORD height) = 0;
		virtual Error SetVideoFPS(WORD fps) = 0;
		virtual Error SetAspectRatio(WORD aspectRatio) = 0;
		virtual Error SetVideoStandard(VideoStandard	standard) = 0;
#if TEST_PAL_TO_NTSC
		virtual Error SetApplicationVideoStandard(VideoStandard	standard) = 0;
		virtual MovingImageStandard GetEncoderMovingImageStandard () = 0;
#endif
		virtual Error SetStreamType(MPEGStreamType streamType) = 0;
		virtual Error SetStreamMode(MPEGStreamMode streamMode) = 0;
		virtual Error SetMPEG2Coding(BOOL mpeg2Coding) {this->mpeg2Coding = mpeg2Coding; GNRAISE_OK;}
      virtual Error SetVideoStreamID(BYTE id) = 0;
      virtual Error SetAudioStreamID(BYTE id) = 0;
      virtual Error SetAC3StreamID(BYTE id) = 0;
   	virtual Error SetPresentationMode(MPEG2PresentationMode presentationMode) = 0;

      virtual Error SetLPCMStreamID(BYTE id) = 0;
		virtual Error SetDTSStreamID(BYTE id) = 0;
      virtual Error SetSPUStreamID(BYTE id) = 0;
		virtual Error SetMLPStreamID(BYTE id) = 0;
      virtual Error SetSPUEnable(BOOL enable) = 0;
      virtual Error SetSPUButtonState(SPUButtonState state) = 0;
      virtual Error SetSPUButtonPosition(int x, int y, int width, int height) = 0;
      virtual Error SetSPUButtonColors(DWORD selected, DWORD active) = 0;
      virtual Error SetSPUPaletteEntry(int p, int y, int u, int v) = 0;
      virtual Error SetSPUCommandHook(MPEG2SPUCommandHookHandle hook) = 0;
      virtual Error SetSPUButtonID(WORD id) {GNRAISE_OK;}
      virtual Error SetBitsPerSample(WORD bits) = 0;
      virtual Error SetChannels(WORD channels) = 0;
      virtual Error DoAuthenticationCommand(MPEG2DVDAuthenticationCommand com, DWORD sector, BYTE __far * key) = 0;

#if WDM_VERSION
		virtual Error SetCCPacketHook(MPEG2CCPacketHookHandle hook) = 0;
#endif
		virtual DWORD SendDataSplit(MPEGElementaryStreamType type, HPTR data, DWORD size, LONG time) = 0;
		virtual void CompleteDataSplit(MPEGElementaryStreamType type) = 0;
		virtual void RestartDataSplit(MPEGElementaryStreamType type) = 0;

		virtual Error SetAudioType(MPEG2AudioType audioType) {this->audioType = audioType; GNRAISE_OK;}
	public:
		VirtualUnit * CreateVirtual(void);

		virtual VirtualMPEG2AVDecoder * CreateVirtualMPEGDecoder(void) = 0;
   };

class VirtualMPEG2AVDecoder : public VirtualMPEG2ElementaryDecoder
	{
	private:
		MPEG2AVDecoder * decoder;
	protected:
   	MPEGStreamType		streamType;
		MPEGStreamMode		streamMode;
   	BOOL					mpeg2Coding;
   	BOOL					ac3;
   	BOOL					lpcm;
   	DWORD					audioBitrate;
		DWORD					videoBitrate;
		DWORD					streamBitrate;
		WORD					videoWidth;
		WORD					videoHeight;
		WORD					videoFPS;
		WORD					aspectRatio;
//		VideoStandard		videoStandard;		// why is this here????
		WORD					sampleRate;
		WORD					leftVolume;
		WORD					rightVolume;
		BOOL					audioMute;

		AC3BassConfig  	bassConfig;
		AC3SpeakerConfig  speakerConfig;
		WORD					centerDelay;
		WORD					surroundDelay;
		WORD					centerVolume;
		WORD					leftSurroundVolume;
		WORD					rightSurroundVolume;
		WORD					subwooferVolume;

		BYTE					videoStreamID;
		BYTE					audioStreamID;
		BYTE					ac3StreamID;
		BYTE					lpcmStreamID;
		BYTE					dtsStreamID;
		BYTE					mlpStreamID;
		BYTE					spuStreamID;
		WORD					channels;
		WORD					bitsPerSample;
		MPEG2PresentationMode	presentationMode;

		BOOL					spuEnable;
		SPUButtonState		buttonState;
		WORD					bx, by, bw, bh;
		DWORD					buttonSelectColor;
		DWORD					buttonActiveColor;
		DWORD					spuPalette[16];
		WORD					buttonID;
		MPEG2SPUCommandHookHandle	spuCommandHook;

#if WDM_VERSION
		MPEG2CCPacketHookHandle		ccPacketHook;
#endif
		MPEG2AudioType		audioType;

		Error PreemptChange(VirtualUnit * previous);
	public:
		VirtualMPEG2AVDecoder(MPEG2AVDecoder * decoder);

		Error Configure(TAG __far * tags);

      virtual Error DoAuthenticationCommand(MPEG2DVDAuthenticationCommand com, DWORD sector, BYTE __far * key);
		virtual Error GetDisplaySize(WORD __far &width, WORD __far &height) = 0;
		virtual DWORD SendDataSplit(MPEGElementaryStreamType type, HPTR data, DWORD size, LONG time);
		virtual void CompleteDataSplit(MPEGElementaryStreamType type);
		virtual void RestartDataSplit(MPEGElementaryStreamType type);

		virtual Error SetLine21Receiver(Line21Receiver * line21Receiver);
	};

#endif // ONLY_EXTERNAL_VISIBLE

#endif // MPEG2DEC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\generic\mp2spudc.h ===
#ifndef MP2SPUDC
#define MP2SPUDC

#include "mp2eldec.h"
#include "library\general\lists.h"
#include "library\lowlevel\kernlmem.h"

#define GNR_SPU_OVERLAY_NOT_SUPPORTED		MKERR(ERROR, SUBPICTURE, GENERAL, 0x01)

#ifndef ONLY_EXTERNAL_VISIBLE

class OSDDisplay
	{
	protected:
		WORD osdColorMask;
	public:
	   virtual Error KillOSDBitmap(void) = 0;
	   
	   virtual Error SetOSDBitmap(WORD numColors, 
	   								   BYTE __far * colorTable, BYTE __far * contrastTable,
	                              WORD x, WORD y, WORD width, WORD height,
	                              DWORD __huge * odd, DWORD __huge * even) = 0;
	
		virtual Error SetOSDPalette(int entry, int y, int u, int v) = 0;	                                   
		
		virtual Error ShowOSD(BOOL enable) = 0;
	};

class SPUDisplay
	{
	public:
		virtual ~SPUDisplay(void) {}
		
		virtual Error KillSPUBitmap(void) = 0;
		virtual Error SetSPUBitmap(BYTE __far * odd, BYTE __far * even) = 0;

		virtual Error SetSPUPosition(int x, int y, int w, int h) = 0;
		virtual Error SetSPUColors(int back, int front, int emph1, int emph2) = 0;
		virtual Error SetSPUContrast(int back, int front, int emph1, int emph2) = 0;
	   virtual Error SetSPUExtColors(int sBack, int sFront, int sEmph1, int sEmph2,
	                                 int aBack, int aFront, int aEmph1, int aEmph2) = 0;
	   virtual Error SetSPUExtContrast(int sBack, int sFront, int sEmph1, int sEmph2,
	                                   int aBack, int aFront, int aEmph1, int aEmph2) = 0;
		virtual Error SetSPUPalette(int entry, int y, int u, int v) = 0;	                                   
		
		virtual Error SetButtonPosition(int x, int y, int w, int h) = 0;

		virtual Error ShowSPU(BOOL enable) = 0;		
		virtual Error ShowButton(SPUButtonState state) = 0;
		
		virtual Error Update(void) {GNRAISE_OK;}
	};


class SPUonOSDDisplay : public SPUDisplay
	{
	private:
		OSDDisplay	*	osd;
	   
	   BYTE				baseColorTable[12];
	   BYTE				baseContrastTable[12];
	   
	   BYTE				usedColorTable[8];
	   BYTE				usedContrastTable[8];
	   
	   KernelMemory	oddBitmapMemory;
	   KernelMemory	evenBitmapMemory;
	   
	   DWORD	__huge *	oddBitmapBuffer;
	   DWORD	__huge *	evenBitmapBuffer;
	   
	   BYTE	__far *	odd;
	   BYTE	__far *	even;
	   
	   WORD GetBitmapUsage(BYTE __far * map, WORD width, WORD height, WORD visibleMask, 
	                       WORD __far & firstVisible, WORD __far & lastVisible);
		
		Error DecodeBitmap2(BYTE __far * map, DWORD __huge * bitmapBuffer, 
		                    WORD width, WORD height, BYTE __far * colorLUT,
		                    WORD skipTop, WORD skipLeft, WORD skipRight);
		Error DecodeBitmap2Button(BYTE __far * map, DWORD __huge * bitmapBuffer, 
		                          WORD width, WORD height, BYTE __far * colorLUT,
		                          WORD skipTop,
		                          WORD buttonLeft, WORD buttonTop, WORD buttonWidth, WORD buttonHeight);
		Error DecodeBitmap4Button(BYTE __far * map, DWORD __huge * bitmapBuffer, 
		                          WORD width, WORD height, BYTE __far * colorLUT,
		                          WORD skipTop,
		                          WORD buttonLeft, WORD buttonTop, WORD buttonWidth, WORD buttonHeight);

		DWORD				changed;
		
		BOOL				enabled;
		WORD				x, y, w, h;
		WORD				bx, by, bw, bh;
	   SPUButtonState	buttonState;

   	WORD colorMask, colorVisibleMask;
		WORD topVisible, bottomVisible;
	public:
		SPUonOSDDisplay(OSDDisplay * osd);
		~SPUonOSDDisplay(void);
		
		Error KillSPUBitmap(void);
		Error SetSPUBitmap(BYTE __far * odd, BYTE __far * even);
		
		Error SetSPUPosition(WORD x, WORD y, WORD w, WORD h);
		Error SetSPUColors(int back, int front, int emph1, int emph2);
		Error SetSPUContrast(int back, int front, int emph1, int emph2);
	 	Error SetSPUExtColors(int sBack, int sFront, int sEmph1, int sEmph2,
	                         int aBack, int aFront, int aEmph1, int aEmph2);
		Error SetSPUExtContrast(int sBack, int sFront, int sEmph1, int sEmph2,
	                           int aBack, int aFront, int aEmph1, int aEmph2);
		Error SetSPUPalette(int entry, int y, int u, int v);
	              
		Error SetButtonPosition(WORD x, WORD y, WORD w, WORD h);
		
		Error ShowSPU(BOOL enable);
		Error ShowButton(SPUButtonState state);

	   Error Update(void);
	};
	
class SPUEntry : public Node
	{
	friend class SPUDecoder;
	private:
		DWORD	startPTS;
		DWORD	nextPTS;
			   
		
		KernelMemory	bufferMem;
		BYTE __far *	buffer;
		WORD				bufferSize;		
		
		WORD				nextCommand;
		
		SPUEntry(WORD size);
	};

class GenericSPUDecoder : public MPEG2StreamReceiver
	{
	protected:
		MPEG2SPUCommandHookHandle	commandHook;
	public:
		GenericSPUDecoder(void) {commandHook = NULL;}
		virtual ~GenericSPUDecoder(void) {}

		virtual Error EnableSPU(BOOL enable) = 0;

		virtual Error SendCommand(MPEGCommand com, DWORD param, DWORD __far &tag);

		Error SetCommandHook(MPEG2SPUCommandHookHandle commandHook) {this->commandHook = commandHook; GNRAISE_OK;}
		virtual Error SetButtonState(SPUButtonState state) = 0;
		virtual Error SetButtonPosition(int x, int y, int w, int h) = 0;
		virtual Error SetButtonColors(DWORD selected, DWORD active) = 0;
		virtual Error SetPalette(int entry, int y, int u, int v) = 0;

		virtual Error Configure(TAG __far * tags);
	};

class SPUDecoder : public GenericSPUDecoder, public PTSCallback
	{
	private:
		List				pending, free;
		SPUDisplay	*	display;
		PTSCaller	*	ptsCaller;
		SPUEntry		*	current;
		SPUEntry		*	filled;
		BOOL				predPending;
				
		enum FillingState {FS_IDLE, FS_FIRST, FS_REST, FS_SKIP} fillingState;
		
		WORD				fillSize;
		BYTE	__far	*	fillPtr;
		
		DWORD				nextPTS;
		BOOL				enabled;
		BOOL				visible;
	   SPUButtonState	buttonState;

		MPEG2SPUCommandHookHandle	commandHook;
	public:
		SPUDecoder(SPUDisplay * display, PTSCaller * ptsCaller);
		virtual ~SPUDecoder(void);
		
		Error EnableSPU(BOOL enable);
	
	   DWORD SendData(HPTR data, DWORD size);
	   void CompleteData(void);
	   void FlushData(void);
	   DWORD LastTransferLocation(DWORD scale) {return 0;}
	
	   void PutPTS(DWORD pts);	
	   
	   Error PTSCallbackReached(DWORD currentPTS);
	   
	   virtual Error SetCommandHook(MPEG2SPUCommandHookHandle commandHook);
	   virtual Error SetButtonState(SPUButtonState state);
	   virtual Error SetButtonPosition(int x, int y, int w, int h);
	   virtual Error SetButtonColors(DWORD selected, DWORD active);
	   virtual Error SetPalette(int entry, int y, int u, int v);
	};

class SPUPESDecoder : public SPUDecoder
	{
	protected:
		BOOL	pesMode;
	public:
		SPUPESDecoder(SPUDisplay * display, PTSCaller * ptsCaller);
		
		Error SendPESData(HPTR data, DWORD size, DWORD __far & done, DWORD __far & used);
		MPEG2PESType NeedsPES(void) {return pesMode ? MP2PES_DVD : MP2PES_ELEMENTARY;}
				
		Error SetPESMode(BOOL pesMode);
	};

class EncryptedSPUPESDecoder : public SPUPESDecoder
	{
	protected:
		struct PESBuffer
			{
			DWORD				pts;
			BOOL				pending;
			BYTE				space[2048];
			} __far * buffer;
		KernelMemory		bufferMem;
		WORD					bufferSize;
		WORD					bufferFirst, bufferLast;
		DWORD 				pesPTS;
      WORD					bufferSemaphore;
      
		void ResetPESBuffer(void);
		
		virtual DWORD SendDecryptionPacket(HPTR data, DWORD size) {ReturnDecryptionPacket(data, size); return size;}
		void ReturnDecryptionPacket(HPTR data, DWORD size);		
	public:		
		EncryptedSPUPESDecoder(SPUDisplay * display, PTSCaller * ptsCaller);
	
		Error SendPESData(HPTR data, DWORD size, DWORD __far & done, DWORD __far & used);
	   void FlushData(void);
	
	   void PutPTS(DWORD pts);		
	};

#endif	
	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\generic\mp2eldec.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


// FILE:      library\hardware\mpeg2dec\generic\mp2eldec.h
// AUTHOR:    U. Sigmund, S. Herr
// COPYRIGHT: (c) 1998 VIONA Development GmbH.  All Rights Reserved.
// CREATED:
//
// PURPOSE:   MPEG2 elementary video/audio decoders and supporting classes.
//
// HISTORY:

#ifndef MP2ELDEC_H
#define MP2ELDEC_H

#include "library/common/prelude.h"
#include "library/common/gnerrors.h"
#include "library/hardware/mpegdec/generic/mpegdec.h"
#include "library/hardware/audio/generic/ac3setup.h"
#include "library/hardware/audio/generic/karaokesetup.h"
#include "library/hardware/video/generic/ccapvenc.h"
#include "library/hardware/mpeg2dec/generic/MP2StreamReceiver.h"

enum SPUButtonState
	{
	SBS_DISABLED,
	SBS_SELECTED,
	SBS_ACTIVATED
	};

struct MPEG2SPUCommandMsg {
	DWORD		pts;
	int		command;
	};

MKHOOK(MPEG2SPUCommand, MPEG2SPUCommandMsg)

typedef MPEG2SPUCommandHook	__far *	MPEG2SPUCommandHookPtr;

//
//  Error definitions
//

#define GNR_DISPLAY_MODE_NOT_SUPPORTED					MKERR(ERROR, MPEG, FORMAT, 0x00)
// The display mode could not be set

#define GNR_AUDIO_TYPE_NOT_SUPPORTED					MKERR(ERROR, MPEG, FORMAT, 0x01)
// The audio format is not supported

#define GNR_NO_SPDIF_HARDWARE								MKERR(ERROR, MPEG, HARDWARE, 0x02)
// We do not SPDIF hardware

#define GNR_FRAME_ADVANCE_BOUNDARY_REACHED			MKERR(WARNING, MPEG, BOUNDS, 0x03)

enum MPEG2PresentationMode
	{
	MPM_FULLSIZE,
	MPM_LETTERBOXED,
	MPM_PANSCAN,
	MPM_FULLSIZE16by9
	};

enum SPDIFHandling
	{
	SPDIFH_DEFAULT,			// On when playback is running, off in all other cases
	SPDIFH_ON,					// Always physically on
	SPDIFH_OFF					// Always physically off (line idle)
	};

// This can be specified for each audio type
enum SPDIFOutputMode
	{
	SPDIFOM_DEFAULT,			// AC3: compressed, LPCM: decompressed, idle: NULL output
	SPDIFOM_DECOMPRESSED,	// Force decompressed output, even for AC3
	SPDIFOM_MUTE_NULL,		// Force mute with NULL output, if SPDIF_ON
	SPDIFOM_OFF					// Physically off
	};

enum SPDIFCopyMode
	{
	SPDIFCM_DEFAULT,			// Use system's default (transfer rights from source material to output)
	SPDIFCM_NO_COPIES,		// do not allow any copies
	SPDIFCM_ONE_GENERATION,	// allow one generation of copies
	SPDIFCM_UNRESTRICTED		// no copy restrictions
	};

enum MPEG2SplitStreamType
	{
	MP2SST_DVD_ENCRYPTED,
	MP2SST_PROGRAM,
	MP2SST_PES,
	MP2SST_ELEMENTARY
	};

// Basic Audio Source Type
enum MPEG2AudioType
	{
	MP2AUDTYP_DEFAULT,		// means: use MPEG2_AUDIO_AC3 and MPEG2_AUDIO_LPCM tags to determine audio type
	MP2AUDTYP_MPEG,			// MPEG(-1) all layers
	MP2AUDTYP_MPEG2,
	MP2AUDTYP_AC3,
	MP2AUDTYP_LPCM,			// includes CDDA (set # of bits and sample rate accordingly)
	MP2AUDTYP_DTS,
	MP2AUDTYP_SDDS,
	MP2AUDTYP_DTS_CDDA,		// CDDA with DTS information
	MP2AUDTYP_MLP,

	MP2AUDTYP_NUMBER_OF_TYPES
	};

// Virtual Surround ("Spatializer") modes
enum MPEG2AudioSpatializer
	{
	MP2AUDSPAT_DEFAULT,
	MP2AUDSPAT_NONE = MP2AUDSPAT_DEFAULT,
	MP2AUDSPAT_SRS_TS_3D,			// SRS True Surround or 3D sound, depending on source material
	MP2AUDSPAT_VMAX_TS_3D		// VMAX True Surround or 3D sound, depending on source material
	};

// PCM Output Configurations (= Bass Redirection Schemes)
enum PCMOutputConfig
	{
	PCMOCFG_DEFAULT,	// ALL, scaled, is default
	PCMOCFG_ALL = PCMOCFG_DEFAULT,
	PCMOCFG_LSW,
	PCMOCFG_LLR,
	PCMOCFG_SLP,
	PCMOCFG_SUM,		// subwoofer = sum of all input channels
	PCMOCFG_BYP,		// Bypass
	PCMOCFG_LSW_WF    // same as config 1 without filters
	};

// Downsample mode for 96kHz LPCM
enum PCM96DownsampleMode
	{
	PCM96DWNS_DEFAULT,
	PCM96DWNS_DOWN_48KHZ = PCM96DWNS_DEFAULT,	// sample down to 48kHz by default
	PCM96DWNS_NONE										// no downsampling, play back using 96kHz
	};


// Program Format Flags for tag MPEG2_AUDIO_PROGRAM_FORMAT
#define AUDPF_PROLOGIC			MKFLAG(0)	// Indicates if Pro Logic Decoding is active or not
#define AUDPF_LEFT				MKFLAG(1)	// Shows if program contains
#define AUDPF_RIGHT				MKFLAG(2)
#define AUDPF_CENTER				MKFLAG(3)
#define AUDPF_LFE					MKFLAG(4)
#define AUDPF_LEFT_SURROUND	MKFLAG(5)
#define AUDPF_RIGHT_SURROUND	MKFLAG(6)
#define AUDPF_MONO_SURROUND	MKFLAG(7)


//
//  CDDA Data Format
//  Describes formats supported by decoder
//

#define CDDADF_AUDIO_ONLY			MKFLAG(0)			// Only audio data (corresponds to LPCM, 2 ch, 16 Bit, 44.1 kHz), default
#define CDDADF_AUDIO_SUBCHANNEL	MKFLAG(1)			// For each block first audio data (2352 bytes), then subchannel (98 bytes)
#define CDDADF_SUBCHANNEL_AUDIO	MKFLAG(2)			// For each block first subchannel (98 bytes), then audio data (2352 bytes)
#define CDDADF_DEFAULT				CDDADF_AUDIO_ONLY

//
//  LPCM Data Format (Endianess)
//

enum LPCMDataFormat
	{
	LDF_BIG_ENDIAN,
	LDF_LITTLE_ENDIAN
	};

//
//  Audio Type Config
//

struct AudioTypeConfig
	{
	union
		{
		struct
			{
			SPDIFOutputMode	spdifOutMode : 3;
			// ...can be expanded up to size of a DWORD...
			} config;

		DWORD	dummy;
		};

	friend BOOL operator==(const AudioTypeConfig a, const AudioTypeConfig b);
	friend BOOL operator!=(const AudioTypeConfig a, const AudioTypeConfig b);

	operator DWORD (void) {return dummy;}

	AudioTypeConfig(DWORD arg) {dummy = arg;}
	AudioTypeConfig(void) {dummy = 0;}
	AudioTypeConfig(SPDIFOutputMode initMode)
		{
		config.spdifOutMode = initMode;
		// ...
		}
	};

inline BOOL operator==(const AudioTypeConfig a, const AudioTypeConfig b)
	{
	return (a.dummy == b.dummy);
	}

//static inline BOOL operator!=(const AudioTypeConfig a, const AudioTypeConfig b)
inline BOOL operator!=(const AudioTypeConfig a, const AudioTypeConfig b)
	{
	return (a.dummy != b.dummy);
	}

#if WDM_VERSION

struct MPEG2CCPacketMsg
	{
	BOOL startField;
	BYTE * data;
	int num;
	};

MKHOOK(MPEG2CCPacket, MPEG2CCPacketMsg)

typedef MPEG2CCPacketHook * MPEG2CCPacketHookPtr;

#endif	// WDM_VERSION

enum ForcedAspectRatio
	{
	FORCED_AR_DEFAULT	= 0,
	// 1 left out. Do not change the following two assignments:
	FORCED_AR_4_BY_3	= 2,
	FORCED_AR_16_BY_9	= 3
	};

enum FrameRateValue
	{
	FRV_23976 = 1,
	FRV_24000 = 2,
	FRV_25000 = 3,
	FRV_29970 = 4,
	FRV_30000 = 5,
	FRV_50000 = 6,
	FRV_59940 = 7,
	FRV_60000 = 8
	};


// Bits for audio speaker test bitfield (MPEG2_AUDIO_TEST_SPEAKER_SELECT)
#define AUDIO_TEST_LEFT_SPEAKER				0x01
#define AUDIO_TEST_RIGHT_SPEAKER				0x02
#define AUDIO_TEST_CENTER_SPEAKER			0x04
#define AUDIO_TEST_SUBWOOFER_SPEAKER		0x08
#define AUDIO_TEST_LEFT_SURROUND_SPEAKER	0x10
#define AUDIO_TEST_RIGHT_SURROUND_SPEAKER	0x20



MKTAG(MPEG2_AUDIO_AC3,						MPEG_DECODER_UNIT,	0x1001, BOOL)
MKTAG(MPEG2_AUDIO_AC3_STREAMID,			MPEG_DECODER_UNIT,	0x1002, BYTE)
MKTAG(MPEG2_CODING_STANDARD,	  		   MPEG_DECODER_UNIT,	0x1003, BOOL)

MKTAG(MPEG2_AC3_BASS_CONFIG,				MPEG_DECODER_UNIT,	0x1004, AC3BassConfig)
MKTAG(MPEG2_AC3_SPEAKER_CONFIG,			MPEG_DECODER_UNIT,	0x1005, AC3SpeakerConfig)
MKTAG(MPEG2_AC3_CENTER_DELAY,				MPEG_DECODER_UNIT,	0x1006, WORD)
MKTAG(MPEG2_AC3_SURROUND_DELAY,			MPEG_DECODER_UNIT,	0x1007, WORD)

MKTAG(MPEG2_AC3_CENTER_VOLUME,			MPEG_DECODER_UNIT,	0x1008, WORD)
MKTAG(MPEG2_AC3_LEFT_SURROUND_VOLUME,  MPEG_DECODER_UNIT,	0x1009, WORD)
MKTAG(MPEG2_AC3_RIGHT_SURROUND_VOLUME,	MPEG_DECODER_UNIT,	0x100a, WORD)
MKTAG(MPEG2_AC3_SUBWOOFER_VOLUME,		MPEG_DECODER_UNIT,	0x100b, WORD)

MKTAG(MPEG2_AC3_DUAL_MODE_CONFIG,		MPEG_DECODER_UNIT,	0x100c, AC3DualModeConfig)
MKTAG(MPEG2_AC3_KARAOKE_CONFIG,			MPEG_DECODER_UNIT,	0x100d, AC3KaraokeConfig)

MKTAG(MPEG2_SPU_STREAMID,					MPEG_DECODER_UNIT,	0x1010, BYTE)
MKTAG(MPEG2_SPU_ENABLE,						MPEG_DECODER_UNIT,	0x1011, BOOL)

MKTAG(MPEG2_SPU_BUTTON_STATE,				MPEG_DECODER_UNIT,	0x1012, SPUButtonState)
MKTAG(MPEG2_SPU_BUTTON_LEFT,				MPEG_DECODER_UNIT,	0x1013, WORD)
MKTAG(MPEG2_SPU_BUTTON_TOP,				MPEG_DECODER_UNIT,	0x1014, WORD)
MKTAG(MPEG2_SPU_BUTTON_WIDTH,				MPEG_DECODER_UNIT,	0x1015, WORD)
MKTAG(MPEG2_SPU_BUTTON_HEIGHT,			MPEG_DECODER_UNIT,	0x1016, WORD)
MKTAG(MPEG2_SPU_BUTTON_SELECT_COLOR,	MPEG_DECODER_UNIT,	0x1017, DWORD)
MKTAG(MPEG2_SPU_BUTTON_ACTIVE_COLOR,	MPEG_DECODER_UNIT,	0x1018, DWORD)
MKTAG(MPEG2_SPU_PALETTE_ENTRY,			MPEG_DECODER_UNIT,	0x1019, DWORD)
	// Palette Bits 0..7 Pen, 8..15 V, 16..23 U, 24..31 Y
MKTAG(MPEG2_SPU_COMMAND_HOOK,				MPEG_DECODER_UNIT,	0x101a, MPEG2SPUCommandHookPtr)
MKTAG(MPEG2_SPU_BUTTON_ID,					MPEG_DECODER_UNIT,	0x101b, WORD)
MKTAG(MPEG2_SPU_BUTTON_STARTTIME,		MPEG_DECODER_UNIT,	0x101c, DWORD)
MKTAG(MPEG2_SPU_BUTTON_ENDTIME,			MPEG_DECODER_UNIT,	0x101d, DWORD)

MKTAG(MPEG2_AUDIO_LPCM,						MPEG_DECODER_UNIT,	0x1021, BOOL)
MKTAG(MPEG2_AUDIO_LPCM_STREAMID,			MPEG_DECODER_UNIT,	0x1022, BYTE)
MKTAG(MPEG2_LPCM_BITSPERSAMPLE,			MPEG_DECODER_UNIT,	0x1023, WORD)
MKTAG(MPEG2_LPCM_CHANNELS,					MPEG_DECODER_UNIT,	0x1024, WORD)

MKTAG(MPEG2_AUDIO_DTS_STREAMID,			MPEG_DECODER_UNIT,	0x1028, BYTE)
MKTAG(MPEG2_AUDIO_MLP_STREAMID,			MPEG_DECODER_UNIT,	0x1029, BYTE)

MKTAG(MPEG2_PRESENTATION_MODE,			MPEG_DECODER_UNIT,	0x1030, MPEG2PresentationMode)

MKTAG(MPEG2_DVD_STREAM_DEMUX,				MPEG_DECODER_UNIT,	0x1031, BOOL)
MKTAG(MPEG2_DVD_STREAM_ENCRYPTED,		MPEG_DECODER_UNIT,	0x1032, BOOL)

#if WDM_VERSION
// Do not use this tag from user mode!
MKTAG(MPEG2_CC_PACKET_HOOK,				MPEG_DECODER_UNIT,	0x1033, MPEG2CCPacketHookPtr)
#endif

// Use this for overriding the default handling of switching ON/OFF SPDIF output
// (on decoders that can control SPDIF out)
MKTAG(MPEG2_SPDIF_HANDLING,				MPEG_DECODER_UNIT,	0x1034, SPDIFHandling)
MKTAG(MPEG2_SPDIF_OUTPUT_MODE,			MPEG_DECODER_UNIT,	0x1035, SPDIFOutputMode)
MKTAG(MPEG2_SPDIF_COPY_MODE,				MPEG_DECODER_UNIT,	0x1036, SPDIFCopyMode)

// This supercedes tags MPEG2_AUDIO_AC3 and MPEG2_AUDIO_LPCM, if available
MKTAG(MPEG2_AUDIO_TYPE,						MPEG_DECODER_UNIT,	0x103a, MPEG2AudioType)

// Specifies audio spatializing algorithm (e.g. SRS True Surround)
MKTAG(MPEG2_AUDIO_SPATIALIZER,			MPEG_DECODER_UNIT,	0x103b, MPEG2AudioSpatializer)

MKTAG(MPEG2_POSITION_SCALE,				MPEG_DECODER_UNIT,	0x1040, DWORD)

// Tags for downscaling the MPEG image and positioning it at an offset.
MKTAG(MPEG2_DOWNSCALE_FACTOR,				MPEG_DECODER_UNIT,	0x1050, int)
MKTAG(MPEG2_DOWNSCALE_HOFFSET,			MPEG_DECODER_UNIT,	0x1051, int)
MKTAG(MPEG2_DOWNSCALE_VOFFSET,			MPEG_DECODER_UNIT,	0x1052, int)
MKTAG(MPEG2_DOWNSCALE_HOFFSET_LBOXED,	MPEG_DECODER_UNIT,	0x1053, int)
MKTAG(MPEG2_DOWNSCALE_VOFFSET_LBOXED,	MPEG_DECODER_UNIT,	0x1054, int)

// New smooth zoom interface:
MKTAG(MPEG2_ZOOM_FACTOR,					MPEG_DECODER_UNIT,	0x1060, int)
MKTAG(MPEG2_ZOOM_SPEED,						MPEG_DECODER_UNIT,	0x1061, int)
MKTAG(MPEG2_ZOOM_ACTION,					MPEG_DECODER_UNIT,	0x1062, int)
MKTAG(MPEG2_ZOOM_HOFFSET,					MPEG_DECODER_UNIT,	0x1063, int)
MKTAG(MPEG2_HOFFSET_SPEED,					MPEG_DECODER_UNIT,	0x1064, int)
MKTAG(MPEG2_HOFFSET_ACTION,				MPEG_DECODER_UNIT,	0x1065, int)
MKTAG(MPEG2_ZOOM_VOFFSET,					MPEG_DECODER_UNIT,	0x1066, int)
MKTAG(MPEG2_VOFFSET_SPEED,					MPEG_DECODER_UNIT,	0x1067, int)
MKTAG(MPEG2_VOFFSET_ACTION,				MPEG_DECODER_UNIT,	0x1068, int)
MKTAG(MPEG2_PIP_HOFFSET,					MPEG_DECODER_UNIT,	0x1069, int)
MKTAG(MPEG2_PIP_VOFFSET,					MPEG_DECODER_UNIT,	0x1070, int)


MKTAG(MPEG2_AC3_EQUALIZER_FRONT_ENABLE,MPEG_DECODER_UNIT,	0x1100, BOOL)
MKTAG(MPEG2_AC3_EQUALIZER_BACK_ENABLE,	MPEG_DECODER_UNIT,	0x1101, BOOL)
MKTAG(MPEG2_AC3_EQUALIZER_FRONT,			MPEG_DECODER_UNIT,	0x1104, DWORD)
MKTAG(MPEG2_AC3_EQUALIZER_BACK,			MPEG_DECODER_UNIT,	0x1105, DWORD)
MKTAG(MPEG2_STILL_FRAME_SEQUENCE,		MPEG_DECODER_UNIT,	0x1106, BOOL)
MKTAG(MPEG2_CURRENT_PLAYBACK_TIME,		MPEG_DECODER_UNIT,	0x1107, LONG)
MKTAG(MPEG2_AC3_VIRTUAL_3D_AUDIO,		MPEG_DECODER_UNIT,	0x1108, BOOL)

// Tags for split stream playback configuration
MKTAG(MPEG2_VIDEO_SPLIT_STREAM_TYPE,	MPEG_DECODER_UNIT,	0x1109, MPEG2SplitStreamType)
MKTAG(MPEG2_AUDIO_SPLIT_STREAM_TYPE,	MPEG_DECODER_UNIT,	0x1110, MPEG2SplitStreamType)
MKTAG(MPEG2_SPU_SPLIT_STREAM_TYPE,		MPEG_DECODER_UNIT,	0x1111, MPEG2SplitStreamType)

MKTAG(MPEG2_FORCED_SOURCE_ASPECT_RATIO, MPEG_DECODER_UNIT,	0x1120, ForcedAspectRatio)
// Switch to WDM playback (meaning: no navpacks in DVD data streams)
MKTAG(MPEG2_WDM_PLAYBACK,					MPEG_DECODER_UNIT,	0x1122, BOOL)
// Returns current value of the decoder's STC
MKTAG(MPEG2_CURRENT_STC,					MPEG_DECODER_UNIT,	0x1123, LONG)

MKTAG(MPEG2_REQUESTED_PLAYBACK_TIME,   MPEG_DECODER_UNIT,   0x1130, LONG)

// Closed Caption output on/off
MKTAG(MPEG2_CC_ENABLE,						MPEG_DECODER_UNIT,	0x1140, BOOL)

// Additional delay tags
MKTAG(MPEG2_AC3_LEFT_DELAY,				MPEG_DECODER_UNIT,	0x1200, WORD)
MKTAG(MPEG2_AC3_RIGHT_DELAY,				MPEG_DECODER_UNIT,	0x1201, WORD)
MKTAG(MPEG2_AC3_LEFT_SURROUND_DELAY,	MPEG_DECODER_UNIT,	0x1202, WORD)
MKTAG(MPEG2_AC3_RIGHT_SURROUND_DELAY,	MPEG_DECODER_UNIT,	0x1203, WORD)
MKTAG(MPEG2_AC3_SUBWOOFER_DELAY,			MPEG_DECODER_UNIT,	0x1204, WORD)

// Dolby Pro Logic Decoder config and mode
MKTAG(MPEG2_PRO_LOGIC_CONFIG,				MPEG_DECODER_UNIT,	0x1210, DolbyProLogicConfig)
MKTAG(MPEG2_PRO_LOGIC_MODE,				MPEG_DECODER_UNIT,	0x1211, DolbyProLogicMode)

// Low Frequency Enable (LFE). Applicable for AC3, MPEG2-MC and DTS stream playback
MKTAG(MPEG2_DECODE_LFE,						MPEG_DECODER_UNIT,	0x1220, BOOL)

// GET only tag that returns whether a LFE channel is present (and being decoded) or not
MKTAG(MPEG2_LFE_STATUS,						MPEG_DECODER_UNIT,	0x1221, BOOL)

// AC3 Audio Coding Mode (acmod property). GET only.
MKTAG(MPEG2_AC3_AUDIO_CODING_MODE,		MPEG_DECODER_UNIT,	0x1225, AC3AudioCodingMode)

// Returns TRUE if Pro Logic decoding is active
MKTAG(MPEG2_PROLOGIC_STATUS,				MPEG_DECODER_UNIT,	0x1226, BOOL)

// PCM output configuration
MKTAG(MPEG2_PCM_OUTPUT_CONFIG,			MPEG_DECODER_UNIT,	0x1230, PCMOutputConfig)

// Dynamic range
MKTAG(MPEG2_AC3_DYNAMIC_RANGE,			MPEG_DECODER_UNIT,	0x1236, AC3DynamicRange)
MKTAG(MPEG2_AC3_HIGH_DYNAMIC_RANGE,		MPEG_DECODER_UNIT,	0x1237, WORD)
MKTAG(MPEG2_AC3_LOW_DYNAMIC_RANGE,		MPEG_DECODER_UNIT,	0x1238, WORD)

MKTAG(MPEG2_AC3_DIALOG_NORM,			MPEG_DECODER_UNIT,	0x1239, AC3DialogNorm)
MKTAG(MPEG2_AC3_OPERATIONAL_MODE,		MPEG_DECODER_UNIT,	0x123a, AC3OperationalMode)

// Audio type specific configurations
MKTAG(MPEG2_AC3_AUDIO_TYPE_CONFIG,		MPEG_DECODER_UNIT,	0x1240, AudioTypeConfig)
MKTAG(MPEG2_LPCM_AUDIO_TYPE_CONFIG,		MPEG_DECODER_UNIT,	0x1241, AudioTypeConfig)
MKTAG(MPEG2_DTS_AUDIO_TYPE_CONFIG,		MPEG_DECODER_UNIT,	0x1242, AudioTypeConfig)
MKTAG(MPEG2_MPEG_AUDIO_TYPE_CONFIG,		MPEG_DECODER_UNIT,	0x1243, AudioTypeConfig)
MKTAG(MPEG2_MPEG2_AUDIO_TYPE_CONFIG,	MPEG_DECODER_UNIT,	0x1244, AudioTypeConfig)
MKTAG(MPEG2_SDDS_AUDIO_TYPE_CONFIG,		MPEG_DECODER_UNIT,	0x1245, AudioTypeConfig)
MKTAG(MPEG2_CDDA_DTS_AUDIO_TYPE_CONFIG,MPEG_DECODER_UNIT,	0x1246, AudioTypeConfig)
MKTAG(MPEG2_MLP_AUDIO_TYPE_CONFIG,		MPEG_DECODER_UNIT,	0x1247, AudioTypeConfig)

MKTAG(MPEG2_PCM96_DOWNSAMPLE_MODE_DAC,		MPEG_DECODER_UNIT,	0x1300, PCM96DownsampleMode)
MKTAG(MPEG2_PCM96_DOWNSAMPLE_MODE_SPDIF,	MPEG_DECODER_UNIT,	0x1301, PCM96DownsampleMode)

MKTAG(MPEG2_VIDEO_MIN_PLAYBACK_SPEED,	MPEG_DECODER_UNIT,	0x1330, WORD)
MKTAG(MPEG2_VIDEO_MAX_PLAYBACK_SPEED,	MPEG_DECODER_UNIT,	0x1331, WORD)

MKTAG(MPEG2_AUDIO_MIN_PLAYBACK_SPEED,	MPEG_DECODER_UNIT,	0x1334, WORD)
MKTAG(MPEG2_AUDIO_MAX_PLAYBACK_SPEED,	MPEG_DECODER_UNIT,	0x1335, WORD)

MKTAG(MPEG2_VIDEO_MIN_SCAN_SPEED,		MPEG_DECODER_UNIT,	0x1340, WORD)
MKTAG(MPEG2_VIDEO_MAX_SCAN_SPEED,		MPEG_DECODER_UNIT,	0x1341, WORD)

MKTAG(MPEG2_AUDIO_MIN_SCAN_SPEED,		MPEG_DECODER_UNIT,	0x1344, WORD)
MKTAG(MPEG2_AUDIO_MAX_SCAN_SPEED,		MPEG_DECODER_UNIT,	0x1345, WORD)

// Use this tag to damp volume during scan modes
MKTAG(MPEG2_AUDIO_VOLUME_DAMP,			MPEG_DECODER_UNIT,	0x1346, BOOL)

// Speaker selection for audio tests (e.g. pink noise test). Bitfield defined above.
MKTAG(MPEG2_AUDIO_TEST_SPEAKER_SELECT,	MPEG_DECODER_UNIT,	0x1350, WORD)

// Data format for CDDA decoder, should be Get/Set
MKTAG(CDDA_DATA_FORMAT,						MPEG_DECODER_UNIT,	0x1400, DWORD)

// Endianess of LPCM decoder (Qry/Get)
MKTAG(LPCM_DATA_FORMAT,						MPEG_DECODER_UNIT,	0x1401, LPCMDataFormat)

MKTAG(MPEG2_TIMEOUT_MSG,					MPEG_DECODER_UNIT,	0x1500, WORD)
MKTAG(MPEG2_REFILL_MSG,						MPEG_DECODER_UNIT,	0x1501, WORD)
MKTAG(MPEG2_DONE_MSG,						MPEG_DECODER_UNIT,	0x1502, WORD)
MKTAG(MPEG2_SIGNAL_MSG,						MPEG_DECODER_UNIT,	0x1503, WORD)
MKTAG(MPEG2_ERROR_MSG,						MPEG_DECODER_UNIT,	0x1504, WORD)

// Karaoke control tags
#define KARAOKE_TAGVALUE_BASE  0x2000

MKTAG(MPEG2_AUDIO_KARAOKE_ENABLE,								MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  0, BOOL)
MKTAG(MPEG2_AUDIO_KARAOKE_LEFT_CHANNEL_MUSIC_VOLUME,		MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  1, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_RIGHT_CHANNEL_MUSIC_VOLUME,		MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  2, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_ENABLE_MUSIC_CHANNEL_MUTE,		MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  3, BOOL)

MKTAG(MPEG2_AUDIO_KARAOKE_LEFT_CHANNEL_VOICE_VOLUME,		MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  4, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_RIGHT_CHANNEL_VOICE_VOLUME,		MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  5, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_ENABLE_VOICE_CHANNEL_MUTE,		MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  6, BOOL)


MKTAG(MPEG2_AUDIO_KARAOKE_PITCH_SHIFT,							MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  7, int)
MKTAG(MPEG2_AUDIO_KARAOKE_ENABLE_PITCH_SHIFT,				MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  8, BOOL)

MKTAG(MPEG2_AUDIO_KARAOKE_VOICE_CANCELLATION,				MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE +  9, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_ENABLE_VOICE_CANCELLATION,		MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 10, BOOL)

MKTAG(MPEG2_AUDIO_KARAOKE_DUET_THRESHOLD,						MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 11, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_ENABLE_DUET,							MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 12, BOOL)

MKTAG(MPEG2_AUDIO_KARAOKE_VOICE_EFFECT,						MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 13, KaraokeVoiceEffectType )
MKTAG(MPEG2_AUDIO_KARAOKE_VOICE_EFFECT_DELAY,				MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 14, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_VOICE_EFFECT_BALANCE,				MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 15, WORD)

MKTAG(MPEG2_AUDIO_KARAOKE_MUSIC_GAIN,							MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 16, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_VOICE_GAIN,							MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 17, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_MUSIC_IN_SHIFT, 					MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 18, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_MUSIC_OUT_SHIFT,					MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 19, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_VOICE_IN_SHIFT, 					MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 20, WORD)
MKTAG(MPEG2_AUDIO_KARAOKE_VOICE_OUT_SHIFT, 					MPEG_DECODER_UNIT,	KARAOKE_TAGVALUE_BASE + 21, WORD)

MKTAG(MPEG2_AUDIO_KARAOKE_ECHO_FEEDBACK,						MPEG_DECODER_UNIT,  KARAOKE_TAGVALUE_BASE + 22, WORD)



#ifndef ONLY_EXTERNAL_VISIBLE

#include "library/common/virtunit.h"
#include "library/general/queues.h"
#include "library/common/krnlint.h"

#define INVALID_PTS	0xffffffff   // must be largest DWORD

class PTSAssoc {
	private:
		struct Assoc {DWORD pos, pts;} * assoc;
		int first;
		int last;
		int num;
	public:
		PTSAssoc(int num);
		~PTSAssoc(void);

		void PutPTS(DWORD pos, DWORD pts);
		DWORD GetPTS(DWORD pos);
		DWORD GetAvgPTS(DWORD pos);
		void Reset(void);
	};

class PTSCallback : Node
	{
	friend class PTSCaller;
	private:
		DWORD	callPTS;
		BOOL	needSequenceStartCallback;

		BOOL HigherPriorityThan(Node * n) {return callPTS < ((PTSCallback *)n)->callPTS;}
	public:
		PTSCallback(void) {callPTS = INVALID_PTS; needSequenceStartCallback = FALSE;}

		virtual Error PTSCallbackReached(DWORD currentPTS) = 0;
		virtual Error PTSCallbackCanceled(void);

		virtual Error SequenceStartReached (void);
	};

class PTSCaller
	{
	private:
		DWORD	lastPTS;

		List	callbacks;
	public:
		PTSCaller(void) {lastPTS = 0;}

		Error AddCallback(DWORD pts, PTSCallback * callback);
		Error RemCallback(PTSCallback * callback);

		Error CheckCallbacks(DWORD currentPTS);
		Error CancelCallbacks(void);

		Error AddSequenceStartCallback (PTSCallback *callback);
		Error RemSequenceStartCallback (PTSCallback *callback);
		Error CallSequenceStartCallbacks (void);
	};

class PTSCounter
	{
	private:
		BOOL running;

		long ptsDelay;

		DWORD basePTS;

		DWORD baseTimeOffset;
		DWORD stopTimeOffset;

		WORD playbackSpeed;

	public:
		PTSCounter(void);
		~PTSCounter(void);

		Error Reset(void);
		Error SetDecoderDelay(long delay); // in milliseconds

		Error Start (WORD playbackSpeed = 1000);
		Error Stop(void);

		Error SyncPTS(DWORD pts);
		Error SetPTS(DWORD pts);
		DWORD GetPTS(void);
	};


class MPEG2CommandQueue
	{
	private:
		struct {MPEGCommand com; DWORD param;} queue[16];
		DWORD	first, last, next;
	public:
		MPEG2CommandQueue(void) {last = 0; Reset();}

		void Reset(void) {first = next = last;}

		BOOL CommandPending(DWORD tag) {if (tag != 0xffffffff) return first <= tag; else return FALSE;}

		Error InsertCommand(MPEGCommand com, DWORD param, DWORD __far &tag);
		BOOL PeekCommand(MPEGCommand __far &com, DWORD __far &param);
		void SkipCommand(void) {first++; next++;}
		BOOL GetCommand(MPEGCommand __far &com, DWORD __far &param);
		Error CompleteCommand(void);
	};


class MPEG2ElementaryDecoder : public PhysicalUnit, public MPEG2StreamReceiver
   {
   friend class VirtualMPEG2ElementaryDecoder;
   protected:
   	DWORD		streamBitrate;
   	DWORD		positionScale, positionBaseScale;

      BOOL		dvdStreamDemux;
      BOOL		dvdStreamEncrypted;

		Error StreamHook(DWORD size);
   	Error SignalHook(DWORD position);
   	Error SignalHook(KernelInt64 position);
   	Error DoneHook(void);
		Error IdleHook(void);

		virtual DWORD RecoverStreamData(HPTR data, DWORD size) {return 0;}
		virtual DWORD StreamDataAvailable(void) {return 0;}
   public:
		MPEG2ElementaryDecoder	*	syncSlave;
      BOOL								slaveMode;

   	MPEG2ElementaryDecoder(void) {positionScale = positionBaseScale = MP2SR_SCALE_BYTES; syncSlave = NULL; slaveMode = FALSE;}

	   virtual Error SendCommand(MPEGCommand com, DWORD param, DWORD __far &tag) = 0;
		virtual BOOL CommandPending(DWORD tag) = 0;
      virtual Error DoCommand(MPEGCommand com, DWORD param);
		virtual Error CompleteCommand(DWORD tag);

		virtual DWORD CurrentLocation(void) = 0;
		virtual MPEGState CurrentState(void) = 0;

	   virtual DWORD GetPTS() = 0;
		virtual Error ConformToPTS(DWORD pts) {GNRAISE_OK;}
		virtual Error SetPlaybackTime(LONG time) {GNRAISE_OK;}

	   virtual Error SetSignalPosition(DWORD position) = 0;
	   virtual Error SetStreamBitRate(DWORD rate) {streamBitrate = rate; GNRAISE_OK;}
	   virtual Error SetPositionScale(DWORD scale) {positionScale = scale; GNRAISE_OK;}

   	virtual Error SetDVDStreamDemux(BOOL dvdDemux) {this->dvdStreamDemux = dvdDemux; GNRAISE_OK;}
   	virtual Error SetDVDStreamEncrypted(BOOL dvdEncrypted) {this->dvdStreamEncrypted = dvdEncrypted; GNRAISE_OK;}

		virtual Error SyncPlay(void) {GNRAISE_OK;}

		virtual Error NotifySiblingBufferFull(void) {GNRAISE_OK;}
		virtual Error NotifyTransferStopped(void) {GNRAISE_OK;}
		virtual Error VOBUBorderReached(void) {GNRAISE_OK;}
   };

class VirtualMPEG2ElementaryDecoder : public VirtualUnit, public MPEG2StreamReceiver
	{
	friend class MPEG2ElementaryDecoder;
	private:
		MPEG2ElementaryDecoder	*	decoder;
	protected:
#if !DRVDLL
		MPEGStreamHookHandle	streamHook;
		MPEGSignalHookHandle	signalHook;
		MPEGSignalHookHandle	doneHook;
	   MPEGIdleHookHandle	idleHook;
#else
		MPEGStreamHook	* streamHook;
		MPEGSignalHook	* signalHook;
		MPEGSignalHook	* doneHook;
	   MPEGIdleHook	* idleHook;
#endif

   	DWORD		streamBitrate;
		DWORD		signalPosition;
   	DWORD		positionScale;

		HBPTR		buffer;
		DWORD		buffStart, buffEnd, buffSize;
		DWORD		streamPosition;
		LONG		playbackTime;

		BOOL							dvdStreamDemux;
		BOOL							dvdStreamEncrypted;

		FixedDualIntQueue	ptsQueue;

      virtual Error RecoverStreamData(void);
      virtual Error ProvideStreamData(void);

      Error PreemptStopPrevious(VirtualUnit * previous);
      Error PreemptChange(VirtualUnit * previous);
      Error PreemptStartNew(VirtualUnit * previous);
	public:
		VirtualMPEG2ElementaryDecoder(MPEG2ElementaryDecoder * unit);
		~VirtualMPEG2ElementaryDecoder(void);

      virtual Error AllocateStreamBuffer(DWORD size);
		virtual Error FlushStreamBuffer(void);

		Error Configure (TAG __far *tags);

	   virtual Error SendCommand(MPEGCommand com, DWORD param, DWORD __far &tag);
		virtual BOOL CommandPending(DWORD tag);
      virtual Error DoCommand(MPEGCommand com, DWORD param);
		virtual Error CompleteCommand(DWORD tag);

		virtual DWORD CurrentLocation(void);
		virtual MPEGState CurrentState(void);

	   virtual DWORD SendData(HPTR data, DWORD size);
	   virtual void CompleteData(void);
		virtual DWORD LastTransferLocation(DWORD scale);

	   virtual Error SendPESData(HPTR data, DWORD size, DWORD __far & done, DWORD __far & used);

	   virtual DWORD GetPTS();
	   virtual void PutPTS(DWORD pts);
		virtual Error ConformToPTS(DWORD pts);

		virtual Error NotifySiblingBufferFull(void);
		virtual Error NotifyTransferStopped(void);
		virtual Error VOBUBorderReached(void);
	};


class MPEG2VideoDecoder : public MPEG2ElementaryDecoder
	{
	friend class VirtualMPEG2VideoDecoder;
	protected:
		virtual Error SetVideoBitrate(DWORD videoBitrate) = 0;
		virtual Error SetVideoWidth(WORD width) = 0;
		virtual Error SetVideoHeight(WORD height) = 0;
		virtual Error SetVideoStandard(VideoStandard	standard) = 0;
#if TEST_PAL_TO_NTSC
		virtual Error SetApplicationVideoStandard(VideoStandard	standard) = 0;	//aa3
		virtual MovingImageStandard GetEncoderMovingImageStandard () = 0;
#endif
		virtual Error SetVideoFPS(WORD fps) = 0;
		virtual Error SetMPEG2Coding(BOOL mpeg2Coding) = 0;
		virtual Error SetAspectRatio(WORD aspectRatio) = 0;
		virtual Error SetPresentationMode(MPEG2PresentationMode presentationMode) = 0;

	public:

	};

class VirtualMPEG2VideoDecoder : public VirtualMPEG2ElementaryDecoder
	{
	private:
		MPEG2VideoDecoder	*		decoder;
	protected:
		DWORD							videoBitrate;
		WORD							videoWidth;
		WORD							videoHeight;
		WORD							videoFPS;
		WORD							aspectRatio;
		VideoStandard				videoStandard;
#if TEST_PAL_TO_NTSC
		VideoStandard				diskVideoStandard;
		VideoStandard				applicationVideoStandard;
		MovingImageStandard		decoderMovingImageStandard;
#endif
		BOOL							mpeg2Coding;
		MPEG2PresentationMode	presentationMode;

		virtual Error GetDisplaySize(WORD __far& width, WORD __far& height);

		Error PreemptChange(VirtualUnit * previous);
	public:
		VirtualMPEG2VideoDecoder(MPEG2VideoDecoder * unit) : VirtualMPEG2ElementaryDecoder(unit)
			{decoder = unit; videoBitrate = 0; videoWidth = 0; videoHeight = 0;
			 videoFPS = 0; mpeg2Coding = FALSE;
			 presentationMode = MPM_FULLSIZE;
#if TEST_PAL_TO_NTSC

			applicationVideoStandard = VSTD_PAL;
#endif
			}

		Error Configure(TAG __far * tags);

		virtual Error SetLine21Receiver(Line21Receiver * line21Receiver);
	};

class MPEG2AudioDecoder : public MPEG2ElementaryDecoder
	{
	public:
		virtual Error SetAudioBitrate(DWORD rate) = 0;
		virtual Error SetSampleRate(WORD rate) = 0; // in samples per second;
		virtual Error SetLeftVolume(WORD volume) = 0;
		virtual Error SetRightVolume(WORD volume) = 0;
		virtual Error SetMute(BOOL mute) = 0;
		virtual Error SetAudioType(MPEG2AudioType audioType) {GNRAISE_OK;}
		virtual Error SetAudioLayer(MPEGAudioLayer audioLayer) {GNRAISE_OK;}
		virtual Error SetLPCM(BOOL lpcm) {GNRAISE_OK;}
		virtual Error SetBitsPerSample(WORD samples) {GNRAISE_OK;}
		virtual Error SetChannels(WORD channels) {GNRAISE_OK;}
	};

class VirtualMPEG2AudioDecoder : public VirtualMPEG2ElementaryDecoder
	{
	private:
		MPEG2AudioDecoder	* decoder;
	protected:
		DWORD	audioBitrate;
		WORD	sampleRate;
		WORD	leftVolume;
		WORD	rightVolume;
		BOOL	audioMute;
		WORD	bitsPerSample;
		WORD	channels;
		BOOL	lpcm;

		MPEGAudioLayer	audioLayer;
		MPEG2AudioType	audioType;

		Error PreemptChange(VirtualUnit * previous);
	public:
		VirtualMPEG2AudioDecoder(MPEG2AudioDecoder	* decoder) : VirtualMPEG2ElementaryDecoder(decoder)
			{this->decoder = decoder;audioBitrate = 0; sampleRate = 48000;
			 leftVolume = 10000; rightVolume = 10000; audioMute = TRUE;
			 audioType = MP2AUDTYP_DEFAULT; lpcm = FALSE; bitsPerSample = 16; channels = 2; audioLayer = MPAUDLAYER_2;
			 }

		Error Configure (TAG __far *tags);
	};

class MPEG2AC3Decoder : public MPEG2AudioDecoder
	{
	public:
		virtual Error SetAC3(BOOL ac3) = 0;

		virtual Error SetBassConfig(AC3BassConfig config) = 0;
		virtual Error SetSpeakerConfig(AC3SpeakerConfig config) = 0;
		virtual Error SetDualModeConfig(AC3DualModeConfig config) = 0;
		virtual Error SetKaraokeConfig(AC3KaraokeConfig config) = 0;
		virtual Error SetCenterDelay(WORD delay) = 0;
		virtual Error SetSurroundDelay(WORD delay) = 0;
		virtual Error SetCenterVolume(WORD volume) = 0;
		virtual Error SetLeftSurroundVolume(WORD volume) = 0;
		virtual Error SetRightSurroundVolume(WORD volume) = 0;
		virtual Error SetSubwooferVolume(WORD volume) = 0;
		virtual Error SetLeftDelay(WORD leftDelay) {GNRAISE_OK;}
		virtual Error SetRightDelay(WORD rightDelay) {GNRAISE_OK;}
		virtual Error SetLeftSurroundDelay(WORD leftSurroundDelay) {GNRAISE_OK;}
		virtual Error SetRightSurroundDelay(WORD rightSurroundDelay) {GNRAISE_OK;}
		virtual Error SetSubwooferDelay(WORD subwooferDelay) {GNRAISE_OK;}
		virtual Error SetPrologicConfig(DolbyProLogicConfig prologicConfig) {GNRAISE_OK;}
		virtual Error SetPrologicMode(DolbyProLogicMode prologicMode) {GNRAISE_OK;}
		virtual Error SetDecodeLFE(BOOL decodeLFE) {GNRAISE_OK;}
		virtual Error SetPCMOutputConfig(PCMOutputConfig pcmOCFG) {GNRAISE_OK;}
		virtual Error SetDynamicRange(AC3DynamicRange dynamicRange) {GNRAISE_OK;}
		virtual Error SetAudioTypeConfig(MPEG2AudioType type, AudioTypeConfig config) {GNRAISE_OK;}
	};

class VirtualMPEG2AC3Decoder : public VirtualMPEG2AudioDecoder
	{
	private:
		MPEG2AC3Decoder	*	decoder;
	protected:
		BOOL						ac3;
		AC3BassConfig  		bassConfig;
		AC3SpeakerConfig		speakerConfig;
		AC3DualModeConfig		dualModeConfig;
		AC3KaraokeConfig		karaokeConfig;
		WORD						centerDelay;
		WORD						surroundDelay;
		WORD						centerVolume;
		WORD						leftSurroundVolume;
		WORD						rightSurroundVolume;
		WORD						subwooferVolume;
		WORD						leftDelay;
		WORD						rightDelay;
		WORD						leftSurroundDelay;
		WORD						rightSurroundDelay;
		WORD						subwooferDelay;
		DolbyProLogicConfig	prologicConfig;
		DolbyProLogicMode		prologicMode;
		BOOL						decodeLFE;
		PCMOutputConfig		pcmOCFG;
		AC3DynamicRange		dynamicRange;
		AudioTypeConfig		ac3Config;
		AudioTypeConfig		dtsConfig;
		AudioTypeConfig		lpcmConfig;
		AudioTypeConfig		mpegConfig;
		AudioTypeConfig		mpeg2Config;
		AudioTypeConfig		cddaDtsConfig;

		Error PreemptChange(VirtualUnit * previous);
	public:
		VirtualMPEG2AC3Decoder(MPEG2AC3Decoder * decoder);
		Error Configure(TAG __far * tags);
	};

//
// Inlines
//

inline Error MPEG2CommandQueue::CompleteCommand(void)
	{
	first++;

	GNRAISE_OK;
	}

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\generic\mp2streamreceiver.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef MP2STREAMRECEIVER_H
#define MP2STREAMRECEIVER_H

#include "library/common/prelude.h"
#include "library/common/gnerrors.h"

enum MPEG2PESType
	{
	MP2PES_ELEMENTARY,
	MP2PES_DVD,
	MP2PES_MPEG
	};

#define MP2SR_SCALE_BITS		0x80000L
#define MP2SR_SCALE_BYTES		0x10000L
#define MP2SR_SCALE_WORDS		0x08000L
#define MP2SR_SCALE_DWORDS		0x04000L
#define MP2SR_SCALE_DVDPES		0x00020L

struct MPEGDataSizePair
	{
	HBPTR		data;
	DWORD		size;
	int		timeStamp;
	DWORD		pad0;
	};

#ifndef ONLY_EXTERNAL_VISIBLE

class MPEG2StreamReceiver
	{
	public:
		virtual DWORD SendData(HPTR data, DWORD size) = 0;
		virtual DWORD SendDataMultiple (MPEGDataSizePair * data, DWORD size);
			//
			// Scale factor is fixed point number 16:16 bits
			//
			// e.g. Scale = 0x8000 is in WORDs
			//
		virtual DWORD LastTransferLocation(DWORD scale = MP2SR_SCALE_BYTES) = 0;
		virtual void CompleteData(void) = 0;
		virtual void FlushData(void) {};

		virtual void PutPTS(DWORD pts) {};

		virtual MPEG2PESType NeedsPES(void) {return MP2PES_ELEMENTARY;}
		virtual Error SendPESData(HPTR data, DWORD size, DWORD __far & done, DWORD __far & used) {GNRAISE(GNR_UNIMPLEMENTED);}
		virtual Error VOBUBorderReached(void) {GNRAISE_OK;}
	};

inline DWORD XScaleDWord(DWORD pos, DWORD from, DWORD to) {return pos == 0xffffffff ? pos : ScaleDWord(pos, from, to);}

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\specific\i7000R.h ===
// FILE:			library\hardware\mpeg2dec\specific\i7000r.h
// AUTHOR:		Viona
// COPYRIGHT:	(c) 1998 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		20.03.98
//
// PURPOSE:	   Sti7000 MPEG-2 decoder register settings
//
// HISTORY:

#ifndef I7000R_H
#define I7000R_H

#include "library\common\prelude.h"



#define I7000REG_MCF				0x00
#define I7000IDX_LAUNCH_SET	5
#define I7000MCF_LAUNCH_SET	I7000REG_MCF, I7000IDX_LAUNCH_SET
#define I7000IDX_PROGRESSIVE	4
#define I7000MCF_PROGRESSIVE	I7000REG_MCF, I7000IDX_PROGRESSIVE
#define I7000IDX_DISPLAY_MODE	2, 2
#define I7000MCF_DISPLAY_MODE	I7000REG_MCF, I7000IDX_DISPLAY_MODE
#define I7000IDX_DECODE_MODE	0, 2
#define I7000MCF_DECODE_MODE	I7000REG_MCF, I7000IDX_DECODE_MODE
// mode values:
#define I7000_NO_COMP	0x0
#define I7000_2M3			0x1
#define I7000_H2M2		0x3

#define I7000REG_CCF				0x01
#define I7000IDX_MRQ				5	// since version CA
#define I7000CCF_MRQ				I7000REG_CCF, I7000IDX_MRQ
#define I7000IDX_D1M				4	// since version CA
#define I7000CCF_D1M				I7000REG_CCF, I7000IDX_D1M
#define I7000IDX_SSC				3
#define I7000CCF_SSC				I7000REG_CCF, I7000IDX_SSC
#define I7000IDX_PBO				2
#define I7000CCF_PBO				I7000REG_CCF, I7000IDX_PBO
#define I7000IDX_EDI				1
#define I7000CCF_EDI				I7000REG_CCF, I7000IDX_EDI
#define I7000IDX_EVI				0
#define I7000CCF_EVI				I7000REG_CCF, I7000IDX_EVI

#define I7000REG_CTL				0x02
#define I7000IDX_SPI				5
#define I7000CTL_SPI				I7000REG_CTL, I7000IDX_SPI
#define I7000IDX_MVC				4
#define I7000CTL_MVC				I7000REG_CTL, I7000IDX_MVC
#define I7000IDX_CFB				3
#define I7000CTL_CFB				I7000REG_CTL, I7000IDX_CFB
#define I7000IDX_ERU				2
#define I7000CTL_ERU				I7000REG_CTL, I7000IDX_ERU
#define I7000IDX_ERO				1
#define I7000CTL_ERO				I7000REG_CTL, I7000IDX_ERO
#define I7000IDX_EDC				0
#define I7000CTL_EDC				I7000REG_CTL, I7000IDX_EDC

#define I7000REG_TIS				0x03
#define I7000IDX_PI				7
#define I7000TIS_PI				I7000REG_TIS, I7000IDX_PI
#define I7000IDX_MP2				6
#define I7000TIS_MP2				I7000REG_TIS, I7000IDX_MP2
#define I7000IDX_SKP				4, 2
#define I7000TIS_SKP				I7000REG_TIS, I7000IDX_SKP
#define I7000IDX_OVW				3
#define I7000TIS_OVW				I7000REG_TIS, I7000IDX_OVW
#define I7000IDX_FIS				2
#define I7000TIS_FIS				I7000REG_TIS, I7000IDX_FIS
#define I7000IDX_RPT				1
#define I7000TIS_RPT				I7000REG_TIS, I7000IDX_RPT
#define I7000IDX_EXE				0
#define I7000TIS_EXE				I7000REG_TIS, I7000IDX_EXE

#define I7000REG_PFH				0x04
#define I7000IDX_BFH				4, 4
#define I7000PFH_BFH				I7000REG_PFH, I7000IDX_BFH
#define I7000IDX_FFH				0, 4
#define I7000PFH_FFH				I7000REG_PFH, I7000IDX_FFH

#define I7000REG_PFV				0x05
#define I7000IDX_BFV				4, 4
#define I7000PFV_BFV				I7000REG_PFV, I7000IDX_BFV
#define I7000IDX_FFV				0, 4
#define I7000PFV_FFV				I7000REG_PFV, I7000IDX_FFV

#define I7000REG_PPR1			0x06
#define I7000IDX_PCT				4, 2
#define I7000PPR1_PCT			I7000REG_PPR1, I7000IDX_PCT
#define I7000IDX_DCP				2, 2
#define I7000PPR1_DCP			I7000REG_PPR1, I7000IDX_DCP
#define I7000IDX_PST				0, 2
#define I7000PPR1_PST			I7000REG_PPR1, I7000IDX_PST

#define I7000REG_PPR2			0x07
#define I7000IDX_TFF				5
#define I7000PPR2_TFF			I7000REG_PPR2, I7000IDX_TFF
#define I7000IDX_FRM				4
#define I7000PPR2_FRM			I7000REG_PPR2, I7000IDX_FRM
#define I7000IDX_CMV				3
#define I7000PPR2_CMV			I7000REG_PPR2, I7000IDX_CMV
#define I7000IDX_QST				2
#define I7000PPR2_QST			I7000REG_PPR2, I7000IDX_QST
#define I7000IDX_IVF				1
#define I7000PPR2_IVF			I7000REG_PPR2, I7000IDX_IVF
#define I7000IDX_AZZ				0
#define I7000PPR2_AZZ			I7000REG_PPR2, I7000IDX_AZZ

#define I7000REG_HRC				0x08
#define I7000IDX_SIMPLE_READ	7
#define I7000HRC_SIMPLE_READ	I7000REG_HRC, I7000IDX_SIMPLE_READ
#define I7000IDX_SIMPLE_WRITE	6
#define I7000HRC_SIMPLE_WRITE	I7000REG_HRC, I7000IDX_SIMPLE_WRITE
#define I7000IDX_READ_INC		5
#define I7000HRC_READ_INC		I7000REG_HRC, I7000IDX_READ_INC
#define I7000IDX_WRITE_INC		4
#define I7000HRC_WRITE_INC		I7000REG_HRC, I7000IDX_WRITE_INC
#define I7000IDX_READ_DEC		3
#define I7000HRC_READ_DEC		I7000REG_HRC, I7000IDX_READ_DEC
#define I7000IDX_WRITE_DEC		2
#define I7000HRC_WRITE_DEC		I7000REG_HRC, I7000IDX_WRITE_DEC
#define I7000IDX_AUTO_READ		1
#define I7000HRC_AUTO_READ		I7000REG_HRC, I7000IDX_AUTO_READ
#define I7000IDX_AUTO_WRITE	0
#define I7000HRC_AUTO_WRITE	I7000REG_HRC, I7000IDX_AUTO_WRITE

#define I7000REG_QMW				0x09

#define I7000REG_MST				0x0A
#define I7000IDX_USE_SGRAM		7	// since version CA
#define I7000MST_USE_SGRAM		I7000REG_MST, I7000IDX_USE_SGRAM
#define I7000IDX_RFI				0, 6
#define I7000MST_RFI				I7000REG_MST, I7000IDX_RFI

#define I7000REG_DFH				0x0B

#define I7000REG_DFP				0x0C
#define I7000REG_DFP8			0x0C
#define I7000REG_DFP0			0x0D

#define I7000REG_RFP				0x0E
#define I7000REG_RFP8			0x0E
#define I7000REG_RFP0			0x0F

#define I7000REG_FFP				0x10
#define I7000REG_FFP8			0x10
#define I7000REG_FFP0			0x11

#define I7000REG_BFP				0x12
#define I7000REG_BFP8			0x12
#define I7000REG_BFP0			0x13

#define I7000REG_BBG1			0x14
#define I7000REG_BBG18			0x14
#define I7000REG_BBG10			0x15

#define I7000REG_BBG2			0x16
#define I7000REG_BBG28			0x16
#define I7000REG_BBG20			0x17

#define I7000REG_BBL				0x18
#define I7000REG_BBL8			0x18
#define I7000REG_BBL0			0x19

#define I7000REG_BBS1			0x1A
#define I7000REG_BBS18			0x1A
#define I7000REG_BBS10			0x1B

#define I7000REG_BBS2			0x1C
#define I7000REG_BBS28			0x1C
#define I7000REG_BBS20			0x1D

#define I7000REG_BBT				0x1E
#define I7000REG_BBT8			0x1E
#define I7000REG_BBT0			0x1F

#define I7000REG_DFS				0x20
#define I7000REG_DFS8			0x20
#define I7000REG_DFS0			0x21

#define I7000REG_DCHP			0x22
#define I7000REG_DCHP8			0x22
#define I7000REG_DCHP0			0x23

#define I7000REG_RCHP			0x24
#define I7000REG_RCHP8			0x24
#define I7000REG_RCHP0			0x25

#define I7000REG_DFW				0x26

#define I7000REG_XFW				0x27

#define I7000REG_XFS				0x28
#define I7000REG_XFS8			0x28
#define I7000REG_XFS0			0x29

#define I7000REG_FCHP			0x2A
#define I7000REG_FCHP8			0x2A
#define I7000REG_FCHP0			0x2B

#define I7000REG_BCHP			0x2C
#define I7000REG_BCHP8			0x2C
#define I7000REG_BCHP0			0x2D

#define I7000REG_LMP				0x2E
#define I7000REG_LMP8			0x2E
#define I7000REG_LMP0			0x2F

#define I7000REG_PLL_DIV0		0x50
#define I7000REG_PLL_DIV024	0x50
#define I7000REG_PLL_DIV016	0x51
#define I7000REG_PLL_DIV08		0x52
#define I7000REG_PLL_DIV00		0x53

#define I7000REG_PLL_DIV1		0x54
#define I7000REG_PLL_DIV124	0x54
#define I7000REG_PLL_DIV116	0x55
#define I7000REG_PLL_DIV18		0x56
#define I7000REG_PLL_DIV10		0x57

#define I7000REG_PLL_DIV3		0x30
#define I7000REG_PLL_DIV324	0x30
#define I7000REG_PLL_DIV316	0x31
#define I7000REG_PLL_DIV38		0x32
#define I7000REG_PLL_DIV30		0x33

#define I7000REG_PLL_DIV4		0x34
#define I7000REG_PLL_DIV424	0x34
#define I7000REG_PLL_DIV416	0x35
#define I7000REG_PLL_DIV48		0x36
#define I7000REG_PLL_DIV40		0x37
// bits:
#define I7000IDX_UNRESET_DIVIDER	29
#define I7000IDX_DIV2_FLAG			28

#define I7000REG_PLL2_SEL		0x39
// values:
#define I7000_SRC_CLKLN		0x0
#define I7000_SRC_CLK0		0x1
#define I7000_SRC_CLK1		0x2
#define I7000_SRC_CLK2		0x3
#define I7000_SRC_CLK3		0x4

#define I7000REG_PLL_DIVFIX	0x3A
#define I7000REG_PLL2_CF		0x3B
#define I7000REG_PLL0_CF		0x3C
#define I7000REG_PLL1_CF		0x3D

#define I7000REG_PLL1_SEL		0x3E
// refer to I7000REG_PLL2_SEL (0x39) for values

#define I7000REG_TST				0x3F

#define I7000REG_BFBP			0x40
#define I7000REG_BFBP8			0x40
#define I7000REG_BFBP0			0x41

#define I7000REG_BMES			0x42

#define I7000REG_PORD			0x43

#define I7000REG_PES_SC124		0x44
#define I7000REG_PES_SC216		0x45
#define I7000REG_PES_SC38		0x46
#define I7000REG_PES_SC40		0x47

#define I7000REG_PES_CFG		0x48
#define I7000IDX_SDT				6
#define I7000PES_CFG_SDT		I7000REG_PES_CFG, I7000IDX_SDT
#define I7000IDX_SS				5
#define I7000PES_CFG_SS			I7000REG_PES_CFG, I7000IDX_SS
#define I7000IDX_IVI				4
#define I7000PES_CFG_IVI		I7000REG_PES_CFG, I7000IDX_IVI
#define I7000IDX_VID_ID			0, 4
#define I7000PES_CFG_VID_ID	I7000REG_PES_CFG, I7000IDX_VID_ID

#define I7000REG_VID_DSM		0x4A

#define I7000REG_PES_EXT		0x4B	// before VID_TS0
#define I7000IDX_SC32			3
#define I7000PES_EXT_SC32		I7000REG_PES_EXT, I7000IDX_SC32
#define I7000IDX_DSA				2     
#define I7000PES_EXT_DSA		I7000REG_PES_EXT, I7000IDX_DSA
#define I7000IDX_TSA				1
#define I7000PES_EXT_TSA		I7000REG_PES_EXT, I7000IDX_TSA
#define I7000IDX_TS32			0
#define I7000PES_EXT_TS32		I7000REG_PES_EXT, I7000IDX_TS32

#define I7000REG_VID_TS124		0x4C
#define I7000REG_VID_TS216		0x4D
#define I7000REG_VID_TS38		0x4E
#define I7000REG_VID_TS40		0x4F

#define I7000REG_CLK_SEL0		0x5C
#define I7000REG_CLK_SEL1		0x5D
#define I7000REG_CLK_SEL2		0x5E
#define I7000REG_CLK_SEL3		0x5F
#define I7000IDX_IDX_SELN		4, 4
#define I7000IDX_IDX_SEL		0, 4
// select values:
#define I7000_CLK_OP0_DIV0		0x1
#define I7000_CLK_OP0_DIV1		0x2
#define I7000_CLK_OP0_4			0x3
#define I7000_CLK_OP1_DIV3		0x4
#define I7000_CLK_OP1_DIV4		0x5
#define I7000_CLK_OP1_3			0x6
#define I7000_CLK_OP2_3			0x7
#define I7000_CLK_POWERDOWN	0x8
#define I7000_CLK_INPUT			0x8

#define I7000REG_HDF				0x60

#define I7000REG_CMD				0x61
#define I7000IDX_QMI				3
#define I7000CMD_QMI				I7000REG_CMD, I7000IDX_QMI
#define I7000IDX_PRS				2
#define I7000CMD_PRS				I7000REG_CMD, I7000IDX_PRS
#define I7000IDX_SRS				1
#define I7000CMD_SRS				I7000REG_CMD, I7000IDX_SRS
#define I7000IDX_HDS				0
#define I7000CMD_HDS				I7000REG_CMD, I7000IDX_HDS
// values:
#define I7000_QMI_INTRA			1
#define I7000_QMI_NON_INTRA	0

#define I7000REG_CDCNT			0x68
#define I7000REG_CDCNT24		0x68
#define I7000REG_CDCNT16		0x69
#define I7000REG_CDCNT8			0x6A
#define I7000REG_CDCNT0			0x6B

#define I7000REG_SCDCNT			0x6C
#define I7000REG_SCDCNT24		0x6C
#define I7000REG_SCDCNT16		0x6D
#define I7000REG_SCDCNT8		0x6E
#define I7000REG_SCDCNT0		0x6F

#define I7000REG_ITS				0x70
#define I7000REG_ITS24			0x70
#define I7000REG_ITS16			0x71
#define I7000REG_ITS8			0x72
#define I7000REG_ITS0			0x73
// interrupt bits:
#define I7000IDX_DVT				21
#define I7000IDX_DVB				20
#define I7000IDX_OFU				19	// till version BA
#define I7000IDX_BNT				19	// since version CA
#define I7000IDX_BFF				18
#define I7000IDX_NDP				17
#define I7000IDX_IEP				16
#define I7000IDX_SCR				15
#define I7000IDX_DOE				14
#define I7000IDX_DUE				13
#define I7000IDX_DSE				12	// low active
#define I7000IDX_WNR				11
#define I7000IDX_RNR				10
#define I7000IDX_BCI				9
#define I7000IDX_HFE				8
#define I7000IDX_HFF				7
#define I7000IDX_PID				6
#define I7000IDX_PSD				5
#define I7000IDX_VST				4
#define I7000IDX_VSB				3
#define I7000IDX_BBE				2
#define I7000IDX_BBF				1
#define I7000IDX_SCH				0

#define I7000MSK_DVT				MKFLAG(21)
#define I7000MSK_DVB				MKFLAG(20)
#define I7000MSK_OFU				MKFLAG(19)	// till version BA
#define I7000MSK_BNT				MKFLAG(19)	// since version CA
#define I7000MSK_BFF				MKFLAG(18)
#define I7000MSK_NDP				MKFLAG(17)
#define I7000MSK_IEP				MKFLAG(16)
#define I7000MSK_SCR				MKFLAG(15)
#define I7000MSK_DOE				MKFLAG(14)
#define I7000MSK_DUE				MKFLAG(13)
#define I7000MSK_DSE				MKFLAG(12)
#define I7000MSK_WNR				MKFLAG(11)
#define I7000MSK_RNR				MKFLAG(10)
#define I7000MSK_BCI				MKFLAG(9)
#define I7000MSK_HFE				MKFLAG(8)
#define I7000MSK_HFF				MKFLAG(7)
#define I7000MSK_PID				MKFLAG(6)
#define I7000MSK_PSD				MKFLAG(5)
#define I7000MSK_VST				MKFLAG(4)
#define I7000MSK_VSB				MKFLAG(3)
#define I7000MSK_BBE				MKFLAG(2)
#define I7000MSK_BBF				MKFLAG(1)
#define I7000MSK_SCH				MKFLAG(0)

#define I7000REG_STA				0x74
#define I7000REG_STA24			0x74
#define I7000REG_STA16			0x75
#define I7000REG_STA8			0x76
#define I7000REG_STA0			0x77
// refer to I7000REG_ITS (0x70) for bits

#define I7000REG_ITM				0x78
#define I7000REG_ITM24			0x78
#define I7000REG_ITM16			0x79
#define I7000REG_ITM8			0x7A
#define I7000REG_ITM0			0x7B
// refer to I7000REG_ITS (0x70) for bits

#define I7000REG_EPS				0x7C
#define I7000REG_EPS8			0x7C
#define I7000REG_EPS0			0x7D

#define I7000REG_REV				0x7F

#define I7000REG_HRP				0x80
#define I7000REG_HRP24			0x80
#define I7000REG_HRP16			0x81
#define I7000REG_HRP8			0x82
#define I7000REG_HRP0			0x83

#define I7000REG_HWP				0x84
#define I7000REG_HWP24			0x84
#define I7000REG_HWP16			0x85
#define I7000REG_HWP8			0x86
#define I7000REG_HWP0			0x87

#define I7000REG_BCBR			0x88
#define I7000REG_BCBR24			0x88
#define I7000REG_BCBR16			0x89
#define I7000REG_BCBR8			0x8A
#define I7000REG_BCBR0			0x8B
#define I7000IDX_NLOOPS			4, 20
#define I7000BCBR_NLOOPS		I7000REG_BCBR, I7000IDX_NLOOPS
#define I7000IDX_WORDCOPY		1
#define I7000BCBR_WORDCOPY		I7000REG_BCBR, I7000IDX_WORDCOPY
#define I7000IDX_INCREMENT		0
#define I7000BCBR_INCREMENT	I7000REG_BCBR, I7000IDX_INCREMENT

#define I7000REG_BCWC			0x8C
#define I7000REG_BCWC24			0x8C
#define I7000REG_BCWC16			0x8D
#define I7000REG_BCWC8			0x8E
#define I7000REG_BCWC0			0x8F

#define I7000REG_OHP				0x90
#define I7000REG_OHP24			0x90
#define I7000REG_OHP16			0x91
#define I7000REG_OHP8			0x92
#define I7000REG_OHP0			0x93

#define I7000REG_BSDA			0x94
#define I7000REG_BSDA24			0x94
#define I7000REG_BSDA16			0x95
#define I7000REG_BSDA8			0x96
#define I7000REG_BSDA0			0x97
#define I7000IDX_BSDA			4, 20
#define I7000BSDA_BSDA			I7000REG_BSDA, I7000IDX_BSDA

#define I7000REG_D1CTRL			0xA0

#define I7000REG_D1LNCNT		0xA1

#define I7000REG_D1L1			0xA2
#define I7000REG_D1L18			0xA2
#define I7000REG_D1L10			0xA3

#define I7000REG_D1L2			0xA4
#define I7000REG_D1L28			0xA4
#define I7000REG_D1L20			0xA5

#define I7000REG_MAF				0xB0
#define I7000REG_MAF120			0xB0
#define I7000REG_MAF112			0xB1
#define I7000REG_MAF104			0xB2
#define I7000REG_MAF96			0xB3
#define I7000REG_MAF88			0xB4
#define I7000REG_MAF80			0xB5
#define I7000REG_MAF72			0xB6
#define I7000REG_MAF64			0xB7
#define I7000REG_MAF56			0xB8
#define I7000REG_MAF48			0xB9
#define I7000REG_MAF40			0xBA
#define I7000REG_MAF32			0xBB
#define I7000REG_MAF24			0xBC
#define I7000REG_MAF16			0xBD
#define I7000REG_MAF8			0xBE
#define I7000REG_MAF0			0xBF

#define I7000REG_HDO				0xC0
#define I7000REG_HDO8			0xC0
#define I7000REG_HDO0			0xC1

#define I7000REG_HDS				0xC2  
#define I7000REG_HDS8			0xC2
#define I7000REG_HDS0			0xC3

#define I7000REG_XDO				0xC4
#define I7000REG_XDO8			0xC4
#define I7000REG_XDO0			0xC5

#define I7000REG_XDS				0xC6
#define I7000REG_XDS8			0xC6
#define I7000REG_XDS0			0xC7

#define I7000REG_VDO				0xC8
#define I7000REG_VDO8			0xC8
#define I7000REG_VDO0			0xC9

#define I7000REG_VDS				0xCA
#define I7000REG_VDS8			0xCA
#define I7000REG_VDS0			0xCB

#define I7000REG_YDO				0xCC
#define I7000REG_YDO8			0xCC
#define I7000REG_YDO0			0xCD

#define I7000REG_YDS				0xCE
#define I7000REG_YDS8			0xCE
#define I7000REG_YDS0			0xCF

#define I7000REG_PAN				0xD0
#define I7000REG_PAN8			0xD0
#define I7000REG_PAN0			0xD1

#define I7000REG_SCANR			0xD2
#define I7000REG_SCANR8			0xD2
#define I7000REG_SCANR0			0xD3

#define I7000REG_CLKLN			0xD4
#define I7000REG_CLKLN8			0xD4
#define I7000REG_CLKLN0			0xD5

#define I7000REG_LSOCSO				0xD6
#define I7000IDX_LUMA_PAN			4, 4
#define I7000LSOCSO_LUMA_PAN		I7000REG_LSOCSO, I7000IDX_LUMA_PAN
#define I7000IDX_CHROMA_PAN		0, 4
#define I7000LSOCSO_CHROMA_PAN	I7000REG_LSOCSO, I7000IDX_CHROMA_PAN

#define I7000REG_HLFLN			0xD8
#define I7000REG_HLFLN8			0xD8
#define I7000REG_HLFLN0			0xD9

#define I7000REG_BPPLN			0xDA

#define I7000REG_WRLN0			0xDB

#define I7000REG_ORLN0			0xDC
#define I7000REG_ORLN08			0xDC
#define I7000REG_ORLN00			0xDD

#define I7000REG_VFCCNT			0xE1

#define I7000REG_LSR				0xE2
#define I7000REG_LSR8			0xE2
#define I7000REG_LSR0			0xE3

#define I7000REG_LMULN0			0xE4

#define I7000REG_DRINT			0xE5

#define I7000REG_VFCRAM			0xE6
#define I7000IDX_FORCE_BANK		6
#define I7000VFCRAM_FORCE_BANK	I7000REG_VFCRAM, I7000IDX_FORCE_BANK
#define I7000IDX_WRITE_BANK		5
#define I7000VFCRAM_WRITE_BANK	I7000REG_VFCRAM, I7000IDX_WRITE_BANK
#define I7000IDX_READ_BANK			4
#define I7000VFCRAM_READ_BANK		I7000REG_VFCRAM, I7000IDX_READ_BANK
#define I7000IDX_LOOP_ADDR			0, 4
#define I7000VFCRAM_LOOP_ADDR		I7000REG_VFCRAM, I7000IDX_LOOP_ADDR

#define I7000REG_VFCCTL			0xE7

#define I7000REG_HDN				0xE8
#define I7000IDX_H2E					0

#define I7000REG_HCTRL			0xE9
//#define I7000IDX_YPEAK_ENABLE		1	not used any more - must be 0 !
//#define I7000HCTRL_YPEAK_ENABLE	I7000REG_HCTRL, I7000IDX_YPEAK_ENABLE
#define I7000IDX_HSRC_BYPASS		0
#define I7000HCTRL_HSRC_BYPASS	I7000REG_HCTRL, I7000IDX_HSRC_BYPASS

#define I7000REG_DRST			0xEA

#define I7000REG_OCF				0xEB
#define I7000IDX_LUMA_DELAY		3, 4
#define I7000OCF_LUMA_DELAY		I7000REG_OCF, I7000IDX_LUMA_DELAY
#define I7000IDX_OVERRIDE_ON		2
#define I7000OCF_OVERRIDE_ON		I7000REG_OCF, I7000IDX_OVERRIDE_ON
#define I7000IDX_24_BITS			1
#define I7000OCF_24_BITS			I7000REG_OCF, I7000IDX_24_BITS
#define I7000IDX_OSD_ENABLE		0
#define I7000OCF_OSD_ENABLE		I7000REG_OCF, I7000IDX_OSD_ENABLE

#define I7000REG_YOVR			0xEC

#define I7000REG_CBOVR			0xED

#define I7000REG_CROVR			0xEE

#define I7000REG_YBLACK			0xEF

#define I7000REG_ACCFRDIF		0xF0

#define I7000REG_FMCTRL			0xF1
// values:
#define I7000_DEINTERLACE		0x0
#define I7000_LINES_FROM_NEXT	0x1
#define I7000_LINES_FROM_PREV	0x2
#define I7000_BLANK_LINES		0x3

#define I7000REG_LMUCTRL		0xF2
#define I7000IDX_LMU_DEI		3
#define I7000LMUCTRL_LMU_DEI	I7000REG_LMUCTRL, I7000IDX_LMU_DEI
#define I7000IDX_LINES			0, 3
#define I7000LMUCTRL_LINES		I7000REG_LMUCTRL, I7000IDX_LMU_LINES

#define I7000REG_FMLPF			0xF3

#define I7000REG_HVMODE			0xF4
#define I7000IDX_DFC					3, 2
#define I7000HVMODE_DFC				I7000REG_HVMODE, I7000IDX_DFC
#define I7000IDX_SLAVESYNC			2
#define I7000HVMODE_SLAVESYNC		I7000REG_HVMODE, I7000IDX_SLAVESYNC
#define I7000IDX_SLAVERESET		1
#define I7000HVMODE_SLAVERESET	I7000REG_HVMODE, I7000IDX_SLAVERESET
#define I7000IDX_SLAVEINPUT		0
#define I7000HVMODE_SLAVEINPUT	I7000REG_HVMODE, I7000IDX_SLAVEINPUT

#define I7000REG_VFCOFS			0xF5



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\specific\i5505R.h ===
// FILE:			library\hardware\mpeg3dec\specific\i5505r.h
// AUTHOR:		D.Heidrich
// COPYRIGHT:	(c) 1998 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		18.06.98
//
// PURPOSE:		Register definition for the STi5505 DVD backend decoder.
//
// HISTORY:

#ifndef I5505R_H
#define I5505R_H

#include "library\common\prelude.h"



//************************************************************************
// Video decoder registers.

#define I5505REG_CFG_MCF		0x00
#define I5505REG_CFG_CCF		0x01


#define I5505REG_VID_CTL		0x02

#define I5505IDX_VID_CTL_ERU		7
#define I5505IDX_VID_CTL_ERS		6
#define I5505IDX_VID_CTL_SPR		5
#define I5505IDX_VID_CTL_ERP		3
#define I5505IDX_VID_CTL_PRS		2
#define I5505IDX_VID_CTL_SRS		1
#define I5505IDX_VID_CTL_EDC		0


#define I5505REG_VID_TIS		0x03

#define I5505TIS_EXE			0
#define I5505TIS_RPT			1
#define I5505TIS_FIS			2
#define I5505TIS_OVW			3
#define I5505TIS_SKP			4, 2
#define I5505TIS_MP2			6			// in VID_PPR2 for chip Cut B


#define I5505REG_VID_PFH		0x04
#define I5505REG_VID_PFV		0x05
#define I5505REG_VID_PPR1		0x06
#define I5505REG_VID_PPR2		0x07


// Display pointers luma and chroma.
#define I5505REG_VID_DFP8		0x0C
#define I5505REG_VID_DFP0		0x0D
#define I5505REG_VID_DFC8		0x58
#define I5505REG_VID_DFC0		0x59

// Reconstructed pointers luma and chroma.
#define I5505REG_VID_RFP8		0x0E
#define I5505REG_VID_RFP0		0x0F
#define I5505REG_VID_RFC8		0x5A
#define I5505REG_VID_RFC0		0x5B

// Forward pointers luma and chroma.
#define I5505REG_VID_FFP8		0x10
#define I5505REG_VID_FFP0		0x11
#define I5505REG_VID_FFC8		0x5C
#define I5505REG_VID_FFC0		0x5D

// Backward pointers luma and chroma.
#define I5505REG_VID_BFP8		0x12
#define I5505REG_VID_BFP0		0x13
#define I5505REG_VID_BFC8		0x5E
#define I5505REG_VID_BFC0		0x5F

// Video bit buffer.
#define I5505REG_VID_VBG8		0x14
#define I5505REG_VID_VBG0		0x15
#define I5505REG_VID_VBL8		0x16
#define I5505REG_VID_VBL0		0x17
#define I5505REG_VID_VBS8		0x18
#define I5505REG_VID_VBS0		0x19
#define I5505REG_VID_VBT8		0x1A
#define I5505REG_VID_VBT0		0x1B

// Audio bit buffer.
#define I5505REG_VID_ABG8		0x1C
#define I5505REG_VID_ABG0		0x1D
#define I5505REG_VID_ABL8		0x1E
#define I5505REG_VID_ABL0		0x1F
#define I5505REG_VID_ABS8		0x20
#define I5505REG_VID_ABS0		0x21
#define I5505REG_VID_ABT8		0x22
#define I5505REG_VID_ABT0		0x23


#define I5505REG_VID_DFS		0x24
#define I5505REG_VID_DFW		0x25

#define I5505REG_VID_XFW		0x28

#define I5505REG_VID_SCN		0x29

#define I5505REG_VID_OTP		0x2A
#define I5505REG_VID_OBP		0x2B

#define I5505REG_VID_PAN8		0x2C
#define I5505REG_VID_PAN0		0x2D

#define I5505REG_CKG_PLL		0x30
#define I5505REG_CKG_CFG		0x31
#define I5505REG_CKG_SMC		0x32
#define I5505REG_CKG_LNK		0x33
#define I5505REG_CKG_AUD		0x35
#define I5505REG_CKG_MCK		0x36
#define I5505REG_CKG_AUX		0x37

#define I5505REG_CFG_DRC		0x38

#define I5505REG_CFG_GCF		0x3A

#define I5505REG_PES_CF1		0x40
#define I5505REG_PES_CF2		0x41


// Bit definitions in status and interrupt registers.
#define I5505STA_SCH			MKFLAG(0)	// start code hit
#define I5505STA_BFF			MKFLAG(1)	// video bit FIFO full
#define I5505STA_HFE			MKFLAG(2)	// header FIFO empty
#define I5505STA_BBF			MKFLAG(3)	// bit buffer full
#define I5505STA_BBE			MKFLAG(4)	// bit buffer empty
#define I5505STA_VSB			MKFLAG(5)	// VSYNC bottom
#define I5505STA_VST			MKFLAG(6)	// VSYNC top
#define I5505STA_PSD			MKFLAG(7)	// pipeline starting to decode
#define I5505STA_PID			MKFLAG(9)	// pipeline idle
#define I5505STA_ERC			MKFLAG(10)	// error concealment
#define I5505STA_PNC			MKFLAG(11)	// panic mode
#define I5505STA_HFF			MKFLAG(12)	// header FIFO full
#define I5505STA_BMI			MKFLAG(13)	// block move idle
#define I5505STA_SER			MKFLAG(14)	// severe error or overflow error
#define I5505STA_PDE			MKFLAG(15)	// picture decoding error or underflow error
#define I5505STA_ABE			MKFLAG(16)	// audio bit buffer empty
#define I5505STA_AFF			MKFLAG(17)	// audio FIFO full
#define I5505STA_SFF			MKFLAG(18)	// sub picture FIFO full
#define I5505STA_ABF			MKFLAG(19)	// audio bit buffer full
#define I5505STA_ERR			MKFLAG(22)	// inconsistency error in PES parser
#define I5505STA_NDP			MKFLAG(23)	// new discarded packet


#define I5505REG_CFG_CDR		0x44

#define I5505REG_VID_FRZ		0x45

#define I5505REG_VID_MLU		0x54   // cut 2.0
#define I5505REG_VID_MCH		0x55   // cut 2.0
#define I5505REG_VID_VFL		0x54   // other cuts
#define I5505REG_VID_VFC		0x55   // other cuts


#define I5505REG_VID_ITM8		0x60   // interrupt mask
#define I5505REG_VID_ITM0		0x61
#define I5505REG_VID_ITM16		0x3C

#define I5505REG_VID_ITS8		0x62   // interrupt status
#define I5505REG_VID_ITS0		0x63
#define I5505REG_VID_ITS16		0x3D

#define I5505REG_VID_STA8		0x64   // status
#define I5505REG_VID_STA0		0x65
#define I5505REG_VID_STA16		0x3B


#define I5505REG_VID_HDF		0x66


#define I5505REG_VID_CDCNT		0x67
#define I5505REG_VID_SCDCNT	0x68

#define I5505REG_VID_HDS		0x69


#define I5505REG_VID_LSO		0x6A
#define I5505REG_VID_LSR0		0x6B
#define I5505REG_VID_CSO		0x6C
#define I5505REG_VID_LSR8		0x6D

#define I5505REG_VID_YDO		0x6E
#define I5505REG_VID_YDS		0x6F
#define I5505REG_VID_XDO8		0x70
#define I5505REG_VID_XDO0		0x71
#define I5505REG_VID_XDS8		0x72
#define I5505REG_VID_XDS0		0x73


#define I5505REG_VID_DCF8		0x74
#define I5505REG_VID_DCF0		0x75

#define I5505IDX_VID_DCF_SPP	14
#define I5505IDX_VID_DCF_BLL	13
#define I5505IDX_VID_DCF_BFL	12
#define I5505IDX_VID_DCF_FNF	11
#define I5505IDX_VID_DCF_FLY	10
#define I5505IDX_VID_DCF_ORF	9
#define I5505IDX_VID_DCF_PXD	6
#define I5505IDX_VID_DCF_EVD	5
#define I5505IDX_VID_DCF_EOS	4
#define I5505IDX_VID_DCF_DSR	3
#define I5505REG_VID_DCF_VFC	0, 3


#define I5505REG_VID_QMW		0x76

// Must be in test mode to access register 0x79
#define I5505REG_VID_TEST		0x77 
#define I5505REG_VID_SET_TEST_MODE		1 // value for above register
#define I5505REG_VID_SET_FUNCTIONAL_MODE	0 // value for above register

#define I5505REG_VID_REV		0x78

// fallback mode enable (set up digital video output)
#define I5505REG_VID_DIGOUT			0x79
#define I5505REG_VID_DIGOUT_ENABLE_CUT2		0x40 // value for above register
#define I5505REG_VID_DIGOUT_ENABLE_CUT3AND4	0xC0 // value for above register





//************************************************************************
// Audio decoder registers.

#define I5505REG_VERSION		0x00
#define I5505REG_IDENT			0x01

/*#define I5505REG_FBADDRL		0x02	// ???
#define I5505REG_FBADDRH		0x03	// ???
#define I5505REG_FBDATA			0x04	// ???
*/
#define I5505REG_SFREQ			0x05
#define I5505REG_EMPH			0x06


#define I5505REG_INTEL			0x07
#define I5505REG_INTEH			0x08
#define I5505REG_INTL			0x09
#define I5505REG_INTH			0x0a
//#define I5505REG_SETINT			0x0b	// ???

#define I5505INTIDX_SYNC		0
#define I5505INTIDX_HEADER		1
#define I5505INTIDX_ERROR		2
#define I5505INTIDX_SFREQ		3
#define I5505INTIDX_DEEMPH		4
#define I5505INTIDX_BOF			5
#define I5505INTIDX_PTS			6
#define I5505INTIDX_ANC			7
#define I5505INTIDX_PCM			8
#define I5505INTIDX_FBFULL		9
#define I5505INTIDX_FBEMPTY	10
#define I5505INTIDX_FIFO		11
//#define I5505INTIDX_BREAK		15	// ???


#define I5505REG_SINSETUP		0x0c

#define I5505IDX_INPUTSETUP	0, 2
#define I5505IDX_REQPOL			2

#define I5505INSET_PARALLEL	0
#define I5505INSET_SERIAL		1
#define I5505INSET_ANALOG		3


#define I5505REG_CANSETUP		0x0d

#define I5505CANSET_PADDING	0
#define I5505CANSET_LEFT1		1
#define I5505CANSET_FALLEDGE	2
#define I5505CANSET_SLOTCNT32	3


#define I5505REG_DATAIN			0x0e
#define I5505REG_ERROR			0x0f
#define I5505REG_RESET			0x10


/*#define I5505REG_PLLSYS			0x11

#define I5505IDXPLL_BYPASS		6
#define I5505IDXPLL_DISABLED	5
#define I5505IDXPLL_DIV			0, 4
*/


#define I5505REG_PLLPCM			0x12	// has additional bit 2
#define I5505IDX_256				2
#define I5505IDX_RP				1
#define I5505IDX_DP				0

#define I5505REG_PLAY			0x13
#define I5505REG_MUTE			0x14
//#define I5505REG_REQ				0x15	// ???
//#define I5505REG_ACK				0x16	// ???


#define I5505REG_PLLMASK		0x18


#define I5505REG_SYNCSTATUS	0x40

#define I5505IDX_FRAMESTATUS	0, 2

#define I5505FRMSTAT_SEARCH	0
#define I5505FRMSTAT_WAIT		1
#define I5505FRMSTAT_SYNC		2

#define I5505IDX_PACKETSTATUS	2, 2

#define I5505PCKSTAT_SEARCH	0
#define I5505PCKSTAT_WAIT		1
#define I5505PCKSTAT_SYNC		2


#define I5505REG_ANCCOUNT		0x41
#define I5505REG_HEAD24			0x42
#define I5505REG_HEAD16			0x43
#define I5505REG_HEAD8			0x44
#define I5505REG_HEAD0			0x45
#define I5505REG_PTS33			0x46
#define I5505REG_PTS24			0x47
#define I5505REG_PTS16			0x48
#define I5505REG_PTS8			0x49
#define I5505REG_PTS0			0x4a
//#define I5505REG_USER1			0x4b	// ???


#define I5505REG_STREAMSEL		0x4c

#define I5505STRSEL_PES			0
#define I5505STRSEL_PESDVD		1
#define I5505STRSEL_PACKMPEG1	2
#define I5505STRSEL_ELEMNTRY	3
#define I5505STRSEL_RES3520A	4
#define I5505STRSEL_SPDIF_IN	5


#define I5505REG_DECODESEL		0x4d

#define I5505DECSEL_AC3			0
#define I5505DECSEL_MPEG		1
#define I5505DECSEL_MPEGEXT	2                                                                
#define I5505DECSEL_LPCM		3
#define I5505DECSEL_PINKNOISE	4
#define I5505DECSEL_CD_DA		5
#define I5505DECSEL_DTS			6

#define I5505REG_BAL_LR			0x4e   // only until cut 2.1
#define I5505REG_VOLUME0		0x4e   // cut 3.1 and higher


#define I5505REG_PACKETLOCK	0x4f
#define I5505REG_AUDIOIDEN		0x50
#define I5505REG_AUDIOID		0x51
#define I5505REG_AUDIOIDEXT	0x52
#define I5505REG_SYNCLOCK		0x53


#define I5505REG_PCMDIVIDER	0x54
#define I5505REG_PCMCONFIG		0x55

#define I5505IDX_PCMORDER		6
#define I5505IDX_PCMDIFF		5
#define I5505IDX_INVLRCLK		4
#define I5505IDX_FORMAT			3
#define I5505IDX_INVSCLK		2
#define I5505IDX_PCMPREC		0, 2

#define I5505PCMPREC_16			0
#define I5505PCMPREC_18			1
#define I5505PCMPREC_20			2
#define I5505PCMPREC_24			3


#define I5505REG_PCMCROSS		0x56


// These registers are not documented for the 5505, but they must be written
// in order to have the audio decoder working.
#define I5505REG_LDLY			0x57
#define I5505REG_RDLY			0x58
#define I5505REG_CDLY			0x59
#define I5505REG_SUBDLY			0x5a
#define I5505REG_LSDLY			0x5b
#define I5505REG_RSDLY			0x5c
#define I5505REG_DLYUPDATE		0x5d


#define I5505REG_IEC958CMD		0x5e
#define I5505IECMD_OFF			0
#define I5505IECMD_MUTED		1
#define I5505IECMD_PCM			2
#define I5505IECMD_ENCODED		3

#define I5505REG_IEC958CAT		0x5f

#define I5505REG_IEC958CONF	0x60
#define I5505IDX_IECDIV			0, 5
#define I5505IDX_IECIDLESTATE	5
#define I5505IDX_IECSLR			5		// Swap left/right on SPDIF. New for Chipcut > 3.1
#define I5505IDX_IECSYNCMT		6
#define I5505IDX_IECAUTOLATOFF	7		// Auto latency off (1)/on (0)

#define I5505REG_IEC958STATUS	0x61
#define I5505IDX_IEC44KHZ		3, 4
#define I5505IDX_IECPREEMPH	2
#define I5505IDX_IECCOPY		1
#define I5505IDX_IECCOMPRESS	0


#define I5505REG_PDEC			0x62

#define I5505IDX_SRSTSENA		6
#define I5505IDX_DEM				5
#define I5505IDX_DCF				4
#define I5505IDX_MDRC			1
#define I5505IDX_PL				0


#define I5505REG_BAL_SUR		0x63   // only until cut 2.1
#define I5505REG_VOLUME1		0x63   // cut 3.1 and higher


#define I5505REG_PLAB			0x64

#define I5505IDX_SRSTSCFG		2, 5


#define I5505REG_PLDWNX			0x65

#define I5505PLDWNX_DISABLED	0
#define I5505PLDWNX_3_0			3
#define I5505PLDWNX_2_1			4
#define I5505PLDWNX_3_1			5
#define I5505PLDWNX_2_2			6
#define I5505PLDWNX_3_2			7


#define I5505REG_OCFG			0x66

#define I5505IDX_OCFG			0, 3
#define I5505IDX_LFE				7


#define I5505REG_PCMSCALE		0x67   // only until cut 2.1
#define I5505REG_CHAN_IDX		0x67   // cut 3.1 and higher


#define I5505REG_LFE				0x68	


// Meaning of register depends on AC3 or MPEG2 audio.
#define I5505REG_COMPMOD		0x69
#define I5505REG_PROGNUMBER	0x69

#define I5505CMPMOD_CUSTOMA	0
#define I5505CMPMOD_CUSTOMD	1
#define I5505CMPMOD_LINEOUT	2
#define I5505CMPMOD_RFMODE		3


#define I5505REG_HDR				0x6a
// meaning of this register in MPEG mode
#define I5505REG_DRC				0x6a

#define I5505REG_LDR				0x6b
#define I5505REG_RPC				0x6c


#define I5505REG_KARAMODE		0x6d

#define I5505KARAMD_AWARE		0
#define I5505KARAMD_MLTCHANL	3
#define I5505KARAMD_DOWNMIX	7
#define I5505KARAMD_REPRDC_1	5
#define I5505KARAMD_REPRDC_2	6
#define I5505KARAMD_REPRDC_12	4

// Definition of this register in MPEG mode:
#define I5505REG_MCOFF			0x6d
#define I5505IDX_MC				0
#define I5505IDX_DEN				4

#define I5505REG_DUALMODE		0x6e

#define I5505DLMD_STEREO		0
#define I5505DLMD_CHANNEL1		1
#define I5505DLMD_CHANNEL2		2
#define I5505DLMD_MIX			3


#define I5505REG_DOWNMIX		0x6f

#define I5505DWNMX_2_0_COMP	0
#define I5505DWNMX_1_0			1
#define I5505DWNMX_2_0			2
#define I5505DWNMX_3_0			3
#define I5505DWNMX_2_1			4
#define I5505DWNMX_3_1			5
#define I5505DWNMX_2_2			6
#define I5505DWNMX_3_2			7

// Definition for MPEG and MPEG Karaoke

#define I5505DMPG_1_0			0
#define I5505DMPG_2_0			1
#define I5505DMPG_3_0			2
#define I5505DMPG_2_1			3
#define I5505DMPG_3_1			4
#define I5505DMPG_2_2			5
#define I5505DMPG_3_2			6
#define I5505DMPG_2_0_DS		9
#define I5505DMPG_KARA_2_0		10
#define I5505DMPG_KARA_A1		11
#define I5505DMPG_KARA_A2		12
#define I5505DMPG_KARA_NONE	13

// Definition for DOWNMIX bits in Pink Noise mode

#define I5505DMPN_L				0
#define I5505DMPN_R				1
#define I5505DMPN_C				2
#define I5505DMPN_LFE			3
#define I5505DMPN_LS				4
#define I5505DMPN_RS				5


// Downsampling mode

#define I5505REG_DWSMODE		0x70

#define I5505DWSM_AUTO			0
#define I5505DWSM_FORCE			1
#define I5505DWSM_SUPPRESS		2


#define I5505REG_SOFTVER		0x71
#define I5505REG_RUN				0x72


#define I5505REG_SKIP_MUTE_CMD	0x73	// ???

#define I5505IDX_SMUT			0
#define I5505IDX_SKP				1
#define I5505IDX_BLK				2
#define I5505IDX_PAU				3
#define I5505IDX_REB				4
#define I5505IDX_MU				5


#define I5505REG_SKIP_MUTE_VALUE	0x74	// ???


#define I5505REG_IEC958REPTIME	0x75


#define I5505REG_AC3STAT0		0x76

#define I5505IDX_FSCOD			5, 2
#define I5505IDX_FRMSZCOD		0, 5


#define I5505REG_AC3STAT1		0x77

#define I5505IDX_LFEPRESENT	3
#define I5505IDX_ACMOD			0, 3


#define I5505REG_AC3STAT2		0x78

#define I5505IDX_BSMOD			5, 3
#define I5505IDX_BSID			0, 5


#define I5505REG_AC3STAT3		0x79	// ???

#define I5505IDX_CMIXLEVEL		2, 2
#define I5505IDX_SURMIXLEVEL	0, 2


#define I5505REG_AC3STAT4		0x7a

#define I5505IDX_DSURMOD		3, 2
#define I5505IDX_COPYRIGHT		2
#define I5505IDX_ORIGBS			1
#define I5505IDX_LANGCODE		0


#define I5505REG_LANGCODE		0x7b
#define I5505REG_DIALNORM		0x7c


#define I5505REG_AC3STAT7		0x7d

#define I5505IDX_ROOMTYPE		6, 2
#define I5505IDX_MIXLEVEL		1, 5
#define I5505IDX_AUDPRODIE		0


#define I5505REG_IEC958LATENCY		0x7e


//#define I5505REG_PCMFCROSS		0x7f
#define I5505REG_IEC958DTDI	0x7f

#define I5505IDX_PFC				7
#define I5505IDX_DTD				6
#define I5505IDX_INF				0, 5


//************************************************************************
// Subpicture decoder registers.

#define I5505REG_SPD_CTL1		0x00

#define I5505IDX_SPD_CTL1_S	0
#define I5505IDX_SPD_CTL1_D	1
#define I5505IDX_SPD_CTL1_V	2
#define I5505IDX_SPD_CTL1_H	3
#define I5505IDX_SPD_CTL1_B	4
#define I5505IDX_SPD_CTL1_SPP	5
#define I5505IDX_SPD_CTL1_TOP	6
#define I5505IDX_SPD_CTL1_BOT	7


#define I5505REG_SPD_RST		0x01

#define I5505REG_SPD_CTL2		0x02

#define I5505REG_SPD_LUT		0x03

#define I5505REG_SPD_XDO8		0x04
#define I5505REG_SPD_XDO0		0x05

#define I5505REG_SPD_YDO8		0x06
#define I5505REG_SPD_YDO0		0x07

#define I5505REG_SPD_XD18		0x08
#define I5505REG_SPD_XD10		0x09

#define I5505REG_SPD_YD18		0x0a
#define I5505REG_SPD_YD10		0x0b

#define I5505REG_SPD_HLSX8		0x0c
#define I5505REG_SPD_HLSX0		0x0d

#define I5505REG_SPD_HLSY8		0x0e
#define I5505REG_SPD_HLSY0		0x0f

#define I5505REG_SPD_HLEX8		0x10
#define I5505REG_SPD_HLEX0		0x11

#define I5505REG_SPD_HLEY8		0x12
#define I5505REG_SPD_HLEY0		0x13

#define I5505REG_SPD_HLRCO8	0x14
#define I5505REG_SPD_HLRCO0	0x15

#define I5505REG_SPD_HLRC8		0x16
#define I5505REG_SPD_HLRC0		0x17

#define I5505REG_SPD_SXDO8		0x24
#define I5505REG_SPD_SXDO0		0x25

#define I5505REG_SPD_SYDO8		0x26
#define I5505REG_SPD_SYDO0		0x27

#define I5505REG_SPD_SXD18		0x28
#define I5505REG_SPD_SXD10		0x29

#define I5505REG_SPD_SYD18		0x2a
#define I5505REG_SPD_SYD10		0x2b

#define I5505REG_SPD_SPB8		0x50
#define I5505REG_SPD_SPB0		0x51

#define I5505REG_SPD_SPE8		0x52
#define I5505REG_SPD_SPE0		0x53

#define I5505REG_SPD_SPREAD	0x4e
#define I5505REG_SPD_SPWRITE	0x4f










//************************************************************************

#define I3520AREG_CFG_MCF		0x00
#define I3520AREG_CFG_CCF		0x01
#define I3520AREG_VID_CTL		0x02

#define I3520AIDX_VID_CTL_ERU		7
#define I3520AIDX_VID_CTL_ERS		6
#define I3520AIDX_VID_CTL_CFB		5
#define I3520AIDX_VID_CTL_DEC		4
#define I3520AIDX_VID_CTL_ERP		3
#define I3520AIDX_VID_CTL_PRS		2
#define I3520AIDX_VID_CTL_SRS		1
#define I3520AIDX_VID_CTL_EDC		0


#define I3520AREG_VID_TIS		0x03  

#define I3520ATIS_EXE			0
#define I3520ATIS_RPT			1
#define I3520ATIS_FIS			2
#define I3520ATIS_OVW			3
#define I3520ATIS_SKP			4, 2
#define I3520ATIS_MP2			6

#define I3520AREG_VID_PFH		0x04
#define I3520AREG_VID_PFV		0x05
#define I3520AREG_VID_PPR1		0x06
#define I3520AREG_VID_PPR2		0x07

#define I3520AREG_CFG_MRF		0x08
#define I3520AREG_CFG_MWF		0x08
#define I3520AREG_CFG_BMS		0x09
#define I3520AREG_CFG_MRP		0x0A
#define I3520AREG_CFG_MWP		0x0B
#define I3520AREG_VID_DFP8		0x0C
#define I3520AREG_VID_DFP0		0x0D
#define I3520AREG_VID_RFP8		0x0E
#define I3520AREG_VID_RFP0		0x0F

#define I3520AREG_VID_FFP8		0x10
#define I3520AREG_VID_FFP0		0x11
#define I3520AREG_VID_BFP8		0x12
#define I3520AREG_VID_BFP0		0x13
#define I3520AREG_VID_VBG8		0x14
#define I3520AREG_VID_VBG0		0x15
#define I3520AREG_VID_VBL8		0x16
#define I3520AREG_VID_VBL0		0x17

#define I3520AREG_VID_VBS8		0x18
#define I3520AREG_VID_VBS0		0x19
#define I3520AREG_VID_VBT8		0x1A
#define I3520AREG_VID_VBT0		0x1B
#define I3520AREG_AUD_ABG8		0x1C
#define I3520AREG_AUD_ABG0		0x1D
#define I3520AREG_AUD_ABL8		0x1E
#define I3520AREG_AUD_ABL0		0x1F

#define I3520AREG_AUD_ABS8		0x20
#define I3520AREG_AUD_ABS0		0x21
#define I3520AREG_AUD_ABT8		0x22
#define I3520AREG_AUD_ABT0		0x23
#define I3520AREG_VID_DFS		0x24
#define I3520AREG_VID_DFW		0x25
#define I3520AREG_VID_DFA		0x26
#define I3520AREG_VID_XFS		0x27

#define I3520AREG_VID_XFW		0x28
#define I3520AREG_VID_XFA		0x29
#define I3520AREG_VID_OTP		0x2A
#define I3520AREG_VID_OBP		0x2B
#define I3520AREG_VID_PAN8		0x2C
#define I3520AREG_VID_PAN0		0x2D
#define I3520AREG_VID_SCN8		0x2E
#define I3520AREG_VID_SCN0		0x2F

#define I3520AREG_CKG_PLL		0x30
#define I3520AREG_CKG_CFG		0x31
#define I3520AREG_CKG_AUD		0x32
#define I3520AREG_CKG_VID		0x33
#define I3520AREG_CKG_PIX		0x34
#define I3520AREG_CKG_PCM		0x35
#define I3520AREG_CKG_MCK		0x36
#define I3520AREG_CKG_AUX		0x37

#define I3520AREG_CFG_DRC		0x38
#define I3520AREG_CFG_BFS		0x39
#define I3520AREG_CFG_GCF		0x3A
#define I3520AREG_VID_STA16	0x3B
#define I3520AREG_VID_ITM16	0x3C
#define I3520AREG_VID_ITS16	0x3D

#define I3520AREG_PES_CF1		0x40
#define I3520AREG_PES_CF2		0x41
#define I3520AREG_PES_SPF		0x42
#define I3520AREG_PES_STA		0x43
#define I3520AREG_PES_SC1		0x44
#define I3520AREG_PES_SC2		0x45
#define I3520AREG_PES_SC3		0x46
#define I3520AREG_PES_SC4		0x47

#define I3520AREG_PES_SC5		0x48
#define I3520AREG_PES_TS1		0x49
#define I3520AREG_PES_TS2		0x4A
#define I3520AREG_PES_TS3		0x4B
#define I3520AREG_PES_TS4		0x4C
#define I3520AREG_PES_TS5		0x4D

#define I3520ASTA_SCH			MKFLAG(0)	//	StartCodeHit
#define I3520ASTA_BFF			MKFLAG(1)	// 
#define I3520ASTA_HFE			MKFLAG(2)	// HeaderFifoEmpty
#define I3520ASTA_BBF			MKFLAG(3)	// BitBufferFull
#define I3520ASTA_BBE			MKFLAG(4)	// BitBufferEmpty
#define I3520ASTA_VSB			MKFLAG(5)	// VSYNCBottom
#define I3520ASTA_VST			MKFLAG(6)	// VSYNCTop
#define I3520ASTA_PSD			MKFLAG(7)	// PipelineStartingToDecode
#define I3520ASTA_PER			MKFLAG(8)	// PipelineError
#define I3520ASTA_PID			MKFLAG(9)	// PipelineIdle
#define I3520ASTA_WFE			MKFLAG(10)	// WriteFIFOEmpty
#define I3520ASTA_RFF			MKFLAG(11)	// ReadFIFOFull
#define I3520ASTA_HFF			MKFLAG(12)	// HeaderFIFOFull
#define I3520ASTA_BMI			MKFLAG(13)	// BlockMoveIdle
#define I3520ASTA_SER			MKFLAG(14)	// SevererErrorOrOverflowError
#define I3520ASTA_PDE			MKFLAG(15)	// PictureDecodingErrorOrUnderflowError
#define I3520ASTA_ABE			MKFLAG(16)	// AudioBitBufferEmpty
#define I3520ASTA_WFN			MKFLAG(17)	// WriteFIFONotFull
#define I3520ASTA_RFN			MKFLAG(18)	// ReadFIFONotEmpty
#define I3520ASTA_ABF			MKFLAG(19)	// AudioBitBufferFull
#define I3520ASTA_HAF			MKFLAG(20)	// HistoryFIFOAlmostFull
#define I3520ASTA_SCR			MKFLAG(21)	// NewSCRLatched
#define I3520ASTA_ERR			MKFLAG(22)	// InconsistencyErrorInPESParser
#define I3520ASTA_NDP			MKFLAG(23)	// NewDiscardedPacket

#define I3520AREG_VID_ITM8		0x60
#define I3520AREG_VID_ITM0		0x61
#define I3520AREG_VID_ITS8		0x62
#define I3520AREG_VID_ITS0		0x63
#define I3520AREG_VID_STA8		0x64
#define I3520AREG_VID_STA0		0x65
#define I3520AREG_VID_HDF		0x66
#define I3520AREG_VID_CDCNT	0x67
#define I3520AREG_VID_SCDCNT	0x68 
#define I3520AREG_VID_HDS		0x69
#define I3520AREG_VID_LSO		0x6A
#define I3520AREG_VID_LSR0		0x6B
#define I3520AREG_VID_CSO		0x6C
#define I3520AREG_VID_LSR8		0x6D
#define I3520AREG_VID_YDO		0x6E
#define I3520AREG_VID_YDS		0x6F
#define I3520AREG_VID_XDO8		0x70
#define I3520AREG_VID_XDO0		0x71
#define I3520AREG_VID_XDS8		0x72
#define I3520AREG_VID_XDS0		0x73
#define I3520AREG_VID_DCF8		0x74
#define I3520AREG_VID_DCF0		0x75    

#define I3520AREG_VID_DCF_OAD	14, 2
#define I3520AREG_VID_DCF_OAM	13
#define I3520AREG_VID_DCF_FRZ	12
#define I3520AREG_VID_DCF_DAM	9, 3
#define I3520AREG_VID_DCF_FLD	8
#define I3520AREG_VID_DCF_USR	7
#define I3520AREG_VID_DCF_PXD	6
#define I3520AREG_VID_DCF_EVD	5
#define I3520AREG_VID_DCF_EOS	4
#define I3520AREG_VID_DCF_DSE	3
#define I3520AREG_VID_DCF_VCF	0, 3

#define I3520AREG_VID_QMW		0x76

#define I3520AREG_AUD_ANC0		0x86
#define I3520AREG_AUD_ANC8		0x87

#define I3520AREG_AUD_ANC16	0x88
#define I3520AREG_AUD_ANC24	0x89
#define I3520AREG_AUD_ESC0		0x8A
#define I3520AREG_AUD_ESC8		0x8B
#define I3520AREG_AUD_ESC16	0x8C
#define I3520AREG_AUD_ESC24	0x8D
#define I3520AREG_AUD_ESC32	0x8E
#define I3520AREG_AUD_ESCX0	0x8F

#define I3520AREG_STC_INC		0x90
#define I3520AREG_AUD_LRP		0x91
#define I3520AREG_AUD_FFL0		0x94
#define I3520AREG_AUD_FFL8		0x95
#define I3520AREG_AUD_P18		0x96

#define I3520AREG_AUD_CDI0		0x98
#define I3520AREG_AUD_FOR		0x99
#define I3520AREG_AUD_ITR0		0x9A
#define I3520AREG_AUD_ITR8		0x9B
#define I3520AREG_AUD_ITM0		0x9C
#define I3520AREG_AUD_ITM8		0x9D
#define I3520AREG_AUD_LCA		0x9E
#define I3520AREG_AUD_EXT		0x9F

#define I3520AREG_AUD_RCA		0xA0
#define I3520AREG_STC_CTL		0xA1
#define I3520AREG_AUD_SID		0xA2
#define I3520AREG_AUD_SYN		0xA3
#define I3520AREG_AUD_IDE		0xA4
#define I3520AREG_AUD_SCM		0xA5
#define I3520AREG_AUD_SYS		0xA6
#define I3520AREG_AUD_SYE		0xA7

#define I3520AREG_AUD_LCK		0xA8
#define I3520AREG_AUD_CRC		0xAA
#define I3520AREG_AUD_SEM		0xAC
#define I3520AREG_AUD_PLY		0xAE

#define I3520AREG_AUD_MUT		0xB0
#define I3520AREG_AUD_SKP		0xB2
#define I3520AREG_AUD_ISS		0xB6

#define I3520AREG_AUD_ORD		0xB8
#define I3520AREG_AUD_LAT		0xBC

#define I3520AREG_AUD_RES		0xC0
#define I3520AREG_AUD_RST		0xC2
#define I3520AREG_AUD_SFR		0xC4
#define I3520AREG_AUD_DEM		0xC6

#define I3520AREG_STC_DIV0		0xC8
#define I3520AREG_STC_DIV8		0xC9
#define I3520AREG_STC0			0xCA
#define I3520AREG_STC8			0xCB
#define I3520AREG_STC16			0xCC
#define I3520AREG_STC24			0xCD
#define I3520AREG_STC32			0xCE

#define I3520AREG_AUD_IFT		0xD2
#define I3520AREG_AUD_SCP		0xD3

#define I3520AREG_AUD_ITS		0xDB
#define I3520AREG_AUD_IMS		0xDC
#define I3520AREG_AUD_HDR0		0xDE
#define I3520AREG_AUD_HDR8		0xDF

#define I3520AREG_AUD_HDR16	0xE0
#define I3520AREG_AUD_HDR24	0xE1
#define I3520AREG_AUD_PTS0		0xE2
#define I3520AREG_AUD_PTS8		0xE3
#define I3520AREG_AUD_PTS16	0xE4
#define I3520AREG_AUD_PTS24	0xE5
#define I3520AREG_AUD_PTS32	0xE6

#define I3520AREG_BAL_LIMx		0xE9
#define I3520AREG_BAL_LIMy		0xEB
#define I3520AREG_AUD_ADA		0xEC
#define I3520AREG_AUD_REV		0xED
#define I3520AREG_AUD_DIV		0xEE
#define I3520AREG_AUD_DIF		0xEF

#define I3520AREG_AUD_BBE		0xF0

#define I3520AREG_VID_REV		0xF8

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\specific\i5505aud.h ===
// FILE:			library\hardware\mpeg2dec\specific\i5505aud.h
// AUTHOR:		U. Sigmund, D. Heidrich, S. Herr
// COPYRIGHT:	(c) 1998 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		30.07.98
//
// PURPOSE:		Audio decoder of the STi5505.
//
// HISTORY:

#ifndef I5505AUD_H
#define I5505AUD_H

#include "..\generic\mp2eldec.h"
#include "library\hardware\audio\generic\audiodac.h"
#include "library\lowlevel\hardwrio.h"
#include "library\general\asncstrm.h"  
#include "library\lowlevel\intrctrl.h"
#include "library\common\krnlstr.h"
#include "library\hardware\clocks\generic\clocks.h"
#include "library\common\profiles.h"


#if 0
enum DACType
	{
	DACT_DEFAULT,
	DACT_PCM1720
	};

enum DACFormat
	{
	DACF_I2S,
	DACF_SONY
	};

enum PLLType
	{
	PLLT_NONE,
	PLLT_PLL1700
	};
#endif

class STi5505AC3Decoder : public MPEG2AC3Decoder, 
                          protected ASyncRefillRequest,
                          protected InterruptHandler
	{
	friend class VirtualSTi5505AC3Decoder;
	protected:
		GenericProfile					*	profile;
		ByteIndexedInOutPort			*	port;
		ByteIndexedInOutPort			*	bufferPort;
		VirtualAudioDAC				*	dac; 
		ASyncOutStream					*	strm;		
		ProgrammableClockGenerator *	audioClock;
		BitOutputPort					*	boardMutePort;

		int			inUpdate;

		// Configuration
		BOOL			dtsEnable;
		BOOL			srsEnable;
		BOOL			enable3DSound;
		BOOL			mpeg2MCEnable;
		int			dacType;
		WORD			dacNum;
		int			dacFormat;
		WORD			dacBits;
		DWORD			dacSampleRate;
		BOOL			dacLRSwap;
		WORD			pcmClock;		
		int			pllType;
		BOOL			halfFsAt96kHz;
		int			downmixForce;
		BOOL			limitPCM;

		DWORD			changed;

		BYTE			chipVersion;
		BYTE			softVersion;

		DWORD 		initialPTS;
		DWORD			audioBitrate;
		DWORD			sampleRate;
		WORD			bitsPerSample;
		WORD			channels;
		MPEGState	state;
		MPEG2AudioType	audioType;
		BOOL			ac3, lpcm;
		BYTE			ac3StreamID;
		PTSAssoc		ptsAssoc;
		DWORD			streamPosition;
		WORD			muteDelay;
		WORD			playbackSpeed;

		WORD			leftDelay;
		WORD			rightDelay;
		WORD			centerDelay;
		WORD			leftSurroundDelay;
		WORD			rightSurroundDelay;
		WORD			subwooferDelay;

		DWORD			signalPosition;
		DWORD			predPosition;

		DWORD			stepCnt;

		DWORD			conformPTS;
		BOOL			conformPTSValid;
		PTSCounter	ptsCounter;

		BOOL			internalPCMClock;
		BOOL			starving, syncPlayDelay;

		MPEG2PESType	needsPES;

		BOOL			decodeLFE;

		int			frameBytePos, frameBytesLeft, frameStepCount;

		AudioTypeConfig			typeConfigs[MP2AUDTYP_NUMBER_OF_TYPES];

		AC3SpeakerConfig			speakerConfig;
		AC3KaraokeConfig			karaokeConfig;
		AC3DualModeConfig			dualModeConfig;

		SPDIFHandling				spdifHandling;
		SPDIFOutputMode			spdifOutMode;
		SPDIFCopyMode				spdifCopyMode;
		SPDIFCopyMode				overrideSPDIFCopyMode;

		MPEG2AudioSpatializer	spatializer;

		DolbyProLogicConfig		prologicConfig;
		DolbyProLogicMode			prologicMode;
		AC3DynamicRange			ac3DynamicRange;
		PCMOutputConfig			pcmOutputConfig;
		PCM96DownsampleMode		downSampleMode;

		VirtualUnit	*	audioBus;

		BOOL	mute;
		WORD	lv, rv, lsv, rsv, swv, cv;   // volumes for left, right, l surround, r surround, subwoofer and center
		
		BOOL	spdifUpdateRequest;
		BYTE	updateSPDIFCmd;

		MPEG2CommandQueue	commandQueue;

		enum XState
			{
			xreset,											//  0
			xplaying,										//  1
			xfrozen,											//  2
			xstopped,										//  3
			xseeking,										//  4
			xresync,											//  5
			xstepping,										//  6
			xstarving,										//  7
			xstill,											//  8
			xseeking_audio,								//  9
			xresync_audio,									// 10
			xseeking_audio_waitforcompletion,		// 11
			xseeking_audio_datacomplete,				// 12
			xtesting											// 13
			} xstate, preSeekAudioState;

#if _DEBUG
		void PrintStatus(void);
#endif

		DWORD		xwatchdog;
#if 0		
		DWORD		oldAvailData;
#endif

		DWORD		GetInternalPTS();

		virtual	Error Update(void);

		Error		ProgramMuteAll(BOOL mute);

		Error SetVolume(void);

		Error SetAudioType(MPEG2AudioType audioType);

		virtual Error	SetSpatializer(MPEG2AudioSpatializer spatializer);

		virtual Error	SetSPDIFHandling(SPDIFHandling spdifHandling);
		virtual Error	SetSPDIFOutputMode(SPDIFOutputMode spdifOutMode);
		virtual Error	SetSPDIFCopyMode(SPDIFCopyMode spdifCopyMode);
		virtual Error	Set96kHzDACDownSampleMode(PCM96DownsampleMode	dacDownSampleMode);
		virtual Error	Set96kHzSPDIFDownSampleMode(PCM96DownsampleMode	spdifDownSampleMode);

   	Error SetDVDStreamEncrypted(BOOL dvdEncrypted);

		Error SetAudioBitrate(DWORD bitrate);
		Error SetSampleRate(WORD rate);
		Error SetLeftVolume(WORD volume);
		Error SetRightVolume(WORD volume);
		Error SetMute(BOOL mute);
		Error SetAC3(BOOL ac3);
		Error SetLPCM(BOOL lpcm);
		Error SetBitsPerSample(WORD samples);
		Error SetChannels(WORD channels);

		Error SetBassConfig(AC3BassConfig config);
		Error SetSpeakerConfig(AC3SpeakerConfig config);
		Error SetDualModeConfig(AC3DualModeConfig config);
		Error SetKaraokeConfig(AC3KaraokeConfig config);
		Error SetCenterDelay(WORD delay);
		Error SetSurroundDelay(WORD delay);      

		Error SetCenterVolume(WORD volume);
		Error SetLeftSurroundVolume(WORD volume);
		Error SetRightSurroundVolume(WORD volume);
		Error SetSubwooferVolume(WORD volume);

		Error SetLeftDelay(WORD leftDelay);
		Error SetRightDelay(WORD rightDelay);
		Error SetLeftSurroundDelay(WORD leftSurroundDelay);
		Error SetRightSurroundDelay(WORD rightSurroundDelay);
		Error SetSubwooferDelay(WORD subwooferDelay);
		Error SetPrologicConfig(DolbyProLogicConfig prologicConfig);
		Error SetPrologicMode(DolbyProLogicMode prologicMode);
		Error SetDecodeLFE(BOOL decodeLFE);
		Error SetPCMOutputConfig(PCMOutputConfig pcmOCFG);
		Error SetDynamicRange(AC3DynamicRange dynamicRange);
		Error SetAudioTypeConfig(MPEG2AudioType type, AudioTypeConfig config);

		virtual Error SendCommand(MPEGCommand com, DWORD param, DWORD __far &tag);
		virtual BOOL CommandPending(DWORD tag);

		virtual DWORD CurrentLocation(void);
		virtual MPEGState CurrentState(void);

		DWORD LastTransferLocation(DWORD scale);

		virtual DWORD GetPTS();
		virtual Error ConformToPTS (DWORD pts);

		DWORD SendData(HPTR data, DWORD size);
#if VIONA_VERSION
		Error SendPESData(HPTR data, DWORD size, DWORD __far & done, DWORD __far & used);
#endif
		void CompleteData(void);

		void PutPTS(DWORD pts);

		//
		// Forward the refill request
		//
		void RefillRequest(DWORD free);
		void Interrupt(void);

		Error SetSignalPosition(DWORD position);
		void	CheckSignalPosition (void);

		void ReadWordHL (ByteIndexedInOutPort *port, WORD offset, WORD &result);

		Error SyncPlay(void);

		InterruptServer	*	vblank;
		InterruptServer	*	audioIRQServer;
		InterruptHandler	*	audioIRQHandler;
		BOOL						audioIRQEnable;

		Error ReInitialize(void);

		Error SelectPlaybackType(void);

		Error ProgramDACFormat(BOOL limitWidth);
		Error ProgramOutputFormat(BOOL limitWidth);
	public:
		STi5505AC3Decoder (ByteIndexedInOutPort	*	port,
		                   ByteIndexedInOutPort	*	bufferPort,
		                   VirtualAudioDAC		 	*	dac,
		                   ASyncOutStream			*	strm,
		                   InterruptServer			*	vblank,
		                   VirtualUnit				*	audioBus = NULL,
		                   BOOL							internalPCMClock = NULL,
		                   ProgrammableClockGenerator * audioClock = NULL,
								 GenericProfile			*	profile = NULL,
								 BitOutputPort				*	boardMutePort = NULL,
								 InterruptServer			*	audioIRQServer = NULL);

		VirtualUnit * CreateVirtual(void);

		Error LoadPatchFile(void);
		Error Initialize(void);
		void AudioInterrupt(void);
	};



class VirtualSTi5505AC3Decoder : public VirtualMPEG2AC3Decoder
	{
	private:
		STi5505AC3Decoder	*		decoder;

		BOOL	idleUnit;
		BOOL	activatedAsIdle;

		SPDIFHandling				spdifHandling;
		SPDIFOutputMode			spdifOutMode;
		SPDIFCopyMode				spdifCopyMode;
		MPEG2AudioSpatializer	spatializer;
		PCM96DownsampleMode		dacDownSampleMode;
		PCM96DownsampleMode		spdifDownSampleMode;
	protected:
		Error PreemptStopPrevious(VirtualUnit * previous);
		Error PreemptStartNew(VirtualUnit * previous);
      Error PreemptChange(VirtualUnit * previous);
	public:
		VirtualSTi5505AC3Decoder(STi5505AC3Decoder * decoder, BOOL idleUnit = FALSE);

		Error Configure(TAG __far * tags);

#if VIONA_VERSION
		MPEG2PESType NeedsPES(void) {return decoder->needsPES;}
#endif
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\specific\OSDdata.h ===
// to import OSD-data

#include "library\common\prelude.h"

#define OSDpixels1 184
#define OSDlines1 94
#define OSDpixels2 160
#define OSDlines2 90

#if WDM_VERSION
extern DWORD OSDdata1[OSDpixels1 / 2 * OSDlines1];
extern DWORD OSDdata2[OSDpixels2 / 8 * OSDlines2];
#else
extern DWORD __based(__segname("_CODE")) OSDdata1[OSDpixels1 / 2 * OSDlines1];
extern DWORD __based(__segname("_CODE")) OSDdata2[OSDpixels2 / 8 * OSDlines2];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\specific\ccubdvd1.h ===
#ifndef CCUBDVD1_H
#define CCUBDVD1_H

#include "library\common\krnlsync.h"
#include "library\lowlevel\intrctrl.h"
#include "library\common\krnlstr.h"
#include "library\hardware\mpeg2dec\generic\mpeg2dec.h"
#include "library\hardware\clocks\generic\clocks.h"
#include "library\hardware\audio\generic\audiodac.h"
#include "library\hardware\video\generic\ccapvenc.h"

#if ZIVA_PC_DECODER
class CCubeDVD1Decoder : public MPEG2AVDecoder, protected InterruptHandler, protected VDCriticalSection, protected VDIRQSafeSpinLock, protected ASyncRefillRequest
#else
class CCubeDVD1Decoder : public MPEG2AVDecoder, protected InterruptHandler, protected VDCriticalSection, protected VDSpinLock, protected ASyncRefillRequest
#endif
	{
	friend class VirtualCCubeDVD1Decoder;
	protected:
		//
		// Configuration parameters
		//
		ByteIndexedInOutPort			*	port;
		ByteOutputPort					*	codePort;
		InterruptServer				*	intServer;
		DualASyncOutStream			*	strm;
		ProgrammableClockGenerator	*	audioClock;
		VirtualAudioDAC				*	dac;
		VirtualUnit						*	videoBus;
		VirtualUnit						*	audioBus;
		MPEG2DVDDecryption			*	decryption;
		BitOutputPort					*	resetPort;
		
		DWORD									ccpTimeoutCounter;

		BOOL									progressive;
#if 0
		BOOL									progressiveMaterial, wasProgressiveMaterial;
		BYTE									progressiveHistory;
#endif

		BOOL									ccEnabled;
		
		BOOL									dvdDemux;
		BOOL									streamEncrypted;

		ForcedAspectRatio					forcedSourceAR;

		SPDIFHandling						spdifHandling;
		LONG									spdifDisableMethod;
		LONG									alwaysDisableSPDIF;
		LONG									alwaysMuteDAC;

		DWORD									uCodeRevision;
		DWORD									siliconRevision;

		WORD									pcmClockDivider;
		
		DWORD									changed;
		
		DWORD									spuPalette[16];
		
		BOOL									mute;
		WORD									leftVolume, rightVolume;
		DWORD									audioSampleRate;
		
		BOOL									ac3, lpcm;

		enum AudioType {AT_LPCM, AT_AC3, AT_MPEG} audioType;
		
		VideoStandard						videoStandard;
		VideoStandard						currentVideoStandard;
		MPEG2PresentationMode			presentationMode;
		
		BYTE									videoStreamID, audioStreamID, ac3StreamID, lpcmStreamID, spuStreamID, dtsStreamID;
		BOOL									spuEnable;
		
		BOOL									highlightValid;
		BOOL									highlightUpdateRequest;
		BOOL									subPicPaletteRequest;
				
		SPUButtonState						buttonState, updateButtonState;
		WORD									buttonID, updateButtonID;
		DWORD									buttonSelectedColor, buttonActiveColor;
		DWORD									updateButtonSelectedColor, updateButtonActiveColor;
		int									buttonLeft, buttonTop, buttonWidth, buttonHeight;
		int									updateButtonLeft, updateButtonTop, updateButtonWidth, updateButtonHeight;
		
		WORD									lastAudioStreamID;
		WORD									lastSPUStreamID;
		WORD									lastVideoStreamID;
		
		DWORD									transferLocation;
		DWORD									transferLocationLow;
		DWORD									videoFilled, audioFilled, lastFilled;
		DWORD									finalLocation;
		
		DWORD									signalPosition, predPosition;
		
		DWORD									audioBitBufferSize, videoBitBufferSize;
		
		WORD									width, height, fps, aspectRatio;
		
      MPEG2CommandQueue					commandQueue;
      
  		BOOL									initialAuthenticate;
  		BOOL									diskKeyValid;
		BOOL									titleKeyValid;
		DWORD									titleKeySector;
		DWORD									authAddr; 
		
		DWORD									shadow160;
		MPEGStreamType 					streamType;
		BOOL									streamMode;
		
		LONG									lastPBTime;
		LONG									lastSTCTime;

#if 0 // WDM_VERSION && _DEBUG
		DWORD rrCount;
		DWORD oldRRCount;
		DWORD	oldRRTime;
#endif


		VirtualCloseCaptionVideoEncoder	*	ccenc;

#if WDM_VERSION
		MPEG2CCPacketHookHandle			ccPacketHook;

		DWORD	ac3OpMode;
		DWORD	ac3LowBoost;
		DWORD ac3HighCut;
		DWORD	pcmScaleFactor;
		DWORD	ac3VoiceSelect;
		
		BOOL	wdmPlayback;

		DWORD	buttonStartTime;
		DWORD	buttonEndTime;
		DWORD	updateButtonStartTime;
		DWORD	updateButtonEndTime;
#endif
		Profile	*	profile;

		Error CompleteCommand(DWORD tag);

		Error	OutDWord(DWORD at, DWORD data);
		Error	OutDWords(DWORD at, DWORD __far * data, DWORD num);
#if 0	//_DEBUG
		Error	OutDWordsXX(DWORD at, DWORD __far * data, DWORD num);
#endif
		Error OutBEDWord(DWORD at, DWORD data);
		Error	OutBEDWords(DWORD at, DWORD __far * data, DWORD num);
		Error InDWordNoLock(DWORD at, DWORD __far & data);
		Error	InDWord(DWORD at, DWORD __far & data);
		Error	InDWordSafe(DWORD at, DWORD __far & data);
		Error	InDWords(DWORD at, DWORD __far * data, DWORD num);
		Error ModifyDWord(DWORD at, DWORD mask, DWORD data);          
		
		Error ReloadConfigurationData(void);
		
		Error	CompleteHighPriorityCommand(DWORD command);
		Error ForceChipCommandExecution(void);
		Error ExecuteChipCommand(DWORD __far * cmd, WORD num);
		BOOL	ChipCommandPending(void);		
		Error	CompleteChipCommand(void);
		
		Error CmdAbort(BOOL flush);
		Error CmdFade(WORD level, WORD fadeTime);
		Error CmdFlushBuffer(WORD bufferID);
		Error CmdFreeze(WORD displayMode);
		Error CmdHighLight(WORD button, WORD action);
		Error CmdHighLight2(WORD contrast, WORD color, WORD left, WORD top, WORD width, WORD height);
		Error CmdNewPlayMode(void);
		Error CmdPause(WORD displayMode);
		Error CmdPlay(WORD playMode, WORD fadeTime, DWORD start, DWORD stop);
		Error CmdReset(void);
		Error CmdResume(WORD playMode);
		Error CmdScan(WORD skip, WORD scanMode, WORD displayMode);
		Error CmdScreenLoad(DWORD address, DWORD length, WORD displayMode);
		Error CmdSelectStream(WORD streamType, WORD streamNumber);
		Error CmdSetFill(WORD x, WORD y, WORD width, WORD height, DWORD color);
		Error CmdSetStreams(WORD videoID, WORD audioID);
		Error CmdSingleStep(WORD displayMode);
		Error CmdSlowMotion(WORD n, WORD displayMode);
		Error CmdAuthenticate(void);
		
		BOOL	stillSequence, wasStillSequence;
		DWORD	contentType;
		
		Error OutOfIRQJob(void);
		
		Error WaitForState(DWORD state);

		BOOL	singleFrame, singleFrameVOBU;
		
		int	xdelaycnt;
		
		enum XState
			{
			xreset,									// 0
			xidle,									// 1
			
			xinit_waitForRecovery,				// 2
			xinit_waitForBitBufferFilled,		// 3
			xinit_waitForDataRequest,        // 4
			xinit_waitForInitialFrame,			// 5
						
			xresync_waitForRecovery,			// 6
			xresync_waitForBitBufferFilled,	// 7
			xresync_waitForDataRequest,      // 8
			xresync_waitForInitialFrame,		// 9
			
			xscanning_restart,					// 10
			xscanning_waitForBitBufferFilled,// 11
			xscanning_waitForDataRequest,    // 12
			xscanning_waitForTransferComplete, // 13
			xscanning_waitForInitialFrame,	// 14
			xscanning_display,               // 15
			xplaying,                        // 16
			xpaused,                         // 17
			xstopped,                        // 18
			xseeking,                        // 19
			xseekprefreeze,                  // 20
			xseekabort,								// 21
			xresetprepare,							// 22
			xresetprefreeze,						// 23
			xresetdelay,							// 24
			xresetflush,							// 25
			xstopprefreeze,						// 26
			xseekabortdelay,						// 27
			xresetprefreezedelay,				// 28
			xresetdelaydelay,						// 29
			xresync_delay,							// 30
			xstopped_eof,							// 31
			xstopped_sof,							// 32
//			xscanning_waitForTransferCompleteInitialFrame	// 33
			xwaitforpaused

			} xstate;
		int xstateWatchdog, xstopWatchdog;		

	   friend XState operator ++(XState __far& x, int a) {return (XState)(((int __far&)x)++);}
	   friend XState operator --(XState __far& x, int a) {return (XState)(((int __far&)x)--);}
	   
	   DWORD	lastIRQTime;
      
      void ShowStatus(char __far * p);
      
      BOOL CheckChipAlive(void);

		DWORD	irqMask;
		
		virtual DWORD	GetIRQStatus();
		virtual void	ClearIRQStatus();
		virtual Error	SetInterruptMask(DWORD mask);
		virtual void	SetAudioClockSelection();
      
		virtual void	PackSyncClear() {;}

		virtual void	ExecuteVSYNCJob() {;}

      Error ProgramVolume(void);
      Error ProgramVideoStreamID(void);
      Error ProgramAudioStreamID(void);
      Error ProgramSPUStreamID(void);

		virtual Error ProgramVideoStandard();

		Error	SetDVDDemux(BOOL dvdDemux);
		Error	SetEncrypted(BOOL streamEncrypted);

		Error	SetForcedSourceAspectRatio(ForcedAspectRatio forcedSourceAR);

		Error	SetSPDIFHandling(SPDIFHandling spidfHandling);
      
		Error SetSampleRate(WORD rate);
		Error SetLeftVolume(WORD volume);
		Error SetRightVolume(WORD volume);
		Error SetMute(BOOL mute);

		Error SetBassConfig(AC3BassConfig config);
		Error SetSpeakerConfig(AC3SpeakerConfig config);
		Error SetCenterDelay(WORD delay);
		Error SetSurroundDelay(WORD delay);

		Error SetCenterVolume(WORD volume);
		Error SetLeftSurroundVolume(WORD volume);
		Error SetRightSurroundVolume(WORD volume);
		Error SetSubwooferVolume(WORD volume);

		Error SetAC3(BOOL ac3);
		Error SetLPCM(BOOL lpcm);
		Error SetVideoBitrate(DWORD videoBitrate);
		Error SetVideoWidth(WORD width);
		Error SetVideoHeight(WORD height);
		Error SetVideoFPS(WORD fps);
		Error SetAspectRatio(WORD aspectRatio);
		Error SetVideoStandard(VideoStandard	standard);
//		Error GetDisplaySize(WORD __far &width, WORD __far &height);	
		Error SetStreamType(MPEGStreamType streamType);
		Error SetStreamMode(MPEGStreamMode streamMode);
      Error SetVideoStreamID(BYTE id);
      Error SetAudioStreamID(BYTE id);
      Error SetAC3StreamID(BYTE id);
		Error SetDTSStreamID(BYTE id);
   	Error SetPresentationMode(MPEG2PresentationMode presentationMode);
		Error SetMPEG2Coding(BOOL mpeg2Coding);
		Error SetAudioBitrate(DWORD rate) {GNRAISE_OK;}
	
      Error SetLPCMStreamID(BYTE id);      
      Error SetSPUStreamID(BYTE id);
      Error SetSPUEnable(BOOL enable);
      Error SetSPUButtonState(SPUButtonState state);
      Error SetSPUButtonPosition(int x, int y, int width, int height);
      Error SetSPUButtonColors(DWORD selected, DWORD active);
      Error SetSPUPaletteEntry(int p, int y, int u, int v);
      Error SetSPUCommandHook(MPEG2SPUCommandHookHandle hook);
      Error SetSPUButtonID(WORD id);
      Error SetBitsPerSample(WORD bits);
      Error SetChannels(WORD channels);
      Error DoInternalAuthenticationCommand(MPEG2DVDAuthenticationCommand com, DWORD sector, BYTE __far * key);
      Error DoAuthenticationCommand(MPEG2DVDAuthenticationCommand com, DWORD sector, BYTE __far * key);
      
#if WDM_VERSION
		Error	SetCCPacketHook(MPEG2CCPacketHookHandle hook);
		Error SetWDMPlayback(BOOL wdmPlayback);
		Error	SetButtonStartTime(DWORD time);
		Error SetButtonEndTime(DWORD time);
#endif
		Error SetCCEnabled(BOOL ccEnabled);

		VirtualMPEG2AVDecoder * CreateVirtualMPEGDecoder(void);

	   DWORD SendData(HPTR data, DWORD size);
	   DWORD InternalTransferLocation(void);

		DWORD SendDataSplit(MPEGElementaryStreamType type, HPTR data, DWORD size, LONG time);
		void	CompleteDataSplit(MPEGElementaryStreamType type);
		void	RestartDataSplit(MPEGElementaryStreamType type);
	   
	   DWORD LastTransferLocation(DWORD scale = MP2SR_SCALE_BYTES);
	   void CompleteData(void);

	   Error SendCommand(MPEGCommand com, DWORD param, DWORD __far &tag);
		BOOL CommandPending(DWORD tag);
			
		DWORD CurrentLocation(void);
		MPEGState CurrentState(void);
			   
	   DWORD GetPTS();
	   
	   Error SetSignalPosition(DWORD position);

		Error	GetPlaybackTime(LONG __far & pbTime);
		Error	GetSTC(LONG __far & stcTime);

	   Error Update(void);
	   
	   Error SendFakeHeader(void);
	   Error BeginSeek(void);
	   Error BeginReset(void);
	   
      void Interrupt(void);
      void CriticalSection(void);

		void RefillRequest(DWORD free);
      
      Error BeginDecoding(void);
      Error EndDecoding(void);
      
      BOOL resetRequest;
      BOOL initialStartup;
      Error ReinitializeChip(void);
      
      KernelString microcodePath;
      
      BYTE ccbuffer[256];

#if WDM_VERSION
		BYTE gopBuffer[256];
		int goppos, goptotal;
		BOOL	origStartfield;
#endif

      int ccspos, ccstotal;
      BOOL ccstartfield;
      
      enum 
      	{
      	ccs_waitForSync,
      	ccs_waitForKey,
      	ccs_waitForHeader,
      	ccs_waitForMarker,
      	ccs_waitForFirstByte,
      	ccs_waitForSecondByte
      	} ccsState;
      
      BOOL lpcmSpdifOut;

		BOOL isZiVAPC;
      
      Error InterpretUserData(DWORD data);
      Error FlushUserData(void);
	public:
      InterruptServer				*	vblankServer;

		CCubeDVD1Decoder(ByteIndexedInOutPort			*	port,
							  InterruptServer					*	intServer,
							  DualASyncOutStream				*	strm,
							  ProgrammableClockGenerator	*	audioClock,
							  VirtualAudioDAC					*	dac,
							  VirtualUnit						*	videoBus,  
							  VirtualUnit						*	audioBus,
							  MPEG2DVDDecryption				*	decryption,
							  ByteOutputPort					*	codePort,
							  BitOutputPort					*	resetPort,
							  VideoStandard						videoStandard,
							  BOOL                           lpcmSpdifOut);

		virtual ~CCubeDVD1Decoder();

		void SetIsZiVAPC(BOOL isZiVAPC) {this->isZiVAPC = isZiVAPC;}
		void SetProfile(Profile * profile) {this->profile = profile;}

		Error	ReInitialize(void);

#if WDM_VERSION
		void	SetVirtualUnitDefaultParameters(VirtualCCubeDVD1Decoder * unit);
#endif

#if 0
		Error SetMemoryROMModes(DWORD romSize, DWORD accessTime, BOOL bus16bits);
		Error SetMemorySRAMModes(DWORD sramSize, DWORD accessTime, BOOL bus16bits);
		Error SetMemoryDRAMModes(DWORD dramSize);
		Error SetMicrocodeParams(DWORD memType, DWORD overlayCacheBase, DWORD overlayCacheSize);
#endif
		
		Error SetVideoOutputModes(DWORD mode);

		virtual Error Initialize(void);
		
		Error LoadMicrocode(KernelString name);
	};
	
class VirtualCCubeDVD1Decoder : public VirtualMPEG2AVDecoder
	{
	friend class CCubeDVD1Decoder;
	private:
		CCubeDVD1Decoder	*	decoder;

		BOOL						dvdDemux;
		BOOL						streamEncrypted;
		SPDIFHandling			spdifHandling;
		ForcedAspectRatio		forcedSourceAR;
#if WDM_VERSION
		BOOL						wdmPlayback;
		DWORD						buttonStartTime;
		DWORD						buttonEndTime;
#endif
		BOOL						ccEnabled;
	protected:
		VirtualCloseCaptionVideoEncoder	*	ccenc;

      Error PreemptStopPrevious(VirtualUnit * previous);
      Error PreemptChange(VirtualUnit * previous);
      Error PreemptStartNew(VirtualUnit * previous);
		
		Error GetDisplaySize(WORD __far &width, WORD __far &height);
	public:
		VirtualCCubeDVD1Decoder(CCubeDVD1Decoder * decoder);
		
		Error Configure (TAG __far *tags);
		
		Error SetCCEncoder(VirtualCloseCaptionVideoEncoder	*	ccenc) {this->ccenc = ccenc; GNRAISE_OK;}
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\specific\i5505spdc.h ===
#ifndef I5505SPDC_H
#define I5505SPDC_H

#include "library\common\prelude.h"
#include "library\lowlevel\hardwrio.h"
#include "library\general\asncstrm.h"
#include "..\generic\mp2spudc.h"

#define NUM_5505SPU_CONTROL_BUFFER	16	// min 14 !

class STi5505SPUDecoder : public GenericSPUDecoder, public PTSCallback
	{
	protected:
		ByteIndexedInOutPort		*	port;
		ByteIndexedInOutPort		*	mpegPort;
		ASyncOutStream				*	strm;
		PTSCaller * ptsCaller;

		int downScaleFactor;

		enum SPUControlState {SCS_IDLE, SCS_FILLFIRST, SCS_FILLING, SCS_READY, SCS_PENDING, SCS_EXECUTING};

		struct SPUControlBuffer
			{
			DWORD		startPTS;
			DWORD		bufferStart, bufferEnd;
			SPUControlState	state;
			} controlBuffer[NUM_5505SPU_CONTROL_BUFFER];

		DWORD nextPTS;
		DWORD bufferWritePosition, bufferReadPosition, bufferBase, bufferSize, bufferEndPosition;
		BYTE upperByte;

		SPUButtonState buttonState;
		int buttonX, buttonY, buttonW, buttonH;
		DWORD selectedColor, activeColor;

		struct PalEntry
			{
			BYTE y, u, v;
			} palette[16];

		int	idleControlBuffer, fillingControlBuffer, pendingControlBuffer, executingControlBuffer;

		BOOL	delayedSwitchOff;
		BOOL	isPaused;
		BOOL	isEnabled;

	public:
		STi5505SPUDecoder (ByteIndexedInOutPort *port, ByteIndexedInOutPort *mpegPort,
		                   ASyncOutStream *strm, PTSCaller *ptsCaller,
		                   DWORD bufferBase,   // byte offset inside the SDRAM
		                   DWORD bufferSize);
		virtual ~STi5505SPUDecoder(void);

		virtual Error EnableSPU(BOOL enable);

		virtual Error SendCommand(MPEGCommand com, DWORD param, DWORD __far &tag);

		virtual DWORD SendData(HPTR data, DWORD size);
		virtual void CompleteData(void);
		virtual void FlushData(void);
		virtual DWORD LastTransferLocation(DWORD scale) {return 0;}

		virtual void PutPTS(DWORD pts);

		// Functions from PTSCallback.
		virtual Error PTSCallbackReached (DWORD currentPTS);
		virtual Error SequenceStartReached (void);

		virtual Error SetButtonState(SPUButtonState state);
		virtual Error SetButtonPosition(int x, int y, int w, int h);
		virtual Error SetButtonColors(DWORD selected, DWORD active);
		virtual Error SetPalette(int entry, int y, int u, int v);

		virtual Error Configure (TAG *tags);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\specific\i3520AR.h ===
// FILE:			library\hardware\mpeg3dec\specific\i3520ar.h
// AUTHOR:		Viona
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		05.12.95
//
// PURPOSE:		
//
// HISTORY:
#ifndef I3520AR_H
#define I3520AR_H

#include "..\..\..\common\prelude.h"

#define I3520AREG_CFG_MCF		0x00
#define I3520AREG_CFG_CCF		0x01
#define I3520AREG_VID_CTL		0x02

#define I3520AIDX_VID_CTL_ERU		7
#define I3520AIDX_VID_CTL_ERS		6
#define I3520AIDX_VID_CTL_CFB		5
#define I3520AIDX_VID_CTL_DEC		4
#define I3520AIDX_VID_CTL_ERP		3
#define I3520AIDX_VID_CTL_PRS		2
#define I3520AIDX_VID_CTL_SRS		1
#define I3520AIDX_VID_CTL_EDC		0


#define I3520AREG_VID_TIS		0x03  

#define I3520ATIS_EXE			0
#define I3520ATIS_RPT			1
#define I3520ATIS_FIS			2
#define I3520ATIS_OVW			3
#define I3520ATIS_SKP			4, 2
#define I3520ATIS_MP2			6

#define I3520AREG_VID_PFH		0x04
#define I3520AREG_VID_PFV		0x05
#define I3520AREG_VID_PPR1		0x06
#define I3520AREG_VID_PPR2		0x07

#define I3520AREG_CFG_MRF		0x08
#define I3520AREG_CFG_MWF		0x08
#define I3520AREG_CFG_BMS		0x09
#define I3520AREG_CFG_MRP		0x0A
#define I3520AREG_CFG_MWP		0x0B
#define I3520AREG_VID_DFP8		0x0C
#define I3520AREG_VID_DFP0		0x0D
#define I3520AREG_VID_RFP8		0x0E
#define I3520AREG_VID_RFP0		0x0F

#define I3520AREG_VID_FFP8		0x10
#define I3520AREG_VID_FFP0		0x11
#define I3520AREG_VID_BFP8		0x12
#define I3520AREG_VID_BFP0		0x13
#define I3520AREG_VID_VBG8		0x14		
#define I3520AREG_VID_VBG0		0x15
#define I3520AREG_VID_VBL8		0x16
#define I3520AREG_VID_VBL0		0x17

#define I3520AREG_VID_VBS8		0x18
#define I3520AREG_VID_VBS0		0x19
#define I3520AREG_VID_VBT8		0x1A
#define I3520AREG_VID_VBT0		0x1B
#define I3520AREG_AUD_ABG8		0x1C
#define I3520AREG_AUD_ABG0		0x1D
#define I3520AREG_AUD_ABL8		0x1E
#define I3520AREG_AUD_ABL0		0x1F

#define I3520AREG_AUD_ABS8		0x20
#define I3520AREG_AUD_ABS0		0x21
#define I3520AREG_AUD_ABT8		0x22
#define I3520AREG_AUD_ABT0		0x23
#define I3520AREG_VID_DFS		0x24
#define I3520AREG_VID_DFW		0x25
#define I3520AREG_VID_DFA		0x26
#define I3520AREG_VID_XFS		0x27

#define I3520AREG_VID_XFW		0x28
#define I3520AREG_VID_XFA		0x29
#define I3520AREG_VID_OTP		0x2A
#define I3520AREG_VID_OBP		0x2B
#define I3520AREG_VID_PAN8		0x2C
#define I3520AREG_VID_PAN0		0x2D
#define I3520AREG_VID_SCN8		0x2E
#define I3520AREG_VID_SCN0		0x2F

#define I3520AREG_CKG_PLL		0x30
#define I3520AREG_CKG_CFG		0x31
#define I3520AREG_CKG_AUD		0x32
#define I3520AREG_CKG_VID		0x33
#define I3520AREG_CKG_PIX		0x34
#define I3520AREG_CKG_PCM		0x35
#define I3520AREG_CKG_MCK		0x36
#define I3520AREG_CKG_AUX		0x37

#define I3520AREG_CFG_DRC		0x38
#define I3520AREG_CFG_BFS		0x39
#define I3520AREG_CFG_GCF		0x3A
#define I3520AREG_VID_STA16	0x3B
#define I3520AREG_VID_ITM16	0x3C
#define I3520AREG_VID_ITS16	0x3D

#define I3520AREG_PES_CF1		0x40
#define I3520AREG_PES_CF2		0x41
#define I3520AREG_PES_SPF		0x42
#define I3520AREG_PES_STA		0x43
#define I3520AREG_PES_SC1		0x44
#define I3520AREG_PES_SC2		0x45
#define I3520AREG_PES_SC3		0x46
#define I3520AREG_PES_SC4		0x47

#define I3520AREG_PES_SC5		0x48
#define I3520AREG_PES_TS1		0x49
#define I3520AREG_PES_TS2		0x4A
#define I3520AREG_PES_TS3		0x4B
#define I3520AREG_PES_TS4		0x4C
#define I3520AREG_PES_TS5		0x4D

#define I3520ASTA_SCH			MKFLAG(0)	//	StartCodeHit
#define I3520ASTA_BFF			MKFLAG(1)	// 
#define I3520ASTA_HFE			MKFLAG(2)	// HeaderFifoEmpty
#define I3520ASTA_BBF			MKFLAG(3)	// BitBufferFull
#define I3520ASTA_BBE			MKFLAG(4)	// BitBufferEmpty
#define I3520ASTA_VSB			MKFLAG(5)	// VSYNCBottom
#define I3520ASTA_VST			MKFLAG(6)	// VSYNCTop
#define I3520ASTA_PSD			MKFLAG(7)	// PipelineStartingToDecode
#define I3520ASTA_PER			MKFLAG(8)	// PipelineError
#define I3520ASTA_PID			MKFLAG(9)	// PipelineIdle
#define I3520ASTA_WFE			MKFLAG(10)	// WriteFIFOEmpty
#define I3520ASTA_RFF			MKFLAG(11)	// ReadFIFOFull
#define I3520ASTA_HFF			MKFLAG(12)	// HeaderFIFOFull
#define I3520ASTA_BMI			MKFLAG(13)	// BlockMoveIdle
#define I3520ASTA_SER			MKFLAG(14)	// SevererErrorOrOverflowError
#define I3520ASTA_PDE			MKFLAG(15)	// PictureDecodingErrorOrUnderflowError
#define I3520ASTA_ABE			MKFLAG(16)	// AudioBitBufferEmpty
#define I3520ASTA_WFN			MKFLAG(17)	// WriteFIFONotFull
#define I3520ASTA_RFN			MKFLAG(18)	// ReadFIFONotEmpty
#define I3520ASTA_ABF			MKFLAG(19)	// AudioBitBufferFull
#define I3520ASTA_HAF			MKFLAG(20)	// HistoryFIFOAlmostFull
#define I3520ASTA_SCR			MKFLAG(21)	// NewSCRLatched
#define I3520ASTA_ERR			MKFLAG(22)	// InconsistencyErrorInPESParser
#define I3520ASTA_NDP			MKFLAG(23)	// NewDiscardedPacket

#define I3520AREG_VID_ITM8		0x60
#define I3520AREG_VID_ITM0		0x61
#define I3520AREG_VID_ITS8		0x62
#define I3520AREG_VID_ITS0		0x63
#define I3520AREG_VID_STA8		0x64
#define I3520AREG_VID_STA0		0x65
#define I3520AREG_VID_HDF		0x66
#define I3520AREG_VID_CDCNT	0x67
#define I3520AREG_VID_SCDCNT	0x68 
#define I3520AREG_VID_HDS		0x69
#define I3520AREG_VID_LSO		0x6A
#define I3520AREG_VID_LSR0		0x6B
#define I3520AREG_VID_CSO		0x6C
#define I3520AREG_VID_LSR8		0x6D
#define I3520AREG_VID_YDO		0x6E
#define I3520AREG_VID_YDS		0x6F
#define I3520AREG_VID_XDO8		0x70
#define I3520AREG_VID_XDO0		0x71
#define I3520AREG_VID_XDS8		0x72
#define I3520AREG_VID_XDS0		0x73
#define I3520AREG_VID_DCF8		0x74
#define I3520AREG_VID_DCF0		0x75    

#define I3520AREG_VID_DCF_OAD	14, 2
#define I3520AREG_VID_DCF_OAM	13
#define I3520AREG_VID_DCF_FRZ	12
#define I3520AREG_VID_DCF_DAM	9, 3
#define I3520AREG_VID_DCF_FLD	8
#define I3520AREG_VID_DCF_USR	7
#define I3520AREG_VID_DCF_PXD	6
#define I3520AREG_VID_DCF_EVD	5
#define I3520AREG_VID_DCF_EOS	4
#define I3520AREG_VID_DCF_DSE	3
#define I3520AREG_VID_DCF_VCF	0, 3

#define I3520AREG_VID_QMW		0x76

#define I3520AREG_AUD_ANC0		0x86
#define I3520AREG_AUD_ANC8		0x87

#define I3520AREG_AUD_ANC16	0x88
#define I3520AREG_AUD_ANC24	0x89
#define I3520AREG_AUD_ESC0		0x8A
#define I3520AREG_AUD_ESC8		0x8B
#define I3520AREG_AUD_ESC16	0x8C
#define I3520AREG_AUD_ESC24	0x8D
#define I3520AREG_AUD_ESC32	0x8E
#define I3520AREG_AUD_ESCX0	0x8F

#define I3520AREG_STC_INC		0x90
#define I3520AREG_AUD_LRP		0x91
#define I3520AREG_AUD_FFL0		0x94
#define I3520AREG_AUD_FFL8		0x95
#define I3520AREG_AUD_P18		0x96

#define I3520AREG_AUD_CDI0		0x98
#define I3520AREG_AUD_FOR		0x99
#define I3520AREG_AUD_ITR0		0x9A
#define I3520AREG_AUD_ITR8		0x9B
#define I3520AREG_AUD_ITM0		0x9C
#define I3520AREG_AUD_ITM8		0x9D
#define I3520AREG_AUD_LCA		0x9E
#define I3520AREG_AUD_EXT		0x9F

#define I3520AREG_AUD_RCA		0xA0
#define I3520AREG_STC_CTL		0xA1
#define I3520AREG_AUD_SID		0xA2
#define I3520AREG_AUD_SYN		0xA3
#define I3520AREG_AUD_IDE		0xA4
#define I3520AREG_AUD_SCM		0xA5
#define I3520AREG_AUD_SYS		0xA6
#define I3520AREG_AUD_SYE		0xA7

#define I3520AREG_AUD_LCK		0xA8
#define I3520AREG_AUD_CRC		0xAA
#define I3520AREG_AUD_SEM		0xAC
#define I3520AREG_AUD_PLY		0xAE

#define I3520AREG_AUD_MUT		0xB0
#define I3520AREG_AUD_SKP		0xB2
#define I3520AREG_AUD_ISS		0xB6

#define I3520AREG_AUD_ORD		0xB8
#define I3520AREG_AUD_LAT		0xBC

#define I3520AREG_AUD_RES		0xC0
#define I3520AREG_AUD_RST		0xC2
#define I3520AREG_AUD_SFR		0xC4
#define I3520AREG_AUD_DEM		0xC6

#define I3520AREG_STC_DIV0		0xC8
#define I3520AREG_STC_DIV8		0xC9
#define I3520AREG_STC0			0xCA
#define I3520AREG_STC8			0xCB
#define I3520AREG_STC16			0xCC
#define I3520AREG_STC24			0xCD
#define I3520AREG_STC32			0xCE

#define I3520AREG_AUD_IFT		0xD2
#define I3520AREG_AUD_SCP		0xD3

#define I3520AREG_AUD_ITS		0xDB
#define I3520AREG_AUD_IMS		0xDC
#define I3520AREG_AUD_HDR0		0xDE
#define I3520AREG_AUD_HDR8		0xDF

#define I3520AREG_AUD_HDR16	0xE0
#define I3520AREG_AUD_HDR24	0xE1
#define I3520AREG_AUD_PTS0		0xE2
#define I3520AREG_AUD_PTS8		0xE3
#define I3520AREG_AUD_PTS16	0xE4
#define I3520AREG_AUD_PTS24	0xE5
#define I3520AREG_AUD_PTS32	0xE6

#define I3520AREG_BAL_LIMx		0xE9
#define I3520AREG_BAL_LIMy		0xEB
#define I3520AREG_AUD_ADA		0xEC
#define I3520AREG_AUD_REV		0xED
#define I3520AREG_AUD_DIV		0xEE
#define I3520AREG_AUD_DIF		0xEF

#define I3520AREG_AUD_BBE		0xF0

#define I3520AREG_VID_REV		0xF8

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\specific\ccdvd1rg.h ===
#ifndef CCCCD1RG_H
#define CCCCD1RG_H

#include "library\common\prelude.h"

#define	CCD1HREG_DATA0				0x00
#define	CCD1HREG_DATA1				0x01
#define	CCD1HREG_DATA2				0x02
#define	CCD1HREG_DATA3				0x03
#define	CCD1HREG_ADDR0				0x04
#define	CCD1HREG_ADDR1				0x05
#define	CCD1HREG_ADDR2				0x06
#define	CCD1HREG_CONTROL			0x07

#define 	CCD1BASE						0x800000
#define	CCD1BREG_HOST_CONTROL	(0x00 | CCD1BASE)
#define	CCD1BREG_CF_READ			(0x2d | CCD1BASE)
#define	CCD1BREG_CF_INTRPT		(0x1c | CCD1BASE)
#define	CCD1BREG_CF_COMMAND		(0x1f | CCD1BASE)
#define	CCD1BREG_CPU_IMDT			(0x34 | CCD1BASE)
#define	CCD1BREG_CPU_IMADR		(0x36 | CCD1BASE)
#define	CCD1BREG_CPU_INDEX		(0x3a | CCD1BASE)
#define	CCD1BREG_CPU_IDXDT		(0x3b | CCD1BASE)
#define	CCD1BREG_DMA_ADR			(0x22 | CCD1BASE)
#define	CCD1BIDX_DMA_MODE			0x0f
#define	CCD1BREG_DMA_DATA			(0x23 | CCD1BASE)
#define	CCD1BIDX_DMA_CYCLE		0x11
#define	CCD1BIDX_CPU_PC			0x09
#define	CCD1BIDX_CPU_DIR			0x0a

#define	CCD1BIDX_HC_LOCAL_STATE	22, 2
#define	CCD1BMSK_HC_LOCAL_STATE	MKBF(CCD1BIDX_HC_LOCAL_STATE, 3)
#define	CCD1BVAL_HC_RUN			0
#define	CCD1BVAL_HC_RESET			3

#define	CCD1BIDX_HC_SHUTDOWN		12
#define	CCD1BIDX_HC_DINTEN		7
#define	CCD1BIDX_HC_DINT			6                         
#define	CCD1BIDX_HC_HINTEN		1
#define	CCD1BIDX_HC_HINT			0

#define	CCD1CMD_ABORT				0x8120
#define	CCD1CMD_DIGEST				0x0621
#define	CCD1CMD_FADE				0x0223
#define	CCD1CMD_FLUSHBUFFER		0x0124
#define	CCD1CMD_FREEZE				0x0125
#define	CCD1CMD_HIGHLIGHT			0x0226
#define  CCD1CMD_HIGHLIGHT2		0x0427
#define	CCD1CMD_NEWPLAYMODE		0x0028
#define	CCD1CMD_PAUSE				0x012a
#define	CCD1CMD_PLAY				0x042b
#define	CCD1CMD_RESET				0x802d
#define	CCD1CMD_RESUME				0x012e
#define	CCD1CMD_SCAN				0x032f
#define	CCD1CMD_SCREENLOAD		0x0330
#define	CCD1CMD_SELECTSTREAM		0x0231
#define	CCD1CMD_SETFILL			0x0532
#define	CCD1CMD_SETSTREAMS		0x0233
#define	CCD1CMD_SINGLESTEP		0x0134
#define	CCD1CMD_SLOWMOTION		0x0235
#define	CCD1CMD_TRANSFERKEY		0x0137

#define	CCD1IRQ_IDX_INIT			23
#define	CCD1IRQ_IDX_AUD			22
#define	CCD1IRQ_IDX_RDYD			20
#define	CCD1IRQ_IDX_HLI			19
#define	CCD1IRQ_IDX_NV				18
#define	CCD1IRQ_IDX_SEQE			17
#define	CCD1IRQ_IDX_BUFF			16
#define	CCD1IRQ_IDX_AEE			15
#define	CCD1IRQ_IDX_ENDD			14
#define	CCD1IRQ_IDX_ENDP			13
#define	CCD1IRQ_IDX_USR			12
#define	CCD1IRQ_IDX_SCN			11
#define	CCD1IRQ_IDX_RDYS			10
#define	CCD1IRQ_IDX_ENDC			9
#define	CCD1IRQ_IDX_UND			8
#define	CCD1IRQ_IDX_AOR			7
#define	CCD1IRQ_IDX_VSYNC			6
#define	CCD1IRQ_IDX_PICD			5
#define	CCD1IRQ_IDX_ENDV			4
#define	CCD1IRQ_IDX_SEQV			3
#define	CCD1IRQ_IDX_GOPV			2
#define	CCD1IRQ_IDX_PICV			1
#define	CCD1IRQ_IDX_ERR			0

#define	CCD1REG_COMMAND				0x40
#define	CCD1REG_PARAM(x)				(0x40 + (4 * x))
#define	CCD1REG_STATUS					0x5c

#define	CCD1REG_ROM_INFO				0x60
//#define	CCD1REG_SRAM_INFO				0x64
#define	CCD1REG_DRAM_INFO				0x68
#define	CCD1REG_UCODE_MEMORY			0x6c

//#define	CCD1REG_UCODE_START			0x70 
//#define	CCD1REG_UCODE_END				0x74 

#define	CCD1REG_VIDEO_MODE			0x7c

#define	CCD1VMOD_CSYNC_ON_HSYNC		7
#define	CCD1VMOD_CSYNC_ENABLED     6
#define	CCD1VMOD_VCLK_MASTER			2
#define	CCD1VMOD_SYNC_MASTER			1
#define	CCD1VMOD_CCIR656OUTPUT		0

#define	CCD1REG_ASPECT_RATIO_DEV	0x80
#define	CCD1REG_ASPECT_RATIO_MOD	0x84
#define	CCD1REG_PAN_SCAN_SOURCE		0x88
#define	CCD1REG_PAN_SCAN_HORIZ		0x8c
//#define	CCD1REG_PAN_SCAN_VERT		0x90
#define	CCD1REG_TOP_BORDER			0x94
#define	CCD1REG_BORDER_COLOR			0x98
#define	CCD1REG_FADE_COLOR			0x9c
//#define	CCD1REG_BACKGROUND_COLOR	0x9c
#define	CCD1REG_OSD_EVEN_FIELD		0xa0
#define	CCD1REG_OSD_ODD_FIELD		0xa4
#define	CCD1REG_STILL_MODE			0xa8
//#define	CCD1REG_STILL_DEF_HSIZE		0xac

// New definition for ZiVA-PC or higher ZiVA-DS silicon
#define	CCD1REG_HOST_OPTIONS			0xac

//#define	CCD1REG_STILL_DEF_VSIZE		0xb0
#define	CCD1REG_IC_TYPE				0xb0
#define	CCD1REG_ERROR_LEVEL			0xb4
#define	CCD1REG_HORIZONTAL_SIZE		0xb8
#define	CCD1REG_VERTICAL_SIZE		0xbc
#define	CCD1REG_ASPECT_RATIO_INFO	0xc0
#define	CCD1REG_FRAME_RATE_CODE		0xc4
#define	CCD1REG_FORCE_CODED_ASPECT_RATIO	0xc8
#define	CCD1REG_HLI_VERTICAL_OFFSET	0xcc

#define	CCD1REG_CLOCK_SELECTION		0xd0

#define	CCD1REG_AUDIO_CONFIG			0xe0
//#define	CCD1REG_NUM_OF_AU_CH			0xe4
#define	CCD1REG_AU_DAC_MODE			0xe8
#define	CCD1REG_AU_CLK_SEL			0xec
#define	CCD1REG_IEC958_DELAY			0xf0
#define	CCD1REG_AUDIO_ATTEN			0xf4
#define	CCD1REG_IEC_958_CHANNEL_STATUS_BITS	0xfc
#define	CCD1REG_AC3_OUT_MODE			0x110
#define	CCD1REG_AC3_OP_MODE			0x114
#define	CCD1REG_AC3_LOW_BOOST		0x118
#define	CCD1REG_AC3_HIGH_CUT			0x11c
#define	CCD1REG_AC3_PCM_SC_FA		0x120
#define	CCD1REG_AC3_LFE_OUT_EN		0x124
#define	CCD1REG_AC3_VOICE_SEL		0x128
#define	CCD1REG_AC3_L_LEVEL			0x12c
#define	CCD1REG_AC3_C_LEVEL			0x130
#define	CCD1REG_AC3_R_LEVEL			0x134
#define	CCD1REG_AC3_SL_LEVEL			0x138
#define	CCD1REG_AC3_SR_LEVEL			0x13c
#define	CCD1REG_AC3_CENTER_DELAY	0x144
#define	CCD1REG_AC3_SURROUND_DELAY	0x148
#define	CCD1REG_BIT_STRM_TYPE		0x1a0
#define	CCD1REG_BIT_STRM_SRC			0x1a4
#define	CCD1REG_SD_MODE				0x1a8
#define	CCD1REG_CD_MODE				0x1ac
#define	CCD1REG_AV_SYNC_MODE			0x1b0
#define	CCD1REG_VID_PTS_SKIP_T		0x1b8
#define	CCD1REG_VID_PTS_REP_T		0x1bc
#define	CCD1REG_AUTO_PAUSE_EN		0x1d4

#define	CCD1REG_VIDEO_ENV_CHANGE	0x1e0
#define	CCD1REG_MEMCOPY_XFER_BLOCKSIZE	0x1e4
#define	CCD1REG_IDLE_DELAY			0x1f0
#define	CCD1REG_VERTICAL_DISPLAYMODE	0x1f4
#define	CCD1REG_CDDA_OUTPUT_GUARDBAND	0x1f8
#define	CCD1REG_VIDEO_BUFFER_GUARDBAND	0x1fc
#define	CCD1REG_INT_MASK				0x200
#define  CCD1REG_AUTO_FLUSH_INTERVAL	0x204
#define	CCD1REG_RDYS_THR_LOW			0x208           


//#define	CCD1REG_NEXT_SEC_ADDR		0x20c

//#define	CCD1REG_CFIFO_LEVEL			0x214		// not in documentation

#define	CCD1REG_MEMORY_MAP			0x21c
#define	CCD1REG_PCI_BUF_START		0x220
#define	CCD1REG_PCI_BUF_END			0x224
#define	CCD1REG_DSI_BUF_START		0x228
#define	CCD1REG_DSI_BUF_END			0x22c
#define	CCD1REG_VID_RBUF_START		0x230
#define	CCD1REG_VID_RBUF_END			0x234
//#define	CCD1REG_SUBPIC_BUF_START	0x238
//#define	CCD1REG_SUBPIC_BUF_END		0x23c
#define	CCD1REG_OSD_BUF_START		0x240
#define	CCD1REG_OSD_BUF_END			0x244
//#define	CCD1REG_BPIC_BUF_START		0x248
//#define	CCD1REG_BPIC_BUF_END			0x24c
#define	CCD1REG_OSD_BUF_IDLE_START		0x248
#define	CCD1REG_OSD_BUF_IDLE_END		0x24c
//#define	CCD1REG_REF1_BUF_START		0x250
//#define	CCD1REG_REF1_BUF_END			0x254
//#define	CCD1REG_REF2_BUF_START		0x258
//#define	CCD1REG_REF2_BUF_END			0x25c
#define	CCD1REG_DISABLE_OSD				0x250
#define	CCD1REG_HSYNC_DELAY				0x254
#define	CCD1REG_STORABLE_BUFFERS_START	0x258
#define	CCD1REG_STORABLE_COORDS_START		0x25c
#define	CCD1REG_AU_IN_BUF_START		0x260
#define	CCD1REG_AU_IN_BUF_END		0x264
//#define	CCD1REG_AU_OUT_BUF_START	0x268
//#define	CCD1REG_AU_OUT_BUF_END		0x26c
#define	CCD1REG_UDATA_BUF_START		0x270
#define	CCD1REG_UDATA_BUF_END		0x274
#define	CCD1REG_UDATA_BUF_READ		0x278
#define	CCD1REG_UDATA_BUF_WRITE		0x27c
#define	CCD1REG_DDATA_BUF_START		0x280
#define	CCD1REG_DDATA_BUF_END		0x284
#define	CCD1REG_SUB_PIC_PAL_START	0x288
#define	CCD1REG_SUB_PIC_PAL_END		0x28c

#define	CCD1REG_PROC_STATE			0x2a0
#define	CCD1STATE_INITIALIZING		1
#define	CCD1STATE_IDLE					2
#define	CCD1STATE_SLOWMOTION			3
#define	CCD1STATE_PLAY					4
#define	CCD1STATE_SCAN					5
#define	CCD1STATE_PAUSE				6
#define	CCD1STATE_FREEZE				7

#define	CCD1REG_MRC_ID					0x2a4
#define	CCD1REG_MRC_STATUS			0x2a8
#define	CCD1MRCSTAT_INITIALIZING	0
#define	CCD1MRCSTAT_COPIED			1
#define	CCD1MRCSTAT_PROCESSED		2
#define	CCD1MRCSTAT_STEADY			3
#define	CCD1MRCSTAT_COMPLETE			4
#define	CCD1MRCSTAT_INCORRECT		5

#define	CCD1REG_INT_STATUS			0x2ac
#define	CCD1REG_HLI_INT_SRC			0x2b0

#define	CCD1REG_BUFF_INT_SRC			0x2b4
#define	CCD1REG_UND_INT_SRC			0x2b8

#define	CCD1BUFFSTAT_SUBPICTURE		2
#define	CCD1BUFFSTAT_AUDIO			1
#define	CCD1BUFFSTAT_VIDEO			0

#define	CCD1REG_AOR_INT_SRC			0x2bc
#define	CCD1REG_AEE_INT_SRC			0x2c0
#define	CCD1REG_ERR_INT_SRC			0x2c4
#define	CCD1ERRSRC_HLI					4
#define	CCD1ERRSRC_VIDEO				3
#define	CCD1ERRSRC_AUDIO				2
#define	CCD1ERRSRC_SYSTEM				1
#define	CCD1ERRSRC_UNUSED				0

#define	CCD1REG_VIDEMPTINESS			0x2c8
#define	CCD1REG_AUDEMPTINESS			0x2cc
#define	CCD1REG_CURR_PIC_DSPLY		0x2d0
#define	CCD1REG_NEXT_PIC_DSPLY		0x2d4
#define	CCD1REG_VIDEO_FIELD			0x2d8

//#define	CCD1REG_DISPLAY_MODE			0x2dc
#define	CCD1DISPMODE_LACED			3
#define	CCD1DISPMODE_FIELD1			2
#define	CCD1DISPMODE_FIELD0			1
#define	CCD1DISPMODE_DISABLED		0

#define	CCD1REG_OSDVALID				0x2e0
#define	CCD1REG_NPICS_DECODED		0x2e4
#define	CCD1REG_NPICS_SKIPPED		0x2e8
#define	CCD1REG_NPICS_REPEAT			0x2ec
#define	CCD1REG_MOST_R_PIC_PTS		0x2f0
#define	CCD1REG_MOST_R_PIC_STC		0x2f4
#define	CCD1REG_N_AUD_DECODED		0x2f8
#define	CCD1REG_MOST_R_AUD_STC		0x310
#define	CCD1REG_NEXT_SEC_ADDR		0x314
#define	CCD1REG_SYS_ERR_COUNT		0x318
#define	CCD1REG_VID_ERR_COUNT		0x31c
#define	CCD1REG_AUD_ERR_COUNT		0x320
#define	CCD1REG_DATE_TIME				0x324
#define	CCD1REG_DATE_TIME				0x324
#define	CCD1REG_VERSION				0x330
#define	CCD1REG_BUILD_NUMBER			0x334
#define	CCD1REG_EXTENDED_VERSION	0x334

#define	CCD1OFF_PIC_START				0x00
#define	CCD1OFF_PIC_REPEAT_CTS		0x04
#define	CCD1OFF_PIC_PAN_SCAN			0x08
#define	CCD1OFF_PIC_USER_DATA		0x0c
#define	CCD1OFF_PIC_CLOSE_CAP		0x10
#define	CCD1OFF_PIC_EXT_DATA			0x14
#define	CCD1OFF_PIC_RES_TREF_P		0x18
#define	CCD1OFF_PIC_PTS				0x1c

#define	CCD1REG_PIC1					0x340
#define	CCD1REG_PIC2					0x360
#define	CCD1REG_PIC3					0x380

#define	CCD1REG_PES_STREAM_ID		0x3a0
#define	CCD1REG_PES_PACKET_LEN		0x3a4
#define	CCD1REG_PES_HEADER			0x3a8

#define	CCD1REG_SUBPIC_EMPTINESS	0x3ac
 
#define	CCD1REG_SEQ_H_SIZE			0x3b0
#define	CCD1REG_SEQ_V_SIZE			0x3b4
#define	CCD1REG_SEQ_PA_RATIO			0x3b8
#define	CCD1REG_SEQ_PIC_RATE			0x3bc
#define	CCD1REG_SEQ_BIT_RATE			0x3c0
#define	CCD1REG_SEQ_VBV_BSIZE		0x3c4
#define	CCD1REG_SEQ_FLAGS				0x3c8

#define	CCD1REG_DISP_SIZE_H_V		0x3cc

#define	CCD1REG_GOP_TIME_CODE		0x3d0
#define	CCD1REG_GOP_FLAGS				0x3d4

#define	CCD1REG_PICHDR_TEMP_REF		0x3d8
#define	CCD1REG_PICHDR_TYPE			0x3dc
#define	CCD1REG_PICHDR_VBV_DELAY	0x3e0
#define	CCD1REG_PICHDR_FLAGS			0x3e4

//#define	CCD1REG_MPAUDIO_HDR1			0x3f0
#define	CCD1REG_AUDIO_TYPE			0x3f0
//#define	CCD1REG_MPAUDIO_HDR2			0x3f4
#define	CCD1REG_AC3_ENGINE_VERSION	0x3f4

#define	CCD1REG_AC3_FRAME_NO			0x400
#define	CCD1REG_AC3_BSI_IS_READ		0x404
#define	CCD1REG_AC3_BSI_VALID		0x408
#define	CCD1REG_AC3_BSI_FRAME		0x40c
#define	CCD1REG_AC3_FSCOD_FSC		0x410
#define	CCD1REG_AC3_BSID_BSMO		0x414
#define	CCD1REG_AC3_ACMOD_CMI		0x418
#define	CCD1REG_AC3_SURMIXLEV		0x41c
#define	CCD1REG_AC3_LFEON_DIAL		0x420
#define	CCD1REG_AC3_COMPR_LAN		0x424
#define	CCD1REG_AC3_MIXLEV			0x428
#define	CCD1REG_AC3_DIALNORM2		0x42c
#define	CCD1REG_AC3_LANGCOD2			0x430
#define	CCD1REG_AC3_ROOMTYP2			0x434
#define	CCD1REG_AC3_ORIGBS_T			0x438
#define	CCD1REG_AC3_TIMECODE2		0x43c

#define CCD1REG_NEW_AUDIO_MODE		0x460
#define CCD1REG_NEW_SUBPICTURE_PALETTE	0x464
#define CCD1REG_NEW_AUDIO_CONFIG		0x468
#define CCD1REG_ML_HEARTBEAT			0x470
#define CCD1REG_SUBPICTURE_ENABLE	0x474
#define CCD1REG_HIGHLIGHT_ENABLE		0x478

#define CCD1REG_KEY_ADDRESS			0x480
#define CCD1REG_SEC_LENGTH				0x484

#define CCD1ACMD_TERMINATE				0
#define CCD1ACMD_REQUEST_DRV_CHAL	1
#define CCD1ACMD_INFORM_DRV_RES		2
#define CCD1ACMD_INFORM_DEC_CHAL		3
#define CCD1ACMD_REQUEST_DEC_RES		4
#define CCD1ACMD_RECEIVE_ENCDK		5
#define CCD1ACMD_INFORM_ENCTK			6
#define CCD1ACMD_ENABLE_DESCRAMBLER	7
#define CCD1ACMD_BYPASS_DESCRAMBLER	8

#define CCD1KSTAT_NEW_CMD				0
#define CCD1KSTAT_COMPLETED			1
#define CCD1KSTAT_ERROR					2
#define CCD1KSTAT_ENCDK					3

#define CCD1REG_KEY_CMD					0
#define CCD1REG_KEY_STATUS				4
#define CCD1REG_DRV_CHAL				8
#define CCD1REG_DEC_CHAL				48
#define CCD1REG_DRV_RES					88
#define CCD1REG_DEC_RES					108
#define CCD1REG_ENCTK					128
              
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\specific\sti4600.h ===
// FILE:			library\hardware\mpeg3dec\specific\sti4600.h
// AUTHOR:		Viona
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		05.12.95
//
// PURPOSE:		
//
// HISTORY:
#ifndef STI4600_H
#define STI4600_H

#include "..\generic\mp2eldec.h"
#include "library\hardware\audio\generic\audiodac.h"
#include "library\lowlevel\hardwrio.h"
#include "library\general\asncstrm.h"  
#include "library\lowlevel\intrctrl.h"
#include "library\common\krnlstr.h"
#include "library\hardware\clocks\generic\clocks.h"

class STi4600AC3Decoder : public MPEG2AC3Decoder, 
                          protected ASyncRefillRequest,
                          protected InterruptHandler
	{
	friend class VirtualSTi4600AC3Decoder;
	protected:
		ByteIndexedInOutPort			*	port;
		VirtualAudioDAC				*	dac; 
		ASyncOutStream					*	strm;		
		ProgrammableClockGenerator * audioClock;
		
		DWORD 		initialPTS;
		DWORD			audioBitrate;
		DWORD			sampleRate;
		BOOL			ptsValid;                                                   
		MPEGState	state;
		BOOL			ac3, lpcm;
		BYTE			ac3StreamID;
		PTSAssoc		ptsAssoc;
		DWORD			streamPosition;
		WORD			muteDelay;
		WORD			playbackSpeed;

		DWORD			signalPosition;
		DWORD			predPosition;
				
		DWORD			stepCnt;
		
		BOOL			internalPCMClock;
		BOOL			starving, syncPlayDelay;		
		BOOL			needsPES;
		
		AC3SpeakerConfig speakerConfig;

		VirtualUnit	*	audioBus;
		
		BOOL	mute;
		WORD	lv, rv, lsv, rsv, swv, cv;
		Error SetVolume(void);

		Error SetAudioBitrate(DWORD bitrate);
		Error SetSampleRate(WORD rate);
		Error SetLeftVolume(WORD volume);
		Error SetRightVolume(WORD volume);
		Error SetMute(BOOL mute);
		Error SetAC3(BOOL ac3);
		Error SetLPCM(BOOL lpcm);

		Error SetBassConfig(AC3BassConfig config);
		Error SetSpeakerConfig(AC3SpeakerConfig config);
		Error SetCenterDelay(WORD delay);
		Error SetSurroundDelay(WORD delay);      
		
		Error SetCenterVolume(WORD volume);
		Error SetLeftSurroundVolume(WORD volume);
		Error SetRightSurroundVolume(WORD volume);
		Error SetSubwooferVolume(WORD volume);

	   Error SendCommand(MPEGCommand com, DWORD param, DWORD __far &tag);
		BOOL CommandPending(DWORD tag);

		DWORD CurrentLocation(void);
		MPEGState CurrentState(void);
		
		DWORD LastTransferLocation(DWORD scale);
			   
	   DWORD GetPTS();
	   DWORD SendData(HPTR data, DWORD size);
#if VIONA_VERSION
		MPEG2PESType NeedsPES(void) {return needsPES ? MP2PES_DVD : MP2PES_ELEMENTARY;}
		Error SendPESData(HPTR data, DWORD size, DWORD __far & done, DWORD __far & used);
#endif
	   void CompleteData(void);
	
	   void PutPTS(DWORD pts);
	   
		//
		// Forward the refill request
		//
		void RefillRequest(DWORD free);
		void Interrupt(void);

	   Error SetSignalPosition(DWORD position);

		Error SyncPlay(void);

		InterruptServer	*	vblank;	
	public:
		STi4600AC3Decoder(ByteIndexedInOutPort	*	port,
					         VirtualAudioDAC	 	*	dac,
					         ASyncOutStream			*	strm,
					         InterruptServer		*	vblank,
					         VirtualUnit				*	audioBus = NULL,
					         BOOL							internalPCMClock = NULL,
					         ProgrammableClockGenerator * audioClock = NULL);
		        
		VirtualUnit * CreateVirtual(void);
		
		Error LoadPatchFile(KernelString name);
		Error Initialize(void);
	};

class VirtualSTi4600AC3Decoder : public VirtualMPEG2AC3Decoder
	{
	private:
		STi4600AC3Decoder	*	device;
	protected:
      Error PreemptStopPrevious(VirtualUnit * previous);
      Error PreemptStartNew(VirtualUnit * previous);		
	public:
		VirtualSTi4600AC3Decoder(STi4600AC3Decoder * device);

#if VIONA_VERSION
		MPEG2PESType NeedsPES(void) {return (lpcm || dvdStreamEncrypted || (!ac3 && audioBitrate > 384000)) ? MP2PES_DVD : MP2PES_ELEMENTARY;}
#endif
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\specific\tl850mcu.h ===
/*
 * This file was generated automatically by mcuas.
 * Do not edit this file. Edit mcu.asm instead.
 */

unsigned short mcuasm_instructions[2560] = {
	0x5000,0x8740,0x4BC1,0xF401,0x190B,0xF2FF,0x1707,0x4741,0xF401,0x18FA,0x4BC1,0x24D4,0xFF00,0x2511,0xFF00,0x6011,
	0x8151,0x4B41,0x8BC0,0x8A31,0x8A00,0x8740,0xF2F1,0xF212,0xE482,0x9802,0x2581,0xE411,0x18FB,0xF2F1,0xECF1,0x1A0D,
	0x4A02,0xF402,0x1903,0x4012,0x8A02,0xF412,0x1930,0x4021,0x4032,0x8A11,0x2059,0x8A22,0x4001,0x4012,0xE811,0x4B33,
	0xE822,0xF733,0xF813,0xF813,0xF813,0xF813,0xE023,0xED11,0x4745,0xED22,0xEF35,0x1806,0x1203,0x2511,0x6004,0x251A,
	0x6014,0x87B1,0x87A2,0x8743,0x8791,0x8782,0x8753,0x6014,0x8A04,0x4021,0x4034,0x8A11,0x8A24,0x8800,0x8810,0x8820,
	0x8830,0x8840,0x8850,0x8860,0x202F,0x8870,0x4B02,0xF524,0xE434,0xF622,0xE432,0x6021,0xF432,0x180B,0x6011,0x4A2A,
	0xF6AA,0xEDAA,0xEDAA,0x6005,0x9812,0x60F5,0xE55A,0x8A2A,0xF434,0x190C,0x4A15,0xF656,0x9916,0x2511,0xFF00,0xF655,
	0xED55,0xED55,0xE551,0x2010,0x8A11,0x9914,0x2514,0xFF00,0x5045,0xE551,0x8A11,0x8800,0x8810,0x8820,0x8830,0x8840,
	0x8850,0x8860,0x8870,0x4A11,0x4B02,0x4A13,0xF511,0xF622,0xE432,0xF633,0xF23A,0x4B2B,0xE41A,0xF6BB,0xE9BC,0xE1AC,
	0x190C,0x4B0B,0xE43B,0xF42B,0x1919,0x4A0B,0xF41B,0x1205,0xEA3B,0xEABB,0xE5BA,0x1712,0x8800,0x8810,0x8820,0x8830,
	0x8840,0x8850,0x8860,0x8870,0x8900,0x8910,0x8920,0x8930,0x8940,0x8950,0x8960,0x2088,0x8970,0x6014,0x9832,0x6004,
	0x9921,0x6004,0xF235,0x4B29,0xE415,0xF699,0xE195,0x6016,0xF432,0x1805,0x9921,0x6026,0x2005,0xF237,0x9911,0x6026,
	0xF237,0xE447,0xF238,0x4A0D,0xE428,0xE8DD,0xF416,0x1829,0xF407,0x1813,0x484A,0x4B5B,0x40CC,0x600E,0xF9A9,0x485A,
	0x8949,0x990D,0x8849,0x4B6B,0x40DC,0xF24E,0xF9A9,0x8959,0x9804,0xEB99,0x990D,0x8859,0xF408,0x1813,0x486A,0x4B7B,
	0x40EC,0x600E,0xF9A9,0x487A,0x8969,0x990D,0x8869,0x4B8B,0x40FC,0xF24E,0xF9A9,0x8979,0x9804,0xEB99,0x990D,0x8879,
	0xE557,0xF407,0x1813,0x480A,0x4B5B,0x408C,0x600E,0xF9A9,0x481A,0x8909,0x990D,0x8809,0x4B6B,0x409C,0xF24E,0xF9A9,
	0x8919,0x9804,0xEB99,0x990D,0x8819,0xF408,0x1813,0x482A,0x4B7B,0x40AC,0x600E,0xF9A9,0x483A,0x8929,0x990D,0x8829,
	0x4B8B,0x40BC,0xF24E,0xF9A9,0x8939,0x9804,0xEB99,0x990D,0x8839,0xF431,0x1919,0x4B1C,0xF22B,0xF5CC,0x403D,0x490A,
	0xF6DD,0xE43D,0x600E,0xFAA9,0x8989,0x602E,0xFAA9,0x89C9,0x403D,0x491A,0xF6DD,0xEEDD,0xE43D,0x601E,0xFAA9,0x8999,
	0x603E,0xFAA9,0x89D9,0x600E,0x9911,0x602E,0x9931,0x606E,0xF40E,0x1903,0x9832,0x604E,0x9932,0x008E,0xF23C,0xE41C,
	0x990C,0x001E,0x47A4,0x47B5,0x4A2A,0xF23F,0x1406,0xF2FF,0x1B00,0xF2FF,0x2314,0x810E,0x6006,0xEC3F,0x1A04,0x4B0D,
	0xE43D,0x992D,0x6016,0x6007,0xF23F,0x1B02,0x6017,0x9931,0x6017,0xF403,0x1904,0x604A,0x9922,0x601A,0xF432,0x1908,
	0x9921,0x20F6,0xF2FF,0xF411,0x1868,0x2176,0xF2FF,0x9911,0x21ED,0xF2FF,0x9921,0x226D,0xF2FF,0xF2FF,0x1B00,0xF2FF,
	0x810E,0xF406,0x182B,0x4B9B,0x4908,0x4919,0xEA8C,0xEA9D,0xE04C,0x811C,0xE05D,0x812D,0xF5BD,0x9922,0xF6BD,0xF29E,
	0xE47E,0x9209,0x008E,0x050E,0xF0EC,0xF28E,0xE47E,0x9208,0x008E,0x030E,0xF0EE,0x813D,0xE0CE,0x814E,0xEA8B,0xE04B,
	0xEA9C,0xE05C,0x008C,0xF2FF,0x1B00,0xF2FF,0x811B,0x812C,0x813D,0xA6EC,0x9807,0xA2EC,0x814C,0x9907,0x22C0,0x4B9E,
	0x4988,0x4999,0xEA8C,0xEA9D,0xE04C,0xE05D,0xF6EB,0x9922,0xF5EB,0xF2FF,0x1B00,0xF2FF,0x811C,0x812D,0x813B,0xF29E,
	0xE47E,0x9209,0x008E,0x050E,0xF0EC,0xF28E,0xE47E,0x9208,0x008E,0x030E,0xF0EE,0x001C,0xE0CE,0x814E,0xEA8D,0xE04D,
	0xEA9C,0xE05C,0x008C,0x006E,0xF2FF,0x1B00,0xF2FF,0x811D,0x812C,0x813B,0x2294,0x814E,0xF2FF,0x1B00,0xF2FF,0x810E,
	0xF406,0x1840,0x4908,0x4919,0x4B9B,0xEA8C,0xEA9D,0xE04C,0x811C,0xEA5E,0xE0DE,0x812E,0xF5BD,0xF2AC,0x1402,0xF6BD,
	0xF29E,0xE47E,0x9209,0x008E,0x050E,0xF0E9,0xF28E,0xE47E,0x9208,0x008E,0x030E,0xF0E8,0x813D,0xE089,0x8149,0x4948,
	0x4959,0xEA8C,0xEA9D,0xE04C,0xEA5E,0xE0DE,0xF2FF,0x1B00,0xF2FF,0x811C,0x812E,0xF5BD,0xECAC,0x1B02,0xF6BD,0x813D,
	0xF29E,0xE47E,0x9209,0x008E,0x050E,0xF0E9,0xF28E,0xE47E,0x9208,0x008E,0x030E,0xF0E8,0xA69E,0x9807,0xA29E,0xE08E,
	0x814E,0x9907,0x224C,0x4928,0x4939,0x4BAB,0xEA8C,0xEA9D,0xE04C,0xEA5E,0xE0DE,0xF2FF,0x1B00,0xF2FF,0x811C,0x812E,
	0xF5BD,0xF2AC,0x1B02,0xF6BD,0x813D,0xF29E,0xE47E,0x9209,0x008E,0x050E,0xF0E9,0xF28E,0xE47E,0x9208,0x008E,0x030E,
	0xF0E8,0xA19E,0xE08E,0x814E,0x4968,0x4979,0xEA8C,0xEA9D,0xE04C,0xEA5E,0xE0DE,0xF2FF,0x1B00,0xF2FF,0x811C,0x812E,
	0xF5BD,0xF2AC,0xE48C,0x980C,0xF6BD,0x813D,0xF29E,0xE47E,0x9209,0x008E,0x050E,0xF0E9,0xF28E,0xE47E,0x9208,0x008E,
	0x030E,0xF0E8,0xA79E,0xE08E,0x220A,0x814E,0xF2FF,0x1B00,0xF2FF,0x810E,0xF406,0x183E,0x4C03,0x4908,0x4919,0xF53F,
	0x1803,0xEB88,0xEB99,0x4B9B,0xEA8C,0xEA9D,0xE04C,0x811C,0xF25E,0xE0DE,0xEAEE,0x812E,0xF5BD,0xF29E,0xE47E,0x9209,
	0x008E,0x040E,0xF0EC,0xF28E,0xE47E,0x9208,0x008E,0x020E,0xF0EE,0x813D,0xE0CE,0x814E,0xEA8D,0xE04D,0xEA9E,0xE05E,
	0xEAEE,0xF2FF,0x1B00,0xF2FF,0x811D,0x812E,0xF6BE,0x813E,0xF29E,0xE47E,0x9209,0x008E,0x060E,0xF0E9,0xF28E,0xE47E,
	0x9208,0x008E,0x020E,0xF0E8,0xA69E,0x9807,0xA29E,0xE08E,0x814E,0x9907,0x21C4,0x4928,0x4939,0xF63F,0x1803,0xEB88,
	0xEB99,0x4BAB,0xEA8C,0xEA9D,0xE04C,0xF25E,0xE0DE,0xEAEE,0xF2FF,0x1B00,0xF2FF,0x811C,0x812E,0xF5BE,0x813E,0xF29E,
	0xE47E,0x9209,0x008E,0x040E,0xF0EC,0xF28E,0xE47E,0x9208,0x008E,0x020E,0xF0EE,0x001C,0xE0CE,0x814E,0xEA8D,0xE04D,
	0xEA9E,0xE05E,0xEAEE,0xF2FF,0x1B00,0xF2FF,0x811D,0x812E,0xF6BE,0x813E,0xF29E,0xE47E,0x9209,0x008E,0x060E,0xF0E9,
	0xF28E,0xE47E,0x9208,0x008E,0x020E,0xF0E8,0xA79E,0xE08E,0x2186,0x814E,0xF2FF,0x1B00,0xF2FF,0x810E,0xF406,0x4B9B,
	0x1837,0x4908,0x4919,0xEA8C,0xEA9D,0xE04C,0x811C,0xEA5E,0xE0DE,0x812E,0xF5BD,0xF29E,0xE47E,0x9209,0x008E,0x050E,
	0xF0EC,0xF28E,0xE47E,0x9208,0x008E,0x030E,0xF0EE,0x813D,0xE0CE,0x814E,0xEA8C,0xE04C,0xEA9D,0xEA5E,0xE0DE,0xF6BD,
	0xF2FF,0x1B00,0xF2FF,0x811C,0x812E,0x813D,0xF29E,0xE47E,0x9209,0x008E,0x050E,0xF0E9,0xF28E,0xE47E,0x9208,0x008E,
	0x030E,0xF0E8,0xA69E,0x9807,0xA29E,0xE08E,0x814E,0x9907,0x2146,0x4988,0x4999,0xEA8C,0xEA9D,0xE04C,0xEA5E,0xE0DE,
	0xF6BD,0xF2FF,0x1B00,0xF2FF,0x811C,0x812E,0x813D,0xF29E,0xE47E,0x9209,0x008E,0x050E,0xF0E9,0xF28E,0xE47E,0x9208,
	0x008E,0x030E,0xF0E8,0xA19E,0xE08E,0x814E,0x49C8,0x49D9,0xEA8C,0xEA9D,0xE04C,0xEA5E,0xE0DE,0xF5BD,0xF2FF,0x1B00,
	0xF2FF,0x811C,0x812E,0x813D,0xF29E,0xE47E,0x9209,0x008E,0x050E,0xF0E9,0xF28E,0xE47E,0x9208,0x008E,0x030E,0xF0E8,
	0xA79E,0xE08E,0x210C,0x814E,0xF2FF,0x1B00,0xF2FF,0x810E,0xF406,0x183D,0x4908,0x4919,0x4B9B,0xEA8C,0xEA9D,0xE04C,
	0x811C,0xE05D,0x812D,0xF5BD,0xF2AC,0x1402,0xF6BD,0xF29E,0xE47E,0x9209,0x008E,0x050E,0xF0EC,0xF28E,0xE47E,0x9208,
	0x008E,0x030E,0xF0EE,0x813D,0xE0CE,0x814E,0xEA8D,0xE04D,0xEA9E,0xE05E,0x008E,0xF5BC,0xF2AA,0x1402,0xF6BC,0xF2FF,
	0x1B00,0xF2FF,0x811D,0x812E,0x813C,0xF29E,0xE47E,0x9209,0x008E,0x050E,0xF0E9,0xF28E,0xE47E,0x9208,0x008E,0x030E,
	0xF0E8,0xA69E,0x9807,0xA29E,0xE08E,0x814E,0x9907,0x20C7,0x4928,0x4939,0x4BAB,0xEA8C,0xEA9D,0xE04C,0xE05D,0xF5BE,
	0xF2AA,0x1B02,0xF6BE,0xF2FF,0x1B00,0xF2FF,0x811C,0x812D,0x813E,0xF29E,0xE47E,0x9209,0x008E,0x050E,0xF0EC,0xF28E,
	0xE47E,0x9208,0x008E,0x030E,0xF0EE,0x001C,0xE0CE,0x814E,0xEA8D,0xE04D,0xEA9E,0xE05E,0x008E,0xF5BC,0xF2AA,0x1B02,
	0xF6BC,0xF2FF,0x1B00,0xF2FF,0x811D,0x812E,0x813C,0xF29E,0xE47E,0x9209,0x008E,0x050E,0xF0E9,0xF28E,0xE47E,0x9208,
	0x008E,0x030E,0xF0E8,0xA79E,0xE08E,0x2089,0x814E,0xF2FF,0x1B00,0xF2FF,0x810E,0xF406,0x183F,0x4908,0x4919,0x4B9B,
	0xEA8C,0xEA9D,0xE04C,0x811C,0xE05D,0x812D,0xF5BD,0xF2AC,0x1402,0xF6BD,0xF29E,0xE47E,0x9209,0x008E,0x050E,0xF0E9,
	0xF28E,0xE47E,0x9208,0x008E,0x030E,0xF0E8,0x813D,0xE089,0x8149,0x4948,0x4959,0xEA8C,0xEA9D,0xE04C,0xE05D,0x008D,
	0xF2FF,0x1B00,0xF2FF,0x811C,0x812D,0xF5BD,0xECAC,0x1B02,0xF6BD,0x813D,0xF29E,0xE47E,0x9209,0x008E,0x050E,0xF0E9,
	0xF28E,0xE47E,0x9208,0x008E,0x030E,0xF0E8,0xA69E,0x9807,0xA29E,0xE08E,0x814E,0x9907,0x2042,0x4928,0x4939,0x4BAB,
	0xEA8C,0xEA9D,0xE04C,0xE05D,0xF5BE,0xF2AA,0x1B02,0xF6BE,0xF2FF,0x1B00,0xF2FF,0x811C,0x812D,0x813E,0xF29E,0xE47E,
	0x9209,0x008E,0x050E,0xF0E9,0xF28E,0xE47E,0x9208,0x008E,0x030E,0xF0E8,0xA19E,0xE08E,0x814E,0x4968,0x4979,0xEA8C,
	0xEA9D,0xE04C,0xE05D,0x008D,0xF2FF,0x1B00,0xF2FF,0x811C,0x812D,0xF5BD,0xF2AC,0xE48C,0x980C,0xF6BD,0x813D,0xF29E,
	0xE47E,0x9209,0x008E,0x050E,0xF0E9,0xF28E,0xE47E,0x9208,0x008E,0x030E,0xF0E8,0xA79E,0xE08E,0x814E,0x4BBE,0xF432,
	0x1914,0xEA5D,0xF5EC,0xF2FF,0x1B00,0xF2FF,0x8114,0x812D,0x813C,0x8140,0xF6EC,0xF2FF,0x1B00,0xF2FF,0x8114,0x812D,
	0x813C,0x602D,0x2014,0x814D,0xF5EC,0xF2FF,0x1B00,0xF2FF,0x8114,0x8125,0x813C,0x8140,0x0085,0xF6EC,0x602D,0xF2FF,
	0x1B00,0xF2FF,0x8114,0x8125,0x813C,0x814D,0xF2FB,0xE48B,0x1803,0x2112,0xFF00,0x4A0A,0x602B,0x912A,0x606B,0x815B,
	0x4A11,0xF611,0x1409,0x4B25,0xF655,0x1835,0x4804,0x4819,0x8844,0x2031,0x8859,0x4A06,0x9816,0x202D,0xFF00,0x4B07,
	0x4A18,0xF677,0xE437,0xF588,0xF437,0x1905,0xF418,0x1907,0x2022,0xFF00,0xF428,0x1903,0x201E,0xFF00,0xEC12,0x1B0C,
	0x4802,0x4819,0x8842,0x8859,0xF213,0x1B15,0x4822,0x4839,0x8862,0x2011,0x8879,0xF213,0x1B06,0x4822,0x4839,0x8862,
	0x200A,0x8879,0x8800,0x8810,0x8820,0x8830,0x8840,0x8850,0x8860,0x8870,0x4741,0xE8AA,0xE911,0x4B32,0x47A3,0x47B4,
	0xED22,0x0103,0x8A0A,0x8741,0xEF23,0x1307,0x87A3,0x87B4,0xF2F1,0x1C69,0x2B3E,0xF212,0x0104,0x87A0,0x87B4,0x4BE1,
	0xE431,0x1835,0xEEF2,0x1433,0x9831,0x216C,0xFF00,0x4741,0x4762,0x7012,0x132C,0x4C83,0xE833,0x1029,0x8C83,0x51C1,
	0xA712,0x4C94,0x8182,0xF043,0x5025,0x8193,0xE153,0xE944,0xF045,0xE944,0x81A5,0x8C94,0x6012,0x81B2,0x41C2,0xF402,
	0x18FF,0x41C2,0x81C0,0xF403,0x1810,0x8181,0xF043,0xE944,0x8193,0xF043,0xE944,0x81A3,0x8C94,0x6012,0x81B2,0x41C2,
	0xF402,0x18FF,0x41C2,0x81C0,0x6011,0x8BE1,0x4741,0x4A32,0x7021,0x2AE9,0xF2FF,0x1C27,0x2AFA,0xFF00,0x4BD1,0xE411,
	0x1903,0x2AF5,0xFF00,0x4C11,0xE611,0x8C11,0x6011,0x81D1,0x5021,0x0891,0x8181,0x6012,0x81B2,0x41C2,0xF402,0x18FF,
	0x41C2,0x81C0,0x4192,0x5013,0xE532,0x8192,0x81A0,0x6032,0x81B2,0x41C2,0xF402,0x18FF,0x41C2,0x81C0,0xFF00,0xFF00,
	0x2AC2,0xFF00,0x4BD1,0xE421,0x1903,0x2ABD,0xFF00,0x4C11,0xE621,0x8C11,0x6011,0x81D1,0x2081,0x8770,0x4BD1,0xE441,
	0x1903,0x2AF0,0xFF00,0x4C11,0xE641,0x8C11,0x6011,0x200C,0x81D1,0x4BD1,0xE481,0x1903,0x2AE5,0xFF00,0x4C11,0xE681,
	0x8C11,0x6011,0x81D1,0x5021,0x0891,0x8181,0x6012,0x81B2,0x41C2,0xF402,0x18FF,0x41C2,0x81C0,0x81A0,0x4192,0x5013,
	0xE532,0x8192,0x6032,0x81B2,0x41C2,0xF402,0x18FF,0x41C2,0x81C0,0x9904,0x2080,0xFF00,0x202F,0xFF00,0x4BD1,0x6102,
	0xE121,0x1903,0x2AED,0xFF00,0x4C11,0xE521,0x8C11,0x6011,0x200D,0x81D1,0x4BD1,0x6202,0xE121,0x1903,0x2AEA,0xFF00,
	0x4C11,0xE521,0x8C11,0x6011,0x81D1,0x4A11,0xF511,0x5042,0xE521,0x2AEA,0x8A11,0xF2F1,0x6402,0xE121,0x18FF,0xF2F1,
	0x4BD1,0x6402,0xE121,0x1903,0x2A5E,0xFF00,0x4C11,0xE521,0x8C11,0x6011,0x81D1,0x5022,0x0852,0x8182,0x81A0,0x6012,
	0x8192,0x81B2,0x41C2,0xF402,0x18FF,0x41C2,0x81C0,0x5013,0x0803,0xF2F2,0xE132,0x18FF,0xF2F2,0x5182,0x0062,0x8182,
	0x6032,0x81B2,0x41C2,0xF402,0x18FF,0x41C2,0x81C0,0x4742,0x8752,0x4192,0xF622,0x8772,0x1910,0x5182,0x0092,0x8182,
	0x5012,0x0802,0x8192,0x6012,0x81B2,0x41C2,0xF402,0x18FF,0x41C2,0x81C0,0x2020,0x4A33,0x5013,0x0B03,0x7223,0x2A23,
	0xFF00,0x5183,0x0093,0x8183,0x6403,0x8193,0x6013,0x81B3,0x41C3,0xF403,0x18FF,0x41C3,0x81C0,0xF2FF,0x1400,0xF2FF,
	0x4011,0x4B33,0xE822,0xE811,0xF733,0xF823,0xF823,0xF823,0xF823,0xE013,0x4754,0xE343,0x8A03,0x8744,0x4B01,0x6032,
	0xF611,0xE431,0x6023,0x7821,0x6013,0x5044,0xE534,0x8A14,0xF2FF,0x1B00,0xF2FF,0x6033,0x6092,0x7831,0x6032,0x8102,
	0x8110,0x8120,0x4B93,0xF533,0x8133,0x8140,0x8110,0x8120,0x4B93,0xF633,0x8133,0x6063,0x8143,0x47A4,0x8114,0x47B5,
	0x6036,0x7961,0xEC55,0x8125,0x4BB3,0xF533,0x8133,0x8140,0x8114,0x8125,0x4BB3,0xF633,0x8133,0x6023,0x8143,0x4A0A,
	0x602B,0x71BA,0x606B,0x815B,0x4742,0xE922,0x4A0A,0xE8AA,0x4B33,0xED33,0x47A4,0x0104,0x47B5,0xEF34,0x1103,0x6004,
	0x0105,0x8742,0x87A4,0x87B5,0x8A0A,0xF2FF,0x1400,0xF2FF,0x981A,0x2FBF,0xFF00,0x4771,0x9901,0x29C2,0xFF00,0x29DD,
	0xFF00,0x51C1,0x6042,0xE512,0x8182,0x6032,0x81B2,0x41C2,0xF402,0x18FF,0x41C2,0x81C0,0x4193,0x6FF4,0xEE33,0xE143,
	0x6062,0xE512,0x8182,0x6032,0x81B2,0x41C2,0xF402,0x18FF,0x41C2,0x81C0,0x4195,0xE145,0xEE55,0xE053,0x4C92,0xF025,
	0xE922,0xF024,0x61F6,0xE164,0xED44,0xEB44,0xEB44,0xEE55,0xEE55,0xEC55,0xF256,0xEC55,0xE554,0x4B07,0xF677,0x9937,
	0xEB44,0xE416,0x1904,0x6645,0x2007,0xFF00,0xE922,0xE922,0xF025,0x63F6,0xE165,0x9837,0xEC55,0xE054,0x00F4,0xEE44,
	0xE844,0x4B35,0xF755,0xF845,0xF845,0xF845,0xF845,0xE035,0xE855,0x8765,0x6031,0x2E7B,0x8BE1,
};
int mcu_instructions_len = 1693;

unsigned short mcuasm_data[512] = {
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0200,0x0100,0x0300,0x0000,0x0200,0x0100,0x0300,
	0x0000,0x0300,0x0100,0x0600,0x0000,0x0300,0x0100,0x0600,0x0000,0x0200,
	0x0100,0x0300,0x0000,0x0200,0x0100,0x0300,0x0000,0x0300,0x0100,0x0600,
	0x0000,0x0300,0x0100,0x0600,0x0000,0x0020,0x0090,0x00b0,0x0040,0x0060,
	0x00d0,0x00f0,0x0000,0x0030,0x0090,0x00e0,0x0040,0x0070,0x00d0,0x00e0,
	0x0000,0x0020,0x0010,0x0030,0x0000,0x0020,0x0010,0x0030,0x0000,0x0030,
	0x0010,0x0060,0x0000,0x0030,0x0010,0x0060,0x0000,0x0020,0x0010,0x0030,
	0x0000,0x0020,0x0010,0x0030,0x0000,0x0030,0x0010,0x0020,0x0000,0x0030,
	0x0010,0x0060,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\specific\STI3520A.H ===
#ifndef STI3520A_H
#define STI3520A_H

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"
#include "library\lowlevel\hardwrio.h"
#include "library\lowlevel\intrctrl.h"
#include "library\general\asncstrm.h"
#include "..\..\clocks\generic\clocks.h"
#include "..\..\audio\generic\audiodac.h"
#if VIONA_VERSION
#include "..\generic\mp2spudc.h"
#endif

#include "..\generic\mp2eldec.h"
#include "..\generic\mp2vsprs.h"

enum STi3520AClockSource
	{ 
	S35CS_POWERDOWN,
	S35CS_AUDCLK	= 3,
	S35CS_MEMCLK	= 4,
	S35CS_PCMCLK	= 5,
	S35CS_PIXCLK	= 6,
	S35CS_EXTCLK	= 7
	};                          
	
enum STi3520AClock
	{            
	S35CL_AUXCLK,
	S35CL_AUDCLK,
	S35CL_MEMCLK,
	S35CL_PCMCLK,
	S35CL_PIXCLK,
	S35CL_VIDCLK
	};

class FrameParameters
	{	
	public:
		BYTE				pfh, pfv, ppr1, ppr2;
		
		MPEG2FrameType				frameType;		
		MPEG2PictureStructure   fieldType;
		
		BOOL				repeatFirstField : 2;
		BOOL				topFieldFirst    : 2;
		BOOL				progressiveFrame : 2;
		BOOL				skipped          : 2;
		DWORD				temporalReference;
		DWORD				streamPosition;
		DWORD				pts;
		int				centerVerticalOffset;
		int				centerHorizontalOffset;
				
		Error Init(MPEG2VideoHeaderParser	* params, DWORD streamPosition, DWORD pts);
	};

class FrameParameterQueue
	{	
	private:
		FrameParameters	*	params;
		WORD	num, first, last;
	public:
		FrameParameterQueue(WORD size);
		virtual ~FrameParameterQueue(void);
		
		Error Reset(void);
		Error InsertFrame(MPEG2VideoHeaderParser * parser, DWORD streamPosition, DWORD pts);
		Error MarkSkipped(void);
		BOOL IsSkipped(void);
		Error GetFrame(FrameParameters __far &params);
		Error NextFrame(void);
		WORD FrameAvail() {return (first <= last) ? (last - first) : (num + last - first);}
	};

class STi3520AMPEG2VideoHeaderParser : public MPEG2VideoHeaderParser
	{
	private:
		ByteIndexedInputPort	*	port;
		BOOL							odd;         
		BOOL							even;
		BYTE							second;
		Error WaitForFIFONonEmpty(void);
	protected:
		Error BeginParse(void);
		Error NextByte(void);
		Error EndParse(void);

		Error ParsePictureHeader(void);	
	public:
		BOOL	skipHeader;
		
		STi3520AMPEG2VideoHeaderParser(ByteIndexedInputPort	*	port);
	};

class STi3520AMPEG2Decoder;
		
class STi3520AMPEG2Decoder : public MPEG2VideoDecoder, protected InterruptHandler, protected ASyncRefillRequest
#if VIONA_VERSION
                             ,public OSDDisplay
#endif                             
	{
	friend class STi3520AAudioStrm;
	friend class VirtualSTi3520AMPEG2Decoder;
	friend class STi3520AVBlankIntServer;
	friend class STi3520AMPEGAudioDecoder;
	friend class STi3520AAudioClockGenerator;

	protected:
		//
		// Basic IO operations
		//
		ByteIndexedInOutPort	*	port;
		
		Error OutByte(int idx, BYTE val);                             
		Error InByte(int idx, BYTE __far&val);

		//
		// to avoid double index programming
		//
		Error OutWordHL(int idx, WORD val);
		Error OutWordLH(int idx, WORD val);
		Error OutWordHL0(int idx, WORD val);
		Error InWordHL(int idx, WORD __far& val);		
		
		Error WriteMem(DWORD at, DWORD high, DWORD low);
		Error WriteMemBlock(DWORD at, DWORD num, const DWORD __far * data);
		Error ReadMem(DWORD at, DWORD __far & high, DWORD __far & low);
		
		ProgrammableClockGenerator	*	audioClock;
	
		class STi3520AAudioStrm * audioStrm;
		
		DWORD SendAudioData(HPTR data, DWORD size);
		DWORD AvailAudioData(void);
		DWORD AvailAudioBuffer(void);		
		
		int	lastIPBuffer, curIPBuffer, curDBuffer;
		DWORD	lastTempReference;
		
		WORD 					IBPBuffers[4];
		DWORD					bufferStreamPos[3];
		BOOL					bufferValid[3];
		FrameParameters	bufferParams[3];
		FrameParameters	currentDisplayParams;
		FrameParameters	currentDecodingParams;
		
		PTSCounter			ptsCounter;
		
		DWORD					currentPTS;
		DWORD					lastDecodePTS;
		DWORD					ptsTimeOffset;
		DWORD					ptsStopTimeOffset;
		
		DWORD	signalPosition;
		DWORD	predFrameStreamPos;
		DWORD	currentFrameStreamPos;
		DWORD	fvcoFreq;
		
		DWORD	scdcnt; 
		DWORD	cdcnt;                          
		DWORD	cdoffset;

		BOOL	prevOdd;
		BOOL	currentOdd;
				
		DWORD frameCnt;
		
		DWORD streamPosition;
		DWORD streamOffset;
		
		FrameParameterQueue					frames;  
		STi3520AMPEG2VideoHeaderParser   parser;
		PTSAssoc									ptsAssoc;
		long										conformPTS;
		BOOL										conformPTSValid;
		
		WORD										videoBitBufferSize;
		WORD										audioBitBufferSize;
		WORD										bitBufferSize;
		
		DWORD										videoBitrate;
		DWORD										audioBitrate;
		
		DWORD										frameSize;
		WORD										osdBase, osdBaseX;
		DWORD										osdSize, osdSizeX;
		BOOL										osdLimitation;
		
		WORD										bbfWatchdog;
		WORD										predVBL;
		WORD										bbeWatchdog;
		WORD										pidWatchdog;
		
		WORD										videoBitBufferThreshold;
		
		WORD										videoBitBufferFill;
		WORD										audioBitBufferFill;
		
		DWORD										lastIFramePosition;
		DWORD										lastGOPPosition;
		DWORD										lastSequenceHeaderPosition;
		DWORD										lastRestartPosition;

		BOOL										continuousAudioStreamMode;
		
		ASyncOutStream						*	strm;
		ByteOutputPort						*	audioPort;
		InterruptServer					*	irqServer;
	protected:                      
		DWORD irqmask;
		                      
		Error SelectIBPBuffers(MPEG2FrameType type, int __far& rfp, int __far& ffp, int __far& bfp);
		Error SelectDFPBuffer(MPEG2FrameType type, int __far& dfp);
		Error ProgramIBPBuffers(int rfp, int ffp, int bfp);                         
		Error ProgramDFPBuffer(int dfp);
		
		Error ReadSCDCount(DWORD __far&val);
		Error LastSCDCount(DWORD __far&val);
		Error ReadCDCount(DWORD __far&val);
		Error LastCDCount(DWORD __far&val);
		
		Error ReadStatus(DWORD __far&status);
		
		DWORD	interruptGhost;
		
		Error ReadInterruptStatus(DWORD __far&status);
		Error WriteInterruptMask(DWORD mask);
		Error SetResetInterruptMask(DWORD set, DWORD reset);
		Error ClearInterruptStatus(DWORD mask);
				
		int		hoffset, voffset, panScanOffset;
		WORD		picLeft, picTop;
		WORD		frameWidth, frameHeight;
		WORD		picWidth, picHeight;
		WORD		frameAspectRatio, picAspectRatio;
		
		WORD		activeLeft, activeTop, activeWidth, activeHeight;
		
#if VIONA_VERSION
		MPEG2PresentationMode presentationMode;
#endif		
		
		Error RebuildDisplayRect(void);		
		Error ProgramDisplayRect(WORD left, WORD top, WORD mwidth, WORD mheight, WORD width, WORD height, WORD mratio, WORD ratio);
		Error ConfigureVideoBus(void);
#if VIONA_VERSION		
		Error SetPanScanOffset(int offset);
#endif		
		Error WriteQuantizerMatrix(BOOL nonIntra, BYTE __far * matrix);

#if VIONA_VERSION		
		Error SetPresentationMode(MPEG2PresentationMode presentationMode);
#endif		
		
		Error ProgramInitalFrameChipParameters(void);
		Error StartFrameDecoding(void); 
		Error RestartFrameDecoding(void); 
		Error StopFrameDecoding(void);
		Error StartFrameDisplay(void);
		Error CompleteFrameDisplay(void);
		Error SkipFrameDisplay(void);
		Error SendFakeHeader(void);
		Error BeginSeek(void);
		Error BeginCue(void);
		Error CompleteSeek(DWORD offset);
		Error InternalSeek(void);
		
		Error HeaderInterrupt(void);
		Error DSyncInterrupt(void);
		Error VSyncInterrupt(BOOL top);
		Error BitBufferFullInterrupt(void);

		Error BeginDecoding(void);		// initialize chip for decoding
		Error StartDecoding(void);		// start decoding
		Error StopDecoding(void);		// stop decoding
		Error EndDecoding(void);		// reset chip after decoding
				
		//
		// Forward the refill request
		//
		void RefillRequest(DWORD free);

		void Interrupt(void);                       
		
		DWORD	stateCnt;
		int	watchDog;
		int	scanWatchDog;
		int	adaptDelay;
		BOOL	framePending;
		BOOL	skipRequest;      
		BOOL	freezeRequest;
		BOOL	lastSkipped;                          
		BOOL	skipTillHeader;
		BOOL	overfull;
		BOOL	initialParametersSent;
		BOOL	streamCompleted;
		BOOL	hasValidFrame;
		BOOL	bFrameOptimization;
		BOOL	closedGOP;
		BOOL	endCodeReceived;
		BOOL	sequenceHeaderFound;
				
		long	frameNominator;
		long	frameDenominator;
		long	frameAccu;
		WORD	playbackSpeed;
								
		enum XState
			{
			xreset,											//  0
			xinit_waitForFirstPictureHeader,    	//  1
			xinit_waitForBitBufferFull,         	//  2
			xinit_waitForStartSync,             	//  3
			xinit_waitForThirdFrame,            	//  4
			xfrozen,                            	//  5
			xplaying,                           	//  6
			xplayingRepeat0,								//  7
			xplayingRepeat1,                    	//  8 
			xplayingRepeat2,                    	//  9
			xplayingRepeat3,                    	// 10
			xstopped,                           	// 11
			xseeking,                           	// 12
			xresync_waitForFirstPictureHeader,  	// 13
			xresync_waitForBitBufferFull,       	// 14
			xresync_waitForStartSync,           	// 15
			xresync_waitForThirdFrame,          	// 16
			xresync_prefreeze1,							//	17
			xresync_prefreeze2,							//	18
			xplaying_recover,                   	// 19
			xstepping,                          	// 20
			xstarving,										// 21
			xcueing,											// 22
			xresyncue_waitForFirstPictureHeader,	// 23
			xresyncue_waitForBitBufferFull,			// 24
			xresyncue_waitForStart,						// 25
			xstill,		      							// 26
			xplayingStill,									// 27
			xscan_waitForFirstPictureHeader,			// 28
			xscan_waitForBitBufferFull,				// 29
			xscan_waitForStartSync,						// 30
			xscan_decoding									// 31
			} xstate;
			
	   friend XState operator ++(XState __far& x, int a) {return (XState)(((int __far&)x)++);}
	   
	   DWORD GetPTS();
	   void PutPTS(DWORD pos);
	   Error ConformToPTS(DWORD pts);
      
      MPEG2CommandQueue	commandQueue;
      
	   Error SendCommand(MPEGCommand com, DWORD param, DWORD __far &tag);
		BOOL CommandPending(DWORD tag);
	
		DWORD CurrentLocation(void);
		MPEGState CurrentState(void);
		DWORD LastTransferLocation(DWORD scale);
			   
	   DWORD SendData(HPTR data, DWORD size);
#if VIONA_VERSION
		MPEG2PESType NeedsPES(void) {return dvdStreamEncrypted ? MP2PES_DVD : MP2PES_ELEMENTARY;}
		Error SendPESData(HPTR data, DWORD size, DWORD __far & done, DWORD __far & used);
#endif
	   void CompleteData(void);
	
		VideoStandard	videoStandard;    
		BOOL mpeg2Coding;
      
      Error ReconfigureBuffers(void);
      
	   Error SetSignalPosition(DWORD position);
		Error SetVideoBitrate(DWORD videoBitrate);
		Error SetAudioBitrate(DWORD audioBitrate);
		Error SetVideoWidth(WORD width);
		Error SetVideoHeight(WORD height);
		Error SetAspectRatio(WORD aspectRatio);
		Error SetVideoStandard(VideoStandard	standard);
		Error SetVideoFPS(WORD fps);
		Error SetMPEG2Coding(BOOL mpeg2Coding);
		
		BOOL	vblankServerEnabled;      
		
		Error EnableVBlankServer(void);
		Error DisableVBlankServer(void);
		
		VirtualUnit	*	videoBus;
		
		Error Lock(VirtualUnit * unit);
		Error Unlock(VirtualUnit * unit);

#if VIONA_VERSION		
	protected:
		DWORD osdHeader[10];
		WORD	osdNumColors;
		BOOL	osdValid, osdEnabled, osdHighColor;
		WORD	osdX, osdY, osdW, osdH;
		WORD	osdPalette[16];
		BYTE	osdTransparency[16];
		BYTE	osdColors[16];
		DWORD	osdHeight, osdWidth;
				
		Error WriteOSDHeader(void);
		
	public:
		Error KillOSDBitmap(void);     
	   Error SetOSDBitmap(WORD numColors,
	   					    BYTE __far * colorTable, BYTE __far * contrastTable,
	                      WORD x, WORD y, WORD width, WORD height,
	                      DWORD __huge * odd, DWORD __huge * even);
	
		Error SetOSDPalette(int entry, int y, int u, int v);	                                   
		
		Error ShowOSD(BOOL enable);
#endif		
	public:
		InterruptServer	*	vblankServer;
		PTSCaller	ptsCaller;
		
		STi3520AMPEG2Decoder(ByteIndexedInOutPort 		* 	port,
		                     ASyncOutStream       		* 	strm,
		                     InterruptServer				*	irqServer,
		                     ByteOutputPort					*	audioPort,
		                     VirtualUnit						*	videoBus = NULL,
		                     ProgrammableClockGenerator * 	audioClock = NULL,
		                     BOOL									continuousAudioStreamMode = FALSE);
		~STi3520AMPEG2Decoder(void);
		
		Error Configure(TAG __far * tags);
		
		Error InitClockGenerator(STi3520AClockSource source, WORD nominator, WORD denominator, DWORD freq);
		Error ProgramClockGenerator(STi3520AClock clock, BOOL external, DWORD freq);
		Error ConfigureMemory(BYTE busWidth, 
									 BOOL preventBitBufferOverflow,
									 BOOL enable,
									 BOOL	segmentsPerRow,
									 BOOL	edoRam,
									 BOOL	sdRam,
									 BOOL	meg20,
									 BYTE refreshInterval);
		BOOL CheckChipInitialisation(void);
		Error ConfigureBuffers(DWORD bitBufferSize,	// in bytes
		                       DWORD frameSize);				// in bytes
		Error SetBufferRatio(DWORD videoBitBuffer, DWORD audioBitBuffer); // in any unit.		                       
		Error SoftReset(void);											 
		
		VirtualUnit * CreateVirtual(void);		

		ASyncOutStream	*	BuildAudioStream();
		Error InitializeAudioStream(void);
   };

class VirtualSTi3520AMPEG2Decoder : public VirtualMPEG2VideoDecoder
	{
	private:
		STi3520AMPEG2Decoder	*	decoder;
	protected:                                
      Error PreemptStopPrevious(VirtualUnit * previous);
      Error PreemptChange(VirtualUnit * previous);
      Error PreemptStartNew(VirtualUnit * previous);

		Error GetDisplaySize(WORD __far &width, WORD __far &height);
		
		DWORD audioBitrate;

		BOOL						initial;		

		struct 
			{
			WORD						width;
			WORD						height;
			BYTE						aspectRatio;
			WORD						aspectRatioFactor;
			BYTE						frameRate;
			DWORD						bitRate;
			DWORD						vbvBufferSize;
			MPEG2CodingStandard	codingStandard;	
			BYTE						intraQuantMatrix[64];
			BYTE						nonIntraQuantMatrix[64];           
			BYTE						chromaIntraQuantMatrix[64];
			BYTE						chromaNonIntraQuantMatrix[64];           
			} parser;
		
	public:
		VirtualSTi3520AMPEG2Decoder(STi3520AMPEG2Decoder * unit);

#if VIONA_VERSION
		MPEG2PESType NeedsPES(void) {return dvdStreamEncrypted ? MP2PES_DVD : MP2PES_ELEMENTARY;}
#endif
		
		Error Configure(TAG __far * tags);
	};

class STi3520AMPEGAudioDecoder : public MPEG2AudioDecoder, 
											protected ASyncRefillRequest,
											protected InterruptHandler
	{
	friend class VirtualSTi3520AMPEGAudioDecoder;
	private:
		STi3520AMPEG2Decoder * decoder;
	protected:                                              
		VirtualAudioDAC	*	pcmDAC;
		ASyncOutStream		*	strm;
		MPEGState				state;
		DWORD						audioBitrate;
		WORD						sampleRate;

		BOOL						mute;
		WORD						leftVolume, rightVolume;
		
		DWORD						streamPosition;

		DWORD						dataNominator, dataDenominator;
		
#if VIONA_VERSION
		BOOL						lpcm;
		WORD						bitsPerSample;
		WORD						channels;
		
		BYTE						frameBuffer[320];
		WORD						framePosition;
		WORD						bytePosition;
		WORD						bytePositionWrap;
		DWORD						bytePositionMask;
		enum {LPS_FILLING, LPS_SENDING} lpcmState;
		
		Error ResetFrameBuffer(void);
		DWORD SendLPCMData(HPTR data, DWORD size);		
#endif
		
		DWORD						predPosition;
		DWORD						signalPosition;

		DWORD						stepCnt;

		PTSAssoc					ptsAssoc;

		PTSCounter				ptsCounter;
		
		VirtualUnit			*	audioBus;   
		
		Error SetAudioBitrate(DWORD audioBitrate);
		Error SetSampleRate(WORD rate); 
		Error SetLeftVolume(WORD volume);
		Error SetRightVolume(WORD volume);
		Error SetMute(BOOL mute);
#if VIONA_VERSION
		Error SetLPCM(BOOL lpcm);
		Error SetBitsPerSample(WORD samples);
		Error SetChannels(WORD channels);
#endif		

		Error ProgramAudioFrequency(DWORD freq);

	   DWORD SendData(HPTR data, DWORD size);
	   void CompleteData(void);

	   Error SendCommand(MPEGCommand com, DWORD param, DWORD __far &tag);
		BOOL CommandPending(DWORD tag);
			
		DWORD CurrentLocation(void);
		MPEGState CurrentState(void);
		DWORD LastTransferLocation(DWORD scale);
			   
	   void PutPTS(DWORD pts);
	   DWORD GetPTS();
	   
	   Error SetSignalPosition(DWORD position);

		Error StopDecoding(void);
		Error StartDecoding(void);

		void RefillRequest(DWORD free);
		
		InterruptServer * vblank;
		
		void Interrupt(void);

		VirtualUnit * CreateVirtual(void);
	public:
		STi3520AMPEGAudioDecoder(STi3520AMPEG2Decoder * decoder,
							          VirtualAudioDAC      *	dac,
							          InterruptServer		 * vblank,
							          VirtualUnit			 * audioBus = NULL,
							          ASyncOutStream		 * stream = NULL);

	};

class VirtualSTi3520AMPEGAudioDecoder : public VirtualMPEG2AudioDecoder
	{
	private:
		STi3520AMPEGAudioDecoder * decoder;

      Error PreemptStopPrevious(VirtualUnit * previous);
      Error PreemptChange(VirtualUnit * previous);
      Error PreemptStartNew(VirtualUnit * previous);
	public:
		VirtualSTi3520AMPEGAudioDecoder(STi3520AMPEGAudioDecoder * unit)
			: VirtualMPEG2AudioDecoder(unit) {decoder = unit; audioMute = FALSE;}
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\specific\sti5505.h ===
#ifndef STI5505_H
#define STI5505_H

#include "library\common\prelude.h"
#include "library\common\krnlint.h"
#include "library\common\gnerrors.h"
#include "library\common\profiles.h"
#include "library\lowlevel\hardwrio.h"
#include "library\lowlevel\intrctrl.h"
#include "library\lowlevel\memmpdio.h"
#include "library\general\asncstrm.h"
#include "library\hardware\osd\generic\osddefs.h"
#include "library\hardware\audio\generic\audiodac.h"
#if VIONA_VERSION
#include "library\hardware\mpeg2dec\generic\mp2spudc.h"
#endif

#include "library\hardware\mpeg2dec\generic\mp2eldec.h"
#include "library\hardware\mpeg2dec\generic\mp2vsprs.h"

// Set this to 1 to enable a test for corrupted SDRAM decoder memory
#define TEST_DECODER_MEMORY		0

class FrameParameters
	{
	public:
		BYTE				pfh, pfv, ppr1, ppr2;

		MPEG2FrameType				frameType;
		MPEG2PictureStructure   fieldType;

		BOOL				repeatFirstField : 2;
		BOOL				topFieldFirst    : 2;
		BOOL				progressiveFrame : 2;
		BOOL				skipped          : 2;
		DWORD				temporalReference;
		KernelInt64		streamPosition;
		DWORD				pts;
		int				centerVerticalOffset;
		int				centerHorizontalOffset;

		Error Init (MPEG2VideoHeaderParser *params, KernelInt64 streamPosition, DWORD pts);
	};



class FrameParameterQueue
	{
	private:
		FrameParameters	*	params;
		WORD	num, first, last;

	public:
		FrameParameterQueue (WORD size);
		virtual ~FrameParameterQueue (void);

		Error Reset (void);
		Error InsertFrame (MPEG2VideoHeaderParser *parser, KernelInt64 streamPosition, DWORD pts);
		Error MarkSkipped (void);
		BOOL IsSkipped (void);
		Error GetFrame (FrameParameters &params);
		Error GetNextFrame (FrameParameters &params);
		Error NextFrame (void);
		WORD FrameAvail(void) {return (first <= last) ? (last - first) : (num + last - first);}
	};


class STi5505MPEG2Decoder;


class STi5505MPEG2VideoHeaderParser : public MPEG2VideoHeaderParser
	{
	private:
		MemoryMappedIO			*	port;
		STi5505MPEG2Decoder	*	decoder;
		BOOL							odd;
		BOOL							even;
		BYTE							second;
      BYTE							ccbuffer[256];

		Line21Receiver			*	line21Receiver;

		Error WaitForFIFONonEmpty (void);
	protected:
		Error BeginParse (void);
		Error NextByte (void);
		Error EndParse (void);

		Error ParsePictureHeader (void);
		Error ParseUserData(void);
	public:
		BOOL	skipHeader;

		STi5505MPEG2VideoHeaderParser (MemoryMappedIO *port, STi5505MPEG2Decoder * decoder);

		Error SetLine21Receiver(Line21Receiver * line21Receiver) {this->line21Receiver = line21Receiver; GNRAISE_OK;}
	};




class STi5505MPEG2Decoder : public MPEG2VideoDecoder, protected InterruptHandler, protected ASyncRefillRequest
#if VIONA_VERSION
                             ,public OSDDisplay
#endif
	{
	friend class VirtualSTi5505MPEG2Decoder;
	friend class STi5505VBlankIntServer;

	protected:
		// Basic IO operations.
		MemoryMappedIO	*	port;
		MemoryMappedIO * 	subPicturePort;
		BitOutputPort	*	widescreenActivePort;
		int	chipVersion;

		inline void OutByte (int idx, BYTE val);
		inline void InByte (int idx, BYTE __far&val);

		// to avoid double index programming
		inline void OutWordHL (int idx, WORD val);
		inline void OutWordLH (int idx, WORD val);
		inline void OutWordHL0 (int idx, WORD val);
		inline void InWordHL (int idx, WORD &val);

		void WriteMem (DWORD at, DWORD high, DWORD low);
		void WriteMemBlock (DWORD at, DWORD num, const DWORD *data);
#if TEST_DECODER_MEMORY
		void ReadMem (DWORD at, DWORD &high, DWORD &low);
#endif

		DWORD SendAudioData(HPTR data, DWORD size);
		DWORD AvailAudioData(void);
		DWORD AvailAudioBuffer(void);

		int	lastIPBuffer, curIPBuffer, curDBuffer;
		DWORD	lastTempReference;

		WORD 					lumaIBPBuffers[4];
		WORD 					chromaIBPBuffers[4];
		DWORD					bufferStreamPos[3];
		BOOL					bufferValid[3];
		FrameParameters	bufferParams[3];
		FrameParameters	currentDisplayParams;
		FrameParameters	currentDecodingParams;

		PTSCounter			ptsCounter;

		DWORD					currentPTS;
		DWORD					lastDecodePTS;
		DWORD					ptsTimeOffset;
		DWORD					ptsStopTimeOffset;

		KernelInt64	signalPosition;
		KernelInt64	predFrameStreamPos;
		KernelInt64	currentFrameStreamPos;

		KernelInt64	scdcnt;
		KernelInt64	cdcnt;
		KernelInt64	cdoffset;

		BOOL	prevOdd;
		BOOL	currentOdd;

		DWORD frameCnt;
		DWORD ipFrameCount;

		KernelInt64 streamPosition;
		KernelInt64 streamOffset;

		FrameParameterQueue					frames;
		STi5505MPEG2VideoHeaderParser		parser;
		PTSAssoc									ptsAssoc;
		long										conformPTS;
		BOOL										conformPTSValid;

		WORD										videoBitBufferSize;
		WORD										audioBitBufferSize;
		WORD										bitBufferSize;

		DWORD										videoBitrate;
		DWORD										audioBitrate;

		DWORD										frameSize;
		DWORD										lumaSize, chromaSize;
		WORD										osdBase, osdBaseX;
		DWORD										osdSize, osdSizeX;
		BOOL										osdLimitation;

		WORD										bbfWatchdog;
		WORD										predVBL;
		WORD										bbeWatchdog;
		WORD										pidWatchdog;

		WORD										videoBitBufferThreshold;
		WORD										audioBitBufferThreshold;

		WORD										videoBitBufferFill;
		WORD										audioBitBufferFill;

		KernelInt64								lastIFramePosition;
		KernelInt64								lastGOPPosition;
		KernelInt64								lastSequenceHeaderPosition;
		KernelInt64								lastRestartPosition;

		BOOL										continuousAudioStreamMode;

		ASyncOutStream						*	strm;
		ByteOutputPort						*	audioPort;
		InterruptServer					*	irqServer;

		Line21Receiver						*	line21Receiver;
		BOOL										ccEnabled;
		StaticProfile						*	profile;
		WORD										digitalOutputEnabled;

		Error										ReadRegistryEntries (void);

	protected:
		DWORD irqmask;

		void SelectIBPBuffers (MPEG2FrameType type, int &rfp, int &ffp, int &bfp);
		void SelectDFPBuffer (MPEG2FrameType type, int &dfp);
		void ProgramIBPBuffers (int rfp, int ffp, int bfp);
		void ProgramDFPBuffer (int dfp);

		void ReadSCDCount (KernelInt64 &val);
		void LastSCDCount (KernelInt64 &val);
		void ReadCDCount (KernelInt64 &val);
		void LastCDCount (KernelInt64 &val);

		void ReadStatus (DWORD &status);

		DWORD	interruptGhost;

		void ReadInterruptStatus (DWORD &status);
		void WriteInterruptMask (DWORD mask);
		void SetResetInterruptMask (DWORD set, DWORD reset);
		void ClearInterruptStatus (DWORD mask);

		int		hoffset, voffset, panScanOffset;
		WORD		picLeft, picTop;
		WORD		frameWidth, frameHeight;
		WORD		picWidth, picHeight;
		WORD		frameAspectRatio, picAspectRatio;
		WORD		dfsShadow, enableOSDShadow;
		BOOL		freezeToOneField;
		int		downscaleFactor, downscaleHOffset, downscaleVOffset;
		int		downscaleHOffsetLetterboxed, downscaleVOffsetLetterboxed;

		WORD		activeLeft, activeTop, activeWidth, activeHeight;
		BOOL		widescreenContent;

		DWORD		lastVideoPTS;
		DWORD		lastAudioPTS;
		BOOL		noPTS;
		BOOL		audioStarted;
		DWORD		firstAudioPTS;

#if VIONA_VERSION
		ForcedAspectRatio forcedSourceAR;
		MPEG2PresentationMode presentationMode;
#endif

		Error RebuildDisplayRect(void);
		Error ProgramDisplayRect(WORD left, WORD top, WORD mwidth, WORD mheight, WORD width, WORD height, WORD mratio, WORD pixelRatio);
		Error ConfigureVideoBus(void);
#if VIONA_VERSION
		Error SetPanScanOffset(int offset);
#endif
		Error WriteQuantizerMatrix(BOOL nonIntra, BYTE __far * matrix);

#if VIONA_VERSION
		Error SetForcedSourceAspectRatio(ForcedAspectRatio forcedSourceAR);
		Error SetPresentationMode(MPEG2PresentationMode presentationMode);
#endif

		Error ProgramInitalFrameChipParameters(void);
		Error StartFrameDecoding(void);
		Error RestartFrameDecoding(void);
		Error StopFrameDecoding(void);
		Error StartFrameDisplay(void);
		Error CompleteFrameDisplay(void);
		Error SkipFrameDisplay(void);
		Error SendFakeHeader(void);
		Error BeginSeek(void);
		Error BeginCue(void);
		Error CompleteSeek(DWORD offset);
		Error InternalSeek(void);

		Error HeaderInterrupt(void);
		Error DSyncInterrupt(void);
		Error VSyncInterrupt(BOOL top);
		Error BitBufferFullInterrupt(void);

		Error BeginDecoding(void);		// initialize chip for decoding
		Error StartDecoding(void);		// start decoding
		Error StopDecoding(void);		// stop decoding
		Error EndDecoding(void);		// reset chip after decoding

		//
		// Forward the refill request
		//
		void RefillRequest(DWORD free);

		void Interrupt(void);

		DWORD	stateCnt;
		int	watchDog;
		int	scanWatchDog;
		int	adaptDelay;
		BOOL	framePending;
		BOOL	skipRequest;
		BOOL	freezeRequest;
		BOOL	lastSkipped;
		BOOL	skipTillHeader;
		BOOL	fakeHeaderRequest;
		BOOL	overfull;
		BOOL	initialParametersSent;
		BOOL	streamCompleted;
		BOOL	hasValidFrame;
		BOOL	bFrameOptimization;
		BOOL	closedGOP;
		BOOL	endCodeReceived;
		BOOL	sequenceHeaderFound;
		BOOL	oneSiblingBufferFull;

		long	frameNominator;
		long	frameDenominator;
		long	frameAccu;
		WORD	playbackSpeed;

		enum XState
			{
			xreset,											//  0
			xinit_waitForFirstPictureHeader,			//  1
			xinit_waitForBitBufferFull,				//  2
			xinit_waitForStartSync,						//  3
			xinit_waitForThirdFrame,					//  4
			xfrozen,											//  5
			xplaying,										//  6
			xplayingRepeat0,								//  7
			xplayingRepeat1,								//  8 
			xplayingRepeat2,								//  9
			xplayingRepeat3,								// 10
			xstopped,										// 11
			xseeking,										// 12
			xresync_waitForFirstPictureHeader,		// 13
			xresync_waitForBitBufferFull,				// 14
			xresync_waitForStartSync,					// 15
			xresync_waitForThirdFrame,					// 16
			xresync_prefreeze1,							// 17
			xresync_prefreeze2,							// 18
			xplaying_recover,								// 19
			xstepping,										// 20
			xstarving,										// 21
			xcueing,											// 22
			xresyncue_waitForFirstPictureHeader,	// 23
			xresyncue_waitForBitBufferFull,			// 24
			xresyncue_waitForStart,						// 25
			xstill,											// 26
			xplayingStill,									// 27
			xfreezingStill,								// 28
			xscan_waitForFirstPictureHeader,			// 29
			xscan_waitForBitBufferFull,				// 30
			xscan_waitForStartSync,						// 31
			xscan_decoding,								// 32
			xseek_waitForIdle								// 33
			} xstate;

		void IncrementState (XState &state) {(XState)(((int &)xstate)++);}

		DWORD GetPTS();
		void PutPTS(DWORD pos);
		Error ConformToPTS(DWORD pts);

		MPEG2CommandQueue	commandQueue;

		Error SendCommand(MPEGCommand com, DWORD param, DWORD __far &tag);
		BOOL CommandPending(DWORD tag);

		DWORD CurrentLocation(void);
		MPEGState CurrentState(void);
		DWORD LastTransferLocation(DWORD scale);

		DWORD SendData(HPTR data, DWORD size);
#if VIONA_VERSION
		MPEG2PESType NeedsPES(void) {return MP2PES_ELEMENTARY;}
		Error SendPESData(HPTR data, DWORD size, DWORD __far & done, DWORD __far & used);
#endif
		void CompleteData(void);

		virtual Error NotifySiblingBufferFull(void);

		BYTE	lastSendDataBytes[4];   // index 0 is the very last byte of previous SendData()

		VideoStandard	videoStandard;    
		BOOL mpeg2Coding;

		Error ReconfigureBuffers(void);

		Error SetSignalPosition(DWORD position);
		Error SetVideoBitrate(DWORD videoBitrate);
		Error SetAudioBitrate(DWORD audioBitrate);
		Error SetVideoWidth(WORD width);
		Error SetVideoHeight(WORD height);
		Error SetAspectRatio(WORD aspectRatio);
		Error SetVideoStandard(VideoStandard	standard);
		Error SetVideoFPS(WORD fps);
		Error SetMPEG2Coding(BOOL mpeg2Coding);

		BOOL	vblankServerEnabled;

		Error EnableVBlankServer(void);
		Error DisableVBlankServer(void);

		VirtualUnit	*	videoBus;

		Error Lock(VirtualUnit * unit);
		Error Unlock(VirtualUnit * unit);

#if VIONA_VERSION
	protected:
		DWORD	osdHeader[130];
		DWORD	osdHeaderBytes;
		WORD	osdNumColors;
		BOOL	osdValid, osdEnabled;
		WORD	osdX, osdY, osdW, osdH;
		WORD	osdPalette[256];
		BYTE	osdTransparency[256];
		BYTE	osdColors[256];
		DWORD	osdDwordsPerLine;
		DWORD	osdFirstBase, osdSecondBase;
		BYTE	*osdFirstField, *osdSecondField;
		VideoStandard osdVideoStandard;
		OSDStandardChangeHookHandle osdStandardChangeHook;

		Error WriteOSDHeader(void);
		Error CheckToSwitchOffOSD (VideoStandard newDecoderStandard);
		Error RedisplayOSD (void);

	public:
		Error KillOSDBitmap(void);
		Error SetOSDBitmap(WORD numColors,
								 BYTE __far * colorTable, BYTE __far * contrastTable,
								 WORD x, WORD y, WORD width, WORD height,
								 DWORD __huge * odd, DWORD __huge * even);

		Error SetOSDPalette(int entry, int y, int u, int v);

		Error ShowOSD(BOOL enable);

		Error CreateOSD (WORD numColors, VideoStandard vidStandard,
		                 BYTE __far * colorTable, BYTE __far * contrastTable,
		                 WORD x, WORD y, WORD width, WORD height, OSDStandardChangeHookPtr hook = NULL);

		Error BitBlitOSD (void *source, int sourceNumColors, int stride,
								int sx, int sy, int swidth, int sheight, int dx, int dy);
		Error SetRectOSD (int color, int x, int y, int width, int height);

		virtual Error SetCCEnabled(BOOL ccEnabled);
		Error SetLine21Receiver(Line21Receiver * line21Receiver);
#endif
	public:
		InterruptServer	*	vblankServer;
		PTSCaller	ptsCaller;

		STi5505MPEG2Decoder (MemoryMappedIO		*	port,
									ASyncOutStream		*	strm,
									MemoryMappedIO		*	subPicturePort,
									InterruptServer	*	irqServer);
		virtual ~STi5505MPEG2Decoder(void);

		Error Initialize (ByteOutputPort	*	audioPort,
								VirtualUnit		*	videoBus,
								BitOutputPort	*	widescreenActivePort,
								StaticProfile	*	profile);

		Error Configure(TAG __far * tags);

		Error ConfigureMemory(BYTE refreshInterval);
		BOOL CheckChipInitialisation(void);
		Error ConfigureBuffers(DWORD bitBufferSize,	// in bytes
		                       DWORD frameSize);		// in bytes
		Error SetBufferRatio(DWORD videoBitBuffer, DWORD audioBitBuffer); // in any unit.
		Error SoftReset(void);

		void	GetSubpictureBufferParameters(DWORD & offset, DWORD & size);

		BOOL	Line21TransferAllowed() {return (ccEnabled && (xstate > xfrozen) && (xstate < xstopped) && (playbackSpeed == 1000));}

		VirtualUnit * CreateVirtual(void);
	};



class VirtualSTi5505MPEG2Decoder : public VirtualMPEG2VideoDecoder
	{
	private:
		STi5505MPEG2Decoder	*	decoder;

		ForcedAspectRatio			forcedSourceAR;

	protected:
		Error PreemptStopPrevious(VirtualUnit * previous);
		Error PreemptChange(VirtualUnit * previous);
		Error PreemptStartNew(VirtualUnit * previous);

		Error GetDisplaySize(WORD __far &width, WORD __far &height);

		DWORD audioBitrate;

		BOOL						initial;

		BOOL						ccEnabled;

		Line21Receiver			*	line21Receiver;

		struct
			{
			WORD						width;
			WORD						height;
			BYTE						aspectRatio;
			WORD						aspectRatioFactor;
			BYTE						frameRate;
			DWORD						bitRate;
			DWORD						vbvBufferSize;
			MPEG2CodingStandard	codingStandard;
			BYTE						intraQuantMatrix[64];
			BYTE						nonIntraQuantMatrix[64];
			BYTE						chromaIntraQuantMatrix[64];
			BYTE						chromaNonIntraQuantMatrix[64];
			} parser;

	public:
		VirtualSTi5505MPEG2Decoder(STi5505MPEG2Decoder * unit);

#if VIONA_VERSION
		MPEG2PESType NeedsPES(void) {return MP2PES_ELEMENTARY;}
#endif

		Error Configure(TAG __far * tags);

		Error SetLine21Receiver(Line21Receiver * line21Receiver) {this->line21Receiver = line21Receiver; GNRAISE_OK;}
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\specific\tl850.h ===
// FILE:      library\hardware\mpeg2dec\specific\tl850.h
// AUTHOR:    Martin Stephan
// COPYRIGHT: (c) 1999 VIONA Development GmbH.  All Rights Reserved.
// CREATED:   05.05.1999
//
// PURPOSE:   TeraLogic TL850 Digital TV Decoder --- header file 
//
// HISTORY:

#ifndef TL850_H
#define TL850_H

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"
#include "library\lowlevel\hardwrio.h"
#include "library\lowlevel\memmpdio.h"
#include "library\lowlevel\intrctrl.h"
#include "library\general\asncstrm.h"
#include "..\..\clocks\generic\clocks.h"
#include "..\..\audio\generic\audiodac.h"
#if VIONA_VERSION
#include "..\generic\mp2spudc.h"
#endif

#include "..\generic\mp2eldec.h"
#include "..\generic\mp2vsprs.h"
#include "library\lowlevel\pci.h"

class FrameParameters
	{	
	public:
		BYTE				pfh, pfv, ppr1, ppr2;
		
		MPEG2FrameType				frameType;		
		MPEG2PictureStructure   fieldType;
		
		BOOL				repeatFirstField : 2;
		BOOL				topFieldFirst    : 2;
		BOOL				progressiveFrame : 2;
		BOOL				skipped          : 2;
		DWORD				temporalReference;
		DWORD				streamPosition;
		DWORD				pts;
		int				centerVerticalOffset;
		int				centerHorizontalOffset;
		BYTE				intraQuant[64];
		BYTE				nonIntraQuant[64];
				
		Error Init(MPEG2VideoHeaderParser	* params, DWORD streamPosition, DWORD pts, BYTE * intraQuant, BYTE * nonIntraQuant);
	};

class FrameParameterQueue
	{	
	private:
		FrameParameters	*	params;
		WORD	num, first, last;
	public:
		FrameParameterQueue(WORD size);
		virtual ~FrameParameterQueue(void);
		
		Error Reset(void);
		Error InsertFrame(MPEG2VideoHeaderParser * parser, DWORD streamPosition, DWORD pts, BYTE * intraQuant, BYTE * nonIntraQuant);
		Error MarkSkipped(void);
		BOOL IsSkipped(void);
		Error GetFrame(FrameParameters __far &params);
		Error NextFrame(void);
		WORD FrameAvail() {return (first <= last) ? (last - first) : (num + last - first);}
	};

class TL850MPEG2VideoHeaderParser : public MPEG2VideoHeaderParser
	{
	private:
		ByteIndexedInputPort	*	port;
		BOOL							odd;         
		BOOL							even;
		BYTE							second;
		Error WaitForFIFONonEmpty(void);
	protected:
		Error BeginParse(void);
		Error NextByte(void);
		Error EndParse(void);

		Error ParsePictureHeader(void);	
	public:
		BOOL	skipHeader;
		
		TL850MPEG2VideoHeaderParser(ByteIndexedInputPort	*	port);
	};

class TL850MPEG2Decoder;

class TL850PCIInterface
	{
	private:
		MemoryMappedIO		*mem;
			 
	public:
		TL850PCIInterface(TL850MPEG2Decoder * tl850);
		~TL850PCIInterface(void);

		Error Initialize(void);
		void	CheckPCIBusConfiguration(void);
		BOOL	CheckInterrupt(void);
		virtual void Interrupt(void);
	};

//all possible cursor looks are enumareted in an enum structure. Use this structure to choose a cursor!
enum CursorType
	{
	CURSOR_DEFAULT,
	CURSOR_ARROW,
	CURSOR_SMILEY
	};
		
class TL850MPEG2Decoder : public MPEG2VideoDecoder, protected InterruptHandler, protected ASyncRefillRequest,
									public OSDDisplay
	{
	friend class VirtualTL850MPEG2Decoder;
	friend class TL850VBlankIntServer;

	private: 
		
	protected:
		
		WORD	currentCursorXPos;
		WORD	currentCursorYPos;
		BYTE	currentCursorHScale;
		BYTE  currentCursorVScale;
		CursorType currentCursorType;

		WORD	currentOverlayXPos;
		WORD  currentOverlayYPos;
		WORD	currentOverlayWidth;
		WORD	currentOverlayHeight;
		BYTE	currentOverlayWindowHScale;
		BYTE  currentOverlayWindowVScale;

		Error OutByte(int idx, BYTE val);                             
		Error InByte(int idx, BYTE __far&val);
	
		Error OutDWordHL(int idx, DWORD val);
		Error OutDWordLH(int idx, DWORD val);
		Error OutDWordHL0(int idx, DWORD val);
		Error InDWordHL(int idx, DWORD __far& val);		

		//FrameParameterQueue					frames;  
		//TL850MPEG2VideoHeaderParser			parser;
		//PTSAssoc									ptsAssoc;
		BitIndexedInOutPort					* genPurposePort;
		ByteIndexedInOutPort					* auxVideoPort;
								
		enum XState
			{
			xreset,											//  0
			xinit_waitForFirstPictureHeader,    	//  1
			xinit_waitForBitBufferFull,         	//  2
			xinit_waitForStartSync,             	//  3
			xinit_waitForThirdFrame,            	//  4
			xfrozen,                            	//  5
			xplaying,                           	//  6
			xplayingRepeat0,								//  7
			xplayingRepeat1,                    	//  8 
			xplayingRepeat2,                    	//  9
			xplayingRepeat3,                    	// 10
			xstopped,                           	// 11
			xseeking,                           	// 12
			xresync_waitForFirstPictureHeader,  	// 13
			xresync_waitForBitBufferFull,       	// 14
			xresync_waitForStartSync,           	// 15
			xresync_waitForThirdFrame,          	// 16
			xresync_prefreeze1,							//	17
			xresync_prefreeze2,							//	18
			xplaying_recover,                   	// 19
			xstepping,                          	// 20
			xstarving,										// 21
			xcueing,											// 22
			xresyncue_waitForFirstPictureHeader,	// 23
			xresyncue_waitForBitBufferFull,			// 24
			xresyncue_waitForStart,						// 25
			xstill,		      							// 26
			xplayingStill,									// 27
			xscan_waitForFirstPictureHeader,			// 28
			xscan_waitForBitBufferFull,				// 29
			xscan_waitForStartSync,						// 30
			xscan_decoding									// 31
			} xstate;
			
		friend XState operator ++(XState __far& x, int a) {return (XState)(((int __far&)x)++);}

		MPEG2CommandQueue	commandQueue;

		DWORD GetPTS();

		Error SetPresentationMode(MPEG2PresentationMode presentationMode);
		Error SendCommand(MPEGCommand com, DWORD param, DWORD __far &tag);
		BOOL	CommandPending(DWORD tag);
		DWORD CurrentLocation(void);
		MPEGState CurrentState(void);
		DWORD LastTransferLocation(DWORD scale);
		
		Error HeaderInterrupt(void);
		Error DSyncInterrupt(void);
		Error VSyncInterrupt(BOOL top);
		Error BitBufferFullInterrupt(void);

		DWORD SendData(HPTR data, DWORD size);
		void	CompleteData(void);
		void	RefillRequest(DWORD free);

		Error SetSignalPosition(DWORD position);
		Error SetVideoBitrate(DWORD videoBitrate);
		Error SetVideoWidth(WORD width);
		Error SetVideoHeight(WORD height);
		Error SetVideoStandard(VideoStandard standard);
		Error SetVideoFPS(WORD fps);
		Error SetMPEG2Coding(BOOL mpeg2Coding);
		Error SetAspectRatio(WORD aspectRatio);
		 
		/* cursor methods */
		Error EnableCursor(void);
		Error DisableCursor(void);
		Error SetCursor(CursorType cursType, WORD xpos, WORD ypos, BYTE hscale, BYTE vscale);
		Error SetCursorLookupTable(BYTE tableNr, DWORD value);

		/* overlay methods */
		Error EnableOverlayWindow(void);
		Error DisableOverlayWindow(void);
		Error SetOverlayWindow(WORD width, WORD height, BYTE hscale, BYTE vscale, WORD xpos, WORD ypos);
		Error ShowOverlayColorFlow(void);

		/* OSD methods */
		Error KillOSDBitmap(void);
	   Error SetOSDBitmap(WORD numColors, 
	   					   BYTE __far * colorTable, BYTE __far * contrastTable,
	                     WORD x, WORD y, WORD width, WORD height,
	                     DWORD __huge * odd, DWORD __huge * even);
		Error SetOSDPalette(int entry, int y, int u, int v);
		Error ShowOSD(BOOL enable);

	public:
		
		/*
		TL850MPEG2Decoder(ByteIndexedInOutPort				* 	port,
		                     ASyncOutStream       		* 	strm,
		                     InterruptServer				*	irqServer,
		                     VirtualUnit						*	videoBus = NULL);
		*/
		TL850MPEG2Decoder(MemoryMappedIO *mem1, MemoryMappedIO *mem2, MemoryMappedIO *mem3);
		~TL850MPEG2Decoder(void);
		
		//
		// Memory area of the ASRs
		//
		MemoryMappedIO			*sdramMem;
		MemoryMappedIO			*regSpaceMem;
		MemoryMappedIO			*transBufferMem;
		TL850PCIInterface		*pciInterface;
		//Interface				*sdramInterface;

		//fast init is only for testing purpose. Init TL850 chip and show a test pattern.
		//All in one routine.
		Error FastInit(void);
		Error Initialize(void);
		Error BuildChipComponents(void);
		BOOL CheckChipInitialization(void);
		Error Configure(TAG __far * tags);

		void Interrupt(void);
		BOOL CheckInterrupt(void);

		VirtualUnit * CreateVirtual(void);		
   };

class VirtualTL850MPEG2Decoder : public VirtualMPEG2VideoDecoder
	{
	private:
		TL850MPEG2Decoder		*	decoder;
	protected:                                
		
	public:
		VirtualTL850MPEG2Decoder(TL850MPEG2Decoder * unit);

		Error Configure(TAG __far * tags);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\specific\sti7000.h ===
// FILE:      library\hardware\mpeg2dec\specific\sti7000.h
// AUTHOR:    U. Sigmund, M. Stephan, C. Scherer
// COPYRIGHT: (c) 1998 VIONA Development GmbH.  All Rights Reserved.
// CREATED:   
//
// PURPOSE:   STi 7000 MPEG-2 HDTV decoder chip --- header file 
//
// HISTORY:

#ifndef STI7000_H
#define STI7000_H

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"
#include "library\common\profiles.h"
#include "library\lowlevel\hardwrio.h"
#include "library\lowlevel\intrctrl.h"
#include "library\general\asncstrm.h"
#include "..\..\clocks\generic\clocks.h"
#include "..\..\audio\generic\audiodac.h"
#if VIONA_VERSION
#include "..\generic\mp2spudc.h"
#endif

#include "..\generic\mp2eldec.h"
#include "..\generic\mp2vsprs.h"

#define NOT_IMPLEMENTED_YET	0

class FrameParameters
	{	
	public:
		BYTE				pfh, pfv, ppr1, ppr2;
		
		MPEG2FrameType				frameType;		
		MPEG2PictureStructure   fieldType;
		
		BOOL				repeatFirstField;
		BOOL				topFieldFirst;
		BOOL				progressiveFrame;
		BOOL				skipped;
		BOOL				enabled;
		DWORD				temporalReference;
		DWORD				streamPosition;
		DWORD				pts;
		int				centerVerticalOffset;
		int				centerHorizontalOffset;
		BYTE				intraQuant[64];
		BYTE				nonIntraQuant[64];
				
		Error Init(MPEG2VideoHeaderParser	* params, DWORD streamPosition, DWORD pts, BYTE * intraQuant, BYTE * nonIntraQuant);
	};

class FrameParameterQueue
	{	
	private:
		FrameParameters	*	params;
		WORD	num, first, last;
	public:
		FrameParameterQueue(WORD size);
		virtual ~FrameParameterQueue(void);
		
		Error Reset(void);
		Error InsertFrame(MPEG2VideoHeaderParser * parser, DWORD streamPosition, DWORD pts, BYTE * intraQuant, BYTE * nonIntraQuant);
		Error MarkSkipped(void);
		BOOL IsSkipped(void);
		Error GetFrame(FrameParameters __far &params);
		Error GetNextFrame(FrameParameters __far &params);
		Error NextFrame(void);
		WORD FrameAvail() {return (first <= last) ? (last - first) : (num + last - first);}
	};

class STi7000MPEG2VideoHeaderParser : public MPEG2VideoHeaderParser
	{
	private:
		ByteIndexedInputPort	*	port;
		BOOL							odd;         
		BOOL							even;
		BYTE							second;
		Error WaitForFIFONonEmpty(WORD timeOut);
		
	protected:
		Error BeginParse(void);
		Error NextByte(void);
		Error EndParse(void);

		Error ParsePictureHeader(void);	
	public:
		BOOL	skipHeader;
		
		STi7000MPEG2VideoHeaderParser(ByteIndexedInputPort	*	port);
	};

class STi7000MPEG2Decoder;
		
class STi7000MPEG2Decoder : public MPEG2VideoDecoder, protected InterruptHandler, protected ASyncRefillRequest
#if VIONA_VERSION
                             ,public OSDDisplay
#endif                             
	{
	friend class VirtualSTi7000MPEG2Decoder;
	friend class STi7000VBlankIntServer;

	private: 
		
		void HaltOnError(Error error);
		Error SetPowerDownMode(void);
		Error ResetPowerDownMode(void);

	protected:
        Profile * profile;
		//
		// Basic IO operations
		//
		ByteIndexedInOutPort	*	port;
		
		Error OutByte(int idx, BYTE val);                             
		Error InByte(int idx, BYTE __far&val);

		//
		// to avoid double index programming
		//
		Error OutWordHL(int idx, WORD val);
		Error OutWordLH(int idx, WORD val);
		Error OutWordHL0(int idx, WORD val);
		Error InWordHL(int idx, WORD __far& val);		
		
		Error OutDWordHL(int idx, DWORD val);
		Error OutDWordLH(int idx, DWORD val);
		Error OutDWordHL0(int idx, DWORD val);
		Error InDWordHL(int idx, DWORD __far& val);
		
		Error SetBitB(int adr, int pos, BOOL val);
		Error SetBitB(int adr, int pos, int num, BYTE val);		
		Error SetBitW(int adr, int pos, BOOL val);
		Error SetBitW(int adr, int pos, int num, WORD val);		
		Error SetBitD(int adr, int pos, BOOL val);
		Error SetBitD(int adr, int pos, int num, DWORD val);		

		Error WriteMem(DWORD at, DWORD high, DWORD low);
		Error WriteMemBlock(DWORD at, DWORD num, const DWORD __far * data);
		Error ReadMem(DWORD at, DWORD __far & high, DWORD __far & low);
		Error WriteMemWord(DWORD at, DWORD num, const WORD __far * data);
		
		ProgrammableClockGenerator	*	audioClock;
	
		int	lastIPBuffer, curIPBuffer, curDBuffer, curBBuffer, lastBBuffer, delayedDBuffer;
		MPEG2FrameType	previousFrameType;
		DWORD	lastTempReference;
		
		WORD 					IBPBuffersY[4], IBPBuffersUV[4];
		DWORD					bufferStreamPos[4];
		BOOL					bufferValid[4];
		FrameParameters	bufferParams[4];
		FrameParameters	currentDisplayParams;
		FrameParameters	currentDecodingParams;
		FrameParameters	currentParams;
		FrameParameters	lastParams;
		
		PTSCounter			ptsCounter;
		
		DWORD					currentPTS;
		DWORD					lastDecodePTS;
//		DWORD					ptsTimeOffset;
//		DWORD					ptsStopTimeOffset;
		
		DWORD	signalPosition;
		DWORD	predFrameStreamPos;
		DWORD	currentFrameStreamPos;
		DWORD	fvcoFreq;
		
		DWORD	cdcnt;		// 32 bit counter into bit buffer                         
		DWORD	scdcnt;		// 32 bit counter into header FIFO
		DWORD	cdoffset;

		BOOL	prevOdd;
		BOOL	currentOdd;
		BOOL	currentTopFirst;
		BOOL	progressiveScan;
		BOOL	doubleFrame;
		BOOL	missingInterrupt;
		BOOL	freezeFrameData;
      BOOL  avSyncEnable; 
      BOOL  osdEnable; 
      BOOL  statusPrintEnable;
      BOOL  ptsPrintEnable;
		DWORD bufferLevel;
				
		DWORD frameCnt;
		DWORD statusPrints;
		
		//just for catching the command pending deadlock!!!!
		int	tempInterruptCounter; 
		
		DWORD streamPosition;
		DWORD streamOffset;
		
		FrameParameterQueue					frames;
		MPEG2FrameType							curFrame;  
		MPEG2FrameType							lastFrame;  
		STi7000MPEG2VideoHeaderParser		parser;
		PTSAssoc									ptsAssoc;
		DWORD										last_vidpts;
		DWORD										last_audpts;
		long										conformPTS;
		BOOL										conformPTSValid;
		
		WORD										bitBufferSize;
		
		DWORD										frameSize;
		DWORD										totalFrameSize;
		DWORD										osdBase, osdBaseX;
		DWORD										osdSize, osdSizeX;
		BOOL										osdLimitation;
		
		WORD										bbfWatchdog;
		WORD										predVBL;
		WORD										bbeWatchdog;
		WORD										pidWatchdog;
		WORD										skipWatchdog;
		WORD										freezeWatchdog;
		int										decodeWatchdog;
		
		WORD										bitBufferThreshold;
		
		WORD										bitBufferFill;
		
		DWORD										lastIFramePosition;
		DWORD										lastGOPPosition;
		DWORD										lastSequenceHeaderPosition;
		DWORD										lastRestartPosition;
		DWORD										doc;	// data output counter
		DWORD										next_doc;
		
		BYTE										cnt;

		ASyncOutStream						*	strm;
		InterruptServer					*	irqServer;
//	protected:                      
		DWORD irqmask;
		                      
		Error SelectIBPBuffers(MPEG2FrameType type, int __far& rfp, int __far& ffp, int __far& bfp);
		Error SelectDFPBuffer(MPEG2FrameType type, int __far& dfp);
		Error ProgramIBPBuffers(int rfp, int ffp, int bfp);                         
		Error ProgramDFPBuffer(int dfp);
		
		Error ReadSCDCount(DWORD __far&val);
		Error LastSCDCount(DWORD __far&val);
		Error ReadCDCount(DWORD __far&val);
		Error LastCDCount(DWORD __far&val);
		
		Error ReadStatus(DWORD __far&status);
		
		DWORD	interruptGhost;
		DWORD its;
		
		Error ReadInterruptStatus(DWORD __far&status);
		Error ReadInterruptMask(DWORD __far&status);
		Error InitInterruptMask(DWORD mask);
		Error WriteInterruptMask(DWORD mask);
		Error SetInterruptMask(DWORD set);
		Error ResetInterruptMask(DWORD reset);
		Error SetIrqMaskReg(DWORD set);
		Error ResetIrqMaskReg(DWORD reset);
		Error ClearInterruptStatus(DWORD mask);
				
#if WDM_VERSION
		//following variables only valid for 32bit-version
		KTIMER	interruptWatchDogTimer;				// timer that checks the existence of interrupts
		KDPC		interruptWatchDogDPC;
		LARGE_INTEGER	intErrorTime;
#endif
		
		int			hoffset, voffset, panScanOffset;
//		WORD			picLeft, picTop;
		WORD			frameWidth, frameHeight;
//		WORD			picWidth, picHeight;
		WORD			frameAspectRatio;
		VideoMode	displayMode;
		BYTE			frameRate;
		BOOL			progressiveSequence;
		WORD			activeLeft, activeTop, activeWidth, activeHeight;
		
#if VIONA_VERSION
		MPEG2PresentationMode presentationMode;
#endif		
		
		Error RebuildDisplayRect(void);
		
		int display_pixels, picture_pixels, blank_pixels, screen_pixels, sync_pixels, outside_pixels;
		int display_lines, picture_lines, blank_lines, screen_lines, sync_lines, outside_lines;
		BOOL progressive_input, progressive_output;
				
		Error ProgramDisplayRect(WORD fwidth, WORD fheight, WORD fratio, BYTE frate, BOOL progressive);
		Error ConfigureVideoBus(void);
#if VIONA_VERSION		
		Error SetPanScanOffset(int offset);
#endif		
		Error WriteQuantizerMatrix(BOOL nonIntra, BYTE __far * matrix);
		Error SetDisplayMode(VideoMode videoMode);

#if VIONA_VERSION		
        Error SetPresentationMode(MPEG2PresentationMode presentationMode);
        Error ReadRegistryEntries(void);
#endif		
		
		Error ProgramInitalFrameChipParameters(void);
		Error StartFrameDecoding(void);
		Error SkipFrameDecoding(void);
		Error StopFrameDecoding(void);
		Error StartFrameDisplay(void);
//		Error SkipFrameDisplay(void);
		Error CompleteFrameDisplay(void);
		Error SendFakeHeader(void);
		Error BeginSeek(void);
		Error BeginCue(void);
		Error CompleteSeek(DWORD offset);
		Error InternalSeek(void);
		
		Error HeaderInterrupt(void);
		Error DSyncInterrupt(void);
		Error VSyncInterrupt(BOOL top);
		Error BitBufferFullInterrupt(void);
		void  SemanticOrSyntaxErrorInterrupt(DWORD interruptStatus);

		Error BeginDecoding(void);		// initialize chip for decoding
		Error StartDecoding(void);		// start decoding
		Error RestartDecoding(void);	// restart decoding after soft reset
		Error StopDecoding(void);		// stop decoding
		Error EndDecoding(void);		// reset chip after decoding
				
		//
		// Forward the refill request
		//
		void RefillRequest(DWORD free);

		void Interrupt(void);                       
		
		DWORD	stateCnt;
		int   startCodeHitWatchDog; 	// watch dog for start code hit interrupt
		int	headerIntWatchDog;		// watch dog for frame decoding 
		int	watchDog;
		int	scanWatchDog;
		int	adaptDelay;
		BOOL	framePending;
		BOOL	startDecodeTriggered;	// TRUE - last interrupt was dsync ---> next one should be a start code hit interrupt
												// FALSE - dsync interrupt not detected (set to false if a start code hit was detected)
		BOOL	skipRequest;      
		BOOL	freezeRequest;
		BOOL	lastSkipped;                          
		BOOL	skipTillHeader;
		BOOL	execute;
		BOOL	decodeNext;
		BOOL	overfull;
		BOOL	initialParametersSent;
		BOOL	streamCompleted;
		BOOL	hasValidFrame;
		BOOL	bFrameOptimization;
		BOOL	closedGOP;
		BOOL	endCodeReceived;
		BOOL	sequenceHeaderFound;
		int	notIdleVSyncCounter;
		BOOL	decodePending;
		BOOL	decodeError;
		BOOL	doubleShot;
		
		WORD	currentFrameHeight;
		WORD	currentFrameWidth;
		WORD	currentFrameRate;
		WORD	currentAspectRatio;
				
		long	frameNominator;
		long	frameDenominator;
		long	frameAccu;
		WORD	playbackSpeed;
								
		enum XState
			{
			xreset,                                //  0
			xinit_waitForFirstPictureHeader,       //  1
			xinit_waitForBitBufferFull,            //  2
			xinit_waitForStartSync,                //  3
			xinit_waitForThirdFrame,               //  4
			xfrozen,                               //  5
			xplaying,                              //  6
			xplayingRepeat0,                       //  7
			xplayingRepeat1,                       //  8 
			xplayingRepeat2,                       //  9
			xplayingRepeat3,                       // 10
			xstopped,                              // 11
			xseeking,                              // 12
			xresync_waitForFirstPictureHeader,     // 13
			xresync_waitForBitBufferFull,          // 14
			xresync_waitForStartSync,              // 15
			xresync_waitForThirdFrame,             // 16
			xresync_prefreeze1,                    // 17
			xresync_prefreeze2,                    // 18
			xplaying_recover,                      // 19
			xstepping,                             // 20
			xstarving,                             // 21
			xcueing,                               // 22
			xresyncue_waitForFirstPictureHeader,   // 23
			xresyncue_waitForBitBufferFull,        // 24
			xresyncue_waitForStart,                // 25
			xstill,                                // 26
			xplayingStill,                         // 27
			xscan_waitForFirstPictureHeader,       // 28
			xscan_waitForBitBufferFull,            // 29
			xscan_waitForStartSync,                // 30
			xscan_decoding,                        // 31
			xdecodeError,                          // 32
			xfrozen_waitForBitBufferFull				// 33
			} xstate;
		
		XState lastxstate;

	   friend XState operator ++(XState __far& x, int a) {return (XState)(((int __far&)x)++);}
	   
	   DWORD GetPTS(void);
	   void PutPTS(DWORD pts);
	   Error ConformToPTS(DWORD pts);

		Error SetPlaybackTime(LONG time);
      
      MPEG2CommandQueue	commandQueue;
      
	   Error SendCommand(MPEGCommand com, DWORD param, DWORD __far &tag);
		BOOL CommandPending(DWORD tag);
	
		DWORD CurrentLocation(void);
		MPEGState CurrentState(void);
		DWORD LastTransferLocation(DWORD scale);
			   
	   DWORD SendData(HPTR data, DWORD size);
#if VIONA_VERSION
		MPEG2PESType NeedsPES(void) {return dvdStreamEncrypted ? MP2PES_DVD : MP2PES_ELEMENTARY;}
		Error SendPESData(HPTR data, DWORD size, DWORD __far & done, DWORD __far & used);
#endif
	   void CompleteData(void);
	
		VideoStandard	videoStandard;    
		BOOL mpeg2Coding;
      
      Error ReconfigureBuffers(void);
      
	   Error SetSignalPosition(DWORD position);
		Error SetVideoBitrate(DWORD videoBitrate);
		Error SetAudioBitrate(DWORD audioBitrate);
		Error SetVideoWidth(WORD width);
		Error SetVideoHeight(WORD height);
		Error SetAspectRatio(WORD aspectRatio);
		Error SetVideoStandard(VideoStandard	standard);
		Error SetVideoFPS(WORD fps);
		Error SetMPEG2Coding(BOOL mpeg2Coding);
		
		BOOL	vblankServerEnabled;      
		
		Error EnableVBlankServer(void);
		Error DisableVBlankServer(void);
		
		VirtualUnit	*	videoBus;
		
		Error Lock(VirtualUnit * unit);
		Error Unlock(VirtualUnit * unit);

#if VIONA_VERSION		
	protected:
		WORD  osdHeader[32];
		WORD	osdNumColors;
		BOOL	osdValid, osdEnabled, osdHighColor;
		WORD	osdX, osdY, osdW, osdH;
		WORD	osdPalette[16];
		BYTE	osdTransparency[16];
		BYTE	osdColors[16];
		DWORD	osdHeight, osdWidth;
		
		WORD	rowStart;
		WORD	rowStop;
		WORD	columnStart;
		WORD	columnStop;
		BOOL	trueColor;
		BOOL	useExistPalet;
		WORD	bytesPerLine;
		BOOL	highPalet;
		BOOL	lineDoubling;
		BYTE	resMode;
		BYTE	mixWeight;
		BOOL	compressPel;
		BYTE	runLength;
		DWORD	curHeaderPtr;
		DWORD	nextHeadPtr;
		DWORD	osdBotDaPtr;
		DWORD	osdTopDaPtr;
		BOOL	T[16];
		BOOL	B[16];
		BYTE	Y[16];
		BYTE	Cb[16];
		BYTE	Cr[16];
		
		
				
		Error WriteOSDHeader(void);
		
	public:
		Error KillOSDBitmap(void);     
	   Error SetOSDBitmap(WORD numColors,
	   					    BYTE __far * colorTable, BYTE __far * contrastTable,
	                      WORD x, WORD y, WORD width, WORD height,
	                      DWORD __huge * odd, DWORD __huge * even);
	
		Error SetOSDPalette(int entry, int y, int u, int v);	                                   
		
		Error ShowOSD(BOOL enable);
#endif		
	public:
		InterruptServer	*	vblankServer;
		PTSCaller	ptsCaller;
		
		STi7000MPEG2Decoder(ByteIndexedInOutPort 	* 	port,
		                    ASyncOutStream       	* 	strm,
		                    InterruptServer			*	irqServer,
		                    VirtualUnit				*	videoBus = NULL,
                            Profile				    *	profile = NULL);
		~STi7000MPEG2Decoder(void);
		
		Error Configure(TAG __far * tags);
      
      Error Initialize(void);
		Error Uninitialize(void);
		Error OSDtestPattern(void);
      
#if NOT_IMPLEMENTED_YET		
		Error InitClockGenerator(STi7000ClockSource source, WORD nominator, WORD denominator, DWORD freq);
		Error ProgramClockGenerator(STi7000Clock clock, BOOL external, DWORD freq);
		Error ConfigureMemory(BYTE busWidth, 
									 BOOL preventBitBufferOverflow,
									 BOOL enable,
									 BOOL	segmentsPerRow,
									 BOOL	edoRam,
									 BOOL	sdRam,
									 BOOL	meg20,
									 BYTE refreshInterval);
#endif
		BOOL CheckChipInitialisation(void);
		Error ConfigureBuffers(void);
		Error SoftReset(void);											 
		Error InterruptWatchDogRoutine(void);
		
		VirtualUnit * CreateVirtual(void);		
   };

#if WDM_VERSION
void	InterruptWatchDogCallback(PKDPC deferredProcCall, PVOID deferredContext, PVOID sysArgFirst, PVOID sysArgSecond);		
#endif

class VirtualSTi7000MPEG2Decoder : public VirtualMPEG2VideoDecoder
	{
	private:
		STi7000MPEG2Decoder	*	decoder;
	protected:                                
      Error PreemptStopPrevious(VirtualUnit * previous);
      Error PreemptChange(VirtualUnit * previous);
      Error PreemptStartNew(VirtualUnit * previous);

		Error GetDisplaySize(WORD __far &width, WORD __far &height);
		
		BOOL						initial;		

		struct 
			{
			WORD						width;
			WORD						height;
			BYTE						aspectRatio;
			WORD						aspectRatioFactor;
			BYTE						frameRate;
			DWORD						bitRate;
			DWORD						vbvBufferSize;
			MPEG2CodingStandard	codingStandard;	
			BYTE						intraQuantMatrix[64];
			BYTE						nonIntraQuantMatrix[64];           
			BYTE						chromaIntraQuantMatrix[64];
			BYTE						chromaNonIntraQuantMatrix[64];           
			} parser;

		VideoMode	displayMode;
		
	public:
		VirtualSTi7000MPEG2Decoder(STi7000MPEG2Decoder * unit);

#if VIONA_VERSION
		MPEG2PESType NeedsPES(void) {return MP2PES_ELEMENTARY;}
#endif
		
		Error Configure(TAG __far * tags);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\specific\sti4600r.h ===
// FILE:			library\hardware\mpeg3dec\specific\sti4600r.h
// AUTHOR:		Viona
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		05.12.95
//
// PURPOSE:		
//
// HISTORY:
#ifndef STI4600R_H
#define STI4600R_H

#define I4600REG_VERSION		0x00
#define I4600REG_IDENT			0x01

#define I4600REG_FBADDRL		0x02
#define I4600REG_FBADDRH		0x03
#define I4600REG_FBDATA			0x04

#define I4600REG_SFREQ			0x05
#define I4600REG_EMPH			0x06

#define I4600REG_INTEL			0x07
#define I4600REG_INTEH			0x08
#define I4600REG_INTL			0x09
#define I4600REG_INTH			0x0a
#define I4600REG_SETINT			0x0b

#define I4600INTIDX_SYNC		0
#define I4600INTIDX_HEADER		1
#define I4600INTIDX_ERROR		2
#define I4600INTIDX_SFREQ		3
#define I4600INTIDX_DEEMPH		4
#define I4600INTIDX_BOF			5
#define I4600INTIDX_PTS			6
#define I4600INTIDX_ANC			7
#define I4600INTIDX_PCM			8
#define I4600INTIDX_FBFULL		9
#define I4600INTIDX_FBEMPTY	10
#define I4600INTIDX_FIFO		11
#define I4600INTIDX_BREAK		15

#define I4600REG_SINSETUP		0x0c

#define I4600IDX_INPUTSETUP	0, 2
#define I4600IDX_REQPOL			2

#define I4600INSET_PARALLEL	0
#define I4600INSET_SERIAL		1
#define I4600INSET_ANALOG		3

#define I4600REG_CANSETUP		0x0d

#define I4600CANSET_PADDING	0
#define I4600CANSET_LEFT1		1
#define I4600CANSET_FALLEDGE	2
#define I4600CANSET_SLOTCNT32	3

#define I4600REG_DATAIN			0x0e
#define I4600REG_ERROR			0x0f
#define I4600REG_RESET			0x10

#define I4600REG_PLLSYS			0x11

#define I4600IDXPLL_BYPASS		6
#define I4600IDXPLL_DISABLED	5
#define I4600IDXPLL_DIV			0, 4

#define I4600REG_PLLPCM			0x12

#define I4600REG_PLAY			0x13
#define I4600REG_MUTE			0x14
#define I4600REG_REQ				0x15
#define I4600REG_ACK				0x16
#define I4600REG_RUN				0x72

#define I4600REG_SYNCSTATUS	0x40

#define I4600IDX_FRAMESTATUS	0, 2

#define I4600FRMSTAT_SEARCH	0
#define I4600FRMSTAT_WAIT		1
#define I4600FRMSTAT_SYNC		2

#define I4600IDX_PACKETSTATUS	2, 2

#define I4600PCKSTAT_SEARCH	0
#define I4600PCKSTAT_WAIT		1
#define I4600PCKSTAT_SYNC		2

#define I4600REG_ANCCOUNT		0x41
#define I4600REG_HEAD24			0x42
#define I4600REG_HEAD16			0x43
#define I4600REG_HEAD8			0x44
#define I4600REG_HEAD0			0x45
#define I4600REG_PTS33			0x46
#define I4600REG_PTS24			0x47
#define I4600REG_PTS16			0x48
#define I4600REG_PTS8			0x49
#define I4600REG_PTS0			0x4a
#define I4600REG_USER1			0x4b

#define I4600REG_STREAMSEL		0x4c

#define I4600STRSEL_PES			0
#define I4600STRSEL_PESDVD		1
#define I4600STRSEL_PACKMPEG1	2
#define I4600STRSEL_ELEMNTRY	3

#define I4600REG_DECODESEL		0x4d

#define I4600DECSEL_AC3			0
#define I4600DECSEL_MPEG		1
#define I4600DECSEL_MPEGEXT	2                                                                
#define I4600DECSEL_LPCM		3

#define I4600REG_PACKETLOCK	0x4f
#define I4600REG_AUDIOIDEN		0x50
#define I4600REG_AUDIOID		0x51
#define I4600REG_AUDIOIDEXT	0x52
#define I4600REG_SYNCLOCK		0x53

#define I4600REG_PCMDIVIDER	0x54
#define I4600REG_PCMCONFIG		0x55
#define I4600REG_PCMCANCEL		0x7e

#define I4600IDX_PCMORDER		6
#define I4600IDX_PCMDIFF		5
#define I4600IDX_INVLRCLK		4
#define I4600IDX_I2S				3	// doku says i2c ???
#define I4600IDX_INVSCLK		2
#define I4600IDX_PCMPREC		0, 2

#define I4600PCMPREC_16			0
#define I4600PCMPREC_18			1
#define I4600PCMPREC_20			2
#define I4600PCMPREC_24			3

#define I4600REG_PCMCROSS		0x56
#define I4600REG_PCMFCROSS		0x7f

#define I4600REG_LDLY			0x57
#define I4600REG_RDLY			0x58
#define I4600REG_CDLY			0x59
#define I4600REG_SUBDLY			0x5a
#define I4600REG_LSDLY			0x5b
#define I4600REG_RSDLY			0x5c
#define I4600REG_DLYUPDATE		0x5d

#define I4600REG_IEC958			0x5e

#define I4600IECMD_OFF			0
#define I4600IECMD_MUTED		1
#define I4600IECMD_PCM			2
#define I4600IECMD_ENCODED		3

#define I4600REG_IEC958CAT		0x5f
#define I4600REG_IEC958CONF1	0x60

#define I4600IDX_IECDIV			0, 5
#define I4600IDX_IECIDLESTATE	5
#define I4600IDX_IECSYNCMT		6

#define I4600REG_IEC958CONF2	0x61

#define I4600IDX_IEC44KHZ		3
#define I4600IDX_IECPREEMPH	2
#define I4600IDX_IECCOPY		1
#define I4600IDX_IECCOMPRESS	0

#define I4600REG_IEC958LEN0	0x75

#define I4600REG_PDEC			0x62
#define I4600REG_PLMOD			0x63

#define I4600PLMOD_NORMAL		0
#define I4600PLMOD_HALL			1
#define I4600PLMOD_MATRIXED	2

#define I4600REG_PLAB			0x64
#define I4600REG_PLDWNX			0x65

#define I4600PLDWNX_DISABLED	0
#define I4600PLDWNX_3_0			3
#define I4600PLDWNX_2_1			4
#define I4600PLDWNX_3_1			5
#define I4600PLDWNX_2_2			6
#define I4600PLDWNX_3_2			7

#define I4600REG_OCFG			0x66

#define I4600OCFG_QUANTRNDPCM	0
#define I4600OCFG_SUMLFREQ		1
#define I4600OCFG_LPONC			2
#define I4600OCFG_NOHP			3
#define I4600OCFG_SUMCHNL		4
#define I4600OCFG_NOPROCESS	5
#define I4600OCFG_QUANTRND		6

#define I4600REG_BAL_LR			0x4e
#define I4600REG_BAL_SUR		0x63
#define I4600REG_PCMSCALE		0x67

#define I4600REG_LFE				0x68
#define I4600REG_COMPMOD		0x69

#define I4600CMPMOD_LINEOUT	0
#define I4600CMPMOD_RFMODE		1
#define I4600CMPMOD_CUSTOM1	2
#define I4600CMPMOD_CUSTOM2	3

#define I4600REG_HDR				0x6a
#define I4600REG_LDR				0x6b
#define I4600REG_RPC				0x6c
#define I4600REG_KARAMODE		0x6d

#define I4600KARAMD_AWARE		0
#define I4600KARAMD_MLTCHANL	3
#define I4600KARAMD_DOWNMIX	7
#define I4600KARAMD_REPRDC_1	5
#define I4600KARAMD_REPRDC_2	6
#define I4600KARAMD_REPRDC_12	4

#define I4600REG_DUALMODE		0x6e

#define I4600DLMD_STEREO		0
#define I4600DLMD_CHANNEL1		1
#define I4600DLMD_CHANNEL2		2
#define I4600DLMD_MIX			3

#define I4600REG_DOWNMIX		0x6f

#define I4600DWNMX_2_0_COMP	0
#define I4600DWNMX_1_0			1
#define I4600DWNMX_2_0			2
#define I4600DWNMX_3_0			3
#define I4600DWNMX_2_1			4
#define I4600DWNMX_3_1			5
#define I4600DWNMX_2_2			6
#define I4600DWNMX_3_2			7

#define I4600REG_AC3STAT0		0x76

#define I4600IDX_FSCOD			5, 2
#define I4600IDX_FRMSZCOD		0, 5

#define I4600REG_AC3STAT1		0x77

#define I4600IDX_LFEPRESENT	3
#define I4600IDX_ACMOD			0, 3

#define I4600REG_AC3STAT2		0x78

#define I4600IDX_BSMOD			5, 3
#define I4600IDX_BSID			0, 5

#define I4600REG_AC3STAT3		0x79

#define I4600IDX_CMIXLEVEL		2, 2
#define I4600IDX_SURMIXLEVEL	0, 2

#define I4600REG_AC3STAT4		0x7a

#define I4600IDX_DSURMOD		3, 2
#define I4600IDX_COPYRIGHT		2
#define I4600IDX_ORIGBS			1
#define I4600IDX_LANGCODE		0

#define I4600REG_LANGCODE		0x7b
#define I4600REG_DIALNORM		0x7c
#define I4600REG_AC3STAT7		0x7d

#define I4600IDX_ROOMTYPE		6, 2
#define I4600IDX_MIXLEVEL		1, 5
#define I4600IDX_AUDPRODIE		0

#define I4600REG_SKIPFRAME		0x73
#define I4600REG_REPEATFRAME	0x74
#define I4600REG_DWSMODE		0x70
#define I4600REG_SOFTVER		0x71


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\specific\tl850cur.h ===
// FILE:			library\hardware\mpeg2dec\specific\tl850cur.h
// AUTHOR:		Martin Stephan
// COPYRIGHT:	(c) 1999 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		29.06.99
//
// PURPOSE:		TL850 MPEG-2 decoder cursor settings
//
// DESCRIPTION:	a cursor is defined as a 32*32 bitmap on the screen. In this header file
//						some cursor looks are defined. 
//

#ifndef TL850CUR_H
#define TL850CUR_H
 
#define CURSOR_BASE_ADDRESS	0x01fffe00

unsigned long arrow[128] = 
	{
	0x11111111, 0x11111110, 0x01111111, 0x11111111,
	0x11111111, 0x11111000, 0x00011111, 0x11111111,
	0x11111111, 0x11100000, 0x00000111, 0x11111111, 
	0x11111111, 0x10000000, 0x00000001, 0x11111111, 
	0x11111110, 0x00000000, 0x00000000, 0x01111111, 
	0x11111000, 0x00000000, 0x00000000, 0x00011111,
	0x11111111, 0x11100000, 0x00000111, 0x11111111,
	0x11111111, 0x11100000, 0x00000111, 0x11111111,
	0x11111111, 0x11100000, 0x00000111, 0x11111111,
	0x11111111, 0x11100000, 0x00000111, 0x11111111,
	0x11111111, 0x11100000, 0x00000111, 0x11111111,
	0x11111111, 0x11100000, 0x00000111, 0x11111111,
	0x11111111, 0x11100000, 0x00000111, 0x11111111,
	0x11111111, 0x11100000, 0x00000111, 0x11111111,
	0x11111111, 0x11100000, 0x00000111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111};

unsigned long smiley[128] =
	{
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111000, 0x00001111, 0x11111111,
	0x11111111, 0x11100111, 0x11110011, 0x11111111, 
	0x11111111, 0x11011111, 0x11111101, 0x11111111, 
	0x11111111, 0x10111111, 0x11111110, 0x11111111, 
	0x11111111, 0x01111111, 0x11111111, 0x01111111,
	0x11111110, 0x11111111, 0x11111111, 0x10111111,
	0x11111110, 0x11111011, 0x11101111, 0x10111111,
	0x11111101, 0x11111111, 0x11111111, 0x11011111,
	0x11111101, 0x11111111, 0x11111111, 0x11011111,
	0x11111101, 0x11111111, 0x01111111, 0x11011111,
	0x11111101, 0x11111111, 0x01111111, 0x11011111,
	0x11111101, 0x11111111, 0x11111111, 0x11011111,
	0x11111101, 0x11111011, 0x11101111, 0x11011111,
	0x11111110, 0x11111101, 0x11011111, 0x10111111,
	0x11111110, 0x11111110, 0x00111111, 0x10111111,
	0x11111111, 0x01111111, 0x11111111, 0x01111111,
	0x11111111, 0x10111111, 0x11111110, 0x11111111,
	0x11111111, 0x11011111, 0x11111101, 0x11111111,
	0x11111111, 0x11100111, 0x11110011, 0x11111111,
	0x11111111, 0x11111000, 0x00001111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111,
	0x11111111, 0x11111111, 0x11111111, 0x11111111};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\specific\zr385xx.h ===
// FILE:			library\hardware\mpeg3dec\specific\zr385xx.h
// AUTHOR:		Viona
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		05.12.95
//
// PURPOSE:		
//
// HISTORY:
#ifndef ZR385XX_H
#define ZR385XX_H

#include "..\generic\mp2eldec.h"
#include "zr38spi.h"
#include "library\hardware\audio\generic\audiodac.h"
#include "library\lowlevel\hardwrio.h"
#include "library\general\asncstrm.h"  
#include "library\lowlevel\intrctrl.h"
#include "library\general\dynarray.h"
#include "library\common\krnlstrm.h"
#include "library\hardware\clocks\generic\clocks.h"

class ZR385XXAC3Decoder : public MPEG2AC3Decoder, 
                          protected ZR385XXSPIComPort, 
                          protected ASyncRefillRequest,
                          protected InterruptHandler
	{
	friend class VirtualZR385XXAC3Decoder;
	protected:
		VirtualAudioDAC	*	dac; 
		ASyncOutStream		*	strm;
		
		DWORD 		initialPTS;
		DWORD			audioBitrate;
		BOOL			ptsValid;                                                   
		MPEGState	state;
		BOOL			ac3;
		BYTE			ac3StreamID;
		PTSAssoc		ptsAssoc;
		DWORD			streamPosition;
      
		DWORD			signalPosition;
		DWORD			predPosition;
				
		DWORD			stepCnt;
		
		AC3Params	ac3Params;
		PROLParams	prolParams;
		PCMParams	pcmParams;
		
		VirtualUnit	*	audioBus;
		
		AC3BassConfig		pBassConfig, bassConfig;
		AC3SpeakerConfig  pSpeakerConfig, speakerConfig;
		WORD					pCenterDelay, centerDelay;
		WORD					pSurroundDelay, surroundDelay;
		
		DynamicByteArray	mpegMicrocode, ac3Microcode;
		ProgrammableClockGenerator	*	audioClock;
		
		Error UpdateAudioParameter(void);
		
		Error SetAudioBitrate(DWORD bitrate);
		Error SetSampleRate(WORD rate);
		Error SetLeftVolume(WORD volume);
		Error SetRightVolume(WORD volume);
		Error SetMute(BOOL mute);
		Error SetAC3(BOOL ac3);

		Error SetBassConfig(AC3BassConfig config);
		Error SetSpeakerConfig(AC3SpeakerConfig config);
		Error SetCenterDelay(WORD delay);
		Error SetSurroundDelay(WORD delay);      
		
		Error SetCenterVolume(WORD volume);
		Error SetLeftSurroundVolume(WORD volume);
		Error SetRightSurroundVolume(WORD volume);
		Error SetSubwooferVolume(WORD volume);

	   Error SendCommand(MPEGCommand com, DWORD param, DWORD __far &tag);
		BOOL CommandPending(DWORD tag);

		DWORD CurrentLocation(void);
		MPEGState CurrentState(void);
		
		DWORD LastTransferLocation(DWORD scale);
			   
	   DWORD GetPTS();
	   DWORD SendData(HPTR data, DWORD size);
	   void CompleteData(void);
	
	   void PutPTS(DWORD pts);
	   
		//
		// Forward the refill request
		//
		void RefillRequest(DWORD free);
		void Interrupt(void);

	   Error SetSignalPosition(DWORD position);

		Error Configure(TAG __far * tags);
		
		InterruptServer	*	vblank;	
	public:
		ZR385XXAC3Decoder(BitInputPort		*	si,
					         BitOutputPort		*	ss,
					         BitOutputPort		*	sck,
					         BitOutputPort		*	so,
					         int						delay,
					         VirtualAudioDAC 	*	dac,
					         ASyncOutStream		*	strm,
					         InterruptServer	*	vblank,
					         VirtualUnit			*	audioBus = NULL,
					         ProgrammableClockGenerator * audioClock = NULL);
		        
		VirtualUnit * CreateVirtual(void);
		
		Error Boot(const char * name);
		Error LoadMicrocodes(KernelString ac3Name, KernelString mpegName);		
	};

class VirtualZR385XXAC3Decoder : public VirtualMPEG2AC3Decoder
	{
	private:
		ZR385XXAC3Decoder	*	device;
	protected:
      Error PreemptStopPrevious(VirtualUnit * previous);
      Error PreemptStartNew(VirtualUnit * previous);		
	public:
		VirtualZR385XXAC3Decoder(ZR385XXAC3Decoder * device);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2enc\generic\meminfo.h ===
//
// FILE:       library\hardware\mpeg2enc\generic\meminfo.h
// AUTHOR:		Martin Stephan
// COPYRIGHT:	(c) 1999 Viona Development GmbH.  All Rights Reserved.
// CREATED:		15.11.1999
//
// PURPOSE: 	encoder memory info prepare class - interface
//
// HISTORY:
//

#ifndef MEMINFO_H
#define MEMINFO_H

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"
#include "library\lowlevel\kernlmem.h"

class EncoderMemoryInfo
	{
	public:				
		KernelMemory *kernelMem;
		//FragmentTableClass *frag;

		EncoderMemoryInfo(void);
		~EncoderMemoryInfo(void);

		Error PrepareMemory (FPTR buffer, DWORD size);
		Error AllocMemory (DWORD size, FPTR __far &data);
		Error FreeMemory (void);

		FPTR KernelSpace(void) {return kernelSpace;}

	protected:
		FPTR userSpace, kernelSpace;
	};

#endif // MEMINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\specific\tl850pid.h ===
/*
 * This file was generated automatically by mcuas.
 * Do not edit this file. Edit PID0x31.mcu instead.
 */
/*
 * This version is our approach to fix the PCI bus lockup issue.
 * We only got new instruction, not data.
 * Do not edit this file. Edit tsdNoByteStop.mcu instead.
 */
unsigned short PID0x31_instructions[1413] = {
	0x5061,0x0FA1,0x6002,0xF112,0xE911,0x5022,0x0B42,0xF112,0x6001,0x8041,0x6FF1,0x80D1,0x354A,0x8271,0x4181,0xF21D,
	0x1DF0,0xFF00,0x6001,0x8051,0x5021,0x0341,0x8061,0x6FF1,0x80D1,0x6001,0x80E1,0x353C,0x4291,0x4181,0x0401,0x8041,
	0xEB1D,0x1D0F,0x6002,0x8052,0x40E2,0xF22D,0x14F5,0xFF00,0x5C0D,0x0FFD,0xE1D1,0x8041,0x5011,0x0BC1,0x205A,0x6001,
	0x3527,0x4291,0x4052,0x65E1,0xEF12,0x12FB,0xFF00,0x3520,0x4291,0x4052,0x5011,0x0BD1,0xEF12,0x11FA,0xFF00,0x5011,
	0x01A1,0x5010,0x0800,0xFB03,0x6472,0xEF23,0x1906,0x5010,0x03C0,0xFB03,0xEF23,0x182C,0x5010,0x0810,0x5011,0x0BB1,
	0xFB03,0xA100,0xEF23,0x1809,0xE811,0x19FC,0xFB03,0x5011,0x0BC1,0x6001,0x2FBA,0x80E1,0x5022,0x0342,0xE312,0x8062,
	0x5011,0x0BC1,0x6001,0x80E1,0x5011,0x0BC1,0x4052,0xF422,0x10FF,0x4052,0xEF12,0x12FC,0x4052,0x5021,0x0341,0x8061,
	0x5010,0x0800,0xFB03,0x6472,0xEF23,0x199F,0xFF00,0x6001,0x80E1,0x4052,0x5011,0x07A1,0xEF12,0x11FF,0x4052,0x5020,
	0x0F80,0xFB03,0x6472,0xEF23,0x1990,0xFF00,0x5011,0x0BC1,0x81B1,0x41A2,0x6201,0xE112,0x8072,0x34CA,0x4291,0x4271,
	0x41B0,0xF211,0x1904,0xF2F1,0x1B00,0xF2F1,0x6001,0x3322,0x8271,0x5012,0x0BC2,0xF400,0x1909,0x5011,0x0761,0x4051,
	0xEF21,0x11EC,0xFF00,0x2017,0x81B2,0xEF20,0x190A,0x5021,0x0321,0x4051,0xE022,0xEF21,0x11E1,0xFF00,0x200C,0x81B2,
	0x5011,0x0BA1,0x4051,0x5012,0x0C22,0xEF21,0x12D7,0xFF00,0x6002,0x81B2,0x6001,0x80E1,0x32FD,0x0400,0x0400,0xFB03,
	0x6471,0xEF13,0x1808,0x6FF1,0x80D1,0x41A2,0x6401,0xE112,0x2F4A,0x8072,0x4191,0x41A2,0xE911,0x8191,0x5011,0xE121,
	0x8071,0xA103,0xFB33,0x41A2,0xED3D,0xEDDD,0x1D06,0x5011,0x0801,0xE121,0x2FB3,0x8071,0x61F2,0xE123,0xA202,0xFB22,
	0xED33,0xED33,0xF522,0xE523,0x5014,0x05A4,0x6FF5,0x6201,0xF042,0xE955,0xEF23,0x1807,0x0054,0xE811,0x19FB,0xF042,
	0x2F9D,0xFF00,0xA147,0xF077,0xA303,0xFB33,0xED3D,0xEDDD,0x1CF8,0xFF00,0x600A,0x6046,0xEE3D,0x1B10,0xA401,0xEC11,
	0xF011,0xF612,0xA526,0x180A,0xF51A,0xEDAD,0xEDDD,0x1D06,0x328B,0x6038,0x680D,0xF5DD,0xE5D7,0xF23B,0xE4FB,0xED7D,
	0xEDDD,0x1C47,0xEE3D,0x1405,0xE971,0xE4F1,0xEFB1,0x1841,0xF271,0xE4F1,0xEFB1,0x191E,0xEE3D,0x143F,0xA141,0xEE7D,
	0xECDD,0x1B14,0xF117,0xA441,0xF011,0x5E02,0xE121,0x190A,0x50C8,0x0F48,0x600A,0x32A7,0x6049,0x501E,0x08DE,0x2248,
	0x6018,0x501E,0x08DE,0x2260,0x6018,0x640D,0xE5D7,0x2F56,0xF117,0xA441,0xF011,0x5E02,0xE121,0x190A,0x50C8,0x0F48,
	0x600A,0x3291,0x6049,0x3234,0x6018,0x2004,0xFF00,0x324C,0x6028,0xA303,0xFB33,0xF23B,0xE4FB,0x600A,0x6046,0xEE3D,
	0x1B08,0xA401,0xEC11,0xF011,0xF612,0xA526,0x1802,0xF51A,0x5FF1,0x0301,0xE117,0xE5B7,0xF2AA,0x183B,0xA603,0xEEAD,
	0x1429,0xF041,0x41C2,0xEF21,0x1924,0x4081,0x4092,0x8221,0x40A1,0x8212,0x8201,0xEC31,0xF012,0xE911,0x81D2,0xF012,
	0xE911,0x81E2,0xF012,0x81F2,0x4051,0x41B2,0xE321,0x8231,0x4261,0xF211,0x180C,0x82A3,0x82BA,0x6388,0x6109,0x324F,
	0x603A,0x31F6,0x6078,0x42A3,0x2004,0x42BA,0x320D,0x6078,0xA633,0xECAD,0xECDD,0x1B02,0xA633,0xECAD,0x1B0A,0xFB31,
	0xE933,0xF211,0x1906,0x680D,0xF5DD,0xE5D7,0x31FD,0x6058,0xEE7D,0x1406,0xEEAD,0xECDD,0x1B0A,0x6EFD,0xE1D7,0xA101,
	0xFB11,0xEE7D,0x1B0A,0xEE1D,0xECDD,0x1A05,0xA142,0xF127,0x2EE5,0xFF00,0x6DFD,0xE1D7,0xA142,0xF127,0xA302,0xFB22,
	0xEE2D,0x14F7,0xFF00,0xE060,0x501C,0x0BCC,0xE36C,0x18F1,0xFF00,0xA442,0xF022,0xF22D,0x1C03,0x20F8,0xFF00,0xA242,
	0xF022,0xF22D,0x1D03,0x2ECA,0xFF00,0xEE1D,0xECDD,0x1B2B,0xFB03,0xA100,0x0FFC,0xA342,0xF022,0xF671,0xE521,0x1821,
	0xF671,0xF421,0x1907,0xF413,0x1414,0xFB0D,0x001D,0x200F,0xE0D2,0xF411,0x190C,0xF423,0x140C,0xFB02,0xA101,0xE4F2,
	0xFB11,0xED22,0xED22,0xF511,0xE512,0x0022,0xEF32,0x180B,0x3280,0xFF00,0x6001,0xA342,0xF121,0xF577,0x31A5,0x6068,
	0xE030,0xE33C,0xF40C,0x1121,0x6006,0xA342,0xF022,0xF671,0xE521,0x1925,0xFB03,0x6FF1,0xEF13,0x1817,0x6008,0x2277,
	0x6009,0x1916,0xF43C,0x140F,0xFB02,0xA101,0xE4F2,0xFB11,0xED22,0xED22,0xF511,0xE512,0x0032,0xEF2C,0x1504,0xE32C,
	0x2FE2,0xE020,0x620D,0xE5D7,0xA141,0x2E78,0xF117,0x5012,0xE527,0x6016,0x0FFC,0x0010,0xA242,0xF121,0xF671,0xF411,
	0x1926,0xF41C,0x1512,0xFB02,0xA100,0xE4F2,0xFB01,0xA100,0xF511,0xED22,0xED22,0xE512,0xA341,0xF112,0xF577,0x5031,
	0xE517,0x0026,0x2021,0x0FEC,0xF40C,0x1109,0xFB02,0xE4F2,0xED22,0xED22,0xA341,0xF112,0x5011,0xE017,0xF208,0xE368,
	0xF2C9,0x600A,0x502E,0x014E,0x218E,0xE069,0xF421,0x190C,0xFB03,0xA342,0xF021,0xF533,0xE531,0xF121,0x5011,0xE017,
	0x0016,0x0FFC,0x0010,0xF678,0x1837,0xF40C,0x1135,0xA242,0xF022,0xF522,0xF412,0x1103,0x202F,0xF577,0x60E1,0xE381,
	0x0FE8,0xEF1C,0x1004,0x60B9,0x2009,0xF577,0xF679,0xE0C9,0xED91,0xED11,0xF577,0xE517,0x0FD9,0x2209,0xFF00,0x1913,
	0x31F8,0xFF00,0xA341,0xF012,0xEFC2,0x1107,0x6001,0xF112,0x620D,0xE5D7,0x2F9A,0xF577,0xE32C,0xE020,0x6002,0xF112,
	0x2F72,0xF577,0xF411,0x1808,0xF577,0xA242,0xF023,0x5FFD,0xE1D3,0xE513,0xF123,0xA342,0xF021,0xEFC1,0x1104,0xE3C1,
	0x2FAE,0xF121,0xF67D,0x1807,0xE31C,0xE010,0x6001,0xF121,0x2F5A,0xF577,0xF208,0xE368,0xF219,0xE069,0x602A,0xE31C,
	0xE010,0x6001,0xF121,0x312F,0xF577,0xF67D,0xEEDD,0x1B06,0xA242,0xF021,0x580D,0xE5D1,0xF121,0x31AD,0xFF00,0xA242,
	0xF021,0x502E,0x0F2E,0x20C4,0xF518,0xEE1D,0xECDD,0x1B53,0xF577,0xEB2D,0x1D32,0xF46C,0x141C,0xA409,0xFB91,0xE999,
	0xED11,0xFB99,0xED11,0xF599,0xE519,0x0069,0xEFC9,0x1608,0xF208,0x3109,0x602A,0x501E,0x08DE,0x20AA,0x6048,0xE3C9,
	0xA341,0xF119,0x600A,0xF2C9,0x501E,0x08DE,0x20FC,0xF208,0xF45C,0x190C,0x5001,0xE517,0xA141,0xF117,0xA402,0xFB22,
	0xA341,0xED22,0xED22,0x2FEF,0xF112,0xF577,0xEDC1,0xED11,0xE5C7,0xA141,0x2FE8,0xF117,0x6091,0xEF1C,0x1416,0xA806,
	0xFB66,0xF566,0x0096,0xEF6C,0x140B,0xF208,0xF269,0x30DB,0x6FFA,0xE36C,0xE060,0x503E,0x0D2E,0x207A,0x6048,0xE3C6,
	0xA341,0xF116,0x2FD1,0x6FDA,0xEDC1,0xED11,0xA142,0xF121,0x2FCB,0x6FDA,0xEB2D,0x1D3C,0xF673,0x1832,0xF577,0xF2C1,
	0xE031,0xF461,0x1018,0xA401,0xE331,0xF453,0x1905,0xA346,0xF066,0x2006,0xA111,0xFB16,0xA111,0xED66,0xED66,0xFB12,
	0xA141,0xE526,0x0066,0xF117,0x6002,0xA341,0xF112,0xF269,0x2F9E,0xE339,0xF451,0x190E,0x5001,0xE517,0xA141,0xF117,
	0xF201,0x0041,0xE331,0xFB11,0xA342,0xED11,0xED11,0x2F9B,0xF121,0xED11,0xED11,0xE517,0xA141,0x2F95,0xF117,0xA342,
	0xF029,0xEF9C,0x148D,0xFF00,0x6001,0x2F83,0xF121,0xF673,0x1826,0xF577,0xF2C1,0xE031,0x6092,0xEF21,0x101A,0xA141,
	0xF117,0xA806,0xE363,0xFB66,0xF566,0x0096,0xE363,0xEF6C,0x140B,0xF208,0xF269,0x3077,0x603A,0xE36C,0xE060,0x503E,
	0x0D2E,0x2016,0x6048,0xE3C6,0xA341,0xF116,0x2F6D,0x601A,0xED11,0xED11,0xA142,0xF121,0x2F67,0x601A,0xA342,0xF026,
	0x6001,0xF121,0xF266,0x19E4,0xFF00,0x2F5D,0xFF00,0x4281,0xED88,0xED88,0xE558,0xF211,0x1903,0xE20E,0x8288,0x4072,
	0x8288,0xE922,0xE4F2,0xF22D,0x030D,0xF1D1,0x6101,0xE512,0xF2F1,0x1705,0x1DFF,0xF2F1,0xE20E,0x8072,0xEB1D,0x1DFA,
	0xF2F1,0xE20E,0x8072,0x4281,0xED88,0xED88,0xE558,0xF211,0x190B,0x4072,0xE922,0xE4F2,0xF22D,0x030D,0xF1D8,0x6101,
	0xE512,0xE20E,0x8072,0x4072,0xE922,0xE4F2,0xF22D,0x030D,0xF1D1,0xE922,0xE4F2,0xF22D,0x030D,0xF1D8,0x6101,0xE512,
	0x6001,0x8281,0xF2F1,0x1400,0xF2F1,0x1DFE,0xF2F1,0xE20E,0x8072,0x4281,0x9901,0xE20E,0xFF00,0xF2F2,0x140E,0x1D0D,
	0x4072,0x600D,0x828D,0xE922,0xE4F2,0xF22D,0x030D,0xF1D1,0x6101,0xE512,0xE20E,0x8072,0xE20E,0xFF00,0xED1B,0x190D,
	0xE20E,0xFF00,0xF2AD,0x1436,0xA441,0xF011,0x51F2,0xE121,0x1903,0xE20E,0xFF00,0xEE1B,0xECBB,0x5032,0x0F22,0xE02B,
	0xF2AD,0x1D2D,0xED51,0xEC11,0x5022,0x0FC2,0xE021,0xEC82,0xF28D,0x1416,0xF013,0x0FE2,0xF63D,0xF12D,0xE922,0xED33,
	0xE911,0xF01D,0xED33,0xF6DD,0xE5D3,0xF01D,0xF123,0xE922,0xEDDD,0xF023,0xEDDD,0xF533,0xE53D,0x2009,0xF12D,0xF013,
	0x0FE2,0xF123,0xE911,0xF013,0xE922,0xF123,0x0FC8,0x2007,0x0049,0xED51,0xEC11,0x502B,0x0FAB,0xE01B,0xF2AD,0x1B07,
	0xA3B1,0xF011,0xE091,0xF311,0xE4F1,0xE019,0xA3B2,0xF022,0xA2B1,0xF011,0xE092,0x1402,0xE911,0xA7B3,0xF033,0xA6BD,
	0xF0DD,0xE332,0x1702,0xE811,0xE3D1,0x141B,0xF2FD,0x14FF,0xFF00,0xE329,0x8018,0xA3B1,0xA2BD,0xF011,0xF0DD,0x8031,
	0x802D,0x6FAD,0x800D,0x501D,0xE59D,0x800D,0x827D,0xE098,0xF229,0xF0B1,0xA2B2,0xF121,0xA1B1,0xF011,0xA3B2,0xF121,
	0xF299,0x1817,0xF2FD,0x14FF,0xFF00,0x8018,0xA3B1,0xA2B2,0xF013,0xF02A,0x8033,0x802A,0x6FAD,0x800D,0x501D,0xE59D,
	0x800D,0x827D,0xE098,0xE093,0x1402,0xE9AA,0xF113,0xF12A,0xE20E,0xFF00,0xED51,0xEC11,0x502B,0x0FAB,0xE01B,0xA2B2,
	0xF021,0xA4B2,0xF121,0xA3B2,0xF021,0xA5B2,0xE20E,0xF121,0xED51,0xEC11,0x502B,0x0FAB,0xE01B,0xA4B2,0xF021,0xA2B2,
	0xF121,0xA5B2,0xF021,0xA3B2,0xE20E,0xF121,0xA142,0xF127,0xF408,0x1934,0xA44B,0xF0BB,0x61F1,0xE11B,0xEDB1,0xEBBB,
	0xEBBB,0xE0B1,0x503B,0x05AB,0xE01B,0xF0B1,0x5202,0x0FF2,0xE121,0xF1B1,0xA1B1,0xF011,0xF61D,0xEEDD,0x1A18,0x51F2,
	0xE121,0xEE11,0xEE11,0xED12,0xEB11,0xEB11,0xE021,0x5032,0x05A2,0xE012,0xF021,0x520D,0x0FFD,0xE1D1,0xF121,0xA121,
	0xF011,0xEE1D,0x1A04,0x61F2,0x2FEF,0xE121,0xA1B1,0xF01B,0xEEBD,0x1A04,0x61F1,0x2FD3,0xE11B,0xA44B,0xF0B3,0x61F1,
	0xE113,0xED31,0xEB32,0xEB22,0xE021,0x503B,0x05AB,0xE01B,0xF0B1,0x58C2,0xE112,0x1803,0x2089,0xFF00,0xF61D,0xEEDD,
	0x140B,0xA1B1,0xF011,0x51F2,0xF61D,0xEEDD,0x1A7F,0xE121,0xEE1B,0x2FE8,0xEEBB,0xF0BE,0xE4FE,0x73E9,0xF29E,0xF20A,
	0xF287,0xEFE7,0x121F,0xFBAD,0xA2B1,0xEB11,0xE071,0xFB12,0x00C1,0xE7D2,0xFB1D,0x00C1,0xE12D,0x1806,0xF0B1,0x580D,
	0xE5D1,0x2064,0xF1B1,0xFB1D,0xF0B1,0xF40D,0x1808,0xE1D2,0x1803,0x540D,0xE5D1,0x520D,0xE5D1,0xF1B1,0x001A,0x2FE2,
	0x0017,0xF0B1,0x60F2,0xE112,0xEFE2,0x194E,0xF61D,0xEEDD,0x1B03,0xEB1D,0x1D4B,0xA1B2,0xF022,0xEB2D,0x1D04,0x504D,
	0xE5D1,0xF1B1,0xED2D,0xEDDD,0x1D1C,0x510D,0xE5D1,0xF1B1,0xA442,0xF022,0x61F1,0xE112,0xED21,0xEB22,0xEB22,0xE021,
	0x5032,0x05A2,0xE012,0xEF2B,0x1805,0xF021,0x508D,0xE5D1,0xF121,0xA122,0xF022,0xEE2D,0x1A23,0x61F1,0x2FEE,0xE112,
	0xEE2D,0xECDD,0x1B1D,0xA241,0xF012,0x580D,0xE5D2,0xF112,0xA442,0xF022,0x61F1,0xE112,0xED21,0xEB22,0xEB22,0xE021,
	0x5032,0x05A2,0xE012,0xF021,0x5E8D,0x0FFD,0xE1D1,0xF121,0xA122,0xF022,0xEE2D,0x1A04,0x61F1,0x2FEF,0xE112,0xF555,
	0x0083,0x200E,0xF231,0x5011,0xE515,0xA1B3,0xF033,0xEE3D,0x1A04,0x61F1,0x2F67,0xE113,0xF652,0xF555,0xF221,0xA142,
	0xF027,0x9908,0x2CAF,0xFF00,0x2D1B,0xFF00,0x4291,0xF211,0x1903,0xE20E,0xFF00,0x5060,0x0DA0,0xF002,0x0010,0xEC23,
	0xEC33,0xF00B,0x0010,0xE432,0x1817,0x0FF2,0x1904,0xF03A,0x2013,0xE1AB,0x0FF2,0x1909,0xF03A,0xF40B,0x1904,0xE802,
	0x200C,0xF12A,0x2009,0xE5AB,0xF03A,0xF40B,0x1904,0x601B,0x2003,0xE7AB,0xE0AB,0xF13B,0x0FF1,0x19E1,0xF002,0x8291,
	0x41A2,0x5041,0xE112,0xE20E,0x8072,
};
int PID0x31_instructions_len = 1413;


unsigned short PID0x31_data[1530] = {
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xFEFF,0x0000,0x0031,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0003,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0031,0x00A0,0x0000,0x0000,0x0100,0xFFFF,
	0x0000,0x0000,0x0000,0x0000,0xFFFF,0x0000,0x0000,0x0000,0x0000,0xFFFF,0x0000,0x0000,0x0000,0x0000,0xFFFF,0x0000,
	0x0000,0x0000,0x0000,0xFFFF,0x0000,0x0000,0x0000,0x0000,0xFFFF,0x0000,0x0000,0x0000,0x0000,0xFFFF,0x0000,0x0000,
	0x0000,0x0000,0xFFFF,0x0000,0x0000,0x0000,0x0000,0xFFFF,0x0000,0x0000,0x0000,0x0000,0xFFFF,0x0000,0x0000,0x0000,
	0x0000,0xFFFF,0x0000,0x0000,0x0000,0x0000,0xFFFF,0x0000,0x0000,0x0000,0x0000,0xFFFF,0x0000,0x0000,0x0000,0x0000,
	0xFFFF,0x0000,0x0000,0x0000,0x0000,0xFFFF,0x0000,0x0000,0x0000,0x0000,0xFFFF,0x0000,0x0000,0x0000,0x0000,0xFFFF,
	0x0000,0x0000,0x0000,0x0000,0xFFFF,0x0000,0x0000,0x0000,0x0000,0xFFFF,0x0000,0x0000,0x0000,0x0000,0xFFFF,0x0000,
	0x0000,0x0000,0x0000,0xFFFF,0x0000,0x0000,0x0000,0x0000,0xFFFF,0x0000,0x0000,0x0000,0x0000,0xFFFF,0x0000,0x0000,
	0x0000,0x0000,0xFFFF,0x0000,0x0000,0x0000,0x0000,0xFFFF,0x0000,0x0000,0x0000,0x0000,0xFFFF,0x0000,0x0000,0x0000,
	0x0000,0xFFFF,0x0000,0x0000,0x0000,0x0000,0xFFFF,0x0000,0x0000,0x0000,0x0000,0xFFFF,0x0000,0x0000,0x0000,0x0000,
	0xFFFF,0x0000,0x0000,0x0000,0x0000,0xFFFF,0x0000,0x0000,0x0000,0x0000,0x0010,0x0000,0x0010,0x0000,0x0010,0x0000,
	0x0040,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x000E,0x0000,0x000E,0x0000,0x000E,0x0000,
	0x000F,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x000F,0x0000,0x000F,0x0000,0x000F,0x0000,
	0x0010,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2020,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2020,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x2020,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2020,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2020,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2020,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x2020,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2020,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2020,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2020,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x2020,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2020,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2020,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2020,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x2020,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2020,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2020,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2020,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x2020,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2020,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2020,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2020,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x2020,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2020,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2020,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2020,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x2020,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2020,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2020,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2020,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x2020,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x2020,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
	0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
};
int PID0x31_data_len = 1530;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\specific\tl850ovl.h ===
// FILE:			library\hardware\mpeg2dec\specific\tl850ovl.h
// AUTHOR:		Martin Stephan
// COPYRIGHT:	(c) 1999 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		06.07.1999
//
// PURPOSE:		TL850 MPEG-2 decoder overlay settings 
//
// DESCRIPTION:	an overlay region is defined. This is only for testing purposes and
//						is not used in a final version.
//

#ifndef TL850OVL_H
#define TL850OVL_H

#define OVERLAY_BASE_ADDRESS	0x1000500
#define OVERLAY_INDEX_ADDRESS 0x000

unsigned long overlay[256] = {
	0x00100000, 0x00100000, 0x00100000, 0x00100000,
	0x00140000, 0x00140000, 0x00140000, 0x00140000,
	0x00180000, 0x00180000, 0x00180000, 0x00180000,
	0x001c0000, 0x001c0000, 0x001c0000, 0x001c0000,

	0x00200000, 0x00200000, 0x00200000, 0x00200000,
	0x00240000, 0x00240000, 0x00240000, 0x00240000,
	0x00280000, 0x00280000, 0x00280000, 0x00280000,
	0x002c0000, 0x002c0000, 0x002c0000, 0x002c0000,

	0x00300000, 0x00300000, 0x00300000, 0x00300000,
	0x00340000, 0x00340000, 0x00340000, 0x00340000,
	0x00380000, 0x00380000, 0x00380000, 0x00380000,
	0x003c0000, 0x003c0000, 0x003c0000, 0x003c0000,

	0x00400000, 0x00400000, 0x00400000, 0x00400000,
	0x00440000, 0x00440000, 0x00440000, 0x00440000,
	0x00480000, 0x00480000, 0x00480000, 0x00480000,
	0x004c0000, 0x004c0000, 0x004c0000, 0x004c0000,

	0x00500000, 0x00500000, 0x00500000, 0x00500000,
	0x00540000, 0x00540000, 0x00540000, 0x00540000,
	0x00580000, 0x00580000, 0x00580000, 0x00580000,
	0x005c0000, 0x005c0000, 0x005c0000, 0x005c0000,

	0x00600000, 0x00600000, 0x00600000, 0x00600000,
	0x00640000, 0x00640000, 0x00640000, 0x00640000,
	0x00680000, 0x00680000, 0x00680000, 0x00680000,
	0x006c0000, 0x006c0000, 0x006c0000, 0x006c0000,

	0x00700000, 0x00700000, 0x00700000, 0x00700000,
	0x00740000, 0x00740000, 0x00740000, 0x00740000,
	0x00780000, 0x00780000, 0x00780000, 0x00780000,
	0x007c0000, 0x007c0000, 0x007c0000, 0x007c0000,

	0x00800000, 0x00800000, 0x00800000, 0x00800000,
	0x00840000, 0x00840000, 0x00840000, 0x00840000,
	0x00880000, 0x00880000, 0x00880000, 0x00880000,
	0x008c0000, 0x008c0000, 0x008c0000, 0x008c0000,

	0x00900000, 0x00900000, 0x00900000, 0x00900000,
	0x00940000, 0x00940000, 0x00940000, 0x00940000,
	0x00980000, 0x00980000, 0x00980000, 0x00980000,
	0x009c0000, 0x009c0000, 0x009c0000, 0x009c0000,

	0x00a00000, 0x00a00000, 0x00a00000, 0x00a00000,
	0x00a40000, 0x00a40000, 0x00a40000, 0x00a40000,
	0x00a80000, 0x00a80000, 0x00a80000, 0x00a80000,
	0x00ac0000, 0x00ac0000, 0x00ac0000, 0x00ac0000,

	0x00b00000, 0x00b00000, 0x00b00000, 0x00b00000,
	0x00b40000, 0x00b40000, 0x00b40000, 0x00b40000,
	0x00b80000, 0x00b80000, 0x00b80000, 0x00b80000,
	0x00bc0000, 0x00bc0000, 0x00bc0000, 0x00bc0000,

	0x00c00000, 0x00c00000, 0x00c00000, 0x00c00000,
	0x00c40000, 0x00c40000, 0x00c40000, 0x00c40000,
	0x00c80000, 0x00c80000, 0x00c80000, 0x00c80000,
	0x00cc0000, 0x00cc0000, 0x00cc0000, 0x00cc0000,

	0x00d00000, 0x00d00000, 0x00d00000, 0x00d00000,
	0x00d40000, 0x00d40000, 0x00d40000, 0x00d40000,
	0x00d80000, 0x00d80000, 0x00d80000, 0x00d80000,
	0x00dc0000, 0x00dc0000, 0x00dc0000, 0x00dc0000,

	0x00e00000, 0x00e00000, 0x00e00000, 0x00e00000,
	0x00e40000, 0x00e40000, 0x00e40000, 0x00e40000,
	0x00e80000, 0x00e80000, 0x00e80000, 0x00e80000,
	0x00ec0000, 0x00ec0000, 0x00ec0000, 0x00ec0000,

	0x00f00000, 0x00f00000, 0x00f00000, 0x00f00000,
	0x00f40000, 0x00f40000, 0x00f40000, 0x00f40000,
	0x00f80000, 0x00f80000, 0x00f80000, 0x00f80000,
	0x00fc0000, 0x00fc0000, 0x00fc0000, 0x00fc0000,

	0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000,
	0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000,
	0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000,
	0x00ff0000, 0x00ff0000, 0x00ff0000, 0x00ff0000};

unsigned long overlayCLUT[3] = {
	0x00010000, 0x00020000, 0x00030000
	};


	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\specific\tl850reg.h ===
// FILE:			library\hardware\mpeg2dec\specific\tl850reg.h
// AUTHOR:		Martin Stephan
// COPYRIGHT:	(c) 1999 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		14.06.99
//
// PURPOSE:		TL850 MPEG-2 decoder register settings
//
// HISTORY:	   

#ifndef TL850REG_H
#define TL850REG_H

/* Register definitions for TL850 mpeg-2 decoder chip */

#define TL850_REGISTER_OFFSET 0xac000000
#define TL850_MEMORY_OFFSET	0xa8000000

//HIF internal register
#define HIF_BASE 					0x00000				//HIF base address
#define HIF_INT0_STAT_REG 		0x00000				//HIF interrupt status register
#define HIF_INT0_MASK_REG 		0x00004				//HIF interrupt mask register
#define HIF_INT1_STAT_REG 		0x00008				//HIF interrupt status register
#define HIF_INT1_MASK_REG 		0x0000C				//HIF interrupt mask register
#define HIF_RAM_TEST_REG 		0x00010				//HIF RAM test register
#define HIF_HINTED_ADDR_REG 	0x00014				//

#define VSC_BASE 					0x01000				//video channel base address
#define VSC_CTRL_REG 			0x01000				//specifies the operation of video port
#define VSC_STAT_REG 			0x01004				//provides status information on the video port
#define VSC_INT_EN_REG 			0x01008				//provides the interrupt enables for the VSC
#define VSC_INT_STAT_REG 		0x0100C				//interrupt status register
#define VSC_MIF_REG 				0x01010				//memory interface control register
#define VSC_DDA_REG 				0x01014				//specifies the horizontal scaling factors
#define VSC_HS_REG 				0x01018				//horizontal scaler control register
#define VSC_VBI0_REG 			0x0101C				//defines the field 0 VBI data capture operation
#define VSC_VBI1_REG 			0x01020				//defines the field 1 VBI data capture operation
#define VSC_VBUF_SADR_REG 		0x01024				//start address of the VBI field buffer in external memory
#define VSC_VBUF_WADR_REG 		0x01028				//current write address of the VBI field buffer in external memory

#define AMR_BASE 					0x02000

#define APU_BASE 					0x03000				//APU base address
#define APU_IOC_CONFIG_REG 	0x03000				//input, output and clock configuration register
#define APU_CPB_CONFIG_REG 	0x03004				//capture and playback configuration register
#define APU_IEC_CONFIG_REG 	0x03008				//IEC958 configuration register
#define APU_IEC_CSB1_REG 		0x0300C				//IEC958	channel status buffer registers
#define APU_IEC_CSB2_REG 		0x03010				//IEC958 channel status buffer registers
#define APU_INT_CONFIG_REG 	0x03014				//interrupt configuration registers
#define APU_INT_STATUS_REG 	0x03018				//interrupt status register
#define APU_RESERVED_REG 		0x0301C				
#define APU_CPB_CBA_REG 		0x03020				//capture/playback begin address register
#define APU_CPB_CEA_REG 		0x03024				//capture/playback end address register
#define APU_CPB_CWA_REG 		0x03028				//capture/playback write address register
#define APU_CPB_CRA_REG 		0x0302C				//capture/playback read address register
#define APU_CPB_CMA_REG 		0x03030				//capture/playback match adress register
#define APU_IAU_IBA0_REG 		0x03034				//internal audio begin address registers
#define APU_IAU_IRA0_REG 		0x03038				//internal audio read address registers
#define APU_IAU_IEA0_REG 		0x0303C				//internal audio end address registers
#define APU_IAU_IBA1_REG 		0x03040				//internal audio begin address registers
#define APU_IAU_IRA1_REG 		0x03044				//internal audio read address registers
#define APU_IAU_IEA1_REG 		0x03048				//internal audio end address registers
#define APU_IAU_IBA2_REG 		0x0304C				//internal audio begin address registers
#define APU_IAU_IRA2_REG 		0x03050				//internal audio read address registers
#define APU_IAU_IEA2_REG 		0x03054				//internal audio end address registers
#define APU_MIX_CONFIG_REG 	0x03058				//mix configuration register
#define APU_MIX_XFC0_REG 		0x0305C				//cross-fade coefficient registers
#define APU_MIX_XFC1_REG 		0x03060				//cross-fade coefficient registers
#define APU_MIX_XFC2_REG 		0x03064				//cross-fade coefficient registers
#define APU_MIX_XFC3_REG 		0x03068				//cross-fade coefficient registers
#define APU_MIX_XFC4_REG 		0x0306C				//cross-fade coefficient registers
#define APU_MIX_XFC5_REG 		0x03070				//cross-fade coefficient registers
#define APU_MIX_XFC6_REG 		0x03074				//cross-fade coefficient registers
#define APU_MIX_XFC7_REG 		0x03078				//cross-fade coefficient registers
#define APU_MIX_XFC8_REG 		0x0307C				//cross-fade coefficient registers

#define BLT_BASE 					0x04000				//BLT base address
#define BLT_CHAN_S0_REG 		0x04000				//channel S0 configuration register
#define BLT_CHAN_S1_REG 		0x04004				//channel S1 configuration register
#define BLT_CHAN_D_REG 			0x04008				//destination channel configuration register
#define BLT_CMD_REG 				0x0400C				//BitBlt command register
#define BLT_STAT_REG 			0x04010				//status register
#define BLT_INTR_STAT_REG 		0x04014				//interrupt status register
#define BLT_LEFT_ADDRESS_S0_REG		0x04018		//channel S0, left address register of first line address processed
#define BLT_RIGHT_ADDRESS_S0_REG		0x0401C		//channel S0, right address register of first line address processed
#define BLT_LEFT_ADDRESS_S1_REG 		0x04020		//channel S1, left address register of first line address processed
#define BLT_RIGHT_ADDRESS_S1_REG 	0x04024		//channel S1, right address register of first line processed
#define BLT_LEFT_ADDRESS_D_REG 		0x04028		//channel D, left address register of first line processed
#define BLT_RIGHT_ADDRESS_D_REG 		0x0402C		//channel D, right address register of first line processed
#define BLT_S0_PITCH_SIZ_REG 	0x04030				//pitch size for channel S0
#define BLT_S1_PITCH_SIZ_REG 	0x04034				//pitch size for channel S1
#define BLT_D_PITCH_SIZ_REG 	0x04038				//pitch size for channel D
#define BLT_H_W_REG 				0x0403C				//bitmap size
#define BLT_LINK_ADDR_REG 		0x04040				//link list address
#define BLT_S0_FG_COLOR_REG 	0x04044				//foreground register
#define BLT_S0_BG_REG 			0x04048				//background register
#define BLT_S1_FG_COLOR_REG 	0x0404C				//global color for S0
#define BLT_S1_BG_REG 			0x04050				//global color for S1
#define BLT_ALPHA_REG 			0x04054				//alpha parameters
#define BLT_PROG_REG 			0x04058				//
#define BLT_PACE_LINE_REG 		0x0405C				//

#define PLL_SYSCLK_REG 			0x05000				//system clock PLL register
#define PLL_MIFCLK_REG 			0x05400				//MIF clock PLL register
#define PLL_DPCCLK_REG 			0x05800				//display processor clock PLL register

//delay line (DLL) registers
#define DLL_BASE 					0x05C00				//dll base address
#define DLL_IRAM 					0x05C00				//instruction RAM
#define DLL_FN_OFST_REG 		0x05D00				//fine offset delay registers
#define DLL_FN_REG 				0x05D04				//fine delay registers
#define DLL_GR_REG 				0x05D08				//gross delay registers
#define DLL_OFST_REG 			0x05D0C				//offset delay registers
#define DLL_RST_REG 				0x05D10				//reset registers
#define DLL_PCLK_DLY_REG 		0x05D14				//pclk delay registers
//end delay line registers

#define MCE_BASE 					0x06000		
#define MCE_CTRL_REG 			0x06000
#define MCE_STAT_REG 			0x06004
#define MCE_IE_REG 				0x06008
#define MCE_IS_REG 				0x0600C
#define MCE_IS_ALIAS_REG 		0x06010
#define MCE_SYNC_CTRL_REG 		0x06014
#define MCE_SYNC_STAT_REG 		0x06018
#define MCE_FNSSC_REG 			0x0601C
#define MCE_FSSC_REG 			0x06020				
#define MCE_VLD_CTRL_REG 		0x06024
#define MCE_TOC_RDATA_REG 		0x06028
#define MCE_Q_WDATA_REG 		0x0602C
#define MCE_MPIC_REG 			0x06030
#define MCE_CH_SADR_REG 		0x06034
#define MCE_CH_EADR_REG 		0x06038
#define MCE_CH_RADR_REG 		0x0603C

#define VPIP_BASE 				0x07000
#define VPIP_CONFIG_REG 		0x07000
#define VPIP_INT_EN_REG 		0x07004
#define VPIP_INT_STAT_REG 		0x07008
#define VPIP_PTR_REG 			0x0700C
#define VPIP_POS_X_REG 			0x07010
#define VPIP_STATUS_REG 		0x07014
#define VPIP_SIZE_REG 			0x07018
#define VPIP_ROW_CONFIG_REG 	0x0701C
#define VPIP_DDA_FACTOR_REG 	0x07020
#define VPIP_COEFF_ADDR_REG 	0x07024
#define VPIP_COEFF_DATA_REG 	0x07028
#define VPIP_ROW_CONFIG2_REG 	0x0702C
#define VPIP_STATUS2_REG 		0x07030

#define HPIP_BASE 				0x08000
#define HPIP_CONFIG_REG 		0x08000
#define HPIP_STATUS_REG 		0x08004
#define HPIP_INT_EN_REG 		0x08008
#define HPIP_INT_STAT_REG 		0x0800C
#define HPIP_PTR_REG 			0x08010
#define HPIP_X_FACTOR_REG 		0x08014
#define HPIP_Y_FACTOR_REG 		0x08018
#define HPIP_DDA_FACTOR_REG 	0x0801C
#define HPIP_COEFF_ADDR_REG 	0x08020
#define HPIP_COEFF_DATA_REG 	0x08024
#define HPIP_CMODEL_REG 		0x08028

//display processor architecture (DPC) registers
#define DPC_BASE 					0x10000				//DPC base address
#define DPC_CONFIG_REG 			0x10000				//DPC configuration register
#define DPC_STATUS_REG 			0x10004				//DPC status 
#define DPC_INT_EN_REG 			0x10008				//DPC interrupt enable
#define DPC_INT_STAT_REG 		0x1000C				//DPC interrupt status register
#define DPC_DISP_COUNT_REG 	0x10010				//DPC display count
#define DPC_SYNC_PARAM1_REG 	0x10014				//DPC sync parameter 1
#define DPC_SYNC_PARAM2_REG 	0x10018				//DPC sync parameter 2
#define DPC_SYNC_PARAM3_REG 	0x1001C				//DPC sync parameter 3
#define DPC_SYNC_PARAM4_REG 	0x10020				//DPC sync parameter 4
#define DPC_SYNC_DELAY1_REG 	0x10024				//DPC sync delay 1
#define DPC_SYNC_DELAY2_REG 	0x10028				//DPC sync delay 2
#define DPC_BG_CUMLUMA_REG 	0x1002C				//accumulated luma of background outside of the overlay region
#define DPC_OVL_CUMLUMA_REG 	0x10030				//accumulated luma of active region of overlay after compositing with the background
#define DPC_PDISP_STALL_REG 	0x10034			   //used to control parameters of stall circuit for primary display FIFO	
#define DPC_BG_CONFIG_REG 		0x10040				//background graphics and video configuration register
#define DPC_BG_COLOR_REG 		0x10044				//default background graphics color in 24-bit YCbCr
#define DPC_BVDOSRC_CFG1_REG 	0x10048				//starting point of the region of interest within the memory map
#define DPC_BVDOSRC_CFG2_REG 	0x1004C				//configuration of field memory buffers
#define DPC_BVDOWIN_CFG1_REG 	0x10050				//configuration of video window
#define DPC_BVDOWIN_CFG2_REG 	0x10054				//configuration of video window
#define DPC_BVDO_SC_CFG1_REG 	0x10058				//left and right positions of the center region within a scan line
#define DPC_BVDO_SC_CFG2_REG 	0x1005C				//top and bottom line positions of the central display region within a frame or field
#define DPC_BVDO_HS_CTL1_REG 	0x10060				//horizontal scaling parameters for central region of the video window
#define DPC_BVDO_HS_CTL2_REG 	0x10064				//horizontal scaling parameters for outside region of the video window
#define DPC_BVDO_VS_CTL1_REG 	0x10068				//vertical scaling parameters for central region of the video window
#define DPC_BVDO_VS_CTL2_REG 	0x1006C				//vertical scaling parameters for outside region of the video window
#define DPC_BVDO_IVPH_REG 		0x10070				//initial phases or steps for the vertical DDA
#define DPC_OVL_CONFIG_REG 	0x10080				//DPC overlay configuration register
#define DPC_OVL_DLIST_SA_REG 	0x10084				//overlay display list start word address
#define DPC_OVL_SA_REG 			0x10088				//overlay plane starting word address
#define DPC_OVL_SIZE_REG 		0x1008C				//size register of overlay region of interest
#define DPC_OVL_POS_REG 		0x10090				//position of the currently active overlay window
#define DPC_GALPHA_IBASE_REG 	0x10094				//global alpha and index base register
#define DPC_OVL_MAX_KEY_REG 	0x10098				//maximum register used for color keying and the matching register for index keying
#define DPC_OVL_MIN_KEY_REG 	0x1009C				//minimum register used for color keying
#define DPC_OVL_FLTR_COEF_REG 0x100A0				//coefficients for the anti-flicker filter for overlay
#define DPC_OVL_DLIST1_REG 	0x100A4				//
#define DPC_OVL_DLIST2_REG 	0x100A8				//
#define DPC_AUX_CONFIG_REG 	0x100C0				//configuration register for auxiliary video output
#define DPC_AUX_POS_REG 		0x100C4				//starting position of the auxiliary video scaling window 
#define DPC_AUX_HS_CTL_REG 	0x100C8				//horizontal scaling parameters for auxiliary video output
#define DPC_AUX_VS_CTL_REG 	0x100CC				//vertical scaling parameters for auxiliary video output
#define DPC_AUX_PROG1_REG 		0x100D0				//part 1 of 3 of the programmable video timing register
#define DPC_AUX_PROG2_REG 		0x100D4				//part 2 of 3 of the programmable video timing register
#define DPC_AUX_PROG3_REG 		0x100D8				//part 3 of 3 of the programmable video timing register
#define DPC_CURS_SA_REG 		0x10100				//cursor starting word address in dynamic memory
#define DPC_CURS_POS_REG 		0x10104				//
#define DPC_CURS_OFFSET_REG 	0x10108				//
#define DPC_CURSCLUT0_REG 		0x10140				//
#define DPC_CURSCLUT1_REG 		0x10144				//
#define DPC_CURSCLUT2_REG 		0x10148
#define DPC_CURSCLUT3_REG 		0x1014C
#define DPC_CURSCLUT4_REG 		0x10150
#define DPC_CURSCLUT5_REG 		0x10154
#define DPC_CURSCLUT6_REG 		0x10158
#define DPC_CURSCLUT7_REG 		0x1015C
#define DPC_CURSCLUT8_REG 		0x10160
#define DPC_CURSCLUT9_REG 		0x10164
#define DPC_CURSCLUT10_REG 	0x10168
#define DPC_CURSCLUT11_REG 	0x1016C
#define DPC_CURSCLUT12_REG 	0x10170
#define DPC_CURSCLUT13_REG 	0x10174
#define DPC_CURSCLUT14_REG 	0x10178
#define DPC_CURSCLUT15_REG 	0x1017C
#define DPC_MEM_ADDR_REG 		0x10180				//memory address pointers for the next memory data access
#define DPC_MEM_DATA_REG 		0x10184				//
#define DPC_GPIO_EN_REG 		0x10190				//set to enable selected pins as GPIO pins
#define DPC_GPIO_OUT_EN_REG 	0x10194				//set pins selected by DPC_GPIO_EN register to output mode
#define DPC_GPIO_OUTDATA_REG 	0x10198				//set pins selected by DPC_GPIO_EN register to bit value
#define DPC_GPIO_INDATA_REG 	0x1019C				//read values of 28 pins
#define DPC_SPG_CONFIG_REG		0x101A0
#define DPC_SPG_HCONFIG_REG	0x101A4
#define DPC_SPG_VCONFIG_REG	0x101A8
#define DPC_SPG_PCONFIG_REG	0x101AC
//end display processor architecture registers

#define MCU_BASE 					0x18000
#define MCU_RF0 					0x1D000
#define MCU_RF1 					0x1D004
#define MCU_RF2 					0x1D008
#define MCU_RF3 					0x1D00C
#define MCU_RF4 					0x1D010
#define MCU_RF5 					0x1D014
#define MCU_RF6 					0x1D018
#define MCU_RF7 					0x1D01C
#define MCU_RF8 					0x1D020
#define MCU_RF9 					0x1D024
#define MCU_RF10 					0x1D028
#define MCU_RF11 					0x1D02C
#define MCU_RF12 					0x1D030
#define MCU_RF13 					0x1D034
#define MCU_RF14 					0x1D038
#define MCU_RF15 					0x1D03C
#define MCU_HALT_REG 			0x1D800
#define MCU_PC 					0x1D804
#define MCU_COND_CODE 			0x1D808
#define MCU_SPL_REG 				0x1D80C
#define MCU_RAM_SLICE_VERTICAL_POSITION	0x1C000
#define MCU_RAM_MBAINC 			0x1C004
#define MCU_RAM_MOTION_TYPE 	0x1C008
#define MCU_RAM_MVECTOR 		0x1C00C
#define MCU_RAM_DELTA_000 		0x1C010
#define MCU_RAM_DELTA_001 		0x1C014
#define MCU_RAM_DELTA_010 		0x1C018
#define MCU_RAM_DELTA_011 		0x1C01C
#define MCU_RAM_DELTA_100 		0x1C020
#define MCU_RAM_DELTA_101 		0x1C024
#define MCU_RAM_DELTA_110 		0x1C028
#define MCU_RAM_DELTA_111 		0x1C02C
#define MCU_RAM_PICTURE_CODING_STRUCTURE 	0x1C2C0
#define MCU_RAM_PICTURE_FIELD 0x1C2C4
#define MCU_RAM_MV_FRAME 		0x1C2C8
#define MCU_RAM_MB_WIDTH 		0x1C2CC
#define MCU_RAM_MBAMAX 			0x1C2D0
#define MCU_RAM_RANGE_00 		0x1C2D4
#define MCU_RAM_RANGE_01 		0x1C2D8
#define MCU_RAM_RANGE_10 		0x1C2DC
#define MCU_RAM_RANGE_11 		0x1C2E0
#define MCU_RAM_FBUF_BASE_FWD 0x1C2E4
#define MCU_RAM_FBUF_BASE_BWD 0x1C2E8
#define MCU_RAM_FBUF_BASE_DST 0x1C2EC
#define MCU_RAM_PICTURE_START 0x1C2F0

//Transport stream demux (TSD) configuration registers
#define TSD_BASE 					0x20000
#define TSD_IRAM_0 				0x20000
#define TSD_IRAM_1 				0x20004
#define TSD_IRAM_16 				0x20040
#define TSD_IRAM_4K_1 			0x21FFC
#define TSD_IRAM_4K 				0x22000
#define TSD_IRAM_5K_1 			0x227FC
#define TSD_DRAM_0 				0x24000
#define TSD_DRAM_1 				0x24004
#define TSD_DRAM_16 				0x24040
#define TSD_DRAM_2K_1 			0x24FFC
#define TSD_DRAM_2K 				0x25000
#define TSD_DRAM_3K_1 			0x257FC
#define TSD_DRAM_4K_1 			0x25FFC
#define TSD_MCU_RF0 				0x26000
#define TSD_MCU_RF1 				0x26004
#define TSD_MCU_RF2 				0x26008
#define TSD_MCU_RF3 				0x2600C
#define TSD_MCU_RF4 				0x26010
#define TSD_MCU_RF5 				0x26014
#define TSD_MCU_RF6 				0x26018
#define TSD_MCU_RF7 				0x2601C
#define TSD_MCU_RF8 				0x26020
#define TSD_MCU_RF9 				0x26024
#define TSD_MCU_RF10 			0x26028
#define TSD_MCU_RF11 			0x2602C
#define TSD_MCU_RF12 			0x26030
#define TSD_MCU_RF13 			0x26034
#define TSD_MCU_RF14 			0x26038
#define TSD_MCU_RF15 			0x2603C
#define TSD_MCU_HALT_REG 		0x26800
#define TSD_MCU_PC 				0x26804
#define TSD_MCU_COND_CODE 		0x26808
#define TSD_MCU_SPL_REG 		0x2680C
#define TSD_DMA_RD_CONFIG 		0x27000
#define TSD_DMA_WR_ADD 			0x27004
#define TSD_IO_BYTELIM_CNT 	0x27800
#define TSD_STC_CNT_LM 			0x27804				//STC counter low
#define TSD_STC_CNT_H 			0x27808				//STC counter high
#define TSD_CON_VCXO 			0x27810				
#define TSD_INT_STATUS 			0x27814				//TSD internal status
//end TSD configuration registers

//Memory interface (MIF) base address
#define MIF_BASE 					0x28000				
#define MIF_CONFIG_REG 			0x28000				//MIF configuration register - specifies the basic memory configuration parameters
// MIF field buffer 
#define MIF_FLD_DSCR_0_REG		0x28040				
#define MIF_FLD_DSCR_1_REG		0x28044
#define MIF_FLD_DSCR_2_REG 	0x28048
#define MIF_FLD_DSCR_3_REG 	0x2804C
#define MIF_FLD_DSCR_4_REG 	0x28050
#define MIF_FLD_DSCR_5_REG 	0x28054
#define MIF_FLD_DSCR_6_REG 	0x28058
#define MIF_FLD_DSCR_7_REG 	0x2805C
#define MIF_FLD_DSCR_8_REG 	0x28060
#define MIF_FLD_DSCR_9_REG 	0x28064
#define MIF_FLD_DSCR_10_REG 	0x28068
#define MIF_FLD_DSCR_11_REG 	0x2806C
#define MIF_FLD_DSCR_12_REG 	0x28070
#define MIF_FLD_DSCR_13_REG 	0x28074
#define MIF_FLD_DSCR_14_REG 	0x28078
#define MIF_FLD_DSCR_15_REG 	0x2807C
// MIF status for client N
// This register specifies the status of the memory operations for a given client. 
#define MIF_STATUS_HIF_RD 		0x28080
#define MIF_STATUS_APU_RD 		0x28084
#define MIF_STATUS_TOC 			0x28088
#define MIF_STATUS_BLT0_RD 	0x2808C
#define MIF_STATUS_VPIP_RD 	0x28090
#define MIF_STATUS_BVDO1 		0x28094
#define MIF_STATUS_CLUT 		0x28098
#define MIF_STATUS_MC_RD 		0x2809C
#define MIF_STATUS_OVL1 		0x280A0
#define MIF_STATUS_OVL2 		0x280A4
#define MIF_STATUS_BLT1_RD 	0x280A8
#define MIF_STATUS_BLT2_RD 	0x280AC
#define MIF_STATUS_BVDO2 		0x280B0
#define MIF_STATUS_BVDO3 		0x280B4
#define MIF_STATUS_CURS 		0x280B8
#define MIF_STATUS_DL 			0x280BC
#define MIF_STATUS_HIF_WR 		0x280C0
#define MIF_STATUS_APU_WR 		0x280C4
#define MIF_STATUS_TRANS 		0x280C8
#define MIF_STATUS_BLT_WR 		0x280CC
#define MIF_STATUS_VPIP_WR 	0x280D0
#define MIF_STATUS_HPIP 		0x280D4
#define MIF_STATUS_VSC 			0x280D8
#define MIF_STATUS_MC_WR 		0x280DC

/*********************************************************************/
/*																							*/
/*							Bit field definitions									*/
/*																							*/
/*********************************************************************/
/* DPC Configuration Register */
#define DPC_CURRENT_FIELD 		0
#define DPC_BVDO_EN 				1
#define DPC_OVL_EN 				2
#define DPC_CURS_EN 				3
#define DPC_AUX_EN 				4
#define DPC_PRM_VOUT_EN 		5
#define DPC_PRM_YCCOUT 			6
#define DPC_VDAC_EN 				7
#define DPC_VDAC_TPAT_EN 		8
#define DPC_VDAC_BLNK_SEL 		9
#define DPC_VDAC_SYNC_EN 		10
#define DPC_DIGITAL_OUT 		11, 2
#define DPC_STRM_DACSEL 		13, 2
#define DPC_DIGITAL_IN 			15
#define DPC_CURS_MODE 			16
#define DPC_PRM_CLIP_MODE 		17
#define DPC_AUX_CLIP_MODE 		18
#define DPC_CONFIG_RESERVE 	19, 13
/* end DPC Configuration Register */

/* DPC Status Register (DPC_STATUS_REG) */
#define DPC_PRM_VOUT_H 			0
#define DPC_PRM_VOUT_V 			1
#define DPC_PRM_VOUT_F 			2
#define DPC_AUX_VOUT_H 			3
#define DPC_AUX_VOUT_V 			4
#define DPC_AUX_VOUT_F 			5
#define DPC_BG_UFLOW 			6
#define DPC_OVL_UFLOW 			7
#define DPC_HCOUNT 				8, 11
#define DPC_VCOUNT 				20, 11
/* end DPC Status Register */

/* DPC Interrupt Enable Register (DPC_INT_EN_REG)*/
#define DPC_SYNCLOSS_INT 		0
#define DPC_SYNCACQ_INT 		1
#define DPC_HSYNCCNT_INT 		2
#define DPC_VSYNCCNT_INT 		3
#define DPC_HVSYNCCNT_INT 		4
#define DPC_EOF0_INT 			5
#define DPC_EOF1_INT 			6
#define DPC_DISPL_INT 			7
#define DPC_MEM_UF_INT 			8
#define DPC_AUX_UF_INT 			9
#define DPC_AUX_OF_INT 			10
#define DPC_IDX_OF_INT			11
/* end Interrupt Enable Register */

/* DPC Interrupt Status Register (DPC_INT_STAT_REG) */
#define DPC_INT_STAT 			0, 10
#define DPC_DIPL_INT_CNT 		24, 8
/* end Interrupt Status Register */

/* DPC Display Count Register (DPC_DISP_COUNT_REG) */
#define DPC_LINE_COUNT 			0, 11
#define DPC_FRAME_COUNT 		16, 8
/* end Display Count Register */

/* DPC Synchronization Parameter 1 Register (DPC_SYNC_PARAM1_REG) */
#define DPC_PRM_CLKSEL 			0
#define DPC_TRS_WIDTH 			1
#define DPC_SYNC_MODE 			2
#define DPC_SYNC_PROGSS 		3
#define DPC_SCAN_REPEAT 		4, 2
#define DPC_VSYNC_DELAY 		6, 10
#define DPC_PIX_PER_LINE 		16, 11
#define DPC_SYNCCODE_EN 		27
#define DPC_SYNCSIG_EN 			28
#define DPC_SYNCSIG_HVIND 		29
#define DPC_OUTPUT_FIELD 		30
#define DPC_DISP_RESET 			31
/* end Synchronization Parameter 1 Register */

/* DPC Synchronization Parameter 2 Register (DPC_SYNC_PARAM1_REG) */
#define DPC_FRONT_PORCH 		0, 9
#define DPC_HSYNC_INVERSE 		9
#define DPC_VSYNC_INVERSE 		10
#define DPC_HSYNC_WIDTH 		12, 7
#define DPC_BACK_PORCH 			20, 9
/* end Synchronization Parameter 2 Register */

/* DPC Synchronization Parameter 3 Register (DPC_SYNC_PARAM3_REG) */
#define DPC_FIELD0_VSYNC 		0, 3
#define DPC_FIELD0_TOP 			4, 8
#define DPC_FIELD0_ACTIVE 		12, 11
#define DPC_FIELD0_BOTTOM 		24, 4
#define DPC_FIELD0_NTSC 		28
/* end Synchronization Parameter 3 Register */

/* DPC Synchronization Parameter 4 Register (DPC_SYNC_PARAM4_REG) */
#define DPC_FIELD1_VSYNC 		0, 3
#define DPC_FIELD1_TOP 			4, 8
#define DPC_FIELD1_ACTIVE 		12, 11
#define DPC_FIELD1_BOTTOM 		24, 4
/* end Synchronization Parameter 4 Register */

/* DPC Synchronization Delay 1 Register (DPC_SYNC_DELAY1_REG) */
#define DPC_SYNC_DELAY_V1 		0, 22
#define DPC_SDELAY_EN1 			24
#define DPC_LINES_TO_SYNC 		28, 4 
/* end Synchronization Delay 1 Register */

/* DPC Synchronization Delay 2 Register (DPC_SYNC_DELAY2_REG) */
#define DPC_SYNC_DELAY_V2 		0, 12
#define DPC_SDELAY_EN2 			24
/* end Synchronization Delay 2 Register */

/* DPC Accumulated luma of Background Register (DPC_BG_CUMLUMA_REG) */
#define DPC_BG_CUMLUMA 			0, 28
/* end Accumulated luma of Background Register */

/* DPC Accumulated Luma of Active Region Register (DPC_OVL_CUMLUMA_REG) */
#define DPC_OVL_CUMLUMA 		0, 28
/* end Accumulated Luma of Active Region Register */

/* DPC Stall Circuit Register (DPC_PDISP_STALL_REG) */
#define DPC_STALL_CLOSE 		0, 8
#define DPC_STALL_FAR 			8, 8
#define DPC_STALL_CYCLES 		16, 5
/* end Stall Circuit Register */

/* DPC Background Register */
/* DPC Background Configuration Register (DPC_BG_CONFIG_REG) */
#define DPC_BVDO_FLD_CFG 		0, 2
#define DPC_BVDO_MPEG1 			2
#define DPC_BVDO_FMT422 		3
#define DPC_BVDO_HFLR_EN 		4
#define DPC_BVDO_VFLR_EN 		5
#define DPC_BVDO_VLUMOFF 		6
#define DPC_BVDO_NUI_EN 		7
#define DPC_BVDO_VFLR_TAP 		8, 4
#define DPC_THROUGHPUT 			12, 3
#define DPC_BG_BWMODE 			15
/* end Background Configuration Register */

/* DPC Background Color Register (DPC_BG_COLOR_REG) */
#define DPC_BG_COLOR 			0, 24
/* end Background Configuration Register */

/* DPC Configuration 1 Register (DPC_BVDOSRC_CFG1_REG) */
#define DPC_BVDO_TOPBASE 		0, 4
#define DPC_BVDO_BOTBASE 		4, 4
#define DPC_BVDOSRC_XPOS 		8, 10
#define DPC_BVDOSRC_YPOS 		20, 11
/* end Configuration 1 Register */

/* DPC Configuration 2 Register (DPC_BVDOSRC_CFG2_REG) */
#define DPC_BVDOSRC_WD 			0, 11
#define DPC_BVDOSRC_HT 			16, 11
/* end Configuration 2 Register */

/* DPC Configuration 1 Register (DPC_BVDOWIN_CFG1_REG) */
#define DPC_BVDO_FIRST_PIX 	0, 4
#define DPC_BVDOWIN_XPOS 		8, 11
#define DPC_BVDOWIN_YPOS 		20, 11
/* end Configuration 1 Register */

/* DPC Configuration 2 Register (DPC_BVDOWIN_CFG2_REG) */
#define DPC_BVDOWIN_WD 			0, 11
#define DPC_BVDOWIN_HT 			16, 11
/* end Configuration 1 Register */

/* DPC Configuration 1 Register (DPC_BVDO_SC_CFG1_REG) */
#define DPC_BVDO_L_XPOS 		0, 12
#define DPC_BVDO_R_XPOS 		16, 12
/* end Configuration 1 Register */

/* DPC Configuration 2 Register (DPC_BVDO_SC_CFG2_REG) */
#define DPC_BVDO_T_YPOS 		0, 12
#define DPC_BVDO_B_YPOS 		16, 12
/* end Configuration 2 Register */

/* DPC Horizontal Control 1 Register (DPC_BVDO_HS_CTL1_REG) */
#define DPC_BVDO_HFS1 			4, 4
#define DPC_BVDO_HFN1 			8, 11
#define DPC_BVDO_HFM1 			20, 12
/* end Horizontal Control 1 Register */
		
/* DPC Horizontal Control 2 Register (DPC_BVDO_HS_CTL2_REG) */
#define DPC_BVDO_HFS2 			4, 4
#define DPC_BVDO_HFN2 			8, 11
#define DPC_BVDO_HFM2 			20, 12
/* end Horizontal Control 2 Register */

/* DPC Vertical Control 1 Register (DPC_BVDO_VS_CTL1_REG) */
#define DPC_BVDO_VFS1 			3, 5
#define DPC_BVDO_VFN1 			8, 11
#define DPC_BVDO_VFM1 			20, 12
/* end Vertical Control 1 Register */

/* DPC Vertical Control 2 Register (DPC_BVDO_VS_CTL2_REG) */
#define DPC_BVDO_VFS2 			3, 5
#define DPC_BVDO_VFN2 			8, 11
#define DPC_BVDO_VFM2 			20, 12
/* end Vertical Control 2 Register */

/* DPC Initial Phases Register (DPC_BVDO_IVPH_REG) */
#define DPC_BVDO_IVPH3BOT 		20, 4 
#define DPC_BVDO_IVPH3TOP 		16, 4
#define DPC_BVDO_IVPH2BOT 		12, 4
#define DPC_BVDO_IVPH2TOP 		8, 4
#define DPC_BVDO_IVPH1BOT 		4, 4
#define DPC_BVDO_IVPH1TOP 		0, 4
/* end Initial Phases Register */

/* DPC Configuration Registers for Overlay */
/* DPC Overlay Configuration Register (DPC_OVL_CONFIG_REG) */
#define DPC_COLOR_KEY_EN 		0
#define DPC_INDEX_KEY_EN 		1
#define DPC_GALPHA_EN 			2
#define DPC_OVL_OPAQUE 			3
#define DPC_GALPHA_MODE1 		4, 2
#define DPC_GALPHA_MODE2 		6, 2
#define DPC_HFLTR_EN 			8
#define DPC_VFLTR_EN 			9
#define DPC_VFLTR_TH_EN 		10
#define DPC_OVL_ALPHA_PM 		11
#define DPC_VFLTR_THRESH 		12, 4
#define DPC_OVL_YCCUB 			16
#define DPC_OVL_BWMODE 			17
/* end Overlay Configuration Register */

/* DPC Overlay Display List Start Register (DPC_OVL_DLIST_SA_REG) */
#define DPC_OVL_DLIST_SA 		4, 22
/* end Overlay Display List Start Register */

/* DPC Overlay Plane Starting Address Register (DPC_OVL_SA_REG) */
#define DPC_OVL_SA 				4, 22
/* end Overlay Plane Starting Address Register */

/* DPC Overlay Region Of Interest Register (DPC_OVL_SIZE_REG) */
#define DPC_OVL_PITCH 			0, 10
#define DPC_OVL_WIDTH 			10, 11
#define DPC_OVL_HEIGHT 			21, 11
/* end Overlay Region Of Interest Register */

/* DPC Overlay Position Register (DPC_OVL_POS_REG) */
#define DPC_OVL_XPOS 			0, 11
#define DPC_OVL_YPOS 			16, 11
/* end Overlay Position Register */

/* DPC Alpha and Index Base Register (DPC_GALPHA_IBASE_REG) */
#define DPC_OVL_CONTRST 		8, 8
#define DPC_OVL_BRIGHT 			16, 8
#define DPC_INDEX_BASE 			28, 4
/* end Alpha and Index Base Register */

/* DPC Maximum Color Keying Register (DPC_OVL_MAX_KEY_REG) */
#define DPC_MAX_BKEY 			0, 8
#define DPC_MAX_GKEY 			8, 8
#define DPC_MAX_RKEY 			16, 8
/* end Maximum Color Keying Register */

/* DPC Minimum Color Keying Register (DPC_OVL_MIN_KEY_REG) */
#define DPC_MIN_BKEY 			0, 8
#define DPC_MIN_GKEY 			8, 8
#define DPC_MIN_RKEY 			16, 8
/* end Minimum Color Keying Register */

/* (DPC_OVL_FLTR_COEF_REG) */
#define DPC_LUMA_COEFF0 		0, 6
#define DPC_LUMA_COEFF1 		8, 5
#define DPC_ALPHA_COEFF0 		16, 6
#define DPC_ALPHA_COEFF1 		24, 5

/* (DPC_OVL_DLIST1_REG) */
#define DPC_OVL_PIXMODE 		0, 4
#define DPC_HSCALE 				4, 2
#define DPC_VSCALE 				6, 2
#define DPC_OVL_FIRSTPIX 		8, 4
#define DPC_DLIST_INT 			12
#define DPC_DLIST_EOL 			13
#define DPC_GLOBAL_ALPHA 		16, 8
#define DPC_OVL_UNDR_VDO 		24

/* (DPC_OVL_DLIST2_REG) */
#define DPC_DLIST_LUTPTR 		0, 18
#define DPC_DLIST_MAP2 			18
#define DPC_DLIST_MAP4 			19
#define DPC_DLIST_PALLET4 		20
#define DPC_DLIST_PALLET8 		21

/* (DPC_AUX_CONFIG_REG) */
#define DPC_AUX_ITU60HZ 		0
#define DPC_AUX_SRC_INTL 		1
#define DPC_AUX_SRC_SEL 		2
#define DPC_AUX_BWMODE 			3
#define DPC_AUX_VDDA_PH 		8, 8
#define DPC_AUX_FIFO_TH 		16, 12

/* (DPC_AUX_POS_REG) */
#define DPC_AUX_XPOS 			0, 12
#define DPC_AUX_YPOS 			16, 11

/* (DPC_AUX_HS_CTL_REG) */
#define DPC_AUX_HFS 				0, 8
#define DPC_AUX_HFN 				8, 12
#define DPC_AUX_HFM 				20, 12

/* (DPC_AUX_VS_CTL_REG) */
#define DPC_AUX_VFS 				0, 8
#define DPC_AUX_VFN 				8, 12
#define DPC_AUX_VFM 				20, 12

/* DPC (DPC_AUX_PROG1_REG) */
#define DPC_AUX_HCNT_H0 		0, 11
#define DPC_AUX_HCNT_H1 		11, 11
#define DPC_AUX_PROG_FLG 		22

/* DPC (DPC_AUX_PROG2_REG) */
#define DPC_AUX_VCNT_MAX 		0, 10
#define DPC_AUX_VCNT_V0_F 		10, 10
#define DPC_AUX_VCNT_V1_F 		20, 10

/* DPC (DPC_AUX_PROG3_REG) */
#define DPC_AUX_VCNT_F1 		0, 10
#define DPC_AUX_VCNT_V0_S 		10, 10
#define DPC_AUX_VCNT_V1_S 		20, 10

/* DPC (DPC_CURS_SA_REG) */
#define DPC_CURS_SA 				4, 22

/* DPC (DPC_CURS_POS_REG) */
#define DPC_CURS_XPOS 			0, 11
#define DPC_CURS_YPOS 			16, 11

/* DPC (DPC_CURS_OFFSET_REG) */
#define DPC_CURS_XOFFSET 		0, 8
#define DPC_CURS_HSCALE 		8, 2
#define DPC_CURS_YOFFSET 		16, 8
#define DPC_CURS_VSCALE 		24, 2

/* DPC (DPC_CURSCLUTx_REG) */
#define DPC_CURSCLUT0 			0, 32
#define DPC_CURSCLUT1 			0, 32
#define DPC_CURSCLUT2 			0, 32
#define DPC_CURSCLUT3 			0, 32
#define DPC_CURSCLUT4 			0, 32
#define DPC_CURSCLUT5 			0, 32
#define DPC_CURSCLUT6 			0, 32
#define DPC_CURSCLUT7 			0, 32
#define DPC_CURSCLUT8 			0, 32
#define DPC_CURSCLUT9 			0, 32
#define DPC_CURSCLUT10 			0, 32
#define DPC_CURSCLUT11 			0, 32
#define DPC_CURSCLUT12 			0, 32
#define DPC_CURSCLUT13 			0, 32
#define DPC_CURSCLUT14 			0, 32
#define DPC_CURSCLUT15 			0, 32

/* DPC (DPC_MEM_ADDR_REG) */
#define DPC_MEM_ADDR 			0, 10
#define DPC_MEM_OVERRIDE 		16

/* DPC (DPC_MEM_DATA_REG) */
#define DPC_MEM_DATA 			0, 32

/* DPC (DPC_GPIO_EN_REG) */
#define DPC_GPIO_EN_RED			0, 8
#define DPC_GPIO_EN_BLU			8, 8
#define DPC_GPIO_EN_GRN			16, 8
#define DPC_GPIO_EN_HSYNC		24
#define DPC_GPIO_EN_VSYNC		25
#define DPC_GPIO_EN_DDC0		26
#define DPC_GPIO_EN_DDC1		27
#define DPC_GPIO_EN 				0, 28

/* DPC (DPC_GPIO_OUT_EN_REG) */
#define DPC_GPIO_OUT_EN_RED		0, 8
#define DPC_GPIO_OUT_EN_BLU		8, 8
#define DPC_GPIO_OUT_EN_GRN		16, 8
#define DPC_GPIO_OUT_EN_HSYNC		24
#define DPC_GPIO_OUT_EN_VSYNC		25
#define DPC_GPIO_OUT_EN_DDC0		26
#define DPC_GPIO_OUT_EN_DDC1		27
#define DPC_GPIO_OUT_EN		 		0, 28

/* DPC (DPC_GPIO_OUTDATA_REG) */
#define DPC_GPIO_OUTDATA_RED		0, 8
#define DPC_GPIO_OUTDATA_BLU		8, 8
#define DPC_GPIO_OUTDATA_GRN		16, 8
#define DPC_GPIO_OUTDATA_HSYNC	24
#define DPC_GPIO_OUTDATA_VSYNC	25
#define DPC_GPIO_OUTDATA_DDC0		26
#define DPC_GPIO_OUTDATA_DDC1		27
#define DPC_GPIO_OUTDATA 			0, 28

/* DPC (DPC_GPIO_INDATA_REG) */
#define DPC_GPIO_INDATA_RED		0, 8
#define DPC_GPIO_INDATA_BLU		8, 8
#define DPC_GPIO_INDATA_GRN		16, 8
#define DPC_GPIO_INDATA_HSYNC		24
#define DPC_GPIO_INDATA_VSYNC		25
#define DPC_GPIO_INDATA_DDC0		26
#define DPC_GPIO_INDATA_DDC1		27
#define DPC_GPIO_INDATA 			0, 28

/* DPC (MCE_CTRL_REG) */
#define MCE_TOC_FEN 				0
#define MCE_TOC_FLUSH_EN 		1
#define MCE_TIF_INDEX 			3, 5
#define MCE_MPEG1 				8
#define MCE_422_REG 				9, 2
#define MCE_DP_RST 				11
#define MCE_PWR_REG 				12
#define MCE_IBUF_FLOW_CNTL 	13
#define MCE_PIPE_STALL_EN 		14
#define MCE_TOC_BYTE_STUFF_EN	15
#define MCE_TOC_ONESHOT_EN 	16

/* DPC (MCE_STAT_REG) */
#define MCE_TOC_RDY 				0
#define MCE_TOC_FLUSH_DONE		1
#define MCE_TIF_FIFO_CNT 		2, 6
#define MCE_RZQ_BUSY 			8
#define MCE_DCT_BUSY 			9
#define MCE_MC_BUSY 				10
#define MCE_VLD_BUSY 			11
#define MCE_VLD_ERR_CODE 		12, 4

/* DPC (MCE_IE_REG) */
#define MCE_SYNC_DONE_IE 						0
#define MCE_VTOC_UF_IE 							1
#define MCE_VLD_NONSLICE_START_IE 			2
#define MCE_VLD_ERR_IE 							3
#define MCE_RZQ_RUN_IE 							4
#define MCE_MC_IENG_ERR_IE 					5
#define MCE_MC_IBUF_OV_IE 						6
#define MCE_TOC_RDY_IE 							7
#define MCE_TOC_FLUSH_DONE_IE					8
#define MCE_VLD_RLFIFO_UDF_IE 				9

/* DPC (MCE_IS_REG) */
#define MCE_SYNC_DONE_INT 						0
#define MCE_VTOC_UF_INT 						1
#define MCE_VLD_NONSLICE_START_INT 			2
#define MCE_VLD_ERR_INT 						3
#define MCE_RZQ_RUN_INT 						4
#define MCE_MC_IENG_ERR_INT 					5
#define MCE_MC_IBUF_OV_INT 					6
#define MCE_TOC_RDY_INT 						7
#define MCE_TOC_FLUSH_DONE_INT 				8
#define MCE_VLD_RLFIFO_UDF_INT 				9

/* DPC (MCE_IS_ALIAS_REG) */
#define MCE_SYNC_DONE_INT_ALIAS 				0
#define MCE_VTOC_UF_INT_ALIAS 				1
#define MCE_VLD_NONSLICE_START_INT_ALIAS 	2
#define MCE_VLD_ERR_INT_ALIAS 				3
#define MCE_RZQ_RUN_INT_ALIAS 				4
#define MCE_MC_IENG_ERR_INT_ALIAS 			5
#define MCE_MC_IBUF_OV_INT_ALIAS 			6
#define MCE_TOC_RDY_INT_ALIAS 				7
#define MCE_TOC_FLUSH_DONE_INT_ALIAS 		8
#define MCE_VLD_RLFIFO_UDF_INT_ALIAS 		9

/* DPC (MCE_SYNC_CTRL_REG) */
#define MCE_SYNC_SEN 			0
#define MCE_SYNC_PEN 			1
#define MCE_SYNC_RANGE 			2, 6
#define MCE_SYNC_PAT 			8, 8

/* DPC (MCE_SYNC_STAT_REG) */
#define MCE_SYNC_DONE 			0
#define MCE_SYNC_DET 			1
#define MCE_SYNCWORD 			8, 8

/* DPC (MCE_FNSSC_REG) */
#define MCE_FNSSC_RADR 			0, 17
#define MCE_FNSSC_INDEX 		18, 6
#define MCE_FNSSC_SC 			24, 8

/* DPC (MCE_FSSC_REG) */
#define MCE_FSSC_RADR 			0, 17
#define MCE_FSSC_INDEX 			18, 6
#define MCE_FSSC_SC 				24, 8

/* DPC (MCE_VLD_CTRL_REG) */
#define MCE_VLD_SHIFT_AMT 		0, 5
#define MCE_VLD_SS 				5
#define MCE_VLD_XTRC_HDR 		6
#define MCE_VLD_MBSKIP_SETUP 	7
#define MCE_VLD_GOTO_IDLE 		8

/* DPC (MCE_TOC_RDATA_REG) */
#define MCE_TOC_RDATA 			0, 32
		 
/* DPC (MCE_Q_WDATA_REG) */
#define MCE_QTAB_WDATA 			0, 8
#define MCE_QTAB_SEL 			8, 2
#define MCE_QADR_RST 			10

/* DPC (MCE_MPIC_REG) */
#define MCE_ALTERNATE_SCAN 					0
#define MCE_INTRA_VLC_FORMAT 					1
#define MCE_Q_SCALE_TYPE 						2
#define MCE_FRAME_PRED_FRAME_DCT 			3
#define MCE_INTRA_DC_PRECISION 				4, 2
#define MCE_PICTURE_STRUCTURE 				6, 2
#define MCE_PICTURE_CODING_TYPE 				8, 3
#define MCE_CONCEALMENT_MV 					11
#define MCE_F_CODE11 							16, 4
#define MCE_F_CODE10 							20, 4
#define MCE_F_CODE01 							24, 4
#define MCE_F_CODE00 							28, 4

/* DPC (MCE_CH_SADR_REG) */
#define MCE_CH_SADR 				0, 17

/* DPC (MCE_CH_EADR_REG) */
#define MCE_CH_EADR 				0, 17

/* DPC (MCE_CH_RADR_REG) */
#define MCE_CH_RADR 				0, 17

/* DPC (HPIP_CONFIG_REG) */
#define HPIP_EN 					0
#define HPIP_LP_BYPASS 			1
#define HPIP_I_BYPASS 			2

/* DPC (HPIP_STATUS_REG) */
#define HPIP_SRC_XPOS 			0, 7
#define HPIP_ROI_XPOS 			8, 7
#define HPIP_YPOS 				16, 7
#define HPIP_DONE_STATUS 		24

/* DPC (HPIP_INT_EN_REG) */
#define HPIP_DONE_INT_EN 		0

/* DPC (HPIP_INT_STAT_REG) */
#define HPIP_DONE_INT_STAT 	0

/* DPC (HPIP_PTR_REG) */
#define HPIP_DST_BASE_TOP 		0, 4
#define HPIP_DST_BASE_BOT 		8, 5

/* DPC (HPIP_X_FACTOR_REG) */
#define HPIP_SRC_WIDTH 			0, 7
#define HPIP_ROI_WIDTH 			8, 7
#define HPIP_ROI_XOFFSET 		16, 7
#define HPIP_DST_WIDTH 			24, 7

/* DPC (HPIP_Y_FACTOR_REG) */
#define HPIP_SRC_HEIGHT 		0, 7

/* DPC (HPIP_DDA_FACTOR_REG) */
#define HPIP_HFS 					0, 10
#define HPIP_HFN 					10, 11
#define HPIP_HFM 					21, 11

/* DPC (HPIP_COEFF_ADDR_REG) */
#define HPIP_COEFF_INDEX 		0, 3

/* DPC (HPIP_COEFF_DATA_REG) */
#define HPIP_COEFF_DATA1 		0, 12
#define HPIP_COEFF_DATA2 		16, 12

/* DPC (HPIP_CMODEL_REG) */
#define HPIP_SRC_BASE_TOP 		0, 5
#define HPIP_SRC_BASE_BOT 		8, 5
#define HPIP_PROGRESSIVE 		16
#define HPIP_FRAME_MODE 		20
#define HPIP_FIELD_SELECT 		24, 2

/* DPC (VPIP_CONFIG_REG) */
#define VPIP_LUM_SAME_FLD 		0, 2
#define VPIP_CHM_SAME_FLD 		2, 4
#define VPIP_MOA_EN 				4
#define VPIP_MOA_VERT 			5
#define VPIP_SAVE_BWIDTH 		6
#define VPIP_SHWMO 				7
#define VPIP_MOA_TH 				8, 4
#define VPIP_MODE 				12, 2
#define VPIP_SRC_FMT422 		14
#define VPIP_DST_FMT422 		15
#define VPIP_SRC_VALID_CNT 	16, 6
#define VPIP_CUR_FLD 			22

/* DPC (VPIP_INT_EN_REG) */
#define VPIP_DONE_INT_EN 		0

/* DPC VPIP_INT_STAT_REG) */
#define VPIP_DONE_INT_STAT 	0

/* DPC (VPIP_PTR_REG) */
#define VPIP_SRC_BASE_TOP 		0, 4
#define VPIP_SRC_BASE_BOT 		8, 4
#define VPIP_DST_BASE_TOP 		16, 4
#define VPIP_DST_BASE_BOT 		24, 4

/* DPC (VPIP_POS_X_REG) */
#define VPIP_SRC_X_LEFT 		3, 9
#define VPIP_DST_X_LEFT 		19, 9

/* DPC (VPIP_STATUS_REG) */
#define VPIP_SRC_X 				3, 9
#define VPIP_DST_X 				19, 9

/* DPC (VPIP_SIZE_REG) */
#define VPIP_WIDTH 				4, 8

/* DPC (VPIP_ROW_CONFIG_REG) */
#define VPIP_IDLE 				0
#define VPIP_LUMA_PASS 			1
#define VPIP_RD_BOT_FIRST 		2
#define VPIP_WR_BOT_FIRST 		3
#define VPIP_REPL_COUNT 		4, 4
#define VPIP_FIRST_PATCH 	   8
#define VPIP_LAST_PATCH 		9
#define VPIP_SRC_Y 				10, 11
#define VPIP_DST_Y 				21, 11

/* DPC (VPIP_DDA_FACTOR_REG) */
#define VPIP_VFS 					0, 10
#define VPIP_VFN					10, 11
#define VPIP_VFM 					21, 11

/* DPC  (VPIP_COEFF_ADDR_REG) */
#define VPIP_COEFF_INDEX 		0, 3

/* DPC  (VPIP_COEFF_DATA_REG) */
#define VPIP_COEFF_DATA1 		0, 12
#define VPIP_COEFF_DATA2 		16, 12

/* DPC  (VPIP_ROW_CONFIG2_REG) */
#define VPIP_DDA_ERROR 			0, 12
#define VPIP_DDA_PHASE 			12, 11
#define VPIP_DDA_LUMA_OW 		31

/* DPC  (VPIP_STATUS2_REG) */
#define VPIP_PATCH_HEIGHT 		0, 6

/* DPC  (MIF_CONFIG_REG) */
#define MIF_MEM_WIDTH 			0
#define MIF_NUM_RANK 			2
#define MIF_RANK_SIZE 			4, 3
#define MIF_NUM_BANK 			8
#define MIF_BANK_SELECT 		12, 3
#define MIF_NUM_COL 				16, 3
#define MIF_TRAS 					20, 2
#define MIF_REFRESH_PERIOD 	24, 8

/* DPC  (MIF_FLD_DSCR_0_REG) */
#define FLD_HEIGHT_0 			0, 7
#define FLD_FORMAT_0 			7
#define FLD_WIDTH_0 				8, 6
#define FLD_AMR_MODE_0 			14, 2
#define FLD_BASE_ADDR_0 		16, 15

/* DPC  (MIF_FLD_DSCR_1_REG) */
#define FLD_HEIGHT_1 			0, 7
#define FLD_FORMAT_1 			7
#define FLD_WIDTH_1 				8, 6
#define FLD_AMR_MODE_1 			14, 2
#define FLD_BASE_ADDR_1 		16, 15

/* DPC  (MIF_FLD_DSCR_2_REG) */
#define FLD_HEIGHT_2 			0, 7
#define FLD_FORMAT_2 			7
#define FLD_WIDTH_2 				8, 6
#define FLD_AMR_MODE_2 			14, 2
#define FLD_BASE_ADDR_2 		16, 15

/* DPC  (MIF_FLD_DSCR_3_REG) */
#define FLD_HEIGHT_3 			0, 7
#define FLD_FORMAT_3 			7
#define FLD_WIDTH_3 				8, 6
#define FLD_AMR_MODE_3 			14, 2
#define FLD_BASE_ADDR_3 		16, 15

/* DPC  (MIF_FLD_DSCR_4_REG) */
#define FLD_HEIGHT_4 			0, 7
#define FLD_FORMAT_4 			7
#define FLD_WIDTH_4 				8, 6
#define FLD_AMR_MODE_4 			14, 2
#define FLD_BASE_ADDR_4 		16, 15

/* DPC  (MIF_FLD_DSCR_5_REG) */
#define FLD_HEIGHT_5 			0, 7
#define FLD_FORMAT_5 			7
#define FLD_WIDTH_5 				8, 6
#define FLD_AMR_MODE_5 			14, 2
#define FLD_BASE_ADDR_5 		16, 15

/* DPC  (MIF_FLD_DSCR_6_REG) */
#define FLD_HEIGHT_6 			0, 7
#define FLD_FORMAT_6 			7
#define FLD_WIDTH_6 				8, 6
#define FLD_AMR_MODE_6 			14, 2
#define FLD_BASE_ADDR_6 		16, 15

/* DPC  (MIF_FLD_DSCR_7_REG) */
#define FLD_HEIGHT_7 			0, 7
#define FLD_FORMAT_7 			7
#define FLD_WIDTH_7 				8, 6
#define FLD_AMR_MODE_7 			14, 2
#define FLD_BASE_ADDR_7 		16, 15

/* DPC  (MIF_FLD_DSCR_8_REG) */
#define FLD_HEIGHT_8 			0, 7
#define FLD_FORMAT_8 			7
#define FLD_WIDTH_8 				8, 6
#define FLD_AMR_MODE_8 			14, 2
#define FLD_BASE_ADDR_8 		16, 15

/* DPC  (MIF_FLD_DSCR_9_REG) */
#define FLD_HEIGHT_9 			0, 7
#define FLD_FORMAT_9 			7
#define FLD_WIDTH_9 				8, 6
#define FLD_AMR_MODE_9 			14, 2
#define FLD_BASE_ADDR_9 		16, 15

/* DPC  (MIF_FLD_DSCR_10_REG) */
#define FLD_HEIGHT_10 			0, 7
#define FLD_FORMAT_10 			7
#define FLD_WIDTH_10 			8, 6
#define FLD_AMR_MODE_10 		14, 2
#define FLD_BASE_ADDR_10 		16, 15

/* DPC  (MIF_FLD_DSCR_11_REG) */
#define FLD_HEIGHT_11 			0, 7
#define FLD_FORMAT_11 			7
#define FLD_WIDTH_11 			8, 6
#define FLD_AMR_MODE_11 		14, 2
#define FLD_BASE_ADDR_11 		16, 15

/* DPC  (MIF_FLD_DSCR_12_REG) */
#define FLD_HEIGHT_12 			0, 7
#define FLD_FORMAT_12 			7
#define FLD_WIDTH_12 			8, 6
#define FLD_AMR_MODE_12 		14, 2
#define FLD_BASE_ADDR_12 		16, 15

/* DPC  (MIF_FLD_DSCR_13_REG) */
#define FLD_HEIGHT_13 			0, 7
#define FLD_FORMAT_13 			7
#define FLD_WIDTH_13 			8, 6
#define FLD_AMR_MODE_13 		14, 2
#define FLD_BASE_ADDR_13 		16, 15

/* DPC  (MIF_FLD_DSCR_14_REG) */
#define FLD_HEIGHT_14 			0, 7
#define FLD_FORMAT_14 			7
#define FLD_WIDTH_14 			8, 6
#define FLD_AMR_MODE_14 		14, 2
#define FLD_BASE_ADDR_14 		16, 15

/* DPC  (MIF_FLD_DSCR_15_REG) */
#define FLD_HEIGHT_15 			0, 7
#define FLD_FORMAT_15 			7
#define FLD_WIDTH_15 			8, 6
#define FLD_AMR_MODE_15 		14, 2
#define FLD_BASE_ADDR_15 		16, 15

/* DPC  (MIF_STATUS_HIF_RD) */
#define MIF_STATUS_HIF_RD_MREQ 				0
#define MIF_STATUS_HIF_RD_BUSY 				1
#define MIF_STATUS_HIF_RD_READY0 			4
#define MIF_STATUS_HIF_RD_READY1 			5
#define MIF_STATUS_HIF_RD_READY2 			6
#define MIF_STATUS_HIF_RD_READY3 			7
#define MIF_STATUS_HIF_RD_DESC_CNT 			8, 4
#define MIF_STATUS_HIF_RD_BUF_CNT 			12, 4

/* DPC  (MIF_STATUS_APU_RD) */
#define MIF_STATUS_APU_RD_MREQ 				0
#define MIF_STATUS_APU_RD_BUSY 				1
#define MIF_STATUS_APU_RD_READY0 			4
#define MIF_STATUS_APU_RD_READY1 			5
#define MIF_STATUS_APU_RD_READY2 			6
#define MIF_STATUS_APU_RD_READY3 			7
#define MIF_STATUS_APU_RD_DESC_CNT 			8, 4
#define MIF_STATUS_APU_RD_BUF_CNT 			12, 4

/* DPC  (MIF_STATUS_TOC) */
#define MIF_STATUS_TOC_MREQ 					0
#define MIF_STATUS_TOC_BUSY 					1
#define MIF_STATUS_TOC_READY0 				4
#define MIF_STATUS_TOC_READY1 				5
#define MIF_STATUS_TOC_READY2 				6
#define MIF_STATUS_TOC_READY3 				7
#define MIF_STATUS_TOC_DESC_CNT 				8, 4
#define MIF_STATUS_TOC_BUF_CNT 				12, 4

/* DPC  (MIF_STATUS_BLT0_RD) */
#define MIF_STATUS_BLT0_RD_MREQ 				0
#define MIF_STATUS_BLT0_RD_BUSY 				1
#define MIF_STATUS_BLT0_RD_READY0 			4
#define MIF_STATUS_BLT0_RD_READY1 			5
#define MIF_STATUS_BLT0_RD_READY2 			6
#define MIF_STATUS_BLT0_RD_READY3 			7
#define MIF_STATUS_BLT0_RD_DESC_CNT 		8, 4
#define MIF_STATUS_BLT0_RD_BUF_CNT 			12, 4

/* DPC  (MIF_STATUS_VPIP_RD) */
#define MIF_STATUS_VPIP_RD_MREQ 				0
#define MIF_STATUS_VPIP_RD_BUSY 				1
#define MIF_STATUS_VPIP_RD_READY0 			4
#define MIF_STATUS_VPIP_RD_READY1 			5
#define MIF_STATUS_VPIP_RD_READY2 			6
#define MIF_STATUS_VPIP_RD_READY3 			7
#define MIF_STATUS_VPIP_RD_DESC_CNT 		8, 4
#define MIF_STATUS_VPIP_RD_BUF_CNT 			12, 4

/* DPC  (MIF_STATUS_BVDO1) */
#define MIF_STATUS_BVDO1_MREQ 				0
#define MIF_STATUS_BVDO1_BUSY 				1
#define MIF_STATUS_BVDO1_READY0 				4
#define MIF_STATUS_BVDO1_READY1 				5
#define MIF_STATUS_BVDO1_READY2 				6
#define MIF_STATUS_BVDO1_READY3 				7
#define MIF_STATUS_BVDO1_DESC_CNT 			8, 4
#define MIF_STATUS_BVDO1_BUF_CNT 			12, 4

/* DPC  (MIF_STATUS_CLUT) */
#define MIF_STATUS_CLUT_MREQ 					0
#define MIF_STATUS_CLUT_BUSY 					1
#define MIF_STATUS_CLUT_READY0 				4
#define MIF_STATUS_CLUT_READY1 				5
#define MIF_STATUS_CLUT_READY2 				6
#define MIF_STATUS_CLUT_READY3 				7
#define MIF_STATUS_CLUT_DESC_CNT 			8, 4
#define MIF_STATUS_CLUT_BUF_CNT 				12, 4

/* DPC  (MIF_STATUS_MC_RD) */
#define MIF_STATUS_MC_RD_MREQ 				0
#define MIF_STATUS_MC_RD_BUSY 				1
#define MIF_STATUS_MC_RD_READY0 				4
#define MIF_STATUS_MC_RD_READY1 				5
#define MIF_STATUS_MC_RD_READY2 				6
#define MIF_STATUS_MC_RD_READY3 				7
#define MIF_STATUS_MC_RD_DESC_CNT 			8, 4
#define MIF_STATUS_MC_RD_BUF_CNT 			12, 4

/* DPC  (MIF_STATUS_OVL1) */
#define MIF_STATUS_OVL1_MREQ 					0
#define MIF_STATUS_OVL1_BUSY 					1
#define MIF_STATUS_OVL1_READY0 				4
#define MIF_STATUS_OVL1_READY1 				5
#define MIF_STATUS_OVL1_READY2 				6
#define MIF_STATUS_OVL1_READY3 				7
#define MIF_STATUS_OVL1_DESC_CNT 			8, 4
#define MIF_STATUS_OVL1_BUF_CNT 				12, 4

/* DPC  (MIF_STATUS_OVL2) */
#define MIF_STATUS_OVL2_MREQ 					0
#define MIF_STATUS_OVL2_BUSY 					1
#define MIF_STATUS_OVL2_READY0 				4
#define MIF_STATUS_OVL2_READY1 				5
#define MIF_STATUS_OVL2_READY2 				6
#define MIF_STATUS_OVL2_READY3 				7
#define MIF_STATUS_OVL2_DESC_CNT 			8, 4
#define MIF_STATUS_OVL2_BUF_CNT 				12, 4

/* DPC  (MIF_STATUS_BLT1_RD) */
#define MIF_STATUS_BLT1_RD_MREQ 				0
#define MIF_STATUS_BLT1_RD_BUSY 				1
#define MIF_STATUS_BLT1_RD_READY0 			4
#define MIF_STATUS_BLT1_RD_READY1 			5
#define MIF_STATUS_BLT1_RD_READY2 			6
#define MIF_STATUS_BLT1_RD_READY3 			7
#define MIF_STATUS_BLT1_RD_DESC_CNT 		8, 4 
#define MIF_STATUS_BLT1_RD_BUF_CNT 			12, 4

/* DPC  (MIF_STATUS_BLT2_RD) */
#define MIF_STATUS_BLT2_RD_MREQ 				0
#define MIF_STATUS_BLT2_RD_BUSY 				1
#define MIF_STATUS_BLT2_RD_READY0 			4
#define MIF_STATUS_BLT2_RD_READY1 			5
#define MIF_STATUS_BLT2_RD_READY2 			6
#define MIF_STATUS_BLT2_RD_READY3 			7
#define MIF_STATUS_BLT2_RD_DESC_CNT 		8, 4
#define MIF_STATUS_BLT2_RD_BUF_CNT 			12, 4

/* DPC  (MIF_STATUS_BVDO2) */
#define MIF_STATUS_BVDO2_MREQ 				0
#define MIF_STATUS_BVDO2_BUSY 				1
#define MIF_STATUS_BVDO2_READY0 				4
#define MIF_STATUS_BVDO2_READY1 				5
#define MIF_STATUS_BVDO2_READY2 				6
#define MIF_STATUS_BVDO2_READY3 				7
#define MIF_STATUS_BVDO2_DESC_CNT 			8, 4
#define MIF_STATUS_BVDO2_BUF_CNT 			12, 4

/* DPC  (MIF_STATUS_BVDO3) */
#define MIF_STATUS_BVDO3_MREQ 				0
#define MIF_STATUS_BVDO3_BUSY 				1
#define MIF_STATUS_BVDO3_READY0 				4
#define MIF_STATUS_BVDO3_READY1 				5
#define MIF_STATUS_BVDO3_READY2 				6
#define MIF_STATUS_BVDO3_READY3 				7
#define MIF_STATUS_BVDO3_DESC_CNT 			8, 4
#define MIF_STATUS_BVDO3_BUF_CNT 			12, 4

/* DPC  (MIF_STATUS_CURS) */
#define MIF_STATUS_CURS_MREQ 					0
#define MIF_STATUS_CURS_BUSY 					1
#define MIF_STATUS_CURS_READY0 				4
#define MIF_STATUS_CURS_READY1 				5
#define MIF_STATUS_CURS_READY2 				6
#define MIF_STATUS_CURS_READY3 				7
#define MIF_STATUS_CURS_DESC_CNT 			8, 4
#define MIF_STATUS_CURS_BUF_CNT 				12, 4

/* DPC  (MIF_STATUS_DL) */
#define MIF_STATUS_DL_MREQ 					0
#define MIF_STATUS_DL_BUSY 					1
#define MIF_STATUS_DL_READY0 					4
#define MIF_STATUS_DL_READY1 					5
#define MIF_STATUS_DL_READY2 					6
#define MIF_STATUS_DL_READY3 					7
#define MIF_STATUS_DL_DESC_CNT 				8, 4
#define MIF_STATUS_DL_BUF_CNT 				12, 4

/* DPC  (MIF_STATUS_HIF_WR) */
#define MIF_STATUS_HIF_WR_MREQ 				0
#define MIF_STATUS_HIF_WR_BUSY 				1
#define MIF_STATUS_HIF_WR_READY0 			4
#define MIF_STATUS_HIF_WR_READY1 			5
#define MIF_STATUS_HIF_WR_READY2 			6
#define MIF_STATUS_HIF_WR_READY3 			7
#define MIF_STATUS_HIF_WR_DESC_CNT 			8, 4
#define MIF_STATUS_HIF_WR_BUF_CNT 			12, 4

/* DPC  (MIF_STATUS_APU_WR) */
#define MIF_STATUS_APU_WR_MREQ 				0
#define MIF_STATUS_APU_WR_BUSY 				1
#define MIF_STATUS_APU_WR_READY0 			4
#define MIF_STATUS_APU_WR_READY1 			5
#define MIF_STATUS_APU_WR_READY2 			6
#define MIF_STATUS_APU_WR_READY3 			7
#define MIF_STATUS_APU_WR_DESC_CNT 			8, 4
#define MIF_STATUS_APU_WR_BUF_CNT 			12, 4

/* DPC  (MIF_STATUS_TRANS) */
#define MIF_STATUS_TRANS_MREQ 				0
#define MIF_STATUS_TRANS_BUSY 				1
#define MIF_STATUS_TRANS_READY0 				4
#define MIF_STATUS_TRANS_READY1 				5
#define MIF_STATUS_TRANS_READY2 				6
#define MIF_STATUS_TRANS_READY3 				7
#define MIF_STATUS_TRANS_DESC_CNT 			8, 4
#define MIF_STATUS_TRANS_BUF_CNT 			12, 4

/* DPC  (MIF_STATUS_BLT_WR) */
#define MIF_STATUS_BLT_WR_MREQ 				0
#define MIF_STATUS_BLT_WR_BUSY 				1
#define MIF_STATUS_BLT_WR_READY0 			4
#define MIF_STATUS_BLT_WR_READY1 			5
#define MIF_STATUS_BLT_WR_READY2 			6
#define MIF_STATUS_BLT_WR_READY3 			7
#define MIF_STATUS_BLT_WR_DESC_CNT 			8, 4
#define MIF_STATUS_BLT_WR_BUF_CNT 			12, 4

/* DPC  (MIF_STATUS_VPIP_WR) */
#define MIF_STATUS_VPIP_WR_MREQ 				0
#define MIF_STATUS_VPIP_WR_BUSY 				1
#define MIF_STATUS_VPIP_WR_READY0 			4
#define MIF_STATUS_VPIP_WR_READY1 			5
#define MIF_STATUS_VPIP_WR_READY2 			6
#define MIF_STATUS_VPIP_WR_READY3 			7
#define MIF_STATUS_VPIP_WR_DESC_CNT 		8, 4
#define MIF_STATUS_VPIP_WR_BUF_CNT 			12, 4

/* DPC  (MIF_STATUS_HPIP) */
#define MIF_STATUS_HPIP_MREQ 					0
#define MIF_STATUS_HPIP_BUSY 					1
#define MIF_STATUS_HPIP_READY0 				4
#define MIF_STATUS_HPIP_READY1 				5
#define MIF_STATUS_HPIP_READY2 				6
#define MIF_STATUS_HPIP_READY3 				7
#define MIF_STATUS_HPIP_DESC_CNT 			8, 4
#define MIF_STATUS_HPIP_BUF_CNT 				12, 4

/* DPC  (MIF_STATUS_VSC) */
#define MIF_STATUS_VSC_MREQ 					0
#define MIF_STATUS_VSC_BUSY 					1
#define MIF_STATUS_VSC_READY0 				4
#define MIF_STATUS_VSC_READY1 				5
#define MIF_STATUS_VSC_READY2 				6
#define MIF_STATUS_VSC_READY3 				7
#define MIF_STATUS_VSC_DESC_CNT 				8, 4
#define MIF_STATUS_VSC_BUF_CNT 				12, 4

/* DPC  (MIF_STATUS_MC_WR) */
#define MIF_STATUS_MC_WR_MREQ 				0
#define MIF_STATUS_MC_WR_BUSY 				1
#define MIF_STATUS_MC_WR_READY0 				4
#define MIF_STATUS_MC_WR_READY1 				5
#define MIF_STATUS_MC_WR_READY2 				6
#define MIF_STATUS_MC_WR_READY3 				7
#define MIF_STATUS_MC_WR_DESC_CNT 			8, 4
#define MIF_STATUS_MC_WRBUF_CNT 				12, 4

/* DPC  (MCU_HALT_REG) */
#define MCU_SS 									1
#define MCU_HLT 									0

/* DPC  (MCU_COND_CODE) */
#define MCU_CC_V 									3
#define MCU_CC_N 									2
#define MCU_CC_C 									1
#define MCU_CC_Z 									0

/* DPC  (MCU_RAM_SLICE_VERTICAL_POSITION) */
#define MCU_SLICE_VERTICAL_POSITION 		0, 8

/* DPC  (MCU_RAM_MBAINC) */
#define MCU_MBAINC 								0, 8

/* DPC  (MCU_RAM_MOTION_TYPE) */
#define MCU_MOTION_TYPE 						0, 2
#define MCU_MACROBLOCK_MOTION_FORWARD 		10
#define MCU_MACROBLOCK_MOTION_BACKWARD 	9
#define MCU_MACROBLOCK_INTRA 					8

/* DPC  (MCU_RAM_MVECTOR) */
#define MCU_MOTION_VERTICAL_FIELD_SELECT_00 		0
#define MCU_MOTION_VERTICAL_FIELD_SELECT_01 		1
#define MCU_MOTION_VERTICAL_FIELD_SELECT_10 		2
#define MCU_MOTION_VERTICAL_FIELD_SELECT_11 		3
#define MCU_DMVECTOR_0 									8, 2
#define MCU_DMVECTOR_1 									12, 2

/* DPC  (MCU_RAM_DELTA_xxx) */
#define MCU_DELTA_R_S_T_000 					0, 11
#define MCU_DELTA_R_S_T_001 					0, 11
#define MCU_DELTA_R_S_T_010 					0, 11
#define MCU_DELTA_R_S_T_011 					0, 11
#define MCU_DELTA_R_S_T_100 					0, 11
#define MCU_DELTA_R_S_T_101 					0, 11
#define MCU_DELTA_R_S_T_110 					0, 11
#define MCU_DELTA_R_S_T_111 					0, 11

/* DPC  (MCU_RAM_PICTURE_CODING_STRUCTURE) */
#define MCU_PICTURE_CODING_TYPE 				0, 2
#define MCU_PICTURE_STRUCTURE 				8, 2

/* DPC  (MCU_RAM_PICTURE_FIELD) */
#define MCU_TOP_FIELD_FIRST 					0
#define MCU_SECOND_FIELD 						8

/* DPC  (MCU_RAM_MV_FRAME) */
#define MCU_FRAME_PRED_FRAME_DCT 			0
#define MCU_CONCEALMENT_MOTION_VECTORS 	8

/* DPC  (MCU_RAM_MB_WIDTH) */
#define MCU_MB_WIDTH 							0, 8

/* DPC  (MCU_RAM_MBAMAX) */
#define MCU_MBAMAX 								0, 14

/* DPC  (MCU_RAM_RANGE_xx) */
#define MCU_RANGE_S_T_00 						0, 13
#define MCU_RANGE_S_T_01 						0, 13
#define MCU_RANGE_S_T_10 						0, 13
#define MCU_RANGE_S_T_11 						0, 134

/* DPC  (MCU_RAM_FBUF_BASE_FWD) */
#define MCU_FBUF_BASE_FWD_EVEN 				0, 4
#define MCU_FBUF_BASE_FWD_ODD 				8, 4

/* DPC  (MCU_RAM_FBUF_BASE_BWD) */
#define MCU_FBUF_BASE_BWD_EVEN 				0, 4
#define MCU_FBUF_BASE_BWD_ODD 				8, 4

/* DPC  (MCU_RAM_FBUF_BASE_DST) */
#define MCU_FBUF_BASE_DST_EVEN 				0, 4
#define MCU_FBUF_BASE_DST_ODD 				8, 4

/* DPC  (MCU_RAM_PICTURE_START) */
#define MCU_PICTURE_START 						0

/* DPC  (APU_IOC_CONFIG_REG) */
#define APU_IJFY 									0
#define APU_ACE 									1
#define APU_IDLY 									2
#define APU_IWL0 									3, 2
#define APU_IWL1 									5, 2
#define APU_IWL2 									7, 2
#define APU_IOC_OWL 								9, 2
#define APU_BYP 									15
#define APU_ICM 									16, 2
#define APU_OCM 									18, 2
#define APU_BCX 									20, 2
#define APU_ACM 									22, 2
#define APU_ACX 									24, 2

/* DPC  (APU_CPB_CONFIG_REG) */
#define APU_CFR 									0
#define APU_CMSK 									1, 6
#define APU_CEN 									7
#define APU_PEN 									8
#define APU_PBM0 									9, 2
#define APU_PBM1 									11, 2
#define APU_PBM2 									13, 2
#define APU_IAM0 									16, 2
#define APU_IAM1 									18, 2
#define APU_IAM2 									20,2 

/* DPC  (APU_CPB_CONFIG_REG) */
#define APU_ENB 									0
#define APU_IEC_OWL 								1, 2
#define APU_MOD0 									3, 2
#define APU_MOD1 									5, 2
#define APU_CSM 									7
#define APU_SEL0 									8, 3
#define APU_SEL1 									12, 3
#define APU_IECAUX 								16, 4
#define APU_U 										20
#define APU_V 										21
#define APU_P 										22
#define APU_FMC 									24, 8

/* DPC  (APU_IEC_CSB1_REG) */
#define APU_CSB1 									0, 32

/* DPC  (APU_IEC_CSB2_REG) */
#define APU_CSB2 									0, 32

/* DPC  (APU_INT_CONFIG_REG) */
#define APU_MATINT 								0, 3
#define APU_CAPOVF_EN 							5
#define APU_CAPUNF_EN 							6
#define APU_IAUWRP_EN 							8, 3
#define APU_IECFRM_EN 							11, 2

/* DPC  (APU_INT_STATUS_REG) */
#define APU_MATINT_STAT 						0
#define APU_CAPOVF_STAT 						5
#define APU_CAPUNF_STAT 						6
#define APU_IAUWRP_STAT							8, 3
#define APU_IECFRM_STAT 						11

/* DPC  (APU_CPB_CxA_REG) */
#define APU_CBA 			5, 20
#define APU_CEA 			5, 20
#define APU_CWA 			5, 20
#define APU_CRA 			5, 20
#define APU_CMA 			5, 20

/* DPC  (APU_IAU_IBAx_REG) */
#define APU_IBA0 			5, 20
#define APU_IBA1 			5, 20
#define APU_IBA2 			5, 20

/* DPC  (APU_IAU_IRAx_REG) */
#define APU_IRA0 			5, 20
#define APU_IRA1 			5, 20
#define APU_IRA2 			5, 20

/* DPC  (APU_IAU_IEAx_REG) */
#define APU_IEA0 			5, 20
#define APU_IEA1 			5, 20
#define APU_IEA2 			5, 20

/* DPC  (APU_MIX_CONFIG_REG) */
#define APU_MIXM0 		0, 2
#define APU_MIXM1 		2, 2
#define APU_MIXM2 		4, 2
#define APU_MIXC0 		8, 8
#define APU_MIXC1 		16, 8
#define APU_MIXC2 		24, 8

/* DPC  (APU_MIX_XFC0_REG) */
#define APU_XFC11 		24, 8
#define APU_XFC10 		16, 8
#define APU_XFC01 		8, 8
#define APU_XFC00 		0, 8

/* DPC  (APU_MIX_XFC1_REG) */
#define APU_XFC13 		24, 8
#define APU_XFC12 		16, 8
#define APU_XFC03 		8, 8
#define APU_XFC02 		0, 8

/* DPC  (APU_MIX_XFC2_REG) */
#define APU_XFC15 		24, 8
#define APU_XFC14 		16, 8
#define APU_XFC05 		8, 8
#define APU_XFC04 		0, 8

/* DPC  (APU_MIX_XFC3_REG) */
#define APU_XFC31 		24, 8
#define APU_XFC30 		16, 8
#define APU_XFC21 		8, 8
#define APU_XFC20 		0, 8

/* DPC  (APU_MIX_XFC4_REG) */
#define APU_XFC33 		24, 8
#define APU_XFC32 		16, 8
#define APU_XFC23 		8, 8
#define APU_XFC22 		0, 8

/* DPC  (APU_MIX_XFC5_REG) */
#define APU_XFC35 		24, 8
#define APU_XFC34 		16, 8
#define APU_XFC25 		8, 8
#define APU_XFC24 		0, 8

/* DPC  (APU_MIX_XFC6_REG) */
#define APU_XFC51 		24, 8
#define APU_XFC50 		16, 8
#define APU_XFC41 		8, 8
#define APU_XFC40 		0, 8

/* DPC  (APU_MIX_XFC7_REG) */
#define APU_XFC53 		24, 8
#define APU_XFC52 		16, 8
#define APU_XFC43 		8, 8
#define APU_XFC42 		0, 8

/* DPC  (APU_MIX_XFC8_REG) */
#define APU_XFC55 		24, 8
#define APU_XFC54 		16, 8
#define APU_XFC45 		8, 8
#define APU_XFC44 		0, 8

/* DPC  (VSC_CTRL_REG) */
#define VSC_EN 					0
#define VSC_VBI_EN0 				1
#define VSC_VBI_EN1 				2
#define VSC_VBI_VACT_ON 		3
#define VSC_VACT_POLARITY 		4
#define VSC_CTYPE 				5
#define VSC_VLINE_ICNT 			6, 10

/* DPC  (VSC_STAT__REG) */
#define VSC_V_FLAG 				0
#define VSC_F_FLAG 				1

/* DPC  (VSC_INT_EN_REG) */
#define VSC_IBUF_OV_IE 			0
#define VSC_VLINE_IE 			1
#define VSC_VBLANK0_IE 			2
#define VSC_VBLANK1_IE 			3
#define VSC_F0_IE 				4
#define VSC_F1_IE 				5
#define VSC_VBI_IE 				6

/* DPC  (VSC_INT_STAT_REG) */
#define VSC_IBUF_OV_INT 		0
#define VSC_VLINE_INT 			1
#define VSC_VBLANK0_INT 		2
#define VSC_VBLANK1_INT 		3
#define VSC_F0_INT 				4
#define VSC_F1_INT 				5
#define VSC_VBI_INT 				6

/* DPC  (VSC_MIF_REG) */
#define VSC_BASE0 				0, 4
#define VSC_F0_OFFSET 			7
#define VSC_BASE1 				8, 4

/* DPC  (VSC_DDA_REG) */
#define VSC_HSTEP_REG 			0, 20
#define VSC_LPHASE 				24, 8

/* DPC  (VSC_HS_REG) */
#define VSC_LINE_WIDTH 			0, 10
#define VSC_SV_HSIZE 			16, 10

/* DPC  (VSC_VBI0_REG) */
#define VSC_VBI0_VOFFSET 		0, 10
#define VSC_VBI0_VSIZE 			16, 9

/* DPC  (VSC_VBI1_REG) */
#define VSC_VBI1_VOFFSET 		0, 10
#define VSC_VBI1_VSIZE 			16, 9

/* DPC  (VSC_VBUF_SADR_REG) */
#define VSC_VBUF_SADR 			3, 23

/* DPC  (VSC_VBUF_WADR_REG) */
#define VSC_VBUF_WADR 			3, 23

/* DPC  (BLT_CHAN_S0_REG) */
#define BLT_X_DIR0 				0
#define BLT_Y_DIR0 				1
#define BLT_PIX_FORMAT0 		2, 4
#define BLT_BLOCK_PAINT0 		6
#define BLT_REDUCE_PIX0 		7, 2
#define BLT_MASK0 				9

/* DPC  (BLT_CHAN_S1_REG) */
#define BLT_X_DIR1 				0
#define BLT_Y_DIR1 				1
#define BLT_PIX_FORMAT1 		2, 4
#define BLT_BLOCK_PAINT1 		6
#define BLT_REDUCE_PIX1 		7, 2
#define BLT_MASK1 				9

/* DPC  (BLT_CHAN_D_REG) */
#define BLT_XY_DITHER 			6, 2

/* DPC  (BLT_CMD_REG) */
#define BLT_BLTOP 				0, 2
#define BLT_BLENDON 				2
#define BLT_ENABLE_S0 			3
#define BLT_ENABLE_S1 			4
#define BLT_ENABLE_D 			5
#define BLT_LINK_LIST_ENABLE 	6
#define BLT_BLTROP 				8, 8
#define BLT_BOOL_SEL_ALPHA 	16, 2

/* DPC  (BLT_STAT_REG) */
#define PACE_BLT 					0, 2
#define SUSPEND_BLT 				2
#define BLT_MASK_FIELD 			3
#define BLT_BUSY 					4
#define END_BLT 					5

/* DPC  (BLT_INTR_STAT_REG) */
#define BLT_END_STATUS 					0
#define BLT_END_OF_CHAIN_STATUS 		1
#define BLT_LATE 							2
#define MASK_BLT_END 					3
#define MASK_END_CHAIN_BLT				4
#define MASK_BLT_LATE 					5

/* DPC  (BLT_LEFT_ADDRESS_Sx_REG) */
#define BLT_LEFT_ADDRESS0 		0, 28
#define BLT_LEFT_ADDRESS1 		0, 28

/* DPC  (BLT_RIGHT_ADDRESS_Sx_REG) */
#define BLT_RIGHT_ADDRESS0 	0, 28
#define BLT_RIGHT_ADDRESS1 	0, 28

/* DPC  (BLT_Sx_PITCH_SIZ_REG) */
#define BLT_PITCH0 				0, 16
#define BLT_PITCH1 				0, 16

/* DPC  (BLT_H_W_REG) */
#define BLT_WIDTH 				0, 16
#define BLT_HEIGHT 				16, 16

/* DPC  (BLT_LINK_ADDR_REG) */
#define BLT_LINK_ADDR 			0, 23

/* DPC  (BLT_S0_FG_COLOR_REG) */
#define BLT_S0_FG_COL 			0, 32

/* DPC  (BLT_S0_BG_REG) */
#define BLT_S0_BG 				0, 32

/* DPC  (BLT_S1_FG_COLOR_REG) */
#define BLT_S1_FG_COL 			0, 32

/* DPC  (BLT_S1_BG_REG) */
#define BLT_S1_BG 				0, 32

/* DPC  (BLT_ALPHA_REG) */
#define BLT_GLO_ALPHA_S 		0, 8
#define BLT_GLO_ALPHA_D 		8, 8
#define BLT_SEL_ALPHA_S 		16, 3
#define BLT_SEL_ALPHA_D 		19, 3
#define BLT_SEL_NEW_ALPHA_D 	22, 4

/* DPC  (BLT_PACE_LINE_REG) */
#define BLT_PACE_LINE 			0, 11

/* DPC  (HIF_INIT_REG) */
#define HIF_BUS_WIDTH 			0
#define HIF_ENDIAN 				1
#define HIF_BYTE_EN 				2
#define HIF_RW_POL 				3
#define HIF_WAIT_POL 			4
#define HIF_SIZE_TR 				5
#define HIF_BURST_IND 			6
#define HIF_STATE 				8, 4

/* DPC  (HIF_STAT_REG) */
#define HIF_WRB_EMPTY 			0

/* DPC  (HIF_INT0_STAT_REG) */
#define HIF_APU_INTR0 			0
#define HIF_BLT_INTR0 			1
#define HIF_MIF_INTR0 			2
#define HIF_DPC_INTR0 			3
#define HIF_VSC_INTR0 			4
#define HIF_HIF_INTR0 			5
#define HIF_MCE_INTR0 			6
#define HIF_VPIP_INTR0 			7
#define HIF_HPIP_INTR0 			8
#define HIF_MCU_INTR0 			9
#define HIF_TS_INTR0 			10
#define HIF_AMR_INTR0 			11

/* DPC  (HIF_INT0_MASK_REG) */
#define HIF_APU_INTR0_EN 		0
#define HIF_BLT_INTR0_EN 		1
#define HIF_MIF_INTR0_EN 		2
#define HIF_DPC_INTR0_EN 		3
#define HIF_VSC_INTR0_EN 		4
#define HIF_HIF_INTR0_EN 		5
#define HIF_MCE_INTR0_EN 		6
#define HIF_VPIP_INTR0_EN 		7
#define HIF_HPIP_INTR0_EN 		8
#define HIF_MCU_INTR0_EN 		9
#define HIF_TS_INTR0_EN 		10
#define HIF_AMR_INTR0_EN 		11

/* DPC  (HIF_INT1_STAT_REG) */
#define HIF_APU_INTR1 			0
#define HIF_BLT_INTR1 			1
#define HIF_MIF_INTR1 			2
#define HIF_DPC_INTR1 			3
#define HIF_VSC_INTR1 			4
#define HIF_HIF_INTR1 			5
#define HIF_MCE_INTR1 			6
#define HIF_VPIP_INTR1 			7
#define HIF_HPIP_INTR1 			8
#define HIF_MCU_INTR1 			9
#define HIF_TS_INTR1 			10
#define HIF_AMR_INTR1 			11
										
/* DPC  (HIF_INT1_MASK_REG) */
#define HIF_APU_INTR1_EN 		0
#define HIF_BLT_INTR1_EN 		1
#define HIF_MIF_INTR1_EN 		2
#define HIF_DPC_INTR1_EN 		3
#define HIF_VSC_INTR1_EN 		4
#define HIF_HIF_INTR1_EN 		5
#define HIF_MCE_INTR1_EN 		6
#define HIF_VPIP_INTR1_EN 		7
#define HIF_HPIP_INTR1_EN 		8
#define HIF_MCU_INTR1_EN 		9
#define HIF_TS_INTR1_EN 		10
#define HIF_AMR_INTR1_EN 		11

/* DPC  (PLL_SYSCLK_REG) */
#define SYSCLK_PLL_RESET 		0
#define SYSCLK_PLL_OEN 			1
#define SYSCLK_PLL_PD 			2
#define SYSCLK_PLL_BP 			3
#define SYSCLK_PLL_OD 			4, 2
#define SYSCLK_PLL_DIV2 		6
#define SYSCLK_PLL_GP_CTRL 	7
#define SYSCLK_PLL_RD 			8, 5
#define SYSCLK_PLL_CLKIN_SEL 	14
#define SYSCLK_PLL_CLKOUT_SEL 15
#define SYSCLK_PLL_FD 			16, 9

/* DPC  (PLL_MIFCLK_REG) */
#define MIFCLK_PLL_RESET 		0
#define MIFCLK_PLL_OEN 			1
#define MIFCLK_PLL_PD 			2
#define MIFCLK_PLL_BP 			3
#define MIFCLK_PLL_OD 			4, 2
#define MIFCLK_PLL_DIV2 		6
#define MIFCLK_PLL_GP_CTRL 	7
#define MIFCLK_PLL_RD 			8, 5
#define MIFCLK_PLL_CLKIN_SEL 	14
#define MIFCLK_PLL_CLKOUT_SEL 15
#define MIFCLK_PLL_FD 			16, 9

/* DPC  (PLL_DPCCLK_REG) */
#define DPCCLK_PLL_RESET 		0
#define DPCCLK_PLL_OEN 			1
#define DPCCLK_PLL_PD 			2
#define DPCCLK_PLL_BP 			3
#define DPCCLK_PLL_OD 			4, 2
#define DPCCLK_PLL_DIV2			6
#define DPCCLK_PLL_GP_CTRL 	7
#define DPCCLK_PLL_RD 			8, 5
#define DPCCLK_PLL_CLKIN_SEL 	14
#define DPCCLK_PLL_CLKOUT_SEL 15
#define DPCCLK_PLL_FD 			16, 9

/* DPC  (TSD_DMA_RD_CONFIG) */
#define TSD_DMA_LENGTH 			0, 8
#define TSD_DMA_VALID 			8
#define TSD_CAE 					9
#define TSD_DMA_DONE3 			13
#define TSD_DMA_DONE2 			14
#define TSD_DMA_DONE1 			15
#define TSD_DMA_RD_ADD 			16, 16

/* DPC  (TSD_DMA_WR_ADD) */
#define TSD_DMA_WRADDL 			0, 16
#define TSD_DMA_WRADDH 			16, 10

/* DPC  (TSD_IO_BYTELIM_CNT) */
#define TSD_BYTELIMIT_COUNTER 0, 16
#define TSD_BYTESTOP_COUNTER 	16, 16

/* DPC  (TSD_STC_CNT_LM) */
#define TSD_STC_COUNTER_L 		0, 16
#define TSD_STC_COUNTER_M 		16, 16

/* DPC  (TSD_STC_CNT_H) */
#define TSD_STC_COUNTER_H 		0, 10

/* DPC  (TSD_CON_VCXO) */
#define TSD_PWM_VALUE 			0, 16
#define TSD_DRAM_OFFSET 		16, 10
#define TSD_DRAM_FULL 			26
#define TSD_ENDIAN 				27
#define TSD_SOURCE 				29
#define TSD_EXTSYNC 				30
#define TSD_XPORT_ON 			31

/* DPC  (TSD_INT_STATUS) */
#define TSD_INT_ISQ 						4
#define TSD_INT_SYNC_ACQUIRED			5
#define TSD_INT_SYNC_LOST 				6
#define TSD_INT_ERROR_PACKET 			7
#define TSD_INT_PACKET_RECEIVED 		8
#define TSD_INT_PCR_RECEIVED 			9


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\specific\vfc7000.h ===
/***************************************************************************/
/* VFC Tables for STi7000 with 32 lines (for version BA and above)         */
/*    ----------------------------------------------                       */
/*    List of tables                                                       */
/*                                                                         */
/*      480i output                                                        */
/* I0480I0480       Good                                                   */
/* I1080I0480       Good                                                   */
/* P0480I0480       Good                                                   */
/* P0720I0480       Good                                                   */
/*                                                                         */
/*     1080i output                                                        */
/* I0480I1080       Good                                                   */
/* I0576I1080       To be improved, errors in first and last lines         */
/* I1080I1080       Good                                                   */
/* P0480I1080       To be improved                                         */
/* P0720I1080       Good                                                   */
/*                                                                         */
/*      720p output                                                        */
/* I0480P0720       Good                                                   */
/* I0576P0720       To be improved, errors in last 5 lines                 */
/* I1080P0720       Good                                                   */
/* P0480P0720       To be improved, errors in last 3 lines                 */
/*                                  and few pixels on the right side       */
/* P0720P0720       Good                                                   */
/* P1080P0720       Doesn't work                                           */
/*                                                                         */
/***************************************************************************/

#include "library\hardware\video\generic\vidtypes.h"

#define	VFCRAM_LINES    		32
#define	NR_VFCPARMS_ENTRIES	17

typedef struct
	{
	VideoLineMode		inputLineMode;
	int					inputLines;
	VideoLineMode		outputLineMode;
	int					outputLines;
	int					pictureLines;

	BYTE					lmuctrl;
	BYTE					vfcram;
	BYTE					vfccnt;
	BYTE					vfcctl[2][VFCRAM_LINES][8];
	} VFCPARMS; //, FAR *P_VFCPARMS;


static VFCPARMS vfctable[] =
{

/********************* unconverted output *********************/

	{							// default VFC setting
	VLM_PROGRESSIVE,
	1,
	VLM_PROGRESSIVE,
	1,
	1,	

	 0x00,
	 0x41,
	 0x00,
	 {
		{
		{0x20, 0x01, 0x02, 0x00, 	0x10, 0x00, 0x00, 0x01},
		{0x22, 0x01, 0x02, 0x00, 	0x10, 0x00, 0x00, 0x01},
		{0x06, 0x01, 0x02, 0x00, 	0x10, 0x00, 0x00, 0x01},
		{0x26, 0x01, 0x02, 0x00, 	0x10, 0x00, 0x00, 0x01},
		{0x52, 0x01, 0x02, 0x00, 	0x10, 0x00, 0x00, 0x01},
		{0x22, 0x01, 0x02, 0x00, 	0x10, 0x00, 0x00, 0x01},
		{0x26, 0x01, 0x02, 0x00, 	0x10, 0x00, 0x00, 0x01},
		{0x28, 0x01, 0x02, 0x00, 	0x10, 0x00, 0x00, 0x01},
		{0x00, 0x00, 0x00, 0x00, 	0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 	0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 	0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 	0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 	0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 	0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 	0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00}
		},
		{
		{0x20, 0x01, 0x02, 0x00, 	0x10, 0x00, 0x00, 0x01},
		{0x22, 0x01, 0x02, 0x00, 	0x10, 0x00, 0x00, 0x01},
		{0x06, 0x01, 0x02, 0x00, 	0x10, 0x00, 0x00, 0x01},
		{0x26, 0x01, 0x02, 0x00, 	0x10, 0x00, 0x00, 0x01},
		{0x52, 0x01, 0x02, 0x00, 	0x10, 0x00, 0x00, 0x01},
		{0x22, 0x01, 0x02, 0x00, 	0x10, 0x00, 0x00, 0x01},
		{0x26, 0x01, 0x02, 0x00, 	0x10, 0x00, 0x00, 0x01},
		{0x28, 0x01, 0x02, 0x00, 	0x10, 0x00, 0x00, 0x01},
		{0x00, 0x00, 0x00, 0x00, 	0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 	0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 	0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 	0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 	0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 	0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 	0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x00}

		}
	 }
	},


	{							// default VFC setting
	VLM_INTERLACED,
	1,
	VLM_INTERLACED,
	1,
	1,	

	0x00,
	0x01,
	0x00,
	{
		{
		{0x20, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
		{0x23, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
		{0x07, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
		{0x25, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
		{0x51, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
		{0x23, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
		{0x27, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
		{0x28, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
		},
		{
		{0x20, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
		{0x21, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
		{0x05, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
		{0x27, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
		{0x53, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
		{0x21, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
		{0x25, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
		{0x28, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
		}
	}
},

/************************* 480i output **************************/

	{								//"I0480I0480",
	VLM_INTERLACED,
	480,
	VLM_INTERLACED,
	480,
	480,	

	0x04,
	0x01,
	0x3A,
	{
		{
        {0x20, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},

        {0x23, 0x12, 0x02, 0x55, 0x10, 0x40, 0x40, 0x41},
        {0x07, 0x24, 0x02, 0xAA, 0x10, 0x80, 0x80, 0x81},
        {0x25, 0x38, 0x02, 0xFF, 0x10, 0xC0, 0xC0, 0xC1},
        {0x51, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},

        {0x23, 0x12, 0x02, 0x55, 0x10, 0x40, 0x40, 0x41},
        {0x27, 0x24, 0x02, 0xAA, 0x10, 0x80, 0x80, 0x81},
        {0x28, 0x48, 0x02, 0xFF, 0x10, 0xC0, 0xC0, 0xC1},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      },
      {
        {0x20, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},

        {0x21, 0x12, 0x02, 0x55, 0x10, 0x40, 0x40, 0x41},
        {0x05, 0x24, 0x02, 0xAA, 0x10, 0x80, 0x80, 0x81},
        {0x27, 0x38, 0x02, 0xFF, 0x10, 0xC0, 0xC0, 0xC1},
        {0x53, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},

        {0x21, 0x12, 0x02, 0x55, 0x10, 0x40, 0x40, 0x41},
        {0x25, 0x24, 0x02, 0xAA, 0x10, 0x80, 0x80, 0x81},
        {0x28, 0x48, 0x02, 0xFF, 0x10, 0xC0, 0xC0, 0xC1},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      }
    }
  },

	{										//"I1088I0480",
	VLM_INTERLACED,
	1088,
	VLM_INTERLACED,
	480,
	480,	

	0x04,
	0x00,
	0x0D,
	{
		{
        {0x03, 0x07, 0x20, 0x46, 0x01, 0x42, 0x84, 0x0B},
        {0x14, 0x2D, 0x20, 0xCB, 0x04, 0x80, 0xC9, 0x13},
        {0x04, 0x07, 0x00, 0x66, 0x01, 0x43, 0x93, 0x18},
        {0x13, 0x3B, 0x00, 0x73, 0x00, 0x01, 0xD3, 0x1B},
        {0x06, 0x1E, 0x20, 0x9B, 0x01, 0x82, 0xC4, 0x4B},
        {0x11, 0x3B, 0x20, 0x53, 0x03, 0x01, 0xC2, 0x0C},
        {0x17, 0x1E, 0x00, 0xBB, 0x01, 0x83, 0xD3, 0x58},
        {0x02, 0x07, 0x00, 0x61, 0x03, 0x00, 0x4A, 0x1B},
        {0x15, 0x2D, 0x20, 0xEB, 0x04, 0x03, 0xC8, 0x11},
        {0x04, 0x07, 0x20, 0x66, 0x02, 0x04, 0x58, 0x09},
        {0x14, 0x2D, 0x00, 0xB3, 0x00, 0x08, 0xDA, 0x1B},
        {0x05, 0x1E, 0x00, 0xB6, 0x03, 0x40, 0x8A, 0x5B},
        {0x12, 0x3B, 0x20, 0x73, 0x01, 0x01, 0x5A, 0x04},
        {0x07, 0x1E, 0x20, 0xBB, 0x02, 0x44, 0x98, 0x49},
        {0x01, 0x3B, 0x00, 0x71, 0x03, 0x01, 0x43, 0x13},
        {0x56, 0x2D, 0x00, 0xBB, 0x00, 0x8A, 0xDB, 0x18},

        {0x03, 0x07, 0x20, 0x46, 0x01, 0x42, 0x84, 0x0B},
        {0x14, 0x2D, 0x20, 0xCB, 0x04, 0x80, 0xC9, 0x13},
        {0x04, 0x07, 0x00, 0x66, 0x01, 0x43, 0x93, 0x18},
        {0x13, 0x3B, 0x00, 0x73, 0x00, 0x01, 0xD3, 0x1B},
        {0x06, 0x1E, 0x20, 0x9B, 0x01, 0x82, 0xC4, 0x4B},
        {0x11, 0x3B, 0x20, 0x53, 0x03, 0x01, 0xC2, 0x0C},
        {0x17, 0x1E, 0x00, 0xBB, 0x01, 0x83, 0xD3, 0x58},
        {0x02, 0x07, 0x00, 0x61, 0x03, 0x00, 0x4A, 0x1B},
        {0x15, 0x2D, 0x20, 0xEB, 0x04, 0x03, 0xC8, 0x11},
        {0x04, 0x07, 0x20, 0x66, 0x02, 0x04, 0x58, 0x09},
        {0x14, 0x2D, 0x00, 0xB3, 0x00, 0x08, 0xDA, 0x1B},
        {0x05, 0x1E, 0x00, 0xB6, 0x03, 0x40, 0x8A, 0x5B},
        {0x12, 0x3B, 0x20, 0x73, 0x01, 0x01, 0x5A, 0x04},
        {0x07, 0x1E, 0x20, 0xBB, 0x02, 0x44, 0x98, 0x49},
        {0x21, 0x3B, 0x00, 0x71, 0x03, 0x01, 0x43, 0x13},
        {0x28, 0x4C, 0x00, 0xFB, 0x03, 0x80, 0xCA, 0x9B}
      },
      {
        {0x03, 0x16, 0x00, 0x66, 0x02, 0x52, 0x92, 0x5A},
        {0x14, 0x3B, 0x00, 0x33, 0x02, 0x0A, 0x5A, 0x0B},
        {0x04, 0x1E, 0x00, 0xBB, 0x02, 0x44, 0x90, 0x4A},
        {0x13, 0x3B, 0x00, 0x31, 0x02, 0x0A, 0x4A, 0x1B},
        {0x06, 0x2C, 0x00, 0xBB, 0x02, 0x92, 0xD2, 0x9A},
        {0x11, 0x07, 0x00, 0x61, 0x03, 0x09, 0x52, 0x1A},
        {0x17, 0x2D, 0x00, 0xBB, 0x00, 0x0A, 0xD0, 0x22},
        {0x02, 0x07, 0x00, 0x66, 0x02, 0x4A, 0x5B, 0x11},
        {0x15, 0x39, 0x00, 0x33, 0x02, 0x12, 0xD2, 0x1A},
        {0x04, 0x1E, 0x00, 0xB6, 0x03, 0x49, 0x92, 0x5A},
        {0x14, 0x3B, 0x00, 0x73, 0x02, 0x01, 0x52, 0x04},
        {0x05, 0x1E, 0x00, 0xBB, 0x02, 0x8A, 0x9B, 0x51},
        {0x12, 0x03, 0x00, 0x11, 0x02, 0x12, 0x52, 0x1A},
        {0x07, 0x2D, 0x00, 0xBB, 0x01, 0x92, 0xDA, 0x19},
        {0x01, 0x07, 0x00, 0x66, 0x02, 0x04, 0x50, 0x0A},
        {0x56, 0x2D, 0x00, 0xB3, 0x01, 0x11, 0xDA, 0x1A},

        {0x03, 0x16, 0x00, 0x66, 0x02, 0x52, 0x92, 0x5A},
        {0x14, 0x3B, 0x00, 0x33, 0x02, 0x0A, 0x5A, 0x0B},
        {0x04, 0x1E, 0x00, 0xBB, 0x02, 0x44, 0x90, 0x4A},
        {0x13, 0x3B, 0x00, 0x31, 0x02, 0x0A, 0x4A, 0x1B},
        {0x06, 0x2C, 0x00, 0xBB, 0x02, 0x92, 0xD2, 0x9A},
        {0x11, 0x07, 0x00, 0x61, 0x03, 0x09, 0x52, 0x1A},
        {0x17, 0x2D, 0x00, 0xBB, 0x00, 0x0A, 0xD0, 0x22},
        {0x02, 0x07, 0x00, 0x66, 0x02, 0x4A, 0x5B, 0x11},
        {0x15, 0x39, 0x00, 0x33, 0x02, 0x12, 0xD2, 0x1A},
        {0x04, 0x1E, 0x00, 0xB6, 0x03, 0x49, 0x92, 0x5A},
        {0x14, 0x3B, 0x00, 0x73, 0x02, 0x01, 0x52, 0x04},
        {0x05, 0x1E, 0x00, 0xBB, 0x02, 0x8A, 0x9B, 0x51},
        {0x12, 0x03, 0x00, 0x11, 0x02, 0x12, 0x52, 0x1A},
        {0x07, 0x2D, 0x00, 0xBB, 0x01, 0x92, 0xDA, 0x19},
        {0x21, 0x07, 0x00, 0x66, 0x02, 0x04, 0x50, 0x0A},
        {0x28, 0x4C, 0x00, 0xFF, 0x02, 0xCB, 0xD3, 0x91}
      }
    }
  },

	{											//"P0480I0480",
	VLM_PROGRESSIVE,
	480,
	VLM_INTERLACED,
	480,
	480,	

	0x04,
	0x01,
	0x76,
	{
		{
        {0x20, 0x03, 0x02, 0x11, 0x10, 0x00, 0x40, 0x08},

        {0x06, 0x2C, 0x02, 0xBB, 0x10, 0x80, 0xC0, 0x88},
        {0x52, 0x03, 0x02, 0x11, 0x10, 0x00, 0x40, 0x08},

        {0x26, 0x4C, 0x02, 0xBB, 0x10, 0x80, 0xC0, 0x88},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      },
      {
        {0x02, 0x16, 0x02, 0x66, 0x10, 0x40, 0x80, 0x48},

        {0x16, 0x39, 0x02, 0x33, 0x10, 0x00, 0xC0, 0x08},
        {0x42, 0x16, 0x02, 0x66, 0x10, 0x40, 0x80, 0x48},

        {0x28, 0x48, 0x02, 0xFF, 0x10, 0xC0, 0xC0, 0xC1},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      }
    }
  },

	{										//"P0720I0480",
	VLM_PROGRESSIVE,
	720,
	VLM_INTERLACED,
	480,
	480,	

	0x04,
	0x00,
	0x3A,
	{
      {
        {0x01, 0x03, 0x00, 0x11, 0x01, 0x0A, 0x5A, 0x1A},
        {0x13, 0x39, 0x20, 0x33, 0x01, 0x0A, 0xDA, 0x1B},
        {0x17, 0x2C, 0x00, 0xBB, 0x01, 0x8A, 0xDA, 0x9A},
        {0x45, 0x16, 0x00, 0x66, 0x01, 0x4A, 0x9A, 0x5A},

        {0x01, 0x03, 0x00, 0x11, 0x01, 0x0A, 0x5A, 0x1A},
        {0x13, 0x39, 0x20, 0x33, 0x01, 0x0A, 0xDA, 0x1B},
        {0x17, 0x2C, 0x00, 0xBB, 0x01, 0x8A, 0xDA, 0x9A},
        {0x25, 0x46, 0x00, 0x66, 0x01, 0x4A, 0x9A, 0x5A},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      },
      {
        {0x07, 0x2C, 0x20, 0xBB, 0x01, 0x8A, 0xDA, 0x9B},
        {0x03, 0x16, 0x20, 0x66, 0x01, 0x4A, 0x9A, 0x5B},
        {0x11, 0x03, 0x20, 0x11, 0x01, 0x0A, 0x5A, 0x1B},
        {0x55, 0x39, 0x00, 0x33, 0x01, 0x0A, 0xDA, 0x1A},

        {0x07, 0x2C, 0x20, 0xBB, 0x01, 0x8A, 0xDA, 0x9B},
        {0x03, 0x16, 0x20, 0x66, 0x01, 0x4A, 0x9A, 0x5B},
        {0x21, 0x03, 0x20, 0x11, 0x01, 0x0A, 0x5A, 0x1B},
        {0x28, 0x48, 0x00, 0xFF, 0x02, 0xD2, 0xD2, 0xD3},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      }
	}
},

/************************* 1080i output ************************/

	{											//"I0480I1080",
	VLM_INTERLACED,
	480,
	VLM_INTERLACED,
	1088,
	1080,	

   0x0C,
   0x04,
   0x3A,
    {
      {
        {0x20, 0x41, 0x00, 0x00, 0x02, 0x12, 0x1A, 0x12},
        {0x20, 0x4B, 0x00, 0x01, 0x02, 0x13, 0x12, 0x12},
        {0x20, 0x07, 0x00, 0x56, 0x02, 0x13, 0x52, 0x52},
        {0x21, 0x1E, 0x00, 0xAD, 0x02, 0x59, 0x8A, 0x9A},

        {0x22, 0x2D, 0x10, 0xF3, 0x02, 0x98, 0xC3, 0xDA},
        {0x24, 0x3B, 0x00, 0x1F, 0x03, 0x02, 0x18, 0x0B},
        {0x26, 0x47, 0x10, 0x44, 0x02, 0x9B, 0x00, 0x5A},
        {0x08, 0x07, 0x00, 0x4A, 0x03, 0x42, 0x58, 0x4B},
        {0x26, 0x1E, 0x10, 0xA6, 0x02, 0xD8, 0x83, 0x9A},
        {0x25, 0x2D, 0x00, 0xF8, 0x02, 0x19, 0xCA, 0xDA},
        {0x23, 0x3B, 0x00, 0x03, 0x02, 0x53, 0x12, 0x12},
        {0x11, 0x07, 0x00, 0x56, 0x02, 0x13, 0x52, 0x52},
        {0x61, 0x1E, 0x00, 0xAD, 0x02, 0x59, 0x8A, 0x9A},

        {0x22, 0x2D, 0x10, 0xF3, 0x02, 0x98, 0xC3, 0xDA},
        {0x24, 0x4B, 0x00, 0x1F, 0x03, 0x02, 0x18, 0x0B},
        {0x26, 0x4B, 0x10, 0x11, 0x02, 0xDB, 0x40, 0x1A},
        {0x28, 0x47, 0x20, 0x6A, 0x03, 0x50, 0x60, 0x4B},
        {0x28, 0x4E, 0x00, 0xAA, 0x02, 0x92, 0x9A, 0x92},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      },
      {
        {0x20, 0x41, 0x00, 0x00, 0x02, 0x12, 0x1A, 0x12},
        {0x22, 0x47, 0x10, 0x44, 0x02, 0x9B, 0x00, 0x5A},
        {0x24, 0x07, 0x00, 0x4A, 0x03, 0x42, 0x58, 0x4B},
        {0x26, 0x1E, 0x10, 0xA6, 0x02, 0xD8, 0x83, 0x9A},

        {0x07, 0x2D, 0x00, 0xF8, 0x02, 0x19, 0xCA, 0xDA},
        {0x27, 0x3B, 0x00, 0x03, 0x02, 0x53, 0x12, 0x12},
        {0x25, 0x07, 0x00, 0x56, 0x02, 0x13, 0x52, 0x52},
        {0x23, 0x1E, 0x00, 0xAD, 0x02, 0x59, 0x8A, 0x9A},
        {0x12, 0x2D, 0x10, 0xF3, 0x02, 0x98, 0xC3, 0xDA},
        {0x20, 0x3B, 0x00, 0x1F, 0x03, 0x02, 0x18, 0x0B},
        {0x22, 0x47, 0x10, 0x44, 0x02, 0x9B, 0x00, 0x5A},
        {0x24, 0x07, 0x00, 0x4A, 0x03, 0x42, 0x58, 0x4B},
        {0x66, 0x1E, 0x10, 0xA6, 0x02, 0xD8, 0x83, 0x9A},

        {0x27, 0x2D, 0x00, 0xF8, 0x02, 0x19, 0xCA, 0xDA},
        {0x28, 0x4B, 0x00, 0x03, 0x02, 0x53, 0x12, 0x12},
        {0x28, 0x47, 0x00, 0x56, 0x02, 0x13, 0x52, 0x52},
        {0x28, 0x4E, 0x00, 0xA5, 0x02, 0x99, 0x91, 0x9A},
        {0x28, 0x4D, 0x00, 0xAA, 0x02, 0x92, 0x9A, 0x92},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      }
    }
  },

	{											//"I0576I1080", errors in first and last lines
	VLM_INTERLACED,
	576,
	VLM_INTERLACED,
	1088,
	1076,	

   0x04,
   0x07,
   0x22,
    {
      {
        {0x20, 0x01, 0x00, 0x00, 0x02, 0x12, 0x1A, 0x12},
        {0x20, 0x43, 0x00, 0x01, 0x02, 0x13, 0x12, 0x12},
        {0x04, 0x1E, 0x10, 0x6D, 0x03, 0x58, 0x8B, 0x83},
        {0x26, 0x4E, 0x20, 0xB7, 0x03, 0x82, 0x98, 0x93},
        {0x21, 0x2D, 0x00, 0xCA, 0x03, 0xC2, 0xD8, 0xCB},
        {0x23, 0x4D, 0x00, 0xE0, 0x03, 0xC8, 0xD8, 0xD3},
        {0x13, 0x3B, 0x00, 0x7F, 0x01, 0x01, 0x18, 0x0C},

        {0x21, 0x4B, 0x00, 0x0D, 0x02, 0x59, 0x0B, 0x12},
        {0x27, 0x07, 0x00, 0x60, 0x03, 0x48, 0x58, 0x53},
        {0x25, 0x47, 0x00, 0x4A, 0x03, 0x42, 0x58, 0x4B},
        {0x05, 0x1E, 0x00, 0xBD, 0x03, 0x81, 0x98, 0x93},
        {0x27, 0x4E, 0x10, 0x9F, 0x03, 0xC0, 0x94, 0x8B},
        {0x22, 0x2D, 0x20, 0xE2, 0x03, 0xC2, 0xD8, 0xD3},
        {0x24, 0x4D, 0x10, 0x38, 0x03, 0x18, 0xCB, 0xC3},
        {0x12, 0x3B, 0x00, 0xF5, 0x00, 0x10, 0x11, 0x14},
        {0x27, 0x07, 0x10, 0x44, 0x02, 0x9B, 0x00, 0x5A},
        {0x26, 0x47, 0x00, 0x4A, 0x03, 0x51, 0x51, 0x53},
        {0x04, 0x1E, 0x10, 0x6D, 0x03, 0x58, 0x8B, 0x83},
        {0x26, 0x4E, 0x20, 0xB7, 0x03, 0x82, 0x98, 0x93},
        {0x21, 0x2D, 0x00, 0xCA, 0x03, 0xC2, 0xD8, 0xCB},
        {0x23, 0x4D, 0x00, 0xE0, 0x03, 0xC8, 0xD8, 0xD3},
        {0x53, 0x3B, 0x00, 0x7F, 0x01, 0x01, 0x18, 0x0C},

        {0x21, 0x4B, 0x00, 0x0D, 0x02, 0x59, 0x0B, 0x12},
        {0x27, 0x07, 0x00, 0x60, 0x03, 0x48, 0x58, 0x53},
        {0x25, 0x47, 0x00, 0x4A, 0x03, 0x42, 0x58, 0x4B},
        {0x05, 0x1E, 0x00, 0xBD, 0x03, 0x81, 0x98, 0x93},
        {0x27, 0x4E, 0x10, 0x9F, 0x03, 0xC0, 0x94, 0x8B},
        {0x22, 0x2D, 0x20, 0xE2, 0x03, 0xC2, 0xD8, 0xD3},
        {0x24, 0x4C, 0x10, 0xEE, 0x02, 0x9B, 0xCB, 0xCA},
        {0x28, 0x48, 0x00, 0xFF, 0x02, 0xD2, 0xDA, 0xD2},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      },
      {
        {0x20, 0x41, 0x00, 0x00, 0x02, 0x12, 0x1A, 0x12},
        {0x20, 0x03, 0x10, 0x04, 0x02, 0x58, 0x03, 0x1A},
        {0x27, 0x47, 0x00, 0x4A, 0x03, 0x42, 0x58, 0x4B},
        {0x25, 0x1E, 0x20, 0x9D, 0x03, 0x82, 0x98, 0x93},
        {0x06, 0x4E, 0x10, 0xE7, 0x03, 0xD8, 0x8B, 0x83},
        {0x27, 0x2D, 0x00, 0xCA, 0x03, 0xD1, 0xD1, 0xD3},
        {0x22, 0x4D, 0x10, 0xCC, 0x02, 0x9B, 0x00, 0xDA},

        {0x14, 0x3B, 0x00, 0xF5, 0x00, 0x10, 0x11, 0x14},
        {0x22, 0x07, 0x10, 0x18, 0x03, 0x18, 0x4B, 0x43},
        {0x27, 0x47, 0x20, 0x62, 0x03, 0x42, 0x58, 0x53},
        {0x26, 0x1E, 0x10, 0xB5, 0x03, 0x40, 0x94, 0x8B},
        {0x05, 0x4E, 0x00, 0x97, 0x03, 0x81, 0x98, 0x93},
        {0x27, 0x2D, 0x00, 0xCA, 0x03, 0xC2, 0xD8, 0xCB},
        {0x21, 0x4D, 0x00, 0xE0, 0x03, 0xC8, 0xD8, 0xD3},
        {0x23, 0x3B, 0x00, 0x07, 0x02, 0xD9, 0x0B, 0x12},
        {0x13, 0x4B, 0x00, 0xD5, 0x01, 0x01, 0x18, 0x0C},
        {0x21, 0x07, 0x00, 0x60, 0x03, 0x48, 0x58, 0x53},
        {0x27, 0x47, 0x00, 0x4A, 0x03, 0x42, 0x58, 0x4B},
        {0x25, 0x1E, 0x20, 0x9D, 0x03, 0x82, 0x98, 0x93},
        {0x06, 0x4E, 0x10, 0xE7, 0x03, 0xD8, 0x8B, 0x83},
        {0x27, 0x2D, 0x00, 0xCA, 0x03, 0xD1, 0xD1, 0xD3},
        {0x62, 0x4D, 0x10, 0xCC, 0x02, 0x9B, 0x00, 0xDA},

        {0x24, 0x4D, 0x00, 0xA0, 0x00, 0xD0, 0xD1, 0xD4},
        {0x26, 0x3B, 0x10, 0xC7, 0x03, 0xD8, 0x0B, 0x03},
        {0x21, 0x4B, 0x20, 0x1D, 0x03, 0x02, 0x18, 0x13},
        {0x22, 0x07, 0x10, 0x60, 0x03, 0x00, 0x54, 0x4B},
        {0x13, 0x47, 0x00, 0x42, 0x03, 0x41, 0x58, 0x53},
        {0x21, 0x1E, 0x00, 0xB5, 0x03, 0x82, 0x98, 0x8B},
        {0x27, 0x4C, 0x10, 0xFB, 0x02, 0x98, 0xC3, 0xDA},
        {0x28, 0x48, 0x00, 0xFF, 0x02, 0xD2, 0xDA, 0xD2},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      }
    }
  },
  
	{							//"I1088I1080",
	VLM_INTERLACED,
	1088,
	VLM_INTERLACED,
	1088,
	1080,	

	0x00,
	0x01,
	0x85,
	{
		{
        {0x20, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},

        {0x23, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
        {0x07, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
        {0x25, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
        {0x51, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},

        {0x23, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
        {0x27, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
        {0x28, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      },
      {
        {0x20, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},

        {0x21, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
        {0x05, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
        {0x27, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
        {0x53, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},

        {0x21, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
        {0x25, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
        {0x28, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      }
    }
  },

	{											//"P0480I1080",
	VLM_PROGRESSIVE,
	480,
	VLM_INTERLACED,
	1088,
	1080,	

   0x04,
   0x01,
   0x3A,
    {
      {
        {0x20, 0x41, 0x00, 0x00, 0x02, 0x12, 0x1A, 0x12},

        {0x01, 0x47, 0x00, 0x60, 0x03, 0x01, 0x53, 0x43},
        {0x24, 0x07, 0x00, 0x4A, 0x03, 0x81, 0x53, 0x43},
        {0x11, 0x1E, 0x00, 0x9F, 0x03, 0x82, 0x98, 0x8B},
        {0x23, 0x2D, 0x00, 0xE0, 0x03, 0xC8, 0xD8, 0xD3},
        {0x07, 0x3B, 0x20, 0xDD, 0x00, 0x01, 0x19, 0x14},
        {0x26, 0x07, 0x00, 0xA0, 0x00, 0x50, 0x51, 0x54},
        {0x12, 0x1E, 0x20, 0xDD, 0x00, 0x81, 0x99, 0x94},
        {0x21, 0x2D, 0x00, 0xCA, 0x03, 0xC8, 0xD8, 0xD3},
        {0x65, 0x3B, 0x00, 0x1F, 0x03, 0x02, 0x18, 0x0B},

        {0x21, 0x07, 0x00, 0x60, 0x03, 0x01, 0x53, 0x43},
        {0x24, 0x1E, 0x00, 0x9F, 0x03, 0xC1, 0x93, 0x83},
        {0x07, 0x2D, 0x00, 0xE0, 0x03, 0xC2, 0xD8, 0xCB},
        {0x25, 0x3B, 0x00, 0x35, 0x03, 0x08, 0x18, 0x13},
        {0x11, 0x07, 0x20, 0x22, 0x00, 0x41, 0x59, 0x54},
        {0x22, 0x1E, 0x00, 0xF5, 0x00, 0x90, 0x91, 0x94},
        {0x08, 0x2C, 0x00, 0xEA, 0x03, 0xC1, 0xD0, 0xDB},
        {0x28, 0x38, 0x00, 0xFF, 0x02, 0xD2, 0xDA, 0xD2},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      },
      {
        {0x20, 0x41, 0x00, 0x00, 0x02, 0x12, 0x1A, 0x12},

        {0x22, 0x07, 0x00, 0xA0, 0x00, 0x50, 0x51, 0x54},
        {0x06, 0x1E, 0x20, 0xDD, 0x00, 0x81, 0x99, 0x94},
        {0x27, 0x2D, 0x00, 0xCA, 0x03, 0xC8, 0xD8, 0xD3},
        {0x23, 0x3B, 0x00, 0x1F, 0x03, 0x02, 0x18, 0x0B},
        {0x17, 0x47, 0x00, 0x60, 0x03, 0x01, 0x53, 0x43},
        {0x24, 0x07, 0x00, 0x4A, 0x03, 0x81, 0x53, 0x43},
        {0x07, 0x1E, 0x00, 0x9F, 0x03, 0x82, 0x98, 0x8B},
        {0x25, 0x2D, 0x00, 0xE0, 0x03, 0xC8, 0xD8, 0xD3},
        {0x51, 0x3B, 0x20, 0xDD, 0x00, 0x01, 0x19, 0x14},

        {0x22, 0x07, 0x00, 0xA0, 0x00, 0x50, 0x51, 0x54},
        {0x26, 0x1E, 0x20, 0xDD, 0x00, 0x81, 0x99, 0x94},
        {0x01, 0x2D, 0x00, 0xCA, 0x03, 0xC8, 0xD8, 0xD3},
        {0x23, 0x3B, 0x00, 0x1F, 0x03, 0x02, 0x18, 0x0B},
        {0x27, 0x07, 0x00, 0x60, 0x03, 0x01, 0x53, 0x43},
        {0x14, 0x4E, 0x00, 0x9F, 0x03, 0xC1, 0x93, 0x83},
        {0x28, 0x1C, 0x00, 0xEF, 0x03, 0xC0, 0xCA, 0xDB},
        {0x08, 0x28, 0x00, 0xFF, 0x02, 0xD2, 0xDA, 0xD2},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      }
    }
  },

	{									//"P0720I1080",
	VLM_PROGRESSIVE,
	720,
	VLM_INTERLACED,
	1088,
	1080,	

	0x04,
	0x01,
	0xB2,
	{
		{
        {0x20, 0x03, 0x01, 0x10, 0x09, 0x11, 0x09, 0x09},

        {0x04, 0x16, 0x01, 0x66, 0x09, 0x49, 0x89, 0x51},
        {0x27, 0x2D, 0x01, 0xFB, 0x0A, 0x81, 0xC9, 0x10},
        {0x51, 0x3B, 0x01, 0x31, 0x09, 0x01, 0x11, 0x02},

        {0x24, 0x16, 0x01, 0x66, 0x09, 0x49, 0x89, 0x51},
        {0x28, 0x2C, 0x01, 0xFF, 0x09, 0x8A, 0xC9, 0x89},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      },
      {
        {0x21, 0x07, 0x01, 0x65, 0x0A, 0x02, 0x41, 0x09},

        {0x07, 0x1E, 0x01, 0xBA, 0x09, 0x91, 0x82, 0x48},
        {0x14, 0x39, 0x01, 0x33, 0x09, 0x09, 0xC9, 0x11},
        {0x61, 0x07, 0x01, 0x65, 0x0A, 0x02, 0x41, 0x09},

        {0x27, 0x1E, 0x01, 0xBA, 0x09, 0x91, 0x82, 0x48},
        {0x28, 0x48, 0x01, 0xFF, 0x09, 0xC9, 0xC9, 0xCA},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      }
    }
  },
    
/************************* 720p output ************************/

  {										//"I0480P0720",
	VLM_INTERLACED,
	480,
	VLM_PROGRESSIVE,
	720,
	720,	

   0x0C,
   0x05,
   0x3A,
    {
      {
        {0x20, 0x41, 0x00, 0x00, 0x02, 0x12, 0x12, 0x13},
        {0x20, 0x41, 0x00, 0x00, 0x02, 0x12, 0x12, 0x13},
        {0x20, 0x43, 0x00, 0x11, 0x02, 0x0A, 0x13, 0x0B},
        {0x20, 0x07, 0x00, 0x65, 0x03, 0x03, 0x41, 0x1A},
        {0x20, 0x46, 0x00, 0x66, 0x02, 0x52, 0x92, 0x5A},

        {0x21, 0x1E, 0x00, 0xBB, 0x03, 0x8B, 0x93, 0x40},
        {0x23, 0x2D, 0x00, 0xFB, 0x03, 0x81, 0xDA, 0x18},
        {0x24, 0x49, 0x00, 0x33, 0x02, 0x12, 0xD2, 0x1A},
        {0x25, 0x3B, 0x00, 0x31, 0x00, 0x03, 0x4B, 0x13},
        {0x26, 0x07, 0x00, 0x65, 0x03, 0x03, 0x41, 0x1A},
        {0x07, 0x46, 0x00, 0x66, 0x02, 0x52, 0x92, 0x5A},
        {0x27, 0x1E, 0x00, 0xBB, 0x03, 0x8B, 0x93, 0x40},
        {0x25, 0x2D, 0x00, 0xFB, 0x03, 0x81, 0xDA, 0x18},
        {0x24, 0x49, 0x00, 0x33, 0x02, 0x12, 0xD2, 0x1A},
        {0x23, 0x3B, 0x00, 0x31, 0x00, 0x03, 0x4B, 0x13},
        {0x22, 0x07, 0x00, 0x65, 0x03, 0x03, 0x41, 0x1A},
        {0x51, 0x46, 0x00, 0x66, 0x02, 0x52, 0x92, 0x5A},

        {0x21, 0x1E, 0x00, 0xBB, 0x03, 0x8B, 0x93, 0x40},
        {0x23, 0x2D, 0x00, 0xFB, 0x03, 0x81, 0xDA, 0x18},
        {0x24, 0x49, 0x00, 0x33, 0x02, 0x12, 0xD2, 0x1A},
        {0x25, 0x3B, 0x00, 0x31, 0x00, 0x03, 0x4B, 0x13},
        {0x26, 0x07, 0x00, 0x65, 0x03, 0x03, 0x41, 0x1A},
        {0x27, 0x46, 0x00, 0x66, 0x02, 0x52, 0x92, 0x5A},
        {0x28, 0x1E, 0x00, 0xBB, 0x03, 0x8B, 0x93, 0x40},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      },
      {
        {0x20, 0x41, 0x00, 0x00, 0x02, 0x12, 0x12, 0x13},
        {0x20, 0x41, 0x00, 0x00, 0x02, 0x12, 0x12, 0x13},
        {0x21, 0x43, 0x00, 0x11, 0x02, 0x0A, 0x13, 0x0B},
        {0x23, 0x07, 0x00, 0x65, 0x03, 0x03, 0x41, 0x1A},
        {0x24, 0x46, 0x00, 0x66, 0x02, 0x52, 0x92, 0x5A},

        {0x25, 0x1E, 0x00, 0xBB, 0x03, 0x8B, 0x93, 0x40},
        {0x26, 0x2D, 0x00, 0xFB, 0x03, 0x81, 0xDA, 0x18},
        {0x07, 0x49, 0x00, 0x33, 0x02, 0x12, 0xD2, 0x1A},
        {0x27, 0x3B, 0x00, 0x31, 0x00, 0x03, 0x4B, 0x13},
        {0x25, 0x07, 0x00, 0x65, 0x03, 0x03, 0x41, 0x1A},
        {0x24, 0x46, 0x00, 0x66, 0x02, 0x52, 0x92, 0x5A},
        {0x23, 0x1E, 0x00, 0xBB, 0x03, 0x8B, 0x93, 0x40},
        {0x22, 0x2D, 0x00, 0xFB, 0x03, 0x81, 0xDA, 0x18},
        {0x11, 0x49, 0x00, 0x33, 0x02, 0x12, 0xD2, 0x1A},
        {0x21, 0x3B, 0x00, 0x31, 0x00, 0x03, 0x4B, 0x13},
        {0x23, 0x07, 0x00, 0x65, 0x03, 0x03, 0x41, 0x1A},
        {0x64, 0x46, 0x00, 0x66, 0x02, 0x52, 0x92, 0x5A},

        {0x25, 0x1E, 0x00, 0xBB, 0x03, 0x8B, 0x93, 0x40},
        {0x26, 0x2D, 0x00, 0xFB, 0x03, 0x81, 0xDA, 0x18},
        {0x27, 0x49, 0x00, 0x33, 0x02, 0x12, 0xD2, 0x1A},
        {0x28, 0x3B, 0x00, 0x31, 0x00, 0x03, 0x4B, 0x13},
        {0x28, 0x07, 0x00, 0x65, 0x03, 0x03, 0x41, 0x1A},
        {0x28, 0x46, 0x00, 0x66, 0x02, 0x52, 0x92, 0x5A},
        {0x28, 0x1E, 0x00, 0xBB, 0x03, 0x8B, 0x93, 0x40},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      }
    }
  },
  
  {												//"I0576P0720",
	VLM_INTERLACED,
	576,
	VLM_PROGRESSIVE,
	720,
	715,	

   0x04,
   0x05,
   0x46,
    {
      {
        {0x20, 0x01, 0x00, 0x00, 0x02, 0x12, 0x1A, 0x12},
        {0x26, 0x43, 0x00, 0x05, 0x02, 0x19, 0x11, 0x1A},
        {0x03, 0x47, 0x00, 0x4A, 0x03, 0x42, 0x58, 0x4B},
        {0x25, 0x1E, 0x00, 0xAD, 0x02, 0x59, 0x8B, 0x92},
        {0x26, 0x4E, 0x00, 0x97, 0x03, 0x81, 0x98, 0x93},

        {0x21, 0x2D, 0x10, 0xB2, 0x03, 0x98, 0xCB, 0xC3},
        {0x22, 0x4D, 0x00, 0xCA, 0x03, 0xD1, 0xD1, 0xD3},
        {0x15, 0x4D, 0x00, 0xE0, 0x03, 0xC2, 0xD8, 0xCB},
        {0x23, 0x3B, 0x00, 0x07, 0x02, 0xD9, 0x0B, 0x12},
        {0x22, 0x4B, 0x00, 0x3D, 0x03, 0x01, 0x18, 0x13},
        {0x27, 0x07, 0x10, 0x18, 0x03, 0x18, 0x4B, 0x43},
        {0x26, 0x47, 0x00, 0x60, 0x03, 0x51, 0x51, 0x53},
        {0x03, 0x47, 0x00, 0x4A, 0x03, 0x42, 0x58, 0x4B},
        {0x25, 0x1E, 0x00, 0xAD, 0x02, 0x59, 0x8B, 0x92},
        {0x66, 0x4E, 0x00, 0x97, 0x03, 0x81, 0x98, 0x93},

        {0x21, 0x4E, 0x10, 0x6D, 0x03, 0x58, 0x8B, 0x83},
        {0x22, 0x4E, 0x00, 0xB5, 0x03, 0x91, 0x91, 0x93},
        {0x25, 0x4E, 0x00, 0x9F, 0x03, 0x82, 0x98, 0x8B},
        {0x23, 0x49, 0x10, 0x00, 0x02, 0xDB, 0x09, 0x1A},
        {0x20, 0x41, 0x00, 0x00, 0x02, 0x12, 0x1A, 0x12},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      },
      {
        {0x20, 0x41, 0x00, 0x00, 0x02, 0x12, 0x1A, 0x12},
        {0x22, 0x43, 0x10, 0x00, 0x02, 0x5B, 0x00, 0x1A},
        {0x21, 0x07, 0x00, 0x68, 0x03, 0x41, 0x58, 0x53},
        {0x27, 0x47, 0x00, 0x52, 0x02, 0x99, 0x4B, 0x52},
        {0x02, 0x1E, 0x00, 0xB5, 0x03, 0x82, 0x98, 0x8B},

        {0x24, 0x4E, 0x00, 0x9F, 0x03, 0x91, 0x91, 0x93},
        {0x26, 0x4E, 0x10, 0xE7, 0x03, 0xD8, 0x8B, 0x83},
        {0x27, 0x2D, 0x00, 0xC2, 0x03, 0xC1, 0xD8, 0xD3},
        {0x21, 0x4D, 0x00, 0xF8, 0x02, 0x19, 0xCB, 0xD2},
        {0x16, 0x3B, 0x00, 0x1F, 0x03, 0x02, 0x18, 0x0B},
        {0x24, 0x4B, 0x00, 0x35, 0x03, 0x11, 0x11, 0x13},
        {0x22, 0x4B, 0x10, 0x4D, 0x03, 0x58, 0x0B, 0x03},
        {0x21, 0x07, 0x00, 0x68, 0x03, 0x41, 0x58, 0x53},
        {0x27, 0x47, 0x00, 0x52, 0x02, 0x99, 0x4B, 0x52},
        {0x42, 0x1E, 0x00, 0xB5, 0x03, 0x82, 0x98, 0x8B},

        {0x24, 0x3B, 0x00, 0x35, 0x03, 0x11, 0x11, 0x13},
        {0x26, 0x4B, 0x10, 0x4D, 0x03, 0x58, 0x0B, 0x03},
        {0x27, 0x07, 0x00, 0x68, 0x03, 0x41, 0x58, 0x53},
        {0x21, 0x46, 0x00, 0xA5, 0x02, 0x99, 0x99, 0x92},
        {0x20, 0x48, 0x00, 0xFF, 0x02, 0xD2, 0xDA, 0xD2},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      }
    }
  },

	{									//"I1088P0720",
	VLM_INTERLACED,
	1088,
	VLM_PROGRESSIVE,
	720,
	720,	

   0x04,
   0x08,
   0x2B,
    {
      {
        {0x20, 0x4B, 0x20, 0x11, 0x02, 0x03, 0x18, 0x1A},
        {0x22, 0x07, 0x20, 0x88, 0x00, 0x41, 0x59, 0x54},
        {0x05, 0x4E, 0x10, 0xB5, 0x03, 0x40, 0x94, 0x8B},
        {0x28, 0x1E, 0x10, 0x9F, 0x03, 0xC0, 0x94, 0x8B},
        {0x25, 0x2D, 0x20, 0x88, 0x00, 0xC1, 0xD9, 0xD4},
        {0x12, 0x3B, 0x20, 0x77, 0x00, 0x01, 0x19, 0x14},
        {0x21, 0x47, 0x10, 0x60, 0x03, 0x00, 0x54, 0x4B},
        {0x24, 0x07, 0x10, 0x4A, 0x03, 0x80, 0x54, 0x4B},

        {0x07, 0x1E, 0x20, 0x77, 0x00, 0x81, 0x99, 0x94},
        {0x26, 0x2D, 0x20, 0x22, 0x00, 0xC1, 0xD9, 0xD4},
        {0x13, 0x4B, 0x10, 0x1F, 0x03, 0xC0, 0x14, 0x0B},
        {0x20, 0x3B, 0x10, 0x35, 0x03, 0x40, 0x14, 0x0B},
        {0x23, 0x07, 0x20, 0x22, 0x00, 0x41, 0x59, 0x54},
        {0x06, 0x1E, 0x20, 0xDD, 0x00, 0x81, 0x99, 0x94},
        {0x27, 0x4D, 0x10, 0xCA, 0x03, 0x80, 0xD4, 0xCB},
        {0x24, 0x2D, 0x10, 0xE0, 0x03, 0x00, 0xD4, 0xCB},
        {0x11, 0x3B, 0x20, 0xDD, 0x00, 0x01, 0x19, 0x14},
        {0x22, 0x07, 0x20, 0x88, 0x00, 0x41, 0x59, 0x54},
        {0x05, 0x4E, 0x10, 0xB5, 0x03, 0x40, 0x94, 0x8B},
        {0x28, 0x1E, 0x10, 0x9F, 0x03, 0xC0, 0x94, 0x8B},
        {0x25, 0x2D, 0x20, 0x88, 0x00, 0xC1, 0xD9, 0xD4},
        {0x12, 0x3B, 0x20, 0x77, 0x00, 0x01, 0x19, 0x14},
        {0x21, 0x47, 0x10, 0x60, 0x03, 0x00, 0x54, 0x4B},
        {0x64, 0x07, 0x10, 0x4A, 0x03, 0x80, 0x54, 0x4B},

        {0x07, 0x1E, 0x20, 0x77, 0x00, 0x81, 0x99, 0x94},
        {0x26, 0x2D, 0x20, 0x22, 0x00, 0xC1, 0xD9, 0xD4},
        {0x13, 0x4B, 0x10, 0x1F, 0x03, 0xC0, 0x14, 0x0B},
        {0x20, 0x3B, 0x10, 0x35, 0x03, 0x40, 0x14, 0x0B},
        {0x23, 0x07, 0x20, 0x22, 0x00, 0x41, 0x59, 0x54},
        {0x28, 0x1E, 0x20, 0xDD, 0x00, 0x81, 0x99, 0x94},
        {0x28, 0x4D, 0x20, 0xEA, 0x03, 0xD0, 0xE0, 0xCB},
        {0x28, 0x2D, 0x10, 0xFF, 0x02, 0x9B, 0xC0, 0xDA}
      },
      {
        {0x20, 0x4B, 0x10, 0x00, 0x02, 0x5B, 0x00, 0x1A},
        {0x20, 0x4B, 0x20, 0x15, 0x03, 0x10, 0x20, 0x0B},
        {0x21, 0x07, 0x20, 0x22, 0x00, 0x41, 0x59, 0x54},
        {0x24, 0x1E, 0x20, 0xDD, 0x00, 0x81, 0x99, 0x94},
        {0x07, 0x4D, 0x10, 0xCA, 0x03, 0x80, 0xD4, 0xCB},
        {0x26, 0x2D, 0x10, 0xE0, 0x03, 0x00, 0xD4, 0xCB},
        {0x13, 0x3B, 0x20, 0xDD, 0x00, 0x01, 0x19, 0x14},
        {0x20, 0x07, 0x20, 0x88, 0x00, 0x41, 0x59, 0x54},

        {0x23, 0x4E, 0x10, 0xB5, 0x03, 0x40, 0x94, 0x8B},
        {0x06, 0x1E, 0x10, 0x9F, 0x03, 0xC0, 0x94, 0x8B},
        {0x27, 0x2D, 0x20, 0x88, 0x00, 0xC1, 0xD9, 0xD4},
        {0x24, 0x3B, 0x20, 0x77, 0x00, 0x01, 0x19, 0x14},
        {0x11, 0x47, 0x10, 0x60, 0x03, 0x00, 0x54, 0x4B},
        {0x22, 0x07, 0x10, 0x4A, 0x03, 0x80, 0x54, 0x4B},
        {0x05, 0x1E, 0x20, 0x77, 0x00, 0x81, 0x99, 0x94},
        {0x28, 0x2D, 0x20, 0x22, 0x00, 0xC1, 0xD9, 0xD4},
        {0x25, 0x4B, 0x10, 0x1F, 0x03, 0xC0, 0x14, 0x0B},
        {0x12, 0x3B, 0x10, 0x35, 0x03, 0x40, 0x14, 0x0B},
        {0x21, 0x07, 0x20, 0x22, 0x00, 0x41, 0x59, 0x54},
        {0x24, 0x1E, 0x20, 0xDD, 0x00, 0x81, 0x99, 0x94},
        {0x07, 0x4D, 0x10, 0xCA, 0x03, 0x80, 0xD4, 0xCB},
        {0x26, 0x2D, 0x10, 0xE0, 0x03, 0x00, 0xD4, 0xCB},
        {0x13, 0x3B, 0x20, 0xDD, 0x00, 0x01, 0x19, 0x14},
        {0x60, 0x07, 0x20, 0x88, 0x00, 0x41, 0x59, 0x54},

        {0x23, 0x4E, 0x10, 0xB5, 0x03, 0x40, 0x94, 0x8B},
        {0x06, 0x1E, 0x10, 0x9F, 0x03, 0xC0, 0x94, 0x8B},
        {0x27, 0x2D, 0x20, 0x88, 0x00, 0xC1, 0xD9, 0xD4},
        {0x24, 0x3B, 0x20, 0x77, 0x00, 0x01, 0x19, 0x14},
        {0x11, 0x47, 0x10, 0x60, 0x03, 0x00, 0x54, 0x4B},
        {0x22, 0x07, 0x10, 0x4A, 0x03, 0x80, 0x54, 0x4B},
        {0x28, 0x1E, 0x20, 0x77, 0x00, 0x81, 0x99, 0x94},
        {0x28, 0x2D, 0x20, 0xEE, 0x02, 0xC3, 0xD8, 0xDA}
      }
    }
  },

	{									//"P0480P0720",
	VLM_PROGRESSIVE,
	480,
	VLM_PROGRESSIVE,
	720,
	717,	// errors in last lines	

   0x04,
   0x40,
   0x77,
    {
      {
        {0x22, 0x47, 0x00, 0x60, 0x03, 0x42, 0x58, 0x4B},
        {0x24, 0x07, 0x00, 0x4A, 0x03, 0x42, 0x58, 0x4B},
        {0x06, 0x1E, 0x00, 0xF5, 0x00, 0x90, 0x91, 0x94},
        {0x26, 0x4D, 0x00, 0xCA, 0x03, 0xC2, 0xD8, 0xCB},
        {0x24, 0x2D, 0x00, 0xE0, 0x03, 0xC2, 0xD8, 0xCB},
        {0x52, 0x3B, 0x00, 0xF5, 0x00, 0x10, 0x11, 0x14},

        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      },
      {
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      }
    }
  },
  
	{										//"P0720P0720", 
	VLM_PROGRESSIVE,
	720,
	VLM_PROGRESSIVE,
	720,
	720,	

   0x04,
   0x41,
   0xB2,
    {
      {
        {0x20, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},

        {0x22, 0x12, 0x02, 0x55, 0x10, 0x40, 0x40, 0x41},
        {0x06, 0x24, 0x02, 0xAA, 0x10, 0x80, 0x80, 0x81},
        {0x26, 0x38, 0x02, 0xFF, 0x10, 0xC0, 0xC0, 0xC1},
        {0x52, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x01},

        {0x22, 0x12, 0x02, 0x55, 0x10, 0x40, 0x40, 0x41},
        {0x26, 0x24, 0x02, 0xAA, 0x10, 0x80, 0x80, 0x81},
        {0x28, 0x48, 0x02, 0xFF, 0x10, 0xC0, 0xC0, 0xC1},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      },
      {
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},

        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      }
    }
  },
  
	{										//"P1080P0720", 
	VLM_PROGRESSIVE,
	1088,
	VLM_PROGRESSIVE,
	720,
	720,	

   0x04,
   0x40,
   0x58,
    {
      {
        {0x07, 0x07, 0x00, 0xA0, 0x00, 0x08, 0x4B, 0x4C},
        {0x21, 0x1E, 0x00, 0x5F, 0x00, 0xC8, 0x8B, 0x8C},
        {0x15, 0x3B, 0x00, 0x5F, 0x00, 0xC8, 0x0B, 0x0C},
        {0x05, 0x07, 0x00, 0x0A, 0x00, 0x88, 0x4B, 0x4C},
        {0x11, 0x2D, 0x00, 0x0A, 0x00, 0x88, 0xCB, 0xCC},
        {0x27, 0x3B, 0x00, 0xF5, 0x00, 0x48, 0x0B, 0x0C},
        {0x03, 0x1E, 0x00, 0xF5, 0x00, 0x48, 0x8B, 0x8C},
        {0x53, 0x2D, 0x00, 0xA0, 0x00, 0x08, 0xCB, 0xCC},

        {0x21, 0x3B, 0x00, 0x5F, 0x00, 0xC8, 0x0B, 0x0C},
        {0x27, 0x07, 0x00, 0x0A, 0x00, 0x88, 0x4B, 0x4C},
        {0x03, 0x2D, 0x00, 0x0A, 0x00, 0x88, 0xCB, 0xCC},
        {0x13, 0x3B, 0x00, 0xF5, 0x00, 0x48, 0x0B, 0x0C},
        {0x07, 0x1E, 0x00, 0xF5, 0x00, 0x48, 0x8B, 0x8C},
        {0x21, 0x2D, 0x00, 0xA0, 0x00, 0x08, 0xCB, 0xCC},
        {0x15, 0x0C, 0x00, 0xEA, 0x03, 0xC1, 0xD8, 0xD3},
        {0x28, 0x18, 0x00, 0xFF, 0x02, 0xD2, 0xDA, 0xD2},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      },
      {
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
      }
    }
  }
 };

 
/**************************** END ************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2dec\specific\zr38spi.h ===
// FILE:			library\hardware\mpeg3dec\specific\zr38spi.h
// AUTHOR:		Viona
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		05.12.95
//
// PURPOSE:		
//
// HISTORY:
//
// ZR38SPI.H
//

#ifndef ZR38SPI_H
#define ZR38SPI_H

#include "..\..\..\common\prelude.h"
#include "..\..\..\lowlevel\hardwrio.h"
#include "..\..\..\lowlevel\timer.h"
#include "library\general\dynarray.h"      
      
#define GNR_ZR38SPI_INVALID_OPCODE					MKERR(ERROR, AC3, UNIMPLEMENTED, 0x0101)
#define GNR_ZR38SPI_INVALID_PARAMETERS 			MKERR(ERROR, AC3, PARAMS,			0x0102)
#define GNR_ZR38SPI_NOT_READY							MKERR(ERROR, AC3, BUSY,				0x0103)
#define GNR_ZR38SPI_WRONG_NUMBER_OF_ARGUMENTS   MKERR(ERROR, AC3, PARAMS,			0x0104)

//
// Generic SPI port
//
class ZR38SPIPort
	{
	private:
		BitInputPort	*	si;
		BitOutputPort	*	ss;
		BitOutputPort	*	sck;
		BitOutputPort	*	so;		
		int					delay;
		
		//
		// Primitive serial bus operations
		//
		void Delay(void);
		Error Start(void);
		Error Stop(void);
		Error SendByte(BYTE data, BYTE __far&result);

	protected:
		//
		// Basic communication function
		//
		Error SendCommandA(BYTE command, int numResult, void __far * result, int xparams, DWORD __far *xparam, int __far *param);
	public:
		ZR38SPIPort(BitInputPort * si, BitOutputPort * ss, BitOutputPort * sck, BitOutputPort * so, int delay);
		
		//
		// Derivatives of the basic communication function, to make live
		// a little easier
		//
		Error SendCommand(BYTE command, int numResult, void __far * result, int xparams, DWORD __far *xparam, int param, ...)
			{return SendCommandA(command, numResult, result, xparams, xparam, &param);}

		Error SendCommand(BYTE command, int numResult, void __far * result, int param, ...)
			{return SendCommandA(command, numResult, result, 0, NULL, &param);}
		Error SendCommand(BYTE command) 
			{return SendCommandA(command, 0, NULL, 0, NULL, NULL);}
		Error SendCommand(BYTE command, int param, ...)
			{return SendCommandA(command, 0, NULL, 0, NULL, &param);}
		Error SendCommand(BYTE command, int numResult, void __far * result)
			{return SendCommandA(command, numResult, result, 0, NULL, NULL);}
		
		//
		// Send a file over the SPI bus
		//	
		Error SendFile(const char * fname);
		Error SendArray(DynamicByteArray array);
	};

//
// Specific SPI port for Zoran ZR38xxx chips, shall be separated from
// the generic SPI port in future.
//
class ZR385XXSPIComPort : public ZR38SPIPort
	{
	public:
		//
		// Parameter structure for the different ZR38xxx commands.
		//
	   class __far CFGParams
	   	{
	   	public:
	   		BOOL	wfa, wfb, aw, bw;
	   		BYTE	wait;
	   		BOOL	db, da, cb, mb, ma, tb, ta;
	   		BOOL	sb, sa;
	   		BYTE	frb, fra;
	   		BYTE	sr;
	   		BOOL	mpe, err, dreq, isp, osp;
	   		BOOL	ays, spo;
	   		BYTE	inw, outw, raw;
	   		BYTE	spas;
	   		BYTE	spbs;
	   		BYTE	sppr;
	   		
	   		CFGParams(	BOOL	wfa, BOOL wfb, BOOL aw, BOOL bw,
								BYTE	wait,
								BOOL	db, BOOL da, BOOL cb, BOOL mb, BOOL ma, BOOL tb, BOOL ta,
								BOOL	sb, BOOL sa,
								BYTE	frb, BYTE fra,
								BYTE	sr,
								BOOL	mpe, BOOL err, BOOL dreq, BOOL isp, BOOL osp,
								BOOL	ays, BOOL spo,
								BYTE	inw, BYTE outw, BYTE raw,
								BYTE	spas,
								BYTE	spbs,
								BYTE	sppr);
				Error Send(ZR38SPIPort * port);
	   	};

	   class __far PNGParams
	   	{
	   	public:
	   		BOOL	ns, l, c, r, ls, rs, sw;
	   		WORD	pcmsf;
	   	
	   		PNGParams(BOOL ns, BOOL l, BOOL c, BOOL r, BOOL ls, BOOL rs, BOOL sw,
	   		          WORD pcmsf);
				Error Send(ZR38SPIPort * port);
	   	};

		class __far PCMParams
			{
			public:
				BOOL	de;
				BYTE	dmm;
				WORD	pcmsf;
				
				PCMParams(BOOL de, BYTE dmm, WORD pcmsf);
				Error Send(ZR38SPIPort * port);
			};
			
		class __far PCMXParams
			{ 
			public:
				BOOL	de, ns;
				BYTE	ocfg;
				WORD	pcmsf;
				BYTE	errcnt;
				BYTE	drc;
				
				PCMXParams(BOOL de, BOOL ns, BYTE ocfg, WORD pcmsf, BYTE errcnt, BYTE drc);
				Error Send(ZR38SPIPort * port);
			};
			
		class __far AC3Params
			{
			public:
				BYTE	prlg;
				BOOL	sif;
				BYTE	comp;
				BYTE	dmm;
				BOOL	sf, ab;
				BYTE	pbcfg;
				BOOL	sw;
				BYTE	ocfg;
				BYTE	cdly;
				BYTE	srdly;
				WORD	dynrng;
				BYTE	dsn;
				BOOL	kar;
				BYTE	rpc;
				WORD	pcmsf;
				
				AC3Params(BYTE prlg, BOOL sif, BYTE comp, BYTE dmm, BOOL sf, BOOL ab,
							 BYTE pbcfg, BOOL sw, BYTE ocfg, BYTE cdly, BYTE srdly,
							 WORD dynrng, BYTE dsn, BOOL kar, BYTE rpc, WORD pcmsf);
				Error Send(ZR38SPIPort * port);
			};
			
		class __far PROLParams
			{ 
			public:
				BOOL	sf;
				BOOL	ab;
				BYTE	bcfg;
				BOOL	sw;
				BYTE	ocfg;
				BYTE	cdly;
				BYTE	srdly;
				WORD	pcmsf;
				
				PROLParams(BOOL sf, BOOL ab, BYTE bcfg, BOOL sw, BYTE ocfg, BYTE cdly, BYTE srdly, WORD pcmsf);
				Error Send(ZR38SPIPort * port);
			};		
				
		class __far MPEG1Params
			{ 
			public:
				BYTE	dmm;
				WORD	pcmsf;
				
				MPEG1Params(BYTE dmm, WORD pcmsf);
				Error Send(ZR38SPIPort * port);
			};
			
		class __far AC3Status
			{
			public:
				BYTE	status;
				BYTE	rst;
				BYTE	bufst;
				BYTE	ptst;
				WORD	dift;

				BYTE	ac3dst;
				BYTE	ac3ist;
				WORD	bitstreamConfig;
				WORD	miscInfo;
				WORD	dialogNorm;
				WORD	languageCode;
				WORD	audioProduction;        
				
				Error Receive(ZR38SPIPort * port);
			};
			
		class __far PCMStatus
			{
			public:
				BYTE	status;
				BYTE	rst;
				BYTE	bufst;
				BYTE	ptst;
				WORD	dift;

				BOOL	e;
				BOOL	m;
				BYTE	afn;
				BYTE	qwl;
				BYTE	sr;
				BYTE	nac;

				Error Receive(ZR38SPIPort * port);
			};           
			
		class __far MPEG1Status
			{
			public:
				BYTE	status;
				BYTE	rst;
				BYTE	bufst;
				BYTE	ptst;
				WORD	dift;

				BYTE	mpgst;
				BOOL	id;
				BYTE	lay;
				BOOL	prt;
				BYTE	br;
				BYTE	sfr;
				BOOL	pad;
				BOOL	prv;
				BYTE	mode;
				BYTE	mext;
				BOOL	cpr;
				BOOL	org;
				BYTE	emph;

				Error Receive(ZR38SPIPort * port);
			};
		
		class __far USERParams
			{
			public:
				BYTE	data[8];
			};
			
		ZR385XXSPIComPort(BitInputPort * si, BitOutputPort * ss, BitOutputPort * sck, BitOutputPort * so, int delay);
	
		//
		// ZR38xxx commands, represented as functions
		//
		
		//
		// Main mode commands
		//
		Error SetCFG(CFGParams __far& params);
		Error SetPNG(PNGParams __far& params);
		Error SetPCM(PCMParams __far& params);
		Error SetPCMX(PCMXParams __far& params);
		Error SetAC3(AC3Params __far& params);
		Error SetSCR(DWORD scr, WORD vd);
		Error SetPROL(PROLParams __far& params);
		Error SetMPEG(MPEG1Params __far& params);

		Error ComUSER(USERParams __far& params);
	
		//
		// Decoding control commands
		//
		Error ComNOP(void);
		Error ComPLAY(void);
		Error ComMUTE(void);
		Error ComUNMUTE(void);
		Error ComSTOP(void);
		Error ComSTOPF(void);
		
		//
		// Status commands
		//
		Error StatAC3(AC3Status __far& status);
		Error StatPCM(PCMStatus __far& status);
		Error StatMPEG1(MPEG1Status __far& status);
		Error StatSTCR(DWORD __far& stcr);
		Error StatVER(DWORD &version);
		
		//
		// Extended commands
		//
		Error ComBOOT(BYTE __far& data, int size);
		Error SetIO(BYTE gpioc, BYTE gpio, BYTE __far& gipor);
		Error ComPOKE(DWORD addr, int size, DWORD __far& data);
		Error ComPEEK(DWORD addr, int size, DWORD __far& data);
		
	};

////////////////////////// Inline implementation /////////////////////////////////////

inline ZR385XXSPIComPort::CFGParams::CFGParams(	BOOL	wfa, BOOL wfb, BOOL aw, BOOL bw,
																BYTE	wait,
																BOOL	db, BOOL da, BOOL cb, BOOL mb, BOOL ma, BOOL tb, BOOL ta,
																BOOL	sb, BOOL sa,
																BYTE	frb, BYTE fra,
																BYTE	sr,
																BOOL	mpe, BOOL err, BOOL dreq, BOOL isp, BOOL osp,
																BOOL	ays, BOOL spo,
																BYTE	inw, BYTE outw, BYTE raw,
																BYTE	spas,
																BYTE	spbs,
																BYTE	sppr)
	{
	this->wfa = wfa;
	this->wfb = wfb;
	this->aw = aw;
	this->bw = bw;
	this->wait = wait;
	this->db = db;
	this->da = da;
	this->cb = cb;
	this->mb = mb;
	this->ma = ma;
	this->tb = tb;
	this->ta = ta;
	this->sb = sb;
	this->sa = sa;
	this->frb = frb;
	this->fra = fra;
	this->sr = sr;
	this->mpe = mpe;
	this->err = err;
	this->dreq = dreq;
	this->isp = isp;
	this->osp = osp;
	this->ays = ays;
	this->spo = spo;
	this->inw = inw;
	this->outw = outw;
	this->raw = raw;
	this->spas = spas;
	this->spbs = spbs;
	this->sppr = sppr;
	}

inline ZR385XXSPIComPort::PNGParams::PNGParams(BOOL ns, BOOL l, BOOL c, BOOL r, BOOL ls, BOOL rs, BOOL sw, WORD pcmsf)
	{
	this->ns = ns;
	this->l = l;
	this->c = c;
	this->r = r;
	this->ls = ls;
	this->rs = rs;
	this->sw = sw;       
	this->pcmsf = pcmsf;
	}

inline ZR385XXSPIComPort::PCMParams::PCMParams(BOOL de, BYTE dmm, WORD pcmsf)
	{
	this->de = de;
	this->dmm = dmm;
	this->pcmsf = pcmsf;
	}

inline ZR385XXSPIComPort::PCMXParams::PCMXParams(BOOL de, BOOL ns, BYTE ocfg, WORD pcmsf, BYTE errcnt, BYTE drc)
	{
	this->de = de;
	this->ns = ns;
	this->ocfg = ocfg;
	this->pcmsf = pcmsf;
	this->errcnt = errcnt;
	this->drc = drc;
	}
	
inline ZR385XXSPIComPort::AC3Params::AC3Params(BYTE prlg, BOOL sif, BYTE comp, BYTE dmm, BOOL sf, BOOL ab,
			 											     BYTE pbcfg, BOOL sw, BYTE ocfg, BYTE cdly, BYTE srdly,
			 											     WORD dynrng, BYTE dsn, BOOL kar, BYTE rpc, WORD pcmsf)
	{
	this->prlg = prlg;
	this->sif = sif;
	this->comp = comp;
	this->dmm = dmm;
	this->sf = sf;
	this->ab = ab;
	this->pbcfg = pbcfg;
	this->sw = sw;
	this->ocfg = ocfg;
	this->cdly = cdly;
	this->srdly = srdly;
	this->dynrng = dynrng;
	this->dsn = dsn;
	this->kar = kar;
	this->rpc = rpc;
	this->pcmsf = pcmsf;
	}
	
inline ZR385XXSPIComPort::PROLParams::PROLParams(BOOL sf, BOOL ab, BYTE bcfg, BOOL sw, BYTE ocfg, BYTE cdly, BYTE srdly, WORD pcmsf)
	{
	this->sf = sf;
	this->ab = ab;
	this->bcfg = bcfg;
	this->sw = sw;
	this->ocfg = ocfg;
	this->cdly = cdly;
	this->srdly = srdly;
	this->pcmsf = pcmsf;
	}
	
inline ZR385XXSPIComPort::MPEG1Params::MPEG1Params(BYTE dmm, WORD pcmsf)
	{
	this->dmm = dmm;
	this->pcmsf = pcmsf;
	}
	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2enc\generic\mp2avmen.h ===
//
// FILE:      library\hardware\mpeg2enc\generic\mp2avmen.h
// AUTHOR:    Martin Stephan
// COPYRIGHT: (c) 1999 VIONA Development GmbH.  All Rights Reserved.
// CREATED:   22.11.1999
//
// PURPOSE:   MPEG2 Audio/Video Multiplex Encoder Class - Interface
//
// HISTORY:
//

#ifndef MP2AVMEN_H
#define MP2AVMEN_H

#include "mpeg2enc.h"

class MPEG2AVMuxEncoder : public MPEG2AVEncoder
	{               
	friend class VirtualMPEG2AVMuxEncoder;

	protected:
		MPEG2VideoEncoder 			*	videoEncoder;
		MPEG2AudioEncoder 			*	audioEncoder;

		VirtualMPEG2VideoEncoder	*	virtualVideoEncoder;
		VirtualMPEG2AudioEncoder	*	virtualAudioEncoder;

		Error StartCapture();
		Error StopCapture();
		Error DoCommand(MPEGCommand com, DWORD param);
		Error AddBuffer(HPTR data, DWORD size);
		MPEGState CurrentState(void);

		Error SetOutputStreamType(MPEGEncoderStreamType outputStreamType);
		Error SetVideoSource(VideoSource source);
		Error SetVideoStandard(VideoStandard standard);

	public:
		MPEG2AVMuxEncoder(MPEG2VideoEncoder 	* videoEncoder,
		                    MPEG2AudioEncoder 	* audioEncoder);
		~MPEG2AVMuxEncoder(void);		

	   VirtualMPEG2AVEncoder * CreateVirtualMPEGEncoder(void);
		};

	
class VirtualMPEG2AVMuxEncoder : public VirtualMPEG2AVEncoder
	{  
	private:
		MPEG2AVMuxEncoder			*	encoder;
	protected:	
		VirtualMPEG2VideoEncoder	*	videoEncoder;
		VirtualMPEG2AudioEncoder	*	audioEncoder;
		
		Error PreemptStopPrevious(VirtualUnit * previous);
		Error PreemptChange(VirtualUnit * previous);
		Error PreemptStartNew(VirtualUnit * previous);
	public:
		VirtualMPEG2AVMuxEncoder(MPEG2AVMuxEncoder * encoder, BOOL idle = FALSE);
		~VirtualMPEG2AVMuxEncoder(void);

		Error DoCommand(MPEGCommand com, DWORD param);
		Error Configure(TAG __far * tags);
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2enc\specific\altrreg.h ===
//
// FILE:			library\hardware\mpeg2enc\specific\altrreg.h
// AUTHOR:		Martin Stephan
// COPYRIGHT:	(c) 1999 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		30.12.1999
//
// PURPOSE:		--- Altera chip specific register definitions for CineMaster II 2000 Encoder --- 
//
// HISTORY:		The definitions are taken from VisionTech's driver.
//					
//

#ifndef ALTRREG_H
#define ALTRREG_H

// All data is in DWORDs
// Kfir registers 
#define ALT_ADR_KFIR_REV_AB					0x000


#define ALT_V11_OLD_REV_AB						0x000


///////////////////////////////////////////////////////////////////////////////////////
//
//		BOARD REVISION 5E
//
///////////////////////////////////////////////////////////////////////////////////////

// offset for Kfir registers 
#define ALT_ADR_KFIR_REV_5E					0x2000

// 1 - Source of interrupt on Read
// 1 - Clear Interrupt when Write
#define ALTREG_INT_REG_CLR_REV_5E			0x3000
#define ALTVAL_INT_CLR_KFIR_INT					0x0001
#define ALTVAL_INT_CLR_ADSP_INT					0x0002
#define ALTVAL_INT_CLEAR_ALL                 0xFF

// 1 - Mask this interupt when Write
#define ALTREG_INT_MASK_REV_5E				0x3004

// 1 - Reset the device when Write 0, except for Kfir PLL - 1
#define ALTREG_RESET_REV_5E					0x3008
#define ALTIDX_RESET_KFIR_REV_5E					0			// 0x0001 - bit 0
#define ALTIDX_RESET_PLL_REV_5E					1			// 0x0002 - bit 1




// 1 - Source of interrupt on Read
// 1 - Clear Interrupt when Write
#define ALT_INT_REG_CLR_REV_AB				0x400
#define ALT_D_INT_REG_CLR_KFIR_INT				0x0001	// bit 0
#define ALT_D_INT_REG_CLR_ADSP_INT           0x0002	// bit 1
#define ALT_D_INT_REG_CLR_LB_TIMEOUT_REV_AB  0x0010	// bit 4
#define ALT_D_INT_CLEAR_ALL                  0xFF		// 

// 1 - Mask this interupt when Write
#define ALT_INT_MASK_REV_AB					0x404
// see ALT_ADR_INT_REG_CLR


// 1 - Reset the device when Write 0;  valid for board revision A and B
#define ALTREG_RESET_REV_AB					0x408			//#define ALT_RESET_REG_REV_AB					0x408
#define ALTIDX_D_RESET_KFIR_REV_ABD				0			//#define ALT_D_RESET_REG_KFIR_REV_ABD			0x0001	// bit 0 
#define ALTIDX_D_RESET_ADSP_REV_AB				1			//#define ALT_D_RESET_REG_ADSP					0x0002	// bit 1
#define ALTIDX_D_RESET_ATOD_REV_AB				2			//#define ALT_D_RESET_REG_ATOD_REV_ABD			0x0004	// bit 2

// 1 - Reset the device when Write 0, except for Kfir PLL - 1; valid for board revision C and D
#define ALTREG_RESET_REV_CD					0x00100008
#define ALTIDX_D_RESET_ATOD_REV_C				0			//0x0001	- bit 0 
#define ALTIDX_D_RESET_ADSP_REV_C				1			//0x0002	- bit 1
#define ALTIDX_D_RESET_KFIR_REV_C				2			//0x0004	- bit 2
#define ALTIDX_D_RESET_GENNUM_REV_C				3			//0x0008	- bit 3
#define ALTIDX_D_RESET_KFIR_PLL_REV_C			4			//0x0010	- bit 4




// ADSP address when write - IAL
#define ALT_ADSP_ADDR_REV_AB					0x40C


// ADSP data when read/write - IDMA
//#define ALT_ADR_ADSP_DATA					0x410
#define ALT_ADSP_DATA_REV_AB					0x450


// Set ADSP IRQs (write 0, then 1) - GPPORT
#define ALT_ADSP_IRQ_REV_AB					0x418
#define ALT_D_ADSP_IRQ_E							0x0001	// bit 0
#define ALT_D_ADSP_IRQ_2							0x0002	// bit 1
#define ALT_D_ADSP_IRQ_FL0_REV_AB				0x0004	// bit 2
#define ALT_D_ADSP_ALL_IRQ							0xFF

// Set ADSP frequency
#define ALT_ADSP_FREQ_REV_AB					0x41C
#define ALT_ADR_ADSP_FREQ_MASK					0x0003	// bit 0 and bit 1
//        00 - 32 KHz,
//        01 - 44.1 KHz,
//        10 - 48 KHz
#define ALT_D_ADSP_SYNC								0x000C	// bit 2 and bit 3

#define ALTREG_KFIR_BASE_ADDRESS				0x420			//#define ALT_KFIR_BASE_ADDRESS_REV_AB		0x420
#define ALTIDX_KFIR_BASE_ADDRESS_BIT0			0
#define ALTIDX_KFIR_BASE_ADDRESS_BIT1			1
#define ALTIDX_KFIR_BASE_ADDRESS_BIT2			2
//#define ALT_KFIR_BASE_ADDRESS_MASK				0x0007	// bit 0 and bit 1 and bit 2
//    000 - Base Address 0,
//    ...
//    111 - Base Address 7
#define ALTIDX_D_KFIR_OUTPUT_FIFO_PRESENT		3			//#define ALT_D_KFIR_OUTPUT_FIFO_PRESENT			0x0008	// bit 3
#define ALTIDX_D_KFIR_I960_MODE					4			//#define ALT_D_KFIR_I960_MODE						0x0010	// bit 4


// I2C interface.
#define ALT_I2C_REV_AB							0x42C //0x414     //0x42C
#define ALT_I2C_DATA_MASK							0x000F	// bit 3,2,1,0
#define ALT_I2C_SUBADDRESS_MASK					0x00F0	// bit 7,6,5,4
#define ALT_I2C_SUBADDRESS_SHIFT					8
#define ALT_I2C_SLAVE_MASK							0x0F00	// bit 11,10,9,8
#define ALT_I2C_SLAVE_SHIFT						16
#define ALT_D_I2C_READY								0x1000	// bit 12
#define ALT_D_I2C_ACCESS							0x2000	// bit 13


// Kfir Audio Base.
#define ALT_KFIR_AUDIO_BASE_REV_AB			0x430
#define ALT_D_KFIR_AUDIO_BASE_MASK				0xFFF		// 
#define ALT_D_KFIR_AUDIO_BASE_SHIFT				20
#define ALT_D_AUDIO_2_ALTERA_2_KFIR				(1<<12)

// 
#define ALT_ADSP_DMA_REV_AB					0x600


// Encoded data when read.
#define ALT_KFIR_OUTPUT_FIFO_DATA_REV_AB  0x10000


#endif // ALTRREG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2enc\generic\mpeg2enc.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:       library\hardware\mpeg2enc\generic\mpeg2enc.h
// AUTHOR:		Martin Stephan
// COPYRIGHT:	(c) 1999 Viona Development GmbH.  All Rights Reserved.
// CREATED:		25.10.1999
//
// PURPOSE: 	MPEG2 video/audio encoders and supporting classes. --- Header file
//
// HISTORY:
//

#ifndef MPEG2ENC_H
#define MPEG2ENC_H

#include "mp2elenc.h"

#ifndef ONLY_EXTERNAL_VISIBLE

class MPEG2AVEncoder : public MPEG2ElementaryEncoder
   {
   friend class VirtualMPEG2AVEncoder;

   protected:
		MPEGEncoderStreamType	outputType;

		virtual Error SetOutputStreamType(MPEGEncoderStreamType outputStreamType) = 0;
		virtual Error SetVideoSource(VideoSource source) = 0;
		virtual Error SetVideoStandard(VideoStandard	standard) = 0;

   public:
		VirtualUnit * CreateVirtual(void);

		virtual VirtualMPEG2AVEncoder * CreateVirtualMPEGEncoder(void) = 0;
   };

class VirtualMPEG2AVEncoder : public VirtualMPEG2ElementaryEncoder
	{
	private:
		MPEG2AVEncoder * encoder;

	protected:
		//MPEGStreamType				streamType;
		MPEGEncoderStreamType	outputStreamType;
		VideoStandard				videoStandard;
		VideoSource					videoSource;

		Error PreemptChange(VirtualUnit * previous);

	public:
		VirtualMPEG2AVEncoder(MPEG2AVEncoder * encoder);

		Error Configure(TAG __far * tags);
	};
#endif

#endif // MPEG2ENC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2enc\generic\mp2elenc.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:       library\hardware\mpeg2enc\generic\mp2elenc.h
// AUTHOR:		Martin Stephan
// COPYRIGHT:	(c) 1999 Viona Development GmbH.  All Rights Reserved.
// CREATED:		25.10.1999
//
// PURPOSE: 	MPEG2 elementary video/audio encoders and supporting classes. --- Header file
//
// HISTORY:
//

#ifndef MP2ELENC_H
#define MP2ELENC_H

#include "library\hardware\mpegenc\generic\mpegenc.h"

#ifndef ONLY_EXTERNAL_VISIBLE

class MPEG2ElementaryEncoder : public PhysicalUnit
   {
   friend class VirtualMPEG2ElementaryEncoder;

   protected:
		Error TransferDoneHook(void);
		Error BufferStarvingHook(void);

		virtual Error DoCommand(MPEGCommand com, DWORD param) = 0;
		virtual Error AddBuffer(HPTR data, DWORD size) = 0;
		virtual MPEGState CurrentState(void) = 0;

	public:
		MPEG2ElementaryEncoder(void) {;}

	};

class VirtualMPEG2ElementaryEncoder : public VirtualUnit
	{
	friend class MPEG2ElementaryEncoder;

	private:
		MPEG2ElementaryEncoder	*	encoder;

	protected:
#if !DRVDLL
		MPEGTransferDoneHookHandle				doneHook;
		MPEGEncoderBufferStarvingHookHandle bufferStarvingHook;
#endif
		Error PreemptStopPrevious(VirtualUnit * previous);
      Error PreemptChange(VirtualUnit * previous);
      Error PreemptStartNew(VirtualUnit * previous);

	public:
		VirtualMPEG2ElementaryEncoder(MPEG2ElementaryEncoder * unit);
		~VirtualMPEG2ElementaryEncoder(void);

		Error Configure (TAG __far *tags);
		virtual Error AddBuffer(HPTR data, DWORD size);
		virtual Error AllocateBuffer (DWORD size, FPTR __far &info, FPTR __far &data) { GNRAISE(GNR_UNIMPLEMENTED); }
		virtual Error FreeBuffer (FPTR info) { GNRAISE(GNR_UNIMPLEMENTED); }
		virtual Error DoCommand(MPEGCommand com, DWORD param);

	};

class MPEG2VideoEncoder : public MPEG2ElementaryEncoder
	{
	friend class VirtualMPEG2VideoEncoder;

	protected:
		virtual Error SetOutputStreamType(MPEGEncoderStreamType outputStreamType) = 0;
		virtual Error SetVideoSource(VideoSource source) = 0;
		virtual Error SetVideoStandard(VideoStandard	standard) = 0;
		virtual Error SetAspectRatio(WORD aspectRatio) = 0;
		virtual Error SetFrameRate(DWORD frameRate) = 0;
		virtual Error SetVideoBitrate(DWORD videoBitrate) = 0;
		virtual Error SetAudioBitrate(DWORD audioBitrate) = 0;
		virtual Error SetVideoWidth(WORD width) = 0;
		virtual Error SetVideoHeight(WORD height) = 0;

	public:

	};

class VirtualMPEG2VideoEncoder : public VirtualMPEG2ElementaryEncoder
	{
	private:
		MPEG2VideoEncoder	*		encoder;

	protected:
		MPEGEncoderStreamType	outputStreamType;
		VideoSource					videoSource;
		VideoStandard				videoStandard;

		Error PreemptChange(VirtualUnit * previous);

	public:
		VirtualMPEG2VideoEncoder(MPEG2VideoEncoder * unit) : VirtualMPEG2ElementaryEncoder(unit)
			{encoder = unit; outputStreamType = MST_UNKNOWN; videoSource = VIDEOSOURCE_MIN;
			 videoStandard = VIDEOSTANDARD_MIN;}

		Error Configure(TAG __far * tags);
	};

class MPEG2AudioEncoder : public MPEG2ElementaryEncoder
	{
	public:

	};

class VirtualMPEG2AudioEncoder : public VirtualMPEG2ElementaryEncoder
	{
	private:
		MPEG2AudioEncoder	* encoder;
	protected:
		Error PreemptChange(VirtualUnit * previous);
	public:
		VirtualMPEG2AudioEncoder(MPEG2AudioEncoder	* encoder) : VirtualMPEG2ElementaryEncoder(encoder)
			{this->encoder = encoder;}

		Error Configure (TAG __far *tags);
	};


#endif // ONLY_EXTERNAL_VISIBLE

#endif // MP2ELENC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2enc\specific\avmuxpar.h ===
#define NUMBER_OF_AVMUX_REGISTERS		74

static const unsigned long AV_MUX_PARAMETER[] =
	{
	0x0,
	0x1,
	0x0,
	0x3,
	0x10,
	0x11,
	0x12,
	0x0,
	0x0,
	0xaa20,
	0x44,
	0xe800,
	0x0,
	0x4b40,
	0x4c,
	0x8ca0,
	0x0,
	0x8ca0,
	0x0,
	0x800,
	0x800,
	0x1f4,
	0x9c4,
	0x0,
	0x0,
	0xad42,
	0x11,
	0x0,
	0xef35,
	0xfff8,
	0xffff,
	0xbb00,
	0xa0ee,
	0xa090,
	0x8,
	0x5440,
	0x89,
	0x83,
	0x0,
	0x0,
	0x0,
	0x0,
	0x0,
	0x0,
	0x0,
	0x0,
	0x0,
	0x0,
	0x0,
	0x0,
	0xe10,
	0x2a30,
	0x355,
	0x0,
	0x24d,
	0x0,
	0x2e72,
	0x0,
	0x2e72,
	0x0,
	0x2e72,
	0x0,
	0x100,
	0x0,
	0x100,
	0x0,
	0x100,
	0x0,
	0xf,
	0x5440,
	0x89,
	0x0,
	0x120,
	0x0,
	};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2enc\specific\alteramc.h ===
//
// FILE:			library\hardware\mpeg2enc\specific\alteramc.h
// AUTHOR:		Martin Stephan
// COPYRIGHT:	(c) 2000 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		16.02.2000
//
// PURPOSE:		microcode for the Altera FPGA board revision 5E
//
// HISTORY:
//

// taken from ALTERA_KEB_PLX_5E.RBF !!!

#define ARRAY_SIZE_ALTERA_MICROCODE 32385

static const unsigned char alteraMicroCode[ARRAY_SIZE_ALTERA_MICROCODE] =
{
	0xff, 0xff, 0x62, 0x7d, 0x16, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xbe, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9c, 0x00, 0x00, 0x02, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x40, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x02, 
	0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x02, 0x40, 
	0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 
	0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x00, 0x40, 
	0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x06, 0x41, 0x00, 0x00, 0xdd, 0x00, 0x00, 0x06, 0x42, 0x02, 
	0x40, 0x02, 0x40, 0x0a, 0x44, 0x02, 0x64, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 
	0x40, 0x02, 0x40, 0x02, 0x44, 0x02, 0x40, 0x02, 0x40, 0x02, 0x44, 0x02, 0x40, 0x02, 0x40, 0x0a, 
	0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x00, 0x00, 0xf4, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 
	0x00, 0x00, 0x02, 0x40, 0x00, 0x40, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 
	0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x98, 0x00, 0x00, 0x02, 0x40, 0x02, 0x40, 0x02, 
	0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 
	0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x00, 0x40, 0x02, 0x40, 0x02, 
	0x40, 0x02, 0x40, 0x02, 0x40, 0x00, 0x00, 0x9c, 0x00, 0x00, 0x02, 0x51, 0x02, 0x40, 0x02, 0x40, 
	0x02, 0x54, 0x02, 0x40, 0x02, 0x40, 0x1a, 0x40, 0x1a, 0x40, 0x02, 0x40, 0x02, 0x40, 0x06, 0x44, 
	0x02, 0x60, 0x02, 0x40, 0x06, 0x44, 0x02, 0x60, 0x02, 0x40, 0x00, 0x40, 0x02, 0x44, 0x0a, 0x42, 
	0x0a, 0x42, 0x04, 0x48, 0x00, 0x00, 0xb3, 0x00, 0x00, 0x00, 0x62, 0x00, 0x42, 0x01, 0x40, 0x07, 
	0x00, 0x00, 0x44, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x05, 0x00, 0x80, 0x40, 0x04, 
	0x00, 0x20, 0x60, 0x88, 0x50, 0x03, 0x41, 0x03, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x40, 0x08, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x03, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xbe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x8d, 0x02, 0x00, 0x00, 0x40, 0x14, 0x60, 0x24, 0x40, 0x01, 0x02, 0x00, 0x60, 
	0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x10, 0x00, 0x00, 0x50, 0x02, 0x04, 0x00, 0x40, 
	0x10, 0x40, 0x15, 0x60, 0x25, 0x00, 0x00, 0x40, 0x29, 0x00, 0x00, 0x40, 0x02, 0x01, 0x00, 0x00, 
	0x00, 0xc0, 0xf7, 0x02, 0x00, 0x40, 0x00, 0x0b, 0x48, 0x08, 0x00, 0x0a, 0x00, 0x80, 0x00, 0x0a, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 
	0x08, 0x04, 0x64, 0x08, 0x00, 0x80, 0x10, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 
	0x40, 0x90, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x8c, 0x02, 0x00, 0x00, 0x40, 0x03, 0x40, 0x03, 0x40, 0x03, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 
	0xc0, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x87, 
	0x02, 0x00, 0x00, 0x20, 0x23, 0x10, 0x00, 0x01, 0x03, 0x01, 0x00, 0x10, 0x83, 0x00, 0x00, 0xc0, 
	0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x04, 0xe1, 0x13, 0x40, 
	0x03, 0xc4, 0x00, 0x00, 0x07, 0x01, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00, 0x40, 0xfe, 0x02, 
	0x00, 0x40, 0x40, 0x01, 0x42, 0x01, 0x44, 0x00, 0x00, 0x00, 0x58, 0x01, 0x42, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x42, 0x03, 0x00, 0x00, 0x41, 0x06, 0x00, 0x00, 0x58, 0x03, 0x41, 0x03, 0x41, 0x03, 
	0x00, 0x00, 0x48, 0x01, 0x00, 0x00, 0x40, 0x04, 0x68, 0x03, 0x00, 0x00, 0x41, 0xf0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0x00, 0x00, 0x00, 
	0x40, 0x01, 0x40, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 
	0x40, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcc, 0x02, 0x00, 0x00, 0x50, 
	0x14, 0x60, 0x14, 0x60, 0x44, 0x00, 0x00, 0x40, 0x04, 0x51, 0x14, 0x00, 0x00, 0x00, 0x00, 0x60, 
	0x17, 0x00, 0x00, 0x60, 0x03, 0x04, 0x00, 0x40, 0x1b, 0x60, 0x15, 0x60, 0x15, 0x00, 0x00, 0x60, 
	0x48, 0x00, 0x00, 0x40, 0x82, 0x40, 0x18, 0x00, 0x00, 0xe0, 0xaf, 0x0a, 0x00, 0x00, 0x41, 0x00, 
	0x48, 0x08, 0x08, 0x00, 0x00, 0x00, 0x12, 0x84, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x00, 
	0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x08, 0x0a, 0x64, 0x00, 0x64, 0x04, 0x00, 0x40, 0x10, 0x05, 
	0x00, 0x00, 0x40, 0x02, 0x08, 0x00, 0x00, 0x00, 0x44, 0xb5, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x40, 0xc8, 0x02, 0x00, 0x00, 0x40, 0x02, 0x40, 0x03, 
	0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
	0x40, 0x03, 0x00, 0x00, 0xc0, 0x03, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0xc0, 0xd8, 0x02, 0x08, 0x00, 0x10, 0x05, 0x12, 0x80, 0x20, 
	0x28, 0x00, 0x00, 0x00, 0x00, 0x22, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00, 0x48, 0xc0, 0x00, 0x10, 
	0x0a, 0xc4, 0x00, 0x50, 0x23, 0x00, 0x0b, 0x04, 0x03, 0xc4, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 
	0x16, 0x10, 0x00, 0x00, 0x00, 0x20, 0x9b, 0x00, 0x42, 0x07, 0x44, 0x08, 0x42, 0x25, 0x50, 0x00, 
	0x00, 0x00, 0x42, 0x05, 0x40, 0x07, 0x00, 0x00, 0x00, 0x00, 0x42, 0x09, 0x00, 0x00, 0x44, 0x00, 
	0x62, 0x23, 0x60, 0x03, 0x40, 0x05, 0x41, 0x07, 0x00, 0x00, 0x51, 0x07, 0x00, 0x00, 0x40, 0x08, 
	0x64, 0x09, 0x00, 0x00, 0x00, 0xd7, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x03, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xbe, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 
	0x40, 0x01, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x40, 0x02, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x8b, 0x02, 0x60, 0x10, 0x60, 0x13, 0x60, 0x10, 0x40, 0x00, 0x00, 0x00, 0x60, 
	0x10, 0x40, 0x12, 0x00, 0x00, 0x00, 0x00, 0x60, 0x02, 0x02, 0x00, 0x50, 0x24, 0x40, 0x05, 0x42, 
	0x17, 0x40, 0x00, 0x61, 0x42, 0x00, 0x00, 0x40, 0x83, 0x00, 0x00, 0x40, 0x82, 0x40, 0x40, 0x00, 
	0x00, 0x40, 0xd7, 0x02, 0x40, 0x03, 0x22, 0x00, 0x48, 0x48, 0x00, 0x03, 0x00, 0x40, 0x40, 0x00, 
	0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x51, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x02, 0x01, 0x0b, 
	0x00, 0x04, 0x00, 0x04, 0x00, 0x20, 0x00, 0x0a, 0x00, 0x00, 0x40, 0x16, 0x10, 0x09, 0x00, 0x00, 
	0xc0, 0x96, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x8e, 0x02, 0xc0, 0x03, 0x40, 0x03, 0x40, 0x03, 0xc0, 0x03, 0x80, 0x00, 0x40, 0x00, 0x40, 0x03, 
	0x00, 0x00, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x03, 0x40, 0x02, 0x40, 0x03, 0x40, 0x02, 
	0x40, 0x00, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 0x80, 0x01, 0x40, 0x02, 0x00, 0x00, 0x40, 0xd2, 
	0x02, 0x40, 0x03, 0x00, 0x00, 0x10, 0x00, 0x62, 0x00, 0x40, 0x00, 0x10, 0x48, 0x00, 0x07, 0xc2, 
	0x00, 0x40, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x03, 0x01, 0x19, 0xe0, 0x13, 0x00, 0x41, 0x00, 
	0x00, 0xc2, 0x00, 0x10, 0x83, 0x00, 0x00, 0x40, 0x12, 0x00, 0x00, 0x01, 0x00, 0x40, 0xf7, 0x12, 
	0x50, 0x03, 0x48, 0x05, 0x42, 0x09, 0x42, 0x09, 0x00, 0x00, 0x42, 0x09, 0x42, 0x09, 0x40, 0x09, 
	0x00, 0x00, 0x48, 0x05, 0x00, 0x00, 0x68, 0x83, 0x40, 0x02, 0x64, 0x02, 0x44, 0x03, 0x41, 0x0b, 
	0x00, 0x40, 0x50, 0x07, 0x00, 0x00, 0x40, 0x44, 0x40, 0x00, 0x28, 0x06, 0x00, 0xd8, 0x00, 0x00, 
	0x03, 0x00, 0x02, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x01, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x8e, 0x00, 0x40, 0x03, 
	0x00, 0x01, 0x40, 0x01, 0x40, 0x01, 0x00, 0x00, 0x40, 0x01, 0x40, 0x01, 0x40, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x03, 0x40, 0x01, 0x00, 0x03, 0x40, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x40, 0x01, 0x00, 0xb8, 0x02, 0x40, 0x07, 0x62, 
	0x80, 0x60, 0x10, 0x60, 0x10, 0x00, 0x00, 0x60, 0x10, 0x50, 0x10, 0x40, 0x10, 0x00, 0x00, 0x60, 
	0x01, 0x01, 0x00, 0x40, 0x16, 0x50, 0x07, 0x41, 0x01, 0x60, 0x18, 0x60, 0x11, 0x00, 0x00, 0x40, 
	0x03, 0x04, 0x00, 0x40, 0x02, 0x54, 0x44, 0x40, 0x03, 0x44, 0xee, 0x02, 0x40, 0x43, 0x00, 0x08, 
	0x48, 0x04, 0x62, 0x00, 0x00, 0x40, 0x40, 0x08, 0x61, 0x00, 0x40, 0x00, 0x00, 0x00, 0x18, 0x04, 
	0x00, 0x00, 0x08, 0x00, 0x00, 0x0b, 0x40, 0x8a, 0x00, 0x04, 0x64, 0x04, 0x00, 0x20, 0x20, 0x02, 
	0x00, 0x00, 0x40, 0x0a, 0x00, 0x06, 0x42, 0x08, 0x40, 0xed, 0x02, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x8f, 0x02, 0x40, 0x00, 0x40, 0x01, 0x40, 0x03, 
	0x40, 0x03, 0x80, 0x00, 0x40, 0x00, 0xc0, 0x02, 0xc0, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
	0x40, 0x00, 0x40, 0x00, 0x00, 0x02, 0x40, 0x02, 0x40, 0x00, 0x80, 0x00, 0x40, 0x03, 0x00, 0x00, 
	0x00, 0x01, 0x40, 0x00, 0x40, 0x00, 0x40, 0x83, 0x06, 0x04, 0x00, 0x20, 0x20, 0x10, 0x20, 0x00, 
	0x08, 0x41, 0x00, 0x10, 0x40, 0x40, 0x05, 0x42, 0x05, 0x02, 0x00, 0x00, 0x11, 0x00, 0x00, 0x10, 
	0x0b, 0xc4, 0x00, 0xc1, 0x11, 0x10, 0x01, 0x02, 0x83, 0x40, 0x00, 0x00, 0x0b, 0x04, 0x00, 0xc0, 
	0x12, 0x00, 0x00, 0x24, 0x12, 0x40, 0xf9, 0x20, 0x50, 0x42, 0x40, 0x01, 0x42, 0x01, 0x42, 0x01, 
	0x00, 0x20, 0x50, 0x04, 0x64, 0x07, 0x48, 0x01, 0x00, 0x00, 0x42, 0x0b, 0x00, 0x80, 0x50, 0x09, 
	0x44, 0x03, 0x40, 0x00, 0x41, 0x03, 0x41, 0x03, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x40, 0x20, 
	0x40, 0x09, 0x00, 0x00, 0x80, 0xd8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x00, 0x9c, 0x00, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 
	0x40, 0x03, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x8e, 0x02, 0x40, 0x18, 0x50, 0x18, 0x60, 0x18, 0x60, 0x18, 0x00, 0x00, 0x40, 
	0x10, 0x40, 0x22, 0x50, 0x04, 0x02, 0x00, 0x60, 0x01, 0x01, 0x00, 0x40, 0x11, 0x60, 0x08, 0x42, 
	0x00, 0x60, 0x19, 0x60, 0x19, 0x00, 0x00, 0x40, 0x85, 0x00, 0x00, 0x40, 0x2a, 0x50, 0x20, 0x00, 
	0x00, 0xc0, 0x8c, 0x02, 0x42, 0x08, 0x64, 0x00, 0x48, 0x00, 0x62, 0x08, 0x00, 0x40, 0x00, 0x44, 
	0x00, 0x44, 0x50, 0x08, 0x00, 0x00, 0x44, 0x00, 0x00, 0x80, 0x00, 0x86, 0x00, 0x24, 0x50, 0x04, 
	0x64, 0x00, 0x64, 0x00, 0x00, 0x80, 0x10, 0x00, 0x00, 0x00, 0x40, 0x02, 0x22, 0x09, 0x00, 0x00, 
	0xc0, 0xcb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0x8c, 0x02, 0x40, 0x00, 0x40, 0x02, 0x40, 0x03, 0x40, 0x03, 0x00, 0x00, 0x40, 0x00, 0x40, 0x03, 
	0x40, 0x02, 0x80, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x40, 0x02, 0x40, 0x02, 0x00, 0x02, 0x40, 0x00, 
	0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0xc0, 0xcb, 
	0x02, 0x20, 0x03, 0x01, 0x05, 0x12, 0x08, 0x01, 0x00, 0x02, 0x00, 0x20, 0x21, 0x20, 0x03, 0x04, 
	0x00, 0x41, 0x00, 0x50, 0x48, 0x00, 0x00, 0x10, 0x13, 0xd0, 0x01, 0xc1, 0x12, 0x00, 0x0b, 0x01, 
	0x07, 0xc1, 0x00, 0x00, 0x8b, 0x00, 0x00, 0xc0, 0x1a, 0x00, 0x80, 0x00, 0x00, 0x40, 0x87, 0x00, 
	0x48, 0x4a, 0x40, 0x05, 0x42, 0x24, 0x50, 0x00, 0x00, 0x40, 0x50, 0x0a, 0x58, 0x2a, 0x40, 0x0b, 
	0x00, 0x00, 0x48, 0x01, 0x00, 0x00, 0x42, 0x08, 0x00, 0x00, 0x40, 0x20, 0x60, 0x0b, 0x48, 0x03, 
	0x00, 0x00, 0x54, 0x0b, 0x00, 0x00, 0x40, 0x04, 0x58, 0x05, 0x00, 0x00, 0xc0, 0x81, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9d, 0x00, 0x40, 0x03, 
	0x40, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 
	0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x03, 0x00, 0x03, 0x40, 0x03, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbb, 0x02, 0x50, 0x03, 0x51, 
	0x00, 0x64, 0x41, 0x40, 0x04, 0x01, 0x00, 0x40, 0x00, 0x44, 0x10, 0x50, 0x02, 0x02, 0x00, 0x50, 
	0x48, 0x00, 0x00, 0x50, 0x20, 0x00, 0x00, 0x40, 0x00, 0x40, 0x80, 0x50, 0x04, 0x02, 0x00, 0x40, 
	0x21, 0x00, 0x00, 0x40, 0x23, 0x40, 0x10, 0x00, 0x00, 0x00, 0xed, 0x22, 0x50, 0x41, 0x60, 0x00, 
	0x00, 0x47, 0x00, 0x0a, 0x00, 0x80, 0x20, 0x80, 0x00, 0x08, 0x00, 0x0b, 0x00, 0x00, 0x42, 0x00, 
	0x00, 0x00, 0x01, 0x08, 0x00, 0x00, 0x48, 0x04, 0x08, 0x04, 0x64, 0x08, 0x00, 0x80, 0x10, 0x00, 
	0x00, 0x00, 0x48, 0x40, 0x20, 0x08, 0x00, 0x00, 0xc0, 0xd4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x40, 0xfb, 0x02, 0x40, 0x01, 0x40, 0x02, 0x40, 0x03, 
	0xc0, 0x02, 0x00, 0x00, 0x40, 0x00, 0x40, 0x01, 0x40, 0x03, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
	0x40, 0x02, 0x00, 0x00, 0x00, 0x02, 0xc0, 0x02, 0x40, 0x02, 0x80, 0x00, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0x40, 0x00, 0x00, 0x00, 0x00, 0xc6, 0x02, 0x00, 0x07, 0x02, 0x05, 0x02, 0x03, 0x61, 
	0x13, 0xc0, 0x00, 0x00, 0x28, 0x10, 0x20, 0x00, 0x03, 0xc4, 0x00, 0x20, 0x09, 0x01, 0x00, 0x10, 
	0x03, 0x02, 0x00, 0xd0, 0x12, 0x60, 0x11, 0x00, 0x00, 0x42, 0x00, 0x40, 0x4b, 0x00, 0x00, 0xd0, 
	0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x90, 0x00, 0x42, 0x43, 0x40, 0x05, 0x68, 0x2a, 0x50, 0x07, 
	0x00, 0x20, 0x50, 0x00, 0x58, 0x01, 0x58, 0x03, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x61, 0x03, 
	0x00, 0x00, 0x40, 0x20, 0x40, 0x07, 0x58, 0x03, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x40, 0x00, 
	0x51, 0x01, 0x00, 0x00, 0x80, 0xbc, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x9d, 0x00, 0x00, 0x01, 0x40, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 
	0x40, 0x03, 0x00, 0x01, 0x40, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x8f, 0x02, 0x50, 0x09, 0x54, 0x80, 0x40, 0x21, 0x40, 0x01, 0x02, 0x00, 0x40, 
	0x0b, 0x44, 0x04, 0x42, 0x04, 0x02, 0x00, 0x40, 0x18, 0x00, 0x00, 0x40, 0x87, 0x00, 0x00, 0x40, 
	0x00, 0x50, 0x01, 0x48, 0x04, 0x02, 0x00, 0x40, 0x09, 0x02, 0x00, 0x40, 0x07, 0x42, 0x29, 0x00, 
	0x00, 0xc0, 0x96, 0x02, 0x00, 0x84, 0x40, 0x00, 0x08, 0x40, 0x00, 0x09, 0x00, 0x40, 0x00, 0x0a, 
	0x42, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x06, 0x00, 0x00, 0x58, 0x04, 
	0x08, 0x04, 0x64, 0x00, 0x00, 0x80, 0x10, 0x04, 0x00, 0x00, 0x58, 0x80, 0x20, 0x05, 0x00, 0x00, 
	0x40, 0xde, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x8e, 0x02, 0x40, 0x03, 0xc0, 0x02, 0x40, 0x00, 0x40, 0x00, 0x80, 0x00, 0x40, 0x02, 0x40, 0x00, 
	0x40, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x40, 0x02, 0x80, 0x00, 0x00, 0x02, 0xc0, 0x00, 
	0xc0, 0x02, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x40, 0xb1, 
	0x02, 0x00, 0x13, 0x60, 0x05, 0x22, 0x46, 0x20, 0x00, 0x41, 0x00, 0xe0, 0x23, 0xd0, 0x49, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x10, 0x03, 0x41, 0x00, 0xc0, 0x12, 0x60, 0x13, 0x40, 
	0x88, 0xc0, 0x00, 0x40, 0x03, 0x02, 0x00, 0xc0, 0x00, 0x40, 0x02, 0x02, 0x00, 0x40, 0xb4, 0x10, 
	0x50, 0x0b, 0x68, 0x01, 0x68, 0x41, 0x40, 0x03, 0x00, 0x40, 0x40, 0x8b, 0x40, 0x0b, 0x58, 0x07, 
	0x00, 0x40, 0x50, 0x03, 0x00, 0x00, 0x41, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x41, 0x0b, 
	0x00, 0x00, 0x41, 0x0b, 0x00, 0x00, 0x40, 0x00, 0x42, 0x25, 0x60, 0x03, 0xa2, 0xea, 0x00, 0x00, 
	0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x03, 0x00, 0xac, 0x00, 0x00, 0x03, 
	0x40, 0x00, 0x40, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xeb, 0x02, 0x40, 0x00, 0x42, 
	0x04, 0x42, 0x07, 0x62, 0x19, 0x00, 0x00, 0x60, 0x11, 0x50, 0x20, 0x40, 0x81, 0x00, 0x00, 0x40, 
	0x24, 0x00, 0x00, 0x50, 0x08, 0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x60, 0x01, 0x01, 0x00, 0x60, 
	0x11, 0x00, 0x00, 0x40, 0x87, 0x60, 0x80, 0x40, 0x04, 0xc1, 0xd1, 0x02, 0x02, 0x40, 0x40, 0x00, 
	0x48, 0x24, 0x10, 0x06, 0x00, 0x20, 0x10, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x64, 0x08, 0x00, 0x00, 0x04, 0x04, 
	0x00, 0x00, 0x68, 0x80, 0x00, 0x05, 0x00, 0x00, 0xe1, 0xb1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x40, 0xc8, 0x02, 0x40, 0x03, 0x40, 0x00, 0x40, 0x00, 
	0x40, 0x02, 0x80, 0x00, 0x40, 0x02, 0x40, 0x00, 0x40, 0x03, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
	0x80, 0x03, 0x40, 0x00, 0x40, 0x00, 0xc0, 0xcd, 0x02, 0x10, 0x03, 0xd0, 0x09, 0x14, 0x81, 0x00, 
	0x01, 0x42, 0x00, 0xc0, 0x01, 0x02, 0x00, 0x00, 0x0b, 0x02, 0x00, 0x00, 0x13, 0x00, 0x00, 0x10, 
	0x45, 0xc0, 0x00, 0xc0, 0x21, 0x40, 0x00, 0x40, 0x83, 0x00, 0x00, 0xe0, 0x10, 0x00, 0x00, 0x40, 
	0x00, 0x20, 0x00, 0x01, 0x00, 0x00, 0xfb, 0x02, 0x42, 0x03, 0x48, 0x01, 0x48, 0x01, 0x68, 0x03, 
	0x00, 0x00, 0x68, 0x43, 0x60, 0x03, 0x40, 0x03, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x44, 0x03, 
	0x40, 0x29, 0x60, 0x03, 0x40, 0x05, 0x48, 0x03, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x40, 0x07, 
	0x40, 0x43, 0x00, 0x05, 0x80, 0xe8, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x03, 0x00, 0x01, 0x00, 0xac, 0x00, 0x00, 0x01, 0x40, 0x00, 0x40, 0x00, 0x00, 0x03, 0x00, 0x00, 
	0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 0x40, 0x00, 0x00, 0x02, 
	0x40, 0x01, 0x00, 0x9f, 0x02, 0x50, 0x19, 0x60, 0x04, 0x62, 0x07, 0x42, 0x8b, 0x00, 0x00, 0x40, 
	0x07, 0x44, 0x09, 0x44, 0x84, 0x00, 0x00, 0x50, 0x19, 0x00, 0x00, 0x60, 0x04, 0x41, 0x00, 0x44, 
	0x17, 0x40, 0x00, 0x62, 0x04, 0x02, 0x00, 0x60, 0x4b, 0x00, 0x00, 0x40, 0x00, 0x42, 0x46, 0x50, 
	0x01, 0x44, 0xb7, 0x02, 0x00, 0x4a, 0x40, 0x00, 0x48, 0x28, 0x00, 0x04, 0x00, 0x80, 0x20, 0x02, 
	0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x08, 
	0x00, 0x04, 0x64, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x03, 0x00, 0x05, 0x48, 0x00, 
	0x40, 0x8a, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x02, 0x00, 0x01, 0x00, 
	0xbe, 0x02, 0x40, 0x02, 0xc0, 0x00, 0x40, 0x00, 0x40, 0x03, 0x00, 0x00, 0x40, 0x02, 0x40, 0x03, 
	0x40, 0x03, 0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 0x40, 0x01, 0x40, 0x02, 0xc0, 0x01, 0x40, 0x02, 
	0xc0, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x40, 0x03, 0x40, 0x00, 0x40, 0xc2, 
	0x06, 0x08, 0x41, 0x50, 0x29, 0x10, 0x01, 0xe4, 0x83, 0x00, 0x00, 0xc0, 0x0b, 0xc8, 0x13, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x14, 0x40, 0x00, 0xc0, 0x12, 0x00, 0x85, 0x40, 0x12, 0xc0, 0x41, 0x40, 
	0x08, 0x01, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x24, 0x04, 0x41, 0x97, 0x00, 
	0x48, 0x0b, 0x68, 0x06, 0x44, 0x01, 0x41, 0x07, 0x00, 0x00, 0x62, 0x01, 0x44, 0x01, 0x52, 0x0b, 
	0x00, 0x20, 0x50, 0x05, 0x00, 0x00, 0x48, 0x03, 0x44, 0x43, 0x20, 0x00, 0x41, 0x09, 0x41, 0x09, 
	0x00, 0x00, 0x48, 0x07, 0x00, 0x20, 0x60, 0x03, 0x40, 0x81, 0x40, 0x00, 0x80, 0xac, 0x00, 0x00, 
	0x03, 0x00, 0x01, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0xbe, 0x00, 0x00, 0x03, 
	0x00, 0x02, 0x40, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x03, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x40, 0x03, 0x40, 0x00, 0x00, 0x00, 0x40, 0x03, 0x40, 0x03, 0x00, 0x00, 
	0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xf8, 0x02, 0x50, 0x00, 0x44, 
	0x00, 0x64, 0x07, 0x62, 0x13, 0x00, 0x00, 0x40, 0x18, 0x60, 0x04, 0x42, 0x13, 0x00, 0x00, 0x40, 
	0x10, 0x00, 0x00, 0x60, 0x05, 0x62, 0x04, 0x01, 0x00, 0x60, 0x20, 0x60, 0x20, 0x00, 0x00, 0x60, 
	0x43, 0x00, 0x00, 0x40, 0x04, 0x41, 0x17, 0x60, 0x48, 0x40, 0xc7, 0x02, 0x02, 0x40, 0x00, 0x08, 
	0x48, 0x10, 0x20, 0x05, 0x00, 0x00, 0x08, 0x08, 0x42, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x54, 0x80, 0x60, 0x08, 0x00, 0x00, 0x44, 0x00, 0x44, 0x04, 0x00, 0x00, 0x28, 0x00, 
	0x00, 0x80, 0x20, 0x00, 0x00, 0x43, 0x20, 0x00, 0x40, 0x87, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 
	0x00, 0x40, 0x02, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 
	0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x03, 0x40, 0x03, 0x40, 0x00, 0x40, 0x00, 0x40, 
	0x00, 0x00, 0x00, 0x40, 0x03, 0x40, 0x00, 0x00, 0x8b, 0x02, 0x00, 0x03, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x03, 0x00, 0x00, 
	0x80, 0x00, 0x00, 0x02, 0x00, 0x01, 0x40, 0xd9, 0x02, 0x10, 0x03, 0x20, 0x20, 0x10, 0x89, 0x00, 
	0x03, 0xc2, 0x00, 0x20, 0x01, 0x11, 0x81, 0x00, 0x09, 0xc2, 0x00, 0x00, 0x14, 0x00, 0x00, 0xc0, 
	0x18, 0x00, 0x11, 0xc0, 0x24, 0xe0, 0x08, 0x21, 0x00, 0x44, 0x00, 0xc0, 0x07, 0x02, 0x00, 0x40, 
	0x04, 0x01, 0x09, 0x02, 0x86, 0xc0, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc1, 0x80, 0x00, 0x00, 0xc1, 0x80, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x92, 0x00, 0x48, 0x00, 0x08, 0x00, 0x88, 0x00, 0x08, 0x00, 0x00, 
	0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x48, 
	0x00, 0x01, 0x02, 0x08, 0x00, 0x08, 0x00, 0x40, 0x00, 0x08, 0x00, 0x40, 0x00, 0x08, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0x10, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x10, 0x80, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x08, 0x14, 
	0x01, 0x00, 0x80, 0xed, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0x00, 0x00, 0x10, 
	0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x83, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x20, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x10, 0x00, 
	0x80, 0x93, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x40, 0x08, 0x10, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 
	0xbd, 0x00, 0x00, 0x00, 0x40, 0x20, 0x10, 0x00, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xc1, 0x60, 0x00, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x00, 0x00, 0xe1, 
	0x00, 0x00, 0x00, 0x14, 0x80, 0x10, 0x00, 0x08, 0x00, 0x04, 0x00, 0x20, 0x00, 0x04, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xec, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x80, 0x00, 0x00, 
	0x01, 0x00, 0x20, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xad, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x04, 0x20, 0x80, 0x40, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x00, 0x01, 0x08, 0x00, 0x00, 0x00, 0x20, 0x00, 
	0x00, 0x00, 0x00, 0x10, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0x02, 0x10, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x80, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x06, 0x00, 0x0a, 0x00, 0x40, 
	0x10, 0x10, 0x00, 0x80, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x9b, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x08, 0x80, 0x40, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x08, 0x00, 
	0x20, 0x00, 0x00, 0x03, 0x00, 0x00, 0xc0, 0x08, 0x00, 0x00, 0x8b, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x84, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x08, 0x00, 0x00, 0x08, 
	0x60, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00, 0x80, 0xcf, 0x00, 0x00, 0x20, 0x02, 0x08, 0x00, 
	0x20, 0x00, 0x00, 0x00, 0x20, 0x00, 0x90, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x00, 0x00, 
	0x00, 0x04, 0x10, 0x00, 0x08, 0x00, 0x00, 0x00, 0xa9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x20, 0x00, 0x02, 0x00, 
	0x30, 0x00, 0x88, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xbc, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x00, 
	0x08, 0x00, 0x00, 0x40, 0x08, 0x00, 0x08, 0x21, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
	0x08, 0x00, 0x00, 0x00, 0x20, 0x80, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x04, 0x80, 
	0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x00, 0x02, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 0x40, 0x80, 0x04, 0x00, 0x20, 0x40, 
	0x00, 0x80, 0x00, 0x04, 0x81, 0x8f, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x40, 0x00, 0x20, 0x00, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x20, 0x80, 0x00, 
	0x02, 0x00, 0xc4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x40, 0x00, 0x80, 0x95, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x10, 0x00, 0x08, 0x80, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x10, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x80, 0x02, 0x00, 
	0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x80, 0x08, 0x00, 0x00, 
	0x02, 0x40, 0x40, 0x10, 0x04, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x40, 0x00, 0x20, 
	0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 
	0x00, 0x80, 0xf0, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x22, 
	0x00, 0x04, 0x10, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x60, 0x00, 0x00, 0x00, 0x40, 0x00, 0x82, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x02, 0x00, 
	0x80, 0xef, 0x00, 0x00, 0x00, 0x44, 0x10, 0x00, 0x40, 0x01, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 
	0x10, 0x54, 0x44, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x08, 0x00, 0x00, 0x00, 
	0xee, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x80, 0x00, 0x01, 0x00, 0x00, 0x00, 0x40, 0x00, 0x81, 0x10, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x08, 0x80, 0xaa, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x80, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x04, 0xac, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x20, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x20, 0x00, 0x08, 0x00, 0x00, 0x02, 0x08, 0x00, 0x00, 
	0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xda, 0x00, 0x10, 
	0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x08, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10, 
	0x00, 0x80, 0x08, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0xc8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x9e, 0x00, 0x00, 0x00, 
	0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x11, 0x02, 0x00, 0x24, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x01, 0x20, 0x10, 0x00, 
	0x00, 0x00, 0x40, 0x00, 0x20, 0x28, 0x02, 0x02, 0x00, 0x00, 0x80, 0x96, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x04, 
	0x08, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x09, 0xde, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x20, 0x00, 
	0x08, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x88, 0x00, 0x00, 0x20, 0x90, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 
	0x00, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x00, 0x04, 0x00, 0x00, 0x02, 0x00, 
	0x00, 0x01, 0x80, 0x10, 0x20, 0x00, 0x00, 0x80, 0xec, 0x00, 0x00, 0x10, 0x20, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x02, 0x80, 0x00, 
	0x00, 0x00, 0x20, 0x20, 0x00, 0x02, 0x00, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x80, 0xe9, 0x00, 0x04, 0x00, 0x14, 0x00, 0x04, 0x00, 0x06, 
	0x00, 0x00, 0x42, 0x04, 0x00, 0x00, 0x04, 0x44, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 
	0x82, 0x28, 0x00, 0x08, 0x00, 0xc8, 0x02, 0x08, 0x80, 0x04, 0x00, 0x08, 0x00, 0x04, 0x00, 0x40, 
	0x00, 0x08, 0x00, 0x08, 0x00, 0x84, 0xeb, 0x00, 0x61, 0x04, 0x00, 0x00, 0x64, 0x03, 0x48, 0x17, 
	0x60, 0x41, 0x40, 0x07, 0x41, 0x03, 0x64, 0x45, 0x40, 0x05, 0x40, 0x00, 0x00, 0x00, 0x48, 0x00, 
	0x00, 0x00, 0x41, 0x03, 0x00, 0x00, 0x68, 0x04, 0x44, 0x03, 0x00, 0x80, 0x60, 0x03, 0x24, 0x02, 
	0x51, 0x03, 0x00, 0x01, 0x00, 0xdf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 
	0x01, 0x00, 0x01, 0x00, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0x01, 
	0x00, 0x03, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x40, 0x03, 0x40, 0x01, 0x40, 0x03, 
	0x40, 0x00, 0x00, 0xfc, 0x02, 0x40, 0x00, 0x02, 0x00, 0x40, 0x04, 0x62, 0x12, 0x40, 0x04, 0x61, 
	0x01, 0x61, 0x8b, 0x40, 0x80, 0x50, 0x00, 0x41, 0x01, 0x00, 0x00, 0x50, 0x14, 0x00, 0x00, 0x60, 
	0x09, 0x02, 0x00, 0x40, 0x00, 0x62, 0x29, 0x00, 0x00, 0x40, 0x24, 0x40, 0x01, 0x40, 0x24, 0x40, 
	0x88, 0xc0, 0xc0, 0x02, 0x00, 0x06, 0x00, 0x00, 0x11, 0x03, 0x00, 0x24, 0x40, 0x10, 0x10, 0x80, 
	0x00, 0x04, 0x18, 0x05, 0x14, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x04, 0x02, 0x00, 0x00, 0x42, 0x00, 
	0x00, 0x00, 0x08, 0x41, 0x20, 0x02, 0x00, 0x80, 0x50, 0x00, 0x40, 0x00, 0x68, 0x00, 0x40, 0x00, 
	0xc0, 0xff, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x8f, 0x02, 0x40, 0x03, 0x00, 0x00, 0x40, 0x03, 0x40, 0x00, 0x40, 0x03, 0x40, 0x00, 0x40, 0x00, 
	0x40, 0x02, 0x40, 0x00, 0x00, 0x01, 0x80, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
	0x40, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x40, 0x02, 0x40, 0x02, 0x40, 0xc5, 
	0x02, 0xc0, 0x83, 0x00, 0x00, 0x00, 0x0b, 0x01, 0x00, 0x22, 0x25, 0xc0, 0x18, 0x10, 0x80, 0x00, 
	0x00, 0x04, 0x28, 0x00, 0x82, 0x40, 0x00, 0x60, 0x18, 0x00, 0x00, 0x10, 0x24, 0x00, 0x00, 0x20, 
	0x08, 0x44, 0x04, 0x01, 0x00, 0xc0, 0x89, 0x00, 0x24, 0x00, 0x85, 0x00, 0x05, 0xc1, 0xe1, 0x02, 
	0x58, 0x00, 0x00, 0x00, 0x48, 0x09, 0x44, 0x07, 0x58, 0x04, 0x44, 0x89, 0x40, 0x0b, 0x42, 0x05, 
	0x58, 0x03, 0x40, 0x00, 0x00, 0x00, 0x48, 0x03, 0x00, 0x00, 0x41, 0x01, 0x00, 0x00, 0x00, 0x00, 
	0x58, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x03, 0x51, 0x01, 0xa2, 0xc4, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0xaf, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x40, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x40, 0x03, 
	0x00, 0x00, 0x00, 0x00, 0x40, 0x01, 0x40, 0x03, 0x00, 0x01, 0x00, 0xfa, 0x02, 0x40, 0x03, 0x00, 
	0x00, 0x60, 0x23, 0x60, 0x00, 0x41, 0x12, 0x50, 0x00, 0x51, 0x80, 0x60, 0x21, 0x40, 0x04, 0x41, 
	0x01, 0x00, 0x00, 0x60, 0x15, 0x00, 0x00, 0x60, 0x08, 0x02, 0x00, 0x00, 0x00, 0x40, 0x87, 0x00, 
	0x00, 0x00, 0x00, 0x40, 0x01, 0x50, 0x14, 0x40, 0x05, 0xc1, 0xe0, 0x0a, 0x04, 0x00, 0x00, 0x00, 
	0x54, 0x08, 0x08, 0x04, 0x00, 0x00, 0x08, 0x04, 0x04, 0x00, 0x28, 0x81, 0x40, 0x04, 0x00, 0x0a, 
	0x00, 0x40, 0x60, 0x08, 0x00, 0x80, 0x50, 0x08, 0x00, 0x00, 0x00, 0x40, 0x60, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x64, 0x00, 0x68, 0x00, 0x08, 0x00, 0x42, 0x83, 0x02, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x40, 0xfb, 0x02, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 
	0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x02, 0x00, 0x01, 0x80, 0x00, 
	0x40, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xc0, 0x02, 0x40, 0x01, 0x40, 0xf4, 0x02, 0x14, 0x03, 0x00, 0x00, 0x00, 0x01, 0x24, 
	0x01, 0x04, 0x24, 0x10, 0x11, 0xd0, 0x49, 0x00, 0x1a, 0x20, 0x10, 0x00, 0x02, 0x42, 0x00, 0xc0, 
	0x43, 0x00, 0x00, 0x40, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 
	0x16, 0x40, 0x85, 0x20, 0x44, 0x90, 0xe2, 0x00, 0x61, 0x00, 0x00, 0x00, 0x54, 0x07, 0x41, 0x17, 
	0x60, 0x01, 0x68, 0x0b, 0x41, 0x03, 0x62, 0x02, 0x44, 0x0b, 0x40, 0x00, 0x00, 0x00, 0x44, 0x07, 
	0x00, 0x00, 0x41, 0x07, 0x00, 0x00, 0x40, 0x08, 0x68, 0x07, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 
	0x52, 0x07, 0x08, 0x0b, 0x00, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0xbe, 0x00, 0x00, 0x03, 0x00, 0x00, 0x40, 0x01, 0x40, 0x00, 0x40, 0x01, 
	0x00, 0x02, 0x40, 0x03, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x03, 
	0x40, 0x03, 0x00, 0x9c, 0x02, 0x40, 0x17, 0x00, 0x00, 0x40, 0x10, 0x60, 0x13, 0x40, 0x04, 0x41, 
	0x02, 0x61, 0x88, 0x40, 0x08, 0x64, 0x03, 0x44, 0x01, 0x00, 0x00, 0x60, 0x11, 0x00, 0x00, 0x60, 
	0x10, 0x00, 0x00, 0x40, 0x01, 0x42, 0x11, 0x00, 0x00, 0x00, 0x00, 0x40, 0x01, 0x40, 0x10, 0x50, 
	0x00, 0x48, 0xa1, 0x02, 0x24, 0x09, 0x00, 0x00, 0x41, 0x08, 0x48, 0x10, 0x50, 0x04, 0x00, 0x01, 
	0x44, 0x07, 0x08, 0x0a, 0x21, 0x02, 0x00, 0x0a, 0x00, 0x20, 0x40, 0x04, 0x00, 0x00, 0x40, 0x03, 
	0x00, 0x00, 0x00, 0x22, 0x40, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x68, 0x40, 0x50, 0x00, 
	0xc0, 0xa5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x9e, 0x02, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x03, 0xc0, 0x01, 0x40, 0x03, 
	0x40, 0x01, 0x40, 0x02, 0x00, 0x01, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 
	0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x02, 0x40, 0x02, 0xc0, 0xa6, 
	0x02, 0x00, 0x00, 0xc1, 0x00, 0x20, 0x23, 0x10, 0x03, 0x00, 0x11, 0x40, 0x06, 0x22, 0x83, 0x10, 
	0x40, 0x00, 0x87, 0x00, 0x02, 0x41, 0x00, 0x10, 0x03, 0x01, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x04, 0x11, 0x03, 0x01, 0x00, 0xc0, 0x00, 0x00, 0x0a, 0x04, 0x85, 0xc0, 0x05, 0xc1, 0x99, 0x00, 
	0x58, 0x00, 0x00, 0x00, 0x61, 0x08, 0x44, 0x07, 0x48, 0x13, 0x40, 0x0b, 0x62, 0x01, 0x61, 0x05, 
	0x42, 0x0a, 0x40, 0x00, 0x00, 0x80, 0x40, 0x0b, 0x00, 0x00, 0x41, 0x03, 0x00, 0x00, 0x40, 0x02, 
	0x68, 0x03, 0x00, 0x40, 0x40, 0x0b, 0x00, 0x00, 0x68, 0x29, 0x50, 0x05, 0x00, 0xa5, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x8f, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x40, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x40, 0x01, 
	0x00, 0x01, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x40, 0x01, 0x00, 0x03, 
	0x00, 0x00, 0x40, 0x03, 0x40, 0x01, 0x40, 0x03, 0x00, 0x00, 0x00, 0x9d, 0x02, 0x40, 0x04, 0x01, 
	0x00, 0x40, 0x10, 0x60, 0x00, 0x54, 0x03, 0x50, 0x03, 0x42, 0x08, 0x41, 0x40, 0x60, 0x13, 0x40, 
	0x01, 0x00, 0x00, 0x60, 0x11, 0x00, 0x00, 0x60, 0x09, 0x02, 0x00, 0x40, 0x01, 0x40, 0x29, 0x00, 
	0x00, 0x60, 0x10, 0x40, 0x01, 0x40, 0x13, 0x40, 0x80, 0xc0, 0xa7, 0x02, 0x04, 0x00, 0x00, 0x20, 
	0x40, 0x0a, 0x08, 0x00, 0x08, 0x00, 0x00, 0x88, 0x10, 0x08, 0x08, 0x45, 0x40, 0x00, 0x00, 0x02, 
	0x00, 0x20, 0x40, 0x04, 0x00, 0x00, 0x61, 0x08, 0x00, 0x00, 0x40, 0x4a, 0x20, 0x02, 0x00, 0x80, 
	0x50, 0x00, 0x64, 0x08, 0x40, 0x00, 0x24, 0x04, 0x40, 0xc7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xaf, 0x02, 0xc0, 0x00, 0x00, 0x00, 0x40, 0x02, 
	0x40, 0x00, 0x40, 0x00, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x40, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x80, 0x01, 0x40, 0x00, 0x80, 0x00, 0x40, 0x02, 
	0x00, 0x00, 0x40, 0x02, 0xc0, 0x00, 0x40, 0x9c, 0x02, 0x50, 0x03, 0x00, 0x00, 0x10, 0x03, 0x22, 
	0x00, 0x20, 0x03, 0x00, 0x21, 0x00, 0x01, 0x21, 0x00, 0x22, 0x24, 0x00, 0x2a, 0xc0, 0x00, 0xd0, 
	0x03, 0x01, 0x00, 0x40, 0x10, 0x00, 0x00, 0x40, 0x12, 0x00, 0x04, 0x41, 0x00, 0x00, 0x89, 0x00, 
	0x12, 0x00, 0x85, 0x40, 0x00, 0x41, 0x8d, 0x12, 0x40, 0x03, 0x00, 0x20, 0x60, 0x03, 0x40, 0x25, 
	0x60, 0x03, 0x68, 0x01, 0x68, 0x0a, 0x40, 0x02, 0x44, 0x03, 0x40, 0x01, 0x00, 0x00, 0x41, 0x01, 
	0x00, 0x00, 0x41, 0x03, 0x00, 0x00, 0x40, 0x00, 0x48, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x40, 0x03, 0x51, 0x03, 0x80, 0xcc, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x03, 0x00, 0x01, 0x00, 0x03, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x01, 0x00, 0x9c, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 
	0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 
	0x40, 0x01, 0x00, 0x00, 0x40, 0x01, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x40, 0x01, 0x40, 0x03, 
	0x40, 0x02, 0x00, 0x9b, 0x02, 0x50, 0x04, 0x01, 0x00, 0x40, 0x89, 0x40, 0x00, 0x44, 0x24, 0x40, 
	0x86, 0x40, 0x11, 0x40, 0x01, 0x60, 0x0b, 0x42, 0x00, 0x00, 0x00, 0x60, 0x09, 0x01, 0x00, 0x60, 
	0x09, 0x02, 0x00, 0x40, 0x01, 0x50, 0x23, 0x00, 0x00, 0x00, 0x00, 0x40, 0x01, 0x50, 0x18, 0x40, 
	0x18, 0xc0, 0xe2, 0x02, 0x40, 0x00, 0x00, 0x20, 0x10, 0x00, 0x00, 0x08, 0x04, 0x04, 0x00, 0x0b, 
	0x24, 0x00, 0x00, 0x02, 0x21, 0x41, 0x20, 0x02, 0x00, 0x40, 0x60, 0x02, 0x00, 0x80, 0x40, 0x00, 
	0x00, 0x00, 0x40, 0x42, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x68, 0x00, 0x41, 0x00, 
	0xc0, 0xcf, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 
	0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xbf, 0x02, 0xc0, 0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x02, 0x40, 0x00, 0x40, 0x03, 0x40, 0x01, 
	0x80, 0x01, 0xc0, 0x01, 0x00, 0x02, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0x40, 0x02, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x40, 0x02, 0x40, 0x02, 0x40, 0xb3, 
	0x06, 0x44, 0x00, 0xc0, 0x00, 0xc0, 0x0b, 0x04, 0x81, 0x20, 0x10, 0xc0, 0x13, 0x00, 0x27, 0x40, 
	0x06, 0x41, 0x4b, 0x00, 0x0a, 0xc1, 0x00, 0x00, 0x89, 0x00, 0x00, 0x50, 0x18, 0x00, 0x00, 0xc0, 
	0x1a, 0x00, 0x04, 0x01, 0x00, 0x40, 0x00, 0x00, 0x1a, 0x00, 0x85, 0x10, 0x29, 0xc0, 0x86, 0x00, 
	0x54, 0x05, 0x00, 0x00, 0x41, 0x08, 0x44, 0x43, 0x40, 0x04, 0x44, 0x03, 0x48, 0x07, 0x40, 0x00, 
	0x48, 0x03, 0x68, 0x03, 0x00, 0x00, 0x48, 0x03, 0x00, 0x00, 0x41, 0x01, 0x00, 0x00, 0x40, 0x40, 
	0x60, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x03, 0x40, 0x08, 0xa2, 0xe3, 0x00, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xbe, 0x00, 0x00, 0x01, 
	0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x40, 0x03, 0x40, 0x01, 0x00, 0x01, 0x00, 0xea, 0x02, 0x40, 0x01, 0x04, 
	0x00, 0x60, 0x13, 0x60, 0x24, 0x60, 0x12, 0x50, 0x07, 0x62, 0x40, 0x40, 0x01, 0x60, 0x04, 0x41, 
	0x08, 0x02, 0x00, 0x50, 0x45, 0x00, 0x00, 0x60, 0x08, 0x02, 0x00, 0x40, 0x00, 0x40, 0x18, 0x00, 
	0x00, 0x00, 0x00, 0x40, 0x00, 0x50, 0x29, 0x40, 0x01, 0xc8, 0x8c, 0x02, 0x00, 0x0a, 0x00, 0x00, 
	0x00, 0x00, 0x21, 0x04, 0x18, 0x11, 0x10, 0x00, 0x00, 0x00, 0x00, 0x02, 0x68, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x48, 0x04, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x48, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x48, 0x00, 0x68, 0x00, 0x00, 0x02, 0xc4, 0xc8, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x02, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x40, 0xdb, 0x02, 0x40, 0x00, 0x80, 0x00, 0x40, 0x00, 
	0x40, 0x01, 0x40, 0x00, 0x40, 0x03, 0x40, 0x00, 0x00, 0x01, 0x40, 0x00, 0xc0, 0x00, 0x00, 0x00, 
	0x40, 0x00, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x03, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x02, 0x40, 0x00, 0x40, 0x00, 0xc0, 0xeb, 0x02, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x04, 0x24, 0x00, 0x03, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x19, 0x40, 0x00, 0x00, 0x00, 0x20, 
	0x43, 0x40, 0x00, 0x10, 0x04, 0x01, 0x00, 0xd0, 0x00, 0x20, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x10, 
	0x08, 0x01, 0x87, 0x00, 0x04, 0x91, 0x82, 0x22, 0x40, 0x09, 0x00, 0x00, 0x48, 0x43, 0x50, 0x17, 
	0x40, 0x23, 0x60, 0x80, 0x50, 0x03, 0x40, 0x80, 0x40, 0x02, 0x58, 0x03, 0x00, 0x00, 0x61, 0x02, 
	0x00, 0x00, 0x58, 0x07, 0x00, 0x00, 0x40, 0x40, 0x60, 0x03, 0x00, 0x00, 0x40, 0x09, 0x00, 0x00, 
	0x58, 0x07, 0x44, 0x05, 0x80, 0xe3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x8f, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x03, 0x40, 0x03, 
	0x00, 0x02, 0x00, 0x02, 0x00, 0x01, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x40, 0x01, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x03, 0x40, 0x01, 
	0x00, 0x00, 0x00, 0xad, 0x02, 0x50, 0x10, 0x00, 0x00, 0x50, 0x04, 0x42, 0x13, 0x60, 0x04, 0x41, 
	0x0a, 0x44, 0x8b, 0x40, 0x01, 0x60, 0x15, 0x40, 0x04, 0x01, 0x00, 0x40, 0x24, 0x00, 0x00, 0x40, 
	0x41, 0x00, 0x00, 0x40, 0x00, 0x40, 0x14, 0x00, 0x00, 0x40, 0x00, 0x44, 0x00, 0x40, 0x41, 0x50, 
	0x20, 0x40, 0x9d, 0x22, 0x50, 0x04, 0x00, 0x00, 0x11, 0x00, 0x21, 0x05, 0x58, 0x04, 0x04, 0x83, 
	0x00, 0x07, 0x00, 0x02, 0x00, 0x02, 0x48, 0x04, 0x00, 0x00, 0x11, 0x08, 0x00, 0x00, 0x41, 0x04, 
	0x00, 0x00, 0x58, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x04, 0x58, 0x00, 0x68, 0x00, 0x02, 0x00, 
	0xc0, 0xc1, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x03, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x8d, 0x02, 0x40, 0x03, 0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 0xc0, 0x01, 0x40, 0x03, 0x40, 0x03, 
	0x80, 0x01, 0x40, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 0x40, 0x00, 0x80, 0x00, 
	0x80, 0x03, 0x40, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x02, 0xc0, 0x00, 0x40, 0x00, 0xc0, 0x91, 
	0x06, 0x08, 0x23, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x44, 0x02, 0xe4, 0x89, 0x10, 0x83, 0x40, 
	0x8a, 0x00, 0x24, 0x50, 0x03, 0x04, 0x00, 0x00, 0x00, 0x44, 0x00, 0x20, 0x02, 0x42, 0x00, 0x40, 
	0x00, 0xe0, 0x2a, 0x00, 0x00, 0x00, 0x21, 0x00, 0x08, 0x41, 0x87, 0xe0, 0x04, 0xc4, 0xae, 0x00, 
	0x68, 0x03, 0x00, 0x00, 0x44, 0x07, 0x61, 0x47, 0x40, 0x13, 0x40, 0x00, 0x41, 0x03, 0x40, 0x80, 
	0x40, 0x00, 0x52, 0x09, 0x00, 0x00, 0x41, 0x04, 0x00, 0x00, 0x48, 0x08, 0x00, 0x00, 0x40, 0x40, 
	0x60, 0x05, 0x00, 0x00, 0x68, 0x0b, 0x00, 0x20, 0x60, 0x02, 0x68, 0x07, 0x22, 0xbb, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0xbe, 0x00, 0x40, 0x03, 
	0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x40, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x03, 0x40, 0x01, 
	0x00, 0x00, 0x40, 0x01, 0x40, 0x03, 0x00, 0x00, 0x40, 0x01, 0x00, 0xed, 0x02, 0x40, 0x26, 0x00, 
	0x00, 0x60, 0x80, 0x40, 0x01, 0x52, 0x25, 0x60, 0x09, 0x62, 0x18, 0x40, 0x01, 0x60, 0x84, 0x40, 
	0x10, 0x00, 0x00, 0x60, 0x00, 0x04, 0x00, 0x50, 0x10, 0x00, 0x00, 0x40, 0x00, 0x40, 0x01, 0x02, 
	0x00, 0x40, 0x01, 0x41, 0x00, 0x40, 0x04, 0x41, 0x41, 0x40, 0x93, 0x02, 0x61, 0x01, 0x00, 0x00, 
	0x02, 0x80, 0x00, 0x08, 0x11, 0x04, 0x00, 0x06, 0x40, 0x00, 0x00, 0x0a, 0x00, 0x03, 0x08, 0x04, 
	0x00, 0x00, 0x18, 0x08, 0x00, 0x80, 0x10, 0x01, 0x00, 0x00, 0x68, 0x00, 0x41, 0x0a, 0x00, 0x80, 
	0x50, 0x00, 0x68, 0x00, 0x00, 0x04, 0x41, 0x00, 0x64, 0x81, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x40, 0xda, 0x02, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 
	0x40, 0x00, 0xc0, 0x00, 0x40, 0x02, 0x40, 0x00, 0x00, 0x01, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 
	0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 0x00, 0x03, 0x40, 0x02, 0x00, 0x00, 0xc0, 0x00, 
	0x00, 0x02, 0x40, 0x00, 0xc0, 0x00, 0xc0, 0xa0, 0x02, 0xc0, 0x08, 0x01, 0x00, 0x10, 0x03, 0x10, 
	0x03, 0x48, 0x13, 0x00, 0x81, 0x00, 0x00, 0x00, 0x02, 0x02, 0x00, 0xe0, 0x20, 0x00, 0x00, 0x00, 
	0x80, 0xc0, 0x00, 0x00, 0x18, 0x40, 0x00, 0xc0, 0x00, 0x20, 0x13, 0x00, 0x00, 0x40, 0x8b, 0x00, 
	0x08, 0x01, 0x00, 0x52, 0x2a, 0x00, 0xcc, 0x02, 0x48, 0x03, 0x00, 0x00, 0x41, 0x03, 0x41, 0x07, 
	0x54, 0x03, 0x48, 0x08, 0x48, 0x0b, 0x40, 0x00, 0x48, 0x40, 0x50, 0x01, 0x00, 0x00, 0x41, 0x00, 
	0x00, 0x00, 0x44, 0x01, 0x00, 0x00, 0x40, 0x00, 0x44, 0x01, 0x00, 0x00, 0x40, 0x09, 0x00, 0x00, 
	0x48, 0x07, 0x52, 0x00, 0x00, 0xd0, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0xac, 0x00, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 
	0x00, 0x00, 0x40, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x03, 0x40, 0x01, 
	0x00, 0x00, 0x00, 0xbf, 0x02, 0x60, 0x25, 0x00, 0x00, 0x60, 0x14, 0x60, 0x13, 0x40, 0x25, 0x50, 
	0x10, 0x50, 0x43, 0x40, 0x00, 0x50, 0x24, 0x40, 0x19, 0x00, 0x00, 0x60, 0x28, 0x00, 0x00, 0x50, 
	0x24, 0x00, 0x00, 0x40, 0x03, 0x60, 0x18, 0x00, 0x00, 0x40, 0x00, 0x44, 0x03, 0x60, 0x01, 0x41, 
	0x00, 0x40, 0xe9, 0x06, 0x61, 0x02, 0x00, 0x00, 0x00, 0x03, 0x28, 0x80, 0x00, 0x04, 0x28, 0x00, 
	0x54, 0x4b, 0x00, 0x80, 0x00, 0x00, 0x22, 0x05, 0x00, 0x40, 0x20, 0x00, 0x00, 0x00, 0x04, 0x00, 
	0x00, 0x00, 0x40, 0x03, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x68, 0x40, 0x00, 0x03, 
	0xc0, 0x9f, 0x02, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xbf, 0x02, 0x40, 0x00, 0x00, 0x00, 0x40, 0x03, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0xc0, 0x00, 
	0x00, 0x03, 0x40, 0x03, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 0x40, 0x02, 0x00, 0x00, 0x40, 0x00, 0x40, 0x03, 0x40, 0xa8, 
	0x02, 0x08, 0x08, 0xc1, 0x00, 0x00, 0x03, 0x00, 0x18, 0x20, 0x13, 0xc0, 0x86, 0x40, 0x22, 0x20, 
	0x00, 0xe0, 0x03, 0x00, 0x12, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x60, 0x28, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x14, 0x40, 0x00, 0xc0, 0x09, 0x01, 0x08, 0x01, 0x87, 0x20, 0x00, 0xc0, 0xc7, 0x00, 
	0x44, 0x03, 0x00, 0x00, 0x54, 0x48, 0x50, 0x87, 0x40, 0x03, 0x41, 0x43, 0x40, 0x04, 0x52, 0x09, 
	0x40, 0x08, 0x44, 0x0a, 0x00, 0x00, 0x44, 0x03, 0x00, 0x00, 0x41, 0x01, 0x00, 0x40, 0x20, 0x40, 
	0x60, 0x01, 0x00, 0x00, 0x40, 0x09, 0x01, 0x02, 0x44, 0x03, 0x54, 0x04, 0x00, 0xfe, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0xae, 0x00, 0x40, 0x03, 
	0x00, 0x00, 0x40, 0x03, 0x00, 0x03, 0x40, 0x03, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0x40, 0x03, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x40, 0x01, 
	0x00, 0x00, 0x00, 0x00, 0x40, 0x01, 0x40, 0x01, 0x00, 0x01, 0x00, 0x8c, 0x02, 0x60, 0x07, 0x01, 
	0x00, 0x40, 0x22, 0x40, 0x13, 0x50, 0x8b, 0x60, 0x08, 0x51, 0x10, 0x40, 0x10, 0x40, 0x11, 0x60, 
	0x00, 0x04, 0x00, 0x60, 0x05, 0x01, 0x00, 0x60, 0x08, 0x02, 0x00, 0x00, 0x00, 0x40, 0x09, 0x02, 
	0x00, 0x40, 0x00, 0x64, 0x05, 0x61, 0x49, 0x40, 0x11, 0xc0, 0xfc, 0x02, 0x44, 0x07, 0x00, 0x00, 
	0x44, 0x01, 0x00, 0x06, 0x44, 0x00, 0x44, 0x24, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0a, 0x41, 0x08, 
	0x00, 0x00, 0x48, 0x04, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x04, 0x41, 0x02, 0x00, 0x00, 
	0x00, 0x44, 0x60, 0x00, 0x68, 0x84, 0x00, 0x00, 0xc0, 0xa2, 0x00, 0x40, 0x03, 0x40, 0x00, 0x40, 
	0x03, 0x40, 0x01, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x01, 0x40, 0x00, 0x40, 
	0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x01, 0x40, 0x00, 0x40, 
	0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 0x00, 0xd9, 0x02, 0x00, 0x00, 0x80, 0x00, 0x00, 0x01, 
	0x00, 0x03, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xd1, 0x02, 0x10, 0x11, 0x40, 0x00, 0x20, 0x07, 0x01, 
	0x03, 0x12, 0x04, 0x21, 0x40, 0x10, 0x25, 0x50, 0x24, 0x00, 0x80, 0x60, 0x21, 0x00, 0x00, 0xe0, 
	0x43, 0xc0, 0x00, 0xe0, 0x04, 0xc2, 0x00, 0x00, 0x10, 0x20, 0x27, 0x00, 0x00, 0x00, 0x01, 0x01, 
	0x24, 0x00, 0x03, 0xd2, 0x88, 0xc0, 0xe4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0xe7, 0x00, 0x08, 0x00, 0xc0, 0x00, 0xc8, 0x00, 0x88, 0x00, 0x08, 
	0x00, 0x08, 0x00, 0x48, 0x00, 0x80, 0x00, 0x88, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x40, 
	0x00, 0x08, 0x02, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 
	0x00, 0x08, 0x00, 0x80, 0xdd, 0x00, 0x02, 0x00, 0x80, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x04, 0x80, 0x08, 0x00, 0x10, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x08, 0x00, 0x80, 0x10, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x10, 0x00, 0x00, 0x00, 
	0x48, 0x10, 0x00, 0xfe, 0x00, 0x00, 0x02, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xac, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x20, 0x00, 0x01, 0xc0, 0x00, 0x00, 
	0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x80, 
	0x80, 0xf3, 0x00, 0x10, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x50, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x11, 0x28, 0x10, 0x00, 0x80, 
	0xd6, 0x00, 0x00, 0x00, 0x80, 0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x84, 0x00, 0x00, 
	0x00, 0x04, 0x80, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x41, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x84, 
	0x00, 0x00, 0x00, 0x02, 0x00, 0x80, 0x00, 0x02, 0x14, 0x00, 0x00, 0x40, 0x40, 0x00, 0x04, 0x00, 
	0x08, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0xb9, 0x00, 
	0x20, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x20, 0x40, 0x00, 0x80, 0x01, 0x40, 0x00, 0x00, 
	0x02, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x48, 
	0x00, 0x00, 0x40, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 0x80, 0xd5, 0x00, 0x40, 0x00, 
	0x00, 0x00, 0x40, 0x02, 0x20, 0x40, 0x00, 0x0c, 0x80, 0x10, 0x20, 0x00, 0x10, 0x00, 0x00, 0x00, 
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x80, 0x00, 0x00, 0x02, 0x00, 0x20, 0x00, 0x04, 0x0c, 0x00, 0xba, 0x08, 0x00, 0x00, 0x00, 
	0x08, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x02, 0x40, 0x01, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x82, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x20, 0xf9, 0x00, 0x20, 0x00, 0x00, 0x00, 
	0x00, 0x04, 0x01, 0x00, 0x00, 0x00, 0x30, 0x80, 0x40, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x0c, 0x00, 0x00, 0x60, 0x10, 0x80, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 
	0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x42, 0x00, 0x00, 0x00, 0x00, 0x44, 
	0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
	0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0xb3, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x8a, 0x00, 0x30, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x40, 0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x90, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x04, 
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x80, 0xcf, 0x00, 0x00, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x12, 0x00, 0x00, 0x00, 
	0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x05, 0x00, 0xc0, 0x98, 0x00, 0x60, 0x00, 0x04, 0x00, 0x00, 0x00, 0x08, 0x00, 
	0x00, 0x00, 0x11, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 
	0x00, 0x00, 0x02, 0x80, 0x00, 0xd2, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x80, 0x00, 0x00, 0x00, 0x02, 0x00, 0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x08, 0x00, 
	0x90, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x21, 
	0x00, 0x00, 0x00, 0x00, 0x87, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x80, 0x00, 0x00, 0x05, 0x00, 
	0x10, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 
	0x00, 0x20, 0x80, 0xcf, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x40, 0x40, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x04, 0x00, 0x00, 0x00, 0x10, 0x00, 0x40, 0x00, 0x00, 0x00, 
	0x02, 0x20, 0xd0, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x20, 0x00, 0x02, 0x20, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x40, 0x40, 0x04, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x18, 0x00, 0x00, 
	0x81, 0xa1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x04, 0x00, 0x00, 
	0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x14, 0x02, 0x04, 0x00, 
	0xfa, 0x02, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x01, 0x00, 0x80, 0x00, 0x00, 0x80, 
	0x00, 0x20, 0x94, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 
	0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x02, 0x40, 0x00, 0x04, 0x00, 0x9a, 
	0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x22, 0x04, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x10, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x08, 0x00, 0x04, 0x00, 0x00, 0x04, 0xc2, 0x00, 
	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x10, 0x00, 0x00, 0x08, 0x10, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0c, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x04, 
	0x02, 0x00, 0x00, 0x00, 0x10, 0x40, 0x00, 0x00, 0x10, 0x28, 0x10, 0x00, 0xa0, 0xc6, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x20, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x04, 0x00, 0x80, 0x00, 0x48, 0x00, 0x02, 0x00, 0xc0, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc5, 0x00, 0x00, 0x00, 
	0x00, 0x80, 0x20, 0x28, 0x10, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x20, 0x40, 0x10, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x20, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x20, 0x00, 0x00, 
	0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x89, 0x9c, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x10, 0x04, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 
	0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x04, 0x02, 0x00, 0x28, 0x00, 0x00, 0x40, 0x80, 0xb4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x04, 0x10, 0x00, 0x00, 0x80, 0x00, 0x01, 0x00, 0x00, 0x08, 0x00, 0x80, 0x12, 
	0x20, 0x80, 0x42, 0x00, 0x00, 0x10, 0x00, 0x08, 0x00, 0x00, 0x80, 0x00, 0x00, 0x14, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x80, 0xb3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x40, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x10, 0x02, 0x80, 0xf8, 0x00, 0x40, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 
	0x00, 0x00, 0x00, 0x08, 0x00, 0x09, 0x00, 0x00, 0x00, 0x04, 0x00, 0x18, 0x0a, 0x48, 0x10, 0x08, 
	0x10, 0x00, 0x00, 0x08, 0x00, 0x20, 0x02, 0x00, 0x10, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 
	0x02, 0x80, 0x00, 0x48, 0x20, 0x04, 0xcf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x22, 0x9c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x9e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x9e, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x40, 0xfa, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x54, 0xab, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0xda, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xfa, 
	0x02, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb2, 0x80, 
	0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x0a, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xe3, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9c, 0x00, 0x40, 0x01, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcc, 0x8a, 0x60, 0x14, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x03, 0x04, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xd4, 0x82, 0x50, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xa1, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0x02, 0x40, 0x03, 0x00, 0x00, 0x80, 0x00, 
	0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xcd, 0x08, 0x02, 0x07, 0x01, 0x00, 0x40, 0x00, 0x00, 
	0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x40, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x9b, 0x40, 0x50, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xa2, 0xb7, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xbc, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xbd, 0x02, 0x40, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x40, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x40, 0xbd, 0x02, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0xc0, 0xe7, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0xf8, 0x02, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xfe, 
	0x02, 0x00, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x9e, 0x20, 
	0x60, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x08, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xba, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbc, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbc, 0x8a, 0x40, 0x02, 0x04, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x43, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xc6, 0x06, 0x00, 0x09, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xc9, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9c, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xfe, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xd5, 0x00, 0x41, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x60, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x40, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x22, 0xe6, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xad, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x88, 0x8a, 0x60, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x40, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x03, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0xc0, 0xa6, 0x42, 0x40, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x20, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0xe0, 0x9b, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0xf9, 0x02, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x80, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x81, 
	0x04, 0x28, 0x10, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 
	0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x40, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd7, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x50, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9e, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9e, 0x02, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x08, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x94, 0x02, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x03, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xa8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9e, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xbe, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xbe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x42, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x22, 0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x9d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x9d, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x40, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 
	0x03, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x40, 0xd7, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x80, 0x10, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x08, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x41, 0xf7, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0xf9, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x40, 0x02, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xf8, 
	0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 
	0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x21, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xa3, 0x00, 
	0x68, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x01, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x0b, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xcf, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xad, 0x00, 0x40, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x02, 0x40, 0x07, 0x01, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x07, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xfb, 0x42, 0x40, 0x04, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x10, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xe5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9d, 0x02, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xb2, 0x02, 0x20, 0x11, 0x00, 0x00, 0x40, 0x00, 0x00, 
	0x00, 0xc0, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x10, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0xc0, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xef, 0x00, 0x68, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x61, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xfb, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x8f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x9e, 0x02, 0x40, 0x09, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x60, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x40, 0xb9, 0x82, 0x20, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x80, 0x20, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xc0, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x9e, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xba, 
	0x02, 0x00, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x19, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xc5, 0x22, 
	0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x03, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x03, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xe3, 0x00, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x00, 0x00, 0x03, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xae, 0x00, 0x50, 0x18, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x85, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x08, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe8, 0x80, 0x20, 0x04, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x20, 0x04, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x94, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 
	0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 
	0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 
	0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x00, 0xde, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb6, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x00, 0x00, 0x00, 0x10, 0x19, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xdd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x9e, 0x00, 0x08, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x80, 0x00, 0x40, 0x00, 0x08, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x40, 0x00, 0x00, 0x02, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x80, 0x9c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x9e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x9e, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 
	0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0xae, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x9e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9e, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xda, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xac, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd8, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x87, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xda, 0x00, 0x00, 0x02, 0x41, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x40, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xbb, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xae, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x10, 0x00, 0x9d, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x80, 0x8f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 
	0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x08, 0xde, 0x00, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 
	0x00, 0x00, 0x12, 0x00, 0x40, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x80, 0xa1, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0xfe, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x88, 
	0xa1, 0x40, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x80, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xba, 0x20, 
	0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9e, 0x20, 0x00, 
	0x00, 0x10, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb4, 0x08, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x20, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x96, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9e, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x20, 0xbc, 0x80, 0x10, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xda, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xd8, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x00, 0x00, 0x10, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdb, 0x02, 0x00, 0x00, 0x44, 0x02, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x40, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x9d, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x9c, 0x00, 0x00, 0x00, 0x50, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xdc, 0x00, 0x00, 0x00, 0x02, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0xb6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x9e, 0x00, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd9, 
	0x00, 0x00, 0x00, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9c, 0x00, 
	0x00, 0x80, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x01, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9c, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9d, 0x02, 0x00, 0x00, 0x50, 
	0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x18, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xb8, 0x02, 0x00, 0x40, 0x00, 0x04, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9d, 0x02, 0x00, 0x00, 0x40, 0x02, 0x80, 0x00, 
	0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xf2, 0x02, 0x00, 0x00, 0x10, 0x03, 0x41, 0x00, 0x00, 
	0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x41, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xa9, 0x00, 0x00, 0x00, 0x44, 0x07, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x50, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x22, 0xca, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x9d, 0x00, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xd9, 0x02, 0x00, 0x00, 0x50, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x40, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0xc0, 0xf7, 0x02, 0x00, 0x00, 0x42, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x54, 0xc3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0xd9, 0x02, 0x00, 0x00, 0xc0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xf9, 
	0x02, 0x00, 0x00, 0x50, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 
	0x07, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf2, 0x00, 
	0x00, 0x00, 0x48, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x09, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9e, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd8, 0x8a, 0x00, 0x00, 0x50, 
	0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xe0, 0x02, 0x00, 0x40, 0x00, 0x04, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x60, 0x08, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x96, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0x02, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xfb, 0x44, 0x00, 0x00, 0x10, 0x03, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x00, 0xc0, 0x00, 0x00, 0x00, 0xc0, 0xf3, 0x00, 0x00, 0x00, 0x52, 0x01, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x50, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xba, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x9c, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x9f, 0x02, 0x00, 0x00, 0x40, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x40, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x40, 0xfa, 0x02, 0x00, 0x20, 0x60, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x52, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x40, 0xe9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x9e, 0x02, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 
	0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xf3, 
	0x02, 0x00, 0x00, 0x00, 0x10, 0xc0, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x84, 0x00, 
	0x00, 0x40, 0x60, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x50, 0x03, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xae, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9e, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9e, 0x8a, 0x00, 0x00, 0x40, 
	0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xa1, 0x06, 0x00, 0x00, 0x02, 0x08, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xb3, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0x02, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xf0, 0x00, 0x01, 0x00, 0x20, 0x22, 0x00, 0x00, 0x00, 
	0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x07, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xaf, 0x00, 0x00, 0x00, 0x58, 0x09, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x50, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x44, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x22, 0xea, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xae, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xe9, 0x02, 0x00, 0x00, 0x40, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x40, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x50, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x40, 0x8b, 0x02, 0x00, 0x20, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x40, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x60, 0x96, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0xf9, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x03, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xcd, 
	0x02, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 
	0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x0b, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xd4, 0x00, 
	0x00, 0x00, 0x68, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x0b, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x03, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe2, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xaf, 0x00, 0x00, 0x00, 
	0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xad, 0x8a, 0x00, 0x00, 0x40, 
	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xbb, 0x0a, 0x00, 0x00, 0x42, 0x04, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x04, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xd0, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9f, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xc6, 0x00, 0x01, 0x00, 0x10, 0x01, 0x04, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x10, 0x21, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x8d, 0x00, 0x00, 0x00, 0x62, 0x03, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x44, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x22, 0x84, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xae, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xae, 0x02, 0x00, 0x00, 0x40, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x50, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0xc0, 0xb7, 0x02, 0x00, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x80, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 
	0x40, 0xb6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0xfa, 0x02, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x03, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xce, 
	0x02, 0x00, 0x00, 0x00, 0x88, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x10, 0xd5, 0x00, 
	0x00, 0x00, 0x58, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x03, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x0b, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x99, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xae, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9e, 0x8a, 0x00, 0x00, 0x40, 
	0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x29, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xbc, 0x06, 0x00, 0x80, 0x20, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xb2, 0x02, 0x40, 0x00, 0x40, 0x00, 0x40, 
	0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 
	0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 
	0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x00, 0xfe, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x40, 0xca, 0x20, 0x00, 0x00, 0x00, 0x8b, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x40, 0x00, 0x00, 0x00, 0xc0, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x9e, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x02, 0x00, 0x00, 0x80, 0x00, 0x08, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xd6, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xda, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x9e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x8f, 0x04, 0x00, 0x20, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0xd0, 0x00, 0x00, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x08, 
	0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0xb0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x80, 0x9f, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x04, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9e, 0x00, 0x00, 0x00, 
	0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x82, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xcb, 0x00, 0x00, 0x00, 0x05, 0x02, 
	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x04, 0x06, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xaf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9e, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x10, 0xdd, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x80, 0xde, 0x02, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 
	0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xee, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x8f, 0x10, 0x00, 0x00, 0x20, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x80, 0xe0, 0x20, 0x00, 0x00, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 
	0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xf6, 0x40, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd2, 
	0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
	0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x40, 0x02, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xde, 0x10, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x82, 0xa7, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0xdc, 0x00, 0x00, 0x04, 
	0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x20, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0xf2, 0x00, 0x00, 0x02, 0x20, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xba, 0x12, 0x00, 0x00, 0x10, 0x08, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb6, 0x00, 0x02, 0x00, 0x84, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xd8, 0x02, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8d, 0x00, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x13, 
	0x40, 0x03, 0x41, 0x03, 0x41, 0x03, 0x61, 0x03, 0x68, 0x0b, 0x40, 0x47, 0x50, 0x03, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x41, 0x03, 0x41, 0x03, 0x00, 0x00, 0x42, 0x04, 0x00, 0x80, 0x50, 0x02, 
	0x00, 0x00, 0x44, 0x05, 0x00, 0xeb, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x03, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x8e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x40, 0x03, 
	0x40, 0x02, 0x40, 0x02, 0x00, 0x01, 0x40, 0x03, 0x00, 0x02, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x40, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x99, 0x02, 0x60, 0x29, 0x00, 0x00, 0x00, 0x00, 0x60, 0x08, 0x54, 0x14, 0x60, 
	0x24, 0x60, 0x24, 0x40, 0x15, 0x40, 0x23, 0x40, 0x22, 0x40, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x60, 0x24, 0x60, 0x25, 0x00, 0x00, 0x50, 0x20, 0x00, 0x00, 0x40, 0x1b, 0x00, 0x00, 0x60, 
	0x11, 0x40, 0xb6, 0x22, 0x10, 0x02, 0x00, 0x00, 0x00, 0x20, 0x20, 0x08, 0x68, 0x00, 0x51, 0x00, 
	0x51, 0x84, 0x20, 0x00, 0x40, 0x00, 0x00, 0x81, 0x50, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x42, 0x00, 0x44, 0x08, 0x00, 0x00, 0x04, 0x03, 0x00, 0x00, 0x02, 0x0b, 0x00, 0x00, 0x22, 0x04, 
	0xc0, 0xb6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xbd, 0x02, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x40, 0x00, 0x40, 0x02, 0x40, 0x02, 
	0x40, 0x00, 0x40, 0x02, 0x40, 0x03, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 
	0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 0x40, 0x00, 0x40, 0xd9, 
	0x02, 0x00, 0x8b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x03, 0x00, 0x45, 0x00, 0x21, 0x00, 
	0x1b, 0x00, 0x09, 0x02, 0x07, 0x01, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x09, 0x28, 
	0x23, 0x00, 0x00, 0xd0, 0x00, 0x00, 0x00, 0x20, 0x13, 0x00, 0x00, 0x00, 0x40, 0xc0, 0xab, 0x00, 
	0x42, 0x08, 0x00, 0x00, 0x00, 0x00, 0x48, 0x27, 0x40, 0x03, 0x58, 0x05, 0x41, 0x03, 0x41, 0x0a, 
	0x44, 0x03, 0x48, 0x45, 0x50, 0x03, 0x00, 0x00, 0x44, 0x0b, 0x00, 0x00, 0x41, 0x83, 0x40, 0x03, 
	0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x20, 0x50, 0x08, 0x00, 0xea, 0x00, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x03, 0x00, 
	0x03, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xaf, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x40, 0x03, 0x40, 0x03, 0x40, 0x00, 0x40, 0x02, 0x00, 0x03, 0x40, 0x03, 
	0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x40, 0x01, 0x00, 0x00, 
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xeb, 0x46, 0x60, 0x21, 0x00, 
	0x00, 0x00, 0x00, 0x50, 0x03, 0x52, 0x08, 0x44, 0x00, 0x62, 0x14, 0x60, 0x23, 0x60, 0x2b, 0x60, 
	0x80, 0x40, 0x14, 0x00, 0x00, 0x50, 0x10, 0x00, 0x00, 0x60, 0x14, 0x60, 0x15, 0x00, 0x00, 0x40, 
	0x1a, 0x00, 0x00, 0x40, 0x18, 0x00, 0x00, 0x40, 0x10, 0x40, 0x87, 0x22, 0x10, 0x0a, 0x00, 0x00, 
	0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x41, 0x44, 0x20, 0x00, 0x40, 0x00, 0x00, 0x82, 
	0x50, 0x04, 0x00, 0x00, 0x02, 0x05, 0x00, 0x00, 0x42, 0x00, 0x44, 0x08, 0x00, 0x00, 0x00, 0x09, 
	0x00, 0x40, 0x10, 0x08, 0x00, 0x00, 0x08, 0x03, 0xc0, 0xf9, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8e, 0x02, 0xc0, 0x03, 0x00, 0x00, 0x80, 0x00, 
	0x40, 0x02, 0xc0, 0x02, 0x40, 0x02, 0xc0, 0x02, 0x40, 0x00, 0x40, 0x02, 0x40, 0x02, 0x40, 0x00, 
	0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 0x40, 0x02, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 
	0x40, 0x02, 0x00, 0x00, 0x40, 0x00, 0x40, 0xb8, 0x04, 0x44, 0x03, 0x04, 0x00, 0x40, 0x00, 0x00, 
	0x19, 0x60, 0x04, 0x21, 0x17, 0x50, 0x01, 0x02, 0x04, 0x02, 0x09, 0x02, 0x19, 0x00, 0x81, 0x00, 
	0x00, 0x20, 0x83, 0x00, 0x00, 0x10, 0x05, 0x14, 0x13, 0x00, 0x00, 0x00, 0x10, 0x40, 0x00, 0x00, 
	0x10, 0xc0, 0x00, 0x20, 0x00, 0x40, 0xec, 0x00, 0x44, 0x0b, 0x44, 0x03, 0x00, 0x00, 0x48, 0x83, 
	0x60, 0x07, 0x41, 0x07, 0x54, 0x13, 0x40, 0x03, 0x61, 0x43, 0x40, 0x05, 0x42, 0x09, 0x00, 0x80, 
	0x40, 0x03, 0x00, 0x00, 0x41, 0x07, 0x61, 0x00, 0x00, 0x00, 0x54, 0x07, 0x00, 0x00, 0x54, 0x05, 
	0x00, 0x40, 0x40, 0x09, 0xa1, 0xd2, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x03, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xaf, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x40, 0x03, 0x40, 0x00, 
	0x40, 0x02, 0x40, 0x01, 0x00, 0x01, 0x40, 0x01, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 
	0x00, 0x00, 0x40, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x8a, 0x02, 0x50, 0x01, 0x68, 0x09, 0x04, 0x00, 0x60, 0x07, 0x42, 0x10, 0x60, 
	0x10, 0x40, 0x89, 0x60, 0x15, 0x40, 0x09, 0x52, 0x10, 0x60, 0x10, 0x00, 0x00, 0x50, 0x04, 0x01, 
	0x00, 0x60, 0x10, 0x40, 0x8a, 0x00, 0x00, 0x40, 0x43, 0x00, 0x00, 0x40, 0x10, 0x00, 0x00, 0x60, 
	0x00, 0x41, 0xd2, 0x42, 0x00, 0x02, 0x08, 0x02, 0x00, 0x00, 0x40, 0x00, 0x41, 0x04, 0x51, 0x04, 
	0x40, 0x02, 0x04, 0x00, 0x40, 0x0a, 0x58, 0x00, 0x02, 0x00, 0x00, 0x20, 0x50, 0x04, 0x00, 0x20, 
	0x40, 0x00, 0x11, 0x05, 0x00, 0x00, 0x24, 0x08, 0x00, 0x00, 0x41, 0x00, 0x00, 0x80, 0x10, 0x00, 
	0x52, 0xc9, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x40, 
	0xd9, 0x02, 0x40, 0x02, 0xc0, 0x02, 0x00, 0x00, 0x40, 0x02, 0x40, 0x00, 0x40, 0x02, 0x40, 0x02, 
	0x40, 0x00, 0x40, 0x02, 0x40, 0x02, 0x40, 0x03, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x40, 0x02, 
	0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x40, 0x00, 0xc0, 0xff, 
	0x02, 0x10, 0x17, 0x50, 0x47, 0x00, 0x00, 0x00, 0x19, 0x20, 0x01, 0x04, 0x81, 0x00, 0x09, 0x28, 
	0x1b, 0x00, 0x01, 0x01, 0x04, 0x18, 0x0b, 0x02, 0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x05, 0x04, 
	0x00, 0x02, 0x00, 0x00, 0x02, 0xc1, 0x00, 0x10, 0x05, 0x01, 0x00, 0x00, 0x49, 0x80, 0xe5, 0x00, 
	0x41, 0x09, 0x41, 0x09, 0x00, 0x00, 0x68, 0x47, 0x40, 0x0b, 0x00, 0x00, 0x41, 0x0b, 0x51, 0x03, 
	0x58, 0x03, 0x44, 0x03, 0x48, 0x03, 0x00, 0x00, 0x62, 0x0b, 0x00, 0x00, 0x41, 0x0b, 0x42, 0x00, 
	0x00, 0x00, 0x41, 0x09, 0x00, 0x00, 0x54, 0x29, 0x50, 0x07, 0x52, 0x01, 0x80, 0xc7, 0x00, 0x00, 
	0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x9d, 0x00, 0x40, 0x01, 
	0x40, 0x01, 0x00, 0x00, 0x00, 0x03, 0x40, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x01, 0x40, 0x03, 
	0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 
	0x40, 0x01, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x40, 0x00, 0x00, 0xec, 0x02, 0x60, 0x10, 0x60, 
	0x10, 0x00, 0x00, 0x40, 0x00, 0x61, 0x10, 0x00, 0x00, 0x60, 0x10, 0x40, 0x15, 0x40, 0x87, 0x50, 
	0x04, 0x62, 0x04, 0x01, 0x00, 0x40, 0x81, 0x00, 0x00, 0x60, 0x10, 0x50, 0x04, 0x02, 0x00, 0x60, 
	0x10, 0x00, 0x00, 0x40, 0x10, 0x40, 0x80, 0x40, 0x04, 0x41, 0xe1, 0x02, 0x52, 0x04, 0x51, 0x04, 
	0x00, 0x20, 0x20, 0x08, 0x41, 0x00, 0x00, 0x00, 0x51, 0x04, 0x28, 0x00, 0x40, 0x00, 0x44, 0x08, 
	0x00, 0x00, 0x00, 0x00, 0x24, 0x06, 0x00, 0x40, 0x50, 0x00, 0x01, 0x04, 0x00, 0x00, 0x41, 0x04, 
	0x00, 0x00, 0x51, 0x00, 0x04, 0x82, 0x40, 0x08, 0xc0, 0xf2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xbc, 0x02, 0x40, 0x03, 0x40, 0x03, 0x00, 0x00, 
	0x40, 0x02, 0x40, 0x00, 0x00, 0x00, 0x40, 0x02, 0x40, 0x00, 0x40, 0x02, 0x40, 0x00, 0x40, 0x00, 
	0x80, 0x00, 0x40, 0x02, 0x00, 0x00, 0x40, 0x02, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
	0x40, 0x02, 0x40, 0x02, 0x40, 0x00, 0x40, 0xc6, 0x02, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00, 0x00, 
	0x21, 0x20, 0x09, 0x01, 0x00, 0x00, 0x01, 0xc2, 0x1b, 0x00, 0x09, 0x22, 0x02, 0x04, 0x00, 0x40, 
	0x00, 0x00, 0x80, 0xc0, 0x00, 0x00, 0x09, 0xd8, 0x11, 0x00, 0x00, 0x10, 0x40, 0x00, 0x00, 0x00, 
	0x05, 0x11, 0x2b, 0x20, 0x13, 0x40, 0xbc, 0x00, 0x52, 0x83, 0x50, 0x03, 0x00, 0x20, 0x60, 0x40, 
	0x40, 0x03, 0x41, 0x03, 0x41, 0x03, 0x41, 0x02, 0x41, 0x03, 0x41, 0x83, 0x40, 0x01, 0x00, 0x00, 
	0x64, 0x07, 0x00, 0x00, 0x41, 0x03, 0x41, 0x03, 0x00, 0x00, 0x41, 0x01, 0x00, 0x00, 0x54, 0x01, 
	0x44, 0x83, 0x50, 0x09, 0x21, 0xed, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x8e, 0x00, 0x40, 0x00, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 
	0x40, 0x00, 0x40, 0x02, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x40, 0x02, 0x40, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x40, 0x01, 0x40, 0x00, 
	0x00, 0x00, 0x00, 0xeb, 0x46, 0x40, 0x04, 0x41, 0x18, 0x00, 0x00, 0x40, 0x04, 0x61, 0x18, 0x60, 
	0x08, 0x64, 0x18, 0x60, 0x08, 0x62, 0x18, 0x60, 0x0b, 0x62, 0x18, 0x00, 0x00, 0x40, 0x80, 0x00, 
	0x00, 0x60, 0x18, 0x60, 0x19, 0x00, 0x00, 0x60, 0x18, 0x00, 0x00, 0x40, 0x18, 0x60, 0x05, 0x41, 
	0x00, 0xc1, 0x8a, 0x02, 0x58, 0x82, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, 0x41, 0x04, 0x40, 0x03, 
	0x41, 0x04, 0x00, 0x80, 0x40, 0x04, 0x14, 0x00, 0x52, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 
	0x62, 0x00, 0x48, 0x08, 0x00, 0x00, 0x41, 0x08, 0x00, 0x00, 0x41, 0x04, 0x52, 0x02, 0x08, 0x08, 
	0x54, 0xc8, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0xe9, 0x02, 0xc0, 0x02, 0x40, 0x02, 0x00, 0x00, 0x40, 0x01, 0x40, 0x00, 0x40, 0x03, 0x40, 0x02, 
	0x40, 0x00, 0x40, 0x02, 0x40, 0x00, 0xc0, 0x02, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x40, 0x02, 
	0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0xc0, 0x02, 0x40, 0x00, 0xc0, 0xc0, 
	0x04, 0x48, 0x19, 0x20, 0x21, 0xc0, 0x00, 0x00, 0x0a, 0x22, 0x01, 0x04, 0x03, 0x10, 0x21, 0x00, 
	0x14, 0x10, 0x01, 0x02, 0x00, 0x40, 0x05, 0xc1, 0x00, 0x40, 0x03, 0x00, 0x00, 0x00, 0x09, 0x18, 
	0x03, 0x04, 0x00, 0x10, 0x00, 0x01, 0x00, 0x20, 0x03, 0x41, 0x18, 0x20, 0x10, 0x00, 0x88, 0x00, 
	0x68, 0x43, 0x60, 0x0a, 0x00, 0x00, 0x64, 0x83, 0x60, 0x07, 0x58, 0x02, 0x68, 0x03, 0x44, 0x13, 
	0x40, 0x0b, 0x00, 0x00, 0x48, 0x01, 0x00, 0x00, 0x64, 0x07, 0x00, 0x00, 0x48, 0x03, 0x41, 0x00, 
	0x00, 0x00, 0x58, 0x04, 0x00, 0x00, 0x51, 0x07, 0x00, 0x00, 0x52, 0x00, 0x80, 0xb8, 0x00, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x02, 0x00, 0x01, 0x00, 0x01, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 
	0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00, 0x03, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x02, 0x40, 0x09, 0x42, 
	0x03, 0x04, 0x00, 0x40, 0x15, 0x40, 0x00, 0x42, 0x17, 0x40, 0x85, 0x50, 0x15, 0x60, 0x01, 0x02, 
	0x00, 0x50, 0x04, 0x01, 0x00, 0x40, 0x80, 0x00, 0x00, 0x50, 0x05, 0x61, 0x17, 0x00, 0x00, 0x40, 
	0x10, 0x00, 0x00, 0x40, 0x03, 0x01, 0x00, 0x40, 0x08, 0x44, 0xdf, 0x42, 0x20, 0x84, 0x00, 0x08, 
	0x00, 0x20, 0x20, 0x08, 0x41, 0x00, 0x00, 0x03, 0x08, 0x18, 0x20, 0x10, 0x00, 0x04, 0x00, 0x80, 
	0x40, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x50, 0x20, 0x10, 0x00, 0x00, 0x00, 0x12, 0x00, 
	0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x08, 0x02, 0x40, 0xe2, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xae, 0x02, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 
	0x40, 0x00, 0xc0, 0x00, 0x40, 0x03, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 
	0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
	0x40, 0x03, 0x00, 0x00, 0x40, 0x03, 0xc0, 0xbe, 0x02, 0x00, 0x03, 0x24, 0x22, 0x00, 0x00, 0x00, 
	0x23, 0x60, 0x09, 0x04, 0x2b, 0x20, 0x23, 0x00, 0x1b, 0x10, 0x13, 0x00, 0x00, 0x20, 0x81, 0xc0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x06, 0x04, 0x00, 0x00, 0x00, 0x00, 0x08, 0xc1, 0x00, 0x10, 
	0x8b, 0x00, 0x00, 0x20, 0x04, 0xc2, 0xfb, 0x00, 0x44, 0x0b, 0x58, 0x07, 0x00, 0x00, 0x62, 0x07, 
	0x44, 0x07, 0x48, 0x03, 0x58, 0x87, 0x40, 0x17, 0x40, 0x03, 0x44, 0x02, 0x58, 0x0b, 0x00, 0x00, 
	0x64, 0x00, 0x00, 0x00, 0x58, 0x03, 0x58, 0x03, 0x00, 0x00, 0x54, 0x04, 0x00, 0x00, 0x54, 0x01, 
	0x00, 0x00, 0x52, 0x0b, 0x00, 0xaf, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x01, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x9c, 0x00, 0x00, 0x03, 0x40, 0x01, 0x00, 0x00, 0x40, 0x03, 0x00, 0x01, 
	0x40, 0x03, 0x40, 0x01, 0x40, 0x03, 0x00, 0x01, 0x00, 0x02, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x40, 0x01, 0x40, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0x00, 0xcd, 0x02, 0x50, 0x41, 0x40, 0x20, 0x00, 0x00, 0x40, 0x23, 0x60, 0x21, 0x60, 
	0x1b, 0x40, 0x20, 0x50, 0x80, 0x60, 0x19, 0x50, 0x06, 0x42, 0x80, 0x00, 0x00, 0x40, 0x04, 0x01, 
	0x00, 0x40, 0x05, 0x41, 0x04, 0x01, 0x00, 0x40, 0x40, 0x00, 0x00, 0x40, 0x88, 0x00, 0x00, 0x40, 
	0x10, 0xc0, 0x98, 0x42, 0x00, 0x82, 0x50, 0x00, 0x00, 0x00, 0x40, 0x00, 0x08, 0x08, 0x41, 0x03, 
	0x41, 0x00, 0x48, 0x10, 0x00, 0x08, 0x14, 0x41, 0x50, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x60, 0x00, 0x48, 0x08, 0x00, 0x00, 0x24, 0x0b, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x08, 0x00, 
	0xc0, 0x8c, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xad, 0x02, 0x40, 0x02, 0x40, 0x00, 0x00, 0x00, 0x40, 0x02, 0xc0, 0x00, 0x40, 0x03, 0x40, 0x00, 
	0xc0, 0x00, 0x40, 0x00, 0x40, 0x01, 0x40, 0x02, 0x00, 0x00, 0xc0, 0x03, 0x80, 0x00, 0xc0, 0x00, 
	0xc0, 0x02, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x03, 0xc0, 0xc7, 
	0x02, 0x10, 0x27, 0x00, 0x89, 0x00, 0x00, 0x00, 0x19, 0x60, 0x23, 0x20, 0x03, 0x20, 0x08, 0x62, 
	0x03, 0xd0, 0x13, 0x00, 0x17, 0x00, 0x01, 0x01, 0x00, 0x40, 0x03, 0x40, 0x00, 0x40, 0x0a, 0x58, 
	0x20, 0x00, 0x00, 0x00, 0x03, 0x01, 0x00, 0x00, 0x05, 0x01, 0x00, 0x20, 0x00, 0x40, 0x92, 0x00, 
	0x68, 0x81, 0x60, 0x0b, 0x00, 0x20, 0x50, 0x83, 0x40, 0x07, 0x68, 0x07, 0x68, 0x87, 0x40, 0x17, 
	0x40, 0x07, 0x40, 0x06, 0x44, 0x0b, 0x00, 0x00, 0x44, 0x03, 0x00, 0x00, 0x68, 0x83, 0x40, 0x07, 
	0x00, 0x40, 0x40, 0x03, 0x00, 0x80, 0x40, 0x03, 0x00, 0x00, 0x48, 0x08, 0x00, 0xe2, 0x00, 0x00, 
	0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
	0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbc, 0x00, 0x40, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00, 0x01, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0x00, 0x01, 
	0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 0x40, 0x01, 0x40, 0x03, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x98, 0x46, 0x40, 0x07, 0x41, 
	0x00, 0x01, 0x00, 0x40, 0x19, 0x60, 0x01, 0x42, 0x80, 0x40, 0x00, 0x52, 0x01, 0x62, 0x41, 0x40, 
	0x43, 0x60, 0x03, 0x01, 0x00, 0x60, 0x1b, 0x00, 0x00, 0x40, 0x05, 0x61, 0x23, 0x00, 0x00, 0x60, 
	0x44, 0x00, 0x00, 0x50, 0x1b, 0x00, 0x00, 0x60, 0x13, 0xc0, 0x92, 0x0a, 0x52, 0x08, 0x24, 0x00, 
	0x00, 0x00, 0x40, 0x2a, 0x10, 0x00, 0x41, 0x04, 0x41, 0x00, 0x40, 0x1a, 0x00, 0x00, 0x00, 0x13, 
	0x20, 0x07, 0x00, 0x00, 0x68, 0x00, 0x00, 0x80, 0x60, 0x00, 0x68, 0x00, 0x00, 0x20, 0x00, 0x06, 
	0x00, 0x00, 0x04, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x40, 0xeb, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9c, 0x02, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 
	0x40, 0x02, 0xc0, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x02, 0x40, 0x00, 0x40, 0x01, 0x40, 0x03, 
	0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x02, 0x80, 0x00, 
	0x40, 0x03, 0x00, 0x00, 0x40, 0x00, 0xc0, 0xe7, 0x00, 0x04, 0x01, 0x02, 0x09, 0x02, 0x00, 0x00, 
	0x11, 0x40, 0x27, 0x20, 0x20, 0x20, 0x08, 0xc2, 0x11, 0x10, 0x27, 0x00, 0x1a, 0x00, 0x43, 0x00, 
	0x00, 0x00, 0x47, 0x40, 0x00, 0x00, 0x06, 0x04, 0x03, 0xc0, 0x00, 0xd0, 0x01, 0x41, 0x00, 0x10, 
	0x13, 0x00, 0x00, 0x00, 0x00, 0x40, 0x8b, 0x80, 0x60, 0x83, 0x60, 0x07, 0x00, 0x00, 0x42, 0x17, 
	0x40, 0x0b, 0x41, 0x03, 0x58, 0x03, 0x42, 0x03, 0x41, 0x03, 0x64, 0x00, 0x68, 0x03, 0x00, 0x80, 
	0x40, 0x00, 0x00, 0x00, 0x48, 0x03, 0x41, 0x00, 0x00, 0x40, 0x40, 0x03, 0x00, 0x00, 0x58, 0x04, 
	0x00, 0x00, 0x58, 0x03, 0xa1, 0x9b, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x9c, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x03, 
	0x40, 0x00, 0x40, 0x03, 0x00, 0x01, 0x40, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x40, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x40, 0x00, 0x00, 0xdd, 0x46, 0x40, 0x18, 0x40, 0x80, 0x00, 0x00, 0x60, 0x11, 0x50, 0x10, 0x60, 
	0x18, 0x40, 0x88, 0x60, 0x15, 0x60, 0x84, 0x40, 0x88, 0x40, 0x07, 0x02, 0x00, 0x50, 0x00, 0x00, 
	0x00, 0x60, 0x05, 0x61, 0x14, 0x00, 0x00, 0x60, 0x04, 0x02, 0x00, 0x40, 0x10, 0x00, 0x00, 0x40, 
	0x04, 0x41, 0xab, 0x42, 0x20, 0x04, 0x24, 0x08, 0x00, 0x20, 0x20, 0x08, 0x58, 0x00, 0x40, 0x03, 
	0x48, 0x00, 0x18, 0x80, 0x40, 0x00, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
	0x62, 0x00, 0x28, 0x00, 0x00, 0x20, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x40, 0x80, 
	0x60, 0xb1, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0xda, 0x02, 0x40, 0x02, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x03, 0x40, 0x00, 
	0x40, 0x00, 0x40, 0x02, 0x40, 0x03, 0x40, 0x03, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 
	0x40, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x02, 0xc0, 0xee, 
	0x88, 0x00, 0x00, 0x04, 0x11, 0x00, 0x00, 0xc0, 0x23, 0x00, 0x03, 0x00, 0x03, 0x10, 0x03, 0x00, 
	0x1b, 0x10, 0x45, 0x00, 0x03, 0x20, 0x00, 0xc0, 0x00, 0xd0, 0x03, 0x00, 0x00, 0x00, 0x06, 0x04, 
	0x00, 0x00, 0x00, 0x50, 0x83, 0x40, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x09, 0x88, 0xce, 0x00, 
	0x64, 0x0b, 0x44, 0x07, 0x00, 0x00, 0x61, 0x03, 0x44, 0x03, 0x44, 0x03, 0x44, 0x87, 0x40, 0x1b, 
	0x40, 0x07, 0x41, 0x03, 0x44, 0x03, 0x00, 0x40, 0x40, 0x0a, 0x00, 0x00, 0x44, 0x03, 0x41, 0x03, 
	0x00, 0x40, 0x40, 0x07, 0x00, 0x00, 0x58, 0x47, 0x40, 0x0b, 0x51, 0x00, 0x00, 0xed, 0x00, 0x00, 
	0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
	0x01, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xbd, 0x00, 0x00, 0x03, 
	0x40, 0x01, 0x00, 0x00, 0x40, 0x01, 0x40, 0x03, 0x40, 0x01, 0x40, 0x01, 0x40, 0x03, 0x00, 0x01, 
	0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x02, 0x00, 0x03, 0x00, 0x8c, 0x02, 0x40, 0x10, 0x60, 
	0x20, 0x00, 0x00, 0x40, 0x19, 0x60, 0x08, 0x61, 0x44, 0x60, 0x20, 0x50, 0x40, 0x60, 0x21, 0x60, 
	0x25, 0x60, 0x84, 0x00, 0x00, 0x60, 0x82, 0x00, 0x00, 0x60, 0x05, 0x61, 0x17, 0x00, 0x00, 0x60, 
	0x00, 0x02, 0x00, 0x40, 0x10, 0x50, 0x10, 0x40, 0x17, 0x40, 0xb7, 0x42, 0x20, 0x84, 0x50, 0x00, 
	0x00, 0x00, 0x40, 0x82, 0x60, 0x00, 0x41, 0x04, 0x41, 0x48, 0x40, 0x10, 0x00, 0x00, 0x28, 0x08, 
	0x62, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x20, 0x40, 0x20, 0x10, 0x00, 0x00, 0x20, 0x00, 0x02, 
	0x00, 0x00, 0x22, 0x88, 0x20, 0x80, 0x00, 0x07, 0x40, 0xd9, 0x00, 0x40, 0x00, 0x40, 0x01, 0x40, 
	0x00, 0x40, 0x01, 0x40, 0x00, 0x40, 0x01, 0x40, 0x01, 0x40, 0x03, 0x40, 0x00, 0x40, 0x00, 0x40, 
	0x00, 0x40, 0x00, 0x40, 0x03, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x01, 0x40, 
	0x00, 0x40, 0x01, 0x40, 0x00, 0x40, 0x03, 0x00, 0xdd, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 
	0x80, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0x80, 0x01, 0xc0, 0xfb, 0x02, 0x00, 0x00, 0x04, 0x09, 0x01, 0x00, 0x00, 
	0x25, 0x00, 0x04, 0x21, 0x20, 0x20, 0x00, 0x14, 0x03, 0xd0, 0x17, 0x00, 0x10, 0x00, 0x00, 0x40, 
	0x00, 0xd0, 0x07, 0xc1, 0x00, 0xd0, 0x0a, 0x08, 0x00, 0xc0, 0x00, 0x10, 0x87, 0x00, 0x00, 0x00, 
	0x13, 0x00, 0x0b, 0x51, 0x00, 0x42, 0xe2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x9e, 0x00, 0x08, 0x02, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 
	0x00, 0x88, 0x00, 0x08, 0x00, 0x08, 0x02, 0x88, 0x00, 0x08, 0x00, 0x08, 0x00, 0x40, 0x00, 0x08, 
	0x00, 0x00, 0x00, 0x08, 0x02, 0x08, 0x00, 0x80, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x48, 
	0x00, 0x08, 0x00, 0x80, 0x9e, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x08, 0x00, 0x00, 0x82, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x00, 
	0x00, 0x00, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x20, 0x00, 0x80, 0xda, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x04, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x80, 0x00, 0x04, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x18, 0xba, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x40, 
	0x02, 0x00, 0x00, 0x00, 0x02, 0x80, 0x02, 0x00, 0x20, 0xc4, 0x00, 0x00, 0x02, 0x04, 0x00, 0x00, 
	0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xc0, 0x01, 0x00, 0x00, 0x00, 
	0x80, 0xd9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 
	0x00, 0x04, 0x00, 0x08, 0x02, 0x04, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x08, 0x00, 0x00, 0x10, 
	0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x80, 
	0xea, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0xda, 
	0x04, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0x00, 
	0x00, 0x00, 0x20, 0x04, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 
	0x00, 0x40, 0x00, 0x04, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0x02, 0x00, 0x00, 0x44, 0x00, 0x00, 0x01, 0x44, 0x00, 0x00, 0x02, 0x40, 0x00, 0xce, 0x00, 0x20, 
	0x00, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x08, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x80, 0x98, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x20, 0x04, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x10, 0x00, 0x80, 0x00, 0x24, 0x00, 0x00, 0x02, 0x00, 0x88, 0x80, 0xeb, 0x00, 0x00, 0x04, 0x00, 
	0x00, 0x00, 0x00, 0x08, 0x08, 0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xaa, 0x02, 0x04, 0x04, 0x00, 0x02, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x00, 0x08, 0x00, 0x00, 
	0x08, 0x24, 0x00, 0x00, 0x10, 0x80, 0x00, 0x00, 0x10, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0xe2, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x40, 0x00, 0x30, 0x00, 0x00, 0x08, 
	0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xeb, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x80, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x08, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xed, 0x80, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x8e, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x20, 0x00, 
	0x10, 0x00, 0x04, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0xc1, 0xfb, 0x10, 0x00, 0x82, 0x00, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 
	0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
	0x04, 0x00, 0x00, 0x00, 0x81, 0x20, 0x40, 0x80, 0x10, 0x00, 0x02, 0x00, 0x10, 0x10, 0x04, 0x00, 
	0x00, 0x10, 0x00, 0x22, 0x00, 0x00, 0x00, 0x10, 0x20, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
	0x00, 0x80, 0x01, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xa1, 0xac, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x02, 0x01, 0x20, 0x00, 0x86, 0x00, 
	0x08, 0x00, 0x20, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x28, 0x00, 
	0x00, 0x80, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x02, 0x00, 0x11, 0x00, 
	0x00, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x08, 
	0x10, 0xeb, 0x00, 0x00, 0x00, 0x04, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x01, 
	0x00, 0x00, 0x00, 0x00, 0x04, 0x40, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x08, 0x20, 
	0x00, 0x02, 0x00, 0x00, 0x00, 0x30, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x88, 
	0xe9, 0x80, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x04, 0x00, 0x40, 0x10, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x8e, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x41, 0x00, 0x80, 0x00, 0x00, 
	0x24, 0x00, 0x00, 0x00, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x08, 0x08, 0x00, 0x10, 0x00, 0x00, 0x04, 0x01, 0x08, 0x00, 0x80, 0x00, 0x00, 0x84, 0xb1, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x20, 0x00, 0x00, 0x08, 0x40, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x10, 0x04, 0x10, 0x00, 
	0x40, 0x00, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x02, 0xd5, 0x20, 0x00, 
	0x10, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x08, 0x00, 0x84, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00, 0xdb, 0x04, 0x00, 0x00, 
	0x00, 0x10, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x12, 0x00, 0x00, 0x01, 0x42, 0x00, 0x28, 0x00, 0x00, 
	0x20, 0x00, 0x00, 0x00, 0xa0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x06, 0x00, 0x00, 0x02, 0x00, 0x00, 0xfc, 0x00, 0x04, 0x08, 0x10, 
	0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x90, 0x00, 0x00, 0x82, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
	0x02, 0x02, 0x40, 0x00, 0x00, 0x04, 0x00, 0x11, 0x10, 0x00, 0xfa, 0x00, 0x60, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x0c, 0x00, 0x0c, 
	0x20, 0x00, 0x80, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 
	0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0xfe, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x00, 0x84, 0x20, 0x40, 0x00, 0x40, 
	0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x42, 0x00, 0xc0, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x80, 
	0x00, 0x00, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x9e, 0x00, 0x08, 0x00, 0x08, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x40, 0x08, 0x12, 0x08, 0x00, 0x00, 0x00, 0x08, 
	0x00, 0x00, 0x02, 0x08, 0x00, 0x48, 0x02, 0x08, 0x40, 0x08, 0x00, 0x08, 0x80, 0x00, 0x00, 0x08, 
	0x40, 0x08, 0x40, 0x08, 0x00, 0x84, 0x83, 0x00, 0x42, 0x03, 0x00, 0x40, 0x60, 0x00, 0x41, 0x0b, 
	0x00, 0x00, 0x00, 0x00, 0x48, 0x0b, 0x41, 0x03, 0x48, 0x03, 0x44, 0x83, 0x50, 0x03, 0x41, 0x0b, 
	0x44, 0x03, 0x41, 0x84, 0x40, 0x44, 0x40, 0x83, 0x40, 0x04, 0x00, 0x00, 0x42, 0x03, 0x64, 0x83, 
	0x40, 0x0b, 0x00, 0x00, 0x80, 0xb3, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x9d, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x03, 
	0x00, 0x00, 0x00, 0x00, 0x40, 0x03, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x40, 0x01, 
	0x00, 0x00, 0x00, 0xd8, 0x02, 0x60, 0x1b, 0x00, 0x00, 0x40, 0x08, 0x61, 0x11, 0x00, 0x00, 0x00, 
	0x00, 0x60, 0x11, 0x60, 0x18, 0x50, 0x26, 0x60, 0x04, 0x41, 0x24, 0x60, 0x10, 0x50, 0x08, 0x62, 
	0x13, 0x60, 0x00, 0x52, 0x15, 0x60, 0x12, 0x00, 0x00, 0x60, 0x1b, 0x40, 0x4b, 0x50, 0x80, 0x00, 
	0x00, 0xc0, 0xf6, 0x02, 0x00, 0x06, 0x00, 0x40, 0x00, 0x20, 0x50, 0x03, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x08, 0x00, 0x43, 0x40, 0x01, 0x00, 0x40, 0x50, 0x04, 0x08, 0x00, 0x08, 0x06, 0x28, 0x00, 
	0x00, 0x24, 0x50, 0x06, 0x00, 0x00, 0x00, 0x00, 0x18, 0x0a, 0x00, 0x06, 0x48, 0x00, 0x00, 0x00, 
	0xc0, 0xb7, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0xbc, 0x02, 0x40, 0x03, 0x00, 0x00, 0x40, 0x02, 0x40, 0x03, 0x00, 0x00, 0x80, 0x00, 0x40, 0x01, 
	0x40, 0x03, 0x40, 0x03, 0xc0, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x03, 0xc0, 0x00, 0x40, 0x02, 
	0x40, 0x03, 0x40, 0x00, 0x00, 0x00, 0x40, 0x03, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0xeb, 
	0x02, 0x00, 0x03, 0x02, 0x00, 0xd0, 0x44, 0xc0, 0x27, 0x00, 0x00, 0x40, 0x00, 0x00, 0x22, 0x00, 
	0x03, 0x20, 0x06, 0x41, 0x00, 0x00, 0x01, 0xe1, 0x00, 0xe0, 0x43, 0x40, 0x00, 0x00, 0x21, 0x00, 
	0x13, 0x00, 0x18, 0x00, 0x00, 0x00, 0x13, 0x00, 0x40, 0xe0, 0x25, 0xc0, 0x00, 0xc0, 0x82, 0x08, 
	0x00, 0x20, 0x40, 0x03, 0x44, 0x03, 0x40, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x58, 0x87, 0x60, 0x4b, 
	0x60, 0x03, 0x40, 0x03, 0x00, 0x00, 0x41, 0x05, 0x61, 0x0b, 0x41, 0x83, 0x40, 0x03, 0x54, 0x03, 
	0x44, 0x02, 0x61, 0x0b, 0x44, 0x03, 0x42, 0x04, 0x42, 0x00, 0x00, 0x00, 0x80, 0x8d, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 
	0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x03, 0x00, 0x02, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 
	0x40, 0x02, 0x00, 0x00, 0x40, 0x01, 0x00, 0x01, 0x00, 0x00, 0x40, 0x00, 0x00, 0x03, 0x40, 0x00, 
	0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x89, 0x42, 0x00, 0x00, 0x50, 
	0x04, 0x51, 0x04, 0x42, 0x23, 0x00, 0x00, 0x00, 0x00, 0x40, 0x21, 0x40, 0x00, 0x44, 0x88, 0x40, 
	0x16, 0x00, 0x00, 0x60, 0x00, 0x44, 0x11, 0x60, 0x07, 0x52, 0x04, 0x42, 0x00, 0x60, 0x04, 0x42, 
	0x10, 0x50, 0x18, 0x50, 0x02, 0x64, 0x8a, 0x00, 0x00, 0xc0, 0x9f, 0x02, 0x00, 0x00, 0x00, 0x08, 
	0x28, 0x0a, 0x00, 0x03, 0x00, 0x00, 0x00, 0x80, 0x00, 0x20, 0x00, 0x80, 0x20, 0x00, 0x40, 0x01, 
	0x00, 0x00, 0x64, 0x00, 0x08, 0x0a, 0x08, 0x00, 0x58, 0x00, 0x28, 0x80, 0x40, 0x80, 0x00, 0x84, 
	0x10, 0x28, 0x20, 0x09, 0x00, 0x08, 0x00, 0x00, 0xc0, 0xca, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xaf, 0x02, 0x00, 0x00, 0x40, 0x02, 0x40, 0x02, 
	0x40, 0x01, 0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x02, 0x40, 0x03, 0x00, 0x00, 
	0xc0, 0x00, 0x40, 0x02, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x03, 
	0xc0, 0x01, 0x40, 0x00, 0x80, 0x00, 0xc0, 0x8e, 0x08, 0xc4, 0x00, 0x00, 0x01, 0x04, 0x01, 0xc1, 
	0x0a, 0x44, 0x00, 0x00, 0x00, 0x10, 0x27, 0x10, 0x05, 0xc1, 0x28, 0x00, 0x07, 0x01, 0x00, 0x40, 
	0x15, 0x10, 0x41, 0x10, 0x00, 0x00, 0x17, 0x00, 0x00, 0x20, 0x1b, 0x20, 0x11, 0x00, 0x03, 0x41, 
	0x40, 0x00, 0x20, 0x40, 0x00, 0xc0, 0xca, 0x20, 0x50, 0x03, 0x48, 0x43, 0x60, 0x01, 0x41, 0x05, 
	0x00, 0x00, 0x64, 0x00, 0x42, 0x0b, 0x44, 0x4b, 0x40, 0x03, 0x62, 0x03, 0x00, 0x00, 0x42, 0x45, 
	0x50, 0x02, 0x41, 0x01, 0x68, 0x01, 0x42, 0x08, 0x42, 0x47, 0x60, 0x08, 0x68, 0x03, 0x44, 0x8b, 
	0x40, 0x07, 0x00, 0x00, 0x22, 0x8d, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x02, 0x00, 0x01, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0xbd, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0x40, 0x03, 0x00, 0x03, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x40, 0x03, 0x00, 0x03, 0x00, 0x00, 0x40, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x40, 0x01, 
	0x00, 0x00, 0x00, 0xec, 0x02, 0x40, 0x04, 0x51, 0x07, 0x42, 0x08, 0x61, 0x10, 0x00, 0x00, 0x40, 
	0x48, 0x50, 0x23, 0x60, 0x13, 0x60, 0x09, 0x42, 0x04, 0x01, 0x00, 0x60, 0x00, 0x42, 0x88, 0x60, 
	0x14, 0x40, 0x07, 0x62, 0x81, 0x60, 0x01, 0x42, 0x20, 0x40, 0x04, 0x61, 0x03, 0x54, 0x11, 0x00, 
	0x00, 0x40, 0xc5, 0x02, 0x02, 0x80, 0x00, 0x40, 0x00, 0x80, 0x50, 0x00, 0x00, 0x00, 0x00, 0x06, 
	0x18, 0x0b, 0x68, 0x02, 0x04, 0x2a, 0x50, 0x06, 0x00, 0x80, 0x20, 0x0a, 0x00, 0x20, 0x50, 0x04, 
	0x00, 0x03, 0x28, 0x04, 0x44, 0x24, 0x00, 0x00, 0x08, 0x80, 0x10, 0x08, 0x48, 0x04, 0x00, 0x80, 
	0xc0, 0xe7, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x02, 0x00, 0x03, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x40, 
	0xea, 0x02, 0x40, 0x03, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x03, 
	0x40, 0x03, 0x40, 0x02, 0x40, 0x02, 0x00, 0x00, 0x40, 0x02, 0x40, 0x00, 0x40, 0x02, 0x40, 0x00, 
	0xc0, 0x00, 0x40, 0x00, 0xc0, 0x00, 0x40, 0x00, 0x40, 0x03, 0x40, 0x00, 0x00, 0x00, 0xc0, 0xda, 
	0x02, 0xe0, 0x29, 0x20, 0x08, 0x11, 0x44, 0xc0, 0x14, 0xc0, 0x00, 0x00, 0x80, 0x00, 0x03, 0x02, 
	0x27, 0x20, 0x03, 0xc1, 0x11, 0x00, 0x00, 0x00, 0x81, 0x00, 0x84, 0x00, 0x11, 0x00, 0x24, 0x40, 
	0x40, 0x20, 0x10, 0x50, 0x18, 0x20, 0x00, 0x00, 0x23, 0x20, 0x03, 0x01, 0x00, 0x20, 0xba, 0x00, 
	0x61, 0x06, 0x58, 0x03, 0x48, 0x0b, 0x40, 0x00, 0x00, 0x20, 0x50, 0x00, 0x51, 0x0b, 0x41, 0x07, 
	0x48, 0x03, 0x40, 0x02, 0x00, 0x80, 0x60, 0x03, 0x41, 0x09, 0x68, 0x04, 0x68, 0x04, 0x44, 0x07, 
	0x42, 0x0b, 0x68, 0x88, 0x50, 0x80, 0x40, 0x03, 0x68, 0x05, 0x54, 0x0b, 0x22, 0xc5, 0x00, 0x00, 
	0x02, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0xbd, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0x40, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x40, 0x03, 0x40, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0x03, 0x40, 0x01, 
	0x00, 0x02, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00, 0x40, 0x02, 0x00, 0xfb, 0x02, 0x40, 0x42, 0x40, 
	0x87, 0x60, 0x10, 0x40, 0x05, 0x02, 0x00, 0x40, 0x49, 0x40, 0x10, 0x60, 0x20, 0x60, 0x85, 0x40, 
	0x01, 0x00, 0x00, 0x40, 0x17, 0x50, 0x00, 0x42, 0x10, 0x40, 0x42, 0x60, 0x23, 0x60, 0x10, 0x40, 
	0x20, 0x40, 0x08, 0x54, 0x15, 0x40, 0x00, 0x42, 0x10, 0x40, 0x8a, 0x02, 0x01, 0x0a, 0x22, 0x08, 
	0x41, 0x08, 0x00, 0x06, 0x00, 0x80, 0x00, 0x02, 0x41, 0x04, 0x40, 0x83, 0x20, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x04, 0x03, 0x02, 0x40, 0x20, 0x00, 0x00, 0x2b, 0x50, 0x46, 0x50, 0x28, 0x00, 0x04, 
	0x04, 0x40, 0x20, 0x02, 0x04, 0x00, 0x58, 0x24, 0xc0, 0xd5, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 
	0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x40, 0xc9, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x00, 
	0x40, 0x00, 0x00, 0x00, 0x40, 0x02, 0x40, 0x00, 0x40, 0x03, 0x40, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x40, 0x03, 0x40, 0x00, 0x40, 0x00, 0x40, 0x03, 0x40, 0x02, 0x40, 0x00, 0x40, 0x00, 0xc0, 0x00, 
	0xc0, 0x03, 0xc0, 0x00, 0x40, 0x02, 0x40, 0xeb, 0x02, 0xd0, 0x41, 0x00, 0x23, 0x20, 0x21, 0xc0, 
	0x40, 0x00, 0x00, 0x10, 0x85, 0x20, 0x11, 0xc0, 0x03, 0x00, 0x2b, 0x00, 0x2a, 0xc0, 0x00, 0x20, 
	0x1b, 0x20, 0x04, 0x02, 0x08, 0x04, 0x03, 0x01, 0x13, 0x00, 0x20, 0xd0, 0x20, 0x50, 0x48, 0x40, 
	0x27, 0x60, 0x18, 0x00, 0x01, 0x11, 0xe3, 0x00, 0x41, 0x04, 0x41, 0x01, 0x48, 0x03, 0x48, 0x01, 
	0x00, 0x00, 0x00, 0x0b, 0x41, 0x07, 0x01, 0x07, 0x44, 0x02, 0x40, 0x80, 0x40, 0x03, 0x41, 0x29, 
	0x40, 0x02, 0x41, 0x03, 0x61, 0x02, 0x64, 0x03, 0x42, 0x03, 0x40, 0x06, 0x44, 0x20, 0x60, 0x84, 
	0x40, 0x27, 0x40, 0x03, 0x00, 0xa5, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 
	0x02, 0x00, 0x03, 0x00, 0x02, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x03, 0x00, 0x9e, 0x00, 0x00, 0x00, 0x40, 0x01, 0x40, 0x00, 0x40, 0x01, 0x00, 0x00, 
	0x40, 0x00, 0x40, 0x03, 0x40, 0x00, 0x40, 0x00, 0x00, 0x01, 0x00, 0x03, 0x40, 0x01, 0x40, 0x02, 
	0x40, 0x01, 0x40, 0x02, 0x40, 0x03, 0x40, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x40, 0x01, 
	0x40, 0x03, 0x00, 0xde, 0x02, 0x50, 0x01, 0x64, 0x18, 0x60, 0x18, 0x60, 0x18, 0x00, 0x00, 0x40, 
	0x80, 0x60, 0x00, 0x62, 0x20, 0x50, 0x18, 0x40, 0x01, 0x50, 0x48, 0x60, 0x00, 0x52, 0x1a, 0x60, 
	0x4b, 0x40, 0x1a, 0x40, 0x1b, 0x60, 0x45, 0x40, 0x20, 0x50, 0x07, 0x42, 0x01, 0x54, 0x80, 0x50, 
	0x1a, 0xc0, 0xc9, 0x02, 0x21, 0x0a, 0x54, 0x08, 0x41, 0x00, 0x41, 0x08, 0x00, 0x00, 0x40, 0x00, 
	0x54, 0x07, 0x40, 0x43, 0x40, 0x07, 0x00, 0x0a, 0x21, 0x00, 0x64, 0x00, 0x40, 0x04, 0x68, 0x07, 
	0x40, 0x04, 0x68, 0x0a, 0x44, 0x00, 0x00, 0x80, 0x10, 0x03, 0x00, 0x08, 0x48, 0x40, 0x60, 0x01, 
	0xc0, 0xcb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 
	0x8d, 0x02, 0x40, 0x03, 0x40, 0x03, 0x40, 0x00, 0x40, 0x03, 0x00, 0x00, 0xc0, 0x03, 0x40, 0x03, 
	0x40, 0x03, 0xc0, 0x03, 0x00, 0x01, 0x40, 0x02, 0xc0, 0x00, 0x40, 0x01, 0xc0, 0x03, 0x40, 0x01, 
	0x40, 0x02, 0x40, 0x00, 0x40, 0x01, 0x40, 0x01, 0x40, 0x03, 0x40, 0x00, 0xc0, 0x01, 0x40, 0xad, 
	0x02, 0xc0, 0x03, 0x01, 0x10, 0xe0, 0x49, 0x20, 0x03, 0x04, 0x00, 0x40, 0x03, 0x00, 0x03, 0xc1, 
	0x03, 0x60, 0x43, 0xc0, 0x02, 0x02, 0x09, 0x42, 0x19, 0x00, 0x82, 0x40, 0x13, 0xc0, 0x12, 0x00, 
	0x03, 0x22, 0x18, 0x00, 0x2a, 0xc0, 0x49, 0xc0, 0x43, 0x20, 0x19, 0x40, 0x07, 0x41, 0xdb, 0x00, 
	0x44, 0x83, 0x50, 0x09, 0x62, 0x07, 0x41, 0x03, 0x00, 0x00, 0x00, 0x00, 0x41, 0x85, 0x60, 0x05, 
	0x48, 0x01, 0x40, 0x20, 0x50, 0x0b, 0x51, 0x40, 0x50, 0x44, 0x40, 0x20, 0x40, 0x04, 0x58, 0x87, 
	0x40, 0x05, 0x00, 0x00, 0x62, 0x03, 0x48, 0x82, 0x40, 0x4b, 0x40, 0x01, 0x00, 0xd4, 0x00, 0x00, 
	0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x02, 0x00, 0x03, 0x00, 0x01, 0x00, 0x9d, 0x00, 0x00, 0x01, 
	0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 
	0x00, 0x01, 0x00, 0x03, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0x40, 0x03, 0x40, 0x01, 0x00, 0x00, 0x00, 0xb8, 0x02, 0x60, 0x04, 0x41, 
	0x01, 0x44, 0x40, 0x60, 0x24, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x42, 0x01, 0x51, 0x25, 0x40, 
	0x01, 0x40, 0x80, 0x40, 0x18, 0x40, 0x00, 0x54, 0x08, 0x52, 0x80, 0x40, 0x03, 0x61, 0x10, 0x00, 
	0x00, 0x40, 0x86, 0x50, 0x03, 0x50, 0x40, 0x50, 0x08, 0x44, 0x8c, 0x22, 0x10, 0x00, 0x04, 0x48, 
	0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x00, 0x48, 0x40, 0x00, 0x00, 0x86, 
	0x20, 0x08, 0x04, 0x02, 0x00, 0x40, 0x00, 0x04, 0x11, 0x20, 0x50, 0x06, 0x00, 0x00, 0x00, 0x80, 
	0x00, 0x01, 0x40, 0x00, 0x48, 0x04, 0x00, 0x08, 0xc0, 0x8c, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xac, 0x02, 0x40, 0x00, 0x40, 0x00, 0xc0, 0x00, 
	0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x40, 0x03, 0x40, 0x00, 0x40, 0x00, 0x00, 0x01, 0x40, 0x02, 
	0xc0, 0x02, 0x40, 0x02, 0x40, 0x00, 0x40, 0x01, 0x40, 0x02, 0x40, 0x00, 0x00, 0x00, 0x40, 0x01, 
	0x00, 0x02, 0x40, 0x00, 0x40, 0x00, 0xc0, 0xf9, 0x02, 0x00, 0x89, 0x10, 0x20, 0x60, 0x11, 0x00, 
	0x00, 0x40, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x11, 0x43, 0x20, 0x05, 0x01, 0x02, 0x02, 0x01, 0x62, 
	0x14, 0xc0, 0x85, 0x20, 0x22, 0x00, 0x14, 0x00, 0x13, 0x00, 0x18, 0x00, 0x00, 0x10, 0x27, 0x00, 
	0x09, 0xe2, 0x01, 0xc2, 0x80, 0x40, 0xf1, 0x08, 0x41, 0x28, 0x60, 0x02, 0x51, 0x0b, 0x41, 0x09, 
	0x00, 0x00, 0x00, 0x20, 0x40, 0x84, 0x60, 0x03, 0x42, 0x05, 0x40, 0x00, 0x61, 0x03, 0x44, 0x80, 
	0x60, 0x03, 0x58, 0x03, 0x41, 0x0b, 0x48, 0x03, 0x40, 0x44, 0x60, 0x48, 0x40, 0x07, 0x40, 0x00, 
	0x44, 0x44, 0x40, 0x02, 0x00, 0xc1, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x02, 0x00, 0x8d, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x40, 0x03, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 
	0x40, 0x03, 0x00, 0x01, 0x00, 0x03, 0x00, 0x02, 0x00, 0x00, 0x40, 0x01, 0x40, 0x03, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xbc, 0x42, 0x50, 0x43, 0x40, 0x0b, 0x41, 0x01, 0x62, 0x10, 0x00, 0x00, 0x00, 
	0x00, 0x50, 0x40, 0x40, 0x48, 0x60, 0x40, 0x40, 0x01, 0x40, 0x0b, 0x64, 0x18, 0x40, 0x17, 0x40, 
	0x00, 0x50, 0x11, 0x50, 0x00, 0x40, 0x12, 0x40, 0x20, 0x50, 0x81, 0x40, 0x00, 0x60, 0x00, 0x52, 
	0x08, 0x44, 0xe0, 0x02, 0x21, 0x00, 0x21, 0x00, 0x08, 0x06, 0x58, 0x08, 0x00, 0x00, 0x00, 0x20, 
	0x20, 0x22, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x04, 0x00, 0x00, 0x01, 0x04, 0x00, 0x41, 0x00, 
	0x00, 0x06, 0x28, 0x00, 0x00, 0x21, 0x00, 0x00, 0x40, 0x00, 0x58, 0x00, 0x28, 0x01, 0x00, 0x08, 
	0xc0, 0xbf, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xbc, 0x02, 0x40, 0x00, 0x40, 0x00, 0xc0, 0x02, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 
	0x40, 0x00, 0x40, 0x00, 0x00, 0x01, 0x40, 0x00, 0x40, 0x00, 0x40, 0x02, 0x40, 0x00, 0x40, 0x02, 
	0x40, 0x00, 0xc0, 0x00, 0x40, 0x00, 0xc0, 0x03, 0x80, 0x02, 0x40, 0x00, 0x40, 0x00, 0x40, 0xfc, 
	0x44, 0xc0, 0x03, 0x00, 0x06, 0x52, 0x03, 0x08, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x44, 0x10, 
	0x81, 0x00, 0x08, 0x04, 0x0a, 0x22, 0x03, 0x00, 0x14, 0x20, 0x09, 0x21, 0x00, 0x00, 0x11, 0x00, 
	0x00, 0x40, 0x18, 0x10, 0x19, 0x40, 0x0b, 0x44, 0x0a, 0x02, 0x18, 0x00, 0x80, 0x40, 0x86, 0x00, 
	0x00, 0x00, 0x68, 0x81, 0x40, 0x03, 0x44, 0x03, 0x00, 0x00, 0x68, 0x0b, 0x42, 0x0b, 0x01, 0x0b, 
	0x51, 0x03, 0x40, 0x00, 0x68, 0x0b, 0x44, 0x03, 0x48, 0x09, 0x41, 0x13, 0x60, 0x04, 0x44, 0x09, 
	0x40, 0x44, 0x60, 0x00, 0x44, 0x03, 0x40, 0x00, 0x68, 0x03, 0x48, 0x81, 0x80, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x9c, 0x00, 0x00, 0x00, 
	0x40, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x03, 0x40, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0x40, 0x03, 0x00, 0x02, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0x00, 0x03, 0x00, 0x01, 0x40, 0x03, 0x40, 0x03, 0x00, 0x03, 0x00, 0xca, 0x02, 0x00, 0x00, 0x40, 
	0x07, 0x51, 0x27, 0x60, 0x08, 0x01, 0x00, 0x40, 0x10, 0x50, 0x23, 0x60, 0x10, 0x40, 0x05, 0x42, 
	0x01, 0x40, 0x40, 0x60, 0x1a, 0x50, 0x10, 0x60, 0x15, 0x40, 0x00, 0x51, 0x00, 0x41, 0x11, 0x40, 
	0x2b, 0x50, 0x09, 0x44, 0x00, 0x40, 0x08, 0x54, 0x07, 0xd2, 0xc6, 0x02, 0x00, 0x00, 0x54, 0x04, 
	0x02, 0x08, 0x00, 0x00, 0x00, 0x00, 0x40, 0x04, 0x18, 0x03, 0x40, 0x83, 0x20, 0x00, 0x00, 0x86, 
	0x50, 0x00, 0x00, 0x03, 0x00, 0x04, 0x68, 0x08, 0x00, 0x82, 0x00, 0x04, 0x00, 0x02, 0x00, 0x80, 
	0x10, 0x03, 0x68, 0x00, 0x48, 0x00, 0x00, 0x17, 0xc0, 0x93, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x40, 0xda, 0x02, 0x80, 0x00, 0x40, 0x00, 0x40, 0x02, 
	0xc0, 0x00, 0x00, 0x00, 0x40, 0x02, 0x40, 0x03, 0x40, 0x03, 0x40, 0x00, 0x80, 0x01, 0x40, 0x02, 
	0xc0, 0x03, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0xc0, 0x00, 0x40, 0x03, 
	0x00, 0x02, 0x40, 0x02, 0x40, 0x03, 0xc0, 0x83, 0x02, 0x40, 0x00, 0x00, 0x11, 0xd0, 0x03, 0x41, 
	0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x03, 0x00, 0x2b, 0x40, 0x42, 0x00, 0x85, 0x40, 
	0x17, 0xc0, 0x00, 0xc2, 0x03, 0x04, 0x08, 0x21, 0x00, 0x04, 0x18, 0x40, 0x00, 0x00, 0x4b, 0xc0, 
	0x0a, 0x22, 0x15, 0x00, 0x83, 0x90, 0xa9, 0x08, 0x41, 0x07, 0x41, 0x03, 0x41, 0x03, 0x41, 0x00, 
	0x00, 0x00, 0x44, 0x07, 0x68, 0x03, 0x48, 0x03, 0x48, 0x01, 0x40, 0x21, 0x60, 0x83, 0x60, 0x03, 
	0x48, 0x08, 0x40, 0x04, 0x48, 0x02, 0x42, 0x00, 0x42, 0x48, 0x60, 0x43, 0x50, 0x03, 0x40, 0x00, 
	0x42, 0x08, 0x64, 0x07, 0x80, 0x81, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x00, 0x9d, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x03, 0x40, 0x00, 0x40, 0x03, 0x40, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x03, 0x00, 0x03, 
	0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xdf, 0x42, 0x50, 0x41, 0x50, 0x18, 0x60, 0x0a, 0x62, 0x05, 0x02, 0x00, 0x60, 
	0x13, 0x40, 0x04, 0x61, 0x03, 0x60, 0x07, 0x41, 0x00, 0x40, 0x89, 0x40, 0x17, 0x50, 0x13, 0x40, 
	0x41, 0x60, 0x04, 0x62, 0x88, 0x50, 0x10, 0x40, 0x28, 0x40, 0x0b, 0x44, 0x03, 0x50, 0x20, 0x40, 
	0x80, 0xc0, 0xf5, 0x0a, 0x21, 0x88, 0x20, 0x04, 0x00, 0x04, 0x00, 0x03, 0x00, 0x80, 0x20, 0x06, 
	0x48, 0x08, 0x41, 0x03, 0x52, 0x04, 0x01, 0x0a, 0x24, 0x00, 0x04, 0x03, 0x00, 0x00, 0x00, 0x0a, 
	0x68, 0x00, 0x28, 0x84, 0x00, 0x00, 0x00, 0x80, 0x00, 0x05, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 
	0xc0, 0xd2, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x9f, 0x02, 0x40, 0x00, 0xc0, 0x02, 0xc0, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x40, 0x03, 0x40, 0x02, 
	0x40, 0x03, 0x40, 0x00, 0x00, 0x02, 0xc0, 0x00, 0xc0, 0x02, 0xc0, 0x00, 0x40, 0x00, 0x40, 0x00, 
	0x40, 0x00, 0x40, 0x02, 0x40, 0x00, 0x40, 0x01, 0x00, 0x01, 0x40, 0x03, 0x40, 0x00, 0x40, 0xfa, 
	0x00, 0x04, 0x40, 0x40, 0x00, 0x44, 0x10, 0x40, 0x0b, 0xc1, 0x00, 0x00, 0x43, 0x20, 0x01, 0x22, 
	0x00, 0xc0, 0x11, 0x10, 0x02, 0x41, 0x0b, 0x61, 0x1b, 0x40, 0x00, 0xc0, 0x40, 0x00, 0x25, 0xc0, 
	0x00, 0xe2, 0x18, 0x00, 0x00, 0x10, 0x02, 0x02, 0x0a, 0x02, 0x03, 0x00, 0x00, 0x40, 0xdb, 0x00, 
	0x41, 0x06, 0x68, 0x07, 0x44, 0x0b, 0x48, 0x01, 0x00, 0x00, 0x64, 0x08, 0x48, 0x08, 0x41, 0x23, 
	0x50, 0x00, 0x44, 0x03, 0x48, 0x07, 0x64, 0x83, 0x40, 0x09, 0x00, 0x00, 0x48, 0x03, 0x68, 0x0b, 
	0x41, 0x09, 0x48, 0x08, 0x42, 0x07, 0x48, 0x08, 0x44, 0x43, 0x40, 0x01, 0x01, 0xa4, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x01, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x9f, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x40, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x40, 0x00, 0x00, 0x03, 
	0x40, 0x00, 0x00, 0x03, 0x40, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0x00, 0x02, 0x40, 0x03, 0x00, 0x00, 0x40, 0x03, 0x40, 0x00, 0x00, 0xef, 0x02, 0x50, 0x40, 0x40, 
	0x01, 0x61, 0x00, 0x64, 0x04, 0x01, 0x00, 0x40, 0x20, 0x60, 0x13, 0x60, 0x18, 0x40, 0x0b, 0x64, 
	0x04, 0x61, 0x43, 0x40, 0x04, 0x51, 0x11, 0x00, 0x00, 0x60, 0x04, 0x41, 0x10, 0x60, 0x01, 0x62, 
	0x20, 0x50, 0x13, 0x50, 0x43, 0x60, 0x08, 0x62, 0x08, 0xd2, 0xa4, 0x02, 0x21, 0x89, 0x20, 0x04, 
	0x41, 0x08, 0x44, 0x08, 0x00, 0x00, 0x02, 0x04, 0x00, 0x03, 0x40, 0x03, 0x02, 0x06, 0x40, 0x00, 
	0x08, 0x02, 0x44, 0x00, 0x08, 0x04, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00, 0x01, 0x28, 0x00, 0x04, 
	0x44, 0x20, 0x20, 0x00, 0x48, 0x00, 0x40, 0x00, 0x48, 0xf7, 0x00, 0x40, 0x01, 0x40, 0x00, 0x40, 
	0x01, 0x40, 0x03, 0x40, 0x00, 0x40, 0x00, 0x40, 0x03, 0x40, 0x03, 0x40, 0x00, 0x40, 0x00, 0x40, 
	0x03, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0x01, 0x40, 0x00, 0x40, 
	0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 0x40, 0xde, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0x00, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 
	0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0xe8, 0x02, 0xc0, 0x41, 0xc0, 0x03, 0xe4, 0x00, 0xe1, 
	0x03, 0x02, 0x00, 0x50, 0x01, 0xc4, 0x03, 0x00, 0x03, 0x20, 0x00, 0x04, 0x00, 0x10, 0x1b, 0x20, 
	0x00, 0x10, 0x10, 0x00, 0x00, 0xd0, 0x40, 0x00, 0x00, 0x10, 0x00, 0x54, 0x20, 0xe0, 0x03, 0xc0, 
	0x04, 0x22, 0x15, 0x00, 0x04, 0x21, 0xd5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xe9, 0x00, 0x00, 0x00, 0x08, 0x02, 0x08, 0x00, 0x48, 0x00, 0x00, 
	0x02, 0x08, 0x02, 0x08, 0x00, 0x08, 0x02, 0x48, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 
	0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x02, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 
	0x00, 0x08, 0x00, 0x00, 0xd2, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x02, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 
	0x08, 0x00, 0x82, 0x00, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x80, 0xf9, 0x00, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x05, 0x00, 0xa0, 0x00, 0x00, 
	0x00, 0x10, 0x00, 0x00, 0x20, 0x00, 0x00, 0x80, 0x00, 0x04, 0x40, 0x00, 0x00, 0x80, 0x80, 0x02, 
	0x00, 0x00, 0xdc, 0x00, 0x20, 0x80, 0x00, 0x40, 0x01, 0x80, 0x01, 0x20, 0x00, 0x00, 0x01, 0x08, 
	0x00, 0x04, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x20, 0x00, 0x48, 0x88, 
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x40, 0x01, 0x80, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0xe1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x10, 
	0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x20, 0x04, 0x00, 
	0x20, 0xc0, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x20, 0x00, 0x08, 0x80, 0x00, 0x00, 
	0xf5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x40, 0x00, 
	0x80, 0x04, 0x00, 0x00, 0x00, 0x80, 0xa0, 0x00, 0x00, 0xa0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x80, 0xb4, 
	0x04, 0x00, 0x08, 0x01, 0x00, 0x00, 0x02, 0x02, 0x00, 0x20, 0x80, 0x00, 0x00, 0x00, 0x00, 0x20, 
	0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x00, 0x04, 
	0x40, 0x00, 0x04, 0x80, 0x00, 0x10, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x20, 0xb9, 0x00, 
	0x0a, 0x20, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x20, 0x42, 
	0x01, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0xc4, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x20, 0xc4, 0x01, 0x00, 0x20, 0x40, 0x02, 0x00, 0x00, 0x00, 0x21, 0x04, 0x80, 0xf1, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0c, 0x00, 0x04, 0x40, 0x00, 0x00, 0x80, 0x10, 0x00, 0x00, 0x00, 0x20, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x02, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x48, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x80, 0xe9, 0x02, 0x00, 0x04, 
	0x00, 0x00, 0x00, 0x04, 0x00, 0x10, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 
	0x10, 0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x00, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x01, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x80, 0xbe, 0x00, 0x00, 0x00, 0x00, 
	0x40, 0x02, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 
	0x80, 0x00, 0x00, 0x01, 0x40, 0x02, 0x00, 0x01, 0x00, 0x10, 0x00, 0x01, 0x00, 0x20, 0x00, 0x00, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x80, 0x80, 0xf3, 0x00, 0x40, 0x40, 0x01, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
	0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x08, 0x10, 0x11, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x20, 0x81, 0xe7, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 
	0x00, 0x00, 0x10, 0x00, 0x00, 0x40, 0x00, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x02, 0x00, 0x08, 0x80, 0x02, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
	0x00, 0x04, 0x80, 0x00, 0x48, 0x00, 0x00, 0x80, 0x86, 0x00, 0x00, 0x00, 0x26, 0x02, 0x00, 0x60, 
	0x00, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x80, 
	0x10, 0x00, 0x00, 0x00, 0x02, 0x04, 0x20, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x04, 0x10, 0x02, 
	0x24, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x8c, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x10, 0x20, 
	0x00, 0x00, 0x80, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x10, 0x00, 0x00, 0x20, 
	0x00, 0x00, 0x00, 0x00, 0x42, 0x00, 0x20, 0x00, 0x40, 0x00, 0x00, 0x00, 0x12, 0x01, 0x00, 0x00, 
	0x10, 0x00, 0x00, 0x00, 0x80, 0x80, 0xae, 0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x08, 0x08, 0x00, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x40, 0x80, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x04, 0x00, 0x00, 
	0x20, 0x00, 0x22, 0x00, 0x10, 0xbb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x10, 0x00, 0x00, 0x00, 0x40, 0x00, 0x08, 0x00, 0x02, 0x04, 0x14, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x10, 0x00, 0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x40, 0x30, 0x00, 0x00, 0xae, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x40, 0x00, 0x08, 0x00, 0x04, 0x00, 
	0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x30, 0x20, 0x10, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x10, 
	0x10, 0x00, 0x00, 0xfc, 0x04, 0x03, 0x20, 0x00, 0x00, 0x46, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 
	0x00, 0x00, 0x08, 0x00, 0x00, 0x04, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x44, 0x00, 0xa0, 0x20, 
	0x20, 0x00, 0x00, 0x00, 0x20, 0x00, 0x40, 0x00, 0x00, 0x10, 0x02, 0x00, 0x04, 0x00, 0x00, 0x40, 
	0x00, 0xa0, 0xf3, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x40, 0x20, 0x04, 0x40, 0x00, 0x88, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 
	0x20, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x40, 
	0x80, 0xea, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x14, 0x00, 0x00, 0x40, 0x41, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x20, 0x04, 
	0x22, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x20, 0x00, 0x00, 0x00, 0x80, 
	0xd4, 0x00, 0x00, 0x00, 0x40, 0x28, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x80, 0x00, 0x10, 0x40, 0x00, 0x00, 0x08, 0x80, 0x00, 0x00, 0x00, 0x08, 0x02, 0x00, 0x00, 0x00, 
	0xa0, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x80, 0x00, 0x00, 0x02, 0x00, 0x08, 0x00, 0x00, 0x86, 
	0x04, 0x00, 0x20, 0x00, 0x04, 0x80, 0x00, 0x20, 0x00, 0x04, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x80, 0x08, 0x00, 0x00, 0x00, 0x40, 0x40, 0x24, 0x00, 0x00, 0x04, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x08, 0x00, 0x00, 0x00, 0x00, 0x84, 0xde, 0x00, 
	0x20, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x20, 0x08, 
	0x14, 0x20, 0x00, 0x08, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x42, 0x00, 
	0x21, 0x00, 0x00, 0x40, 0x20, 0x0c, 0x10, 0x00, 0x20, 0x00, 0x20, 0x00, 0x80, 0xf1, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x20, 0x00, 0x00, 0x88, 
	0x00, 0x08, 0x10, 0x00, 0x00, 0x20, 0x00, 0x00, 0x20, 0x80, 0x00, 0x00, 0x08, 0x00, 0x00, 0x02, 
	0x04, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 0x80, 0x00, 0x20, 0xf6, 0x18, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x88, 0x00, 0x00, 0x20, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x02, 0x00, 0x00, 0x40, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x24, 0x10, 
	0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x80, 0xdf, 0x00, 0x04, 0x00, 0x00, 
	0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 
	0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x80, 0x04, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 
	0x08, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x44, 0x00, 0x80, 0xc2, 0x40, 0x00, 0x00, 0x00, 0x04, 
	0x00, 0x00, 0x20, 0x08, 0x00, 0x00, 0x10, 0x00, 0x20, 0x00, 0x00, 0x04, 0x20, 0x00, 0x40, 0x00, 
	0x12, 0x00, 0x00, 0x48, 0x34, 0x00, 0x10, 0x00, 0x12, 0x10, 0x10, 0x04, 0xd0, 0x08, 0x00, 0x08, 
	0x10, 0x00, 0x08, 0x04, 0x00, 0x40, 0x00, 0x00, 0x80, 0xaa, 0x80, 0x00, 0x06, 0x00, 0x10, 0x90, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 
	0x00, 0x91, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x20, 0x01, 0x00, 0x00, 
	0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x04, 0xa6, 0x00, 0x60, 0x00, 0x82, 0x10, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0xc0, 0x00, 0x80, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x04, 0x00, 0x04, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0xec, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x02, 0x88, 
	0x00, 0x08, 0x00, 0x00, 0x10, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x28, 0x00, 0x48, 0x40, 0x08, 
	0x08, 0x08, 0x10, 0x08, 0x00, 0x00, 0x02, 0x04, 0x00, 0x84, 0x00, 0x04, 0x00, 0x60, 0x10, 0x04, 
	0x02, 0x04, 0x00, 0x00, 0x00, 0x06, 0xa5, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x40, 0x00, 0x80, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x9c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x40, 0x00, 
	0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 
	0x00, 0x02, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 
	0x40, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x02, 0x40, 0x42, 0x40, 0x12, 0x40, 0x0a, 0x42, 0x02, 0x40, 
	0x02, 0x40, 0x02, 0x40, 0x02, 0x00, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 
	0x02, 0x40, 0x02, 0x00, 0x02, 0x40, 0x02, 0x40, 0x00, 0x40, 0x00, 0x40, 0x02, 0x40, 0x02, 0x00, 
	0x00, 0x80, 0xe9, 0x00, 0x00, 0x02, 0x40, 0x0a, 0x40, 0x02, 0x40, 0x12, 0x40, 0x02, 0x40, 0x02, 
	0x40, 0x02, 0x40, 0x02, 0x40, 0x12, 0x40, 0x02, 0x40, 0x02, 0x40, 0x0a, 0x40, 0x02, 0x40, 0x02, 
	0x52, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x00, 
	0x80, 0xad, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x40, 0x00, 0x00, 0x02, 0x00, 
	0x02, 0x00, 0x00, 0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x40, 
	0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 
	0xba, 0x00, 0x00, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 
	0x40, 0x02, 0x00, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 
	0x00, 0x02, 0x40, 0x02, 0x40, 0x00, 0x40, 0x00, 0x40, 0x02, 0x40, 0x02, 0x00, 0x00, 0x00, 0x98, 
	0x00, 0x00, 0x02, 0x40, 0x00, 0x42, 0x00, 0x40, 0x00, 0x50, 0x02, 0x40, 0x1a, 0x40, 0x1a, 0x40, 
	0x02, 0x00, 0x02, 0x50, 0x02, 0x40, 0x02, 0x40, 0x02, 0x41, 0x1a, 0x40, 0x1a, 0x40, 0x02, 0x00, 
	0x02, 0x40, 0x02, 0x40, 0x00, 0x40, 0x00, 0x40, 0x02, 0x40, 0x06, 0x04, 0x00, 0x80, 0xff, 0xff, 
	0xff, };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2enc\specific\iVacAPI.h ===
//********************* FILE DESCRIPTION *******************************
//
//  THIS SDK INCLUDING CODE, BINARIES, AND INFORMATION IS PROVIDED "AS IS" WITHOUT 
//  WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED 
//  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
// FILE NAME:  DOAPI.H
//
// COPYRIGHT:		    Company Confidential
//		          Copyright (c) iCompression, Inc. 1997,1998,1999
//			             All Rights Reserved
//
// VERSION: Pre-release
//
// FUNCTION: FW Maibox interface prototypes and defines
//
// DEPENDENCIES: NONE
// RESTRICTIONS: NONE
//
// EXTERNAL REFERENCES:  none.
//
// MODIFICATION HISTORY:
// DATE			DEVELOPER		CHANGE DESCRIPTION
// 01/30/98		Deb Chatterjee	Original creation
// 02/10/98		A. Mobini		Translation to 'C' and separation of OS dependencies
// 10/21/99		Martin Stephan, VIONA Development GmbH, several changes to adapt to our software architecture
//**********************************************************************
#ifndef _DOAPI_H
#define _DOAPI_H

#include <fwid.h>

#ifndef _WDM_
#ifndef _EXTERN
#define _EXTERN
#endif
#endif // _WDM_

#define MAX_PARAMS 8
#define MAX_QUEUED_MAILBOX_COMMANDS 10
#define API_CALL_SUCCESS 0
#define API_CALL_FAILURE 0xFFFFFFFF
#define MAILBOX_ADDRESS_INSIDE_FW 0xED00
#define MAILBOX_SIZE_IN_DWORDS 12
#define MAILBOX_SIZE_IN_BYTES 48
#define MAILBOX_FLAG_MAILBOX_FULL 1
#define MAILBOX_FLAG_PARAMETERS_SET 2
#define MAILBOX_FLAG_MAILBOX_READY 3
#define MAILBOX_FLAG_MAILBOX_DONE 7

typedef char CHAR;
typedef unsigned char UCHAR;
typedef unsigned char BYTE;
typedef BYTE * PBYTE;
typedef short SHORT;
typedef long LONG;
typedef unsigned short WORD;
typedef unsigned long DWORD;
#define VOID void
#define HANDLE VOID *	
#define open _open
#define read _read
#define filelength _filelength
#define close _close

#pragma pack(1)

enum eReturnCodes {
	RC_SUCCESS							= 0x00000000,	/* Successful completion */
	RC_ERROR_INVALIDPARAMETER			= 0x88000000,	/* One or more of the formal parameters are out of range */
	RC_ERROR_UNKOWN						= 0x88000001,	/* Unknown error */
	RC_ERROR_ROM_DOWNLOAD_FILEOPEN		= 0x88000010,	/* Error openning the rom file */
	RC_ERROR_ROM_DOWNLOAD_DATATXFER		= 0x88000020,	/* Error transferring the rom image to the device */
	RC_ERROR_DEVICE_UNINITIALIZED		= 0x88000100,	/* Error initializing the device */
	RC_ERROR_DEVICE_MEMWRITE			= 0x88000200,	/* Error writing to iVAC memory */
	RC_ERROR_DEVICE_MEMREAD				= 0x88000400,	/* Error reading from iVAC memory */
};

typedef enum
{
	WDM_DRIVER						= 0x00,
	VXD_DRIVER						= 0x01
} DRIVER_TYPE;

typedef enum
{
	PYTHON							= 0x00,
	PYTHON_DS						= 0x01,
	PYTHON_2						= 0x02
} BOARD_TYPE;

typedef enum
{
	PHILIPS_7111					= 0x00,
	PHILIPS_7114					= 0x01,
	MICRONAS						= 0x02
} DIGITIZER_TYPE;

typedef enum
{
	BOARD_6MEG						= 0x00,
	BOARD_12MEG						= 0x01
} BOARD_MEMORY;

typedef enum
{
	SUPPORTED_AUDIOSAMPLINGRATE_32		= 1,
	SUPPORTED_AUDIOSAMPLINGRATE_44		= 2,
	SUPPORTED_AUDIOSAMPLINGRATE_48		= 4
} SUPPORTED_AUDIO_FREQUENCIES;

typedef enum
{
	VIDEO_INPUT_656						= 0,
	VIDEO_INPUT_601						= 1,
} VIDEO_FORMAT;

typedef struct
{
	BOARD_TYPE		eBoardType;				// Python, Python DS, Python 2
	DIGITIZER_TYPE	eDigitizer;				// 7111, 7114, Micronas
	BOARD_MEMORY	eBoardMemory;			// 6 Meg, 12 Meg
	BYTE			bSupportedAudioFreq;	// Bitmask indicating which of 32, 44.1 and, 
											// 48 KHz frequencies are supported. the value 
											// is a OR between any of the values in 
											// SUPPORTED_AUDIO_FREQUENCIES
} BOARD_DESCRIPTION;

typedef enum
{
	MEMORY_SIZE						= 0x01,
	AUDIO_DIGITIZER					= 0x0E,
	VIDEO_INPUT_FORMAT				= 0x10,
	VIDEO_DIGITIZER					= 0xE0
} SUBVENDOR_ID_MASK;

typedef enum
{
	MEMORY_6						= 0x00,
	MEMORY_12						= 0x01,
	AUDIO_DIG_MIC_32				= 0x00,
	AUDIO_DIG_MIC_48				= 0x02,
	AUDIO_DIG_CRYSTAL				= 0x04,
	VIDEO_INPUT_FORMAT_656			= 0x00,
	VIDEO_INPUT_FORMAT_601			= 0x10,
	VIDEO_DIG_7111					= 0x00,
	VIDEO_DIG_7114					= 0x20,
	VIDEO_DIG_MICRONAS				= 0xE0
} SUBDEVICE_ID_VALUES;

typedef enum
{
	MPEG_COMPLIANT					= 0x01,
	NON_MPEG_COMPLIANT				= 0x00
} MPEG_COMPLIANCE;

typedef enum 
{
	PROP_STREAMOUTPUT_ELEMENTARY	= 0x00,
	PROP_STREAMOUTPUT_PROGRAM		= 0x01,
	PROP_STREAMOUTPUT_TRANSPORT		= 0x02,
	PROP_STREAMOUTPUT_PES			= 0x03,	//Not supported
	PROP_STREAMOUTPUT_MPEG1			= 0x04
} OUTPUT_TYPE;

typedef enum 
{
	PROP_VIDEOINPUT_YC					= 0x00,
	PROP_VIDEOINPUT_COMPOSITE			= 0x01
} VIDEO_INPUT_TYPE;

typedef enum
{
	PROP_VIDEORESOLUTION_720x480		= 0,
	PROP_VIDEORESOLUTION_576x576		= 0, // For PAL
	PROP_VIDEORESOLUTION_480x480		= 1,
	PROP_VIDEORESOLUTION_480x576		= 1, // For PAL
	PROP_VIDEORESOLUTION_352x480		= 2,
	PROP_VIDEORESOLUTION_352x576		= 2, // For PAL
	PROP_VIDEORESOLUTION_352x240		= 2  // For MPEG1
} VIDEO_RESOLUTION;

typedef enum
{
	PROP_TVFORMAT_NTSC		= 0,
	PROP_TVFORMAT_PAL		= 1
} TV_ENCODE_FORMAT;

typedef enum
{
	PROP_ASPECTRATIO_4X3			= 0x00,
	PROP_ASPECTRATIO_PANSCAN		= 0x01,
	PROP_ASPECTRATIO_16X9			= 0X02
} ASPECT_RATIO;

typedef enum
{
	PROP_MPEGAUDIOLAYER_I			= 0x03,
	PROP_MPEGAUDIOLAYER_II			= 0x02,
	PROP_MPEGAUDIOLAYER_III			= 0x01,
} MPEG_AUDIO_LAYER;

typedef enum
{
	PROP_AUDIOSAMPLINGRATE_32		= 0x02,
	PROP_AUDIOSAMPLINGRATE_44		= 0x00,
	PROP_AUDIOSAMPLINGRATE_48		= 0x01,
	PROP_AUDIOSAMPLINGRATE_UNSUPPORTED = 0x10
} SAMPLING_RATE;

typedef enum
{	
	PROP_AUDIOOUTPUTMODE_MONO		= 0x03,
	PROP_AUDIOOUTPUTMODE_STEREO		= 0x00,
	PROP_AUDIOOUTPUTMODE_DUAL		= 0x02,
	PROP_AUDIOOUTPUTMODE_JOINT		= 0x01
} AUDIO_OUTPUT_MODE;

typedef enum
{
	PROP_AUDIOCRC_OFF				= 0x00,
	PROP_AUDIOCRC_ON				= 0x01
} CRC_STATE;

typedef enum
{
	PROP_VIDEOGOPSTRUCT_IBP			= 0x00,
	PROP_VIDEOGOPSTRUCT_IP			= 0x01,
	PROP_VIDEOGOPSTRUCT_I			= 0x02
} GOP_STRUCTURE;

typedef enum
{
	PROP_AUDIOENCODINGMODE_MPEG				= 0x00,
	PROP_AUDIOENCODINGMODE_DOLBY_DIGITAL	= 0x01,
	PROP_AUDIOENCODINGMODE_LPCM				= 0x02
} AUDIO_ENCODING_MODE;

typedef struct
{
	DWORD		dwTime;
	DWORD		dwVideoFrames;
} CAPTURE_STATUS;

typedef enum
{
	RC_VIDEOENCODINGMODE_VBR	= 0x00,
	RC_VIDEOENCODINGMODE_CBR	= 0x01
}  BITRATE_MODE;

typedef struct
{
	BITRATE_MODE	bEncodingMode;	// Variable or Constant bit rate
	WORD			wBitrate;		// Actual bitrate in 1/400 mbits/sec
	BYTE			bVariance;		// 1-100 as a percentage of variance
} VIDEO_BITRATE;

typedef enum
{
	DATARATE_LAYERII_64			= 0x04,
	DATARATE_LAYERII_96			= 0x06,
	DATARATE_LAYERII_112		= 0x07,
	DATARATE_LAYERII_128		= 0x08,
	DATARATE_LAYERII_160		= 0x09,
	DATARATE_LAYERII_192		= 0x0A,
	DATARATE_LAYERII_224		= 0x0B,
	DATARATE_LAYERII_256		= 0x0C,
	DATARATE_LAYERII_320		= 0x0D,
	DATARATE_LAYERII_384		= 0x0E
} AUDIO_DATARATE_LAYER_II;

#ifdef MINIDRIVER
typedef enum 
{
	STATE_STOPPED   = 0x00,
    STATE_PAUSED    = 0x01,
    STATE_RUNNING   = 0x02
}  RUN_STATE;
#endif // #ifdef MINIDRIVER

//
// definition of the full HW device extension structure This is the structure
// that will be allocated in HW_INITIALIZATION by the stream class driver
// Any information that is used in processing a device request (as opposed to
// a STREAM based request) should be in this structure.  A pointer to this
// structure will be passed in all requests to the minidriver. (See
// HW_STREAM_REQUEST_BLOCK in STRMINI.H)
//


typedef struct {
    DWORD mailBoxFlag; /* Bit 0 = 0 -> empty, 1 -> full */
                     /* Bit 1 = 0 -> input parameters have been set,
                              = 1 -> input parameters are not valid */
                     /* Bit 2 = 1 - > if the call has been processed,
                              = 0 - >otherwise */
    DWORD commandCode;  /* Each API function will have a command code */
    DWORD returnCode;   /* Return code = 0 for success, -1 for failure */
    DWORD timeToLive;   /* Explained later */
    DWORD parameterBuffer[MAX_PARAMS];
                      /* Same buffer will be shared between input and
                         output */
} FW_API_MAILBOX;

typedef enum eApiCommandCode
{
	ApiCommand_NoOperation = 0, 
	ApiCommand_StartCapture = 1, 
	ApiCommand_StopCapture = 2, 
	ApiCommand_SetAudioStreamID = 3,
	ApiCommand_GetAudioStreamID = 4,
	ApiCommand_SetVideoStreamID = 5,
	ApiCommand_GetVideoStreamID = 6,
	ApiCommand_SetPrivateStreamID = 7,
	ApiCommand_GetPrivateStreamID = 8,
	ApiCommand_SetAudioPID = 9,
	ApiCommand_GetAudioPID = 10,
	ApiCommand_SetVideoPID = 11,
	ApiCommand_GetVideoPID = 12,
	ApiCommand_SetAuxPID = 13,
	ApiCommand_GetAuxPID = 14,
	ApiCommand_SetVideoResolution = 15,
	ApiCommand_GetVideoResolution = 16,
	ApiCommand_SetVideoBitRate = 17,
	ApiCommand_GetVideoBitRate = 18,
	ApiCommand_SetGOPSize = 19,
	ApiCommand_GetGOPSize = 20,
	ApiCommand_SetPredictionDistance = 21,
	ApiCommand_GetPredictionDistance = 22,
	ApiCommand_SetTVEncodingFormat = 23,
	ApiCommand_GetTVEncodingFormat = 24,
	ApiCommand_SetAspectRatio = 25,
	ApiCommand_GetAspectRatio = 26,
	ApiCommand_SetStreamOutputType = 27,
	ApiCommand_GetStreamOutputType = 28,
	ApiCommand_SetMPEGAudioLayer = 29,
	ApiCommand_GetMPEGAudioLayer = 30,
	ApiCommand_SetAudioSamplingRate = 31,
	ApiCommand_GetAudioSamplingRate = 32,
	ApiCommand_SetAudioDataRate = 33,
	ApiCommand_GetAudioDataRate = 34,
	ApiCommand_SetAudioOutputMode = 35,
	ApiCommand_GetAudioOutputMode = 36,
	ApiCommand_SetAudioCRCState = 37,
	ApiCommand_GetAudioCRCState = 38,
	ApiCommand_ReadIOPort = 39,
	ApiCommand_WriteIOPort = 40,
	ApiCommand_SetupDMATxfer = 41,
	ApiCommand_DownloadROMFile = 42, 
	ApiCommand_SetCroppingFormat = 43,
	ApiCommand_GetCroppingFormat = 44,
	ApiCommand_SetVideoInputType = 45,
	ApiCommand_GetVideoInputType = 46,
	ApiCommand_SetGOPStructure = 47,
	ApiCommand_GetGOPStructure = 48,
	ApiCommand_SetVideoDigitizer = 55,
	ApiCommand_GetVideoDigitizer = 56,
	ApiCommand_SetVideoMemoryMode = 57,
	ApiCommand_GetVideoMemoryMode = 58,
	ApiCommand_SetVideoD1Or601 = 59,
	ApiCommand_GetVideoD1Or601 = 60,
	ApiCommand_SetVideoPSCompliance = 61,
	ApiCommand_GetVideoPSCompliance = 62
} API_COMMAND_CODE;

#pragma pack()
	
#ifdef __cplusplus
extern "C"
{
#endif

_EXTERN FW_IDENTIFICATION_STRUCTURE g_FWId;
_EXTERN DWORD g_dwAPIStatus;
_EXTERN DWORD g_dwMailBoxAddress;
_EXTERN FW_API_MAILBOX g_fwApiMailBox;

_EXTERN VOID InitializeMailBox(VOID *pHwDevExt, int paramA);
#ifdef _WIN32_WCE
DWORD DownloadROMFile(VOID *pHwDevExt, LPCTSTR kszFileName, BYTE bOutputStreamType);
#else
_EXTERN DWORD DownloadROMFile(VOID *pHwDevExt, BYTE *Filename, BYTE bOutputStreamType);
#endif
_EXTERN DWORD NoOp(VOID *pHwDevExt);
_EXTERN DWORD StartCapture(VOID *pHwDevExt);	
_EXTERN DWORD StopCapture(VOID *pHwDevExt);	
_EXTERN DWORD SetAudioStreamID(VOID *pHwDevExt, WORD wStreamNumber, WORD wStreamID );	
_EXTERN DWORD GetAudioStreamID(VOID *pHwDevExt, WORD wStreamNumber, WORD *pbStreamID);
_EXTERN DWORD SetVideoStreamID(VOID *pHwDevExt, WORD wStreamNumber, WORD wStreamID);
_EXTERN DWORD GetVideoStreamID(VOID *pHwDevExt, WORD wStreamNumber, WORD *pwStreamID);
_EXTERN DWORD SetPrivateStreamID(VOID *pHwDevExt, WORD wStreamNumber, WORD wStreamID);
_EXTERN DWORD GetPrivateStreamID(VOID *pHwDevExt, WORD wStreamNumber, WORD *pwStreamID);
_EXTERN DWORD SetAudioPID(VOID *pHwDevExt, WORD wStreamNumber, WORD wPID);
_EXTERN DWORD GetAudioPID(VOID *pHwDevExt, WORD wStreamNumber, WORD *pwPID);
_EXTERN DWORD SetVideoPID(VOID *pHwDevExt, WORD wStreamNumber, WORD wPID);
_EXTERN DWORD GetVideoPID(VOID *pHwDevExt, WORD wStreamNumber, WORD *pwPID);
_EXTERN DWORD SetAuxPID(VOID *pHwDevExt, WORD wStreamNumber, WORD wPID);
_EXTERN DWORD GetAuxPID(VOID *pHwDevExt, WORD wStreamNumber, WORD *pwPID);
_EXTERN DWORD SetVideoResolution(VOID *pHwDevExt, BYTE bResolutionIndex);
_EXTERN DWORD GetVideoResolution(VOID *pHwDevExt, BYTE *pbResolutionIndex);
_EXTERN DWORD SetVideoBitRate(VOID *pHwDevExt, BYTE bEncodingMode, WORD wVideoBitrate, BYTE bVariance);
_EXTERN DWORD GetVideoBitRate(VOID *pHwDevExt, BYTE *pbEncodingMode, WORD *pwVideoBitrate, BYTE *pbVariance);
_EXTERN DWORD SetGOPSize(VOID *pHwDevExt, BYTE bGOPSize);
_EXTERN DWORD GetGOPSize(VOID *pHwDevExt, BYTE *pbGOPSize);
_EXTERN DWORD SetPredictionDistance(VOID *pHwDevExt, WORD wDistance);
_EXTERN DWORD GetPredictionDistance(VOID *pHwDevExt, WORD *pwDistance);
_EXTERN DWORD SetTVEncodingFormat(VOID *pHwDevExt, BYTE bTVFormat);
_EXTERN DWORD GetTVEncodingFormat(VOID *pHwDevExt, BYTE *pbTVFormat);
_EXTERN DWORD SetCroppingFormat(VOID *pHwDevExt, BYTE bCrop);
_EXTERN DWORD GetCroppingFormat(VOID *pHwDevExt, BYTE *pbCrop);
_EXTERN DWORD SetAspectRatio(VOID *pHwDevExt, BYTE bAspectRatio);
_EXTERN DWORD GetAspectRatio(VOID *pHwDevExt, BYTE *pbAspectRatio);
_EXTERN DWORD SetStreamOutputType(VOID *pHwDevExt, BYTE bOutputType);
_EXTERN DWORD GetStreamOutputType(VOID *pHwDevExt, BYTE *pbOutputType);
_EXTERN DWORD SetMPEGAudioLayer(VOID *pHwDevExt, BYTE bMPEGAudLayer);
_EXTERN DWORD GetMPEGAudioLayer(VOID *pHwDevExt, BYTE *pbMPEGAudLayer);
_EXTERN DWORD SetAudioSamplingRate(VOID *pHwDevExt, BYTE bSamplingRate);
_EXTERN DWORD GetAudioSamplingRate(VOID *pHwDevExt, BYTE *pbSamplingRate);
_EXTERN DWORD SetAudioDataRate(VOID *pHwDevExt, BYTE bDataRate);	
_EXTERN DWORD GetAudioDataRate(VOID *pHwDevExt, BYTE *pbDataRate);
_EXTERN DWORD SetAudioOutputMode(VOID *pHwDevExt, BYTE bOutputMode);
_EXTERN DWORD GetAudioOutputMode(VOID *pHwDevExt, BYTE *pbOutputMode);
_EXTERN DWORD SetAudioCRCState(VOID *pHwDevExt, BYTE bCRCState);
_EXTERN DWORD GetAudioCRCState(VOID *pHwDevExt, BYTE *pbCRCState);
_EXTERN DWORD ReadIOPort(VOID *pHwDevExt, BYTE bPortID, DWORD dwReg, DWORD *pdwValue);
_EXTERN DWORD WriteIOPort(VOID *pHwDevExt, BYTE bPortID, DWORD dwReg, DWORD dwValue);
_EXTERN DWORD SetupDMATxfer(VOID *pHwDevExt, DWORD dwSrc, DWORD dwDst, DWORD dwSize);
_EXTERN DWORD PostGenericRequest(VOID *pHwDevExt, FW_API_MAILBOX *data);
_EXTERN DWORD SetVideoInputType(VOID *pHwDevExt, BYTE bVideoInput);
_EXTERN DWORD GetVideoInputType(VOID *pHwDevExt, BYTE * pbVideoInput);
_EXTERN DWORD SetGOPStructure(VOID *pHwDevExt, BYTE eGOPStructure);
_EXTERN DWORD GetGOPStructure(VOID *pHwDevExt, BYTE * eGOPStructure);
_EXTERN DWORD SetVideoDigitizer(VOID *pHwDevExt, BYTE bVideoDigitizer);
_EXTERN DWORD GetVideoDigitizer(VOID *pHwDevExt, BYTE *pbVideoDigitizer);
_EXTERN DWORD SetVideoMemoryMode(VOID *pHwDevExt, BYTE bMemoryMode);
_EXTERN DWORD GetVideoMemoryMode(VOID *pHwDevExt, BYTE *pbMemoryMode);
_EXTERN DWORD SetVideoInputFormat(VOID *pHwDevExt, BYTE bVideoInputFormat);
_EXTERN DWORD GetVideoInputFormat(VOID *pHwDevExt, BYTE *pbVideoInputFormat);
_EXTERN DWORD SetVideoMpegCompliance(VOID *pHwDevExt, BYTE bMpegCompliance);
_EXTERN DWORD GetVideoMpegCompliance(VOID *pHwDevExt, BYTE *pbMpegCompliance);

//PRIVATE FUNCTIONS
_EXTERN DWORD ExecuteApiRequest(VOID *pHwDevExt, FW_API_MAILBOX *pfwApiMailBox);
_EXTERN DWORD GetMailBoxAddress(VOID *pHwDevExt);
//TEMPORARY API - FOR FILTER USE ONLY
//GetVideoResolution should be used
_EXTERN DWORD GetActualResolution(VOID *pHwDevExt, WORD *pwWidth, WORD *pwHeight);

#ifdef __cplusplus
}
#endif

#endif //_DOAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2enc\specific\iVac.h ===
// FILE:      library\hardware\mpeg2enc\specific\iVac.h
// AUTHOR:    Martin Stephan
// COPYRIGHT: (c) 1999 VIONA Development GmbH.  All Rights Reserved.
// CREATED:   
//
// PURPOSE:   iCompression iVac Encoder Chip class  --- header file 
//
// HISTORY:

#ifndef IVAC_H
#define IVAC_H

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"
#include "library\common\vddebug.h"
#include "library\lowlevel\intrctrl.h"
#include "library\hardware\mpeg2enc\generic\mpeg2enc.h"

class DataBuffer
	{
	public:
		Error Init(HPTR data, DWORD size);

	private:
		HPTR  data;			// pointer to address that should be filled with incoming data 
		DWORD size;			// size of data area 
	};

// the data buffer queue class manages data buffers that are sent from the application (or higher-level drivers)
//	to our driver. A data buffer itself (see the declaration above) exists of a pointer to the data and the size
//	of the buffer. 
class DataBufferQueue
	{
	public:
		DataBufferQueue(WORD size);
		~DataBufferQueue(void);

		Error Reset(void);
		Error InsertDataBuffer(HPTR data, DWORD size);
		Error GetDataBuffer(DataBuffer &buffer);
		WORD DataBufferAvailable() {return (first <= last) ? (last - first) : (sizeOfQueue + last - first);}

	private:
		DataBuffer * dataBuffer;
		int sizeOfQueue;		// size of data buffer queue
		int num;					// current number of data buffers in queue. Only valid when initialised with 1 buffer!!!
		int first, last;		// first and last data buffer
	};

//
// iVac encoder chip class
// 
// inherits from MPEG2AVEncoder, InterruptHandler, and VDSpinLock
// To synchronize the access to the device's registers you can use the VDSpinLock class. 
// This is mostly the case when the Interrupt Service Routine is doing a lot of access to the 
// device's registers. 
//	For example if you want to read or write to a register just call EnterLock() before and 
// LeaveLock() after the access:
// Function OutDWord()
//		{
//		EnterLock()
//		...
//		register access 
//		...
//		LeaveLock()
//		}
//
class IVACEncoder	: public MPEG2AVEncoder, protected InterruptHandler, protected VDSpinLock
	{
	friend class VirtualIVACEncoder;
	friend class IVACPCI;

	public:
		//IVACEncoder(DWordIndexedInOutPort * port);
		//IVACEncoder(MemoryMappedIO * mem, MemoryMappedIO * reg);
		IVACEncoder(InterruptServer * irqServer);
		~IVACEncoder();

		Error Initialize(void);
		void Interrupt(void);
		MPEGEncoderState CurrentState(void);

	protected:
		VirtualMPEG2AVEncoder * CreateVirtualMPEGEncoder(void);		

		DataBufferQueue				dataBuffers;
		DWordIndexedInOutPort	*	port;

		Error OutDWord(int idx, DWORD val);                             
		Error InDWord(int idx, DWORD __far&val);

		Error StartCapture(void);
		Error StopCapture(void);
		virtual Error PutBuffer(HPTR data, DWORD size);
		Error	AudioInterrupt(void);
		Error VideoInterrupt(void);
		Error SetOutputType(MPEGEncoderOutputType outputType);

	private:
		InterruptServer			*	irqServer;
		MPEGEncoderState			currentState;

		Error DownloadFirmware(void);

   };

//
// virtual iVac encoder chip class
//
class VirtualIVACEncoder : public VirtualMPEG2AVEncoder
	{
	public:
		VirtualIVACEncoder(IVACEncoder * encoder);

		Error Configure(TAG __far * tags);

	protected:

	private:
		IVACEncoder * encoder;

	};


#endif // IVAC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2enc\specific\IVacDev.h ===
// FILE:       library\hardware\mpeg2enc\specific\iVacDev.h
// AUTHOR:		Martin Stephan
// COPYRIGHT:	(c) 1999 Viona Development GmbH.  All Rights Reserved.
// CREATED:		21.10.1999
//
// PURPOSE: 	Interface between iVac API and the CineMaster Capture board class --- Header file
//
// HISTORY:
//

#ifndef IVACDEV_H
#define IVACDEV_H



#include "cinmenc.h"

#ifdef __cplusplus
extern "C"
{
#endif

_EXTERN void SetBoard(CineMasterCapture * capBoard);

#ifdef __cplusplus
}
#endif


#endif // IVACDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2enc\specific\ivacprop.h ===
// FILE:      library\hardware\mpeg2enc\specific\ivacprop.h
// AUTHOR:    Martin Stephan
// COPYRIGHT: (c) 1999 Viona Development GmbH. All Rights Reserved.
// CREATED:   19.10.1999
//
// PURPOSE:   Properties for the iVac Encoder Chip
//
// HISTORY:	  taken from the iCompression iVac WDM driver sources -> iVacCtrlProp.h


// ------------------------------------------------------------------------
// Property set for iVacControl
// ------------------------------------------------------------------------

#define STATIC_PROPSETID_IVAC_CONTROL\
    0xee6c0342, 0xe3a9, 0x11d2, 0xa5, 0x3e, 0x0, 0xa0, 0xc9, 0xef, 0x50, 0x6a
DEFINE_GUIDSTRUCT("0xee6c0342-0xe3a9-0x11d2-a53e-00a0c9ef506a", PROPSETID_IVAC_CONTROL);
#define PROPSETID_IVAC_CONTROL DEFINE_GUIDNAMED(PROPSETID_IVAC_CONTROL)

#define STATIC_PROPSETID_IVAC_PROPERTIES\
    0xd2185a40, 0x0398, 0x11d3, 0xa5, 0x3e, 0x0, 0xa0, 0xc9, 0xef, 0x50, 0x6a
DEFINE_GUIDSTRUCT("0xd2185a40-0x0398-0x11d3-a53e-00a0c9ef506a", PROPSETID_IVAC_PROPERTIES);
#define PROPSETID_IVAC_PROPERTIES DEFINE_GUIDNAMED(PROPSETID_IVAC_PROPERTIES)

typedef enum 
	{
	VIVACE_GET_IRQ_VAL,			// Get only
	VIVACE_GET_SDSMEM_VAL,		// Get only
	VIDACE_GET_REGMEM_VAL,		// Get only
   VIVACE_READ_REG_VAL,			// Get only
   VIVACE_WRITE_REG_VAL,		// Set only
	VIVACE_READ_MEM_VAL,			// Get only
	VIVACE_WRITE_MEM_VAL,		// Set only
	VIVACE_START_CAPTURE,		// Set only
	VIVACE_STOP_CAPTURE,			// Set only
	VIVACE_PREPARE_GET			// Set only : Set some values needed for the next Gt
	} KSPROPERTY_IVAC_CONTROL;

typedef struct
	{
   DWORD		dwAddress;	// Address offset of the memory area we want to read
	DWORD		dwCount;		// Number of bytes we want to read (have to be smaller than 4096
	BOOL		bReady;		// Are we ready to receive a Get command
	} PREPARE_GET;

typedef struct 
	{
   WORD wIrq;
	} KSPROPERTY_IVACCONTROL_GET_IRQ, *PKSPROPERTY_IVACCONTROL_GET_IRQ;

typedef struct 
	{
   DWORD dwSdMem;
	} KSPROPERTY_IVACCONTROL_GET_SDMEM, *PKSPROPERTY_IVACCONTROL_GET_SDMEM;

typedef struct 
	{
   DWORD dwRegMem;
	} KSPROPERTY_IVACCONTROL_GET_REGMEM, *PKSPROPERTY_IVACCONTROL_GET_REGMEM;

typedef struct 
	{
   DWORD		dwAddress; // In:  Address offset of the register we want to read
	DWORD		dwValue;   // Out: Value of the register that we read
	} KSPROPERTY_IVACCONTROL_READ_REG, *PKSPROPERTY_IVACCONTROL_READ_REG;

typedef struct 
	{
   DWORD		dwAddress; // In:  Address offset of the register where we want to write
	DWORD		dwValue;   // Out: Value we want to write in that register
	} KSPROPERTY_IVACCONTROL_WRITE_REG, *PKSPROPERTY_IVACCONTROL_WRITE_REG;

typedef struct 
	{
   DWORD		dwAddress; // In:  Address offset of the memory area we want to read
	DWORD		dwCount;   // In: Number of bytes we want to read (have to be smaller than 4096
	PBYTE		pOutBuffer;// Out: Read buffer (the first dwCount bytes are filled up)
	} KSPROPERTY_IVACCONTROL_READ_MEM, *PKSPROPERTY_IVACCONTROL_READ_MEM;

typedef struct 
	{
   DWORD		dwAddress; // In:  Address offset of the memory area we want to read
	DWORD		dwCount;   // In: Number of bytes we want to read (have to be smaller than 4096
	PBYTE		pInBuffer; // In: Buffer containing dwCount bytes of data to write
	} KSPROPERTY_IVACCONTROL_WRITE_MEM, *PKSPROPERTY_IVACCONTROL_WRITE_MEM;

typedef struct 
	{
	OUTPUT_TYPE eOutputType;		// In: Type of the output (hardcoded to program for now)
	} KSPROPERTY_IVACCONTROL_START_CAPTURE, *PKSPROPERTY_IVACCONTROL_START_CAPTURE;

typedef struct 
	{
	OUTPUT_TYPE eOutputType;		// In: Type of the output (hardcoded to program for now)
	} KSPROPERTY_IVACCONTROL_STOP_CAPTURE, *PKSPROPERTY_IVACCONTROL_STOP_CAPTURE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2enc\specific\kfir.h ===
//
// FILE:      library\hardware\mpeg2enc\specific\kfir.h
// AUTHOR:    Martin Stephan
// COPYRIGHT: (c) 1999 VIONA Development GmbH.  All Rights Reserved.
// CREATED:   19.11.1999
//
// PURPOSE:   VisionTech KFIR Encoder Chip class  --- header file 
//
// HISTORY:
//

#ifndef KFIR_H
#define KFIR_H

#include "library\lowlevel\intrctrl.h"
#include "library\hardware\mpeg2enc\generic\mp2elenc.h"


// Must be in consecutive order !!!
// When new controller type is added, check if it max size is lower then MAX_BUFFER and set MAX_BUFFER if neccessary.
// mst: taken from VisionTech's driver (file kfir.h). Has to be examined (what means KF_CONTR_TYPE???)
typedef enum KF_CONTR_TYPE_Tag {
  KF_GC               = 0,
  KF_DSP_RISC_MC      = 1,
  KF_DSP_RISC_CRAM    = 2,
  KF_DSP_UNIT_MC      = 3,
  KF_BSM_MC           = 4,
  KF_MUX_MC           = 5,
} KF_CONTR_TYPE;

// mst: taken from VisionTech's driver (file kfir.h).
typedef enum KF_CONTR_TYPE_DEV_ID_Tag {
  KF_DEV_ID_GC             = 7,
  KF_DEV_ID_DSP            = 4,
  KF_DEV_ID_BSM            = 5,
  KF_DEV_ID_MUX            = 8,
} KF_CONTR_DEV_ID;


//
// KFIR encoder chip class
// 
// inherits from MPEG2AVEncoder, InterruptHandler, and VDSpinLock
// To synchronize the access to the device's registers you can use the VDSpinLock class. 
// This is mostly the case when the Interrupt Service Routine is doing a lot of access to the 
// device's registers. 
//	For example if you want to read or write to a register just call EnterLock() before and 
// LeaveLock() after the access:
// Function OutDWord()
//		{
//		EnterLock()
//		...
//		register access 
//		...
//		LeaveLock()
//		}
// 1.12.99: leave out the VDSpinLock class. Because the PCI bridge chip (if separate) should need and use this. 
//
class KFIRMPEGEncoder : public MPEG2VideoEncoder, protected InterruptHandler //, protected VDSpinLock
	{
	friend class VirtualKFIRMPEGEncoder;

	public:
		KFIRMPEGEncoder(DWordIndexedInOutPort		* ioPort,
								DWordIndexedInOutPort	* muxFifoPort,
								InterruptServer			* irqServer);
		KFIRMPEGEncoder(DWordIndexedInOutPort		* ioPort,
								InterruptServer			* irqServer);
		
		~KFIRMPEGEncoder(void);

		InterruptServer			*	vidServer;

		Error Initialize(void);
		void Interrupt(void);
		VirtualUnit * CreateVirtual(void);		

	protected:
		MPEGEncoderStreamType	outputType;
		VideoSource					videoSource;
		VideoStandard				videoStandard;
		WORD							aspectRatio;
		DWORD							frameRate;
		DWORD							videoBitrate;
		DWORD							audioBitrate;
		WORD							frameWidth;
		WORD							frameHeight;
		WORD							vbvBufferSize;

		//
		// Basic IO operations
		//
		DWordIndexedInOutPort	*	ioPort;
		//
		// IO operations for the MUX Audio FIFO 
		//
		DWordIndexedInOutPort	*  muxFifoPort;

		Error EnableVidServer(void);
		Error DisableVidServer(void);

		Error OutDWord(int idx, DWORD val);
		Error InDWord(int idx, DWORD __far &val);
		Error KFIRMPEGEncoder::OutAVMuxPortDWord(int idx, DWORD val);
		Error KFIRMPEGEncoder::InAVMuxPortDWord(int idx, DWORD val);

		Error BeginCapture(void);		// initialize chip for encoding
		Error EndCapture(void);			// reset chip after encoding
		Error StartCapture(void);		// start capturing
		Error StopCapture(void);		// stop capturing
		Error PauseCapture(void);		// pause capturing
		Error RestartCapture(void);
		
		MPEGState CurrentState(void);
		Error DoCommand(MPEGCommand com, DWORD param);
		virtual Error AddBuffer(HPTR data, DWORD size);

		Error SetOutputStreamType(MPEGEncoderStreamType outputStreamType);
		Error SetVideoSource(VideoSource source);
		Error SetVideoStandard(VideoStandard standard);		
		Error SetAspectRatio(WORD aspectRatio);
		Error SetFrameRate(DWORD frameRate);
		Error SetVideoBitrate(DWORD videoBitrate);
		Error SetAudioBitrate(DWORD audioBitrate);
		Error SetVideoWidth(WORD width);
		Error SetVideoHeight(WORD height);

		DWORD irqmask;

		Error ReadStatus(DWORD __far& status);
		Error ReadRecord(DWORD __far& record);
		
		Error InitInterruptMask(DWORD mask);
		Error SetInterruptMask(DWORD set);
		Error ResetInterruptMask(DWORD reset);
		Error ReadInterruptMask(DWORD __far&status);
		Error WriteInterruptMask(DWORD mask);
		Error ReadInterruptStatus(DWORD __far&status);
		Error ClearInterruptStatus(DWORD mask);

	private:
		InterruptServer			*	irqServer;
		MPEGState					currentState;
		BOOL							parameterHasChanged;

		Error DownloadMicrocode(void);
		Error CheckDRAM(void);
		Error SetKfirParameters(void);
		Error SetAVMuxParameters(void);
		Error StartKfir(void);
   };							

//
// virtual KFIR encoder chip class
//
class VirtualKFIRMPEGEncoder : public VirtualMPEG2VideoEncoder
	{
	public:
		VirtualKFIRMPEGEncoder(KFIRMPEGEncoder * encoder);

		Error Configure(TAG __far * tags);

	protected:
		Error PreemptStopPrevious(VirtualUnit * previous);
      Error PreemptChange(VirtualUnit * previous);
      Error PreemptStartNew(VirtualUnit * previous);

	private:
		KFIRMPEGEncoder * encoder;

	};


#endif // KFIR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2enc\specific\kfirPar.h ===
#define NUMBER_OF_KFIR_REGISTERS		100

static const unsigned long KFIR_PARAMETER[] =
	{
	0x2,
	0x3,
	0x5,
	0x5,
	0x4,
	0xf2,
	0x2b,
	0x0,
	0x70,
	0x0,
	0x0,
	0x1,
	0x1,
	0x0,
	0x0,
	0x0,
	0x0,
	0x0,
	0x0,
	0x0,
	0x0,
	0x190,
	0x0,
	0x0,
	0x0,
	0x0,
	0x0,
	0x0,
	0x0,
	0x0,
	0x0,
	0x240,
	0x2bf2,
	0x0,
	0x2c,
	0x5d1,
	0x29,
	0xa3,
	0x166,
	0xb6db,
	0x249,
	0x249,
	0x0,
	0x0,
	0x1474,
	0x3efc,
	0x0,
	0x1,
	0x0,
	0x3,
	0x5,
	0x630,
	0x24,
	0x1,
	0x1,
	0x0,
	0x0,
	0x70,
	0x0,
	0x0,
	0x1,
	0x960,
	0x1,
	0x1,
	0x1,
	0x32b,
	0x0,
	0x21,
	0x8,
	0xffd7,
	0x53,
	0x39c,
	0x53,
	0xffd7,
	0x8,
	0x8,
	0xffd7,
	0x53,
	0x39c,
	0x53,
	0xffd7,
	0x8,
	0xffd8,
	0xd8,
	0x1e0,
	0x178,
	0x38,
	0xffc0,
	0xffc0,
	0x38,
	0x178,
	0x1e0,
	0xd8,
	0xffd8,
	0x4800,
	0x9,
	0xa,
	0x4,
	0x40,
	0x3c,
	};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2enc\specific\kfirmic.h ===
//
// FILE:			library\hardware\mpeg2enc\specific\kfirmic.h
// AUTHOR:		Martin Stephan
// COPYRIGHT:	(c) 1999 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		27.12.1999
//
// PURPOSE:		microcode for the KFIR chip
//
// HISTORY:
//



#define	SEGMENTS_COUNT	6

#define SEGMENT0_DATA_TYPE	0
#define SEGMENT0_LENGTH	2304
static const unsigned long KFIR_GC[] =
	{
	0x00000000,
	0x000c0000,
	0x000a2000,
	0x00182000,
	0x00060001,
	0x000e00fe,
	0x0016003e,
	0x00180400,
	0x00060226,
	0x000a1400,
	0x00181400,
	0x001007f0,
	0x00060004,
	0x000e00fe,
	0x00100833,
	0x0010080e,
	0x00060001,
	0x000e00ea,
	0x00100829,
	0x0006000a,
	0x000e00ab,
	0x0006021c,
	0x000a1400,
	0x00181400,
	0x001307ac,
	0x00181800,
	0x000c00ab,
	0x00041800,
	0x000e00ab,
	0x0016d015,
	0x0006000a,
	0x000e00ab,
	0x001307ac,
	0x00181800,
	0x000c00ab,
	0x00041800,
	0x000e00ab,
	0x0016d020,
	0x000c003e,
	0x00175031,
	0x00060001,
	0x000a2124,
	0x001387df,
	0x000c0079,
	0x0016d02a,
	0x00060001,
	0x000a2128,
	0x00182000,
	0x00160033,
	0x00060001,
	0x000a2124,
	0x00060001,
	0x000e00fe,
	0x00082230,
	0x000e00e7,
	0x00082234,
	0x000e00e8,
	0x00082238,
	0x000e00e9,
	0x00060001,
	0x000e00ea,
	0x00100829,
	0x000c00ff,
	0x0016d041,
	0x0016003e,
	0x000c00fc,
	0x00175052,
	0x00060002,
	0x000e00fe,
	0x000c0095,
	0x000a1854,
	0x000c0092,
	0x000a187c,
	0x00181800,
	0x0008186c,
	0x000e00ab,
	0x00081870,
	0x000e00ac,
	0x00060000,
	0x000e00ff,
	0x00160004,
	0x001e0000,
	0x00060000,
	0x000e00fe,
	0x000a1800,
	0x00181800,
	0x000a0800,
	0x000c003c,
	0x000a1420,
	0x00181400,
	0x00060080,
	0x000a2120,
	0x00060457,
	0x000a2000,
	0x00182000,
	0x000c003e,
	0x00175067,
	0x00120000,
	0x000c003d,
	0x000a1868,
	0x00181800,
	0x0006000b,
	0x00160068,
	0x00060004,
	0x000a2000,
	0x000a0c00,
	0x00060001,
	0x000a1000,
	0x00180800,
	0x000a0400,
	0x00180400,
	0x000a0404,
	0x00180400,
	0x000c0060,
	0x000a2014,
	0x000c0062,
	0x000a04a4,
	0x000c0061,
	0x000a2018,
	0x000c0063,
	0x000a04a8,
	0x000c0030,
	0x0017207e,
	0x00060002,
	0x000e009c,
	0x0016007f,
	0x000e009c,
	0x00060000,
	0x000e00e1,
	0x000c0031,
	0x0016d086,
	0x00060001,
	0x000e00e1,
	0x000e0031,
	0x000c0000,
	0x000a1674,
	0x000c0002,
	0x000a1690,
	0x000c0003,
	0x000a1694,
	0x000c0004,
	0x000a1698,
	0x000c0007,
	0x000a167c,
	0x000c0006,
	0x000a1678,
	0x000c0005,
	0x000a1670,
	0x000c0008,
	0x000a1688,
	0x000c0009,
	0x000a1684,
	0x000c000a,
	0x000a16d0,
	0x000c000b,
	0x000a16bc,
	0x000c0037,
	0x000a1680,
	0x000c002e,
	0x000a16c4,
	0x000c002f,
	0x000a16f0,
	0x000a1858,
	0x000c0001,
	0x000a16fc,
	0x00060000,
	0x000a175c,
	0x000c0068,
	0x00041800,
	0x000a1760,
	0x000c003a,
	0x000a166c,
	0x00181000,
	0x000a1124,
	0x000c0067,
	0x000a11bc,
	0x000a1740,
	0x000c002f,
	0x000a11a4,
	0x000c0039,
	0x000a1184,
	0x000c0029,
	0x000a11ac,
	0x000c0028,
	0x000a11b0,
	0x000c0025,
	0x000a11b4,
	0x000c0036,
	0x000a11b8,
	0x000c0015,
	0x000a111c,
	0x000c000b,
	0x000a113c,
	0x000c0018,
	0x000a1138,
	0x000c0017,
	0x000a1134,
	0x000c0016,
	0x000a1130,
	0x000c0021,
	0x000a1174,
	0x000c0020,
	0x000a114c,
	0x000c0023,
	0x000a116c,
	0x000c0024,
	0x000a1170,
	0x000c0022,
	0x000a1168,
	0x000a16f4,
	0x00026005,
	0x000a0410,
	0x000c0026,
	0x000a1190,
	0x000c2027,
	0x000a118c,
	0x000c001f,
	0x000a1188,
	0x000c0034,
	0x000a16f8,
	0x00068003,
	0x00040800,
	0x000e0069,
	0x000c002f,
	0x001720e3,
	0x000600f0,
	0x001600e4,
	0x00060120,
	0x000e009a,
	0x000c003f,
	0x000a0408,
	0x000c0040,
	0x000a040c,
	0x000c0041,
	0x000a0414,
	0x000c0042,
	0x000a0418,
	0x000c0043,
	0x000a041c,
	0x000c0044,
	0x000a0420,
	0x000c0045,
	0x000a0424,
	0x000c0046,
	0x000a0428,
	0x000c0047,
	0x000a042c,
	0x000c0048,
	0x000a0430,
	0x000c0049,
	0x000a0434,
	0x000c004a,
	0x000a0438,
	0x000c004b,
	0x000a043c,
	0x000c004c,
	0x000a0440,
	0x000c004d,
	0x000a0444,
	0x000c004e,
	0x000a0448,
	0x000c004f,
	0x000a044c,
	0x000c0050,
	0x000a0450,
	0x000c0051,
	0x000a0454,
	0x000c0052,
	0x000a0458,
	0x000c0053,
	0x000a045c,
	0x000c0054,
	0x000a0460,
	0x000c0055,
	0x000a0464,
	0x000c0056,
	0x000a0468,
	0x000c0057,
	0x000a046c,
	0x000c0058,
	0x000a0470,
	0x000c0059,
	0x000a0474,
	0x000c005a,
	0x000a0478,
	0x000c005b,
	0x000a047c,
	0x000c005c,
	0x000a0480,
	0x000c005d,
	0x000a0484,
	0x000c0067,
	0x0017512f,
	0x000c802f,
	0x0017412f,
	0x000c0031,
	0x00070003,
	0x0016912f,
	0x000c0034,
	0x0007001e,
	0x0016912f,
	0x00060001,
	0x00160130,
	0x00060000,
	0x000e0076,
	0x00174133,
	0x00160134,
	0x00060001,
	0x000e003b,
	0x00060222,
	0x000a1400,
	0x00181400,
	0x00060000,
	0x000a1400,
	0x00181400,
	0x00060000,
	0x000a212c,
	0x00100259,
	0x001002c2,
	0x000e0085,
	0x0010079a,
	0x0010088b,
	0x00060001,
	0x000e00b6,
	0x001002f6,
	0x00060000,
	0x000e00b6,
	0x000c0031,
	0x00068002,
	0x00168163,
	0x001002c2,
	0x000e0086,
	0x00180400,
	0x0011075a,
	0x0010872f,
	0x0010079a,
	0x0010088b,
	0x00060002,
	0x000e00dc,
	0x001002f6,
	0x000c0031,
	0x00068003,
	0x00168163,
	0x000c003b,
	0x00172163,
	0x001002c2,
	0x000e0087,
	0x000c00c0,
	0x0016d162,
	0x00180400,
	0x0011075a,
	0x0010872f,
	0x0010079a,
	0x0010088b,
	0x001002f6,
	0x00060001,
	0x000e0084,
	0x000c0085,
	0x000a1850,
	0x000e008f,
	0x000a1844,
	0x001002c2,
	0x000c803b,
	0x0016c16e,
	0x000e0087,
	0x0016016f,
	0x000e0085,
	0x000c00c0,
	0x0016d176,
	0x00180400,
	0x0011075a,
	0x0010872f,
	0x0010079a,
	0x0010088b,
	0x00060000,
	0x000a16a0,
	0x00060004,
	0x000e0078,
	0x00100370,
	0x000c0031,
	0x000e008e,
	0x001002e4,
	0x000c00e1,
	0x00172234,
	0x000c00ff,
	0x0016d183,
	0x00160007,
	0x001007f0,
	0x000c003b,
	0x0016a1a0,
	0x001002c2,
	0x000e0085,
	0x000c00c0,
	0x0016d18f,
	0x00180400,
	0x0011075a,
	0x0010872f,
	0x0010079a,
	0x0010088b,
	0x00060006,
	0x000e00da,
	0x001002f6,
	0x001002c2,
	0x000e0088,
	0x000c00c0,
	0x0016d19b,
	0x00180400,
	0x0011075a,
	0x0010872f,
	0x0010079a,
	0x0010088b,
	0x00060008,
	0x000e00dc,
	0x0006000a,
	0x000e0078,
	0x001002f6,
	0x000c0082,
	0x000e0083,
	0x00060002,
	0x000e0084,
	0x000c0085,
	0x000a1850,
	0x000e008f,
	0x001002c2,
	0x000c803b,
	0x001741af,
	0x000c8031,
	0x0017c1ae,
	0x000e0085,
	0x001601af,
	0x000e0088,
	0x000c803b,
	0x0016c1b6,
	0x000c80be,
	0x001741b5,
	0x000e0089,
	0x001601b6,
	0x000e0087,
	0x000a1844,
	0x000c008e,
	0x000a16a0,
	0x000c00c0,
	0x0016d1c0,
	0x00180400,
	0x0011075a,
	0x0010872f,
	0x0010079a,
	0x0010088b,
	0x00100370,
	0x001002e4,
	0x000c00be,
	0x00068001,
	0x00042000,
	0x000e00be,
	0x000c0031,
	0x00068002,
	0x00168234,
	0x000c00ff,
	0x0016d1cd,
	0x00060003,
	0x000e00fe,
	0x001007f0,
	0x000c803b,
	0x0016c1d4,
	0x000c80be,
	0x001741d4,
	0x000c0088,
	0x001601d5,
	0x000c0086,
	0x000a1850,
	0x000e008f,
	0x000c803b,
	0x001741df,
	0x000c8088,
	0x00036000,
	0x00026800,
	0x000e0086,
	0x00027000,
	0x000e0088,
	0x001002c2,
	0x000c803b,
	0x001741e8,
	0x000c8031,
	0x00070002,
	0x0017b1e7,
	0x000e0085,
	0x001601e8,
	0x000e0089,
	0x000c803b,
	0x0016c1eb,
	0x000e0085,
	0x00060003,
	0x000e0084,
	0x000c8031,
	0x0004b800,
	0x000c008e,
	0x00040800,
	0x000a16a0,
	0x000c00c0,
	0x0016d1f9,
	0x00180400,
	0x0011075a,
	0x0010872f,
	0x0010079a,
	0x0010088b,
	0x00100370,
	0x001002e4,
	0x000c0031,
	0x00068003,
	0x00168234,
	0x000c00ff,
	0x0016d202,
	0x00060003,
	0x000e00fe,
	0x001007f0,
	0x000c803b,
	0x0016c209,
	0x000c80be,
	0x00174209,
	0x000c0089,
	0x0016020a,
	0x000c0087,
	0x000a1850,
	0x000e008f,
	0x000c803b,
	0x00174214,
	0x000c8089,
	0x00036000,
	0x00026800,
	0x000e0087,
	0x00027000,
	0x000e0089,
	0x001002c2,
	0x000c803b,
	0x0016c21d,
	0x000c80be,
	0x0017621b,
	0x000e0086,
	0x0016021e,
	0x000e0088,
	0x0016021e,
	0x000e0085,
	0x000c803b,
	0x0016c225,
	0x000c80be,
	0x00174224,
	0x000e0088,
	0x00160225,
	0x000e0086,
	0x000c8031,
	0x00060002,
	0x0004a000,
	0x000c008e,
	0x00040800,
	0x000a16a0,
	0x000c00c0,
	0x0016d232,
	0x00180400,
	0x0011075a,
	0x0010872f,
	0x0010079a,
	0x0010088b,
	0x00100370,
	0x001002e4,
	0x000c00ff,
	0x0016d237,
	0x00160007,
	0x001007f0,
	0x000c008e,
	0x000c8031,
	0x00020800,
	0x000e008e,
	0x000c0083,
	0x00040800,
	0x000e0083,
	0x000d007d,
	0x0016f243,
	0x00036800,
	0x00160244,
	0x00070000,
	0x001791a1,
	0x00060000,
	0x000e00b7,
	0x000c2080,
	0x000c4081,
	0x00021800,
	0x000e0080,
	0x00026007,
	0x00026007,
	0x000e0081,
	0x00060001,
	0x000e007d,
	0x00100259,
	0x000c8031,
	0x00043800,
	0x000e008e,
	0x000c0082,
	0x000e0083,
	0x00060001,
	0x000e0084,
	0x001601a4,
	0x000c007d,
	0x0016d261,
	0x00060001,
	0x000a169c,
	0x000c202c,
	0x000c402a,
	0x000a1150,
	0x00160273,
	0x00060000,
	0x000a169c,
	0x000c202d,
	0x000c402b,
	0x000c806c,
	0x000d007f,
	0x0002b000,
	0x000d00f5,
	0x0002b000,
	0x000d00f6,
	0x0002b000,
	0x00070002,
	0x0017b26f,
	0x00160272,
	0x0002e001,
	0x0002e801,
	0x00020800,
	0x000a1150,
	0x000c00e1,
	0x00068000,
	0x00070000,
	0x00172286,
	0x000c8032,
	0x000d0031,
	0x00060000,
	0x00021000,
	0x0004b800,
	0x0016e27a,
	0x000e0082,
	0x000c8032,
	0x00050800,
	0x0004b800,
	0x000c007d,
	0x0016d286,
	0x00035800,
	0x000c0031,
	0x00054000,
	0x00026800,
	0x000a1128,
	0x00027000,
	0x000a112c,
	0x00081250,
	0x00036000,
	0x00081424,
	0x00041000,
	0x000c80f2,
	0x00020800,
	0x000e00f2,
	0x000c8036,
	0x0017c296,
	0x00026001,
	0x00026001,
	0x00160298,
	0x00026007,
	0x00020000,
	0x00021000,
	0x000a1150,
	0x00081424,
	0x00026007,
	0x000e00d7,
	0x000c2019,
	0x000c401c,
	0x000a1140,
	0x000c201a,
	0x000c401d,
	0x000a1144,
	0x000c201b,
	0x000c401e,
	0x000a1148,
	0x000602d7,
	0x000a1000,
	0x000c007d,
	0x001752b6,
	0x000c0035,
	0x001752b3,
	0x00060222,
	0x000a1400,
	0x00181400,
	0x00060000,
	0x000a1400,
	0x00181400,
	0x001602b6,
	0x00060222,
	0x000a1400,
	0x00181400,
	0x00060074,
	0x000a1400,
	0x00181000,
	0x00181400,
	0x000c007d,
	0x001752c1,
	0x00060000,
	0x000e00ee,
	0x000e00ef,
	0x000e00f0,
	0x000e00f1,
	0x00140000,
	0x000c808a,
	0x0016e2c8,
	0x00060001,
	0x000e008a,
	0x00060000,
	0x001602dc,
	0x000c808b,
	0x0016e2cd,
	0x00060001,
	0x000e008b,
	0x001602dc,
	0x000c808c,
	0x0016e2d3,
	0x00060001,
	0x000e008c,
	0x00060002,
	0x001602dc,
	0x000c808d,
	0x0016e2d9,
	0x00060001,
	0x000e008d,
	0x00060003,
	0x001602dc,
	0x00060001,
	0x000e00bf,
	0x00060004,
	0x000a1848,
	0x000c80c1,
	0x000e00c1,
	0x00026800,
	0x000e00c2,
	0x000a184c,
	0x000c00c1,
	0x00140000,
	0x00060000,
	0x000c808f,
	0x0016e2e9,
	0x000e008a,
	0x001602f5,
	0x0017c2ec,
	0x000e008b,
	0x001602f5,
	0x00070002,
	0x0017b2f0,
	0x000e008c,
	0x001602f5,
	0x00070003,
	0x0017b2f4,
	0x000e008d,
	0x001602f5,
	0x000e00bf,
	0x00140000,
	0x000c0034,
	0x00041800,
	0x00026004,
	0x00026005,
	0x000c8022,
	0x0004b800,
	0x00020800,
	0x00020000,
	0x000c8038,
	0x00020800,
	0x000a0804,
	0x00060000,
	0x000e00ae,
	0x000e00af,
	0x000e00b0,
	0x000e00b1,
	0x000e00b3,
	0x000e00d0,
	0x000e00d1,
	0x000e00d2,
	0x000e00d3,
	0x0011075a,
	0x0010872f,
	0x000a1804,
	0x001007b8,
	0x00181800,
	0x000c00b1,
	0x000c809a,
	0x0016830b,
	0x000c00b3,
	0x00172321,
	0x00060001,
	0x000e00b3,
	0x000e00af,
	0x000e00b1,
	0x000c002f,
	0x0017231c,
	0x0016030b,
	0x00180400,
	0x000c0041,
	0x000a0414,
	0x000a0490,
	0x0016030b,
	0x00140000,
	0x000c0037,
	0x000c80c0,
	0x0017632b,
	0x0017432d,
	0x00070002,
	0x0017332f,
	0x00068001,
	0x00042000,
	0x00160332,
	0x00068000,
	0x00160332,
	0x00068001,
	0x00160332,
	0x00068001,
	0x00042000,
	0x00068000,
	0x000e00c3,
	0x000c00c2,
	0x0017535e,
	0x00172355,
	0x00070002,
	0x0017134c,
	0x00070003,
	0x00171343,
	0x000c00c3,
	0x000e00cd,
	0x00026800,
	0x000e00c8,
	0x000c0078,
	0x000e00d8,
	0x000c007c,
	0x000e0073,
	0x00160366,
	0x000c00c3,
	0x000e00cc,
	0x00026800,
	0x000e00c7,
	0x000c0078,
	0x000e00d9,
	0x000c007c,
	0x000e0072,
	0x00160366,
	0x000c00c3,
	0x000e00cb,
	0x00026800,
	0x000e00c6,
	0x000c0078,
	0x000e00da,
	0x000c007c,
	0x000e0071,
	0x00160366,
	0x000c00c3,
	0x000e00ca,
	0x00026800,
	0x000e00c5,
	0x000c0078,
	0x000e00db,
	0x000c007c,
	0x000e0070,
	0x00160366,
	0x000c00c3,
	0x000e00c9,
	0x00026800,
	0x000e00c4,
	0x000c0078,
	0x000e00dc,
	0x000c007c,
	0x000e006f,
	0x000c2078,
	0x000c407c,
	0x00021800,
	0x00021800,
	0x00020800,
	0x000e0078,
	0x00026007,
	0x00026007,
	0x000e007c,
	0x00140000,
	0x000c0034,
	0x00041800,
	0x00026004,
	0x00026005,
	0x000c8022,
	0x0004b800,
	0x00020800,
	0x00020000,
	0x000c8038,
	0x00020800,
	0x000a0804,
	0x000c00c0,
	0x00175380,
	0x000c00c0,
	0x00021800,
	0x000e00c0,
	0x00060000,
	0x000e00ae,
	0x000e00af,
	0x000e00b0,
	0x000e00b1,
	0x000e00b3,
	0x000e00d0,
	0x000e00d1,
	0x000e00d2,
	0x000e00d3,
	0x00068002,
	0x000c00c0,
	0x0017038e,
	0x00160391,
	0x00060001,
	0x000e00af,
	0x000e00b1,
	0x000c00c0,
	0x00068003,
	0x00170395,
	0x001603a1,
	0x0011075a,
	0x0010872f,
	0x000c00ff,
	0x00175679,
	0x000a1804,
	0x001007b8,
	0x001007d8,
	0x00181800,
	0x000c00b1,
	0x000c809a,
	0x00168395,
	0x00160679,
	0x000c003b,
	0x001723a8,
	0x000c0037,
	0x00068000,
	0x000d2078,
	0x000d407c,
	0x001603c7,
	0x000c008f,
	0x001753c3,
	0x001723be,
	0x00070002,
	0x001713b9,
	0x00070003,
	0x001713b4,
	0x000c00cd,
	0x000c80c8,
	0x000d20d8,
	0x000d4073,
	0x001603c7,
	0x000c00cc,
	0x000c80c7,
	0x000d20d9,
	0x000d4072,
	0x001603c7,
	0x000c00cb,
	0x000c80c6,
	0x000d20da,
	0x000d4071,
	0x001603c7,
	0x000c00ca,
	0x000c80c5,
	0x000d20db,
	0x000d4070,
	0x001603c7,
	0x000c00c9,
	0x000c80c4,
	0x000d20dc,
	0x000d406f,
	0x000a1680,
	0x00026800,
	0x000a16d8,
	0x000e00c3,
	0x00027000,
	0x000e007b,
	0x00026007,
	0x00026007,
	0x000e007e,
	0x000c0074,
	0x000a16d0,
	0x000c0084,
	0x000a16a4,
	0x000a1158,
	0x00068002,
	0x001783f3,
	0x001703e5,
	0x000c000c,
	0x000a16c8,
	0x000c000f,
	0x000a16cc,
	0x000c0074,
	0x0016d3df,
	0x000c0012,
	0x000a16c0,
	0x000a11a0,
	0x0006000f,
	0x000a16ac,
	0x000a16b4,
	0x001603ff,
	0x000c000d,
	0x000a16c8,
	0x000c0010,
	0x000a16cc,
	0x000c0074,
	0x0016d3ec,
	0x000c0013,
	0x000a16c0,
	0x000a11a0,
	0x00060005,
	0x000a16ac,
	0x0006000f,
	0x000a16b4,
	0x001603ff,
	0x000c000e,
	0x000a16c8,
	0x000c0011,
	0x000a16cc,
	0x000c0074,
	0x0016d3fa,
	0x000c0014,
	0x000a16c0,
	0x000a11a0,
	0x00060005,
	0x000a16ac,
	0x000a16b4,
	0x00081424,
	0x000a110c,
	0x000602e2,
	0x000a1000,
	0x00181000,
	0x000c0036,
	0x0017a407,
	0x00160407,
	0x000c0036,
	0x0016d410,
	0x000c003a,
	0x00172410,
	0x00081298,
	0x000a1664,
	0x0008129c,
	0x000a1668,
	0x00160414,
	0x000600ff,
	0x000a1664,
	0x000600ff,
	0x000a1668,
	0x00060081,
	0x000a1400,
	0x00181400,
	0x00060000,
	0x000e0095,
	0x000e0092,
	0x000e0094,
	0x000e0091,
	0x000e0093,
	0x000e0090,
	0x000e0096,
	0x000e009b,
	0x000e00ab,
	0x000e00b5,
	0x000c0084,
	0x000a1158,
	0x00068002,
	0x00168485,
	0x0017844c,
	0x00068000,
	0x00070001,
	0x0010084b,
	0x000c0096,
	0x00021800,
	0x000e0096,
	0x00068000,
	0x00070001,
	0x0010084b,
	0x000c0096,
	0x00021800,
	0x000e0096,
	0x00068000,
	0x00070001,
	0x0010084b,
	0x000c0096,
	0x00021800,
	0x000e0096,
	0x00068000,
	0x00070001,
	0x0010084b,
	0x000c0096,
	0x00021800,
	0x000e0096,
	0x00068000,
	0x00070001,
	0x0010084b,
	0x000c0096,
	0x00021800,
	0x000e0096,
	0x00068000,
	0x00070001,
	0x0010084b,
	0x000c0096,
	0x00021800,
	0x000e0096,
	0x00160485,
	0x00068001,
	0x00070001,
	0x0010084b,
	0x00068001,
	0x00070000,
	0x0010084b,
	0x000c0096,
	0x00021800,
	0x000e0096,
	0x00068001,
	0x00070001,
	0x0010084b,
	0x00068001,
	0x00070000,
	0x0010084b,
	0x000c0096,
	0x00021800,
	0x000e0096,
	0x00068001,
	0x00070001,
	0x0010084b,
	0x00068001,
	0x00070000,
	0x0010084b,
	0x000c0096,
	0x00021800,
	0x000e0096,
	0x00068001,
	0x00070001,
	0x0010084b,
	0x00068001,
	0x00070000,
	0x0010084b,
	0x000c0096,
	0x00021800,
	0x000e0096,
	0x00068001,
	0x00070001,
	0x0010084b,
	0x00068001,
	0x00070000,
	0x0010084b,
	0x000c0096,
	0x00021800,
	0x000e0096,
	0x00068001,
	0x00070001,
	0x0010084b,
	0x00068001,
	0x00070000,
	0x0010084b,
	0x000c0096,
	0x00021800,
	0x000e0096,
	0x00068001,
	0x00070001,
	0x0010084b,
	0x000c0084,
	0x00068002,
	0x001685f9,
	0x00170555,
	0x0010086d,
	0x000c009f,
	0x00041800,
	0x000a1854,
	0x000c00a1,
	0x00041800,
	0x000a1824,
	0x000a0c0c,
	0x00181800,
	0x000a0c1c,
	0x00180800,
	0x000c0095,
	0x000a1854,
	0x000c0092,
	0x000a1808,
	0x000a0808,
	0x00100790,
	0x00181800,
	0x000a081c,
	0x00080830,
	0x000e00a2,
	0x00080834,
	0x000e00a0,
	0x000c00a2,
	0x0010077f,
	0x000e00a2,
	0x000c00a0,
	0x00100787,
	0x000e00a0,
	0x00068001,
	0x00070000,
	0x0010084b,
	0x000c0096,
	0x00021800,
	0x000c8022,
	0x001684b1,
	0x000c00b5,
	0x00021800,
	0x000e00b5,
	0x00060000,
	0x000e0096,
	0x00100790,
	0x001307ac,
	0x00181800,
	0x001387df,
	0x00180c00,
	0x000c00a0,
	0x00041800,
	0x000a1854,
	0x000c00a2,
	0x00041800,
	0x000a1828,
	0x000a0c14,
	0x00181800,
	0x000a0c20,
	0x0011075a,
	0x000a1804,
	0x00181800,
	0x000a1804,
	0x00181800,
	0x00180800,
	0x000a0820,
	0x0010872f,
	0x00068001,
	0x00070001,
	0x0010084b,
	0x00180c00,
	0x00080c38,
	0x0002e000,
	0x0002e803,
	0x00026002,
	0x000e00a4,
	0x00026800,
	0x000e00a6,
	0x000c8091,
	0x0002e805,
	0x000c00a1,
	0x00041800,
	0x00040800,
	0x00020000,
	0x000c80a4,
	0x00020800,
	0x000e00a4,
	0x000c8094,
	0x0002e805,
	0x000c009f,
	0x00041800,
	0x00040800,
	0x00020000,
	0x000c80a6,
	0x00020800,
	0x000e00a6,
	0x00080c3c,
	0x0002e000,
	0x0002e803,
	0x00026002,
	0x000e00a8,
	0x00026800,
	0x000e00aa,
	0x000c8091,
	0x0002e805,
	0x000c00a2,
	0x00041800,
	0x00040800,
	0x00020000,
	0x000c80a8,
	0x00020800,
	0x000e00a8,
	0x000c8094,
	0x0002e805,
	0x000c00a0,
	0x00041800,
	0x00040800,
	0x00020000,
	0x000c80aa,
	0x00020800,
	0x000e00aa,
	0x00181000,
	0x000a1414,
	0x00060013,
	0x000a1000,
	0x000c8091,
	0x0002e804,
	0x000c00a4,
	0x0017d507,
	0x00160508,
	0x00021800,
	0x000e00ad,
	0x00026001,
	0x00026001,
	0x00020800,
	0x000e00ab,
	0x000c00a6,
	0x0017d510,
	0x00160511,
	0x00021800,
	0x000e00ac,
	0x000c80ad,
	0x00020806,
	0x000e00ad,
	0x000c8094,
	0x0002e804,
	0x000c00ac,
	0x00026001,
	0x00026001,
	0x00020800,
	0x000e00ac,
	0x000a1854,
	0x000c00ab,
	0x000a182c,
	0x000c00ad,
	0x000a0c10,
	0x00181800,
	0x000c8091,
	0x0002e804,
	0x000c00a8,
	0x0017d527,
	0x00160528,
	0x00021800,
	0x000e00ad,
	0x00026001,
	0x00026001,
	0x00020800,
	0x000e00ab,
	0x000c00aa,
	0x0017d530,
	0x00160531,
	0x00021800,
	0x000e00ac,
	0x000c80ad,
	0x00020806,
	0x000e00ad,
	0x000c8094,
	0x0002e804,
	0x000c00ac,
	0x00026001,
	0x00026001,
	0x00020800,
	0x000e00ac,
	0x000a1854,
	0x000c00ab,
	0x000a1830,
	0x000c00ad,
	0x000a0c18,
	0x00181800,
	0x00181000,
	0x00060009,
	0x00100860,
	0x000a0c24,
	0x00181000,
	0x0006000e,
	0x00100860,
	0x000a0c2c,
	0x00080828,
	0x000e00a1,
	0x0008082c,
	0x000e009f,
	0x000c00a1,
	0x0010077f,
	0x000e00a1,
	0x000c009f,
	0x00100787,
	0x000e009f,
	0x00160615,
	0x000c0095,
	0x000a1854,
	0x000c0092,
	0x000a1808,
	0x000a0808,
	0x000c00a1,
	0x0010077f,
	0x000e00a1,
	0x000c009f,
	0x00100787,
	0x000e009f,
	0x000c8034,
	0x000c00b5,
	0x00070001,
	0x00179565,
	0x00060002,
	0x00070002,
	0x0004b000,
	0x00168569,
	0x00043800,
	0x00041000,
	0x00181800,
	0x000a1854,
	0x000c0096,
	0x000a180c,
	0x000a080c,
	0x000c0096,
	0x00021800,
	0x000c8022,
	0x00168577,
	0x000c00b5,
	0x00021800,
	0x000e00b5,
	0x00060000,
	0x000e0096,
	0x00181800,
	0x000a0818,
	0x0010086d,
	0x000c009f,
	0x00041800,
	0x000a1854,
	0x000c00a1,
	0x00041800,
	0x000a1824,
	0x000a0c0c,
	0x00181800,
	0x000a0c1c,
	0x000a1804,
	0x00181800,
	0x000a1804,
	0x00181800,
	0x0011075a,
	0x0010872f,
	0x001307ac,
	0x00181800,
	0x00180c00,
	0x00080c38,
	0x0002e000,
	0x0002e803,
	0x00026002,
	0x000e00a4,
	0x00026800,
	0x000e00a6,
	0x000c8091,
	0x0002e805,
	0x000c00a1,
	0x00041800,
	0x00040800,
	0x00020000,
	0x000c80a4,
	0x00020800,
	0x000e00a4,
	0x000c8094,
	0x0002e805,
	0x000c009f,
	0x00041800,
	0x00040800,
	0x00020000,
	0x000c80a6,
	0x00020800,
	0x000e00a6,
	0x000c00a4,
	0x001755a9,
	0x001605ab,
	0x000c00a6,
	0x001755ad,
	0x00060008,
	0x000e0098,
	0x000c8091,
	0x0002e804,
	0x000c00a4,
	0x0017d5b2,
	0x001605b3,
	0x00021800,
	0x000e00ad,
	0x00026001,
	0x00026001,
	0x00020800,
	0x000e00ab,
	0x000c00a6,
	0x0017d5bb,
	0x001605bc,
	0x00021800,
	0x000e00ac,
	0x000c80ad,
	0x00020806,
	0x000e00ad,
	0x000c8094,
	0x0002e804,
	0x000c00ac,
	0x00026001,
	0x00026001,
	0x00020800,
	0x000e00ac,
	0x000a1854,
	0x000c00ab,
	0x000a182c,
	0x000c00ad,
	0x000a0c10,
	0x00181800,
	0x001387df,
	0x00181000,
	0x00100815,
	0x00060009,
	0x00100860,
	0x000a0c24,
	0x000c009b,
	0x000c8033,
	0x0004b800,
	0x00180800,
	0x001785d9,
	0x0010085a,
	0x00181800,
	0x00080828,
	0x000e00a1,
	0x0008082c,
	0x000e009f,
	0x000c0095,
	0x000c8069,
	0x001785f4,
	0x00068002,
	0x001685f4,
	0x000c0092,
	0x001755f4,
	0x000c8022,
	0x0004b800,
	0x001705f4,
	0x000c009f,
	0x000c8095,
	0x0002e805,
	0x001705ed,
	0x001605f4,
	0x000c00a1,
	0x000c8092,
	0x0002e805,
	0x001705f2,
	0x001605f4,
	0x00060000,
	0x001605f7,
	0x00080838,
	0x00026004,
	0x00026001,
	0x000e0099,
	0x00160615,
	0x00181800,
	0x000c0095,
	0x000a1854,
	0x000c0092,
	0x000a1808,
	0x000a0808,
	0x00181800,
	0x0010086d,
	0x0011075a,
	0x0010872f,
	0x001307ac,
	0x00181800,
	0x001387df,
	0x000a1804,
	0x00181800,
	0x000a1804,
	0x00181800,
	0x00181000,
	0x00100815,
	0x00060009,
	0x00100860,
	0x000a0c24,
	0x000c009b,
	0x000c8033,
	0x0004b800,
	0x00178614,
	0x0010085a,
	0x00181800,
	0x00181400,
	0x00181000,
	0x00081280,
	0x000a16dc,
	0x00081278,
	0x000a1620,
	0x0008127c,
	0x000a163c,
	0x00081264,
	0x000a1638,
	0x00081260,
	0x000a1614,
	0x000c00a3,
	0x000a1628,
	0x000c00a5,
	0x000a162c,
	0x000c00a7,
	0x000a1630,
	0x000c00a9,
	0x000a1634,
	0x00081424,
	0x000a110c,
	0x000c009b,
	0x00068002,
	0x00168633,
	0x000c8033,
	0x0002b800,
	0x00178633,
	0x00060109,
	0x000a1400,
	0x000c009b,
	0x0016a641,
	0x000c8033,
	0x00178641,
	0x00041800,
	0x000a115c,
	0x000c0098,
	0x000a1160,
	0x00080c30,
	0x000a1100,
	0x00080c34,
	0x000a1104,
	0x0006001d,
	0x000a1000,
	0x0010087a,
	0x000c009b,
	0x00021800,
	0x000e009b,
	0x001307ac,
	0x00181800,
	0x000c0099,
	0x000e0098,
	0x000c8034,
	0x000c0095,
	0x0017065e,
	0x000c00b1,
	0x000c809a,
	0x00168652,
	0x000c00b3,
	0x00172652,
	0x00160679,
	0x000c0092,
	0x00021800,
	0x000e0092,
	0x000c8022,
	0x00168485,
	0x00060000,
	0x000e0092,
	0x000c8034,
	0x000c0095,
	0x00021800,
	0x000e0095,
	0x00168485,
	0x000c8033,
	0x000c009b,
	0x00070003,
	0x0002b000,
	0x00168485,
	0x0017866e,
	0x00181400,
	0x00060224,
	0x000a1400,
	0x00181400,
	0x00181000,
	0x00081424,
	0x000a110c,
	0x0006036d,
	0x000a1000,
	0x00181000,
	0x0011075a,
	0x0010872f,
	0x000a1804,
	0x001007b8,
	0x001007d8,
	0x00181800,
	0x000c00ff,
	0x00175679,
	0x000c00b1,
	0x000c809a,
	0x0016866e,
	0x00080498,
	0x00026007,
	0x00026002,
	0x00026001,
	0x00026001,
	0x000e0075,
	0x000c00c0,
	0x00068004,
	0x0017070f,
	0x00068003,
	0x00168686,
	0x00060004,
	0x001606d7,
	0x0016d6f2,
	0x000c003b,
	0x0017570f,
	0x000c00b3,
	0x0017271d,
	0x000c007d,
	0x001756d6,
	0x000c0076,
	0x001756d6,
	0x000c8022,
	0x00032800,
	0x0002c800,
	0x0002e801,
	0x0002e801,
	0x000c0075,
	0x001686a8,
	0x000c0077,
	0x00068005,
	0x0017069a,
	0x001606a6,
	0x000c006e,
	0x00021800,
	0x000e006e,
	0x00068004,
	0x001686a4,
	0x00060000,
	0x000e006d,
	0x000e006e,
	0x000e0074,
	0x001606d6,
	0x00060000,
	0x000e0077,
	0x00060000,
	0x001606d6,
	0x000c0077,
	0x00068005,
	0x001706c0,
	0x000c006c,
	0x001756b6,
	0x000c00f5,
	0x000e00f6,
	0x000c007f,
	0x000e00f5,
	0x000c006c,
	0x000e007f,
	0x00060000,
	0x000e006c,
	0x001606d6,
	0x000c006e,
	0x00021800,
	0x000e006e,
	0x00068004,
	0x001686c0,
	0x00060000,
	0x000e006d,
	0x000e006e,
	0x000e0074,
	0x001606d6,
	0x00060000,
	0x000e0077,
	0x000c006d,
	0x00068004,
	0x001706cb,
	0x001786d1,
	0x00021800,
	0x000e006d,
	0x00060000,
	0x000e0074,
	0x001606d6,
	0x00060005,
	0x000e006d,
	0x00060000,
	0x000e006e,
	0x00060001,
	0x000e0074,
	0x000c006e,
	0x001756d5,
	0x00041800,
	0x000e006e,
	0x00060001,
	0x0017570f,
	0x000e00c0,
	0x00060000,
	0x000e00ae,
	0x000e00af,
	0x000e00b0,
	0x000e00b1,
	0x000e00b3,
	0x000e00d0,
	0x000e00d1,
	0x000e00d2,
	0x000e00d3,
	0x000c00c0,
	0x001726e5,
	0x001606e9,
	0x00060001,
	0x000e00b1,
	0x000e00af,
	0x00160652,
	0x000c00c0,
	0x00068004,
	0x00168652,
	0x00180400,
	0x0011075a,
	0x0010872f,
	0x0010079a,
	0x0010088b,
	0x001603a1,
	0x000c00b3,
	0x0017271d,
	0x000c00ff,
	0x0017571d,
	0x00180400,
	0x0011075a,
	0x0010872f,
	0x0010079a,
	0x0010088b,
	0x000c00c0,
	0x0017a702,
	0x000e00b3,
	0x00060000,
	0x000e00af,
	0x000e00b1,
	0x0016066e,
	0x00068002,
	0x0017870a,
	0x00060001,
	0x000e00b3,
	0x00060000,
	0x000e00af,
	0x000e00b1,
	0x00160652,
	0x00060001,
	0x000e00b3,
	0x000e00af,
	0x000e00b1,
	0x00160652,
	0x000c00b3,
	0x0017271d,
	0x00060001,
	0x000e00b3,
	0x000e00af,
	0x000e00b1,
	0x000c002f,
	0x00172718,
	0x00160652,
	0x00180400,
	0x000c0041,
	0x000a0414,
	0x000a0490,
	0x00160652,
	0x00100322,
	0x000c00c0,
	0x00068004,
	0x0016872b,
	0x000c00f5,
	0x000e00f6,
	0x000c007f,
	0x000e00f5,
	0x000c006c,
	0x000e007f,
	0x00060001,
	0x000e006c,
	0x00060000,
	0x000e00c0,
	0x000c00b7,
	0x00021800,
	0x000e00b7,
	0x00140000,
	0x000c0034,
	0x0006801e,
	0x0016873a,
	0x000c00af,
	0x0002e001,
	0x0002a800,
	0x00170738,
	0x00041800,
	0x00160739,
	0x00021800,
	0x0016073b,
	0x000c00d0,
	0x000a1854,
	0x000c00ae,
	0x000a183c,
	0x000a0488,
	0x00070004,
	0x00021000,
	0x000e00ae,
	0x000c8022,
	0x00168752,
	0x00060000,
	0x000e00ae,
	0x000c00af,
	0x000c809c,
	0x00020800,
	0x000e00af,
	0x000c00d2,
	0x00021800,
	0x000e00d2,
	0x000c8034,
	0x0007000e,
	0x0017b751,
	0x00026001,
	0x000e00d0,
	0x001007d8,
	0x00181800,
	0x000c00b6,
	0x0016d759,
	0x000a1864,
	0x000a0494,
	0x00181800,
	0x00140000,
	0x000c0034,
	0x0006801e,
	0x00168765,
	0x000c00b1,
	0x0002e001,
	0x0002a800,
	0x00170763,
	0x00041800,
	0x00160764,
	0x00021800,
	0x00160766,
	0x000c00d1,
	0x000a1854,
	0x000c00b0,
	0x000a1840,
	0x000a048c,
	0x00070004,
	0x00021000,
	0x000e00b0,
	0x000c8022,
	0x0016877d,
	0x00060000,
	0x000e00b0,
	0x000c00b1,
	0x000c809c,
	0x00020800,
	0x000e00b1,
	0x000c00d3,
	0x00021800,
	0x000e00d3,
	0x000c8034,
	0x0007000e,
	0x0017b77c,
	0x00026001,
	0x000e00d1,
	0x00181800,
	0x00140000,
	0x0016d781,
	0x00060001,
	0x000c8022,
	0x0004b805,
	0x00168786,
	0x00026800,
	0x00041800,
	0x00140000,
	0x0016d789,
	0x00060001,
	0x000c8034,
	0x0002e805,
	0x00070010,
	0x0004b000,
	0x0016878f,
	0x00043800,
	0x00140000,
	0x000c8034,
	0x000c00b5,
	0x0016d794,
	0x00060001,
	0x0004b800,
	0x00168797,
	0x00043800,
	0x00041800,
	0x000e00ab,
	0x00140000,
	0x00100833,
	0x0010080e,
	0x00060001,
	0x000e00ea,
	0x00100829,
	0x000c00c0,
	0x0016d7ab,
	0x000c00fd,
	0x001757ab,
	0x000a1804,
	0x001007b8,
	0x001007d8,
	0x00181800,
	0x001307ac,
	0x00181800,
	0x001387df,
	0x001607a1,
	0x00140000,
	0x000a185c,
	0x000a2020,
	0x000c2079,
	0x000c407a,
	0x00021800,
	0x000e0079,
	0x00026007,
	0x00026007,
	0x000e007a,
	0x001007b8,
	0x001007d8,
	0x00140000,
	0x000c00e4,
	0x001757cd,
	0x00060000,
	0x000e00e4,
	0x000c00de,
	0x000a2104,
	0x000c00df,
	0x000a2108,
	0x000c00e0,
	0x000a210c,
	0x000c00e5,
	0x000a2110,
	0x00060001,
	0x000a2100,
	0x00060493,
	0x000a201c,
	0x00038000,
	0x001757cb,
	0x001607c8,
	0x00060000,
	0x000e00e6,
	0x00038000,
	0x001757d7,
	0x000c00e6,
	0x0016d7d7,
	0x00060001,
	0x000e00e6,
	0x00060001,
	0x000e00eb,
	0x0010080e,
	0x00100829,
	0x00140000,
	0x00008000,
	0x001757de,
	0x00060001,
	0x000e00ec,
	0x0010080e,
	0x00100829,
	0x00140000,
	0x000c0079,
	0x0016d7e3,
	0x000c007a,
	0x001757ed,
	0x000a1860,
	0x000a2024,
	0x000c2079,
	0x000c407a,
	0x00041800,
	0x000e0079,
	0x00026007,
	0x00026007,
	0x000e007a,
	0x001007b8,
	0x001007d8,
	0x00181800,
	0x00140000,
	0x000c0084,
	0x000a2114,
	0x00100805,
	0x00081424,
	0x000e00ee,
	0x00026007,
	0x00026007,
	0x000e00ef,
	0x000c00ba,
	0x000a2118,
	0x000c00bb,
	0x000a211c,
	0x000c007b,
	0x000a2178,
	0x000c007e,
	0x000a217c,
	0x00060000,
	0x000a2100,
	0x00060493,
	0x000a201c,
	0x00140000,
	0x00081424,
	0x000ca0ee,
	0x000cc0ef,
	0x00040802,
	0x000e00ba,
	0x00026007,
	0x00026007,
	0x000e00bb,
	0x00140000,
	0x00082028,
	0x000e00e7,
	0x0008202c,
	0x000e00e8,
	0x00082030,
	0x000e00e9,
	0x00140000,
	0x000c009b,
	0x00068002,
	0x00168828,
	0x000c8033,
	0x0002b800,
	0x00178828,
	0x000a1414,
	0x00060018,
	0x000a1000,
	0x000c0093,
	0x000a1854,
	0x000c0090,
	0x000a1838,
	0x00181800,
	0x000c0093,
	0x000a1854,
	0x000c0090,
	0x000a1834,
	0x00181800,
	0x00140000,
	0x000c00dd,
	0x00021800,
	0x000e00dd,
	0x001a0000,
	0x00060000,
	0x00068007,
	0x00021800,
	0x0016882f,
	0x001c0000,
	0x00140000,
	0x00181400,
	0x00081424,
	0x000ca0f0,
	0x000cc0f1,
	0x00040802,
	0x000e00bc,
	0x00026007,
	0x00026007,
	0x000e00bd,
	0x000ca0b8,
	0x000cc0b9,
	0x000c20bc,
	0x000c40bd,
	0x00020800,
	0x000e00b8,
	0x00026007,
	0x00026007,
	0x000e00b9,
	0x00081424,
	0x000e00f0,
	0x00026007,
	0x00026007,
	0x000e00f1,
	0x00140000,
	0x000c00ab,
	0x000a1854,
	0x000c0096,
	0x0016e852,
	0x000a180c,
	0x000a080c,
	0x00160858,
	0x00177856,
	0x000a1810,
	0x000a0810,
	0x00160858,
	0x000a1814,
	0x000a0814,
	0x00181800,
	0x00140000,
	0x000c0095,
	0x000a1854,
	0x000c0092,
	0x000a0824,
	0x000a1818,
	0x00140000,
	0x000a1000,
	0x00060000,
	0x00060000,
	0x000c0084,
	0x00068002,
	0x00170867,
	0x0016086b,
	0x000c0098,
	0x0016d86b,
	0x00060001,
	0x0016086c,
	0x00060000,
	0x00140000,
	0x000c0094,
	0x000a1854,
	0x000c0091,
	0x000a181c,
	0x000a0c44,
	0x00181800,
	0x000c0094,
	0x000a1854,
	0x000c0091,
	0x000a1820,
	0x000a0c08,
	0x00181800,
	0x00140000,
	0x000c00a4,
	0x000e00a3,
	0x000c00a6,
	0x000e00a5,
	0x000c00a8,
	0x000e00a7,
	0x000c00aa,
	0x000e00a9,
	0x000c0091,
	0x000e0090,
	0x000c0092,
	0x000e0091,
	0x000c0094,
	0x000e0093,
	0x000c0095,
	0x000e0094,
	0x00140000,
	0x000c0077,
	0x00021800,
	0x000e0077,
	0x000c00f7,
	0x000e00f8,
	0x000c00f4,
	0x000e00f7,
	0x000c00f3,
	0x000e00f4,
	0x000c0075,
	0x000e00f3,
	0x000c0068,
	0x000e00f9,
	0x000c00f9,
	0x00041800,
	0x000e00f9,
	0x001758ab,
	0x0010872f,
	0x0011075a,
	0x00060000,
	0x000e00ae,
	0x000e00af,
	0x000e00b0,
	0x000e00b1,
	0x000a0490,
	0x0010872f,
	0x000c00ae,
	0x001758a4,
	0x00180400,
	0x0011075a,
	0x0010872f,
	0x00160898,
	0x000c002f,
	0x001728ae,
	0x001608b2,
	0x000c0041,
	0x00070080,
	0x00041000,
	0x000a0414,
	0x000a0490,
	0x00140000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	0x001e0000,
	};


#define SEGMENT1_DATA_TYPE	1
#define SEGMENT1_LENGTH	1024
static const unsigned short KFIR_DSP_RISC_MC[] =
	{
	0x0000,
	0xd080,
	0xd400,
	0xe001,
	0x3000,
	0x3401,
	0x701c,
	0x5000,
	0xf000,
	0xd000,
	0xd400,
	0xe013,
	0x5000,
	0xf000,
	0xd000,
	0xd500,
	0xe017,
	0x5000,
	0xf000,
	0xd000,
	0xd400,
	0xe01b,
	0x5000,
	0xf000,
	0xd080,
	0xd400,
	0xe01f,
	0x5000,
	0xf000,
	0x9016,
	0x3403,
	0xc444,
	0xd0a0,
	0xd740,
	0xe04e,
	0x5000,
	0xd080,
	0xd460,
	0xe022,
	0x5000,
	0x4400,
	0x6400,
	0x143c,
	0x6c00,
	0x101c,
	0x9400,
	0xcc38,
	0x9401,
	0xcc38,
	0xd0e0,
	0xd500,
	0xe031,
	0x300c,
	0xb018,
	0x5000,
	0xc044,
	0x9000,
	0x9401,
	0xc442,
	0xd0c0,
	0xd500,
	0xe031,
	0x3004,
	0xb018,
	0x5000,
	0xc044,
	0x3008,
	0xb018,
	0xd080,
	0xe067,
	0x5000,
	0x4000,
	0xd090,
	0xe067,
	0x4400,
	0x6000,
	0x183c,
	0x6800,
	0x102c,
	0xb030,
	0x6400,
	0x18fa,
	0x107c,
	0x107c,
	0x20ac,
	0x143c,
	0x6c00,
	0x183c,
	0x6400,
	0x106c,
	0xb031,
	0x6800,
	0x10f0,
	0x187e,
	0x187e,
	0x208e,
	0xcc62,
	0x143c,
	0x5000,
	0x4000,
	0xd180,
	0xe067,
	0x4400,
	0x6000,
	0x183c,
	0x6800,
	0x102c,
	0xb032,
	0x6400,
	0x18fa,
	0x107c,
	0x107c,
	0x20ac,
	0xcc73,
	0x143c,
	0x6c00,
	0x183c,
	0x6400,
	0x106c,
	0xb033,
	0x6800,
	0x10f0,
	0x187e,
	0x187e,
	0x208e,
	0xcc7f,
	0x143c,
	0x5000,
	0x4000,
	0xd182,
	0xe067,
	0x4400,
	0x6000,
	0x183c,
	0x6800,
	0x102c,
	0xb034,
	0x6400,
	0x18fa,
	0x107c,
	0x107c,
	0x20ac,
	0xcc90,
	0x143c,
	0x6c00,
	0x183c,
	0x6400,
	0x106c,
	0xb035,
	0x6800,
	0x10f0,
	0x187e,
	0x187e,
	0x208e,
	0xcc9c,
	0x143c,
	0x183d,
	0x9016,
	0x3401,
	0xc8a7,
	0x5000,
	0x4000,
	0xd080,
	0xd420,
	0xe06d,
	0x4400,
	0xc0aa,
	0x5000,
	0x4000,
	0x4400,
	0x143e,
	0x6000,
	0x183c,
	0x6800,
	0x102c,
	0xb036,
	0x6400,
	0x18fa,
	0x107c,
	0x107c,
	0x20ac,
	0xccb7,
	0x143c,
	0x6c00,
	0x183c,
	0x6400,
	0x106c,
	0xb037,
	0x6800,
	0x10f0,
	0x187e,
	0x187e,
	0x208e,
	0xccc3,
	0x143c,
	0x3000,
	0xc4c6,
	0x143c,
	0x3001,
	0x101c,
	0xb006,
	0x9408,
	0x101c,
	0xb008,
	0x9016,
	0x3401,
	0xc8ec,
	0x5000,
	0xd090,
	0xd430,
	0xe06d,
	0x4400,
	0x9430,
	0x9032,
	0x105c,
	0x18f0,
	0x9431,
	0x9033,
	0x105c,
	0x202c,
	0xb034,
	0x6400,
	0x143c,
	0x6c00,
	0x185c,
	0x5000,
	0x4400,
	0x6400,
	0x143c,
	0x6c00,
	0x105c,
	0x106c,
	0x9434,
	0xc4f2,
	0x9422,
	0xc4f2,
	0xd080,
	0xd400,
	0xe059,
	0x3001,
	0xb018,
	0xc0f6,
	0xd080,
	0xd420,
	0xe038,
	0x3000,
	0xb035,
	0x9028,
	0x3400,
	0x5000,
	0xcd3b,
	0xd180,
	0xe067,
	0x5000,
	0x4000,
	0xd182,
	0xe067,
	0x4400,
	0x6000,
	0x143c,
	0x6800,
	0x189c,
	0x10ba,
	0x100c,
	0xb030,
	0x6400,
	0x143c,
	0x6c00,
	0x109c,
	0x9430,
	0x20dc,
	0xb030,
	0x5000,
	0x4000,
	0xd180,
	0xd402,
	0xe078,
	0x4400,
	0x6000,
	0x143c,
	0x6800,
	0x149c,
	0x10b5,
	0x100c,
	0xb031,
	0x18b9,
	0x102e,
	0x6400,
	0x143c,
	0x6c00,
	0x109c,
	0x9431,
	0x24dc,
	0x9030,
	0x1074,
	0xb030,
	0x3401,
	0x5000,
	0xc539,
	0x4400,
	0x6400,
	0x143c,
	0x6c00,
	0x109c,
	0x206c,
	0x107c,
	0x107c,
	0x3401,
	0xc539,
	0x10f0,
	0x107c,
	0x9430,
	0xcd3b,
	0x3001,
	0xc13c,
	0x3000,
	0xb019,
	0xd300,
	0xd600,
	0x3400,
	0xcd47,
	0x3000,
	0xdb40,
	0x3000,
	0xdc00,
	0xe08a,
	0xc14c,
	0x3000,
	0xdb50,
	0x3000,
	0xdc00,
	0xe08a,
	0x9007,
	0x9406,
	0x100c,
	0x101c,
	0x181d,
	0x9407,
	0x182d,
	0x34ff,
	0xc157,
	0x107c,
	0x187e,
	0xcd55,
	0x3440,
	0x101c,
	0xa000,
	0x3410,
	0x1098,
	0x107c,
	0xb030,
	0x9005,
	0x3880,
	0x10ec,
	0x941c,
	0x1034,
	0x10ec,
	0x9417,
	0x1034,
	0x9403,
	0x200d,
	0x9404,
	0x201c,
	0x9402,
	0x101c,
	0x941d,
	0x10f4,
	0x10ec,
	0x100c,
	0x100c,
	0xb031,
	0x9430,
	0x10f4,
	0x18ec,
	0x902e,
	0x3403,
	0xc97d,
	0x3401,
	0xcd8c,
	0xc99b,
	0xc1ac,
	0x103e,
	0x3401,
	0xcd82,
	0x3001,
	0xc185,
	0x3470,
	0xc585,
	0x3070,
	0x183c,
	0x9021,
	0x3402,
	0x1839,
	0x340e,
	0x10a4,
	0xc1bc,
	0x3000,
	0x9431,
	0xc590,
	0x143c,
	0x9021,
	0x381a,
	0x1038,
	0x3806,
	0x1089,
	0x107c,
	0x9430,
	0x3880,
	0x10f4,
	0x10ec,
	0xc1bc,
	0x9021,
	0x9431,
	0xc5a2,
	0x3803,
	0x1049,
	0x107c,
	0xc1a7,
	0x381d,
	0x1038,
	0x3803,
	0x1089,
	0x107c,
	0x9430,
	0x3880,
	0x10f4,
	0x10ec,
	0xc1bc,
	0x9021,
	0x9431,
	0xc5b3,
	0x3803,
	0x1049,
	0x107c,
	0xc1b8,
	0x3804,
	0x1038,
	0x381c,
	0x1089,
	0x107c,
	0x9430,
	0x3880,
	0x10f4,
	0x10ec,
	0x3402,
	0xcdc0,
	0x3002,
	0xc1c3,
	0x3470,
	0xc5c3,
	0x3070,
	0x183c,
	0x902f,
	0x3401,
	0xc9cc,
	0x107e,
	0x3404,
	0xcdcb,
	0x3004,
	0x183c,
	0x103e,
	0xb030,
	0x3540,
	0x101c,
	0xa000,
	0x14fc,
	0x3900,
	0x1839,
	0x202c,
	0xb01f,
	0x103d,
	0xb030,
	0x35cd,
	0x101c,
	0xa000,
	0x18fc,
	0x3500,
	0x1439,
	0x201c,
	0xb031,
	0x9035,
	0x3400,
	0xc9ec,
	0x900f,
	0x140c,
	0x3007,
	0x241c,
	0x9031,
	0x101c,
	0xb031,
	0x31bf,
	0xc1ed,
	0x31b1,
	0x102c,
	0xa000,
	0xb032,
	0x901f,
	0x9415,
	0x101c,
	0xb015,
	0x9035,
	0x3401,
	0xc9fe,
	0x3000,
	0x5000,
	0xd340,
	0xd700,
	0xdb40,
	0xe0d7,
	0xc204,
	0x3000,
	0x5000,
	0xd340,
	0xd700,
	0xdb40,
	0xe07e,
	0x9030,
	0x35ed,
	0x101c,
	0xa000,
	0x18fc,
	0x3500,
	0x1439,
	0x201c,
	0xb033,
	0x9035,
	0x3400,
	0xca19,
	0x900f,
	0x140c,
	0x3001,
	0x141c,
	0x9033,
	0x101c,
	0xb033,
	0x31c6,
	0xc21a,
	0x31b8,
	0x102c,
	0xa000,
	0xb034,
	0x9018,
	0x147c,
	0x141d,
	0x201c,
	0x3400,
	0x5000,
	0xd0e0,
	0xd700,
	0xca34,
	0x9032,
	0xd806,
	0x9031,
	0xdc00,
	0xe096,
	0x9032,
	0x5000,
	0xd0f0,
	0xd780,
	0xd806,
	0x9031,
	0xdc00,
	0xe096,
	0xc241,
	0x9032,
	0xd804,
	0x9031,
	0xdc00,
	0xe09b,
	0x9032,
	0x5000,
	0xd0f0,
	0xd780,
	0xd804,
	0x9031,
	0xdc00,
	0xe09b,
	0x8000,
	0x143c,
	0x5000,
	0x8400,
	0x181c,
	0x9035,
	0x3400,
	0xca4c,
	0x303f,
	0x3800,
	0xc24e,
	0x103e,
	0x3802,
	0xb01e,
	0xca8f,
	0x901f,
	0x9420,
	0xca56,
	0xb020,
	0x3410,
	0xc257,
	0x3400,
	0x9018,
	0x101c,
	0x102c,
	0xb018,
	0x902f,
	0x3401,
	0xca8f,
	0x9018,
	0x147c,
	0x141d,
	0x201c,
	0x3400,
	0xca85,
	0xd0e0,
	0xd700,
	0x3030,
	0xd806,
	0x3007,
	0xdc00,
	0xe0bf,
	0x5000,
	0xd0f0,
	0xd780,
	0x3030,
	0xd806,
	0x3007,
	0xdc00,
	0xe0bf,
	0x5000,
	0xd0e0,
	0xd700,
	0x3030,
	0xd806,
	0x3037,
	0xdc00,
	0xe0cb,
	0x5000,
	0xd0f0,
	0xd780,
	0x3030,
	0xd806,
	0x3037,
	0xdc00,
	0xe0cb,
	0x5000,
	0xc28f,
	0xd0e0,
	0xd700,
	0xd804,
	0xe0c4,
	0x5000,
	0xd0e0,
	0xd700,
	0xd804,
	0xe0d0,
	0x5000,
	0x9016,
	0x3403,
	0xc693,
	0xf000,
	0x9035,
	0x3400,
	0xd0e0,
	0xd600,
	0xcaa5,
	0x9034,
	0xdb02,
	0x9033,
	0xdc02,
	0xe0a2,
	0x9034,
	0x5000,
	0xd0f0,
	0xd680,
	0xdb02,
	0x9033,
	0xdc02,
	0xc2b1,
	0x9034,
	0xdb00,
	0x9033,
	0xdc03,
	0xe0a2,
	0x9034,
	0x5000,
	0xd0f0,
	0xd680,
	0xdb00,
	0x9033,
	0xdc03,
	0xe0a2,
	0x5000,
	0x3010,
	0x5000,
	0xd340,
	0xd400,
	0xdb40,
	0x3000,
	0xdc00,
	0xe0a7,
	0x3020,
	0x5000,
	0xd300,
	0xd600,
	0xdb40,
	0xe0b3,
	0x9035,
	0x3400,
	0x5000,
	0xd0c0,
	0xd420,
	0xcecf,
	0x9019,
	0xcecb,
	0xd808,
	0xc2cc,
	0xd828,
	0xe043,
	0x5000,
	0xf000,
	0x9019,
	0xced3,
	0xd808,
	0xc2d4,
	0xd828,
	0xe060,
	0x5000,
	0xf000,
	0x9009,
	0x9414,
	0xcede,
	0x101c,
	0x147d,
	0xcede,
	0x103d,
	0xb009,
	0x3000,
	0xb02a,
	0xf000,
	0x9003,
	0xb004,
	0x3000,
	0xb015,
	0xb008,
	0x9016,
	0x3402,
	0xcb3c,
	0x3403,
	0xcb55,
	0x9010,
	0xb002,
	0x900c,
	0x34ff,
	0xc6f3,
	0x30ff,
	0xc2f6,
	0x3400,
	0xcef6,
	0x3001,
	0x3440,
	0x101c,
	0xa400,
	0x900d,
	0x1834,
	0x900a,
	0x1038,
	0xb030,
	0x9023,
	0x10f4,
	0x14fc,
	0x900e,
	0x1434,
	0x900b,
	0x1434,
	0x9030,
	0x141c,
	0x3100,
	0x10d0,
	0x10bc,
	0x34ff,
	0xc70e,
	0x30ff,
	0xc311,
	0x3400,
	0xcf11,
	0x3001,
	0x3440,
	0x101c,
	0xa400,
	0x9009,
	0x10fc,
	0x10bc,
	0x1434,
	0x9013,
	0xcf1b,
	0x103d,
	0xb005,
	0x902a,
	0x3400,
	0xcb21,
	0x942c,
	0xc322,
	0x942b,
	0x101c,
	0xb02a,
	0x183c,
	0x9003,
	0x942d,
	0x10f4,
	0x10bc,
	0x107c,
	0x200e,
	0x3500,
	0x1435,
	0xc731,
	0x3801,
	0x202d,
	0xc334,
	0x3400,
	0xcf34,
	0x3000,
	0x14fc,
	0x3900,
	0x1839,
	0x202c,
	0xb026,
	0x103d,
	0xb027,
	0xf000,
	0x9011,
	0xb002,
	0x900d,
	0x34ff,
	0xc743,
	0x30ff,
	0xc346,
	0x3400,
	0xcf46,
	0x3001,
	0x3440,
	0x101c,
	0xa400,
	0x9023,
	0x10f4,
	0x14fc,
	0x900e,
	0x1434,
	0x900b,
	0x1834,
	0x900a,
	0x3500,
	0x1435,
	0x10e4,
	0xc309,
	0x9012,
	0xb002,
	0x900e,
	0x34ff,
	0xc75c,
	0x30ff,
	0xc35f,
	0x3400,
	0xcf5f,
	0x3001,
	0x3440,
	0x101c,
	0xa400,
	0x900d,
	0x1434,
	0x9024,
	0x14f4,
	0x900a,
	0x1834,
	0x900b,
	0x3500,
	0x1435,
	0x10e4,
	0xc309,
	0x9003,
	0x9404,
	0x281c,
	0x3400,
	0x9009,
	0x202c,
	0xb009,
	0x901c,
	0x9415,
	0x10f4,
	0xb015,
	0x14be,
	0x147d,
	0x147d,
	0x10f4,
	0x10fc,
	0x107c,
	0x3402,
	0xcf81,
	0x103d,
	0x34ff,
	0xc784,
	0x103d,
	0xb030,
	0x9405,
	0x241e,
	0x9002,
	0x101c,
	0xb002,
	0x103e,
	0xb004,
	0x3100,
	0x1870,
	0x901c,
	0x9408,
	0x10e4,
	0x10fc,
	0xb007,
	0x9016,
	0x3402,
	0xcb9d,
	0x3403,
	0xcba6,
	0x9030,
	0xb00c,
	0x9002,
	0xb010,
	0xf000,
	0x9030,
	0xb00d,
	0x9002,
	0xb011,
	0x900a,
	0x3401,
	0x201c,
	0xb00a,
	0xf000,
	0x9030,
	0xb00e,
	0x9002,
	0xb012,
	0x900b,
	0x3401,
	0x201c,
	0xb00b,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	0xf000,
	};
				
  
#define SEGMENT2_DATA_TYPE	0
#define SEGMENT2_LENGTH	576
static const unsigned long KFIR_DSP_RISC_CRAM[] =
	{
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x0000ffff,
	0x0000ffff,
	0x00008000,
	0x00005555,
	0x00004000,
	0x00003333,
	0x00002aaa,
	0x00002492,
	0x00002000,
	0x00001c71,
	0x00001999,
	0x00001745,
	0x00001555,
	0x000013b1,
	0x00001249,
	0x00001111,
	0x00001000,
	0x00000f0f,
	0x00000e38,
	0x00000d79,
	0x00000ccc,
	0x00000c30,
	0x00000ba2,
	0x00000b21,
	0x00000aaa,
	0x00000a3d,
	0x000009d8,
	0x0000097b,
	0x00000924,
	0x000008d3,
	0x00000888,
	0x00000842,
	0x00000800,
	0x000007c1,
	0x00000787,
	0x00000750,
	0x0000071c,
	0x000006eb,
	0x000006bc,
	0x00000690,
	0x00000666,
	0x0000063e,
	0x00000618,
	0x000005f4,
	0x000005d1,
	0x000005b0,
	0x00000590,
	0x00000572,
	0x00000555,
	0x00000539,
	0x0000051e,
	0x00000505,
	0x000004ec,
	0x000004d4,
	0x000004bd,
	0x000004a7,
	0x00000492,
	0x0000047d,
	0x00000469,
	0x00000456,
	0x00000444,
	0x00000432,
	0x00000421,
	0x00000410,
	0x00000400,
	0x000003f0,
	0x000003e0,
	0x000003d2,
	0x000003c3,
	0x000003b5,
	0x000003a8,
	0x0000039b,
	0x0000038e,
	0x00000381,
	0x00000375,
	0x00000369,
	0x0000035e,
	0x00000353,
	0x00000348,
	0x0000033d,
	0x00000333,
	0x00000329,
	0x0000031f,
	0x00000315,
	0x0000030c,
	0x00000303,
	0x000002fa,
	0x000002f1,
	0x000002e8,
	0x000002e0,
	0x000002d8,
	0x000002d0,
	0x000002c8,
	0x000002c0,
	0x000002b9,
	0x000002b1,
	0x000002aa,
	0x000002a3,
	0x0000029c,
	0x00000295,
	0x0000028f,
	0x00000288,
	0x00000282,
	0x0000027c,
	0x00000276,
	0x00000270,
	0x0000026a,
	0x00000264,
	0x0000025e,
	0x00000259,
	0x00000253,
	0x0000024e,
	0x00000249,
	0x00000243,
	0x0000023e,
	0x00000239,
	0x00000234,
	0x00000230,
	0x0000022b,
	0x00000226,
	0x00000222,
	0x0000021d,
	0x00000219,
	0x00000214,
	0x00000210,
	0x0000020c,
	0x00000208,
	0x00000204,
	0x00000200,
	0x000001fc,
	0x000001f8,
	0x000001f4,
	0x000001f0,
	0x000001ec,
	0x000001e9,
	0x000001e5,
	0x000001e1,
	0x000001de,
	0x000001da,
	0x000001d7,
	0x000001d4,
	0x000001d0,
	0x000001cd,
	0x000001ca,
	0x000001c7,
	0x000001c3,
	0x000001c0,
	0x000001bd,
	0x000001ba,
	0x000001b7,
	0x000001b4,
	0x000001b2,
	0x000001af,
	0x000001ac,
	0x000001a9,
	0x000001a6,
	0x000001a4,
	0x000001a1,
	0x0000019e,
	0x0000019c,
	0x00000199,
	0x00000197,
	0x00000194,
	0x00000192,
	0x0000018f,
	0x0000018d,
	0x0000018a,
	0x00000188,
	0x00000186,
	0x00000183,
	0x00000181,
	0x0000017f,
	0x0000017d,
	0x0000017a,
	0x00000178,
	0x00000176,
	0x00000174,
	0x00000172,
	0x00000170,
	0x0000016e,
	0x0000016c,
	0x0000016a,
	0x00000168,
	0x00000166,
	0x00000164,
	0x00000162,
	0x00000160,
	0x0000015e,
	0x0000015c,
	0x0000015a,
	0x00000158,
	0x00000157,
	0x00000155,
	0x00000153,
	0x00000151,
	0x00000150,
	0x0000014e,
	0x0000014c,
	0x0000014a,
	0x00000149,
	0x00000147,
	0x00000146,
	0x00000144,
	0x00000142,
	0x00000141,
	0x0000013f,
	0x0000013e,
	0x0000013c,
	0x0000013b,
	0x00000139,
	0x00000138,
	0x00000136,
	0x00000135,
	0x00000133,
	0x00000132,
	0x00000130,
	0x0000012f,
	0x0000012e,
	0x0000012c,
	0x0000012b,
	0x00000129,
	0x00000128,
	0x00000127,
	0x00000125,
	0x00000124,
	0x00000123,
	0x00000121,
	0x00000120,
	0x0000011f,
	0x0000011e,
	0x0000011c,
	0x0000011b,
	0x0000011a,
	0x00000119,
	0x00000118,
	0x00000116,
	0x00000115,
	0x00000114,
	0x00000113,
	0x00000112,
	0x00000111,
	0x0000010f,
	0x0000010e,
	0x0000010d,
	0x0000010c,
	0x0000010b,
	0x0000010a,
	0x00000109,
	0x00000108,
	0x00000107,
	0x00000106,
	0x00000105,
	0x00000104,
	0x00000103,
	0x00000102,
	0x00000101,
	0x00000000,
	0x00000101,
	0x00000202,
	0x00000303,
	0x00000404,
	0x00000505,
	0x00000606,
	0x00000707,
	0x00000808,
	0x00000808,
	0x0000090a,
	0x0000090a,
	0x00000a0c,
	0x00000a0c,
	0x00000b0e,
	0x00000b0e,
	0x00000c10,
	0x00000c10,
	0x00000d12,
	0x00000d12,
	0x00000e14,
	0x00000e14,
	0x00000f16,
	0x00000f16,
	0x00001018,
	0x00001018,
	0x00001018,
	0x0000111c,
	0x0000111c,
	0x0000111c,
	0x00001220,
	0x00001220,
	0x00001220,
	0x00001220,
	0x00001324,
	0x00001324,
	0x00001324,
	0x00001324,
	0x00001428,
	0x00001428,
	0x00001428,
	0x00001428,
	0x0000152c,
	0x0000152c,
	0x0000152c,
	0x0000152c,
	0x00001630,
	0x00001630,
	0x00001630,
	0x00001630,
	0x00001734,
	0x00001734,
	0x00001734,
	0x00001734,
	0x00001838,
	0x00001838,
	0x00001838,
	0x00001838,
	0x00001838,
	0x00001838,
	0x00001838,
	0x00001940,
	0x00001940,
	0x00001940,
	0x00001940,
	0x00001940,
	0x00001940,
	0x00001940,
	0x00001a48,
	0x00001a48,
	0x00001a48,
	0x00001a48,
	0x00001a48,
	0x00001a48,
	0x00001a48,
	0x00001a48,
	0x00001b50,
	0x00001b50,
	0x00001b50,
	0x00001b50,
	0x00001b50,
	0x00001b50,
	0x00001b50,
	0x00001b50,
	0x00001c58,
	0x00001c58,
	0x00001c58,
	0x00001c58,
	0x00001c58,
	0x00001c58,
	0x00001c58,
	0x00001d60,
	0x00001d60,
	0x00001d60,
	0x00001d60,
	0x00001d60,
	0x00001d60,
	0x00001d60,
	0x00001d60,
	0x00001d60,
	0x00001d60,
	0x00001e68,
	0x00001e68,
	0x00001e68,
	0x00001e68,
	0x00001e68,
	0x00001e68,
	0x00001e68,
	0x00001f70,
	0x00001f70,
	0x00001f70,
	0x00001f70,
	0x00001f70,
	0x00000030,
	0x00000031,
	0x00000032,
	0x00000033,
	0x00000034,
	0x00000035,
	0x00000036,
	0x00000037,
	0x00000038,
	0x00000039,
	0x0000003a,
	0x0000003b,
	0x0000003c,
	0x0000003d,
	0x0000003e,
	0x0000004e,
	0x0000005e,
	0x0000006e,
	0x0000007e,
	0x0000008e,
	0x0000009e,
	0x000000ae,
	0x000000be,
	0x000000ce,
	0x000000de,
	0x000000ee,
	0x000000fe,
	0x0000010e,
	0x00000000,
	0x00000000,
	0x00000008,
	0x00000100,
	0x00000010,
	0x00000200,
	0x00000108,
	0x00000300,
	0x00000018,
	0x00000208,
	0x00000110,
	0x00000308,
	0x00000020,
	0x00000400,
	0x00000210,
	0x00000500,
	0x00000118,
	0x00000310,
	0x00000028,
	0x00000408,
	0x00000218,
	0x00000508,
	0x00000120,
	0x00000600,
	0x00000318,
	0x00000030,
	0x00000410,
	0x00000220,
	0x00000510,
	0x00000128,
	0x00000608,
	0x00000320,
	0x00000000,
	0x00000030,
	0x00000028,
	0x00000428,
	0x00000020,
	0x00000220,
	0x00000420,
	0x00000620,
	0x00000018,
	0x00000218,
	0x00000418,
	0x00000618,
	0x00000010,
	0x00000110,
	0x00000210,
	0x00000310,
	0x00000410,
	0x00000610,
	0x00000008,
	0x00000108,
	0x00000208,
	0x00000308,
	0x00000408,
	0x00000508,
	0x00000608,
	0x00000000,
	0x00000100,
	0x00000200,
	0x00000300,
	0x00000400,
	0x00000500,
	0x00000600,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	};


#define SEGMENT3_DATA_TYPE	0
#define SEGMENT3_LENGTH	256
static const unsigned long KFIR_DSP_UNIT_MC[] =
	{
	0x0e007a6f,
	0x0a007a2f,
	0x04200000,
	0x0a200000,
	0x04200000,
	0x0a200000,
	0x04200000,
	0x0a200000,
	0x04200000,
	0x0a200000,
	0x04200000,
	0x0a200000,
	0x04200000,
	0x0a200000,
	0x04200000,
	0x0a200000,
	0x04200000,
	0x00200000,
	0x0e007a00,
	0x0b000074,
	0x05400074,
	0x01400050,
	0x0e007a00,
	0x0a000074,
	0x04400074,
	0x00400050,
	0x0e007a00,
	0x09e00001,
	0x05e00001,
	0x01e00001,
	0x0e007a00,
	0x09e00001,
	0x04e00001,
	0x0e007a00,
	0x00807a2d,
	0x0a800004,
	0x00013803,
	0x00809a07,
	0x04805821,
	0x00013803,
	0x00809a07,
	0x0a805821,
	0x00013803,
	0x00809a07,
	0x04805821,
	0x00013803,
	0x00809a03,
	0x00805820,
	0x0e007a00,
	0x00807a2d,
	0x0a807821,
	0x04a07821,
	0x0aa07821,
	0x04a07821,
	0x00200000,
	0x0e007a00,
	0x00807a2d,
	0x0a800004,
	0x00813821,
	0x04a00004,
	0x00813821,
	0x0aa00004,
	0x00813821,
	0x04a00004,
	0x00013820,
	0x00200000,
	0x0e007a00,
	0x00807a2d,
	0x0a800004,
	0x00803821,
	0x04a00004,
	0x00803821,
	0x0aa00004,
	0x00803821,
	0x04a00004,
	0x00003820,
	0x00200000,
	0x0e007a00,
	0x00807a2d,
	0x0a800004,
	0x008c3821,
	0x04a00004,
	0x008c3821,
	0x0aa00004,
	0x008c3821,
	0x04a00004,
	0x000c3820,
	0x00200000,
	0x0e007a00,
	0x00807c0d,
	0x0a813821,
	0x04a13821,
	0x0aa13821,
	0x04a13821,
	0x00200000,
	0x0e007a00,
	0x00807c0d,
	0x0a803821,
	0x04a03821,
	0x0aa03821,
	0x04a03821,
	0x00200000,
	0x0e007a00,
	0x0a807a2d,
	0x0000380c,
	0x04804021,
	0x0000380c,
	0x00004020,
	0x0e007a00,
	0x00807a2d,
	0x0a800004,
	0x00813807,
	0x04804021,
	0x00013803,
	0x00004020,
	0x0e007a00,
	0x0a807a2d,
	0x04804021,
	0x00004020,
	0x0e007a00,
	0x0a807a2d,
	0x00800004,
	0x048040a1,
	0x00800004,
	0x000040a0,
	0x0e007a00,
	0x06807a2d,
	0x00000000,
	0x02844921,
	0x00844921,
	0x00844921,
	0x00844921,
	0x00844921,
	0x00844921,
	0x0c844921,
	0x009c4921,
	0x04a46921,
	0x0e007a00,
	0x06807a2d,
	0x00000000,
	0x02844921,
	0x00844921,
	0x00844921,
	0x00844921,
	0x00844921,
	0x00844921,
	0x0c844921,
	0x009c4921,
	0x04a46921,
	0x0e007a00,
	0x00807a2d,
	0x0a8c7121,
	0x04ac7121,
	0x00200000,
	0x0e007a00,
	0x00807a2d,
	0x00001803,
	0x0a827121,
	0x00201803,
	0x04827121,
	0x00200000,
	0x0e007a00,
	0x00807a09,
	0x0a986121,
	0x04b86121,
	0x00200000,
	0x0e007a00,
	0x06807a2d,
	0x00000000,
	0x02844921,
	0x00844921,
	0x00844921,
	0x00844921,
	0x00844921,
	0x00844921,
	0x0c844921,
	0x009c4921,
	0x04a46921,
	0x0e007a00,
	0x06807a2d,
	0x00000000,
	0x02844921,
	0x00844921,
	0x00844921,
	0x00844921,
	0x00844921,
	0x00844921,
	0x0c844921,
	0x009c4921,
	0x04a46921,
	0x0e007a00,
	0x06907c0d,
	0x0a806921,
	0x04b060a1,
	0x003060a0,
	0x0e007a00,
	0x00907c0d,
	0x0a9060a1,
	0x04b060a1,
	0x0ab060a1,
	0x04b060a1,
	0x003060a0,
	0x0e007a00,
	0x06807c0d,
	0x0a806921,
	0x04b068a1,
	0x003068a0,
	0x0e007a00,
	0x00807c0d,
	0x0a9068a1,
	0x04b068a1,
	0x0ab068a1,
	0x04b068a1,
	0x003068a0,
	0x0e007a00,
	0x06807a2d,
	0x00000000,
	0x02845121,
	0x00845121,
	0x00845121,
	0x00845121,
	0x00845121,
	0x00845121,
	0x0c845121,
	0x00805121,
	0x04a47121,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	0x0e007a00,
	};


#define SEGMENT4_DATA_TYPE	0
#define SEGMENT4_LENGTH	1024
static const unsigned long KFIR_BSM_MC[] =
	{
	0x00c00000,
	0x05c00087,
	0x05000600,
	0x05c00c87,
	0x00000000,
	0x05c00e87,
	0x00000000,
	0x00c00907,
	0x00407a87,
	0x044000a2,
	0x054018ba,
	0x00000000,
	0x004078c7,
	0x02c000d9,
	0x0141003b,
	0x00c004c7,
	0x008078c7,
	0x00407c87,
	0x044000a2,
	0x054018ba,
	0x00000000,
	0x00403a87,
	0x054008ba,
	0x00000000,
	0x00407e87,
	0x054008ba,
	0x00000000,
	0x00403e87,
	0x054004ba,
	0x00000000,
	0x00403c87,
	0x054010ba,
	0x00000000,
	0x00403887,
	0x054010ba,
	0x00000000,
	0x054002b9,
	0x00000000,
	0x00404487,
	0x054014ba,
	0x00000000,
	0x054002b8,
	0x00000000,
	0x0040a087,
	0x01000191,
	0x0040a0c7,
	0x0187303b,
	0x05000600,
	0x05c01e87,
	0x00000000,
	0x05c02087,
	0x00000000,
	0x05c02287,
	0x00000000,
	0x05c02487,
	0x00000000,
	0x00404287,
	0x0540008a,
	0x00000000,
	0x05c02687,
	0x00000000,
	0x054004b8,
	0x00000000,
	0x00000000,
	0x054018b8,
	0x00000000,
	0x054002b9,
	0x00000000,
	0x05c06c87,
	0x054010ba,
	0x00000000,
	0x00403687,
	0x054002ba,
	0x00000000,
	0x0040ae87,
	0x054004ba,
	0x00000000,
	0x0040b087,
	0x05400aba,
	0x00000000,
	0x05000600,
	0x05c01e87,
	0x00000000,
	0x05c02087,
	0x00000000,
	0x05c03287,
	0x00000000,
	0x00407887,
	0x054006ba,
	0x00000000,
	0x00c00287,
	0x054002ba,
	0x00000000,
	0x00404887,
	0x054010ba,
	0x00000000,
	0x00404a87,
	0x054010ba,
	0x00000000,
	0x00404c87,
	0x054010ba,
	0x00000000,
	0x00c58087,
	0x05401cba,
	0x00000000,
	0x00c00287,
	0x054002ba,
	0x00000000,
	0x004078c7,
	0x0147123b,
	0x00c48087,
	0x05401cba,
	0x03472000,
	0x05c03a87,
	0x00000000,
	0x02800000,
	0x05000600,
	0x05c03c87,
	0x00000000,
	0x05c03e87,
	0x00000000,
	0x03ab1000,
	0x00404e87,
	0x0540008a,
	0x00000000,
	0x054002b8,
	0x00000000,
	0x05000600,
	0x02800000,
	0x05000600,
	0x05c04287,
	0x00000000,
	0x05c04487,
	0x00000000,
	0x00405087,
	0x054014ba,
	0x00000000,
	0x00405347,
	0x054006bd,
	0x00000000,
	0x00403487,
	0x054010ba,
	0x00000000,
	0x00403287,
	0x054010ba,
	0x00000000,
	0x0189d23d,
	0x05c04687,
	0x00000000,
	0x0040a0c7,
	0x0189a03b,
	0x05c04887,
	0x00000000,
	0x0349d000,
	0x00405687,
	0x054006ba,
	0x00000000,
	0x014a863d,
	0x05c04a87,
	0x00000000,
	0x0040a0c7,
	0x018a503b,
	0x05c04c87,
	0x00000000,
	0x034a8000,
	0x00405a87,
	0x054006ba,
	0x00000000,
	0x054002b8,
	0x00000000,
	0x0040a0c7,
	0x018dc03b,
	0x05000600,
	0x05c01e87,
	0x00000000,
	0x05c02087,
	0x00000000,
	0x05c05087,
	0x00000000,
	0x00405687,
	0x054008ba,
	0x00000000,
	0x00405ac7,
	0x00000000,
	0x054008bb,
	0x00000000,
	0x00405ec7,
	0x00000000,
	0x054004bb,
	0x00000000,
	0x00c00687,
	0x054004ba,
	0x00000000,
	0x00404087,
	0x0540008a,
	0x00000000,
	0x00406087,
	0x0540008a,
	0x00000000,
	0x054002b8,
	0x00000000,
	0x0040a0c7,
	0x0540008b,
	0x00000000,
	0x00406487,
	0x0240000a,
	0x0540008a,
	0x00000000,
	0x00406687,
	0x0540008a,
	0x00000000,
	0x00406c87,
	0x0540008a,
	0x00000000,
	0x00406887,
	0x0540008a,
	0x00000000,
	0x00000000,
	0x054002b8,
	0x00000000,
	0x0040a087,
	0x01000191,
	0x00806c07,
	0x004026c7,
	0x00c000d9,
	0x008026c7,
	0x05000600,
	0x00806a07,
	0x00808c07,
	0x00809a07,
	0x00809e07,
	0x0101fef8,
	0x0080a2c7,
	0x0080aa07,
	0x0080ac07,
	0x02800000,
	0x00406cc7,
	0x05000600,
	0x05c05c87,
	0x00000000,
	0x05c05e87,
	0x00c00093,
	0x054020ba,
	0x00000000,
	0x00c000d9,
	0x00806cc7,
	0x0040a107,
	0x00406ec7,
	0x014fb23c,
	0x05c0809f,
	0x034fc000,
	0x0400008b,
	0x05400aba,
	0x00000000,
	0x054002b8,
	0x00000000,
	0x00808007,
	0x00808807,
	0x00808a07,
	0x00807607,
	0x00800207,
	0x00800407,
	0x00800607,
	0x00800847,
	0x02800000,
	0x00802007,
	0x00409ec7,
	0x0191d23b,
	0x00409ac7,
	0x00c00307,
	0x02c000dc,
	0x0191923b,
	0x00808007,
	0x00808807,
	0x00808a07,
	0x004052c7,
	0x0151d43b,
	0x00409ac7,
	0x00c01107,
	0x02c000dc,
	0x0151d03b,
	0x00807607,
	0x00800207,
	0x00800407,
	0x00800607,
	0x00809e07,
	0x00406ac7,
	0x00c000cb,
	0x00806ac7,
	0x00407b07,
	0x00c00121,
	0x02125023,
	0x00806a47,
	0x00406ac7,
	0x00c05b07,
	0x0212d023,
	0x00c002c7,
	0x00800ac7,
	0x00c07ec7,
	0x008010c7,
	0x00801c47,
	0x00400ac7,
	0x00809ac7,
	0x02c0191f,
	0x00400c87,
	0x00800d07,
	0x00800e87,
	0x00406ac7,
	0x01d3723b,
	0x038ec000,
	0x03561000,
	0x00407b07,
	0x01961023,
	0x004010c7,
	0x0156103b,
	0x004052c7,
	0x0154543b,
	0x00400ac7,
	0x02c010df,
	0x0154503b,
	0x004008c7,
	0x00c000cb,
	0x008008c7,
	0x00808c47,
	0x02800000,
	0x004052c7,
	0x0156163b,
	0x00400c87,
	0x00400f47,
	0x0156102a,
	0x00c01107,
	0x02c000d4,
	0x01553023,
	0x004014c7,
	0x00407707,
	0x01561023,
	0x004016c7,
	0x00400307,
	0x01561023,
	0x02c008d7,
	0x0155b83b,
	0x004018c7,
	0x00400507,
	0x01561023,
	0x00401ac7,
	0x00400707,
	0x01561023,
	0x004008c7,
	0x00c000cb,
	0x008008c7,
	0x00808c47,
	0x00809e47,
	0x02800000,
	0x004052c7,
	0x0156943b,
	0x004010c7,
	0x0156903b,
	0x00400ac7,
	0x030010df,
	0x00800ac7,
	0x00800cc7,
	0x004008c7,
	0x00c04507,
	0x02171023,
	0x00c01087,
	0x054016ba,
	0x00000000,
	0x010042fb,
	0x0356a000,
	0x05c1609f,
	0x00000000,
	0x00800847,
	0x00400ac7,
	0x00405347,
	0x0157923d,
	0x05c1a49f,
	0x0357d000,
	0x0157c43d,
	0x05c1e49f,
	0x0357d000,
	0x05c2249f,
	0x00000000,
	0x00406107,
	0x0158503c,
	0x00400cc7,
	0x0198503b,
	0x00c00487,
	0x054004ba,
	0x00000000,
	0x0158b03c,
	0x004010c7,
	0x0198b03b,
	0x00401c87,
	0x0540008a,
	0x00000000,
	0x00400ac7,
	0x02c020df,
	0x0199603b,
	0x00401f07,
	0x0040a0c7,
	0x0159323b,
	0x05c080a7,
	0x03594000,
	0x0400008c,
	0x05400aba,
	0x00000000,
	0x00400ac7,
	0x02c010df,
	0x019a503b,
	0x004014c7,
	0x00407707,
	0x008076c7,
	0x010000e3,
	0x00405707,
	0x03ae2000,
	0x004016c7,
	0x00400307,
	0x008002c7,
	0x010000e3,
	0x00405707,
	0x03ae2000,
	0x00400ac7,
	0x02c008df,
	0x015b483b,
	0x004018c7,
	0x00400507,
	0x008004c7,
	0x010000e3,
	0x00405b07,
	0x03ae2000,
	0x00401ac7,
	0x00400707,
	0x008006c7,
	0x010000e3,
	0x00405b07,
	0x03ae2000,
	0x00400ac7,
	0x02c004df,
	0x015ba43b,
	0x004010c7,
	0x05c2649f,
	0x00000000,
	0x004010c7,
	0x02c0411f,
	0x00808f07,
	0x02c0211f,
	0x00809107,
	0x02c0111f,
	0x00809307,
	0x02c0091f,
	0x00809507,
	0x02c0051f,
	0x00809707,
	0x02c0031f,
	0x00809907,
	0x004020c7,
	0x00400b07,
	0x02c00327,
	0x0160023c,
	0x00c00118,
	0x01dce63b,
	0x00c00107,
	0x00406a87,
	0x00c05b47,
	0x021d302a,
	0x0040a367,
	0x035d4000,
	0x03c00000,
	0x004080a7,
	0x01000095,
	0x00808167,
	0x00c00107,
	0x00d00147,
	0x021e402a,
	0x01200097,
	0x00c00150,
	0x019e003d,
	0x0400014d,
	0x00c00121,
	0x01ddd03d,
	0x04400161,
	0x01000095,
	0x0100008a,
	0x035e9000,
	0x00c00150,
	0x019e903d,
	0x0400014d,
	0x00c00121,
	0x01de603d,
	0x00c00150,
	0x01ded63b,
	0x05c2e4a7,
	0x035ee000,
	0x05c2fca7,
	0x00000000,
	0x054000a5,
	0x00000000,
	0x00406a87,
	0x00c05b47,
	0x019f602a,
	0x04c00000,
	0x03a2c000,
	0x00406487,
	0x015fb23a,
	0x05c00487,
	0x00000000,
	0x035fd000,
	0x05c00687,
	0x00000000,
	0x00c000d9,
	0x015cbc3b,
	0x02800000,
	0x04c00000,
	0x02400008,
	0x00408f5f,
	0x01a1703d,
	0x03c00000,
	0x01a0c23d,
	0x00dfff07,
	0x01610025,
	0x00c00687,
	0x054004ba,
	0x00000000,
	0x03614000,
	0x00c00487,
	0x054004ba,
	0x00000000,
	0x03614000,
	0x04800000,
	0x06000000,
	0x06000000,
	0x06000000,
	0x03a2c000,
	0x05c00687,
	0x00000000,
	0x00406547,
	0x0240000d,
	0x00c000d9,
	0x01600c3b,
	0x02800000,
	0x054020b8,
	0x00c18107,
	0x00000000,
	0x0100010c,
	0x01e1e03c,
	0x02800000,
	0x05800000,
	0x02800000,
	0x05000600,
	0x02800000,
	0x05000600,
	0x05c06487,
	0x00000000,
	0x05c06687,
	0x00000000,
	0x02800000,
	0x00406707,
	0x01a6e23c,
	0x04800200,
	0x04801000,
	0x04802000,
	0x04801200,
	0x04800400,
	0x04800600,
	0x04801400,
	0x04802200,
	0x04803000,
	0x04804000,
	0x04803200,
	0x04802400,
	0x04801600,
	0x04800800,
	0x04800a00,
	0x04801800,
	0x04802600,
	0x04803400,
	0x04804200,
	0x04805000,
	0x04806000,
	0x04805200,
	0x04804400,
	0x04803600,
	0x04802800,
	0x04801a00,
	0x04800c00,
	0x04800e00,
	0x04801c00,
	0x04802a00,
	0x04803800,
	0x04804600,
	0x04805400,
	0x04806200,
	0x04807000,
	0x04807200,
	0x04806400,
	0x04805600,
	0x04804800,
	0x04803a00,
	0x04802c00,
	0x04801e00,
	0x04802e00,
	0x04803c00,
	0x04804a00,
	0x04805800,
	0x04806600,
	0x04807400,
	0x04807600,
	0x04806800,
	0x04805a00,
	0x04804c00,
	0x04803e00,
	0x04804e00,
	0x04805c00,
	0x04806a00,
	0x04807800,
	0x04807a00,
	0x04806c00,
	0x04805e00,
	0x04806e00,
	0x04807c00,
	0x04807e00,
	0x036ad000,
	0x04801000,
	0x04802000,
	0x04803000,
	0x04800200,
	0x04801200,
	0x04800400,
	0x04801400,
	0x04802200,
	0x04803200,
	0x04804000,
	0x04805000,
	0x04806000,
	0x04807000,
	0x04807200,
	0x04806200,
	0x04805200,
	0x04804200,
	0x04803400,
	0x04802400,
	0x04800600,
	0x04801600,
	0x04800800,
	0x04801800,
	0x04802600,
	0x04803600,
	0x04804400,
	0x04805400,
	0x04806400,
	0x04807400,
	0x04804600,
	0x04805600,
	0x04806600,
	0x04807600,
	0x04802800,
	0x04803800,
	0x04800a00,
	0x04801a00,
	0x04800c00,
	0x04801c00,
	0x04802a00,
	0x04803a00,
	0x04804800,
	0x04805800,
	0x04806800,
	0x04807800,
	0x04804a00,
	0x04805a00,
	0x04806a00,
	0x04807a00,
	0x04802c00,
	0x04803c00,
	0x04800e00,
	0x04801e00,
	0x04802e00,
	0x04803e00,
	0x04804c00,
	0x04805c00,
	0x04806c00,
	0x04807c00,
	0x04804e00,
	0x04805e00,
	0x04806e00,
	0x04807e00,
	0x06000000,
	0x06000000,
	0x06000000,
	0x02800000,
	0x00402687,
	0x00407f07,
	0x01eb643c,
	0x00c030c7,
	0x036ba000,
	0x01eb963c,
	0x00c032c7,
	0x036ba000,
	0x00c03cc7,
	0x022d301a,
	0x00c00107,
	0x0100009a,
	0x00c00121,
	0x022c001a,
	0x036bc000,
	0x00802687,
	0x004028c7,
	0x00c000dc,
	0x00c07907,
	0x022cf023,
	0x010000e3,
	0x008028c7,
	0x00402a87,
	0x00c00091,
	0x022d1022,
	0x010000a2,
	0x00802a87,
	0x00402d47,
	0x00c00169,
	0x00802d47,
	0x008028c7,
	0x036d3000,
	0x00802a87,
	0x036d3000,
	0x00402c87,
	0x05400cba,
	0x00000000,
	0x00402a87,
	0x05400cba,
	0x00000000,
	0x00402887,
	0x00c080c7,
	0x0300009a,
	0x05400eba,
	0x00000000,
	0x00402687,
	0x05400cba,
	0x00000000,
	0x02800000,
	0x0100010c,
	0x00802f07,
	0x04400121,
	0x00803107,
	0x00c00b47,
	0x0440012c,
	0x0400014c,
	0x0100014d,
	0x00cffe87,
	0x01ef0013,
	0x01eee02b,
	0x036f0000,
	0x010000e3,
	0x036fc000,
	0x00e00147,
	0x0400008c,
	0x01000155,
	0x00d00087,
	0x01ef6013,
	0x036fc000,
	0x022f802b,
	0x036fc000,
	0x00c000e3,
	0x00e00087,
	0x022fc013,
	0x010000d3,
	0x00d00147,
	0x00c00098,
	0x0230102b,
	0x00e00147,
	0x0100009d,
	0x00403147,
	0x00c00115,
	0x0100010c,
	0x00402e87,
	0x04000154,
	0x05c314af,
	0x00000000,
	0x00d00087,
	0x01b1003d,
	0x0230e013,
	0x05400089,
	0x00000000,
	0x03710000,
	0x05400088,
	0x00000000,
	0x004030c7,
	0x010000cb,
	0x02c000e3,
	0x00402f07,
	0x01b1803c,
	0x01b1803d,
	0x054000a3,
	0x00000000,
	0x02800000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	};

#define SEGMENT5_DATA_TYPE	0
#define SEGMENT5_LENGTH	1536
static const unsigned long KFIR_MUX_MC[] =
	{
	0x00000000,
	0x0000a000,
	0x00009800,
	0x00019000,
	0x0001e800,
	0x0001f000,
	0x0000a009,
	0x00006800,
	0x0001a806,
	0x0001f800,
	0x00019000,
	0x0001e000,
	0x00006001,
	0x0000e247,
	0x0000a040,
	0x00006802,
	0x0001a818,
	0x00006000,
	0x0000e204,
	0x0000e205,
	0x0001215d,
	0x0001400e,
	0x00014820,
	0x00018011,
	0x0000600c,
	0x0000e1b9,
	0x0000a087,
	0x00016060,
	0x0001881f,
	0x00006001,
	0x0001c000,
	0x0000a087,
	0x00016060,
	0x00018829,
	0x0001212d,
	0x0001215d,
	0x0001213b,
	0x0001241b,
	0x00006800,
	0x0001b02f,
	0x0001803f,
	0x0001214c,
	0x0001215d,
	0x0001241b,
	0x00006800,
	0x0001b0bd,
	0x0001803f,
	0x0000a247,
	0x00016060,
	0x0001883f,
	0x0000a207,
	0x000121d5,
	0x0000a23a,
	0x0000aa3b,
	0x0000b23c,
	0x00002860,
	0x0000a01b,
	0x00002808,
	0x0000a228,
	0x0000aa29,
	0x0000b22a,
	0x00017020,
	0x000188bd,
	0x00012413,
	0x00006801,
	0x0001a0bd,
	0x0000a205,
	0x0001219e,
	0x0000a04f,
	0x0000a850,
	0x00002860,
	0x0000a23a,
	0x0000aa3b,
	0x0000b23c,
	0x00004008,
	0x0000e1b4,
	0x0000e9b5,
	0x0000f1b6,
	0x00006000,
	0x0000e1b7,
	0x000061ba,
	0x00014820,
	0x00006001,
	0x00014802,
	0x0000a1b4,
	0x0000a9b5,
	0x0000b1b6,
	0x0001217f,
	0x0000a1b7,
	0x00014809,
	0x00006001,
	0x00014801,
	0x0000a07a,
	0x0000a87b,
	0x00014816,
	0x0000607f,
	0x00014807,
	0x0000a1b8,
	0x00014803,
	0x000061bb,
	0x00014820,
	0x0000a1b9,
	0x00014810,
	0x00006001,
	0x00014801,
	0x0000a07c,
	0x0000a87d,
	0x00014816,
	0x0000a07e,
	0x0000a87f,
	0x00014819,
	0x0000a082,
	0x0000a883,
	0x00014818,
	0x0000a080,
	0x0000a881,
	0x00014818,
	0x0000a208,
	0x0000aa09,
	0x00002860,
	0x0000b853,
	0x00016008,
	0x0001887c,
	0x00002068,
	0x0000e20a,
	0x0000e1bb,
	0x0000a047,
	0x0000e1c0,
	0x00006003,
	0x0000e1ba,
	0x0000a234,
	0x0000aa35,
	0x0000b236,
	0x0000e1a7,
	0x0000e9a8,
	0x0000f1a9,
	0x0000a23a,
	0x0000aa3b,
	0x0000b23c,
	0x0000e1bd,
	0x0000e9be,
	0x0000f1bf,
	0x00012259,
	0x0000a208,
	0x0000aa09,
	0x00016860,
	0x000188b6,
	0x0000a20a,
	0x00016060,
	0x000188a2,
	0x0000a208,
	0x0000aa09,
	0x00002860,
	0x0000a053,
	0x00016008,
	0x0001889d,
	0x00002068,
	0x0000e20a,
	0x0000e1bb,
	0x00006000,
	0x0000e1ba,
	0x00012259,
	0x0000a20a,
	0x00003060,
	0x00003071,
	0x00003071,
	0x00012526,
	0x0001400e,
	0x00014820,
	0x00005058,
	0x00016070,
	0x000188a6,
	0x0000a20a,
	0x00002860,
	0x0000a208,
	0x0000aa09,
	0x00004008,
	0x0000e208,
	0x0000ea09,
	0x00006000,
	0x0000e20a,
	0x0001808f,
	0x0000a205,
	0x00002018,
	0x0000681f,
	0x00002026,
	0x0000e205,
	0x00006001,
	0x0000e24c,
	0x0001241b,
	0x00006800,
	0x0001a81f,
	0x0000a207,
	0x000121d5,
	0x0000a087,
	0x00016060,
	0x000188d0,
	0x0000a23a,
	0x0000aa3b,
	0x0000b23c,
	0x00002860,
	0x0000a01b,
	0x00002808,
	0x0000a228,
	0x0000aa29,
	0x0000b22a,
	0x00016020,
	0x0001881f,
	0x0000a22b,
	0x0000aa2c,
	0x00002860,
	0x0000a054,
	0x00016008,
	0x000188d7,
	0x00002068,
	0x0000e23d,
	0x0000e1bb,
	0x0000a048,
	0x0000e1c0,
	0x00006002,
	0x0000e1ba,
	0x0000a228,
	0x0000aa29,
	0x0000b22a,
	0x0000e1a7,
	0x0000e9a8,
	0x0000f1a9,
	0x00012259,
	0x0000a22b,
	0x0000aa2c,
	0x00016860,
	0x00018919,
	0x000068ff,
	0x0000286d,
	0x000070ff,
	0x00002830,
	0x00017008,
	0x00018919,
	0x0000a23d,
	0x00016060,
	0x000188fd,
	0x0000a22b,
	0x0000aa2c,
	0x00002860,
	0x0000a054,
	0x00016008,
	0x000188f8,
	0x00002068,
	0x0000e23d,
	0x0000e1bb,
	0x00006000,
	0x0000e1ba,
	0x00012259,
	0x0000a23d,
	0x00003060,
	0x00003071,
	0x00003071,
	0x0000a248,
	0x00002860,
	0x00008800,
	0x00014820,
	0x00012526,
	0x00005058,
	0x00016070,
	0x00018903,
	0x00002068,
	0x00006bff,
	0x0000200e,
	0x0000e248,
	0x0000a23d,
	0x0001247b,
	0x0000a23d,
	0x00002860,
	0x0000a22b,
	0x0000aa2c,
	0x00004008,
	0x0000e22b,
	0x0000ea2c,
	0x00006000,
	0x0000e23d,
	0x000180e4,
	0x0000a207,
	0x00002018,
	0x00006807,
	0x00002026,
	0x0000e207,
	0x0000a277,
	0x0000aa78,
	0x0000b279,
	0x00002860,
	0x0000a004,
	0x00002020,
	0x0000e277,
	0x0000ea78,
	0x0000f279,
	0x0000a087,
	0x00016060,
	0x0001881f,
	0x00006001,
	0x0001c000,
	0x0001801f,
	0x00006000,
	0x0000e24c,
	0x00012413,
	0x00006800,
	0x0001b13a,
	0x0000a009,
	0x00006801,
	0x0001a93a,
	0x00006820,
	0x00004838,
	0x00016868,
	0x0001892d,
	0x00018136,
	0x00013000,
	0x0001241b,
	0x00006800,
	0x0001b14b,
	0x00012413,
	0x00002860,
	0x0000a084,
	0x00017020,
	0x0001894b,
	0x0000a009,
	0x00006801,
	0x0001a94b,
	0x00006820,
	0x00004838,
	0x00016868,
	0x0001893b,
	0x00018147,
	0x00013000,
	0x00006000,
	0x0000e24c,
	0x00012413,
	0x00006800,
	0x0001b15c,
	0x0001241b,
	0x00006800,
	0x0001b15c,
	0x0000a009,
	0x00006801,
	0x0001a95c,
	0x00006820,
	0x00004838,
	0x00016868,
	0x0001894c,
	0x00018158,
	0x00013000,
	0x00012413,
	0x00006800,
	0x0001b17e,
	0x0000a009,
	0x00006800,
	0x0001a97e,
	0x0001400e,
	0x0000a040,
	0x00006800,
	0x0001b968,
	0x00014820,
	0x0000a00a,
	0x00006800,
	0x0001a963,
	0x0000a040,
	0x00006802,
	0x0001b970,
	0x000061b9,
	0x00014820,
	0x00009000,
	0x0000e00c,
	0x0000e80d,
	0x0000f00e,
	0x0001400e,
	0x0001400e,
	0x00007100,
	0x00006000,
	0x00014820,
	0x00005058,
	0x00016070,
	0x00018978,
	0x0001f800,
	0x00019000,
	0x00013000,
	0x0000e1a4,
	0x0000e9a5,
	0x0000f1a6,
	0x0000a1a5,
	0x0000a9a6,
	0x00002063,
	0x00002062,
	0x00002062,
	0x00014803,
	0x00006001,
	0x00014801,
	0x0000687f,
	0x0000286d,
	0x000070ff,
	0x00003048,
	0x0000a1a4,
	0x0000a9a5,
	0x00002063,
	0x00002062,
	0x00002062,
	0x00002061,
	0x00002016,
	0x0001480f,
	0x00006001,
	0x00014801,
	0x0000a1a4,
	0x00002016,
	0x0001480f,
	0x00006001,
	0x00014801,
	0x00013000,
	0x00002000,
	0x00002000,
	0x00002000,
	0x00006a84,
	0x00003008,
	0x0000c000,
	0x00003058,
	0x0000e1aa,
	0x0000c000,
	0x00003058,
	0x0000c800,
	0x00003058,
	0x00002000,
	0x00002000,
	0x0000e208,
	0x0000ea09,
	0x0000c000,
	0x00003058,
	0x0000c800,
	0x00003058,
	0x0000e26d,
	0x0000ea6e,
	0x0000a208,
	0x0000aa09,
	0x00002860,
	0x0000a247,
	0x00016860,
	0x000189c2,
	0x0000a00b,
	0x00002000,
	0x00002000,
	0x00002008,
	0x0000e208,
	0x0000ea09,
	0x00006000,
	0x0000e247,
	0x00012423,
	0x0000a04f,
	0x0000a850,
	0x00002860,
	0x0000a234,
	0x0000aa35,
	0x0000b236,
	0x00002008,
	0x0000e234,
	0x0000ea35,
	0x0000f236,
	0x0000a23a,
	0x0000aa3b,
	0x0000b23c,
	0x00002008,
	0x0000e23a,
	0x0000ea3b,
	0x0000f23c,
	0x00013000,
	0x00002000,
	0x00002000,
	0x00002000,
	0x00006b84,
	0x00003008,
	0x0000c000,
	0x00003058,
	0x0000e22b,
	0x0000ea2c,
	0x0000c000,
	0x00003058,
	0x0000c800,
	0x00003058,
	0x0000d000,
	0x00003058,
	0x00002860,
	0x0000a04f,
	0x0000a850,
	0x00002008,
	0x0000e228,
	0x0000ea29,
	0x0000f22a,
	0x00013000,
	0x0000e1a1,
	0x00006801,
	0x00002061,
	0x0000e19e,
	0x0000c000,
	0x00014810,
	0x00003048,
	0x0000a19e,
	0x00004008,
	0x0001a1f8,
	0x0000e19e,
	0x000181f0,
	0x0000a1a1,
	0x0000200e,
	0x0001a1ff,
	0x0000c000,
	0x00003058,
	0x00002063,
	0x00014808,
	0x00013000,
	0x00006108,
	0x0000e26f,
	0x0000a26f,
	0x00003060,
	0x0000c000,
	0x00003058,
	0x0000e270,
	0x0000c000,
	0x00003058,
	0x0000e271,
	0x0000c000,
	0x00003058,
	0x0000e272,
	0x00016860,
	0x00018a32,
	0x00002070,
	0x0000e26f,
	0x000060bc,
	0x0000e273,
	0x0000e233,
	0x00006001,
	0x0000e203,
	0x0000a271,
	0x0000e1c9,
	0x0000a270,
	0x0000e1cb,
	0x0001229b,
	0x00002860,
	0x0000a273,
	0x00004008,
	0x00004018,
	0x0000e273,
	0x00006000,
	0x00014808,
	0x0000a26f,
	0x00003060,
	0x0000a272,
	0x000121ec,
	0x00002070,
	0x0000e26f,
	0x0000a272,
	0x00002860,
	0x0000a273,
	0x00005008,
	0x000060ff,
	0x00014808,
	0x00005058,
	0x00016070,
	0x00018a2d,
	0x00018202,
	0x00013000,
	0x00007000,
	0x0000a1ba,
	0x00006802,
	0x00002026,
	0x0001a240,
	0x00006005,
	0x00003010,
	0x0000a1ba,
	0x00006801,
	0x00002026,
	0x0001a240,
	0x00006005,
	0x00003010,
	0x00002070,
	0x0000e1bc,
	0x0000a1bb,
	0x00006803,
	0x00002008,
	0x00003040,
	0x00002070,
	0x0000e1bb,
	0x00006006,
	0x00002010,
	0x00006803,
	0x0000200e,
	0x00006801,
	0x0001a256,
	0x00006804,
	0x00005020,
	0x0000a1bc,
	0x00002010,
	0x0000e1bc,
	0x0000a1bb,
	0x00002010,
	0x0000e1bb,
	0x00006806,
	0x00002008,
	0x00013000,
	0x00006000,
	0x00015000,
	0x00012233,
	0x00006001,
	0x00014818,
	0x0000a1c0,
	0x00014808,
	0x0000a1bb,
	0x00014810,
	0x0000a065,
	0x00014808,
	0x0000a1ba,
	0x00014802,
	0x00006000,
	0x00014801,
	0x00006000,
	0x00014801,
	0x0000a066,
	0x00014804,
	0x0000a1bc,
	0x00014808,
	0x0000a1bb,
	0x00006803,
	0x00004808,
	0x0000a1bc,
	0x00003060,
	0x00004020,
	0x0000e1bb,
	0x0000a1ba,
	0x00006802,
	0x00002026,
	0x0001a290,
	0x00006005,
	0x00004040,
	0x0000e1bc,
	0x0000a1ba,
	0x00014804,
	0x0000a1a7,
	0x0000a9a8,
	0x0000b1a9,
	0x0001217f,
	0x0000a1ba,
	0x00006801,
	0x00002026,
	0x0001a290,
	0x0000a1bc,
	0x00007005,
	0x00004010,
	0x0000e1bc,
	0x00006001,
	0x00014804,
	0x0000a1bd,
	0x0000a9be,
	0x0000b1bf,
	0x0001217f,
	0x0000b9bc,
	0x00003060,
	0x000060ff,
	0x00016870,
	0x00018a98,
	0x00014808,
	0x00005058,
	0x00018293,
	0x00015800,
	0x00002062,
	0x00013000,
	0x00006000,
	0x0000e1c6,
	0x0000e1c8,
	0x00006001,
	0x0000e1c7,
	0x00009000,
	0x00003060,
	0x0000a1ae,
	0x0000a9af,
	0x0000b1b0,
	0x00002860,
	0x00002070,
	0x0000e1ae,
	0x0000e9af,
	0x0000f1b0,
	0x00005048,
	0x00003075,
	0x00003075,
	0x00003050,
	0x00003050,
	0x0000a1b1,
	0x0000a9b2,
	0x0000b1b3,
	0x00002010,
	0x0000e1b1,
	0x0000e9b2,
	0x0000f1b3,
	0x0000a045,
	0x00002860,
	0x0000a1c9,
	0x00017808,
	0x00018acd,
	0x0000a212,
	0x00006801,
	0x0001a2bf,
	0x000182c8,
	0x0000a013,
	0x0000a814,
	0x0000b015,
	0x00002860,
	0x0000a1b1,
	0x0000a9b2,
	0x0000b1b3,
	0x00016008,
	0x00018acd,
	0x00006001,
	0x0000e1c6,
	0x00006000,
	0x0000e212,
	0x00012354,
	0x000060b8,
	0x0000e1c1,
	0x00006001,
	0x0000e1c5,
	0x0000a1c6,
	0x00006801,
	0x0001a2da,
	0x000060b2,
	0x0000e1c1,
	0x00006007,
	0x0000e1c5,
	0x00006003,
	0x0000e1c7,
	0x0000a233,
	0x00002860,
	0x0000a1c1,
	0x00016020,
	0x00018ae0,
	0x000182e2,
	0x00006003,
	0x0000e1c7,
	0x0000a1c7,
	0x00006803,
	0x0001b2f9,
	0x00006802,
	0x0001a2f9,
	0x0000a1c1,
	0x00004008,
	0x0000e1c1,
	0x00002860,
	0x0000a233,
	0x00017020,
	0x00018aef,
	0x000182f1,
	0x00004020,
	0x0000e1c8,
	0x0000a1c8,
	0x00004020,
	0x0000e1c1,
	0x0000a1c5,
	0x00002860,
	0x0000a1c8,
	0x00002008,
	0x0000e1c5,
	0x00006047,
	0x00014808,
	0x0000a070,
	0x00014801,
	0x0000a203,
	0x00014801,
	0x0000a071,
	0x00014801,
	0x0000a1c9,
	0x0001480d,
	0x0000a06f,
	0x00014802,
	0x0000a1c7,
	0x00014802,
	0x000061cc,
	0x00003060,
	0x0000b9cb,
	0x00003040,
	0x0000c000,
	0x00014804,
	0x00002018,
	0x0000680f,
	0x0000200e,
	0x00010000,
	0x0000a1c7,
	0x00006803,
	0x0001b33d,
	0x00006802,
	0x0001a33d,
	0x0000a1c5,
	0x00014808,
	0x0000a067,
	0x00014803,
	0x0000a1c6,
	0x00014801,
	0x0000a068,
	0x00014804,
	0x00006001,
	0x0000e1fc,
	0x0000a1c6,
	0x00006801,
	0x0001a332,
	0x0000a1ff,
	0x00014801,
	0x0000a1fd,
	0x0000a9fe,
	0x00014820,
	0x0000e201,
	0x0000ea02,
	0x0000603f,
	0x00014806,
	0x0000a200,
	0x00014809,
	0x0000a1fc,
	0x00006806,
	0x00002008,
	0x0000e1fc,
	0x0000a1fc,
	0x00002860,
	0x0000a1c5,
	0x0001a33d,
	0x00005008,
	0x000060ff,
	0x00016870,
	0x00018b3d,
	0x00014808,
	0x00005058,
	0x00018338,
	0x0000a1c1,
	0x000068bc,
	0x00004020,
	0x00013000,
	0x000060bc,
	0x0000e233,
	0x00006000,
	0x0000e203,
	0x0000a1ca,
	0x0000e1c9,
	0x0000602d,
	0x0000e1cb,
	0x0001229b,
	0x000068bc,
	0x00005020,
	0x000060ff,
	0x000060ff,
	0x00014808,
	0x00012526,
	0x00005058,
	0x00016070,
	0x00018b4d,
	0x00013000,
	0x0000a013,
	0x0000a814,
	0x0000b015,
	0x00002860,
	0x0000a1b1,
	0x0000a9b2,
	0x0000b1b3,
	0x00005008,
	0x00016008,
	0x00018b7b,
	0x0000b9ab,
	0x00002018,
	0x0000e1ab,
	0x0000a213,
	0x0000aa14,
	0x0000b215,
	0x00002860,
	0x0000a016,
	0x0000a817,
	0x0000b018,
	0x00002008,
	0x0000e213,
	0x0000ea14,
	0x0000f215,
	0x0000a216,
	0x0000aa17,
	0x0000b218,
	0x00002860,
	0x0000a019,
	0x0000a81a,
	0x00002008,
	0x0000e216,
	0x0000ea17,
	0x0000f218,
	0x00002070,
	0x0000e1b1,
	0x0000e9b2,
	0x0000f1b3,
	0x00018354,
	0x0000a1b1,
	0x0000a9b2,
	0x0000b1b3,
	0x00002860,
	0x0000a074,
	0x0001243f,
	0x00002063,
	0x00002062,
	0x0000e249,
	0x0000ea4a,
	0x0000f24b,
	0x0000a1b1,
	0x0000a9b2,
	0x0000b1b3,
	0x00002860,
	0x0000a075,
	0x0001243f,
	0x00002860,
	0x0000a249,
	0x0000aa4a,
	0x0000b24b,
	0x00002008,
	0x00002063,
	0x00002063,
	0x00002061,
	0x0000e219,
	0x0000ea1a,
	0x0000f21b,
	0x0000a1b1,
	0x0000a9b2,
	0x0000b1b3,
	0x00002860,
	0x0000a076,
	0x0001243f,
	0x00002063,
	0x00002062,
	0x0000e249,
	0x0000ea4a,
	0x0000f24b,
	0x0000a1b1,
	0x0000a9b2,
	0x0000b1b3,
	0x00002860,
	0x0000a077,
	0x0001243f,
	0x00002860,
	0x0000a249,
	0x0000aa4a,
	0x0000b24b,
	0x00002008,
	0x00002063,
	0x00002063,
	0x00002061,
	0x0000e21c,
	0x0000ea1d,
	0x0000f21e,
	0x0000a012,
	0x00002860,
	0x0000a1ab,
	0x00016008,
	0x00018bd5,
	0x00004008,
	0x0000e1ab,
	0x0000a21f,
	0x0000aa20,
	0x0000b221,
	0x00002860,
	0x0000a05f,
	0x0000a860,
	0x00002008,
	0x0000e21f,
	0x0000ea20,
	0x0000f221,
	0x0000a222,
	0x0000aa23,
	0x0000b224,
	0x00002860,
	0x0000a063,
	0x0000a864,
	0x00002008,
	0x0000e222,
	0x0000ea23,
	0x0000f224,
	0x00006000,
	0x0000e213,
	0x0000ea14,
	0x0000f215,
	0x0000e216,
	0x0000ea17,
	0x0000f218,
	0x0000a213,
	0x0000aa14,
	0x0000b215,
	0x00002063,
	0x00002063,
	0x00002860,
	0x0000a219,
	0x0000aa1a,
	0x0000b21b,
	0x00002808,
	0x0000a21f,
	0x0000aa20,
	0x0000b221,
	0x00002008,
	0x0000e225,
	0x0000ea26,
	0x0000f227,
	0x0000a216,
	0x0000aa17,
	0x0000b218,
	0x00002063,
	0x00002063,
	0x00002860,
	0x0000a21c,
	0x0000aa1d,
	0x0000b21e,
	0x00002808,
	0x0000a222,
	0x0000aa23,
	0x0000b224,
	0x00002008,
	0x0000e1fd,
	0x0000e9fe,
	0x0000f1ff,
	0x0000692c,
	0x0001243f,
	0x00002860,
	0x0000a225,
	0x0000aa26,
	0x0000b227,
	0x00004008,
	0x0000692c,
	0x00016008,
	0x00018c0b,
	0x00005008,
	0x0000a1fd,
	0x0000a9fe,
	0x0000b1ff,
	0x00002018,
	0x0000e1fd,
	0x0000e9fe,
	0x0000f1ff,
	0x00002070,
	0x000183fe,
	0x00006800,
	0x00016008,
	0x00018c10,
	0x0000e200,
	0x00013000,
	0x00006000,
	0x0000e200,
	0x00013000,
	0x0000a204,
	0x00006820,
	0x00003008,
	0x0000a205,
	0x00004040,
	0x0000681f,
	0x0000200e,
	0x00013000,
	0x0000a206,
	0x00006808,
	0x00003008,
	0x0000a207,
	0x00004040,
	0x00006807,
	0x0000200e,
	0x00013000,
	0x0000a01b,
	0x00002860,
	0x0000a26d,
	0x0000aa6e,
	0x0001243f,
	0x00002061,
	0x0000e234,
	0x0000ea35,
	0x0000f236,
	0x00003060,
	0x0000a1aa,
	0x00006803,
	0x0001a432,
	0x00002070,
	0x0001843b,
	0x0000a237,
	0x0000aa38,
	0x0000b239,
	0x00002860,
	0x00002070,
	0x0000e237,
	0x0000ea38,
	0x0000f239,
	0x00002068,
	0x0000e23a,
	0x0000ea3b,
	0x0000f23c,
	0x00013000,
	0x0000e19e,
	0x0000e99f,
	0x0000f1a0,
	0x00006024,
	0x0000e1a1,
	0x00007000,
	0x00002869,
	0x0000a19e,
	0x0000a99f,
	0x0000b1a0,
	0x00018c4b,
	0x0001844c,
	0x00003040,
	0x00002000,
	0x0000e19e,
	0x0000e99f,
	0x0000f1a0,
	0x0000a1a1,
	0x00004018,
	0x0000e1a1,
	0x00016060,
	0x00018c45,
	0x00002070,
	0x00013000,
	0x00007040,
	0x00006800,
	0x00008800,
	0x00010000,
	0x00003058,
	0x0000615e,
	0x00017008,
	0x00018c59,
	0x00006000,
	0x0000e01d,
	0x0000e254,
	0x00012466,
	0x00006000,
	0x00009800,
	0x00019000,
	0x0000a254,
	0x00016860,
	0x00018c6e,
	0x000060aa,
	0x0000e1a4,
	0x0000688d,
	0x0000709f,
	0x00018472,
	0x00006095,
	0x0000e1a4,
	0x00006878,
	0x0000708a,
	0x0000c000,
	0x00005048,
	0x00010000,
	0x00003058,
	0x00003048,
	0x0000a1a4,
	0x00017010,
	0x00018c72,
	0x00013000,
	0x00002860,
	0x00006003,
	0x0000300e,
	0x00016870,
	0x00018c92,
	0x00008800,
	0x00006801,
	0x00016830,
	0x00018c8a,
	0x00006802,
	0x00016830,
	0x00018c8f,
	0x00002063,
	0x00014818,
	0x00018492,
	0x00002063,
	0x00002063,
	0x00002063,
	0x00014808,
	0x00018492,
	0x00002063,
	0x00002063,
	0x00014810,
	0x00013000,
	0x0000e23e,
	0x0000ea3f,
	0x0000f240,
	0x00002068,
	0x0000e241,
	0x0000ea42,
	0x0000f243,
	0x00002070,
	0x0000e244,
	0x0000ea45,
	0x0000f246,
	0x0000a000,
	0x00006801,
	0x0001a4ef,
	0x0000a004,
	0x0000e280,
	0x0000a001,
	0x0000a802,
	0x0000b003,
	0x0000e281,
	0x0000ea82,
	0x0000f283,
	0x0000a087,
	0x00016860,
	0x00018cd3,
	0x0000a274,
	0x0000aa75,
	0x0000b276,
	0x00002860,
	0x0000a004,
	0x00002008,
	0x0000e274,
	0x0000ea75,
	0x0000f276,
	0x0000a274,
	0x0000aa75,
	0x0000b276,
	0x00002860,
	0x0000a27a,
	0x0000aa7b,
	0x0000b27c,
	0x00003060,
	0x00004820,
	0x0000a088,
	0x00016020,
	0x00018ced,
	0x00002040,
	0x0000e27a,
	0x0000ea7b,
	0x0000f27c,
	0x0000a088,
	0x0000e280,
	0x0000a27d,
	0x0000aa7e,
	0x0000b27f,
	0x00002860,
	0x0000a089,
	0x00002008,
	0x0000e27d,
	0x0000ea7e,
	0x0000f27f,
	0x0000e281,
	0x0000ea82,
	0x0000f283,
	0x0000a206,
	0x00002000,
	0x00002000,
	0x00002000,
	0x00006b84,
	0x00003008,
	0x0000a280,
	0x00010000,
	0x00003058,
	0x0000a281,
	0x0000aa82,
	0x0000b283,
	0x00010000,
	0x00003058,
	0x00010800,
	0x00003058,
	0x00011000,
	0x00003058,
	0x0000a206,
	0x00002018,
	0x00006807,
	0x0000200e,
	0x0000e206,
	0x0000a087,
	0x00016060,
	0x00018cb5,
	0x0001c800,
	0x0001851a,
	0x0000a204,
	0x00002000,
	0x00002000,
	0x00002000,
	0x00006a84,
	0x00003008,
	0x0000a005,
	0x00010000,
	0x00003058,
	0x0000a006,
	0x0000a807,
	0x00010000,
	0x00003058,
	0x00010800,
	0x00003058,
	0x0000a01e,
	0x0000a81f,
	0x00010000,
	0x00003058,
	0x00010800,
	0x00003058,
	0x0000a204,
	0x00002018,
	0x0000681f,
	0x0000200e,
	0x0000e204,
	0x0000a010,
	0x00002860,
	0x0000a250,
	0x00016808,
	0x00018d1a,
	0x00002018,
	0x0000e250,
	0x0000a251,
	0x0000aa52,
	0x0000b253,
	0x00003060,
	0x00006001,
	0x00002040,
	0x0000e251,
	0x0000ea52,
	0x0000f253,
	0x00018509,
	0x0000a244,
	0x0000aa45,
	0x0000b246,
	0x00003060,
	0x0000a241,
	0x0000aa42,
	0x0000b243,
	0x00002860,
	0x0000a23e,
	0x0000aa3f,
	0x0000b240,
	0x00013800,
	0x00006007,
	0x00004018,
	0x00016860,
	0x00018d2b,
	0x00018527,
	0x00013000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	0x00019000,
	};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpegdec\specific\CS4920.H ===
// FILE:      library\hardware\mpegdec\specific\cs4920.h
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   10.04.95
//
// PURPOSE:   Implementation of ZR36100 abstract audio decoder class.
//
// HISTORY:

#ifndef CS4920_H
#define CS4920_H

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"
#include "library\common\krnlstr.h"
#include "library\lowlevel\hardwrio.h"
#include "zr36100.h"

#define	GNR_NO_CRYSTAL_MCODE				MKERR(ERROR, MPEG, FILEIO, 0x10)
	// The microcode for the audio DSP could not be found

#define	GNR_CRYSTAL_DOWNLOAD_FAILED   MKERR(ERROR, MPEG, NOACK,  0x11)
	// The microcode download failed.
	
#define I2C_CS4920	0xCC
	// I2C address for the currently used microcode.

class CS4920 : public MPEGAudioDecoder {
	private:
		ByteInOutPort		*	i2c;
		BitOutputPort		*	reset;
		BitOutputPort		*	boot; 
		BitInputPort		*	request;
		
		WORD						leftVolume;
		WORD						rightVolume;
		
	public:
		CS4920(ByteInOutPort * i2c,			// I2C bus for comunication
		       BitOutputPort * reset,			// __HIGH__ active reset line
		       BitOutputPort * boot,			// __HIGH__ active boot line
		       BitInputPort	* request);		// __HIGH__ active request line

			//
			// Check, if a microcode is already present
			//
		BOOL CheckMicrocode(void);		       		
		Error SendCommand(BYTE command, WORD level);		
		
			//
			// Load a new microcode into the chip
			//
		Error LoadMicrocode(KernelString name);
	
			//
			// Mute/Unmute the audio outputs
			//		
      Error MuteAudio(BOOL mute);      
      
      	//
      	// Set the channel volumes [0..10000]
      	//
      Error SetLeftVolume(WORD volume);
      Error SetRightVolume(WORD volume);		
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpegdec\generic\MPEGDEC.H ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


// FILE:      library\hardware\mpegdec\generic\mpegdec.h
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   10.04.95
//
// PURPOSE:
//
// HISTORY:

#ifndef MPEGDEC_H
#define MPEGDEC_H

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"
#include "library\common\tags.h"
#include "library\common\hooks.h"
#include "library\common\tagunits.h"
#include "library\hardware\video\generic\vidtypes.h"
#include "library\hardware\mpgcodec\generic\mpgcodec.h"

#ifndef ONLY_EXTERNAL_VISIBLE
#include "library\common\virtunit.h"
#endif

//
// Commands and parameters:
//
//		none                  : do nothing
//    start                 : start the operation
//    play([1..1000] speed) : play at specific speed (1000 = normal)
//    seek                  : stop playback, go standby
//    stop                  : stop playback
//    step(int frames)      : step some frames
//    freeze                : freeze current frame
//    resync                : resync after seek
//    end                   : end the operation
//
// State transition diagram
//
//	INITIAL:		reset
//
//	SRCSTATE		COMMAND/EVENT		DSTSTATE		ACTION
//
//	reset			start					initial		Init MPEG Decoder, start transfering data
// 				default				reset
//
//	initial		play					playing		Start playing the MPEG Stream
//					...					frozen		Freeze after first I-Frame
//
//	frozen		play					playing		Continue playing from current location
//					seek					seeking		Complete operation, and stop playback
//       		step					stepping		Go to step mode
//					end					reset
//					stop					stopped
//					default				frozen
//
//	playing		play					leaping		Adjust playback speed if required
//											playing
//					seek					seeking		Complete operation and stop playback
//					end					reset
//					stop					stopped
//					default				playing
//
// leaping     default           playing
//
//	stepping		play					playing
//					seek					seeking
//					end					reset
//					stop					stopped
//					default				stepping
//											frozen
//
//	seeking		resync				resyncing
//					resyncue				cued
//					end					reset
//
//	resyncing	play					playing
//					...					frozen
//
//	stopped		play					initial
//					end					reset
//					default				stopped
//

struct MPEGStreamMsg {
	DWORD		size;
	};

struct MPEGSignalMsg {
	DWORD		position;
	};

struct MPEGIdleMsg {
	};

struct MPEGErrorMsg {
	Error		error;
	};

MKHOOK(MPEGStream, MPEGStreamMsg)
MKHOOK(MPEGSignal, MPEGSignalMsg)
MKHOOK(MPEGIdle,   MPEGIdleMsg)
MKHOOK(MPEGError,  MPEGErrorMsg)

typedef MPEGStreamHook	__far *	MPEGStreamHookPtr;
typedef MPEGSignalHook	__far *	MPEGSignalHookPtr;
typedef MPEGIdleHook		__far *	MPEGIdleHookPtr;
typedef MPEGErrorHook	__far	*	MPEGErrorHookPtr;

enum MPEGStreamType {audioOnly, videoOnly, multiplexed};

enum MPEGStreamMode {singleStream, dualStream};

enum MPEGAudioLayer
	{
	MPAUDLAYER_1,
	MPAUDLAYER_2,
	MPAUDLAYER_3							// = MP3
	};

enum MPEGStereoMode
	{
	MPSS_NORMAL,							// Select output of first (normal) stereo program
	MPSS_DEFAULT = MPSS_NORMAL,
	MPSS_SECOND_STEREO					// Select output of second stereo program
	};

MKTAG(MPEG_AUDIO_BITRATE,					MPEG_DECODER_UNIT,	0x0001, DWORD)
MKTAG(MPEG_AUDIO_STREAMID,					MPEG_DECODER_UNIT,	0x0002, BYTE)
MKTAG(MPEG_VIDEO_STREAMID,					MPEG_DECODER_UNIT,	0x0003, BYTE)
MKTAG(MPEG_VIDEO_WIDTH,						MPEG_DECODER_UNIT,	0x0004, WORD)
MKTAG(MPEG_VIDEO_HEIGHT,   				MPEG_DECODER_UNIT,   0x0005, WORD)
MKTAG(MPEG_VIDEO_FPS,      				MPEG_DECODER_UNIT,   0x0006, WORD)
MKTAG(MPEG_STREAM_TYPE,						MPEG_DECODER_UNIT,	0x0007, MPEGStreamType)
MKTAG(MPEG_STREAM_HOOK,						MPEG_DECODER_UNIT,	0x0008, MPEGStreamHookPtr)
MKTAG(MPEG_LEFT_VOLUME,    				MPEG_DECODER_UNIT,   0x0009, WORD)
MKTAG(MPEG_RIGHT_VOLUME,   				MPEG_DECODER_UNIT,   0x000A, WORD)
MKTAG(MPEG_AUDIO_MUTE,     				MPEG_DECODER_UNIT,   0x000B, BOOL)
MKTAG(MPEG_SIGNAL_HOOK,						MPEG_DECODER_UNIT,	0x000C, MPEGSignalHookPtr)
MKTAG(MPEG_SIGNAL_POSITION,				MPEG_DECODER_UNIT,	0x000D, DWORD)
MKTAG(MPEG_DONE_HOOK,						MPEG_DECODER_UNIT,	0x000E, MPEGSignalHookPtr)
MKTAG(MPEG_VIDEO_BITRATE,					MPEG_DECODER_UNIT,   0x000F, DWORD)
MKTAG(MPEG_STREAM_BITRATE,					MPEG_DECODER_UNIT,   0x0010, DWORD)
MKTAG(MPEG_INTRA_QUANTIZER_MATRIX,		MPEG_DECODER_UNIT,	0x0011, BYTE __far *)
MKTAG(MPEG_NON_INTRA_QUANTIZER_MATRIX,	MPEG_DECODER_UNIT,	0x0012, BYTE __far *)
MKTAG(MPEG_VIDEOSTANDARD,					MPEG_DECODER_UNIT,	0x0013, VideoStandard)
#if TEST_PAL_TO_NTSC
MKTAG(MPEG_APP_VIDEOSTANDARD,				MPEG_DECODER_UNIT,	0x0014, VideoStandard)
MKTAG(MPEG_MOVING_IMG_STD,					MPEG_DECODER_UNIT,	0x0015, MovingImageStandard)
#endif
MKTAG(MPEG_STREAM_MODE,						MPEG_DECODER_UNIT,	0x0016, MPEGStreamMode)

MKTAG(MPEG_DISPLAY_WIDTH,					MPEG_DECODER_UNIT,	0x0020, WORD)
MKTAG(MPEG_DISPLAY_HEIGHT,					MPEG_DECODER_UNIT,	0x0021, WORD)

MKTAG(MPEG_VIDEO_BRIGHTNESS,				MPEG_DECODER_UNIT,	0x0022, WORD)
MKTAG(MPEG_VIDEO_CONTRAST,					MPEG_DECODER_UNIT,	0x0023, WORD)

MKTAG(MPEG_AUDIO_SAMPLERATE,				MPEG_DECODER_UNIT,	0x0024, WORD)
MKTAG(MPEG_IDLE_HOOK,						MPEG_DECODER_UNIT,	0x0025, MPEGIdleHookPtr)

MKTAG(MPEG_ASPECT_RATIO,					MPEG_DECODER_UNIT,	0x0026, WORD)
MKTAG(MPEG_SUPPORTS_HIRES_STILL,			MPEG_DECODER_UNIT,	0x0027, BOOL)

MKTAG(MPEG_CURRENT_STREAM_SEGMENT,		MPEG_DECODER_UNIT,	0x0028, DWORD)
MKTAG(MPEG_FIRST_STREAM_SEGMENT,			MPEG_DECODER_UNIT,	0x0029, DWORD)
MKTAG(MPEG_LAST_STREAM_SEGMENT,			MPEG_DECODER_UNIT,	0x002a, DWORD)

MKTAG(MPEG_DISPLAY_MODE,					MPEG_DECODER_UNIT,   0x0030, VideoMode)

// Determines the audio layer contained in the MPEG data/to be decoded
MKTAG(MPEG_AUDIO_LAYER,						MPEG_DECODER_UNIT,	0x0031, MPEGAudioLayer)

// CRC check enable/disable for MPEG (e.g. MP3) decoding (default: FALSE (off))
MKTAG(MPEG_CRC_CHECK,						MPEG_DECODER_UNIT,	0x0032, BOOL)

// Controls second stereo mode for MPEG audio material
MKTAG(MPEG_AUDIO_STEREO_MODE,				MPEG_DECODER_UNIT,	0x0033, MPEGStereoMode)

// Controls Deemphasis on DAC output
MKTAG(MPEG_AUDIO_DEEMPHASIS,				MPEG_DECODER_UNIT,	0x0034, BOOL)

MKTAG(MPEG_ERROR_HOOK,						MPEG_DECODER_UNIT,	0x0035, MPEGErrorHookPtr)


#ifndef ONLY_EXTERNAL_VISIBLE

#define MPEG_BUFF_SIZE	0x40000
#define MPEG_BUFF_ADD	0x01000

class MPEGParams {
	public:
		DWORD					audioBitRate;
		DWORD					videoBitRate;
		DWORD					streamBitRate;
		BYTE					audioStreamID;
		BYTE					videoStreamID;
		WORD					videoWidth;
		WORD					videoHeight;
		WORD					videoFPS;
		MPEGStreamType  	streamType;
		BYTE					intraQuantizerMatrix[64];
		BYTE					nonIntraQuantizerMatrix[64];
		VideoStandard		videoStandard;
		MPEGParams(void);
	};

class MPEGDecoder : public PhysicalUnit {
	friend class VirtualMPEGDecoder;
	protected:
		Error StreamHook(DWORD size);
		Error SignalHook(DWORD position);
		Error DoneHook(void);

		virtual DWORD RecoverData(HPTR data, DWORD size) = 0;
	public:
		virtual Error SendCommand(MPEGCommand com, DWORD param, DWORD __far &tag) = 0;
		Error DoCommand(MPEGCommand com, DWORD param);
		virtual Error CompleteCommand(DWORD tag) = 0;
		virtual DWORD SendData(HPTR data, DWORD size) = 0;
		virtual void CompleteData(void) = 0;
		virtual DWORD CurrentLocation(void) = 0;
		virtual MPEGState CurrentState(void) = 0;

		virtual Error SetSignal(DWORD position) = 0;

		virtual Error SetLeftVolume(WORD volume) = 0;
		virtual Error SetRightVolume(WORD volume) = 0;
		virtual Error MuteAudio(BOOL mute) = 0;

		virtual Error SetVideoStreamID(BYTE id) = 0;
		virtual Error SetAudioStreamID(BYTE id) = 0;
	};

class VirtualMPEGDecoder : public VirtualUnit {
	friend class MPEGDecoder;
	protected:
		HPTR					buffer;
		DWORD					buffPos;
		DWORD					buffStart;
		DWORD					buffFill;

		DWORD					signalPosition;

		MPEGParams			params;

#if !DRVDLL
		MPEGStreamHookHandle	streamHook;
		MPEGSignalHookHandle	signalHook;
		MPEGSignalHookHandle	doneHook;
#endif

		WORD					leftVolume;
		WORD					rightVolume;
		BOOL					audioMute;
		BOOL					completed;

		DWORD	FindNextValidHeader(void);

		virtual Error GetDisplaySize(WORD __far &width, WORD __far &height);
	private:
		MPEGDecoder		*	decoder;
	public:
		VirtualMPEGDecoder(MPEGDecoder * unit);
		~VirtualMPEGDecoder(void);

		Error Configure (TAG __far *tags);

		Error SendCommand(MPEGCommand com, DWORD param, DWORD __far &tag);
		Error DoCommand(MPEGCommand com, DWORD param);
		Error CompleteCommand(DWORD tag);

		MPEGState CurrentState(void);

		Error SendBuffer(void);
		Error RecoverBuffer(void);

		DWORD SendData(HPTR data, DWORD size);
		void CompleteData(void);

		DWORD CurrentLocation(void);
	};

inline Error MPEGDecoder::DoCommand(MPEGCommand com, DWORD param)
	{
	DWORD tag;

	GNREASSERT(SendCommand(com, param, tag));
	GNREASSERT(CompleteCommand(tag));

	GNRAISE_OK;
	}

inline Error VirtualMPEGDecoder::DoCommand(MPEGCommand com, DWORD param)
	{
	DWORD tag;

	GNREASSERT(SendCommand(com, param, tag));
	GNREASSERT(CompleteCommand(tag));

	GNRAISE_OK;
	}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpeg2enc\specific\kfirreg.h ===
//
// FILE:      library\hardware\mpeg2enc\specific\kfirreg.h
// AUTHOR:    Martin Stephan
// COPYRIGHT: (c) 1999 VIONA Development GmbH.  All Rights Reserved.
// CREATED:   27.12.1999
//
// PURPOSE:   --- KFIR chip specific register definitions --- 
//
// HISTORY:
//

#ifndef KFIRREG_H
#define KFIRREG_H


#define DEV_ID_GC									7

#if 0

#define KFIR_ASPECT_RATIO						0*4
#define KFIR_FRAME_RATE_CODE					1*4
#define KFIR_COLOR_PRIM							2*4
#define KFIR_TRANSFER_CHAR						3*4
#define KFIR_MATRIX_COEFF						4*4
#define KFIR_BIT_RATE_0							5*4
#define KFIR_BIT_RATE_1							6*4
#define KFIR_BIT_RATE_2							7*4
#define KFIR_VBV_BUFFER_SIZE					8*4
#define KFIR_PROGRESSIVE_SEQ					9*4
#define KFIR_PROGRESSIVE_FRAME				10*4
#define KFIR_INTRA_DC_PRECISION				11*4
#define KFIR_INTRA_VLC_FORMAT_I				12*4
#define KFIR_INTRA_VLC_FORMAT_P				13*4
#define KFIR_INTRA_VLC_FORMAT_B				14*4
#define KFIR_ALT_SCAN_I							15*4  //  R/W
#define KFIR_ALT_SCAN_P							16*4  //  R/W
#define KFIR_ALT_SCAN_B							17*4  //  R/W
#define KFIR_FRAME_PRED_FRAME_DCT_I			18*4  //  R/W
#define KFIR_FRAME_PRED_FRAME_DCT_P			19*4  //  R/W
#define KFIR_FRAME_PRED_FRAME_DCT_B			20*4  //  R/W
#define KFIR_AVG_ACT								21*4  //  R/W
#define KFIR_X_I									22*4  //  R/W
#define KFIR_X_P									23*4  //  R/W
#define KFIR_X_B									24*4  //  R/W
#define KFIR_D0_I_0								25*4  //  R/W
#define KFIR_D0_P_0								26*4  //  R/W
#define KFIR_D0_B_0								27*4  //  R/W
#define KFIR_D0_I_1								28*4  //  R/W
#define KFIR_D0_P_1								29*4  //  R/W
#define KFIR_D0_B_1								30*4  //  R/W
#define KFIR_INTRAD								31*4  //  R/W
#define KFIR_TMIN									32*4  //  R/W
#define KFIR_R2									33*4  //  R/W
#define KFIR_MB_WIDTH							34*4  //  R/W
#define KFIR_RMBW									35*4  //  R/W
#define KFIR_RMB									36*4  //  R/W
#define KFIR_GETB									37*4  //  R/W
#define KFIR_C1									38*4  //  R/W
#define KFIR_C2									39*4  //  R/W
#define KFIR_STD_PICT_DEL						40*4  //  R/W
#define KFIR_FIRST_PICT_DEL					41*4  //  R/W
#define KFIR_GOPR1_1								42*4  //  R/W
#define KFIR_GOPR2_1								43*4  //  R/W
#define KFIR_GOPR1_0								44*4  //  R/W
#define KFIR_GOPR2_0								45*4  //  R/W
#define KFIR_SLICE_CONTROL						46*4  //  R/W
#define KFIR_VIDEO_FORMAT						47*4  //  R/W
#define KFIR_INTERLACED_SOURCE				48*4  //  R/W
#define KFIR_M										49*4  //  R/W
#define KFIR_MULTIPLE							50*4  //  R/W
#define KFIR_TOTAL_MBS							51*4  //  R/W
#define KFIR_MB_LINES							52*4  //  R/W
#define KFIR_RANDOM_SCAN						53*4  //  R/W
#define KFIR_VBR_ENABLE							54*4  //  R/W
#define KFIR_TOP_FIRST							55*4  //  R/W
#define KFIR_LOW_SEARCH_RANGE					56*4  //  R/W
#define KFIR_CONST_MQUANT						57*4  //  R/W
#define KFIR_LOW_LATENCY						58*4  //  R/W
#define KFIR_AUTO_PULLDOWN						59*4  //  R/W
#define KFIR_BITSTREAM_WIDTH					60*4  //  R/W
#define KFIR_VOB_BASE_ADDR						61*4  //  R/W
#define KFIR_USE_SDRAM_FIFO					62*4  //  R/W
#define KFIR_VIB_DEC_PATTERN					63*4  //  R/W
#define KFIR_VIB_DEC_SIZE						64*4  //  R/W
#define KFIR_VIB_VIDEO_PAR						65*4  //  R/W
#define KFIR_VIB_HORI_TOP_BOT					66*4  //  R/W
#define KFIR_VIB_VERT_TOP_BOT					67*4  //  R/W
#define KFIR_VIB_FILTERC_YH_0					68*4  //  R/W
#define KFIR_VIB_FILTERC_YH_1					69*4  //  R/W
#define KFIR_VIB_FILTERC_YH_2					70*4  //  R/W
#define KFIR_VIB_FILTERC_YH_3					71*4  //  R/W
#define KFIR_VIB_FILTERC_YH_4					72*4  //  R/W
#define KFIR_VIB_FILTERC_YH_5					73*4  //  R/W
#define KFIR_VIB_FILTERC_YH_6					74*4  //  R/W
#define KFIR_VIB_FILTERC_CH_0					75*4  //  R/W
#define KFIR_VIB_FILTERC_CH_1					76*4  //  R/W
#define KFIR_VIB_FILTERC_CH_2					77*4  //  R/W
#define KFIR_VIB_FILTERC_CH_3					78*4  //  R/W
#define KFIR_VIB_FILTERC_CH_4					79*4  //  R/W
#define KFIR_VIB_FILTERC_CH_5					80*4  //  R/W
#define KFIR_VIB_FILTERC_CH_6					81*4  //  R/W
#define KFIR_VIB_FILTERC_CV0_0				82*4  //  R/W
#define KFIR_VIB_FILTERC_CV0_1				83*4  //  R/W
#define KFIR_VIB_FILTERC_CV0_2				84*4  //  R/W
#define KFIR_VIB_FILTERC_CV0_3				85*4  //  R/W
#define KFIR_VIB_FILTERC_CV0_4				86*4  //  R/W
#define KFIR_VIB_FILTERC_CV0_5				87*4  //  R/W
#define KFIR_VIB_FILTERC_CV1_0				88*4  //  R/W
#define KFIR_VIB_FILTERC_CV1_1				89*4  //  R/W
#define KFIR_VIB_FILTERC_CV1_2				90*4  //  R/W
#define KFIR_VIB_FILTERC_CV1_3				91*4  //  R/W
#define KFIR_VIB_FILTERC_CV1_4				92*4  //  R/W
#define KFIR_VIB_FILTERC_CV1_5				93*4  //  R/W
#define KFIR_TELE_THRESHOLD_0					94*4  //  R/W
#define KFIR_TELE_THRESHOLD_1					95*4  //  R/W
#define KFIR_DMA_BSM_BURST						96*4  //  R/W
#define KFIR_DMA_BSM_BURST_END				97*4  //  R/W
#define KFIR_DMA_VIB_BURST						98*4  //  R/W
#define KFIR_DMA_VIB_BURST_END				99*4  //  R/W
#define KFIR_FILE_MODE							100*4		// taken from VisionTech's driver (file KfirDef.h)
#define KFIR_MPEG_I_NEG							103*4 	// taken from VisionTech's driver (file KfirDef.h)
#define KFIR_FRAME_SKIP_RATIO					104*4		// taken from VisionTech's driver (file KfirDef.h)
#define KFIR_GOP_0								128*4  //  R                      
#define KFIR_GOP_1								129*4  //  R
#define KFIR_PICT_TYPE							132*4  //  R
#define KFIR_X										146*4  // ?/W
#define KFIR_Y										149*4  //  ?/W
// DRAM check
// 1 in at least one bit - error
// 0                     - no errors.
#define KFIR_TEST_0								171*4  
#define KFIR_TEST_1								172*4  
// end DRAM check
#define KFIR_FRAME								183*4  //  R
#define KFIR_FIFO_REG_0							184*4  //  R
#define KFIR_FIFO_REG_1							185*4  //  R
#define KFIR_SRAM_CNT_0							186*4  //  R
#define KFIR_SRAM_CNT_1							187*4  //  R
#define KFIR_SRAM_REG_0							188*4  //  R
#define KFIR_SRAM_REG_1							189*4  //  R

#define KFIR_200                          200*4   // W
#define KFIR_DEV_INST                     KFIR_200   // W/R

#define KFIR_201                          201*4   // R
#define KFIR_EXEC                         KFIR_201  // R

#define KFIR_202                          202*4
#define KFIR_VIB_FIFO_BASE_ADR            KFIR_202   // W

#define KFIR_203									203*4
#define KFIR_MUX_FIFO_BASE_ADR            KFIR_203   // W

#define KFIR_204                          204*4
#define KFIR_AUDIO_FIFO_BASE_ADR          KFIR_204   // W

#define KFIR_205									205*4
#define KFIR_DREQ_MUX_VIB						KFIR_205

// 27 MHz based counter
#define KFIR_206									206*4
#define KFIR_REF_CLK_27M						KFIR_206

// MUX Memory Size
#define KFIR_207                          207*4
#define KFIR_MUX_MEM_SIZE						KFIR_207
// 20 bits

// MUX Memory Counter
#define KFIR_208                          208*4
#define KFIR_MUX_MEM_CNT						KFIR_208
// 20 bits

// VIB, Video Input Buffer, File Mode Memory Size
#define KFIR_209                          209*4
#define KFIR_VIB_MEM_SIZE						KFIR_209
// 20 bits

// VIB, Video Input Buffer, File Mode Memory Counter
#define KFIR_210                          210*4
#define KFIR_VIB_MEM_CNT						KFIR_210
// 20 bits

// I960 Config register. Master/Slave mode configuration. 
#define KFIR_211                          211*4   // W
#define KFIR_I960_CONFIG						KFIR_211
#define KFIR_I960_CONFIG_SLAVE					0
#define KFIR_I960_CONFIG_MASTER					1


#define KFIR_INTERRUPT_CNT						221*4  //  R
#define KFIR_AUDIO_PTS_0						222*4  //  R/W
#define KFIR_AUDIO_PTS_1						223*4  //  R/W
#define KFIR_AUDIO_PTS_2						224*4  //  R/W
#define KFIR_AUDIO_INT_ACK						228*4  //  ?/W
#define KFIR_AUDIO_FRAME_SIZE					229*4   // R/W
#define KFIR_MUX_CNT_0							231*4
#define KFIR_MUX_CNT_1							232*4
#define KFIR_MUX_CNT_2							233*4
#define KFIR_INT_VIDEO							234*4  //  R/W
#define KFIR_INT_AUDIO							235*4  //  R/W
#define KFIR_INT_DMA_MUX						236*4  //  R/W
#define KFIR_INT_DMA_VIB						237*4  //  R/W
#define KFIR_TEST_MODE							252*4  //  ?/W
#define KFIRIDX_TEST_MODE							0		// bit 0 
#define KFIR_TEST_MODE_OFF							0x0
#define KFIR_TEST_MODE_ON							0x1
#define KFIR_PAUSE								253*4   // R/W
#define KFIRVAL_RESUME								0x0
#define KFIRVAL_PAUSE								0x1

#define KFIR_EREADY								254*4  //  R
#define KFIRIDX_EREADY_0							0		// bit 0
#define KFIRVAL_ENCODING							0x0
#define KFIRVAL_READY								0x1
#define KFIRVAL_TEST									0x2
#define KFIRVAL_STOP_DETECT						0x3
#define KFIRVAL_SEQ_END								0x4

#define KFIR_RECORD								255*4  //  R/W
#define KFIRIDX_RECORD								0		// bit 0
#define KFIRVAL_RECORD_STOP						0x0
#define KFIRVAL_RECORD_START						0x1

#else // board revision 5E

#define KFIR_ASPECT_RATIO						0*4+ALT_ADR_KFIR_REV_5E
#define KFIR_FRAME_RATE_CODE					1*4+ALT_ADR_KFIR_REV_5E
#define KFIR_COLOR_PRIM							2*4+ALT_ADR_KFIR_REV_5E
#define KFIR_TRANSFER_CHAR						3*4+ALT_ADR_KFIR_REV_5E
#define KFIR_MATRIX_COEFF						4*4+ALT_ADR_KFIR_REV_5E
#define KFIR_BIT_RATE_0							5*4+ALT_ADR_KFIR_REV_5E
#define KFIR_BIT_RATE_1							6*4+ALT_ADR_KFIR_REV_5E
#define KFIR_BIT_RATE_2							7*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VBV_BUFFER_SIZE					8*4+ALT_ADR_KFIR_REV_5E
#define KFIR_PROGRESSIVE_SEQ					9*4+ALT_ADR_KFIR_REV_5E
#define KFIR_PROGRESSIVE_FRAME				10*4+ALT_ADR_KFIR_REV_5E
#define KFIR_INTRA_DC_PRECISION				11*4+ALT_ADR_KFIR_REV_5E
#define KFIR_INTRA_VLC_FORMAT_I				12*4+ALT_ADR_KFIR_REV_5E
#define KFIR_INTRA_VLC_FORMAT_P				13*4+ALT_ADR_KFIR_REV_5E
#define KFIR_INTRA_VLC_FORMAT_B				14*4+ALT_ADR_KFIR_REV_5E
#define KFIR_ALT_SCAN_I							15*4+ALT_ADR_KFIR_REV_5E 
#define KFIR_ALT_SCAN_P							16*4+ALT_ADR_KFIR_REV_5E
#define KFIR_ALT_SCAN_B							17*4+ALT_ADR_KFIR_REV_5E
#define KFIR_FRAME_PRED_FRAME_DCT_I			18*4+ALT_ADR_KFIR_REV_5E
#define KFIR_FRAME_PRED_FRAME_DCT_P			19*4+ALT_ADR_KFIR_REV_5E
#define KFIR_FRAME_PRED_FRAME_DCT_B			20*4+ALT_ADR_KFIR_REV_5E
#define KFIR_AVG_ACT								21*4+ALT_ADR_KFIR_REV_5E
#define KFIR_X_I									22*4+ALT_ADR_KFIR_REV_5E
#define KFIR_X_P									23*4+ALT_ADR_KFIR_REV_5E
#define KFIR_X_B									24*4+ALT_ADR_KFIR_REV_5E
#define KFIR_D0_I_0								25*4+ALT_ADR_KFIR_REV_5E
#define KFIR_D0_P_0								26*4+ALT_ADR_KFIR_REV_5E
#define KFIR_D0_B_0								27*4+ALT_ADR_KFIR_REV_5E
#define KFIR_D0_I_1								28*4+ALT_ADR_KFIR_REV_5E
#define KFIR_D0_P_1								29*4+ALT_ADR_KFIR_REV_5E
#define KFIR_D0_B_1								30*4+ALT_ADR_KFIR_REV_5E
#define KFIR_INTRAD								31*4+ALT_ADR_KFIR_REV_5E
#define KFIR_TMIN									32*4+ALT_ADR_KFIR_REV_5E
#define KFIR_R2									33*4+ALT_ADR_KFIR_REV_5E
#define KFIR_MB_WIDTH							34*4+ALT_ADR_KFIR_REV_5E
#define KFIR_RMBW									35*4+ALT_ADR_KFIR_REV_5E
#define KFIR_RMB									36*4+ALT_ADR_KFIR_REV_5E
#define KFIR_GETB									37*4+ALT_ADR_KFIR_REV_5E
#define KFIR_C1									38*4+ALT_ADR_KFIR_REV_5E
#define KFIR_C2									39*4+ALT_ADR_KFIR_REV_5E
#define KFIR_STD_PICT_DEL						40*4+ALT_ADR_KFIR_REV_5E
#define KFIR_FIRST_PICT_DEL					41*4+ALT_ADR_KFIR_REV_5E
#define KFIR_GOPR1_1								42*4+ALT_ADR_KFIR_REV_5E
#define KFIR_GOPR2_1								43*4+ALT_ADR_KFIR_REV_5E
#define KFIR_GOPR1_0								44*4+ALT_ADR_KFIR_REV_5E
#define KFIR_GOPR2_0								45*4+ALT_ADR_KFIR_REV_5E
#define KFIR_SLICE_CONTROL						46*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIDEO_FORMAT						47*4+ALT_ADR_KFIR_REV_5E
#define KFIR_INTERLACED_SOURCE				48*4+ALT_ADR_KFIR_REV_5E
#define KFIR_M										49*4+ALT_ADR_KFIR_REV_5E
#define KFIR_MULTIPLE							50*4+ALT_ADR_KFIR_REV_5E
#define KFIR_TOTAL_MBS							51*4+ALT_ADR_KFIR_REV_5E
#define KFIR_MB_LINES							52*4+ALT_ADR_KFIR_REV_5E
#define KFIR_RANDOM_SCAN						53*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VBR_ENABLE							54*4+ALT_ADR_KFIR_REV_5E
#define KFIR_TOP_FIRST							55*4+ALT_ADR_KFIR_REV_5E
#define KFIR_LOW_SEARCH_RANGE					56*4+ALT_ADR_KFIR_REV_5E
#define KFIR_CONST_MQUANT						57*4+ALT_ADR_KFIR_REV_5E
#define KFIR_LOW_LATENCY						58*4+ALT_ADR_KFIR_REV_5E
#define KFIR_AUTO_PULLDOWN						59*4+ALT_ADR_KFIR_REV_5E
#define KFIR_BITSTREAM_WIDTH					60*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VOB_BASE_ADDR						61*4+ALT_ADR_KFIR_REV_5E
#define KFIR_USE_SDRAM_FIFO					62*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_DEC_PATTERN					63*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_DEC_SIZE						64*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_VIDEO_PAR						65*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_HORI_TOP_BOT					66*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_VERT_TOP_BOT					67*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_YH_0					68*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_YH_1					69*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_YH_2					70*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_YH_3					71*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_YH_4					72*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_YH_5					73*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_YH_6					74*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_CH_0					75*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_CH_1					76*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_CH_2					77*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_CH_3					78*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_CH_4					79*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_CH_5					80*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_CH_6					81*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_CV0_0				82*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_CV0_1				83*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_CV0_2				84*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_CV0_3				85*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_CV0_4				86*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_CV0_5				87*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_CV1_0				88*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_CV1_1				89*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_CV1_2				90*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_CV1_3				91*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_CV1_4				92*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FILTERC_CV1_5				93*4+ALT_ADR_KFIR_REV_5E
#define KFIR_TELE_THRESHOLD_0					94*4+ALT_ADR_KFIR_REV_5E
#define KFIR_TELE_THRESHOLD_1					95*4+ALT_ADR_KFIR_REV_5E
#define KFIR_DMA_BSM_BURST						96*4+ALT_ADR_KFIR_REV_5E
#define KFIR_DMA_BSM_BURST_END				97*4+ALT_ADR_KFIR_REV_5E
#define KFIR_DMA_VIB_BURST						98*4+ALT_ADR_KFIR_REV_5E
#define KFIR_DMA_VIB_BURST_END				99*4+ALT_ADR_KFIR_REV_5E
#define KFIR_FILE_MODE							100*4+ALT_ADR_KFIR_REV_5E	// taken from VisionTech's driver (file KfirDef.h)
#define KFIR_MPEG_I_NEG							103*4+ALT_ADR_KFIR_REV_5E 	// taken from VisionTech's driver (file KfirDef.h)
#define KFIR_FRAME_SKIP_RATIO					104*4+ALT_ADR_KFIR_REV_5E		// taken from VisionTech's driver (file KfirDef.h)
#define KFIR_GOP_0								128*4+ALT_ADR_KFIR_REV_5E         
#define KFIR_GOP_1								129*4+ALT_ADR_KFIR_REV_5E
#define KFIR_PICT_TYPE							132*4+ALT_ADR_KFIR_REV_5E
#define KFIR_X										146*4+ALT_ADR_KFIR_REV_5E
#define KFIR_Y										149*4+ALT_ADR_KFIR_REV_5E
// DRAM check
// 1 in at least one bit - error
// 0                     - no errors.
#define KFIR_TEST_0								171*4+ALT_ADR_KFIR_REV_5E
#define KFIR_TEST_1								172*4+ALT_ADR_KFIR_REV_5E
// end DRAM check
#define KFIR_FRAME								183*4+ALT_ADR_KFIR_REV_5E
#define KFIR_FIFO_REG_0							184*4+ALT_ADR_KFIR_REV_5E
#define KFIR_FIFO_REG_1							185*4+ALT_ADR_KFIR_REV_5E
#define KFIR_SRAM_CNT_0							186*4+ALT_ADR_KFIR_REV_5E
#define KFIR_SRAM_CNT_1							187*4+ALT_ADR_KFIR_REV_5E
#define KFIR_SRAM_REG_0							188*4+ALT_ADR_KFIR_REV_5E
#define KFIR_SRAM_REG_1							189*4+ALT_ADR_KFIR_REV_5E

#define KFIR_200                          200*4+ALT_ADR_KFIR_REV_5E
#define KFIR_DEV_INST                     KFIR_200   // W/R

#define KFIR_201                          201*4+ALT_ADR_KFIR_REV_5E
#define KFIR_EXEC                         KFIR_201  // R

#define KFIR_202                          202*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_FIFO_BASE_ADR            KFIR_202   // W

#define KFIR_203									203*4+ALT_ADR_KFIR_REV_5E
#define KFIR_MUX_FIFO_BASE_ADR            KFIR_203   // W

#define KFIR_204                          204*4+ALT_ADR_KFIR_REV_5E
#define KFIR_AUDIO_FIFO_BASE_ADR          KFIR_204   // W

#define KFIR_205									205*4+ALT_ADR_KFIR_REV_5E
#define KFIR_DREQ_MUX_VIB						KFIR_205

// 27 MHz based counter
#define KFIR_206									206*4+ALT_ADR_KFIR_REV_5E
#define KFIR_REF_CLK_27M						KFIR_206

// MUX Memory Size
#define KFIR_207                          207*4+ALT_ADR_KFIR_REV_5E
#define KFIR_MUX_MEM_SIZE						KFIR_207
// 20 bits

// MUX Memory Counter
#define KFIR_208                          208*4+ALT_ADR_KFIR_REV_5E
#define KFIR_MUX_MEM_CNT						KFIR_208
// 20 bits

// VIB, Video Input Buffer, File Mode Memory Size
#define KFIR_209                          209*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_MEM_SIZE						KFIR_209
// 20 bits

// VIB, Video Input Buffer, File Mode Memory Counter
#define KFIR_210                          210*4+ALT_ADR_KFIR_REV_5E
#define KFIR_VIB_MEM_CNT						KFIR_210
// 20 bits

// I960 Config register. Master/Slave mode configuration. 
#define KFIR_211                          211*4+ALT_ADR_KFIR_REV_5E
#define KFIR_I960_CONFIG						KFIR_211
#define KFIR_I960_CONFIG_SLAVE					0
#define KFIR_I960_CONFIG_MASTER					1


#define KFIR_INTERRUPT_CNT						221*4+ALT_ADR_KFIR_REV_5E
#define KFIR_AUDIO_PTS_0						222*4+ALT_ADR_KFIR_REV_5E
#define KFIR_AUDIO_PTS_1						223*4+ALT_ADR_KFIR_REV_5E
#define KFIR_AUDIO_PTS_2						224*4+ALT_ADR_KFIR_REV_5E
#define KFIR_AUDIO_INT_ACK						228*4+ALT_ADR_KFIR_REV_5E
#define KFIR_AUDIO_FRAME_SIZE					229*4+ALT_ADR_KFIR_REV_5E
#define KFIR_MUX_CNT_0							231*4+ALT_ADR_KFIR_REV_5E
#define KFIR_MUX_CNT_1							232*4+ALT_ADR_KFIR_REV_5E
#define KFIR_MUX_CNT_2							233*4+ALT_ADR_KFIR_REV_5E
#define KFIR_INT_VIDEO							234*4+ALT_ADR_KFIR_REV_5E
#define KFIR_INT_AUDIO							235*4+ALT_ADR_KFIR_REV_5E
#define KFIR_INT_DMA_MUX						236*4+ALT_ADR_KFIR_REV_5E
#define KFIR_INT_DMA_VIB						237*4+ALT_ADR_KFIR_REV_5E
#define KFIR_TEST_MODE							252*4+ALT_ADR_KFIR_REV_5E
#define KFIRIDX_TEST_MODE							0		// bit 0 
#define KFIR_TEST_MODE_OFF							0x0
#define KFIR_TEST_MODE_ON							0x1
#define KFIR_PAUSE								253*4+ALT_ADR_KFIR_REV_5E
#define KFIRVAL_RESUME								0x0
#define KFIRVAL_PAUSE								0x1

#define KFIR_EREADY								254*4+ALT_ADR_KFIR_REV_5E
#define KFIRIDX_EREADY_0							0		// bit 0
#define KFIRVAL_ENCODING							0x0
#define KFIRVAL_READY								0x1
#define KFIRVAL_TEST									0x2
#define KFIRVAL_STOP_DETECT						0x3
#define KFIRVAL_SEQ_END								0x4

#define KFIR_RECORD								255*4+ALT_ADR_KFIR_REV_5E
#define KFIRIDX_RECORD								0		// bit 0
#define KFIRVAL_RECORD_STOP						0x0
#define KFIRVAL_RECORD_START						0x1

#endif 

//
// A/V Multiplexer Parameters
//

#define KFIR_MUX_STREAM_TYPE							0				// stream type
#define KFIR_MUX_PROGRAM_NUMBER						1				// number (id) of a program within the transport stream
#define KFIR_MUX_TRANSPORT_STREAM_ID				2				// transport stream id
#define KFIR_MUX_AUDIO_STREAM_TYPE					3				// audio stream type
#define KFIR_MUX_PMT_PID								4				// program map table packet id
#define KFIR_MUX_VIDEO_PID								5				// video packet id
#define KFIR_MUX_AUDIO_PID								6				// audio packet id
#define KFIR_MUX_VIDEO_STREAM_ID						7				// video stream id within the PES packet
#define KFIR_MUX_AUDIO_STREAM_ID						8				// audio stream id within the PES packet
#define KFIR_MUX_VIDEO_BITRATE_LOW					9				// 16 least significant bits of video bit rate
#define KFIR_MUX_VIDEO_BITRATE_HIGH					10				// 16 most significant bits of video bit rate
#define KFIR_MUX_AUDIO_BITRATE_LOW					11				// 16 least significant bits of audio bit rate
#define KFIR_MUX_AUDIO_BITRATE_HIGH					12				// 16 most significant bits of audio bit rate
#define KFIR_MUX_TRANSPORT_BITRATE_LOW				13				// 16 least significant bits of transport bitrate
#define KFIR_MUX_TRANSPORT_BITRATE_HIGH			14				// 16 most significant bits of transport bitrate
#define KFIR_MUX_VPTS_OFFSET_LOW						15				// 16 least significant bits of initial video PTS/DTS offset, ms
#define KFIR_MUX_VPTS_OFFSET_HIGH					16				// 16 most significant bits of initial video PTS/DTS offset, ms
#define KFIR_MUX_APTS_OFFSET_LOW						17				// 16 least significant bits of initial audio PTS/DTS offset, ms
#define KFIR_MUX_APTS_OFFSET_HIGH					18				// 16 most significant bits of initial audio PTS/DTS offset, ms 
#define KFIR_MUX_MAX_VIDEO_PES_SIZE					19				// maximum size of a packetized video elementary stream packet, bytes
#define KFIR_MUX_MAX_AUDIO_PES_SIZE					20				// maximum size of a packetized audio elementary stream packet, bytes
#define KFIR_MUX_PAT_RATE								21				// time interval between two successive PAT/PMT table transmission, ms
#define KFIR_MUX_FRAMES_PER_100_SEC					22				// number of video frames within 100 sec
#define KFIR_MUX_PAT_TABLE_SIZE						23				// size of program association table, bytes
#define KFIR_MUX_PMT_TABLE_SIZE						24				// size of program map table, bytes
#define KFIR_MUX_PCR_BITLIMIT_LOW					25				// PCR bitlimit [15:0]
#define KFIR_MUX_PCR_BITLIMIT_MID					26				// PCR bitlimit [31:16]
#define KFIR_MUX_PCR_BITLIMIT_HIGH					27				// PCR bitlimit [47:32]
#define KFIR_MUX_PCR_STEP_LOW							28				// PCR step	[15:0]
#define KFIR_MUX_PCR_STEP_MID							29				// PCR step [31:16]
#define KFIR_MUX_PCR_STEP_HIGH						30				// PCR step [47:32]
#define KFIR_MUX_PCR_STEP_100SEC_LOW				31				// PCR step 100 sec [15:0]
#define KFIR_MUX_PCR_STEP_100SEC_HIGH				32				// PCR step 100 sec [31:16]
#define KFIR_MUX_PCR_BASE_STEP_LOW					33				// PCR base step [15:0]
#define KFIR_MUX_PCR_BASE_STEP_HIGH					34				// PCR base step [31:16]
#define KFIR_MUX_PCR_BASE_STEP_100SEC_LOW			35				// PCR base step 100 sec [15:0]
#define KFIR_MUX_PCR_BASE_STEP_100SEC_HIGH		36				// PCR base step 100 sec [31:16]
#define KFIR_MUX_PPH_C1									37				// PES packet header constant #1
#define KFIR_MUX_PPH_C2									38				// PES packet header constant #2
#define KFIR_MUX_TPH_C1									39				// transport packet header constant #1
#define KFIR_MUX_TPH_C2									40				// transport packet header constant #2
#define KFIR_MUX_ES_RATE_FLAG							41				// ES rate flag
#define KFIR_MUX_ESCR_FLAG								42				// ESCR flag
#define KFIR_MUX_ESCR_BASE_LOW						43				// ESCR base [15:0]
#define KFIR_MUX_ESCR_BASE_MID						44				// ESCR base [31:16]
#define KFIR_MUX_ESCR_BASE_HIGH						45				// ESCR base [32]
#define KFIR_MUX_ESCR_EXTENTION						46				// ESCR extension
#define KFIR_MUX_SCRAMBLING							47				// scrambling
#define KFIR_MUX_ERROR_INDICATOR						48				// error indicator
#define KFIR_MUX_PRIORITY								49				// priority
#define KFIR_MUX_DTS_PER_FRAME						50				// DTS per frame
#define KFIR_MUX_PTS_DTS_OFFSET						51				// PTS - DTS offset
#define KFIR_MUX_PCR_CORRECTION_CONST_LOW			52				// PCR correction const [10:0]
#define KFIR_MUX_PCR_CORRECTION_CONST_HIGH		53				// PCR correction const [21:11]
#define KFIR_MUX_PCR_BASE_CORRECTION_CONST_LOW	54				// PCR base correction const [10:0]
#define KFIR_MUX_PCR_BASE_CORRECTION_CONST_HIGH	55				// PCR base correction const [21:11]
#define KFIR_MUX_ES_RATE_LOW							56				// ES rate [15:0]
#define KFIR_MUX_ES_RATE_HIGH							57				// ES rate [31:16]
#define KFIR_MUX_PROGRAM_MUX_RATE_LOW				58				// program mux rate (video bit rate + audio bit rate) in BPS/400, bits [15:0]
#define KFIR_MUX_PROGRAM_MUX_RATE_HIGH				59				// program mux rate (video bit rate + audio bit rate) in BPS/400, bits [21:16]
#define KFIR_MUX_RATE_BOUND_LOW						60				// max program mux rate over the entire stream, bits [15:0]
#define KFIR_MUX_RATE_BOUND_HIGH						61				// max program mux rate over the entire stream, bits [21:16]
#define KFIR_MUX_SHF_LOW								62				// bits [15:0] of SHF
#define KFIR_MUX_SHF_HIGH								63				// bits [24:16] of SHF
#define KFIR_MUX_AUDIO_PAR_CONST_LOW				64				// audio par const [15:0]
#define KFIR_MUX_AUDIO_PAR_CONST_HIGH				65				// audio par const [23:16]
#define KFIR_MUX_VIDEO_PAR_CONST_LOW				66				// video par const [15:0]
#define KFIR_MUX_VIDEO_PAR_CONST_HIGH				67				// video par const [23:16]
#define KFIR_MUX_AUDIO_MISS_LATENCY					68				// sets the maximum period of waiting for missing audio data before sending the video frames (in video frames)
#define KFIR_MUX_PAT_TABLE_START						80				// PAT table elements, leftmost element first
#define KFIR_MUX_PMT_TABLE_START						110			// PMT table elements, leftmost element first



#endif // KFIRREG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpegdec\specific\ZR36100.H ===
// FILE:      library\hardware\mpegdec\specific\zr36100.h
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   10.04.95
//
// PURPOSE:   
//
// HISTORY:

#ifndef ZR36100_H
#define ZR36100_H

#include "zr361x0.h"
	
class ZR36100 : public ZR361X0 {
	friend class VirtualZR36100;
	private:                       
		DWORD lastCommandInt;
		
		Error WaitForReady(void);
		Error SendChipCommand(WORD command);

		Error SendRegisterSet(MPEGParams __far &params);
		Error InitChip(MPEGParams __far &params);

		DWORD SendFakeHeader(MPEGParams __far &params);
		
		void VBlankInterrupt(void);

		BOOL			forwardRequest;

	public:
		ZR36100(ASyncOutStream       * strm, 
		        ByteIndexedInOutPort * bio, 
		        WordIndexedInOutPort * wio,
		        BitOutputPort		  * resetPin,
		        BitOutputPort		  * mb4,
		        MPEGAudioDecoder	  * audio,
		        BOOL						 mixedIO, 
		        WORD						 transferSize, 
		        KernelString				 mCodePath,
		        VirtualUnit			  * videoBus,
		        VirtualUnit          * audioBus,
		        InterruptServer		  * vblankIntServer);
		~ZR36100(void);

		VirtualUnit * CreateVirtual(void);
	};



class VirtualZR36100 : public VirtualZR361X0 {
	protected:
		Error GetDisplaySize(WORD __far &width, WORD __far &height);
	public:
		VirtualZR36100(ZR361X0	*	unit);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpegdec\specific\ZR36110.H ===
// FILE:      library\hardware\mpegdec\specific\zr36110.h
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   10.04.95
//
// PURPOSE:   
//
// HISTORY:

#ifndef ZR36110_H
#define ZR36110_H

#include "zr361x0.h"

class VirtualZR36110;
	
class ZR36110 : public ZR361X0 {
	friend class VirtualZR36110;
	private:                       
		BOOL	audioIDPending;
		BYTE	newAudioID;
		
		Error WaitForReady(void);
		Error SendChipCommand(WORD command);
		
		Error SendRegisterSet(MPEGParams __far &params);
		Error InitChip(MPEGParams __far &params);

		DWORD SendFakeHeader(MPEGParams __far &params);

		Error SetBrightness(WORD brightness);
		Error SetContrast(WORD contrast);

		Error SetVideoStreamID(BYTE id);
		Error SetAudioStreamID(BYTE id);
		
		void VBlankInterrupt(void);
	public:
		ZR36110(ASyncOutStream       * strm, 
		        ByteIndexedInOutPort * bio, 
		        WordIndexedInOutPort * wio,
		        BitOutputPort		  * resetPin, 
		        BitOutputPort		  * mb4,
		        MPEGAudioDecoder	  * audio,
		        BOOL						 mixedIO, 
		        WORD						 transferSize, 
		        KernelString				 mCodePath,
		        VirtualUnit			  * videoBus,
		        VirtualUnit          * audioBus,
		        InterruptServer		  * vblankIntServer);
		~ZR36110(void);

		VirtualUnit * CreateVirtual(void);
	};



class VirtualZR36110 : public VirtualZR361X0 {
	protected:
		WORD brightness;
		WORD contrast;
				
		Error GetDisplaySize(WORD __far &width, WORD __far &height);
		Error Configure (TAG __far *tags);    
		
		Error SetOnlineParams(void);
	public:
		VirtualZR36110(ZR361X0	*	unit);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpgcodec\generic\mpgcodec.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:       library\hardware\mpgcodec\generic\mpgcodec.h
// AUTHOR:		Martin Stephan
// COPYRIGHT:	(c) 1999 Viona Development GmbH.  All Rights Reserved.
// CREATED:		22.11.1999
//
// PURPOSE: 	shared definitions for MPEG2 encoder and decoder --- Header file
//					most of these definitions were previously defined in mpegdec.h
//					and were now moved to mpgcodec.h!
//
// HISTORY:
//

#ifndef MPGCODEC_H
#define MPGCODEC_H


enum MPEGCommand {mpc_none, 	  		// 0x0
                  mpc_start,    		// 0x1
                  mpc_play,     		// 0x2
                  mpc_seek,     		// 0x3
                  mpc_stop,     		// 0x4
                  mpc_step,     		// 0x5
                  mpc_freeze,   		// 0x6
                  mpc_resync,   		// 0x7
                  mpc_resyncue, 		// 0x8
                  mpc_cue,				// 0x9
                  mpc_end,				// 0xA
                  mpc_params,			// 0xB
                  mpc_stepkey,		// 0xC
                  mpc_scan,			// 0xD
						mpc_reverse,		// 0xE
						mpc_trickplay,		// 0xF
						mpc_seekaudio,		// 0x10
						mpc_resyncaudio,	// 0x11
						mpc_audio_test		// 0x12	Audio tests : pink noise, test tone
						};

enum MPEGState   {mps_reset, mps_preempted, mps_initial,
                  mps_frozen, mps_playing, mps_stepping,
                  mps_seeking, mps_resyncing, mps_stopped,
                  mps_scanning, mps_trickplaying, mps_testing,
						mps_capturing};

enum MPEGElementaryStreamType
	{
	MST_VIDEO,
	MST_AUDIO,
	MST_SUBPICTURE
	};


#endif // MPGCODEC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpegdec\specific\zr361x0.h ===
// FILE:      library\hardware\mpegdec\specific\zr361x0.h
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   10.04.95
//
// PURPOSE:   Combined parent class for ZR36100 (I11) and ZR36110 (I16)
//
// HISTORY:

#ifndef ZR361X0_H
#define ZR361X0_H

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"
#include "..\generic\mpegdec.h"        
#include "library\lowlevel\hardwrio.h"
#include "library\lowlevel\intrctrl.h"
#include "library\general\asncstrm.h"
#include "library\common\krnlstr.h"

#define	GNR_ZR361X0_TIMEOUT			MKERR(ERROR, MPEG, TIMEOUT, 0x01)
	// Timeout during parameter transfer

#define	GNR_ZR361X0_INITIAL_IDLE	MKERR(ERROR, MPEG, BUSY, 0x02)
	// Chip not correctly initialized

class ZR361X0VBlankIntHandler;
class ZR361X0IdleIntHandler;

	//
	// Polled IO data transfer class.
	//
class ZR361X0PortOutStream : public ASyncOutStream {
	protected:
		ByteIndexedInOutPort	*	bio;					// data ports
		WordIndexedInOutPort	*	wio;                    
		WORD				   		transferSize;		// size of one transfer burst
		BOOL							transferRunning;	// transfer is running
		//
		// Circular buffer handling:
		//            _____________________AvailData();
		//           /                    /
		//   .......######################............
		//          |                    |
		//           \startValid          \endValid
		//
		// or
		//
		//   #########......................##########
		//           |                      |
		//            \endValid              \startValid
		//   
		volatile DWORD				startValid;			// start of circular buffer
		DWORD							endValid;       	// end of circular buffer
		DWORD							buffSize;   		// size of the circular buffer
		DWORD							buffStart;			// start of buffer in stream
		
		HBPTR							buffer;				// pointer to buffer

		virtual DWORD TransferBlock(FPTR buff, DWORD num) = 0;
		DWORD TransferHBlock(HBPTR buff, DWORD num);
	public:
		ZR361X0PortOutStream(ByteIndexedInOutPort * bio,
		                     WordIndexedInOutPort * wio,
		                     WORD                   transferSize,
		                     DWORD						  buffSize);
		
		//
		// Transfer data in interrupt
		//
		void IntTransfer(DWORD maxTransfer);

		//
		// Implementation of ASyncOutStream
		//				
		Error WriteData(HPTR data, DWORD size, DWORD __far &done);
		DWORD AvailSpace(void);
		DWORD AvailData(void);
		DWORD GetTransferLocation(void);
		void SetTransferLocation(DWORD pos);
		Error RecoverData(HPTR buffer, DWORD size, DWORD __far &done);
				
		Error StartTransfer(void);
		Error StopTransfer(void);       
		Error SyncTransfer(void);
		Error CompleteTransfer(void);
		Error FlushBuffer(void);		
	};

	//
	// Base definition of a MPEG audio decoder
	//	
class MPEGAudioDecoder {
	public:
		virtual Error MuteAudio(BOOL mute) = 0;
		virtual Error SetLeftVolume(WORD volume) = 0; // 0..10000
		virtual Error SetRightVolume(WORD volume) = 0; // 0..10000
	};

	//
	// Base class for ZR36100 and ZR36110 MPEG decoders
	//	
class ZR361X0 : public MPEGDecoder, protected ASyncRefillRequest {
	friend class VirtualZR361X0;
	friend class ZR361X0VBlankIntHandler;
	friend class ZR361X0IdleIntHandler;
	protected:                       
		BitOutputPort				*	resetPin;
		BitOutputPort				*	mb4;
		ByteIndexedInOutPort    *	bio;
		WordIndexedInOutPort		*	wio;
		ASyncOutStream				*	strm;                          
		MPEGAudioDecoder			*	audio;
		ZR361X0PortOutStream		*	pstrm;   //	Port dma out stream
						
		ZR361X0IdleIntHandler 	*	idleIntHandler;	// handler for IDLE interrupt
		ZR361X0VBlankIntHandler *	vblankIntHandler;	// handler for VBLANK interrupt	

		DWORD								intCount;			// interrupt counter
		DWORD								lastInnerInt;		// last interrupt during transfer
		
      InterruptServer		  	*	vblankIntServer;  // VBLANK interrupt server
		
		struct FullCommand {						// Command queue
			MPEGCommand	com;
			DWORD			data;
			} comBuffer[16];
		volatile DWORD			lastTag;			// last inserted command
		volatile DWORD			nextTag;			// first inserted command
		volatile DWORD			doneTag;			// last executed command
				
		volatile enum ExtStates {xreset,				// 0
		                         xinitial1,       // 1
		                         xinitial2,       // 2
		                         xinitial3,       // 3
					                xfrozen,         // 4
					                xplaying,        // 5
					                xsuspended,      // 6
					                xstepping,       // 7
					                xseekpending,    // 8
					                xseeking,        // 9
					                xresyncing,      // 10
					                xresyncing1,     // 11
					                xresyncing2,     // 12
					                xresyncing3,     // 13
					                xstopfreeze,     // 14
					                xstopped,        // 15
					                xrestarting,     // 16
					                xrestarting1,    // 17
					                xleaping,        // 18
					                xslowleaping,    // 19
					                xseekfreeze,		// 20
					                xresetfreeze,		// 21
					                xcued,           // 22
					                xresetpending,	// 23
					                xfastleaping,		// 24
					                xfastfreezing,	// 25
					                xkeystepping,		// 26
					                xillegal} extState; // 27

		WORD						stateDelay;			// delay counter for state transition
		DWORD						stateRepeat;		// number of repeate for current state
		WORD						lastPlayCommand; 	// last play command, for speed changes
		DWORD						statePosition;		// file position at last state

		DWORD						maxTransfer;		// maximum number of bytes to transfer per interrupt
		
		KernelString			mCodePath;			// path to the microcode directories
		
		BOOL						wordHost;         // flag whether this is a word host
		BOOL						mixedIO;				// mixedIO or DMA only
		WORD						transferSize;		// number of bytes per port stroke
		MPEGStreamType			streamType;			// type of current MPEG stream
		BOOL						pulldown;			// 3/2 pulldown (speed bug fix)
		
		DWORD						signalPosition;	// position of next signal

		DWORD						watchPosition;		
		DWORD						watchCount;
		
		//
		// Tests whether commands are pending
		//
		BOOL CommandsPending(void) {return nextTag != lastTag;}
		//
		// Get the next command from the queue
		//
		BOOL NextCommand(MPEGCommand __far &com, DWORD __far &param);
		//
		// Complete command execution
		//
		void DoneCommand(void);
		//
		// Check the next command
		//
		MPEGCommand PeekCommand(void);

		//
		// Wait for ready bit set
		//
		virtual Error WaitForReady(void) = 0;
		//
		// Send data to the chip
		//
		Error SendChipData(FPTR data, WORD num);
		//
		// Send a command to the chip
		//
		virtual Error SendChipCommand(WORD command) = 0;
		
		//
		// Send a microcode
		//		
		Error SendMCode(KernelString name, BYTE reg, WORD len);
		//
		// Initialize the chip, microcodes/parameters
		//
		virtual Error InitChip(MPEGParams __far &params) = 0;
		//
		// Put the chip into resetstate
		//
		Error ResetChip(void);
		
		//
		// VBlank ISR
		//
		virtual void VBlankInterrupt(void) = 0;
		//
		// Idle ISR
		//
		void IdleInterrupt(void);                        
		
		BOOL			forwardRequest;

		//
		// Forward the refill request
		//
		void RefillRequest(DWORD free);
		//
		// Send data to the buffer
		//
		DWORD SendData(HPTR data, DWORD size);
		//
		// Recover data from the buffer
		//
		DWORD RecoverData(HPTR data, DWORD size); 
		//
		// Send a fake restart header to the buffer
		//
		virtual DWORD SendFakeHeader(MPEGParams __far &params) = 0;
      
      //
      // Set audio parameters
      //
		Error SetLeftVolume(WORD volume);
		Error SetRightVolume(WORD volume);
		Error MuteAudio(BOOL mute);       
		
		Error SetVideoStreamID(BYTE id);
		Error SetAudioStreamID(BYTE id);

		DWORD prevPos;
		DWORD	signalPos;
		
   	//
   	// Set a signal
   	//
   	Error	SetSignal(DWORD position);   	

		VirtualUnit	*	videoBus;
		VirtualUnit	*	audioBus;	 
		
		Error Lock(VirtualUnit * unit);
		Error Unlock(VirtualUnit * unit);
	public:
		ZR361X0(ByteIndexedInOutPort * bio, 
		        WordIndexedInOutPort * wio,
		        BitOutputPort		  * resetPin,
		        BitOutputPort		  * mb4,
		        MPEGAudioDecoder	  * audio,
		        BOOL						 mixedIO, 
		        WORD						 transferSize, 
		        KernelString				 mCodePath,
		        VirtualUnit			  * videoBus,
		        VirtualUnit          * audioBus,
		        InterruptServer		  * vblankIntServer);
		~ZR361X0(void);
      
		Error SendCommand(MPEGCommand com, DWORD param, DWORD __far &tag); 
		Error CompleteCommand(DWORD tag);
		
//		DWORD SendData(APTR data, DWORD size);
		void CompleteData(void);
		DWORD GetData(APTR data, DWORD size);
		
		MPEGState CurrentState(void);    
		DWORD CurrentLocation(void);
	};



class VirtualZR361X0 : public VirtualMPEGDecoder {
	protected:
		ZR361X0	*	decoder;             
		
		BOOL			initialCall;
		DWORD			illegalFakeOffset;

		virtual Error SetOnlineParams(void);
		
		Error Preempt(VirtualUnit * unit);
	public:
		VirtualZR361X0(ZR361X0	*	unit);
		
		void IllegalSeek(void);
		
		void IllegalResync(DWORD pos);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\mpegenc\generic\mpegenc.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:       library\hardware\mpegenc\generic\mpegenc.h
// AUTHOR:		Martin Stephan
// COPYRIGHT:	(c) 1999 Viona Development GmbH.  All Rights Reserved.
// CREATED:		26.10.1999
//
// PURPOSE: 	MPEG encoder and supporting classes. --- Header file
//
// HISTORY:
//

#ifndef MPEGENC_H
#define MPEGENC_H

#include "library\common\vddebug.h"
#include "library\common\tags.h"
#include "library\common\hooks.h"
#include "library\common\tagunits.h"
#include "library\common\virtunit.h"
#include "library\hardware\video\generic\vidtypes.h"
#include "library\hardware\mpgcodec\generic\mpgcodec.h"


struct MPEGTransferDoneMsg {
	};

struct MPEGEncoderBufferStarvingMsg {
	};


MKHOOK(MPEGTransferDone, MPEGTransferDoneMsg)
MKHOOK(MPEGEncoderBufferStarving, MPEGEncoderBufferStarvingMsg)


typedef MPEGTransferDoneHook	__far *	MPEGTransferDoneHookPtr;
typedef MPEGEncoderBufferStarvingHook __far *  MPEGEncoderBufferStarvingHookPtr;


enum MPEGEncoderStreamType
	{
	MST_UNKNOWN					= 0x00,
	MST_AUDIO_ELEMENTARY		= 0x01,
	MST_VIDEO_ELEMENTARY		= 0x02,
	MST_PROGRAM					= 0x03,
	MST_TRANSPORT				= 0x04,
	MST_PACKET_ELEMENTARY	= 0x05,
	MST_PACKET_VIDEO_ES		= 0x06,
	MST_PACKET_AUDIO_ES		= 0x07,
	MST_MPEG1					= 0x08
	};


MKTAG(MPEG_TRANSFER_DONE_HOOK,		MPEG_ENCODER_UNIT,	0x0001, MPEGTransferDoneHookPtr)
MKTAG(MPEG_ENCODER_BUFFER_STARVING, MPEG_ENCODER_UNIT,   0x0002, MPEGEncoderBufferStarvingHookPtr)
MKTAG(MPEG_ENC_OUTPUT_TYPE,			MPEG_ENCODER_UNIT,   0x0003, MPEGEncoderStreamType)
MKTAG(MPEG_ENC_VIDEO_SOURCE,			MPEG_ENCODER_UNIT,	0x0004, VideoSource)
MKTAG(MPEG_ENC_VIDEOSTANDARD,			MPEG_ENCODER_UNIT,	0x0005, VideoStandard)
//MKTAG(MPEG_ENC_VIDEO_WIDTH,	MPEG_ENCODER_UNIT,	0x0002, WORD)
//MKTAG(MPEG_ENC_VIDEO_HEIGHT,  MPEG_ENCODER_UNIT,   0x0003, WORD)

//
// Previous definition conflicted with decoder definition.
// Should move shared defines to hardware\mpgcodec\generic\mpgcodec.h"
//
//#include "library\hardware\mpegdec\generic\mpegdec.h"

#endif // MPEGENC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\osd\generic\osddefs.h ===
// FILE:			library\hardware\osd\generic\osddefs.h
// AUTHOR:		D.Heidrich
// COPYRIGHT:	(c) 1999 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		24.08.99
//
// PURPOSE:		General definitions for OSD.
//
// HISTORY:

#ifndef OSDDEFS_H
#define OSDDEFS_H

#include "library\common\prelude.h"
#include "library\common\hooks.h"
#include "library\hardware\video\generic\vidtypes.h"



struct OSDStandardChangeMsg {
	VideoStandard newStandard;
	};

MKHOOK(OSDStandardChange, OSDStandardChangeMsg);

typedef OSDStandardChangeHook *OSDStandardChangeHookPtr;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\panel\specific\futabavfd01.h ===
// FILE:			library\hardware\panel\specific\futabavfd01.h
// AUTHOR:		H.Horak
// COPYRIGHT:	(c) 1999 VIONA Development GmbH & Co. KG.  All Rights Reserved.
// CREATED:		13.08.1999
//
// PURPOSE:		Futaba VFD #1 segment position definitions
//
// HISTORY:

#ifndef FUTABA01VFD_H
#define FUTABA01VFD_H

// LAST_SEGMENT is used to determin VFD array size
#define LAST_SEGMENT 139
#define DISPLAY_SIZE 1+(LAST_SEGMENT>>3)	// Size of BYTE array

// VFD segment position in bitfield
#define SEG_DTS			3
#define SEG_ZOOM			4
#define SEG_5_1CH			5
#define SEG_PBC			6
#define SEG_LAST			7
#define SEG_INDEX			8
#define SEG_DIGITAL		40
#define SEG_DOLBY			41
#define SEG_ANGLE			64
#define SEG_REMAIN		65
#define SEG_TRACK			80
#define SEG_CHAPTER		88
#define SEG_B				89
#define SEG_A_TO			90
#define SEG_CHANNEL		104
#define SEG_TITLE			112
#define SEG_REPEAT		113
#define SEG_REPEAT_1		114	// belongs to repeat for repeat once
#define SEG_MICROPHONE	126
#define SEG_CUSTOM_0		127
#define SEG_CUSTOM_1		128
#define SEG_CUSTOM_2		129
#define SEG_PAUSE			130
#define SEG_PLAY			131
#define SEG_CD				132
#define SEG_VCD			133
#define SEG_DVD			134
#define SEG_SUPER			135	// belongs to VCD for SVCD
#define SEG_LOCKED		136
#define SEG_L				137
#define SEG_R				138
#define SEG_SLASH			139	// This is LAST_SEGMENT

#define SEG_PIE_OUTLINE	121
#define SEG_PIE_POS_0	122
#define SEG_PIE_POS_1	123
#define SEG_PIE_POS_2	124
#define SEG_PIE_POS_3	125

//  a
// b c
//  d
// e f
//  g

#define SEG_MINUTE_SEPERATOR	32
#define SEG_HOUR_SEPERATOR 	56

#define SEG7_0_a	9
#define SEG7_0_b	11
#define SEG7_0_c	10
#define SEG7_0_d	12
#define SEG7_0_e	14
#define SEG7_0_f	13
#define SEG7_0_g	15

#define SEG7_1_a	33
#define SEG7_1_b	35
#define SEG7_1_c	34
#define SEG7_1_d	36
#define SEG7_1_e	38
#define SEG7_1_f	37
#define SEG7_1_g	39

#define SEG7_2_a	25
#define SEG7_2_b	27
#define SEG7_2_c	26
#define SEG7_2_d	28
#define SEG7_2_e	30
#define SEG7_2_f	29
#define SEG7_2_g	31

#define SEG7_3_a	57
#define SEG7_3_b	59
#define SEG7_3_c	58
#define SEG7_3_d	60
#define SEG7_3_e	62
#define SEG7_3_f	61
#define SEG7_3_g	63

#define SEG7_4_a	49
#define SEG7_4_b	51
#define SEG7_4_c	50
#define SEG7_4_d	52
#define SEG7_4_e	54
#define SEG7_4_f	53
#define SEG7_4_g	55

#define SEG7_5_a	81
#define SEG7_5_b	83
#define SEG7_5_c	82
#define SEG7_5_d	84
#define SEG7_5_e	86
#define SEG7_5_f	85
#define SEG7_5_g	87

#define SEG7_6_a	73
#define SEG7_6_b	75
#define SEG7_6_c	74
#define SEG7_6_d	76
#define SEG7_6_e	78
#define SEG7_6_f	77
#define SEG7_6_g	79

#define SEG7_7_a	105
#define SEG7_7_b	107
#define SEG7_7_c	106
#define SEG7_7_d	108
#define SEG7_7_e	110
#define SEG7_7_f	109
#define SEG7_7_g	111

#define SEG7_8_a	97
#define SEG7_8_b	99
#define SEG7_8_c	98
#define SEG7_8_d	100
#define SEG7_8_e	102
#define SEG7_8_f	101
#define SEG7_8_g	103

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\panel\specific\PioneerCMKSP3X.h ===
// FILE:			library\hardware\panel\specific\pioneer.h
// AUTHOR:		M Spinnenweber
// COPYRIGHT:	(c) 2000 RAVISENT TECHNOLOGIES.  All Rights Reserved.
// CREATED:		FEB.22.2000
//
// PURPOSE:		Pioneer Front Panel CMKS-P3X
//
// HISTORY:
//
//


#ifndef PIONEERCMKSP3X_H
#define PIONEERCMKSP3X_H




#include "..\generic\panels.h"
#include "library\common\VDDEBUG.h"
#include "library\common\krnlsync.h"
#include "library\lowlevel\memmpdio.h"
#include "embedded\library\generic\cemsg.h"




// This section defines in general a generic panel object. These are the symbols and routines which are
// common to all front panel objects. This code could be merged into panel.h and panel.cpp if desired
// by Viona.


#define PANEL_SEGMENT_ALL                 0xFFFF
#define PANEL_SEGMENT_NONE                0x0000

#define PANEL_SEGMENT_5_1CH               1
#define PANEL_SEGMENT_L                   2
#define PANEL_SEGMENT_R                   3
#define PANEL_SEGEMNT_SLASH               4
#define PANEL_SEGMENT_LOCKED              5
#define PANEL_SEGMENT_ZOOM                6
#define PANEL_SEGMENT_LAST                7
#define PANEL_SEGMENT_PBC                 8
#define PANEL_SEGMENT_REPEAT              9
#define PANEL_SEGMENT_A_TO                10
#define PANEL_SEGMENT_B                   11
#define PANEL_SEGMENT_MINUTE_SEPERATOR    12
#define PANEL_SEGMENT_HOUR_SEPERATOR      13
#define PANEL_SEGMENT_REMAIN              14
#define PANEL_SEGMENT_SINGLE              15
#define PANEL_SEGMENT_TRACK               16
#define PANEL_SEGMENT_CHAPTER             17
#define PANEL_SEGMENT_CHANNEL             18
#define PANEL_SEGMENT_TITLE               19
#define PANEL_SEGMENT_ANGLE               20
#define PANEL_SEGMENT_DVD                 21
#define PANEL_SEGMENT_VCD                 22
#define PANEL_SEGMENT_CD                  23
#define PANEL_SEGMENT_SUPER               24
#define PANEL_SEGMENT_DOLBY_DIGITAL       25
#define PANEL_SEGMENT_DTS                 26
#define PANEL_SEGMENT_PLAY                27
#define PANEL_SEGMENT_PAUSE               28
#define PANEL_SEGMENT_SLASH               29
#define PANEL_SEGMENT_CONDITION				30
#define PANEL_SEGMENT_LAST_MEMO				31
#define PANEL_SEGMENT_TOTAL					32
#define PANEL_SEGMENT_96KHZ					33
#define PANEL_SEGMENT_DOT_LEFT				34
#define PANEL_SEGMENT_DOT_RIGHT			   35
#define PANEL_SEGMENT_COLON					36
#define PANEL_SEGMENT_GUI						37
#define PANEL_SEGMENT_LED                 38


#define PANEL_FIELD_JUSTIFICATION_LEFT    0
#define PANEL_FIELD_JUSTIFICATION_RIGHT   1
#define PANEL_FIELD_JUSTIFICATION_CENTER  2


#define PANEL_FIELD_NONE                  0x00
#define PANEL_FIELD_CHAPTER               0x01
#define PANEL_FIELD_TITLE                 0x02
#define PANEL_FIELD_TRACK                 0x04
#define PANEL_FIELD_TIME                  0x08
#define PANEL_FIELD_ANGLE                 0x10


class GenericPanel 
   { 

   protected:

      BYTE           displaySize;
      BOOL           power;
      DWORD          fieldsLocked;
      DWORD          fieldsBeingEdited;
      DWORD          fieldsEnabled;
      WORD           editValue;

		PanelNumType   testNumType;



   protected:

                   GenericPanel           ( BYTE displaySize );
                  ~GenericPanel           ( void );

     virtual void  ClearDisplay           ( void )=0;
     virtual void  EnableSegment          ( WORD segmentId )=0;
     virtual void  DisableSegment         ( WORD segmentId )=0;
     virtual void  Write                  ( BYTE position, BYTE data )=0;



             void  WriteDigit             ( BYTE position, BYTE data );
             void  WriteNumberField       ( DWORD number, BYTE fieldPosition, BYTE fieldSize, BYTE fieldJustification, BOOL removeLeadingZeros );
             void  WriteStringField       ( char* data, BYTE fieldPosition, BYTE fieldSize, BYTE fieldJustification );
             void  SetField               ( BYTE fieldPposition, BYTE fieldSize, BYTE data );
             void  WriteTestNumber        ( int number );
             void  WriteTestResult        ( BOOL result );
             void  SetPower               ( void );


    virtual  void  LockField              ( DWORD field );
             void  UnlockField            ( DWORD field );
             BOOL  FieldLocked            ( DWORD field );

             void  EnableField            ( DWORD field );
             void  DisableField           ( DWORD field );
             BOOL  FieldEnabled           ( DWORD field );


    virtual  void  BeginEditField         ( DWORD field );
             void  EndEditField           ( DWORD field );
             BOOL  FieldBeingEdited       ( DWORD field );
         
     
   };




// Pioneer CMKSP3X specific code


// This will include diagnostic code for testing the front panel. This code will run during the execution 
// of the constructor. The front panel will execute a reset, a display all segments, and wait for 1 second.
// Next it will start the couting test. This test will count up from 0 each 1/10 of a second to verify no 
// loss of communications to the front panel. Pressing any key will advance to the panel/remote button 
// test. Each remote button / panel button press will be displayed as it's name on the front panel. Press
// power to exit this test. The next test is the segment light test. Each panel button/ remote button press
// will cause a different LED or playback segment to light, one at a time. Press Power to exit this test
// and resume the player.
// 
//#define  PIONEER_FRONT_PANEL_DIAGNOSTICS  1
#undef   PIONEER_FRONT_PANEL_DIAGNOSTICS


#define GNR_PIONEER_FRONT_PANEL_LT1_ERROR                  MKERR(ERROR, FRONTPANEL, HARDWARE, 0x01)
#define GNR_PIONEER_FRONT_PANEL_XRDY_ERROR                 MKERR(ERROR, FRONTPANEL, HARDWARE, 0x02)
#define GNR_PIONEER_FRONT_PANEL_CHECKSUM_ERROR             MKERR(ERROR, FRONTPANEL, HARDWARE, 0x03)
#define GNR_PIONEER_FRONT_PANEL_UNKNOWN_PACKET_TYPE_ERROR  MKERR(ERROR, FRONTPANEL, HARDWARE, 0x04)

#define PIONEER_FRONT_PANEL_XRDY_MAXTIME                                         1250    // 1250 = 80ms  =(1250 * 64EXP-6)seconds

#define PIONEER_FRONT_PANEL_SEND_PACKET_MAX_RETRIES                              5


#define PIONEER_FRONT_PANEL_BUFFER_SIZE			                                 64		  // size of the PanelOperations (POP) array
#define PIONEER_FRONT_PANEL_POLLING_INTERVAL                                     20000   // 20000us = 20ms


#define PIONEER_FRONT_PANEL_PACKET_SIZE								                  16
#define PIONEER_FRONT_PANEL_PACKET_REGISTER_BASE_ADDRESS			                  0x80

#define PIONEER_FRONT_PANEL_MYCHIP_EMI_BASE_ADDRESS                              0x60000000
#define PIONEER_FRONT_PANEL_MYCHIP_EMI_SIZE                                      0x1000


#define PIONEER_FRONT_PANEL_INTERRUPT_MASK_REGISTER							         0x03      
#define PIONEER_FRONT_PANEL_PIN_FUNCTION_REGISTER								         0x70
#define PIONEER_FRONT_PANEL_PORTA_DIRECTION_REGISTER							         0x71
#define PIONEER_FRONT_PANEL_PORTB_DIRECTION_REGISTER							         0x72
#define PIONEER_FRONT_PANEL_PORTC_DIRECTION_REGISTER						            0x73
#define PIONEER_FRONT_PANEL_PORTA_DATA_REGISTER 								         0x74
#define PIONEER_FRONT_PANEL_PORTB_DATA_REGISTER									         0x75
#define PIONEER_FRONT_PANEL_PORTC_DATA_REGISTER							               0x76
#define PIONEER_FRONT_PANEL_CH0_AUTO_TRANSMISSION_MODE_CONTROL_REGISTER1         0xa0
#define PIONEER_FRONT_PANEL_CH0_AUTO_TRANSMISSION_MODE_CONTROL_REGISTER2         0xa1
#define PIONEER_FRONT_PANEL_CH0_AUTO_TRANSMISSION_LENGTH_REGISTER 		         0xa3
#define PIONEER_FRONT_PANEL_CH0_AUTO_TRANSMISSION_CLOCK_REGISTER	               0xa4
#define PIONEER_FRONT_PANEL_AUTO_TRANSMISSION_INTERVAL_REGISTER                  0xa5
#define PIONEER_FRONT_PANEL_CLOCK_PRESCALER_REGISTER										0xa8 
#define PIONEER_FRONT_PANEL_CH0_INTERRUPT_CONTROL_REGISTER							   0xa9
#define PIONEER_FRONT_PANEL_CH0_COMMAND_REGISTER					                  0xaa
#define PIONEER_FRONT_PANEL_CH2_COMMAND_REGISTER                                 0xac

#define PIONEER_FRONT_PANEL_LT1_BIT_MASK	   						                  0x02
#define PIONEER_FRONT_PANEL_XRDY_BIT_MASK                                        0x01

#define PIONEER_FRONT_PANEL_VERSION5                                             0x05
#define PIONEER_FRONT_PANEL_VERSION14                                            0x14

#define PIONEER_FRONT_PANEL_PACKET_TYPE_COMMAND                                  0x02
#define PIONEER_FRONT_PANEL_PACKET_TYPE_SEGMENT                                  0x03

#define PIONEER_FRONT_PANEL_PACKET_TYPE_FRONT_PANEL_BUTTON                       0x01
#define PIONEER_FRONT_PANEL_PACKET_TYPE_DVD_REMOTE                               0xa3
#define PIONEER_FRONT_PANEL_PACKET_TYPE_NO_KEY_INPUT				                  0xff
#define PIONEER_FRONT_PANEL_PACKET_TYPE_LASERDISC_REMOTE			                  0xa8


#define PIONEER_FRONT_PANEL_PACKET_VERSION_OFFSET                                0x0e
#define PIONEER_FRONT_PANEL_PACKET_KEY_DATA0_OFFSET                              0x00
#define PIONEER_FRONT_PANEL_PACKET_KEY_DATA1_OFFSET                              0x01
#define PIONEER_FRONT_PANEL_PACKET_KEY_DATA2_OFFSET                              0x02
#define PIONEER_FRONT_PANEL_PACKET_KEY_DATA3_OFFSET                              0x03


#define PIONEER_FRONT_PANEL_KEYCODE_VERSION5_OPEN_CLOSE                          0x01
#define PIONEER_FRONT_PANEL_KEYCODE_VERSION5_REVERSE				                  0x11
#define PIONEER_FRONT_PANEL_KEYCODE_VERSION5_FORWARD                             0x10
#define PIONEER_FRONT_PANEL_KEYCODE_VERSION5_STOP                                0x12
#define PIONEER_FRONT_PANEL_KEYCODE_VERSION5_PAUSE                               0x13
#define PIONEER_FRONT_PANEL_KEYCODE_VERSION5_PLAY                                0x00
#define PIONEER_FRONT_PANEL_KEYCODE_VERSION5_POWER                               0x06
#define PIONEER_FRONT_PANEL_KEYCODE_VERSION5_VNR                                 0x20

#define PIONEER_FRONT_PANEL_KEYCODE_VERSION14_OPEN_CLOSE                         0x01
#define PIONEER_FRONT_PANEL_KEYCODE_VERSION14_REVERSE				                  0x13
#define PIONEER_FRONT_PANEL_KEYCODE_VERSION14_FORWARD                            0x12
#define PIONEER_FRONT_PANEL_KEYCODE_VERSION14_STOP                               0x11
#define PIONEER_FRONT_PANEL_KEYCODE_VERSION14_PAUSE                              0x10
#define PIONEER_FRONT_PANEL_KEYCODE_VERSION14_PLAY                               0x00
#define PIONEER_FRONT_PANEL_KEYCODE_VERSION14_POWER                              0x06
#define PIONEER_FRONT_PANEL_KEYCODE_VERSION14_VNR                                0x20

#define PIONEER_FRONT_PANEL_REMOTE_POWER								                  0xbc
#define PIONEER_FRONT_PANEL_REMOTE_OPEN_CLOSE						                  0xb6

#define PIONEER_FRONT_PANEL_REMOTE_SELECT_UP                                     0xf2
#define PIONEER_FRONT_PANEL_REMOTE_SELECT_LEFT                                   0x63
#define PIONEER_FRONT_PANEL_REMOTE_SELECT_RIGHT                                  0x64
#define PIONEER_FRONT_PANEL_REMOTE_SELECT_DOWN                                   0xf3
#define PIONEER_FRONT_PANEL_REMOTE_SELECT                                        0xef

#define PIONEER_FRONT_PANEL_REMOTE_DISPLAY                                       0xe3
#define PIONEER_FRONT_PANEL_REMOTE_SETUP                                         0xb0
#define PIONEER_FRONT_PANEL_REMOTE_MENU                                          0xb9

#define PIONEER_FRONT_PANEL_REMOTE_SKIP_REVERSE                                  0x9d
#define PIONEER_FRONT_PANEL_REMOTE_SKIP_FORWARD                                  0x9c
#define PIONEER_FRONT_PANEL_REMOTE_SCAN_REVERSE                                  0x9b
#define PIONEER_FRONT_PANEL_REMOTE_SCAN_FORWARD                                  0x9a
#define PIONEER_FRONT_PANEL_REMOTE_STILLFRAME_REVERSE                            0xb8
#define PIONEER_FRONT_PANEL_REMOTE_STILLFRAME_FORWARD                            0xb7

#define PIONEER_FRONT_PANEL_REMOTE_AUDIO                                         0xbe
#define PIONEER_FRONT_PANEL_REMOTE_SUBTITLE                                      0x36
#define PIONEER_FRONT_PANEL_REMOTE_ANGLE                                         0xb5
#define PIONEER_FRONT_PANEL_REMOTE_RETURN                                        0xf4
#define PIONEER_FRONT_PANEL_REMOTE_PLAY                                          0x9e
#define PIONEER_FRONT_PANEL_REMOTE_STOP                                          0x98
#define PIONEER_FRONT_PANEL_REMOTE_PAUSE                                         0x9f
#define PIONEER_FRONT_PANEL_REMOTE_SEARCH_MODE                                   0xb3
#define PIONEER_FRONT_PANEL_REMOTE_CLEAR                                         0xe5
#define PIONEER_FRONT_PANEL_REMOTE_PROGRAM                                       0xec
#define PIONEER_FRONT_PANEL_REMOTE_RANDOM                                        0xfe
#define PIONEER_FRONT_PANEL_REMOTE_REPEAT                                        0xe4
#define PIONEER_FRONT_PANEL_REMOTE_AB                                            0xe8

#define PIONEER_FRONT_PANEL_REMOTE_1                                             0xa1
#define PIONEER_FRONT_PANEL_REMOTE_2									                  0xa2
#define PIONEER_FRONT_PANEL_REMOTE_3                                             0xa3
#define PIONEER_FRONT_PANEL_REMOTE_4                                             0xa4
#define PIONEER_FRONT_PANEL_REMOTE_5                                             0xa5
#define PIONEER_FRONT_PANEL_REMOTE_6                                             0xa6
#define PIONEER_FRONT_PANEL_REMOTE_7                                             0xa7
#define PIONEER_FRONT_PANEL_REMOTE_8                                             0xa8
#define PIONEER_FRONT_PANEL_REMOTE_9                                             0xa9
#define PIONEER_FRONT_PANEL_REMOTE_0                                             0xa0
#define PIONEER_FRONT_PANEL_REMOTE_PLUS10                                        0xbf

#define PIONEER_FRONT_PANEL_REMOTE_CONDITION_MEMORY                              0xb1
#define PIONEER_FRONT_PANEL_REMOTE_LASTMEMORY                                    0xf6
#define PIONEER_FRONT_PANEL_REMOTE_VNR                                           0x30
#define PIONEER_FRONT_PANEL_REMOTE_TOP_MENU							                  0xb4

#define PIONEER_FRONT_PANEL_COMMAND_DISPLAY                                      0x20
#define PIONEER_FRONT_PANEL_COMMAND_ENABLE_DISPLAY_ALL                           0x01
#define PIONEER_FRONT_PANEL_COMMAND_ENABLE_RESET_ON_ERROR                        0x03
#define PIONEER_FRONT_PANEL_COMMAND_DISABLE_DISPLAY_ALL                          0x06
#define PIONEER_FRONT_PANEL_COMMAND_DISABLE_TESTMODE                             0x0f
#define PIONEER_FRONT_PANEL_COMMAND_POWER_OFF                                    0x10
#define PIONEER_FRONT_PANEL_COMMAND_RESET_REQUEST                                0x12
#define PIONEER_FRONT_PANEL_COMMAND_ENABLE_TESTMODE                              0x14
#define PIONEER_FRONT_PANEL_COMMAND_DISABLE_RESET_ON_ERROR                       0x15

#define PIONEERFRONTPANEL_COMPLETIONCODE_BUTTONPRESSED                           0x01
#define PIONEERFRONTPANEL_COMPLETIONCODE_DVDREMOTEPRESSED                        0xa3
#define PIONEERFRONTPANEL_COMPLETIONCODE_LASERDISCREMOTEPRESSED                  0xa8
#define PIONEERFRONTPANEL_COMPLETIONCODE_NOCOMMAND                               0xff

#define PIONEER_FRONT_PANEL_SEGMENT_CONDITION						                  0x0001
#define PIONEER_FRONT_PANEL_SEGMENT_LAST_MEMO						                  0x0002
#define PIONEER_FRONT_PANEL_SEGMENT_ANGLE								                  0x0004
#define PIONEER_FRONT_PANEL_SEGMENT_TITLE								                  0x0008
#define PIONEER_FRONT_PANEL_SEGMENT_TOTAL								                  0x0010
#define PIONEER_FRONT_PANEL_SEGMENT_REMAIN							                  0x0020
#define PIONEER_FRONT_PANEL_SEGMENT_DOLBY_DIGITAL					                  0x0040
#define PIONEER_FRONT_PANEL_SEGMENT_96KHZ								                  0x0080
#define PIONEER_FRONT_PANEL_SEGMENT_CHPTRK   						                  0x0100
#define PIONEER_FRONT_PANEL_SEGMENT_DOT_LEFT							                  0x0200
#define PIONEER_FRONT_PANEL_SEGMENT_DOT_RIGHT						                  0x0400
#define PIONEER_FRONT_PANEL_SEGMENT_COLON								                  0x0800
#define PIONEER_FRONT_PANEL_SEGMENT_GUI							                     0x1000
#define PIONEER_FRONT_PANEL_SEGMENT_LED                                          0x2000

#define PIONEER_FRONT_PANEL_DISPLAY_SIZE			                                 10      // ten character display

#define PIONEER_FRONT_PANEL_TITLE_FIELD_POSITION                                 1
#define PIONEER_FRONT_PANEL_TITLE_FIELD_WIDTH                                    2

#define PIONEER_FRONT_PANEL_TIME_FIELD_POSITION                                  6
#define PIONEER_FRONT_PANEL_TIME_FIELD_WIDTH                                     5

#define PIONEER_FRONT_PANEL_CHAPTER_FIELD_POSITION                               4
#define PIONEER_FRONT_PANEL_CHAPTER_FIELD_WIDTH                                  2

#define PIONEER_FRONT_PANEL_TRACK_FIELD_POSITION                                 4
#define PIONEER_FRONT_PANEL_TRACK_FIELD_WIDTH                                    2

#define PIONEER_FRONT_PANEL_ANGLE_FIELD_POSITION                                 6
#define PIONEER_FRONT_PANEL_ANGLE_FIELD_WIDTH                                    5


#define PIONEER_FRONT_PANEL_TRAY_STATUS_FIELD_POSITION                           1
#define PIONEER_FRONT_PANEL_TRAY_STATUS_FIELD_WIDTH                              10

#define PIONEER_FRONT_PANEL_TIME_FIELD_POSITION                                  6
#define PIONEER_FRONT_PANEL_TIME_FIELD_WIDTH                                     5

#define PIONEER_FRONT_PANEL_MINUTE_FIELD_POSITION                                6
#define PIONEER_FRONT_PANEL_MINUTE_FIELD_WIDTH                                   3

#define PIONEER_FRONT_PANEL_SECOND_FIELD_POSITION                                9
#define PIONEER_FRONT_PANEL_SECOND_FIELD_WIDTH                                   2

#define PIONEER_FRONT_PANEL_POLLING_STATE_UPDATE_SEGMENTS                        0
#define PIONEER_FRONT_PANEL_POLLING_STATE_UPDATE_CHARACTERS                      1


#define PIONEER_FRONT_PANEL_ANGLE_FIELD_DISPLAY_TIME                             5000    // milsec = 5sec


class PioneerFrontPanel : public GenericPanel, public PollingPanel
	{
	private:
      MemoryMappedIO       mychip;

      BYTE                 packet[PIONEER_FRONT_PANEL_PACKET_SIZE];

      WORD                 segmentBuffer;
      BYTE                 characterBuffer[PIONEER_FRONT_PANEL_DISPLAY_SIZE];
 
      BYTE                 pollingState;
      BOOL                 initialized;

      BOOL                 segmentUpdateRequired;
      BOOL                 displayUpdateRequired;
      BOOL                 testMode;

      DWORD                fieldLockFlags;

      PanelDiskType        diskType;
      PanelAudioType       audioType;


      PanelState           prePanelState;
      PanelState           panelState;
      PanelTrayStatus      trayStatus;

      DWORD                angleTimer;

      BYTE                 editPos;
      PanelTimeMode        timeMode;
      int                  time;
      int                  title;
      int                  numOfTitles;
      int                  chapter;
      int                  numOfChapters;
      int                  angle;
      int                  numOfAngles;



	protected:

           BOOL     PollCEMessage         ( DWORD &ceMsg );
           void     ExecuteOperation      ( POP pop );

           void     InitializeMychip      ( void );

           void     ExecuteCommand        ( BYTE command );
           void     Reset                 ( void );
           void     EnableDisplayAll      ( void );				
			  void     DisableDisplayAll     ( void );
           void     EnableResetOnError    ( void );
           void     DisableResetOnError   ( void );
           void     EnableTestMode        ( void );
           void     DisableTestMode       ( void );
			  BYTE     CalculateChecksum     ( void );
           void     MakePacket            ( BYTE type, BYTE command, BYTE data1, BYTE data2, BYTE data3, BYTE data4, BYTE data5, BYTE data6, BYTE data7, BYTE data8, BYTE data9, BYTE data10, BYTE data11, BYTE data12, BYTE data13 );
           DWORD    TranslateRemote       ( BYTE code );
           DWORD    TranslateButton       ( BYTE version, BYTE code );
           DWORD    ProcessReturnPacket   ( DWORD* message, BOOL* messageReceived );
           DWORD    SendPacket            ( DWORD* message, BOOL* messageReceived );
           DWORD    UpdateSegments        ( DWORD* message, BOOL* messageReceived );
           DWORD    UpdateCharacters      ( DWORD* message, BOOL* messageReceived );
  
           void     EnableSegment         ( WORD segmentId );
           void     DisableSegment        ( WORD segmentId );
           void     ClearDisplay          ( void );

           void     SetTitle              ( void );
           void     ClearTitleField       ( void );

           void     SetChapter            ( void );
           void     ClearChapterField     ( void );

           void     SetTrack              ( void );
           void     ClearTrackField       ( void );

           void     SetTime               ( void );
           void     ClearTimeField        ( void );

           void     SetAngle              ( void );
           void     ClearAngleField       ( void );

           void     BeginEditField        ( DWORD field );
           void     EditWriteDigit        ( BYTE position, BYTE number );


           void     PowerOff              ( void );

           void     LockField             ( DWORD field );

           void     SetTrayStatus         ( PanelTrayStatus trayStatus );

           void     Write                 ( BYTE position, BYTE data );

           void     SetDiskType           (void);
           void     SetAudioType          (void);
           void     SetPanelState         (void);



#ifdef PIONEER_FRONT_PANEL_DIAGNOSTICS
           void     ShiftCharactersLeft   ( void );
           void     WriteScrollingMessage ( char* string, DWORD shiftDelay );
           void     Diagnostics           ( void );
#endif


	public:
                    PioneerFrontPanel ( int taskPriority );
                   ~PioneerFrontPanel ( void );
      POPList       GetInitPOPList    ( int __far & size );
      VirtualUnit*  CreateVirtual     ( void );
      void          SetSystemPower    ( BOOL on );

         

	};


class VirtualPioneerFrontPanel : public VirtualPanel
	{
	public:
		VirtualPioneerFrontPanel(PioneerFrontPanel* panel) : VirtualPanel(panel) {;}
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\osd\generic\osd.h ===
#ifndef OSD_H
#define OSD_H

#include "library\common\prelude.h"
#include "library\common\virtunit.h"
#include "library\common\tags.h"
#include "library\common\tagunits.h"

MKTAG(OSD_ENABLE,						OSD_UNIT,	0x00000001, 	BOOL)
MKTAG(OSD_VISIBLE,					OSD_UNIT,	0x00000002,		BOOL)

MKTAG(OSD_LEFT,						OSD_UNIT,	0x00000003,		WORD)
MKTAG(OSD_TOP,							OSD_UNIT,	0x00000004,		WORD)
MKTAG(OSD_WIDTH,						OSD_UNIT,	0x00000005,		WORD)
MKTAG(OSD_HEIGHT,						OSD_UNIT,	0x00000006,		WORD)

MKTAG(OSD_PALETTE_ENTRY,			OSD_UNIT,	0x00000007,		DWORD)
	// Palette Bits 0..7 Pen, 8..15 V, 16..23 U, 24..31 Y
	
MKTAG(OSD_DISPLAY_WIDTH,			OSD_UNIT, 0x00000008,		WORD)
MKTAG(OSD_DISPLAY_HEIGHT,			OSD_UNIT,	0x00000009,		WORD)

enum OSDCommand
	{
	OSDC_NONE,
	OSDC_FILL,
	OSDC_COPY,
	OSDC_XOR,
	OSDC_EXPAND,
	OSDC_UPDATE
	};

class OnScreenDisplay : public PhysicalUnit
	{
	friend class VirtualOnScreenDisplay;
	protected:
		virtual Error EnableOSD(BOOL enable) = 0;
		virtual Error ShowOSD(BOOL show) = 0;
		virtual Error SetPaletteEntry(int entry, WORD y, WORD u, WORD v) = 0;
		virtual Error UpdateRegion(WORD left, WORD top, WORD width, WORD height, FPTR data, WORD stride) = 0;
		virtual Error ClearDisplay(void) = 0;
		
		virtual WORD DisplayWidth(void) = 0;
		virtual WORD DisplayHeight(void) = 0;
	};

class VirtualOnScreenDisplay : public VirtualUnit
	{
	protected:
		OnScreenDisplay	*	device;
		
		WORD	left, top, width, height;
		WORD	stride;
		BYTE	__far *	map;
		BOOL	enable, visible;
		DWORD	palette[16];

      Error PreemptStopPrevious(VirtualUnit * previous);
      Error PreemptChange(VirtualUnit * previous);
      Error PreemptStartNew(VirtualUnit * previous);		
	public:
		VirtualOnScreenDisplay(OnScreenDisplay * device);
		~VirtualOnScreenDisplay(void);
		
		Error ExecuteCommand(OSDCommand com, WORD color, WORD x, WORD y, WORD w, WORD h, FPTR data, WORD dstride);
		
		Error Configure(TAG __far * tags);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\panel\generic\panels.h ===
// FILE:			library\hardware\panel\generic\panels.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1999 VIONA Development GmbH & Co. KG.  All Rights Reserved.
// CREATED:		02.08.1999
//
// PURPOSE:		Generic User Interface Panel Class
//
// HISTORY:

#ifndef PANELS_H
#define PANELS_H

#include "library\common\virtunit.h"
#include "library\common\tagunits.h"
#include "library\common\hooks.h"
#include "library\common\krnlsync.h"

// Panel Operations data type

#define MKPOPTYPE(name, id) \
	static const DWORD POPTYPEID_##name = id & 0xffff; 

struct __far POP {
	DWORD	id;
	DWORD	data;
	POP (DWORD _id, DWORD _data) { data = _data; id = _id; };
	POP () {}
#if !__EDG__  || __EDG_VERSION__ < 240
	~POP () {}  // Mainly workaround for a memory leak bug in the C++ frontend compiler (1.6.2 toolset).
#endif
	};

typedef POP * POPList;

#define POPDONE POP(0,0)

#define POP_SET	0x1000
#define POP_GET	0x2000
#define POP_QRY	0x4000

#define MKPOP(name, id, type)	\
	inline POP SET_POP_##name(type x) {return POP((id << 16) | POPTYPEID_##type | POP_SET, (DWORD)(x));}	\
	inline POP GET_POP_##name(type __far &x) {return POP((id << 16) | POPTYPEID_##type | POP_GET, (DWORD)(&x));}	\
	inline POP QRY_POP_##name(BOOL __far &x) {return POP((id << 16) | POPTYPEID_##type | POP_QRY, (DWORD)(&x));}	\
	inline POP INI_POP_##name(type x) {return POP((id << 16) | POPTYPEID_##type, (DWORD)(x));} \
	inline type VAL_POP_##name(POP pop) {return (type)(pop.data);}	\
	static const DWORD ID_POP_##name = id;

#define EXECUTE_POP_START \
	switch (pop.id >> 16) {

#define EXECUTE_POP_END }


// Panel specific data types

enum PanelSegment
	{
	PSG_NONE,
	PSG_SET,
	PSG_CLR,
	PSG_STEP
	};

enum PanelNumType
	{
	PNUM_NONE,
	PNUM_DEC,
	PNUM_DEC_SIMPLE_LEFT,
	PNUM_HEX,
	PNUM_HEX_SIMPLE_LEFT,
	PNUM_BIN
	};

enum PanelNumericInfo
	{
	PNI_NONE					= 0,
	PNI_TIME					= 1,
	PNI_ANGLE				= 2,
	PNI_TITLE				= 4,
	PNI_CHAPTER				= 8,
	PNI_NUM_ANGLES			= 16,
	PNI_NUM_TITLES			= 32,
	PNI_NUM_CHAPTERS		= 64,
	PNI_PBC_ENTRY			= 128,
	PNI_PBC_NUM_ENTRIES	= 256
	};

enum PanelDiskType
	{
	PDT_NONE,
	PDT_VIDEO_DVD,
	PDT_AUDIO_DVD,
	PDT_VIDEO_CD,
	PDT_AUDIO_CD,
	PDT_SUPER_VIDEO_CD,
	PDT_SUPER_AUDIO_CD
	};

enum PanelAudioType
	{
	PAT_NONE,
	PAT_AC3,
	PAT_MPEG1,
	PAT_MPEG2,
	PAT_LPCM,
	PAT_DTS,
	PAT_SDDS,
	PAT_PROLOGIC,
	PAT_SRS
	};

enum PanelState
	{
	PST_STOPPED,
	PST_PAUSED,
	PST_STILL,
	PST_PLAYING,
	PST_BUSY,
	PST_INIT,
	PST_SCANNING_FORWARD_FAST,
	PST_SCANNING_FORWARD_SMOOTH,
	PST_SCANNING_BACKWARD_FAST,
	PST_SCANNING_BACKWARD_SMOOTH,
	PST_INACTIVE,
	PST_REVERSEPLAY,
	PST_TRICKPLAY,
	PST_REVERSESCAN,
	PST_STOPPED_FOR_RESUME
	};

enum PanelTimeMode
	{
	PTM_INACTIVE,
	PTM_TOTAL,
	PTM_TOTAL_ELAPSED,
	PTM_TOTAL_REMAIN,
	PTM_SINGLE_ELAPSED,
	PTM_SINGLE_REMAIN,
	PTM_SINGLE
	};

enum PanelTrayStatus
	{
	PTS_UNKNOWN,
	PTS_INSERTED,
	PTS_REMOVED,
	PTS_INSERTING,
	PTS_REMOVING
	};

// General type defs

typedef char * STRING8;		// String with max. size of 8 characters
typedef DWORD	SEGMENT4;	// 4 segments, each one byte of the DWORD. MSB is first segment from the left.
typedef DWORD	TIME;			// Time representation
typedef DWORD	DUMMY; 		// Dummy type if not parameter is used

// Panel Operation data types
MKPOPTYPE(int,					0x01)
MKPOPTYPE(char,	 			0x02)
MKPOPTYPE(BYTE,				0x03)
MKPOPTYPE(WORD,				0x04)
MKPOPTYPE(DWORD,				0x05)
MKPOPTYPE(BOOL,				0x06)
MKPOPTYPE(DUMMY,				0x07)
MKPOPTYPE(TIME,				0x08)
MKPOPTYPE(STRING8,			0x09)
MKPOPTYPE(SEGMENT4,			0x0a)
MKPOPTYPE(PanelSegment,		0x0b)
MKPOPTYPE(PanelNumType,		0x0c)
MKPOPTYPE(PanelNumericInfo,0x0d)
MKPOPTYPE(PanelDiskType, 	0x0e)
MKPOPTYPE(PanelAudioType,	0x0f)
MKPOPTYPE(PanelState,		0x10)
MKPOPTYPE(PanelTimeMode,	0x11)
MKPOPTYPE(PanelTrayStatus, 0x12)

// Definition of Panel Operations
MKPOP(TEST_SEGMENTS,			0x0,		PanelSegment)
MKPOP(TEST_NUMBER_TYPE,		0x1,		PanelNumType)
MKPOP(TEST_NUMBER,			0x2,		int)
MKPOP(TEST_RESULT,			0x3,		BOOL)

MKPOP(RESET,		 			0x010,	DUMMY)

MKPOP(POWER,					0x020,	BOOL)

MKPOP(BRIGHTNESS,				0x030,	DWORD)

MKPOP(ENABLE_PIE, 	 		0x040,	BOOL)

MKPOP(ENABLE,					0x048,	PanelNumericInfo)
MKPOP(DISABLE,					0x049,	PanelNumericInfo)
MKPOP(EDIT_ENTER,				0x04a,	PanelNumericInfo)
MKPOP(EDIT_LEAVE,	 			0x04b,	PanelNumericInfo)
MKPOP(EDIT_WRITE_DIGIT,		0x04c,	int)
MKPOP(EDIT_WRITE_CHAR,		0x04d,	char)
MKPOP(EDIT_WRITE_STRING, 	0x04e,	STRING8)

MKPOP(DISK_TYPE,	 			0x050,	PanelDiskType)
MKPOP(REGION,					0x051,	DWORD)

MKPOP(AUDIO_TYPE,	 			0x060,	PanelAudioType)

MKPOP(PANEL_STATE,			0x070,	PanelState)

MKPOP(TRAY,						0x080,	PanelTrayStatus)

MKPOP(TIME_MODE,		  	  	0x090,	PanelTimeMode)
MKPOP(TIME,				  	  	0x092,	DWORD)

MKPOP(TITLE,					0x100,	int)
MKPOP(NUM_TITLES,				0x101,	int)
MKPOP(CHAPTER,					0x102,	int)
MKPOP(NUM_CHAPTERS,	 		0x103,	int)
MKPOP(ANGLE,					0x104,	int)
MKPOP(NUM_ANGLES,				0x105,	int)
MKPOP(PBC_ENTRY,				0x106,	int)
MKPOP(PBC_NUM_ENTRIES, 		0x107,	int)

MKPOP(AUDIO_CHANNELS,  		0x110,	int)

MKPOP(SPEED,			  		0x121,	int)

MKPOP(LOCKED, 					0x130,	BOOL)
MKPOP(ZOOM, 					0x131,	int)
MKPOP(LAST, 					0x132,	int)
MKPOP(PLAYBACK_CONTROL,		0x133,	BOOL)

MKPOP(REPEAT, 					0x140,	BOOL)
MKPOP(REPEAT_START,			0x141,	BOOL)
MKPOP(REPEAT_END,				0x142,	BOOL)

MKPOP(ADVANCE_FRAME_BY,		0x150,	BOOL)

//....



// Definition of keyboard input hook

struct PanelKeyboardMsg { 
	DWORD		ceMsg;
	};

MKHOOK(PanelKeyboard,   PanelKeyboardMsg)

typedef PanelKeyboardHook	__far *	PanelKeyboardHookPtr;


// Tags for Panel Classes

MKTAG(PANEL_KEYBOARD_HOOK, PANEL_UNIT, 0x0001, PanelKeyboardHookPtr)

//...



#ifndef ONLY_EXTERNAL_VISIBLE

class Panel : public PhysicalUnit {
	friend class VirtualPanel;
	private:
		POPList CreatePOPListFromPtr(int __far & size, POP __far * pops);
	protected:
		Error SignalKeyHook(DWORD ceMsg);
		POPList CreatePOPList(int __far & size, POP pop, ...);
	public:
		virtual POPList GetInitPOPList(int __far & size) = 0;
		
		virtual Error StartQueueOperations(void) = 0;
		virtual Error QueueOperation(POP * pop) = 0;
		virtual Error EndQueueOperations(DWORD __far &tag) = 0;

		virtual Error FlushOperations(void) = 0;

		virtual Error CompleteOperations(DWORD tag) = 0;
		virtual BOOL  OperationsPending(DWORD tag) = 0;
	};


class VirtualPanel : public VirtualUnit {
	friend class Panel;
	private:
		Panel			*	panel;
	protected:
		POPList			popList;
		int				plSize;		// Number of elements in list for faster search

		PanelKeyboardHookHandle	keyHook;

		Error Preempt(VirtualUnit * previous);
	public:
		VirtualPanel(Panel * panel);
		virtual ~VirtualPanel(void);

		Error Configure(TAG __far * tags);

		virtual Error DoOperations(POP __far * pops);
		Error __cdecl DoOperationsOps(POP pop, ...);
		virtual Error SendOperations(DWORD __far &tag, POP __far * pops);
		Error __cdecl SendOperationsOps(DWORD __far &tag, POP pop, ...);
		virtual Error CompleteOperations(DWORD tag);
		virtual BOOL  OperationsPending(DWORD tag);
	};


class PollingPanel : public Panel {
	private:
		BOOL	endTask;
		DWORD	bufferSize;
		DWORD	pollInterval;
		DWORD	lastOp;
		DWORD	curOp;
		DWORD preCeMsg, failedCeMsg;
		POPList * opBuff;
		friend void PollingPanel_HandlerTask(void *panel);
		virtual void PanelTaskProcedure(void);
		
		VDTimedSemaphore	taskSema;
		VDSemaphore			completeSema;

		task_t *	panelTask;	// This ST specific stuff could be avoided by creating a 
									// KernelTask class!
		clock_t nextTime;
	protected:
		virtual void ExecuteOperation(POP pop) = 0;
		virtual BOOL PollCEMessage(DWORD & ceMsg) {return FALSE;}
	public:
		PollingPanel(DWORD bufferSize, DWORD pollInterval, int taskPriority, DWORD stackSize = 4*1000);	// pollInterval in us
		virtual ~PollingPanel(void);

		Error StartQueueOperations(void);
		Error QueueOperation(POP * pop);
		Error EndQueueOperations(DWORD __far &tag);

		Error FlushOperations(void);

		Error CompleteOperations(DWORD tag);
		BOOL  OperationsPending(DWORD tag);
	};


#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\panel\specific\vestel12fp01.h ===
// FILE:			library\hardware\panel\specific\vestel12fp01.h
// AUTHOR:		H.Horak, S. Herr
// COPYRIGHT:	(c) 1999 VIONA Development GmbH & Co. KG.  All Rights Reserved.
// CREATED:		04.08.1999
//
// PURPOSE:		Vestel Front Panel 12FP01
//
// HISTORY:

#ifndef VESTEL12FP01_H
#define VESTEL12FP01_H

#include "futabavfd01.h"
#include "..\generic\panels.h"
#include "library\lowlevel\hardwrio.h"
#include "library\common\krnlsync.h"

class Vestel12FP01Panel : public PollingPanel, public VDMutex 
	{
	private:
		ByteIndexedInOutPort * port;
		BYTE display[DISPLAY_SIZE];
		BYTE preDisplay[DISPLAY_SIZE];
		PanelNumType testNumType;
		PanelDiskType diskType;
		PanelAudioType audioType;
		PanelState panelState, prePanelState;
		PanelTrayStatus trayStatus, preTrayStatus;
		PanelTimeMode timeMode;

		int panelNumericInfo, panelNumericEdit, panelNumericUsed;
		int editPos;
		int displayAngleTime, playerSpeed;
		int preBrightness, brightness;
		int time, angle, title, chapter, pbcEntry, pbcEntries, numOfAngles, numOfTitles, numOfChapters;
		int refCountRepeat;
		int region;
		BOOL enPBC, enPie, power, testMode;
		BYTE	ledAdr;

		void SetPower();
		void ReadKey(BYTE * data);
		void ClrDisplayArray();
		void SetDisplayArray();	// For debugging and testing
		void UpdateDisplay();
		void StepSegment();		// For debugging
		void SetBrightness();

		void SetbitsNumerical(int digit, int value, BYTE *array);
		void ClrTimeDisplay(BYTE *array);
		void ClrTitleDisplay(BYTE *array);
		void ClrChapterDisplay(BYTE *array);
		void ClrNumDisplay(BYTE *array);

		BOOL LockNumDisplay(PanelNumericInfo lock);
		void FreeNumDisplay(PanelNumericInfo free);

		void SetTestResult(BOOL result);

		void SetDiskType();
		void SetAudioType();
		void SetPanelState();
		void SetTrayStatus();

		void SetTime();
		void SetTitle();
		void SetChapter();
		void SetPBCEntry();
		void SetPBCEntries();

		void EditTime();
		void EditTitle();
		void EditChapter();
		void EditPBCEntry();
		void EditAngle();

		void AngleTimer();
		void SetAngle();

		void SetAudioChannels(int channel);

		void WriteSegment(int seg, BOOL state);
		void WriteDigit(int number, int pos);
		void WriteTestNumber (int number);
		void WriteTitle(int number, BOOL enable);
		void WriteChannel(int number, BOOL enable);
		void WriteChapter(int number, BOOL enable);
		void WriteTrack(int number, BOOL enable);
		void WriteNumOfEntries(int number, BOOL enable);
		
		void UpdateActiveSymbols();
		void DeletePie(BYTE *array);
		void EmptyPie(BYTE *array);
		void FullPie(BYTE *array);
		void CrossedPie(BYTE *array);
		void RotatePie(int speed, int roteate, BYTE *array);
		void FlashPie(int speed, BYTE *array);
		void FlashPlaySymbol(int speed, BYTE *array);


	protected:
		void ExecuteOperation(POP pop);
		BOOL PollCEMessage(DWORD & ceMsg);

	public:
		Vestel12FP01Panel(int taskPriority, ByteIndexedInOutPort * port, BOOL powerLEDOn = FALSE);

		POPList GetInitPOPList(int __far & size);

		VirtualUnit * CreateVirtual(void);

		void SetSystemPower(BOOL on);
	};

class VirtualVestel12FP01Panel : public VirtualPanel
	{
	public:
		VirtualVestel12FP01Panel(Vestel12FP01Panel * panel) : VirtualPanel(panel) {;}
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\pcibrdge\specific\amcc\Copyport.h ===
#ifndef COPYPORT_H
#define COPYPORT_H

#include "library\common\prelude.h"


extern "C"
	{
#if NT_KERNEL
	void __stdcall CopyFromInPort(WORD pollport, WORD dataport, FPTR p, WORD dsize);
	void __stdcall CopyToOutPort(WORD pollport, WORD dataport, FPTR p, WORD dsize, WORD rest);

	void __stdcall CopyBytesFromInPort(WORD dataport, FPTR p, DWORD bytesize);
	void __stdcall CopyBytesToOutPort(WORD dataport, FPTR p, DWORD bytesize);
#else
	void FAR PASCAL CopyFromInPort (WORD pollport, WORD dataport, FPTR p, WORD dsize);
	void FAR PASCAL CopyToOutPort (WORD pollport, WORD dataport, FPTR p, WORD dsize, WORD rest);

	void FAR PASCAL CopyBytesFromInPort (WORD dataport, FPTR p, DWORD bytesize);
	void FAR PASCAL CopyBytesToOutPort  (WORD dataport, FPTR p, DWORD bytesize);
#endif
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\panel\specific\vestel3button.h ===
// FILE:			library\hardware\panel\specific\vestel3button.h
// AUTHOR:		M Spinnenweber
// COPYRIGHT:	(c) 2000 RAVISENT TECHNOLOGIES.  All Rights Reserved.
// CREATED:		APR.18.2000
//
// PURPOSE:		Vestel 3 Button Panel
//
// HISTORY:
//


#ifndef VESTEL3BUTTONPANEL_H
#define VESTEL3BUTTONPANEL_H


#include "..\generic\panels.h"
#include "library\common\VDDEBUG.h"
#include "library\hardware\uproc\specific\st55xx\cpu5505.h"
#include "embedded\library\generic\cemsg.h"


#define VESTEL3BUTTON_PANEL_BUFFER_SIZE			                                 64		  // size of the stack
#define VESTEL3BUTTON_PANEL_POLLING_INTERVAL                                     100000  // 20000us = 100ms

#define VESTEL3BUTTON_PANEL_DEBOUNCE_TIME                                        2       // Time in polling intervals


class Vestel3ButtonPanel : public PollingPanel
	{
	private:
      GPIOBitInputPort*    switch1;
      GPIOBitInputPort*    switch2;
      GPIOBitInputPort*    switch3;

      BOOL                 initialized;

      DWORD                switch1DebounceTimeRemaining;
      DWORD                switch2DebounceTimeRemaining;
      DWORD                switch3DebounceTimeRemaining;

	protected:

           BOOL     PollCEMessage         ( DWORD &ceMsg );

	public:
                    Vestel3ButtonPanel ( int taskPriority, GPIOBitInputPort* pswitch1,GPIOBitInputPort* pswitch2,GPIOBitInputPort* pswitch3 );
                   ~Vestel3ButtonPanel ( void );
      POPList       GetInitPOPList     ( int __far & size );
      void          ExecuteOperation   (POP pop);


      VirtualUnit*  CreateVirtual      ( void );
      void          SetSystemPower     ( BOOL on );
   

	};


class VirtualVestel3ButtonPanel : public VirtualPanel
	{
	public:
		VirtualVestel3ButtonPanel(Vestel3ButtonPanel* panel) : VirtualPanel(panel) {;}
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\pcibrdge\specific\amcc\COPYPORT.ASM ===
TITLE   copyport.ASM


; copyport.asm - Copy DWORD data from an input port and to an output port.


?PLM=1          ; PASCAL Calling convention is DEFAULT
?WIN=0          ; Windows calling convention
?386regs=1 

.xlist
include cmacros.new
.list


;---------------------------------------;
;       Segment Declarations            ;
;---------------------------------------;

ifndef  SEGNAME
	SEGNAME equ <_TEXT32>
endif

createSeg %SEGNAME, CodeSeg, dword, public, CODE

sBegin  CodeSeg
	assumes cs,CodeSeg
	assumes ds,Data
	assumes es,nothing


	ALIGN 2

.486





;-----------------------------------------------------------------------;
; void FAR PASCAL CopyFromInPort (WORD pollport, WORD dataport,
;                                 LPSTR p, WORD dsize);

cProc   CopyFromInPort,<FAR, PASCAL, PUBLIC>,< edi >
	parmW  pollport
	parmW  dataport
	parmD  p          ; destination
	parmW  dsize      ; number of DWORDs to copy

cBegin
		; Load destination pointer.
		cld
		xor     edi, edi
		les     di, p

		; Calculate number of 16 byte blocks.
		mov     bx, dsize
		shr     bx, 2
		jz      noRead4   ; if less than 16 bytes

		; Copy data in portions of 4 DWORDs.
		xor     ecx, ecx
loopRead4:
		mov     dx, pollport
		mov     cx, 4
pollRead4:
		in      al, dx
		and     al, 16
		jz      pollRead4
		mov     dx, dataport
		rep insd es:[edi], dx
		dec     bx
		jnz     loopRead4

		; How many DWORDs remain ?
noRead4:
		mov     bx, dsize
		and     bx, 3
		jz      endRead4   ; if no remaining DWORDs

		; Copy DWORD data.
loopRead:
		mov     dx, pollport
pollRead:
		in      al, dx
		and     al, 32
		jnz     pollRead
		mov     dx, dataport
		insd    es:[edi], dx
		dec     bx
		jnz     loopRead

endRead4:

		cEnd CopyFromInPort





;-----------------------------------------------------------------------;
; void FAR PASCAL CopyToOutPort (WORD pollport, WORD dataport,
;                                LPSTR p, WORD dsize, WORD rest);

cProc   CopyToOutPort,<FAR, PASCAL, PUBLIC>,< esi >
	parmW  pollport
	parmW  dataport
	parmD  p          ; source
	parmW  dsize      ; number of DWORDs to copy
	parmW  rest

cBegin
		push    ds

		; Load source pointer.
		cld
		xor     esi, esi
		lds     si, p

		; Calculate number of 16 byte blocks.
		mov     bx, dsize
		shr     bx, 2
		jz      noWrite4   ; if less than 16 bytes

		; Copy data in portions of 4 DWORDs.
		xor     ecx, ecx
loopWrite4:
		mov     dx, pollport
		mov     cx, 4
pollWrite4:
		in      al, dx
		and     al, 2
		jz      pollWrite4
		mov     dx, dataport
		rep outsd dx, ds:[esi]
		dec     bx
		jnz     loopWrite4

		; How many DWORDs remain ?
noWrite4:
		mov     bx, dsize
		and     bx, 3
		jz      endWrite4   ; if no remaining DWORDs

		; Copy DWORD data.
loopWrite:
		mov     dx, pollport
pollWrite:
		in      al, dx
		and     al, 2
		jz      pollWrite
		mov     dx, dataport
		outsd   dx, ds:[esi]
		dec     bx
		jnz     loopWrite

endWrite4:
		mov     bx, rest
		or      bx, bx
		jz      endWrite5
loopWrite5:
		lodsb   ds:[esi]
		mov     cl, 8
		ror     eax, cl
		dec     bx
		jnz     loopWrite5

		mov     bx, 4
		sub     bx, rest
		add     bx, bx
		add     bx, bx
		add     bx, bx
		mov     cl, bl
		ror     eax, cl

		mov     dx, pollport
		push    eax
pollWrite5:
		in      al, dx
		and     al, 2
		jz      pollWrite5
		pop     eax
		mov     dx, dataport
		out     dx, eax

endWrite5:
		pop     ds

		cEnd CopyToOutPort





;-----------------------------------------------------------------------;
; void FAR PASCAL CopyBytesFromInPort (WORD dataport, LPSTR p, DWORD bytesize);

cProc   CopyBytesFromInPort,<FAR, PASCAL, PUBLIC>,< edi >
	parmW  dataport
	parmD  p          ; destination
	parmD  bytesize   ; number of bytes to copy

cBegin
		push    es

		; Load source pointer.
		cld
		xor     edi, edi
		les     di, p
		mov     dx, dataport

		; Copy whole words.
		mov     ecx, bytesize
		shr     ecx, 1
		jz      noRead2   ; if less than 2 bytes
		rep  insw es:[edi], dx

		; How many bytes remain ?
noRead2:
		mov     ecx, bytesize
		and     cx, 1
		jz      endRead2   ; if no remaining bytes

		; Copy one additional byte.
		in      ax, dx
		stosb   es:[edi]   ; store al

endRead2:
		pop     es

		cEnd CopyBytesFromInPort





;-----------------------------------------------------------------------;
; void FAR PASCAL CopyBytesToOutPort (WORD dataport, LPSTR p, DWORD bytesize);

cProc   CopyBytesToOutPort,<FAR, PASCAL, PUBLIC>,< esi >
	parmW  dataport
	parmD  p          ; source
	parmD  bytesize   ; number of bytes to copy

cBegin
		push    ds

		; Load source pointer.
		cld
		xor     esi, esi
		lds     si, p
		mov     dx, dataport

		; Copy whole words.
		mov     ecx, bytesize
		shr     ecx, 1
		jz      noWrite2   ; if less than 2 bytes
		rep  outsw dx, ds:[esi]

		; How many bytes remain ?
noWrite2:
		mov     ecx, bytesize
		and     cx, 1
		jz      endWrite2   ; if no remaining bytes

		; Copy one additional byte.
		lodsb   ds:[esi]   ; loaded to al
		xor     ah, ah
		out     dx, ax

endWrite2:
		pop     ds

		cEnd CopyBytesToOutPort





sEnd CodeSeg

end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\panel\specific\vfd2041.h ===
// FILE:      vfd2041.h
// AUTHOR:    H.Horak
// COPYRIGHT: (c) 1998 VIONA Development GmbH.  All Rights Reserved.
// CREATED:   29.09.98
//
// PURPOSE:   
//
// HISTORY:

#ifndef VFD2041_H
#define VFD2041_H

#include "library\lowlevel\hwbusio.h"
#include "library\common\gnerrors.h"
#include "library\common\krnlsync.h"



#define VFD2041_I2C_ADDRESS  0x5c



class VFD2041
	{
	private:
		AsyncByteInOutBus *port;
		VDMutex monitorMutex;
		BOOL	enablePanel;
		
	public:
		VFD2041 (AsyncByteInOutBus *port);
		virtual ~VFD2041 (void);

		Error Initialize (void);

		Error PanelWrite (char * str, int row, int column);

		Error PanelButton (char * str);

		Error PanelPlaybackSpeed (int speed);

		Error PanelBitRate (int kiloBits);

		Error PanelChapter(int chapter);

		Error PanelAudioBits(int bitsPerSample);

		Error PanelAudioSamples(int samplesPerSecond);

		Error PanelAudioChannels(int channels);

		Error PanelTime (int hours, int minutes, int seconds);

		Error VFD2041::PanelClr (void);

	};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\pcibrdge\specific\amcc\S5933.h ===
// FILE:      library\hardware\pcibrdge\specific\amcc\s5933.h
// AUTHOR:    D. Heidrich
// COPYRIGHT: (c) 1996 VIONA Development GmbH. All Rights Reserved.
// CREATED:   29.01.96
//
// PURPOSE:   Abstraction for AMCC S5933 PCI controller.
//
// HISTORY:

#ifndef S5933_H
#define S5933_H

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"
#include "library\lowlevel\intrctrl.h"
#include "library\lowlevel\dmachanl.h"



class S5933;



class S5933DMAChannel : public DMAChannel
	{
	friend class S5933;

	protected:
		S5933 *amcc;
		BOOL writeChannel;
		DWORD physicalAddress;
		DWORD start, transferSize;

		virtual Error InitTransfer (DMABuffer *buffer, DWORD start, DWORD size);
		void FinishTransfer (void);

		virtual Error StartTransfer (void);
		virtual Error StopTransfer (void);

		virtual Error EndTransfer (void);

	public:
		S5933DMAChannel (S5933 *amcc, BOOL writeChannel);
		virtual ~S5933DMAChannel (void);

		virtual long GetTransferLocation (void);
		virtual void SetTransferLocation (long pos);
	};



// Interrupt server for AMCC interrupts.

class S5933IntServer : public InterruptServer
	{
	private:
		BYTE enableMask;   // bit in the interrupt control register
		BYTE checkMask;
		S5933 *amcc;

	protected:
		Error EnableInt (void);
		Error DisableInt (void);

	public:
		S5933IntServer (S5933 *amcc, BYTE enableMask, BYTE checkMask)
			{this->amcc = amcc; this->enableMask = enableMask; this->checkMask = checkMask;}

		Error SwitchOn (void) {return EnableInt ();}
		Error SwitchOff (void) {return DisableInt ();}

		BOOL IsActive (BYTE intReg) {return (intReg & checkMask) != 0;}
	};



class S5933
	{
	friend class S5933IntServer;
	friend class S5933DMAChannel;

	protected:
		WORD base;
		WORD cntBase;
		BOOL writeBurst, readBurst;

		BYTE intReg;
		BOOL readTransferRunning, writeTransferRunning;

		S5933IntServer *dmaReadIRQ;
		S5933IntServer *dmaWriteIRQ;

		Error StartWriteDMA (DWORD physicalAddress, DWORD size);
		Error StartReadDMA (DWORD physicalAddress, DWORD size);

		Error FinishWriteDMA (void);
		Error FinishReadDMA (void);

	public:
		S5933IntServer *jpegIRQ;

		S5933DMAChannel *dmaReadChannel;
		S5933DMAChannel *dmaWriteChannel;

		S5933 (WORD basePort, WORD counterBasePort, BOOL writeDMABurst, BOOL readDMABurst)
			{
			base = basePort;
			cntBase = counterBasePort;
			writeBurst = writeDMABurst;
			readBurst  = readDMABurst;
			writeTransferRunning = FALSE;
			readTransferRunning = FALSE;
			}

		virtual Error Build (void);

		BOOL CheckInterrupt (void);
		virtual void Interrupt (void);   // called in ISR

		Error WriteData (FPTR data, DWORD size, WORD counterOffset);
		Error ReadData (FPTR data, DWORD size, WORD counterOffset);   // size must be multiple of four
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\pcibrdge\specific\bt848\BT848.h ===
// FILE:      library\hardware\pcibridge\specific\bt848\bt848.h
// AUTHOR:    Viona
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   05.12.95
//
// PURPOSE:   
//
// HISTORY:

#ifndef BT848_H
#define BT848_H

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"

#ifndef ONLY_EXTERNAL_VISIBLE

#include "library\lowlevel\memmpdio.h"
#include "library\lowlevel\i2c.h"  
#include "library\lowlevel\intrctrl.h"
#include "library\lowlevel\dmachanl.h" 

#endif

//#include "vidde848.h"

#ifndef ONLY_EXTERNAL_VISIBLE
#include "bt848reg.h"
#endif

#define	GNR_ILLEGAL_DMA_BUFFER_SIZE	MKERR(ERROR, DMA, PARAMS, 0x010)
	// The size of the dma buffer was not in the supported range

#ifndef ONLY_EXTERNAL_VISIBLE

class BT848 {
	protected:           
		BitInOutPort			*	sda;
		BitInOutPort			*	scl;
		DWORD						intStatus;        
		int						chipRevision;
	public:
		//
		// Memory area of the ASRs
		//
		MemoryMappedIO			*	mem;
		
		//
		// I2C bus supported by the BT848
		//
		I2CBus					*	i2c;
		
		//
		// General IO pins
		//
		BitIndexedInOutPort	*	genpport;
	
		//
		// Forteen on chip interrupts
		//		
      InterruptServer		*	sync_error;	
      InterruptServer		*  opcode_error;
      InterruptServer	   *	pabort;
      InterruptServer		*  data_par_err;
      InterruptServer    	*	parity_error;
      InterruptServer    	*	fifo_resync;
      InterruptServer    	*	fifo_target;
      InterruptServer    	*	fifo_overrun;
      InterruptServer    	*	irq_in_risc; 
      InterruptServer    	*	gpio_int;
      InterruptServer    	*	i2c_write_read;
      InterruptServer    	*  video_input;
      InterruptServer    	*	hlock_change;
      InterruptServer    	*	lum_chro_overfl;
      InterruptServer    	*	hsync;
      InterruptServer    	*	vsync;
      InterruptServer    	*	videoformat_chg;
        
		//
		// Shadow registers for ASR read problems
		//		
		DWORD							intShadow;
		DWORD							i2cShadow;
		
		BT848(MemoryMappedIO * mem, int chipRevision);
		~BT848(void);

		//
		// Initialize the Bt848
		//		
		virtual Error BuildPorts(void);		
		//
		// Configure the general IO pins for input or output
		//
//		virtual Error ConfigurePPort(DWORD inputs);          
		//
		//
		// To be called in the isr
		//
		virtual void Interrupt(void);
		BOOL CheckInterrupt(void);
	};
      
	//
	// Interrupt server for BT848 interrupt
	//	
class BT848IntServer : public InterruptServer {
	private:
		int		intCtrlBit;	// bit in the interrupt control registers
		BT848	*	bt848;
	protected:
		Error EnableInt(void);
		Error DisableInt(void);		
	public:
		BT848IntServer(BT848 * bt848, int intCtrlBit) {this->bt848 = bt848; this->intCtrlBit = intCtrlBit;}
	};                                                                                          

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\pcibrdge\specific\bt848\bt848reg.h ===
//
// FILE:      library\hardware\pcibridge\specific\bt848\bt848reg.h
// AUTHOR:    P.C. Straasheijm
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   9.10.96
//
// PURPOSE:   Register definitions for the bt848 chip
// 
// HISTORY:
//
//

#ifndef BT848REG_H
#define BT848REG_H                                            

#include "library\common\prelude.h"

//
//Device Status Register
//

#define BT848REG_DEVSTAT		0x00

#define BT848IDX_PRES			7
#define BT848IDX_HLOC			6
#define BT848IDX_FIELD			5
#define BT848IDX_NUML			4
#define BT848IDX_CSEL			3
#define BT848IDX_LOF          1
#define BT848IDX_COF          0
                                                       
//
//Input Format Register
//

#define BT848REG_INPUTFOR		0x04

#define BT848IDX_HACTIVE		7
#define BT848IDX_MUXSEL			5, 2
#define BT848IDX_XTSEL			3, 2
#define BT848IDX_FORMAT			0, 3


//
//Temporal Decimation Register
//
                              
                              
#define BT848REG_TEMDECR		0x08

#define BT848IDX_DEC_FIELD		7
#define BT848IDX_FLDALIGN		6
#define BT848IDX_DEC_RAT		0, 6


//
//MSB Cropping Register EVEN
//

#define BT848REG_MSB_CROPR_E	0x0C

#define BT848IDX_VDELAY_E		6, 2
#define BT848IDX_VACTIV_E		4, 2
#define BT848IDX_HDELAY_E		2, 2
#define BT848IDX_HAKTIV_E		0, 2


//
//MSB Cropping Register ODD
//

#define BT848REG_MSB_CROPR_O	0x8C

#define BT848IDX_VDELAY_O		6, 2
#define BT848IDX_VACTIV_O		4, 2
#define BT848IDX_HDELAY_O		2, 2
#define BT848IDX_HAKTIV_O		0, 2


//
//Vertical Delay Register EVEN
//

#define BT848REG_VDELAYL_E		0x10


//
//Vertical Delay Register ODD
//

#define BT848REG_VDELAYL_O		0x90


//
//Vertical Activ Register EVEN
//

#define BT848REG_VACTIVL_E		0x14


//
//Vertical Activ Register ODD
//

#define BT848REG_VACTIVL_O		0x94


//
//Horizontal Delay Register EVEN
//

#define BT848REG_HDELAYL_E		0x18


//
//Horizontal Delay Register ODD
//

#define BT848REG_HDELAYL_O		0x98


//
//Horizontal Activ Register EVEN
//

#define BT848REG_HACTIVL_E		0x1C


//
//Horizontal Activ Register ODD
//

#define BT848REG_HACTIVL_O		0x9C


//
//Horizontal Scaling Register EVEN UPPER
//

#define BT848REG_HSCALH_E		0x20


//
//Horizontal Scaling Register ODD UPPER
//

#define BT848REG_HSCALH_O		0xA0
                                  
                                  
//
//Horizontal Scaling Register EVEN LOWER
//

#define BT848REG_HSCALL_E		0x24


//
//Horizontal Scaling Register ODD LOWER
//

#define BT848REG_HSCALL_O		0xA4


//
//Brightness Control Register
//

#define BT848REG_BRCONTR		0x28


//
//Miscellaneous Control Register
//

#define BT848REG_MISCEL_O		0xAC

#define BT848IDX_LNOTCH_0		7
#define BT848IDX_COMP_O			6
#define BT848IDX_LDEC_O			5
#define BT848IDX_CBSENSE_O		4
#define BT848IDX_CON_MSB_O		2
#define BT848IDX_SAT_U_MSB_O	1
#define BT848IDX_SAT_V_MSB_O	0


#define BT848REG_MISCEL_E		0x2C

#define BT848IDX_LNOTCH_E		7
#define BT848IDX_COMP_E			6
#define BT848IDX_LDEC_E			5
#define BT848IDX_CBSENSE_E		4
#define BT848IDX_CON_MSB_E		2
#define BT848IDX_SAT_U_MSB_E	1
#define BT848IDX_SAT_V_MSB_E	0


//
//Luma Gain Register
//

#define BT848REG_CONTRAST_L	0x30

//
//Chroma Gain (U) Register
//

#define BT848REG_SAT_U_L      0x34

//                                
//Chroma Gain (V) Register
//

#define BT848REG_SAT_V_L		0x38

//
//HUE Control Register
//

#define BT848REG_HUE				0x3C


//
//SC Loop Control Register  EVEN
//

#define BT848REG_SCLOOP_E		0x40

#define BT848IDX_CAGC_E 		6
#define BT848IDX_CKILL_E		5
#define BT848IDX_HFILT_E		3, 2


//
//SC Loop Control Register  ODD
//

#define BT848REG_SCLOOP_O		0xC0

#define BT848IDX_CAGC_O 		6
#define BT848IDX_CKILL_O		5
#define BT848IDX_HFILT_O		3, 2


//
//Output Format Register
//


#define BT848REG_OUTFORM		0x48

#define BT848IDX_RANG			7
#define BT848IDX_CORE			5, 2

//
//Vertical Scaling Upper EVEN
//

#define BT848REG_VSCALE_HI_E	0x4C

#define BT848IDX_YCOMB_HI_E	7
#define BT848IDX_COMB_HI_E		6
#define BT848IDX_INT_HI_E		5
#define BT848IDX_VSCALE_HI_E	0, 5


//
//Vertical Scaling Upper ODD
//

#define BT848REG_VSCALE_HI_O	0xCC

#define BT848IDX_YCOMB_HI_O	7
#define BT848IDX_COMB_HI_O		6
#define BT848IDX_INT_HI_O		5
#define BT848IDX_VSCALE_HI_O	0, 5


//
//Vertical Scaling Register EVEN
//


#define BT848REG_VSCALE_LO_E	0x50


//
//Vertical Scaling Register ODD
//


#define BT848REG_VSCALE_LO_O	0xD0


//
//Test Control Register
//


#define BT848REG_TEST			0x54


//
//AGC Delay Register
//

#define BT848REG_ADELAY			0x60


//
//Burst Delay Register
//

#define BT848REG_BDELAY			0x5D


//
//ADC Interface Register
//

#define BT848REG_ADC				0x68

#define BT848IDX_SYNC_T			5
#define BT848IDX_AGC_EN			4
#define BT848IDX_CLK_SLEEP		3
#define BT848IDX_Y_SLEEP		2
#define BT848IDX_C_SLEEP		1
#define BT848IDX_CRUSH			0


//
//Video Timing Control EVEN
//

#define BT848REG_E_VTC   		0x6C

#define BT848IDX_HSFMT_E		7
#define BT848IDX_VFILT_E		0, 2


//
//Video Timing Control ODD
//

#define BT848REG_O_VTC   		0xEC

#define BT848IDX_HSFMT_O		7
#define BT848IDX_VFILT_O		0, 2


//
//Software Reset Register
//

#define BT848REG_SRESET			0x7C 
#define BT848IDX_SRESET			0


//
//Color Format Register
//

#define BT848REG_COLOR_FMT		0xD4

#define BT848IDX_COLOR_ODD		4, 4
#define BT848IDX_COLOR_EVEN	0, 0


//
// Color control register
//

#define BT848REG_COLOR_CTL		0xD8

#define BT848IDX_EXT_FRMRATE	7
#define BT848IDX_COLOR_BARS	6
#define BT848IDX_RGB_DED		5
#define BT848IDX_GAMMA			4
#define BT848IDX_WSWAP_ODD		3
#define BT848IDX_WSWAP_EVEN	2
#define BT848IDX_BSWAP_ODD		1
#define BT848IDX_BSWAP_EVEN	0


//
//Capture Control
//

#define BT848REG_CAP_CTL		0xDC

#define BT848IDX_DITH_FRAME	4
#define BT848IDX_CAP_VBI_ODD	3
#define BT848IDX_CAP_VBI_EVEN	2
#define BT848IDX_CAPTURE_ODD	1
#define BT848IDX_CAPTURE_EVEN 0


//
//VBI Packet size
//

#define BT848REG_VBI_PCK_SIZE	0xE0


//
//VBI Packet Size / DELAY
//


#define BT848REG_VBI_PCK_DEL	0xE4

#define BT848IDX_VBI_HDELAY	2, 6
#define BT848IDX_EXT_FRAME		1
#define BT848IDX_VBI_PKT_HI	0

//
//Interupt Status
//

#define BT848REG_INT_STAT		0x100

#define BT848IDX_RISCS			28, 4
#define BT848IDX_RISC_EN_I		27
#define BT848IDX_RACK			25
#define BT848IDX_FIELD_I		24
#define BT848IDX_SCERR			19
#define BT848IDX_OCERR			18
#define BT848IDX_PABORT			17
#define BT848IDX_RIPERR			16
#define BT848IDX_PPERR			15
#define BT848IDX_FDSR			14
#define BT848IDX_FTRGT			13
#define BT848IDX_FBUS			12
#define BT848IDX_RISCI			11
#define BT848IDX_GPINT			9
#define BT848IDX_I2CDONE		8
#define BT848IDX_VPRES			5
#define BT848IDX_HLOCK			4
#define BT848IDX_OFLOW			3
#define BT848IDX_HSYNC			2
#define BT848IDX_VSYNC			1
#define BT848IDX_FMTCHG			0


//
//Interupt Mask
//

#define BT848REG_INT_MASK		0x104


//
//RISC Program Counter
//

#define BT848REG_RISC_COUNT	0x120


//
//Risc Program Start Address
//

#define BT848REG_RISC_STRT_ADD	0x114


//
//GPIO and DMA Control
//


#define BT848REG_GPIO_DMA_CTL	0x10C

#define BT848IDX_GPINTC			15
#define BT848IDX_GPINTI			14
#define BT848IDX_GPWEC			13
#define BT848IDX_GPIOMODE		11, 2
#define BT848IDX_GPCLKMODE		10
#define BT848IDX_PLTP23			6, 2
#define BT848IDX_PLTP1			4, 2
#define BT848IDX_PKTP			2, 2
#define BT848IDX_RISC_EN		1
#define BT848IDX_FIFO_EN		0


//
//GPIO Output enable Control
//


#define BT848REG_GPIO_OUT_EN	0x118


//
//GPIO Registered Input Control
//


#define BT848REG_GPIO_REG_INP	0x11C


//
//GPIO Data I/O
//


#define BT848REG_GPIO_DATA		0x200  // till 0x2FF

#define GPIO_DATA_SIZE			0x100


//
//I2C Data/Control
//


#define BT848REG_I2C_DATA_CTL 0x110

#define BT848IDX_I2CCDB0		24, 8
#define BT848IDX_I2CCDB1		16, 8
#define BT848IDX_I2CCDB2		8,  8
#define BT848IDX_I2CDIV			4,  4
#define BT848IDX_I2CSYNC		3
#define BT848IDX_I2CW3B			2
#define BT848IDX_I2CSCL			1
#define BT848IDX_I2CSDA			0


//
// For YUV2RGB
//
#define BT848_YUV422				0x00
#define BT848_RGB24				0x01
#define BT848_RGB16				0x02
#define BT848_RGB15				0x03

//__________________________________________________________

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\pcibrdge\specific\i20\I20regs.h ===
//
// FILE:      library\hardware\pcibridge\specific\i20\i20regs.h
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   21.03.95
//
// PURPOSE:   Register definitions for the I20 chip
// 
// HISTORY:
//
//

#ifndef I20REGS_H
#define I20REGS_H                                            

#include "..\..\..\..\common\prelude.h"

#define I20REG_HTIMING			0x00
#define I20IDX_HSPOL				30
#define I20REG_HSPOL				I20REG_HTIMING, I20IDX_HSPOL
#define I20IDX_HSTART			10, 10
#define I20REG_HSTART			I20REG_HTIMING, I20IDX_HSTART
#define I20IDX_HEND				 0, 10
#define I20REG_HEND				I20REG_HTIMING, I20IDX_HEND     
			
#define I20REG_VTIMING			0x04
#define I20IDX_VSPOL				30
#define I20REG_VSPOL				I20REG_VTIMING, I20IDX_VSPOL
#define I20IDX_VSTART			10, 10
#define I20REG_VSTART			I20REG_VTIMING, I20IDX_VSTART
#define I20IDX_VEND				 0, 10
#define I20REG_VEND				I20REG_VTIMING, I20IDX_VEND     

//
// For VSPOL and HSPOL
//
#define I20_NEGATIVE_EDGE		TRUE
#define I20_POSITIVE_EDGE		FALSE



#define I20REG_VIDCONFIG		0x08
#define I20IDX_EXTFI				26
#define I20REG_EXTFI				I20REG_VIDCONFIG, I20IDX_EXTFI
#define I20IDX_TOPFIELD			25
#define I20REG_TOPFIELD			I20REG_VIDCONFIG, I20IDX_TOPFIELD
#define I20IDX_VCLKPOL			24
#define I20REG_VCLKPOL			I20REG_VIDCONFIG, I20IDX_VCLKPOL
#define I20IDX_HFILTER			21,  3
#define I20REG_HFILTER			I20REG_VIDCONFIG, I20IDX_HFILTER
#define I20IDX_DUPFLD			20
#define I20REG_DUPFLD			I20REG_VIDCONFIG, I20IDX_DUPFLD
#define I20IDX_HORDCM			14,  6
#define I20REG_HORDCM			I20REG_VIDCONFIG, I20IDX_HORDCM
#define I20IDX_VERDCM			 8,  6
#define I20REG_VERDCM			I20REG_VIDCONFIG, I20IDX_VERDCM
#define I20IDX_DISPMOD			 6
#define I20REG_DISPMOD			I20REG_VIDCONFIG, I20IDX_DISPMOD
#define I20IDX_YUV2RGB			 3,  2
#define I20REG_YUV2RGB			I20REG_VIDCONFIG, I20IDX_YUV2RGB
#define I20IDX_ERRDIF			 2
#define I20REG_ERRDIF			I20REG_VIDCONFIG, I20IDX_ERRDIF
#define I20IDX_PACK24			 1
#define I20REG_PACK24			I20REG_VIDCONFIG, I20IDX_PACK24
#define I20IDX_LITTLEENDIAN	 0
#define I20REG_LITTLEENDIAN	I20REG_VIDCONFIG, I20IDX_LITTLEENDIAN                      

//
// For YUV2RGB
//
#define I20_YUV422				0x00
#define I20_RGB888				0x01
#define I20_RGB565				0x02
#define I20_RGB555				0x03



#define I20REG_VIDTOPBASE		0x0c
#define I20REG_VIDBOTBASE		0x10 

#define I20REG_DISPGRAB			0x14
#define I20IDX_DISPSTRIDE		16, 16
#define I20REG_DISPSTRIDE		I20REG_DISPGRAB, I20IDX_DISPSTRIDE
#define I20IDX_VIDOVF			 8
#define I20REG_VIDOVF			I20REG_DISPGRAB, I20IDX_VIDOVF
#define I20IDX_SNAPSHOT			 1
#define I20REG_SNAPSHOT			I20REG_DISPGRAB, I20IDX_SNAPSHOT
#define I20IDX_FRAMEGRAB		 0
#define I20REG_FRAMEGRAB		I20REG_DISPGRAB, I20IDX_FRAMEGRAB

#define I20REG_VIDWIN			0x18
#define I20IDX_VIDEN				31
#define I20REG_VIDEN				I20REG_VIDWIN, I20IDX_VIDEN
#define I20IDX_MINPIX			25,  6
#define I20REG_MINPIX			I20REG_VIDWIN, I20IDX_MINPIX
#define I20IDX_TRITONFIX		24
#define I20REG_TRITONFIX		I20REG_VIDWIN, I20IDX_TRITONFIX
#define I20IDX_VIDWINHT			12, 10
#define I20REG_VIDWINHT			I20REG_VIDWIN, I20IDX_VIDWINHT
#define I20IDX_VIDWINWID		 0, 10
#define I20REG_VIDWINWID		I20REG_VIDWIN, I20IDX_VIDWINWID

#define I20REG_MASKTOPBASE		0x1c
#define I20REG_MASKBOTBASE		0x20
                                                             
#define I20REG_MASKCTRL			0x24                                                             
#define I20IDX_OVLENABLE		15
#define I20REG_OVLENABLE		I20REG_MASKCTRL, I20IDX_OVLENABLE
#define I20IDX_MASKSTRIDE		 0,  8
#define I20REG_MASKSTRIDE		I20REG_MASKCTRL, I20IDX_MASKSTRIDE

#define I20REG_SYSCTRL			0x28
#define I20IDX_SOFTRESET		24
#define I20REG_SOFTRESET		I20REG_SYSCTRL, I20IDX_SOFTRESET
#define I20IDX_WAITSTATE		16,  3
#define I20REG_WAITSTATE		I20REG_SYSCTRL, I20IDX_WAITSTATE
#define I20IDX_GENPURDIR		 0,  8
#define I20REG_GENPURDIR		I20REG_SYSCTRL, I20IDX_GENPURDIR

#define I20REG_GUESTCTRL		0x2c
#define I20IDX_GENPURIO(x,y)	(24+x),  y
#define I20REG_GENPURIO(x,y)	I20REG_GUESTCTRL, I20IDX_GENPURIO(x, y)
#define I20IDX_GENPURIOBIT(x)	(24+x)
#define I20REG_GENPURIOBIT(x)	I20REG_GUESTCTRL, I20IDX_GENPURIOBIT(x)
#define I20IDX_GUESTDUR(x)		(2+4*x), 2                 
#define I20REG_GUESTDUR(x)		I20REG_GUESTCTRL, I20IDX_GUESTDUR(x)
#define I20IDX_GUESTREC(x)		(0+4*x), 2              
#define I20REG_GUESTREC(x)		I20REG_GUESTCTRL, I20IDX_GUESTREC(x)

#define I20REG_GENPURIOALL			0x2f

//
// For GENPURIO
//

#define I20_GENP_INPUT				TRUE
#define I20_GENP_OUTPUT				FALSE

//
// For GUESTDUR
//
#define I20_DUR3CLKS				0x00
#define I20_DUR4CLKS				0x01
#define I20_DUR12CLKS			0x02
#define I20_DUR15CLKS			0x03

//
// For GUESTREC
//
#define I20_REC3CLKS				0x00
#define I20_REC4CLKS				0x01
#define I20_REC12CLKS			0x02
#define I20_REC15CLKS			0x03


#define I20REG_CODMEMBASE		0x30

#define I20REG_CODCTRL			0x34
#define I20IDX_CODTIME			30
#define I20REG_CODTIME			I20REG_CODCTRL, I20IDX_CODTIME    
#define I20IDX_CODEMPTY			29
#define I20REG_CODEMPTY			I20REG_CODCTRL, I20IDX_CODEMPTY
#define I20IDX_CODFLUSH			28                            
#define I20REG_CODFLUSH			I20REG_CODCTRL, I20IDX_CODFLUSH
#define I20IDX_CODGUESTID		20,  3
#define I20REG_CODGUESTID		I20REG_CODCTRL, I20IDX_CODGUESTID
#define I20IDX_CODGUESTREG		16,  3                           
#define I20REG_CODGUESTREG		I20REG_CODCTRL, I20IDX_CODGUESTREG
#define I20IDX_CODMEMSIZE		12,  3                            
#define I20REG_CODMEMSIZE		I20REG_CODCTRL, I20IDX_CODMEMSIZE
#define I20IDX_CODMEMSTEP		 8,  3                           
#define I20REG_CODMEMSTEP		I20REG_CODCTRL, I20IDX_CODMEMSTEP
#define I20IDX_CODREADEN		 7                               
#define I20REG_CODREADEN		I20REG_CODCTRL, I20IDX_CODREADEN
#define I20IDX_CODTRSHLD		 1,  3                          
#define I20REG_CODTRSHLD		I20REG_CODCTRL, I20IDX_CODTRSHLD
#define I20IDX_CODAUTOEN		 0                              
#define I20REG_CODAUTOEN		I20REG_CODCTRL, I20IDX_CODAUTOEN

//
// For CODMEMSIZE
//
#define I20_CODMEMSIZE8K		0x00
#define I20_CODMEMSIZE16K		0x01
#define I20_CODMEMSIZE32K		0x02
#define I20_CODMEMSIZE64K		0x03
#define I20_CODMEMSIZE128K		0x04
#define I20_CODMEMSIZE256K		0x05
                                  
//
// For CODMEMSTEP
//                                  
#define I20_CODMEMSTEP8K		0x00
#define I20_CODMEMSTEP16K		0x01
#define I20_CODMEMSTEP32K		0x02
#define I20_CODMEMSTEP64K		0x03
#define I20_CODMEMSTEP128K		0x04
#define I20_CODMEMSTEP256K		0x05


#define I20REG_CODMEMPOINT32	0x38
#define I20REG_CODMEMPOINT		0x38,  0, 16

#define I20REG_INTSTATUS		0x3c
#define I20IDX_GIRQ1				30
#define I20REG_GIRQ1				I20REG_INTSTATUS, I20IDX_GIRQ1
#define I20IDX_GIRQ0				29
#define I20REG_GIRQ0				I20REG_INTSTATUS, I20IDX_GIRQ0
#define I20IDX_CODREPIRQ		28
#define I20REG_CODREPIRQ		I20REG_INTSTATUS, I20IDX_CODREPIRQ
                                                                
#define I20REG_INTENABLE		0x40                                                                
#define I20IDX_GIRQ1EN			30
#define I20REG_GIRQ1EN			I20REG_INTENABLE, I20IDX_GIRQ1EN
#define I20IDX_GIRQ0EN			29
#define I20REG_GIRQ0EN			I20REG_INTENABLE, I20IDX_GIRQ0EN
#define I20IDX_CODREPIRQEN		28
#define I20REG_CODREPIRQEN		I20REG_INTENABLE, I20IDX_CODREPIRQEN
#define I20IDX_INTPINEN			24
#define I20REG_INTPINEN			I20REG_INTENABLE, I20IDX_INTPINEN

#define I20REG_I2C				0x44
#define I20IDX_I2CSDA			1
#define I20REG_I2CSDA			I20REG_I2C, I20IDX_I2CSDA
#define I20IDX_I2CSCL			0
#define I20REG_I2CSCL			I20REG_I2C, I20IDX_I2CSCL

#define I20REG_POSTOFFICE		0x200
#define I20IDX_POPEN				25
#define I20REG_POPEN				I20REG_POSTOFFICE, I20IDX_POPEN
#define I20IDX_POTIME			24
#define I20REG_POTIME			I20REG_POSTOFFICE, I20IDX_POTIME
#define I20IDX_PODIR				23
#define I20REG_PODIR				I20REG_POSTOFFICE, I20IDX_PODIR
#define I20IDX_POGUESTID		20,  3
#define I20REG_POGUESTID		I20REG_POSTOFFICE, I20IDX_POGUESTID
#define I20IDX_POGUESTREG		16,  3
#define I20REG_POGUESTREG		I20REG_POSTOFFICE, I20IDX_POGUESTREG
#define I20IDX_PODATA			 0,  8
#define I20REG_PODATA			I20REG_POSTOFFICE, I20IDX_PODATA

#define I20_PO_OUTPUT			HIGH
#define I20_PO_INPUT				LOW

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\pcibrdge\specific\i22\I22.H ===
// FILE:      library\hardware\pcibridge\specific\i22\i22.h
// AUTHOR:    Ulrich Sigmund, Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   15.05.95
//
// PURPOSE: The I22 chip class.
//
// HISTORY:

#ifndef I22_H
#define I22_H

#include "..\..\..\..\common\prelude.h"
#include "..\..\..\..\common\gnerrors.h"
#include "..\..\..\..\lowlevel\memmpdio.h"
#include "..\..\..\..\lowlevel\i2c.h"
#include "..\i20\i20.h"

#include "i22regs.h"



class I22 : public I20
	{
	public:
		I22 (MemoryMappedIO *mem);
		virtual ~I22 (void);

		InterruptServer *jpegCodeIRQ;

		virtual Error BuildPorts (void);
		virtual Error ConfigureGuest (int no, int dur, int rec);

		virtual void Interrupt (void);
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\pcibrdge\specific\i20\i20.h ===
// FILE:      library\hardware\pcibridge\specific\i20\i20.h
// AUTHOR:    Viona
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   05.12.95
//
// PURPOSE:   
//
// HISTORY:

#ifndef I20_H
#define I20_H

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"
#include "library\lowlevel\memmpdio.h"
#include "library\lowlevel\i2c.h"  
#include "library\lowlevel\intrctrl.h"
#include "library\lowlevel\dmachanl.h"
#include "library\common\krnlsync.h"

#include "i20regs.h"

#define	GNR_ILLEGAL_DMA_BUFFER_SIZE	MKERR(ERROR, DMA, PARAMS, 0x010)
	// The size of the dma buffer was not in the supported range

class I20 : public VDSpinLock {
	protected:           
		BitInOutPort			*	sda;
		BitInOutPort			*	scl;
		DWORD							intStatus;        
		int							chipRevision;
	public:
		//
		// Memory area of the ASRs
		//
		MemoryMappedIO			*	mem;
		
		//
		// I2C bus supported by the I20
		//
		I2CBus					*	i2c;
		
		//
		// Guest bus
		//
		ByteInOutBus			*	guestBus;

		ByteIndexedInOutPort * BuildHandshakePort(int guestID, int gpio, BOOL level);
				
		//
		// General IO pins
		//
		BitIndexedInOutPort	*	genPPort;
	
		//
		// Three on chip interrupts
		//		
		InterruptServer		*	guestIRQ0;
		InterruptServer		*	guestIRQ1;
		InterruptServer		*	codRepIRQ;

		//
		// Code DMA channel		
		//
		CircularDMAChannel	*	codeDMA;

		//
		// Shadow registers for ASR read problems
		//		
		DWORD							intShadow;
		DWORD							i2cShadow;
		
		I20(MemoryMappedIO * mem, int chipRevision);
		~I20(void);

		//
		// Initialize the I20
		//		
		virtual Error BuildPorts(void);		

		// Reinitialization function (e.g. after power down)
		virtual Error ReInitialize(void);

		//
		// Configure the general IO pins for input or output
		//
		virtual Error ConfigurePPort(BYTE inputs);          
		//
		// Configure guest timing
		//
		virtual Error ConfigureGuest(int no, int dur, int rec);
		//
		// Configure code dma
		//
		virtual Error ConfigureCodeDMA(int no, int reg, int trshld);
		
		//
		// To be called in the isr
		//
		virtual void Interrupt(void);
		InterruptServeType CheckInterrupt(void);
	};
      
	//
	// Interrupt server for I20 interrupt
	//	
class I20IntServer : public InterruptServer {
	private:
		int		intCtrlBit;	// bit in the interrupt control registers
		I20	*	i20;
	protected:
		Error EnableInt(void);
		Error DisableInt(void);		
	public:
		I20IntServer(I20 * i20, int intCtrlBit) {this->i20 = i20; this->intCtrlBit = intCtrlBit;}
	};                                                                                          

BOOL CheckI20BoardAccess(DWORD physical);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\pcibrdge\specific\i22\FRAGTAB.H ===
// FILE:      library\hardware\pcibridge\specific\i22\fragtab.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   12.05.95
//
// PURPOSE: The fragment table class.
//
// HISTORY:

#ifndef FRAGTAB_H
#define FRAGTAB_H

#include "..\..\..\..\common\prelude.h"
#include "..\..\..\..\lowlevel\dmabuffr.h"



class FragmentTableClass : public ContinuousDMABuffer
	{
	private:
		ScatteredDMABuffer *scatter;
		FPTR lockedBuffer;
		BOOL allocated;

	public:
		FragmentTableClass (void);
		~FragmentTableClass (void);

		Error CreateFragmentBuffer (FPTR buffer, DWORD size);
		Error DeleteFragmentBuffer (void);

		Error GetBufferPointer (FPTR __far &buffer, DWORD __far &size)
			{ return scatter->GetBuffer (buffer, size); }

		Error GetFragmentTablePtr (DWORD __far * __far &fragTable)
			{
			FPTR fptr;
			DWORD size;
			Error err = GetBuffer (fptr, size);
			fragTable = (DWORD __far *)fptr;
			return err;
			}

		void GetFragmentInfo (DWORD __far * __far &fragTable, DWORD __far &physical,
		                      DWORD __far &byteSize, BOOL __far &finalFragment)
			{
			physical = *fragTable++;
			byteSize = *fragTable++;
			finalFragment = (byteSize & 1) != 0;
			byteSize = (byteSize << 1) & ~3;
			}
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\pcibrdge\specific\bt848\Framlist.h ===
// FILE:      library\hardware\pcibridge\specific\bt848\Framlist.h
// AUTHOR:    P.C.Straasheijm
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   14.10.95
//
// PURPOSE: The PIP-related classes.
//
// Discription: This is a PIP related class for DMA-chip, such as BT848 who works with a
//				risc programm


#ifndef FRAMELIST_H
#define FRAMELIST_H


#include "library\general\flists.h" 
#include "library\common\gnerrors.h"

class __far RISC_Instruction: public FNode {
	 public:
		int 			left;
		int 			width;
		
		RISC_Instruction(int start = 0, int size = 0);
		
		RISC_Instruction  * Prede(void);
		RISC_Instruction  * Succe(void);		
	 };


class __far Linelist : public FList
	 {
	
	  public:
	  
	  	int 				left, width;
	  	RISC_Instruction	* startlist;
	  	Linelist (int x, int width);
	  	~Linelist(void);
	  	Error Add_Line (int l, int w);
	  	Error Rem_Line (int l, int w);
	 };
	 

class __far FrameList {

   
   public:
   
	int						left, top;		// screen coordinates
	int 						width, height;
	Linelist  		__far	*(__far *lines_array);
	
	FrameList (int x, int y, int height, int width);
	~FrameList(void);
	
	Error Initialize(void);          
	
	void AddRect(int x, int y, int w, int h);

	void RemRect(int x, int y, int w, int h);

};                                           
	          
	          
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\pcibrdge\specific\PLX9054\p9054reg.h ===
//
// FILE:      library\hardware\pcibrdge\specific\plx9054\p9054reg.h
// AUTHOR:    Martin Stephan
// COPYRIGHT: (c) 1999 VIONA Development GmbH.  All Rights Reserved.
// CREATED:   23.11.1999
//
// PURPOSE:   PLX 9054 register specific definitions --- interface
//
// HISTORY:
//

#ifndef P9054REG_H
#define P9054REG_H

////////////////////////////////////////////
// PCI CONFIGURATION REGISTERS				//
////////////////////////////////////////////
// Definitions for the PLX Configuration space registers.
// All bits numbers are starting from 0.
#define PLX9054_PCI_CONFIGURATION_ID			0x00
#define PLX9054_PCI_VENDOR_ID						0x00
#define PLX9054_PCI_DEVICE_ID						0x02
#define PLX9054_PCI_COMMAND						0x04
#define PLX9054_PCI_STATUS							0x06
#define PLX9054_PCI_REVISION_ID					0x08
#define PLX9054_PCI_CLASS_CODE					0x09
#define PLX9054_PCI_CACHE_LINE_SIZE				0x0C
#define PLX9054_PCI_BUS_LATENCY_TIMER			0x0D
#define PLX9054_PCI_HEADER_TYPE					0x0E
#define PLX9054_PCI_BUILT_IN_SELF_TEST			0x0F
#define PLX9054_PCI_BASE_ADDRESS_0				0x10
#define PLX9054_PCI_BASE_ADDRESS_1				0x14
#define PLX9054_PCI_BASE_ADDRESS_2				0x18
#define PLX9054_PCI_BASE_ADDRESS_3				0x1C
#define PLX9054_PCI_BASE_ADDRESS_4				0x20
#define PLX9054_PCI_BASE_ADDRESS_5				0x24
#define PLX9054_PCI_CRD_BUS_CIS_POINTER		0x28
#define PLX9054_PCI_SUBSYSTEM_VENDOR_ID		0x2C					// Subsystem ID
#define SUBSYSTEM_ID_SHIFT								16					// Subsystem Vendor ID
#define PLX9054_PCI_SUBSYSTEM_DEVICE_ID		0x2E
#define PLX9054_PCI_EXPANSION_ROM_BASE			0x30
#define PLX9054_PCI_NEW_CAPABILITY_POINTER	0x34
#define PLX9054_PCI_INTERRUPT_LINE				0x3C
#define PLX9054_PCI_INTERRUPT_PIN				0x3D
#define PLX9054_PCI_MIN_GRANT						0x3E
#define PLX9054_PCI_MAX_LATENCY					0x3F
#define PLX9054_PCI_POWER_MANAGEMENT_CAPABILITY_ID					0x40
#define PLX9054_PCI_POWER_MANAGEMENT_NEXT_CAPABILITY_POINTER	0x41
#define PLX9054_PCI_POWER_MANAGEMENT_CAPABILITIES					0x42
#define PLX9054_PCI_POWER_MANAGEMENT_CONTROL_STATUS				0x44
#define PLX9054_PCI_BRIDGE_SUPPORT_EXTENSIONS						0x46
#define PLX9054_PCI_POWER_MANAGEMENT_DATA								0x47
#define PLX9054_PCI_HOT_SWAP_CONTROL									0x48
#define HOT_SWAP_LED																0x00080000
#define PLX9054_PCI_HOT_SWAP_NEXT_CAPABILITY_POINTER				0x49
#define PLX9054_PCI_HOT_SWAP_CONTROL_STATUS							0x4A
#define PLX9054_IDX_LED_ON_OFF												3
#define PLX9054_PCI_VITAL_PRODUCT_DATA_CONTROL						0x4C
#define VPD_ADDRESS_SHIFT														16
#define VPD_ADDRESS																0x7FFF0000
#define VPD_FLAG																	0x80000000
#define PLX9054_PCI_VITAL_PRODUCT_DATA_NEXT_CAPABILITY_POINTER	0x4D
#define PLX9054_PCI_VITAL_PRODUCT_DATA_ADRESS						0x4E
#define PLX9054_PCI_VPD_DATA												0x50


////////////////////////////////////////////
// LOCAL CONFIGURATION REGISTERS				//
////////////////////////////////////////////
// Definitions for the PLX local internal registers.	
#define PLX9054_LAS0RR_OFFSET         0x00						// Range for PCI-to-Local Address Space 0

#define PLX9054_LB0_BASE_ADR          0x04						// Local Base Address (Remap) for PCI-to-Local Address Space 0
#define SPACE0_ENABLED                      0x00000001
#define LB_SPACE0_ADDRESS_MASK              0xFFFFFFF0

#define PLX9054_MARBR_OFFSET          0x08						// Mode/DMA Arbitration
#define DIRECT_SLAVE_LOCK_ENABLE            (1 << 22)			// 22 bit
#define PRIORITY_MASK                       0x00180000
#define PRIORITY_DMA_0                      0x00100000

// 
#define PLX9054_BIGEND_LMISC_PROTAREA 0x0C						// Serial EEPROM Write-Protected address boundary *
																				// Local miscellaneous control +
																				// Big/Little endian descriptor
#define PROT_AREA_SHIFT                     16					
#define PROT_AREA_MASK                      0x007F0000
#define BIGEND_DIRECT_MASTER                0x00000002
#define BIGEND_SPACE_1                      (1 << 5)			// 5 bit
#define BIGEND_DMA0                         (1 << 7)

#define PLX9054_LBRD0_OFFSET          0x18						// local bus region descriptors for PCI-to-Local address
#define SPACE0_BUSWIDTH8                    0x00000000
#define SPACE0_BUSWIDTH16                   0x00000001
#define SPACE0_BUSWIDTH32                   0x00000003
#define SPACE0_READY_INPUT_ENABLE           0x00000040
#define SPACE0_BTERM_INPUT_ENABLE           0x00000080
#define SPACE0_PREFETCH_DISABLE             0x00000100
#define SPACE0_BURST_ENABLE                 0x01000000
#define SPACE0_PREFETCH_COUNT_ENABLE        0x00000400
#define PCI_TARGET_RETRY_DELAY_MAX          0xF0000000      /* 15 * 4 PCI clocks */


#define EROM_BUSWIDTH8                      0x00000000
#define EROM_BUSWIDTH16                     0x00010000
#define EROM_BUSWIDTH32                     0x00030000
#define EROM_READY_INPUT_ENABLE             0x00400000
#define EROM_BTERM_INPUT_ENABLE             0x00800000
#define EROM_PREFETCH_DISABLE               0x00000200
#define EROM_BURST_ENABLE                   0x04000000
#define EROM_PREFETCH_COUNT_ENABLE          0x00000400

#define PLX9054_LB_PCI_RANGE          0x1C						// Range for PCI initiator-to-PCI
#define PLX9054_DMRR_OFFSET           PLX9054_LB_PCI_RANGE
#define LB_PCI_RANGE_MASK                   0xFFFF0000

#define PLX9054_LB_BASE_ADR           0x20						// local base address for PCI initiator-to-PCI memory
#define PLX9054_DMLBAM_OFFSET         PLX9054_LB_BASE_ADR
#define LB_BASE_ADR_MASK                    0xFFFF0000

#define PLX9054_DMLBA1_OFFSET         0x24						// local base address for PCI initiator-to-PCI I/O configuration

#define PLX9054_PCI_BASE_ADR          0x28						// PCI base address for PCI initiator-to-PCI
#define PLX9054_DMPBAM_OFFSET         PLX9054_PCI_BASE_ADR 
#define LB_PCI_MEM_ENABLE                   0x00000001
#define LB_PCI_IO_ENABLE                    0x00000002
#define PCI_PREFETCH_SIZE_INF               0x00001008
#define PCI_KEEP_BUS                        0x00000010
#define USE_PCI_BASE_ADR                    0x00002000
#define PCI_BASE_ADR_MASK                   0xFFFF0000

////////////////////////////////////////////
// RUNTIME REGISTERS								//
////////////////////////////////////////////
#define PLX9054_MBOX0							0x40
#define PLX9054_MBOX1							0x44
#define PLX9054_MBOX2							0x48
#define PLX9054_MBOX3							0x4C
#define PLX9054_MBOX4							0x50
#define PLX9054_MBOX5							0x54
#define PLX9054_MBOX6							0x58
#define PLX9054_MBOX7							0x5C
#define PLX9054_P2LDBELL						0x60
#define PLX9054_L2PDBELL						0x64
#define PLX9054_INTCSR							0x68				// Interrupt Control/Status
#define PLX9054IDX_EN_TEA_LSERR0							0
#define PLX9054IDX_EN_TEA_LSERR1							1
#define PLX9054IDX_GEN_SERR_INT							2	
#define PLX9054IDX_MAILBOX_INT_ENABLE					3
#define PLX9054IDX_POWER_MANAGEMENT_INT_ENABLE		4
#define PLX9054IDX_POWER_MANAGEMENT_INT				5
#define PLX9054IDX_DATA_CHECK_PAR_ERROR_ENABLE		6
#define PLX9054IDX_DATA_CHECK_PAR_ERROR_STATUS		7
#define PLX9054IDX_PCI_INT_ENABLE						8
#define PLX9054IDX_PCI_DOORBELL_INT_ENABLE			9
#define PLX9054IDX_PCI_ABORT_INT_ENABLE				10
#define PLX9054IDX_LOCAL_IN_INT_ENABLE					11
#define PLX9054IDX_RETRY_ABORT_ENABLE					12
#define PLX9054IDX_PCI_DOORBELL_INT_ACTIVE			13
#define PLX9054IDX_PCI_ABORT_INT_ACTIVE				14
#define PLX9054IDX_LOCAL_IN_INT_ACTIVE					15
#define PLX9054IDX_LOCAL_OUT_INT_ENABLE				16
#define PLX9054IDX_LOCAL_DOORBELL_INT_ENABLE			17
#define PLX9054IDX_LOCAL_DMA_CH0_INT_ENABLE			18
#define PLX9054IDX_LOCAL_DMA_CH1_INT_ENABLE			19
#define PLX9054IDX_LOCAL_DOORBELL_INT_ACTIVE			20
#define PLX9054IDX_DMA_CH0_INT_ACTIVE					21
#define PLX9054IDX_DMA_CH1_INT_ACTIVE					22
#define PLX9054IDX_BIST_INT_ACTIVE						23
#define PLX9054_CNTRL							0x6C						// USER I/O Control
#define PLX9054_IDX_GENERAL_PURPOSE_OUTPUT			16
#define PLX9054_IDX_GENERAL_PURPOSE_INPUT				17
#define PLX9054_IDX_SERIAL_EEPROM_CLK					24
#define PLX9054_IDX_SERIAL_EEPROM_CS					25
#define PLX9054_IDX_SERIAL_EEPROM_WRITE_BIT			26
#define PLX9054_IDX_PCI_ADAPTER_SOFT_RESET			30
#define GP_OUTPUT_ENABLE									0x00040000
#define PLX9054_PCIHIDR							0x70
#define PLX9054_PCIHREV							0x74


/////////////////////////////////////////
// DMA REGISTERS								//
/////////////////////////////////////////
// DMAMODE0 register.
#define PLX9054_DMA0_MODE             0x80						// DMA Channel 0 Mode
#define DMA0_BTERM_ENABLE                   (1 << 7)      // 7 bit
#define DMA0_LOCAL_BURST_ENABLE             (1 << 8)      // 8 bit
#define DMA0_DONE_ENABLE                    (1 << 10)     // 10 bit
#define DMA0_HOLD_LOCAL_ADRESS              (1 << 11)     // 11 bit
#define DMA0_DEMAND_MODE                    (1 << 12)     // 12 bit
#define DMA0_FAST_TERMINATION               (1 << 15)     // 15 bit
#define DMA0_INT_TO_PCI                     (1 << 17)     // 17 bit


// DMAPADR0 register
#define PLX9054_DMA0_PCI_ADDRESS      0x84						// DMA Channel 0 PCI Address


// DMALADR0 register
#define PLX9054_DMA0_LB_ADDRESS       0x88						// DMA Channel 0 Local Address


// DMASIZ0 register
#define PLX9054_DMA0_SIZE             0x8C						// DMA Channel 0 Transfer Byte Count


// DMADPR0 register
#define PLX9054_DMA0_DESCR_PTR        0x90						// DMA Channel 0 Descriptor pointer
#define DMA0_DESCRIPTOR_INT_ENABLE          (1 << 2)      // 2 bit
#define DMA0_LOCAL_TO_PCI_TRANSFER          (1 << 3)      // 3 bit


#define PLX9054_DMA1_MODE             0x94						// DMA Channel 1 Mode
#define DMA1_DONE_ENABLE                    0x00000400    // 10 bit
#define DMA1_INT_TO_PCI                     0x00020000    // 18 bit


#define PLX9054_DMA1_DESCR_PTR        0xA4						// DMA Channel 1 Descriptor pointer
#define DMA1_INT_TERM_CNT_ENABLE            0x00000004

// DMACSR0 register
#define PLX9054_DMA_CMD_STS           0xA8						// DMA Channel 0 and 1 Command/Status
#define DMA0_ENABLE                         1             // 0 bit
#define DMA0_START                          (1 << 1)      // 1 bit
#define DMA0_ABORT                          (1 << 2)      // 2 bit
#define DMA0_CLEAR_INT                      (1 << 3)      // 3 bit
#define DMA0_TRANSFER_DONE                  (1 << 4)      // 4 bit

#define DMA1_CLEAR_INT                      0x00000800
#define DMA1_TRANSFER_DONE                  0x00001000

#define PLX9054_LAS1RR_OFFSET         0xF0						// Range for PCI-to-Local Address Space 1

#define PLX9054_LB1_BASE_ADR          0xF4						// Local Base Address (Remap) for PCI-to-Local Address Space 1
#define PLX9054_LAS1BA_OFFSET         PLX9054_LB1_BASE_ADR
#define SPACE1_ENABLED                      0x00000001
#define LB_SPACE1_ADDRESS_MASK              0xFFFFFFF0

#define PLX9054_LBRD1_OFFSET          0xF8						// Local Bus Region Descriptor (Space 1) for PCI-to-Local Accesses 
#define SPACE1_BUSWIDTH8                    0x00000000
#define SPACE1_BUSWIDTH16                   0x00000001
#define SPACE1_BUSWIDTH32                   0x00000003
#define SPACE1_READY_INPUT_ENABLE           0x00000040
#define SPACE1_BTERM_INPUT_ENABLE           0x00000080
#define SPACE1_PREFETCH_DISABLE             0x00000200
#define SPACE1_BURST_ENABLE                 0x00000100
#define SPACE1_PREFETCH_COUNT_ENABLE        0x00000400


#endif // P9054REG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\pcibrdge\specific\i22\I22REGS.H ===
//
// FILE:      library\hardware\pcibridge\specific\i22\i22regs.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   10.04.95
//
// PURPOSE:   Additional register definitions for the I22 chip. The I22 has
//            some bits and registers more than the I20.
// 
// HISTORY:

#ifndef I22REGS_H
#define I22REGS_H

#include "..\..\..\..\common\prelude.h"
#include "..\i20\i20regs.h"



// Interrupt status register

#define I22IDX_JCODREPIRQ		27
#define I22REG_JCODREPIRQ		I20REG_INTSTATUS, I22IDX_JCODREPIRQ



// Interrupt control register

#define I22IDX_JCODREPIRQEN	27
#define I22REG_JCODREPIRQEN	I20REG_INTENABLE, I22IDX_JCODREPIRQEN



// JPEG mode and control

#define I22REG_JMODE				0x100
#define I22IDX_JPG				31
#define I22REG_JPG				I22REG_JMODE, I22IDX_JPG
#define I22IDX_JPGMODE			29,  2
#define I22REG_JPGMODE			I22REG_JMODE, I22IDX_JPGMODE
#define I22IDX_RTBSY_FB			6
#define I22REG_RTBSY_FB			I22REG_JMODE, I22IDX_RTBSY_FEEDBACK
#define I22IDX_GO_ENABLE		5
#define I22REG_GO_ENABLE		I22REG_JMODE, I22IDX_GO_ENABLE
#define I22IDX_SYNCMSTR			4
#define I22REG_SYNCMSTR			I22REG_JMODE, I22IDX_SYNCMSTR
#define I22IDX_FLD_PER_BUFF	3
#define I22REG_FLD_PER_BUFF	I22REG_JMODE, I22IDX_FLD_PER_BUFF
#define I22IDX_VFIFO_FB			2
#define I22REG_VFIFO_FB			I22REG_JMODE, I22IDX_VFIFO_FB
#define I22IDX_CFIFO_FB			1
#define I22REG_CFIFO_FB			I22REG_JMODE, I22IDX_CFIFO_FB
#define I22IDX_STILL_LENDIAN	0
#define I22REG_STILL_LENDIAN	I22REG_JMODE, I22IDX_STILL_LENDIAN

// JPG modes
#define I22_MOTION_COMPRESS	0x03
#define I22_MOTION_DECOMPRESS	0x02
#define I22_STILL_COMPRESS		0x01
#define I22_STILL_DECOMPRESS	0x00



// JPEG process control

#define I22REG_JPROCESS			0x104
#define I22IDX_P_RESET			7
#define I22REG_P_RESET			I22REG_JPROCESS, I22IDX_P_RESET
#define I22IDX_COD_TRNS_EN		5
#define I22REG_COD_TRNS_EN		I22REG_JPROCESS, I22IDX_COD_TRNS_EN
#define I22IDX_AVFE_RESET		3
#define I22REG_AVFE_RESET		I22REG_JPROCESS, I22IDX_AVFE_RESET
#define I22IDX_ACTIVE			0
#define I22REG_ACTIVE			I22REG_JPROCESS, I22IDX_ACTIVE



// Vertical sync parameters

#define I22REG_VERTSYNC			0x108
#define I22IDX_VSYNCSIZE		16,  8
#define I22REG_VSYNCSIZE		I22REG_VERTSYNC, I22IDX_VSYNCSIZE
#define I22IDX_FRMTOT			 0, 16
#define I22REG_FRMTOT			I22REG_VERTSYNC, I22IDX_FRMTOT



// Horizontal sync parameters

#define I22REG_HORZSYNC			0x10C
#define I22IDX_HSYNCSTART		16, 16
#define I22REG_HSYNCSTART		I22REG_HORZSYNC, I22IDX_HSYNCSTART
#define I22IDX_LINETOT			 0, 16
#define I22REG_LINETOT			I22REG_HORZSYNC, I22IDX_LINETOT



// Field horizontal active portion

#define I22REG_HORZACTIVE		0x110
#define I22IDX_NAX				16, 16
#define I22REG_NAX				I22REG_HORZACTIVE, I22IDX_NAX
#define I22IDX_PAX				 0, 16
#define I22REG_PAX				I22REG_HORZACTIVE, I22IDX_PAX



// Field vertical active portion

#define I22REG_VERTACTIVE		0x114
#define I22IDX_NAY				16, 16
#define I22REG_NAY				I22REG_VERTACTIVE, I22IDX_NAY
#define I22IDX_PAY				 0, 16
#define I22REG_PAY				I22REG_VERTACTIVE, I22IDX_PAY



// Field process parameters

#define I22REG_FIELDPARAS		0x118
#define I22IDX_VERDEC			1
#define I22REG_VERDEC			I22REG_FIELDPARAS, I22IDX_VERDEC
#define I22IDX_ODD_EVEN			0
#define I22REG_ODD_EVEN			I22REG_FIELDPARAS, I22IDX_ODD_EVEN



// JPEG code base address

#define I22REG_I_STAT_COM		0x11C



// JPEG CFIFO threshold

#define I22REG_THRESHOLD		0x120
#define I22IDX_COD_THRESHOLD	 0,  8
#define I22REG_COD_THRESHOLD	I22REG_THRESHOLD, I22IDX_COD_THRESHOLD



// JPEG coder guest ID

#define I22REG_CODERGUEST		0x124
#define I22IDX_GUESTID			 4,  3
#define I22REG_GUESTID			I22REG_CODERGUEST, I22IDX_GUESTID
#define I22IDX_GUESTREG			 0,  3
#define I22REG_GUESTREG			I22REG_CODERGUEST, I22IDX_GUESTREG



// JPEG code debug register

#define I22REG_CODEDEBUG		0x128
#define I22IDX_SERV_STATE		12,  4
#define I22REG_SERV_STATE		I22REG_CODEDEBUG, I22IDX_SERV_STATE
#define I22IDX_CODBUFFCNT		10,  2
#define I22REG_CODBUFFCNT		I22REG_CODEDEBUG, I22IDX_CODBUFFCNT
#define I22IDX_CODFRAGCNT		 0,  8
#define I22REG_CODFRAGCNT		I22REG_CODEDEBUG, I22IDX_CODFRAGCNT



// GuestBus control register 2. We have the same duration and recovery timing
// as GuestBus control register 1. In contrast to GuestBus control register 1,
// 4..7 is used as index here.

#define I22REG_GUESTCTRL_2		0x12C
#define I22IDX_GUESTDUR(x)		(2+4*(x-4)), 2
#define I22REG_GUESTDUR(x)		I22REG_GUESTCTRL_2, I22IDX_GUESTDUR(x)
#define I22IDX_GUESTREC(x)		(0+4*(x-4)), 2
#define I22REG_GUESTREC(x)		I22REG_GUESTCTRL_2, I22IDX_GUESTREC(x)



// Still transfer register assuming little endian format configuration

#define I22REG_STILL_TRANSFER	0x300
#define I22IDX_STILL_BSY		31
#define I22REG_STILL_BSY		I22REG_STILL_TRANSFER, I22IDX_STILL_BSY
#define I22IDX_STILL_PIXEL		 0, 24
#define I22REG_STILL_PIXEL		I22REG_STILL_TRANSFER, I22IDX_STILL_PIXEL



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\pcibrdge\specific\saa7145\saa7145r.h ===
// FILE:			library\hardware\pcibridge\specific\saa7145\saa7145r.h
// AUTHOR:		U. Sigmund, S. Herr
// COPYRIGHT:	(c) 1995 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		19.03.96
//
// PURPOSE:		Register definitions for Philips SAA 7145
//
// HISTORY:

#ifndef SAA7145R_H
#define SAA7145R_H

#include "..\common\prelude.h"

#define SAA7145REG_VDBA			0x00

#define SAA7145REG_VDPCTRL1	0x04
#define SAA7145IDX_VDPA			 2, 22
#define SAA7145IDX_VDPEN		 0

#define SAA7145REG_VDMAC		0x08
#define SAA7145IDX_EVID			31
#define SAA7145IDX_VBS			25, 3
#define SAA7145IDX_VTHR			21, 3
#define SAA7145IDX_VEND			19, 2
#define SAA7145IDX_PFMT			16, 3
#define SAA7145IDX_VFLIP		15
#define SAA7145IDX_VPCH			0, 13

#define SAA7145_PFMT_RGB32		0
#define SAA7145_PFMT_RGB24		1
#define SAA7145_PFMT_RGB16		2
#define SAA7145_PFMT_RGB15		3
#define SAA7145_PFMT_YUV16		4
#define SAA7145_PFMT_Y			5
#define SAA7145_PFMT_RGB16D	6
#define SAA7145_PFMT_RGB15D	7

#define SAA7145_VBS_1			0
#define SAA7145_VBS_2			1
#define SAA7145_VBS_4			2
#define SAA7145_VBS_8			3
#define SAA7145_VBS_16			4
#define SAA7145_VBS_32			5
#define SAA7145_VBS_64			6
#define SAA7145_VBS_ANY			7

#define SAA7145_VTHR_1			0
#define SAA7145_VTHR_16			1
#define SAA7145_VTHR_32			2
#define SAA7145_VTHR_48			3
#define SAA7145_VTHR_64			4
#define SAA7145_VTHR_80			5
#define SAA7145_VTHR_96			6
#define SAA7145_VTHR_112		7

#define SAA7145_VEND_NONE		0
#define SAA7145_VEND_2BYTE		1
#define SAA7145_VEND_4BYTE		2

#define SAA7145REG_VPCTL		0x0C
#define SAA7145IDX_VPCTL		0, 16
#define SAA7145IDX_TEST			15
#define SAA7145IDX_EVEND		11
#define SAA7145IDX_ODDD			10
#define SAA7145IDX_REVS			9
#define SAA7145IDX_REHS			8
#define SAA7145IDX_TWOS			7
#define SAA7145IDX_SF			6
#define SAA7145IDX_FODD			5
#define SAA7145IDX_FD			3, 2
#define SAA7145IDX_SOE			2
#define SAA7145IDX_XSS			1
#define SAA7145IDX_VPZ			0

#define SAA7145_FD_NORMAL		0
#define SAA7145_FD_NOISE		1
#define SAA7145_FD_FORCE		2
#define SAA7145_FD_EXTERNAL	3

#define SAA7145REG_XWC			0x10
#define SAA7145IDX_XWS			16, 10
#define SAA7145IDX_XWZ			0, 10

#define SAA7145REG_YWC			0x14
#define SAA7145IDX_YWS			16, 10
#define SAA7145IDX_YWZ			0, 10

#define SAA7145REG_FSCTL		0x18
#define SAA7145IDX_ILO			31
#define SAA7145IDX_FMODE		28, 3
#define SAA7145IDX_XSCI			16, 11
#define SAA7145IDX_YSCI			0, 11

#define SAA7145REG_YPR			0x1c
#define SAA7145IDX_YPO			16, 10
#define SAA7145IDX_YPE			0, 10

#define SAA7145REG_CDBA			0x20

#define SAA7145REG_CDF			0x24
#define SAA7145IDX_CPO			24, 9
#define SAA7145IDX_CPIX			16, 6
#define SAA7145IDX_CLINE		0, 10

#define SAA7145REG_CDMAC		0x28
#define SAA7145IDX_ECLIP		31
#define SAA7145IDX_CEND			19, 2
#define SAA7145IDX_CPOL			16
#define SAA7145IDX_CPCH			0, 10

#define SAA7145REG_LCR			0x2c
#define SAA7145IDX_SLCT			16, 10
#define SAA7145IDX_TLCT			0, 10

#define SAA7145REG_ADBA			0x30
#define SAA7145REG_ADPA			0x34
#define SAA7145IDX_ADPA			2, 15

#define SAA7145REG_ADMAC		0x38
#define SAA7145IDX_EAUD			31
#define SAA7145IDX_AEND			19
#define SAA7145IDX_AFMT			16, 2
#define SAA7145IDX_ARNG			0, 4

#define SAA7145_AFMT_16RISE	0
#define SAA7145_AFMT_8RISE		1
#define SAA7145_AFMT_16FALL	2
#define SAA7145_AFMT_8FALL		3

// RPS address/enable register
#define SAA7145REG_RPSREG		0x3c
#define SAA7145IDX_RPSPTR		2, 30
#define SAA7145IDX_ERPS			0

// RPS page register
#define SAA7145REG_RPSR			0x40
#define SAA7145IDX_RPSP			11, 21
#define SAA7145IDX_ERPSP		0

// RPS Timout register.
#define SAA7145REG_RPSTO		0x44
#define SAA7145IDX_TOSEL		28, 2
#define SAA7145IDX_TOV			24, 4
#define SAA7145IDX_TOP			0, 24


// Interrupt registers.
#define SAA7145REG_ISR			0x48
#define SAA7145REG_IER			0x4C
#define SAA7145REG_IMR			0x50

// Interrupt bits
#define SAA7145IDX_MASTER		0
#define SAA7145IDX_EC1			1
#define SAA7145IDX_EC2			2
#define SAA7145IDX_GP0			4
#define SAA7145IDX_GP1			5
#define SAA7145IDX_GP2			6
#define SAA7145IDX_GP3			7
#define SAA7145IDX_VFO			8
#define SAA7145IDX_VPE			9
#define SAA7145IDX_CFU			10
#define SAA7145IDX_AFO			11
#define SAA7145IDX_FID			12
#define SAA7145IDX_FIDN			13
#define SAA7145IDX_HBI			14
#define SAA7145IDX_VBI			15
#define SAA7145IDX_VFE			16
#define SAA7145IDX_RPS_PE		17
#define SAA7145IDX_RPS_L		18
#define SAA7145IDX_RPS_TO		19
#define SAA7145IDX_RPS_I		20
#define SAA7145IDX_RPS_S		21
#define SAA7145IDX_UPLD			22
#define SAA7145IDX_ARI			23
#define SAA7145IDX_IIC_D		24
#define SAA7145IDX_IIC_E		25
#define SAA7145IDX_DEBI_TO		26
#define SAA7145IDX_DEBI_I		27
#define SAA7145IDX_DEBI_D		28
#define SAA7145IDX_PPEW			29
#define SAA7145IDX_PABO			30
#define SAA7145IDX_PPER			31

// Interrupt groups for faster IRQ dispatch.
#define SAA7145IDX_IRQPCI		29, 3
#define SAA7145IDX_IRQDEBI		26, 3
#define SAA7145IDX_IRQI2C		24, 2
#define SAA7145IDX_IRQAUDIO	23, 1
#define SAA7145IDX_IRQRPS		17, 6
#define SAA7145IDX_IRQVIDEO	8, 9
#define SAA7145IDX_IRQGPIO		4, 4
#define SAA7145IDX_IRQEC		1, 2


#define SAA7145REG_ECR			0x54
#define SAA7145IDX_ECR			0, 20
#define SAA7145REG_ECT			0x58
#define SAA7145IDX_ECT			0, 20
#define SAA7145REG_ECC			0x5C
#define SAA7145IDX_ECC			0, 20

// General purpose IO port (GPIO)
#define SAA7145REG_GPIOC		0x60

#define SAA7145IDX_GPIOC(x)	(8*x),8
#define SAA7145REG_GPIO(x)		SAA7145REG_GPIOC, SAA7145IDX_GPIOC(x)

#define SAA7145IDX_IOS			0
#define SAA7145IDX_DIR			1
#define SAA7145IDX_MIO			2
#define SAA7145IDX_MSEL			3, 5

#define SAA7145IDX_IOSX(x)		(8*x)
#define SAA7145IDX_DIRX(x)		(8*x+1)
#define SAA7145IDX_MIOX(x)		(8*x+2)
#define SAA7145IDX_MSELX(x)	(8*x+3), 5

#define SAA7145REG_DEBICFG		0x64
#define SAA7145IDX_XIRQPOL		29
#define SAA7145IDX_SS_DS		28
#define SAA7145IDX_XIRQ_WAIT	27
#define SAA7145IDX_TIMEOUT		22, 4
#define SAA7145IDX_SWAP			20, 2
#define SAA7145IDX_SLAVE16		19
#define SAA7145IDX_INCR			18
#define SAA7145IDX_IN_MO		17
#define SAA7145IDX_TIEN			16

#define SAA7145REG_DEBIDAT		0x68
#define SAA7145REG_DEBICMD		0x6c
#define SAA7145IDX_BLOCKLEN	17,15
#define SAA7145IDX_WRITE_N		16
#define SAA7145IDX_A16_IN		0,16


// IC transfer register
#define SAA7145REG_I2CTFR		0x70
#define SAA7145IDX_I2CB2		24,8
#define SAA7145IDX_I2CB1		16,8
#define SAA7145IDX_I2CB0		8,8
#define SAA7145IDX_I2CATTR2	6,2
#define SAA7145IDX_I2CATTR1	4,2
#define SAA7145IDX_I2CATTR0	2,2

#define SAA7145IDX_I2CBX(x)	(8*x+8),8

// control block.
#define SAA7145IDX_I2CCTL		0, 8

// IC control/status register
#define SAA7145REG_I2CSC		0x74
#define SAA7145IDX_I2CCC		8, 3
#define SAA7145IDX_I2CSTA		0, 8
// Status bit definitions:
#define SAA7145IDX_I2CBUSY		0			// Also available in I2CTFR register!
#define SAA7145IDX_I2CERR		1			// Also available in I2CTFR register!
#define SAA7145IDX_I2CDTERR	4
#define SAA7145IDX_I2CAPERR	5
#define SAA7145IDX_I2CIRQ		7

#define SAA7145REG_UTIL			0x78
#define SAA7145REG_TURBO		0x7c

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\pcibrdge\specific\saa7145\rps7145.h ===
// FILE:			library\hardware\pcibridge\specific\saa7145\rps7145.h
// AUTHOR:		U. Sigmund
// COPYRIGHT:	(c) 1996 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		19.03.96
//
// PURPOSE:		Class for Register Programming Sequencer (RPS) programs.
//
// HISTORY:

#ifndef RPS7145_H
#define RPS7145_H

#include "..\common\prelude.h"
#include "..\common\gnerrors.h"
#include "..\lowlevel\dmabuffr.h"

#define RPS_LDREG(reg, val)		0x50000100UL | (DWORD)(reg), (DWORD)(val)
#define RPS_STREG(reg, addr)		0x60000100UL | (DWORD)(reg), (DWORD)(addr)
#define RPS_STOP						0x30000000UL
#define RPS_JUMP(flags, dest)		0x40000000UL | (DWORD)(flags), (DWORD)(dest)
#define RPS_IRQ						0x20000000UL
#define RPS_NOP						0x00000000UL
#define RPS_WAIT(flags)				0x90000000UL | (DWORD)(flags)
#define RPS_CHECK(flags)			0x80000000UL | (DWORD)(flags)
#define RPS_PAUSE(flags)			0xa0000000UL | (DWORD)(flags)
#define RPS_SET(flags)				0x10000000UL | (DWORD)(flags)
#define RPS_CLR(flags)				0x00000000UL | (DWORD)(flags)
#define RPS_DONE						0xffffffffUL

#define RPSB_ANY		15
#define RPSF_ANY		(1<<RPSB_ANY)
#define RPSB_INV		14
#define RPSF_INV		(1<<RPSB_INV)
#define RPSB_RPS_S	13
#define RPSF_RPS_S	(1<<RPSB_RPS_S)
#define RPSB_VFE		12
#define RPSF_VFE		(1<<RPSB_VFE)
#define RPSB_GPIO3	11
#define RPSF_GPIO3	(1<<RPSB_GPIO3)
#define RPSB_GPIO2	10
#define RPSF_GPIO2	(1<<RPSB_GPIO2)
#define RPSB_GPIO1	9
#define RPSF_GPIO1	(1<<RPSB_GPIO1)
#define RPSB_GPIO0	8
#define RPSF_GPIO0	(1<<RPSB_GPIO0)
#define RPSB_EAW		7
#define RPSF_EAW		(1<<RPSB_EAW)
#define RPSB_EOL		6
#define RPSF_EOL		(1<<RPSB_EOL)
#define RPSB_HS		5
#define RPSF_HS		(1<<RPSB_HS)
#define RPSB_HT		4
#define RPSF_HT		(1<<RPSB_HT)
#define RPSB_ODD		3
#define RPSF_ODD		(1<<RPSB_ODD)
#define RPSB_EVEN		2
#define RPSF_EVEN		(1<<RPSB_EVEN)
#define RPSB_DEBID	1
#define RPSF_DEBID	(1<<RPSB_DEBID)
#define RPSB_I2CD		0
#define RPSF_I2CD		(1<<RPSB_I2CD)



class RPSProgram
	{
	friend class SAA7145;

	private:
		ContinuousDMABuffer *buffer;
		DWORD __far *dataMem;
		DWORD __far *codeMem;

		WORD dataSize;
		WORD codeSize;
		WORD codeEnd;
		BOOL valid;

		WORD nLabels;
		WORD __far *labels;

		WORD nLabeledJumps, lastLabeled;
		WORD __far *labeledJumps;

		Error AppendFix (DWORD __far *com, BOOL patching);

	public:
		RPSProgram (WORD dataSize, WORD codeSize, WORD nLabels, WORD nLabeledJumps);
		virtual ~RPSProgram (void);

		Error __cdecl Build (DWORD commands, ...);
		Error __cdecl Append (DWORD commands, ...);
		Error __cdecl Patch (WORD labelNumber, DWORD commands, ...);
		Error CalculateJumps (void);

		Error SetLabel (WORD labelNumber);
		Error GetLabelAddress (WORD labelNumber, DWORD __far &physical);

		Error ReadValue (WORD at, DWORD __far &data) {data = dataMem[at]; GNRAISE_OK;}
		Error WriteValue (WORD at, DWORD data) {dataMem[at] = data; GNRAISE_OK;}
		Error GetDataAddress (WORD at, DWORD __far &physical);

		Error GetPhysicalCodeAddress (DWORD __far &physical);
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\pcibrdge\specific\PLX9054\plx9054.h ===
//
// FILE:       library\hardware\pcibridge\specific\PLX9054\plx9054.h
// AUTHOR:		Martin Stephan
// COPYRIGHT:	(c) 1999 Viona Development GmbH.  All Rights Reserved.
// CREATED:		19.11.1999
//
// PURPOSE: 	PCI bridge class for CineMaster II encoder --- Header file
//
// HISTORY:		
//

#ifndef PLX9054_H
#define PLX9054_H

#include "library\common\gnerrors.h"
#include "library\lowlevel\hwbusio.h"
#include "library\lowlevel\intrctrl.h"
#include "library\common\krnlsync.h"

//
// PLX 9054 PCI bridge class
//
class PLX9054 : public VDSpinLock
	{
	public:
		PLX9054(MemoryMappedIO * plxMem, MemoryMappedIO * localMem, MemoryMappedIO * msgMem, IndexedInOutPort * configPort);
		~PLX9054(void);

		//
		// Initialize the PLX 9054 PCI bridge chip
		//		
		virtual Error BuildPorts(void);

		//
		// To be called in the isr
		//
		virtual void Interrupt(void);				
		InterruptServeType CheckInterrupt(void);

		Error Initialize(void);

		//
		// configure local bus
		//
		virtual Error ConfigureLocal(void);
		
		//
		// Interrupts
		//		
		InterruptServer		*	encoderIRQ;

		//
		// Memory areas
		//
		MemoryMappedIO			*	plxMem;
		MemoryMappedIO			*  localMem;
		MemoryMappedIO			*	controlMem;

		//
		// Configuration space port
		//
		IndexedInOutPort		*	configPort;

		//
		// Local bus
		//
		DWordInOutBus			*	localBus;
		//
		// Control bus
		//
		DWordInOutBus			*	controlBus;

		DWORD						intShadow;
		
	protected:
		DWORD						intStatus;        

	private:

	};


//
// Interrupt server for PLX interrupt
//	
class PLX9054IntServer : public InterruptServer 
	{
	private:
		PLX9054	*	plx9054;

	protected:
		Error EnableInt(void);
		Error DisableInt(void);

	public:
		PLX9054IntServer(PLX9054 * plx9054) : InterruptServer()
			{ this->plx9054 = plx9054; }
	};                                                                                          


#endif // PLX9054_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\pcibrdge\specific\saa7145\S7145PIP.H ===
// FILE:      library\hardware\pcibridge\specific\saa7145\s7145pip.h
// AUTHOR:    Dietmar Heidrich, S. Herr
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   08.04.95
//
// PURPOSE: The PIP-related classes.
//
// HISTORY:

#ifndef SAA7145PIP_H
#define SAA7145PIP_H

#ifndef ONLY_EXTERNAL_VISIBLE

#include "..\lowlevel\memmpdio.h"
#include "..\lowlevel\dmabuffr.h"      
#include "..\videodma\gfxconfg.h"
#include "..\lowlevel\intrctrl.h"
#include "rps7145.h"

#endif


#include "..\videodma\dmapip.h"

//
// Maximum values for destination rectangle size.
//
#define PIP_WIDTH_MAX   768
#define PIP_HEIGHT_MAX  576


//
// PIP Display Mode (also valid for grabbing).
//
enum PIPDisplayMode
	{
	PDMD_MIN 						= 0,
	PDMD_EMULATED_INTERLACED	= 0,		// Interlaced display.
	PDMD_SINGLE_FIELD,						// Single field display.
	PDMD_AUTOMATIC,							// Automatic decision of display mode.
	PDMD_MAX = PDMD_AUTOMATIC
	};

//
// HFilter type (valid for PIP and grabbing).
//
enum PIPHFilterType
	{
	PIP_HF_CHOOSE_BEST 	= -1,				// Automatic selection of filter type.
	PIP_HF_L0C3  			= 0,				// The enum values correspond to the values of I20's HFilter register.
	PIP_HF_L3C3				= 1,
	PIP_HF_L4C4a 			= 2,
	PIP_HF_L5C4  			= 3,
	PIP_HF_L4C4b 			= 4,
	PIP_HFILTER_MIN 		= -1,
	PIP_HFILTER_MAX 		= 4
	};

enum PIPErrDiffusion
	{
	PIP_ED_ON 	= 0,
	PIP_ED_OFF 	= 1,
	PIP_ED_AUTOMATIC
	};


// Error definitions.
#define GNR_DMA_PIP_NOT_POSSIBLE		MKERR(ERROR, PIP, GENERAL, 0x01)		// Current screen mode does not allow DMA PIP
#define GNR_VIDEO_STD_NOT_SUPPORTED	MKERR(ERROR, PIP, GENERAL, 0x02)		// Desired video standard (e.g. SECAM) not supported.
#define GNR_PIP_NOT_RUNNING			MKERR(ERROR, PIP, GENERAL, 0x03)		// PIP is not running when trying to execute OptimizeBuffer()
#define GNR_NO_OPTIMAL_MINPIX			MKERR(ERROR, PIP, GENERAL, 0x04)		// No optimal minPix value could be found by OptimizeBuffer()
#define GNR_DEST_RECT_SIZE				MKERR(ERROR, PIP, GENERAL, 0x05)		// Destination rectangle too small or too big.
#define GNR_WRONG_GRAB_SIZE			MKERR(ERROR, PIP, GENERAL, 0x06)		// Dimensions of frame to grab are too big.
#define GNR_NO_VBLANK_IRQ				MKERR(ERROR, PIP, GENERAL, 0x07)		// An expected VBlank IRQ did not occur.
#define GNR_GRAB_TIMEOUT				MKERR(ERROR, PIP, GENERAL, 0x08)		// A timeout occurred during grabbing a frame.
#define GNR_WRONG_GRAB_FORMAT			MKERR(ERROR, PIP, GENERAL, 0x09)		// An unsupported capture format was requested
#define GNR_SAMPLEMODE_NOT_SUPPORTED	MKERR(ERROR, PIP, GENERAL, 0x0a)		// Desired video sample mode not supported

#ifndef ONLY_EXTERNAL_VISIBLE

#define VBLANK_TIMEOUT 100				// Time in [ms] until a VSYNC IRQ must have occurred.
#define GRAB_TIMEOUT	  1000			// Time in [ms] until grabbing of one frame must be finished.

struct SAA7145PIPSetting {
	DWORD			vdba;
	DWORD			vdpctrl1;
	DWORD			vdmac;
	DWORD			vpctl;
	DWORD			xwc;
	DWORD			ywc;
	DWORD			fsctl;
	DWORD			ypr;
	DWORD			cdba;
	DWORD			cdf;
	DWORD			cdmac;
	};

class SAA7145PIPVBlankIntHandler;			// Forward declaration of IRQ handler class.

//
// Physical SAA7145 Masked DMA PIP class.
//
class SAA7145PIP : public MaskDMAPIP
	{
	friend class VirtualSAA7145PIP;
	friend class SAA7145PIPVBlankIntHandler;

	protected:
		MemoryMappedIO			*	io;						// IO object for SAA7145 PIP registers.

		GraphicConfig			*	gfxConfig;				// Stores information about current graphics card and screen mode.
		ContinuousDMABuffer 		maskBuffer;				// mask DMA buffer
		DWORD							maskPhysical;

		Profile					*	profile;

		BOOL 							maskEnabled;			// Indicates use of mask information. If false, the DMA window
																	// is always on top.
		BOOL							grabMode;				// The PIP object is in grabbing mode, when this flag is TRUE.

		HardVideoParams 			ntsc, pal; 
		const HardVideoParams* 	curVideoParams;		// Pointer to the settings of the current video standard.

		VideoStandard 				curVideoStd;			// Contains the current video standard.
		VideoSampleMode			sampleMode;
		int							hOffset, vOffset;
		DWORD							dispgrab;

		WORD	curMaskDwpr;									// Number of DWORDs per mask row.

		BOOL	extFieldInd;									// External field indication.
		BOOL	topField;										// Top field indication.
		BIT	vclkPolarity;									// VCLK polarity.

		int	srcLeft, srcTop;
		WORD	srcWidth, srcHeight;	// Dimensions of the source rectangle.

		WORD	ConvertGrabFormat(GrabFormat format);	// Converts destination format to the YUV2RGB register value. 
		WORD	ConvertPIPFormat(PIPFormat format);		// Same for PIP format. In both functions packed24 is set
																	// in respect to 24 or 32 bit mode.
		int	GetPixelSize (GrabFormat type);			// Get size of a pixel for a certain format.

		Error WaitVBlankIRQ(WORD count);					// Wait for the number of "count" VSYNC IRQs to occur.

		BOOL	adaptSourceSize;								// Tells, if the source rectangle is adapted to the video
																	// standard.
		SAA7145PIPVBlankIntHandler	* vBlankIntHandler;	// VBlank handler.
		InterruptServer 			* vBlankIntServer;	// Interrupt server.

		SAA7145PIPSetting				pipSetting, grabSetting;
		SAA7145PIPSetting	__far	*	currentPIPSetting;

		ContinuousDMABuffer	*	captureDMA;

		FPTR							captureDMABuffer;
		DWORD							captureDMADWordsPerRow;

		HPTR							captureBuffer;
		DWORD							captureDWordsPerRow;

		WORD							captureHeight;

		StreamCaptureHook		*	captureHook;
		YStreamCaptureHook	*	yCaptureHook;

		RPSProgram *pipEnableRPS;

	protected:
		int dmaSuspended;										// Internal DMA suspension flag.

		void 	VBlankInterrupt(void);						// VBlank (VSYNC) IRQ routine.
		DWORD volatile vBlankCount;						// Tells us, how many vertical blank IRQs happened.

		Error StopDMA(void);									// Stops DMA.
		Error StartDMA(void);								// Starts DMA.
		Error EnablePIP(BOOL enable);						// Enables PIP in general.

		Error Update(void);									// Updates all PIP parameters.

		virtual Error CalculateSettings (SAA7145PIPSetting __far &setting,
													DWORD dstBase, DWORD bytesPerRow,
													PIPFormat pixelFormat,
													BOOL mask,
													int left, int top,
													WORD width, WORD height);

		Error ProgramSettings(SAA7145PIPSetting __far &setting);

		Error ProgramAll(void);								// Reprograms all DMA PIP/grab registers of the SAA7145.

		Error SetMask(RectBitMap * map);
		Error SetSourceRect(int left, int top, int width, int height);
		Error SetVideoStandard(VideoStandard std);
		Error SetSampleMode(VideoSampleMode sampleMode);
		Error SetHOffset(int offset);
		Error SetVOffset(int offset);
		Error SetMaskEnable(BOOL enable);
		Error SetAdaptSourceSize(BOOL adaptSourceSize);
		Error SetExtFieldInd(BOOL enable);
		Error SetTopField(BOOL field);

		Error GrabFrame(FPTR base, WORD width,  WORD height, 		   // Grab a single frame from the running picture.
							WORD stride, GrabFormat fmt);

		Error StartGrabStream(StreamCaptureHookHandle hook,
					             WORD width, WORD height, 
					             WORD stride, 
					             GrabFormat fmt);

		Error SupplyStreamGrabBuffer(HPTR buffer);

		HPTR	GetStreamGrabBuffer (void);

		Error StopGrabStream(void);

		Error StartGrabYStream(YStreamCaptureHookHandle hook,
		                       int left, int top,
		                       WORD width, WORD height);

		Error StopGrabYStream(void);

		int   HorizontalAlign(void);						// Delivers the alignment for SAA7145 PIP (destination is always
																	// DWORD aligned, so e.g. 24 bit modes need a different alignment
																	// than 16 or 15 bit).
		int   VerticalAlign(void);							// Same for vertical.

		int MaxDestWidth(void) {return srcWidth;}		// Returns maximum horizontal size of the destination rectangle.
		int MaxDestHeight(void) {return srcHeight;}	// Maximum vertical size of the destination rectangle.

		RectBitMap *CreateDMAMap(int left, int top, int width, int height)
			{return new InverseRectBitMap(left, top, width, height);}			// We need an inverse bitmap for the SAA7145!
	public:
		SAA7145PIP (HINSTANCE hinst, MemoryMappedIO *io, InterruptServer *vblankIntServer,
		            Profile *profile);
		~SAA7145PIP(void);

		VirtualUnit *CreateVirtual(void);

		Error ReadConfig (char *filename);				// Allows to read advanced parameters from a configuration file.
		Error Initialize(void);								// Initializes the SAA7145 PIP. Call after the object was constructed.

		Error SuspendDMA(void);								// Nested DMA disabe.
		Error ResumeDMA(void);								// Nested DMA enable.
	};


//
// Virtual SAA7145 PIP.
//
class VirtualSAA7145PIP : public VirtualMaskDMAPIP 
	{
	friend class SAA7145PIP;

	private:
		SAA7145PIP *unit;

	protected:
		BOOL					maskEnabled;
		BOOL					extFieldInd;
		BOOL					topField;

		Error Preempt (VirtualUnit *previous);
	public:
		VirtualSAA7145PIP (SAA7145PIP *physical);
		Error Configure (TAG __far *tags);
	};


#endif // ONLY_EXTERNAL_VISIBLE


// SAA7145 PIP specific tags                     
MKTAG (PIP_H_FILTER,     	PIP_UNIT, 0x00000030, PIPHFilterType)	// Horizontal filter type selection.
MKTAG (PIP_DISPLAY_MODE, 	PIP_UNIT, 0x00000031, PIPDisplayMode) 	// DispMode selection.
MKTAG (PIP_DUP_FIELD,    	PIP_UNIT, 0x00000032, BOOL)				// DupField switch.
MKTAG (PIP_ERR_DIFFUSION,	PIP_UNIT, 0x00000034, PIPErrDiffusion)	// Error diffusion type selection.
MKTAG (PIP_MIN_PIX,      	PIP_UNIT, 0x00000035, int)					// MinPix value (FIFO threshold).
MKTAG (PIP_MASK_ENABLE,	 	PIP_UNIT, 0x00000036, BOOL)				// Mask enable/disable switch.
MKTAG (PIP_EXT_FIELD_IND,  PIP_UNIT, 0x00000037, BOOL)				// ExtFI mode selection.
MKTAG (PIP_TOP_FIELD,      PIP_UNIT, 0x00000038, BOOL)				// Top field interpretation selection.
MKTAG (PIP_MINPIX_AUTO,		PIP_UNIT, 0x00000039, BOOL)				// Automatic adaption of MinPix to picture size.

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\pcibrdge\specific\saa7145\saa7145.h ===
// FILE:			library\hardware\pcibridge\specific\saa7145\saa7145.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1996 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		19.03.96
//
// PURPOSE:		Philips SAA 7145 management class.
//
// HISTORY:

#ifndef SAA7145_H
#define SAA7145_H

#include "..\common\prelude.h"
#include "..\common\gnerrors.h"
#include "..\lowlevel\memmpdio.h"
#include "..\lowlevel\i2c.h"  
#include "..\lowlevel\intrctrl.h"
#include "..\lowlevel\dmachanl.h"

#include "saa7145r.h"
#include "rps7145.h"

///////////////////////////////////////////////////////////////////////////////
// Error definitions.
///////////////////////////////////////////////////////////////////////////////

#define	GNR_ILLEGAL_DMA_BUFFER_SIZE	MKERR(ERROR, DMA, PARAMS, 0x010)
	// The size of the dma buffer was not in the supported range

#define GNR_RPS_IN_USE						MKERR(ERROR, PCICONTROLLER, GENERAL, 0x01)
	// An RPS program was already installed.


#ifndef ONLY_EXTERNAL_VISIBLE

///////////////////////////////////////////////////////////////////////////////
// Interrupt server for 7145 interrupts
///////////////////////////////////////////////////////////////////////////////

class SAA7145IntServer : public InterruptServer
	{
	private:
		int		intCtrlBit;	// bit in the interrupt control registers
		class SAA7145	*	saa7145;
	protected:
		Error EnableInt(void);
		Error DisableInt(void);
	public:
		SAA7145IntServer(SAA7145 * saa7145, int intCtrlBit) {this->saa7145 = saa7145; this->intCtrlBit = intCtrlBit;}
	};                                                                                          

///////////////////////////////////////////////////////////////////////////////
// Special mixed indexed Byte/Word In/Out Port
///////////////////////////////////////////////////////////////////////////////

class ByteWordIndexedInOutPort : public ByteIndexedInOutPort, public WordIndexedInOutPort
	{ };


///////////////////////////////////////////////////////////////////////////////
// The SAA 7145 management class.
///////////////////////////////////////////////////////////////////////////////

class DEBIQueue;

class SAA7145
	{
	friend class SAA7145IntServer;

	public:
		// Endian swapping control
		enum EndianSwap {ES_NO_SWAP, ES_TWO_BYTE_SWAP, ES_FOUR_BYTE_SWAP, ES_RESERVED};
	
		// Bus interface style for DEBI port.
		enum BusStyle {BS_INTEL, BS_MOTOROLA};
	
		// Possible I2C clock rates (PCI clock divisors).
		enum I2CClockRate {I2C_CLK_120, I2C_CLK_3200, I2C_CLK_80, I2C_CLK_RESERVED1,
		                   I2C_CLK_480, I2C_CLK_6400, I2C_CLK_320, I2C_CLK_RESERVED2};
	
		// Possible RPS timeouts.
		enum TimeOutSelect {TO_NONE, TO_PCI, TO_VSYNC, TO_BOTH};

		// General IO pin input/output mode.
		enum GIOPinMode {GIO_INPUT=0, GIO_OUTPUT=1};

	private:
		RPSProgram 				*	program;

	protected:           
		DWORD intEnable;
		DWORD intStatus;

	public:
		// Memory area of the register set
		MemoryMappedIO			*	mem;

		// I2C bus supported by the 7145
		ByteInOutBus			*	i2c;
		
		// Audio Input Port DMA
		CircularDMAChannel	*	audioInputDMA;

		// General IO pins
		BitIndexedInOutPort	*	genPPort;

		// One IRQ server for every IRQ
		InterruptServer*	irqServers[32];

		DEBIQueue				*	debiQueue;

		SAA7145(MemoryMappedIO * mem);
		~SAA7145(void);

		// Initialize the 7145 and create all the ports.
		virtual Error Initialize(void);

		virtual Error ResetDEBI (void);

		// Configure the general IO pins for input or output and their IRQ function
		// N.B.: "mode" defines transition edge if monitor = FALSE, else it is the IRQ source.
		virtual Error ConfigurePPort(int at, GIOPinMode output, BOOL monitor, int mode);

		// Configure IC port.
		virtual Error ConfigureI2C(I2CClockRate clockRate);

		// Configure IRQs (i.e. for which IRQs to create interrupt servers).
		virtual Error ConfigureIRQs(DWORD mask);										// Mask is built like in the IMR register.

		// Create a new DEBI port.
		virtual Error CreateDEBIPort(WORD			addr,				// slave base address
											  BOOL			xirqWait,
											  BIT				xirqPol,
											  BOOL 			smart,			// smart or dumb slave
											  BOOL			slave16,			// 16 bit transfer support
											  int 			timeOutClks,	// -1 signals that timer should not be used
											  EndianSwap	swap,				// swapping order of bytes
											  BusStyle		busStyle,		// bus style (Intel or Motorola)
											  BOOL			asynch,			// port operates in parallel, not neccessarily
											                              // successfull
											  ByteWordIndexedInOutPort * __far &port);		// pointer to new port

		// Create a new DEBI DMA channel.
		virtual Error CreateDEBIDMA(WORD				addr,
											 BOOL				xirqWait,
											 BIT				xirqPol,
											 BOOL 			smart,
											 BOOL				slave16,
											 int 				timeOutClks,
											 EndianSwap 	swap,
											 BusStyle		busStyle,
											 DMAChannel		*	__far &channel);		// pointer to new DMA channel


		// Installation of a RPS program.
		virtual Error InstallRPSProgram(RPSProgram * program, TimeOutSelect toSel, DWORD videoTimeOut, DWORD pciTimeOut);

		// Removing of current RPS program (if there is any).
		virtual Error RemoveRPSProgram();


		// To be called in the ISR
		virtual void Interrupt(void);
		BOOL CheckInterrupt(void);
	};


#endif	// of ONLY_EXTERNAL_VISIBLE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\pcibrdge\specific\saa7145\scatdma.h ===
// FILE:      library\hardware\pcibridge\specific\saa7145\scatdma.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1996 Viona Development.  All Rights Reserved.
// CREATED:   10.05.96
//
// PURPOSE: The scattered DMA classes for the SAA7145.
//
// HISTORY:

#ifndef SCATDMA7145_H
#define SCATDMA7145_H

#include "..\common\prelude.h"
#include "..\lowlevel\dmabuffr.h"
#include "..\i22\fragtab.h"
#include "..\saa7145\saa7145.h"
#include "..\saa7145\rps7145.h"



class ScatteredBuffer7145
	{
	private:
		SAA7145 *saa7145;

		// DEBI port configuration for transfer
		DWORD debiCfg;
		WORD slaveAddress;
		BOOL increment;

		FragmentTableClass *fragTab;
		RPSProgram *program;
		BOOL writeBuffer;
		FPTR bufferPtr;
		DWORD bufferSize;

		HGLOBAL handle;

	public:
		ScatteredBuffer7145 (SAA7145 *saa7145, BOOL writeBuffer, BOOL xirqWait, BIT xirqPol,
		                     int timeOutClks,   // use -1 for no timeout (smart slaves only)
		                     WORD slaveAddress, BOOL smartSlave, BOOL slave16, BOOL increment,
		                     SAA7145::EndianSwap swap, SAA7145::BusStyle busStyle);
		virtual ~ScatteredBuffer7145 (void);

		Error PrepareBuffer (FPTR buffer, DWORD size);
		Error UnprepareBuffer (void);
		HGLOBAL GetHandle (void) {return handle;}

		Error SetBuffer (DWORD size);
		Error GetStartAddress (DWORD __far &start) {return program->GetPhysicalCodeAddress (start);}
		FPTR GetBufferPtr (void) {return bufferPtr;}
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\pcibrdge\specific\saa7146\saa7146.h ===
// FILE:			library\hardware\pcibridge\specific\saa7146\saa7146.h
// AUTHOR:		D. Heidrich, S. Herr
// COPYRIGHT:	(c) 1996 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		02.10.96
//
// PURPOSE:		Philips SAA 7146 management class.
//
// HISTORY:

#ifndef SAA7146_H
#define SAA7146_H

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"
#include "library\lowlevel\memmpdio.h"
#include "library\lowlevel\i2c.h"  
#include "library\lowlevel\intrctrl.h"
#include "library\lowlevel\dmachanl.h"

#include "saa7146r.h"
#include "rps7146.h"


// Error definitions.

#define	GNR_ILLEGAL_DMA_BUFFER_SIZE	MKERR(ERROR, DMA, PARAMS, 0x010)
	// The size of the dma buffer was not in the supported range

#define GNR_RPS_IN_USE						MKERR(ERROR, PCICONTROLLER, GENERAL, 0x01)
	// An RPS program was already installed


#ifndef ONLY_EXTERNAL_VISIBLE



class SAA7146IntServer : public InterruptServer
	{
	private:
		int intCtrlBit;   // bit in the interrupt control registers
		class SAA7146 *saa7146;

	protected:
		Error EnableInt (void);
		Error DisableInt (void);

	public:
		SAA7146IntServer (SAA7146 *saa7146, int intCtrlBit) {this->saa7146 = saa7146; this->intCtrlBit = intCtrlBit;}
	};



class SAA7146PageTable : public ContinuousDMABuffer
	{
	private:
		ScatteredDMABuffer *scatter;
		FPTR lockedBuffer;
		BOOL allocated;
		DWORD bufferStartOffset;
		DWORD alignedPhysical;
		FPTR alignedLogical;

	public:
		SAA7146PageTable (void);
		~SAA7146PageTable (void);

		Error CreateBufferTable (FPTR buffer, DWORD size);
		Error CreateBufferTableDownRound (FPTR buffer, DWORD size, BOOL wrapEnd);
		Error DeleteBufferTable (void);

		DWORD GetPageTablePhysical (void) {return alignedPhysical;}
		FPTR GetPageTableLogical (void) {return alignedLogical;}

		// This offset is needed as logical base address if the MMU is used.
		DWORD GetBufferStartOffset (void) {return bufferStartOffset;}
	};



// Special mixed indexed Byte/Word In/Out port.

class ByteWordIndexedInOutPort : public ByteIndexedInOutPort, public WordIndexedInOutPort
	{ };



class DEBIQueue;


class SAA7146
	{
	friend class SAA7146IntServer;

	public:
		// Possible RPS timeouts
		enum TimeOutSelect {TO_NONE, TO_PCI, TO_VSYNC, TO_BOTH};

		// RPS task number.
		enum RPSTaskNumber {RPSTASK_0=0, RPSTASK_1=1};

		// Video port selection.
		enum VideoPortSelection {VP_PORT_A, VP_PORT_B};

	private:
		RPSProgram *program[2];

	protected:
		DWORD intEnable;
		DWORD intStatus;

		DWORD initDD1, dataPort;

	public:
		MemoryMappedIO *mem;
		ByteInOutBus *i2c;

		CircularDMAChannel *audioInputDMA;

		// General IO pins
		BitIndexedInOutPort *genPPort;

		// One IRQ server for each IRQ
		InterruptServer *irqServers[32];

		DEBIQueue *debiQueue;

		SAA7146 (MemoryMappedIO *mem);
		~SAA7146(void);

		// Initialize the 7146 and create all the ports.
		virtual Error Initialize (void);

		virtual Error ResetDEBI (void);

		// Configure the general IO pins for input or output and their IRQ function.
		// "monitorBit" valid only for GPIO_MONITOR mode.
		virtual Error ConfigureGPIO (int gpio, GPIOMode7146 mode, int monitorBit);

		// Configure IC port.
		virtual Error ConfigureI2C (IICClockRate7146 clockRate);

		// Configure IRQs (i.e. for which IRQs to create interrupt servers).
		virtual Error ConfigureIRQs (DWORD mask);   // mask layout like in interrupt registers

		// Configure video port A or B.
		virtual Error ConfigureVideoPort (VideoPortSelection port, VideoPortData7146 dataDirection,
		                                  BOOL outputSAVandEAV, BOOL llcOutputMode, SyncIO7146 syncSel,
		                                  BOOL invertVSPol, BOOL invertHSPol, SyncDetect7146 edgeSel,
		                                  FieldInterrupt7146 fieldInt, BOOL invertFieldDetect);
		virtual Error ConfigureVideoPort (VideoPortSelection port, VideoPortData7146 dataDirection,
		                                  BOOL outputSAVandEAV, BOOL invertFieldDetect);
		BurstLength7146 Burst2Register (int burst);
		FifoThreshold7146 VThreshold2Register (int threshold);

		// Create a new DEBI port.
		virtual Error CreateDEBIPort (WORD slaveBaseAddr,
		                              BOOL slave16,			// 16 bit transfer support
		                              int timeOutClks,		// -1 signals that timer should not be used
		                              ByteSwap7146 swap,		// swapping order of bytes
		                              DEBIBusStyle7146 busStyle,	// bus style (Intel or Motorola)
		                              BOOL asynch,			// port operates in parallel; this might fail
		                              ByteWordIndexedInOutPort * __far &port);		// pointer to new port

		// Create a new DEBI DMA channel.
		virtual Error CreateDEBIDMA (WORD addr, BOOL slave16, int timeOutClks, ByteSwap7146 swap,
		                             DEBIBusStyle7146 busStyle, DMAChannel * __far &channel);		// pointer to new DMA channel


		// Installation of RPS program.
		virtual Error InstallRPSProgram (RPSProgram *program, RPSTaskNumber task, TimeOutSelect toSel,
		                                 VideoPortSelection videoPort, DWORD videoTimeOut, DWORD pciTimeOut);
		virtual Error RemoveRPSProgram (RPSTaskNumber task);
		virtual BOOL RPSIsInstalled (RPSTaskNumber task) {return program[task] != NULL;}


		// To be called in the ISR
		virtual void Interrupt (void);
		BOOL CheckInterrupt (void);
	};



#endif // ONLY_EXTERNAL_VISIBLE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\pcibrdge\specific\saa7146\scatdma.h ===
// FILE:      library\hardware\pcibridge\specific\saa7146\scatdma.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1996 Viona Development.  All Rights Reserved.
// CREATED:   02.10.96
//
// PURPOSE: The scattered DMA classes for the SAA7146.
//
// HISTORY:

#ifndef SCATDMA7146_H
#define SCATDMA7146_H

#include "library\common\prelude.h"
#include "library\lowlevel\dmabuffr.h"
#include "library\hardware\pcibrdge\specific\saa7146\saa7146.h"
#include "library\hardware\pcibrdge\specific\saa7146\rps7146.h"



class ScatteredBuffer7146
	{
	private:
		SAA7146 *saa7146;

		// DEBI port configuration for transfer.
		DWORD debiCfg;
		WORD slaveAddress;
		BOOL increment;

		SAA7146PageTable *pageTable;
		RPSProgram *program;
		BOOL writeBuffer;
		FPTR bufferPtr;
		DWORD bufferSize;

		HGLOBAL handle;

	public:
		ScatteredBuffer7146 (SAA7146 *saa7146, BOOL writeBuffer,
		                     int timeOutClks,   // use -1 for no timeout
		                     WORD slaveAddress, BOOL slave16, BOOL increment,
		                     ByteSwap7146 swap, DEBIBusStyle7146 busStyle);
		virtual ~ScatteredBuffer7146 (void);

		Error PrepareBuffer (FPTR buffer, DWORD size, BOOL playback);
		Error UnprepareBuffer (void);
		HGLOBAL GetHandle (void) {return handle;}

		struct PlayParametersRPS
			{
			DWORD start;        // physical start of block transfer RPS program
			DWORD mmu1, mmu2;   // physical patch addresses for MMU page table entries
			DWORD returnStart;  // physical start of second block
			DWORD blockSizeRPS;   // byte size of RPS program to transfer one block
			DWORD sizeEntry;    // back offset from return patch address to last size entry
			};

		Error SetBuffer (PlayParametersRPS parameters, DWORD size);
		Error GetStartAddress (DWORD __far &start) {return program->GetPhysicalCodeAddress (start);}
		DWORD GetBufferStartOffset (void) {return pageTable->GetBufferStartOffset ();}
		FPTR GetBufferPtr (void) {return (FPTR)((BYTE __huge *)bufferPtr + GetBufferStartOffset ());}

		Error GetPageTablePhysical (DWORD __far &physical);
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\pcibrdge\specific\zivapc\zivapcrg.h ===
//
// FILE:      library\hardware\pcibridge\specific\zivapc\zivarg.h
// AUTHOR:    S. Herr
// COPYRIGHT: (c) 1998 VIONA Development GmbH.  All Rights Reserved.
// CREATED:   17.03.98
//
// PURPOSE:   Register definitions for the ZiVA-PC chip
// 
// HISTORY:

#ifndef ZIVAPCRG_H
#define ZIVAPCRG_H                                            

#include "..\..\..\..\common\prelude.h"

//
// PCI Config space registers
//

#define ZIVAREG_CFG_COMMANDREG0	0x4
#define ZIVAIDX_CFG_IOS				0
#define ZIVAIDX_CFG_BUSM			2
#define ZIVAIDX_CFG_PEREN			6


#define ZIVAREG_CFG_COMMANDREG1	0x5
#define ZIVAIDX_CFG_SEREN			0

#define ZIVAREG_CFG_STATUS0		0x6

#define ZIVAREG_CFG_STATUS1		0x7
#define ZIVAIDX_CFG_PPERR			0
#define ZIVAIDX_CFG_DEVS			1, 2
#define ZIVAIDX_CFG_TABT			4
#define ZIVAIDX_CFG_MABT			5
#define ZIVAIDX_CFG_SERR			6
#define ZIVAIDX_CFG_PERR			7

#define ZIVAREG_CFG_REVISION		0x8

#define ZIVAREG_D_CFG_BASEADDR	0x10
#define ZIVAIDX_CFG_ADSS			0
#define ZIVAIDX_CFG_IOB				8, 24

#define ZIVAREG_W_CFG_SUBVENDOR	0x2c
#define ZIVAREG_W_CFG_SUBDEVICE	0x2e

#define ZIVAREG_CFG_PSCONT			0x44
#define ZIVAIDX_CFG_ZVEN			0
#define ZIVAIDX_CFG_DCNT			1
#define ZIVAIDX_CFG_CLKON			2
#define ZIVAIDX_CFG_DVDON			3
#define ZIVAIDX_CFG_PLLON			4
#define ZIVAIDX_CFG_SRESET			5
#define ZIVAIDX_CFG_BOFFZ			6
#define ZIVAIDX_CFG_PWROFF			7

#define ZIVAREG_CFG_MISCCONF		0x48
#define ZIVAIDX_CFG_ZVA3EN			0
#define ZIVAIDX_CFG_ZVAEN			1
#define ZIVAIDX_CFG_AUDCON			2, 2
#define ZIVAIDX_CFG_DMAM			4

#define ZIVAREG_CFG_DELAYTRANS	0x4c
#define ZIVAIDX_CFG_DTCYCLE		0, 4
#define ZIVAIDX_CFG_DTTO			7

#define ZIVAREG_CFG_PMCS0			0x64
#define ZIVAIDX_CFG_PWRS			0, 2

#define ZIVAREG_CFG_PMCS1			0x65
#define ZIVAIDX_CFG_PMEEN			0
#define ZIVAIDX_CFG_DSEL			1, 4
#define ZIVAIDX_CFG_DSCL			5, 2
#define ZIVAIDX_CFG_PMES			7

//
// Host I/O Area registers
//

#define ZIVAREG_IOCONT0				0x0
#define ZIVAIDX_MSTEN0				0
#define ZIVAIDX_MSTEN1				1
#define ZIVAIDX_MSTSEL				2
#define ZIVAIDX_STRNS				3
#define ZIVAIDX_AMUTE				6
#define ZIVAIDX_RSTA					7

#define ZIVAREG_IOCONT1				0x1
#define ZIVAIDX_STCIEN				0
#define ZIVAIDX_AMSTEN0				1
#define ZIVAIDX_AMSTEN1				2
#define ZIVAIDX_AMSTSEL				3

#define ZIVAREG_IOCONT2				0x2

#define ZIVAREG_IOCONT3				0x3
#define ZIVAIDX_I2SCN				0
#define ZIVAIDX_LRCN					1
#define ZIVAIDX_6CHEN				2
#define ZIVAIDX_AUDEN				3
#define ZIVAIDX_DAS					4, 4

#define ZIVAREG_IOINTF0				0x4
#define ZIVAIDX_VMSTI				0, 2
#define ZIVAIDX_VMSTABT				2
#define ZIVAIDX_VDI					3
#define ZIVAIDX_AMSTI				5, 2
#define ZIVAIDX_STCI					7

#define ZIVAIDX_W_VMSTI0			0
#define ZIVAIDX_W_VMSTI1			1
#define ZIVAIDX_W_VMSTI				0, 2
#define ZIVAIDX_W_VMSTABT			2
#define ZIVAIDX_W_VDI				3
#define ZIVAIDX_W_VSI				4
#define ZIVAIDX_W_AMSTI0			5
#define ZIVAIDX_W_AMSTI1			6
#define ZIVAIDX_W_AMSTI				5, 2
#define ZIVAIDX_W_STCI				7

#define ZIVAREG_IOINTF1				0x5
#define ZIVAIDX_VMBAT				0
#define ZIVAIDX_STCRFI				1
#define ZIVAIDX_AMSTABT				2
#define ZIVAIDX_AMBAT				3
#define ZIVAIDX_ATHRI				4
#define ZIVAIDX_AEMPI				5
#define ZIVAIDX_VTHRI				6
#define ZIVAIDX_VEMPI				7

#define ZIVAIDX_W_VMBAT				8
#define ZIVAIDX_W_STCRFI			9
#define ZIVAIDX_W_AMSTABT			0xa
#define ZIVAIDX_W_AMBAT				0xb
#define ZIVAIDX_W_ATHRI				0xc
#define ZIVAIDX_W_AEMPI				0xd
#define ZIVAIDX_W_VTHRI				0xe
#define ZIVAIDX_W_VEMPI				0xf


#define ZIVAREG_IODMAINT0			0x6
#define ZIVAIDX_VDMATHR				0, 3
#define ZIVAIDX_VDMACNT				4, 4

#define ZIVAREG_IODMAINT1			0x7
#define ZIVAIDX_ADMATHR				0, 3
#define ZIVAIDX_ADMACNT				4, 4

#define ZIVAREG_D_IOMADR			0x8

#define ZIVAREG_D_IOMTC				0xc

#define ZIVAREG_IOCPLT				0x10

#define ZIVAREG_IOCPCNT				0x11
#define ZIVAIDX_PSEL					0, 2
#define ZIVAIDX_CPCLR				2

#define ZIVAREG_AVCONT0				0x12
#define ZIVAIDX_FMSK					1
#define ZIVAIDX_FMSKEN				2

#define ZIVAREG_AVCONT1				0x13
#define ZIVAIDX_GPOUT				0, 2
#define ZIVAIDX_GPOUT0				0
#define ZIVAIDX_GPOUT1				1

#define ZIVAREG_IOVMODE				0x14
#define ZIVAIDX_VMOD					0, 4

#define ZIVAREG_IOHSCNT				0x15
#define ZIVAIDX_HSCNT				1, 7

#define ZIVAREG_IOVPCNT				0x16
#define ZIVAIDX_VPCNT				0, 4

#define ZIVAREG_IOPOL				0x17
#define ZIVAIDX_VSPOL				0
#define ZIVAIDX_HSPOL				1


#define ZIVAREG_IOI2C0				0x18

#define ZIVAREG_IOI2C1				0x19
                     
#define ZIVAREG_IOI2C2				0x1a
#define ZIVAIDX_RWZ					0
#define ZIVAIDX_DA					1, 7

#define ZIVAREG_IOI2C3				0x1b
#define ZIVAIDX_ACK					0
#define ZIVAIDX_NOSP					1
#define ZIVAIDX_NODT					2
#define ZIVAIDX_NOSA					3
#define ZIVAIDX_NODA					4
#define ZIVAIDX_NOST					5
#define ZIVAIDX_RES					6
#define ZIVAIDX_BUSY					7

#define ZIVAREG_IOI2CERR			0x1c
#define ZIVAIDX_I2CERR				0

#define ZIVAREG_IOEEPROM			0x20
#define ZIVAIDX_DW					0
#define ZIVAIDX_DR					1
#define ZIVAIDX_CS					2
#define ZIVAIDX_SK					3

#define ZIVAREG_IOPSCNT				0x22
#define ZIVAIDX_ASYN1				0
#define ZIVAIDX_ASYN2				1
#define ZIVAIDX_PSSCLR				2
#define ZIVAIDX_STMOD				3

#define ZIVAREG_RSTCONT				0x27
#define ZIVAIDX_PRST					2

#define ZIVAREG_D_STCCNT			0x28

#define ZIVAREG_STCCONT0			0x2c
#define ZIVAIDX_STCSTR				0
#define ZIVAIDX_STCCLR				1

#define ZIVAREG_STCCONT1			0x2d
#define ZIVAIDX_SINTS				0, 6
#define ZIVAIDX_STCTSTA				7

#define ZIVAREG_D_STCREF			0x3c
                  
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\pcibrdge\specific\saa7146\saa7146r.h ===
// FILE:			library\hardware\pcibridge\specific\saa7146\saa7146r.h
// AUTHOR:		D. Heidrich
// COPYRIGHT:	(c) 1996 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		01.10.96
//
// PURPOSE:		Register definitions for Philips SAA 7146.
//
// HISTORY:

#ifndef SAA7146R_H
#define SAA7146R_H

#include "library\common\prelude.h"



// 7146 byte swap values for all relevant registers

enum ByteSwap7146
	{
	SAA7146_NO_SWAP	= 0,
	SAA7146_SWAP2		= 1,
	SAA7146_SWAP4		= 2
	};



// Video FIFO 1
#define SAA7146REG_BASEODD1			0x00

#define SAA7146REG_BASEEVEN1			0x04

#define SAA7146REG_PROTADDR1			0x08

#define SAA7146REG_PITCH1				0x0c

#define SAA7146REG_BASEPAGE1			0x10
#define SAA7146IDX_PAGE1				12, 20
#define SAA7146REG_PAGE1				SAA7146REG_BASEPAGE1, SAA7146IDX_PAGE1
#define SAA7146IDX_ME1					11
#define SAA7146REG_ME1					SAA7146REG_BASEPAGE1, SAA7146IDX_ME1
#define SAA7146IDX_LIMIT1				4, 4
#define SAA7146REG_LIMIT1				SAA7146REG_BASEPAGE1, SAA7146IDX_LIMIT1
#define SAA7146IDX_PV1					3
#define SAA7146REG_PV1					SAA7146REG_BASEPAGE1, SAA7146IDX_PV1
#define SAA7146IDX_SWAP1				0, 2
#define SAA7146REG_SWAP1				SAA7146REG_BASEPAGE1, SAA7146IDX_SWAP1

#define SAA7146REG_NUM_LINE_BYTE1	0x14
#define SAA7146IDX_NUMLINES1			16, 12
#define SAA7146REG_NUMLINES1			SAA7146REG_NUM_LINE_BYTE1, SAA7146IDX_NUMLINES1
#define SAA7146IDX_NUMBYTES1			0, 12
#define SAA7146REG_NUMBYTES1			SAA7146REG_NUM_LINE_BYTE1, SAA7146IDX_NUMBYTES1



// Video FIFO 2
#define SAA7146REG_BASEODD2			0x18

#define SAA7146REG_BASEEVEN2			0x1c

#define SAA7146REG_PROTADDR2			0x20

#define SAA7146REG_PITCH2				0x24

#define SAA7146REG_BASEPAGE2			0x28
#define SAA7146IDX_PAGE2				12, 20
#define SAA7146REG_PAGE2				SAA7146REG_BASEPAGE2, SAA7146IDX_PAGE2
#define SAA7146IDX_ME2					11
#define SAA7146REG_ME2					SAA7146REG_BASEPAGE2, SAA7146IDX_ME2
#define SAA7146IDX_LIMIT2				4, 4
#define SAA7146REG_LIMIT2				SAA7146REG_BASEPAGE2, SAA7146IDX_LIMIT2
#define SAA7146IDX_PV2					3
#define SAA7146REG_PV2					SAA7146REG_BASEPAGE2, SAA7146IDX_PV2
#define SAA7146IDX_RW2					2
#define SAA7146REG_RW2					SAA7146REG_BASEPAGE2, SAA7146IDX_RW2
#define SAA7146IDX_SWAP2				0, 2
#define SAA7146REG_SWAP2				SAA7146REG_BASEPAGE2, SAA7146IDX_SWAP2

#define SAA7146REG_NUM_LINE_BYTE2	0x2c
#define SAA7146IDX_NUMLINES2			16, 12
#define SAA7146REG_NUMLINES2			SAA7146REG_NUM_LINE_BYTE2, SAA7146IDX_NUMLINES2
#define SAA7146IDX_NUMBYTES2			0, 12
#define SAA7146REG_NUMBYTES2			SAA7146REG_NUM_LINE_BYTE2, SAA7146IDX_NUMBYTES2



// Video FIFO 3
#define SAA7146REG_BASEODD3			0x30

#define SAA7146REG_BASEEVEN3			0x34

#define SAA7146REG_PROTADDR3			0x38

#define SAA7146REG_PITCH3				0x3c

#define SAA7146REG_BASEPAGE3			0x40
#define SAA7146IDX_PAGE3				12, 20
#define SAA7146REG_PAGE3				SAA7146REG_BASEPAGE3, SAA7146IDX_PAGE3
#define SAA7146IDX_ME3					11
#define SAA7146REG_ME3					SAA7146REG_BASEPAGE3, SAA7146IDX_ME3
#define SAA7146IDX_LIMIT3				4, 4
#define SAA7146REG_LIMIT3				SAA7146REG_BASEPAGE3, SAA7146IDX_LIMIT3
#define SAA7146IDX_PV3					3
#define SAA7146REG_PV3					SAA7146REG_BASEPAGE3, SAA7146IDX_PV3
#define SAA7146IDX_RW3					2
#define SAA7146REG_RW3					SAA7146REG_BASEPAGE3, SAA7146IDX_RW3
#define SAA7146IDX_SWAP3				0, 2
#define SAA7146REG_SWAP3				SAA7146REG_BASEPAGE3, SAA7146IDX_SWAP3

#define SAA7146REG_NUM_LINE_BYTE3	0x44
#define SAA7146IDX_NUMLINES3			16, 12
#define SAA7146REG_NUMLINES3			SAA7146REG_NUM_LINE_BYTE3, SAA7146IDX_NUMLINES3
#define SAA7146IDX_NUMBYTES3			0, 12
#define SAA7146REG_NUMBYTES3			SAA7146REG_NUM_LINE_BYTE3, SAA7146IDX_NUMBYTES3



// Arbitration control
#define SAA7146REG_PCI_BT_V			0x48
#define SAA7146IDX_BURSTDEBI			26, 3
#define SAA7146REG_BURSTDEBI			SAA7146REG_PCI_BT_V, SAA7146IDX_BURSTDEBI
#define SAA7146IDX_BURST3				18, 3
#define SAA7146REG_BURST3				SAA7146REG_PCI_BT_V, SAA7146IDX_BURST3
#define SAA7146IDX_THRESH3				16, 2
#define SAA7146REG_THRESH3				SAA7146REG_PCI_BT_V, SAA7146IDX_THRESH3
#define SAA7146IDX_BURST2				10, 3
#define SAA7146REG_BURST2				SAA7146REG_PCI_BT_V, SAA7146IDX_BURST2
#define SAA7146IDX_THRESH2				 8, 2
#define SAA7146REG_THRESH2				SAA7146REG_PCI_BT_V, SAA7146IDX_THRESH2
#define SAA7146IDX_BURST1				 2, 3
#define SAA7146REG_BURST1				SAA7146REG_PCI_BT_V, SAA7146IDX_BURST1
#define SAA7146IDX_THRESH1				 0, 2
#define SAA7146REG_THRESH1				SAA7146REG_PCI_BT_V, SAA7146IDX_THRESH1

#define SAA7146REG_PCI_BT_A			0x4c
#define SAA7146IDX_BURSTA1_IN			26, 3
#define SAA7146REG_BURSTA1_IN			SAA7146REG_PCI_BT_A, SAA7146IDX_BURSTA1_IN
#define SAA7146IDX_THRESHA1_IN		24, 2
#define SAA7146REG_THRESHA1_IN		SAA7146REG_PCI_BT_A, SAA7146IDX_THRESHA1_IN
#define SAA7146IDX_BURSTA1_OUT		18, 3
#define SAA7146REG_BURSTA1_OUT		SAA7146REG_PCI_BT_A, SAA7146IDX_BURSTA1_OUT
#define SAA7146IDX_THRESHA1_OUT		16, 2
#define SAA7146REG_THRESHA1_OUT		SAA7146REG_PCI_BT_A, SAA7146IDX_THRESHA1_OUT
#define SAA7146IDX_BURSTA2_IN			10, 3
#define SAA7146REG_BURSTA2_IN			SAA7146REG_PCI_BT_A, SAA7146IDX_BURSTA2_IN
#define SAA7146IDX_THRESHA2_IN		 8, 2
#define SAA7146REG_THRESHA2_IN		SAA7146REG_PCI_BT_A, SAA7146IDX_THRESHA2_IN
#define SAA7146IDX_BURSTA2_OUT		 2, 3
#define SAA7146REG_BURSTA2_OUT		SAA7146REG_PCI_BT_A, SAA7146IDX_BURSTA2_OUT
#define SAA7146IDX_THRESHA2_OUT		 0, 2
#define SAA7146REG_THRESHA2_OUT		SAA7146REG_PCI_BT_A, SAA7146IDX_THRESHA2_OUT

enum FifoThreshold7146
	{
	SAA7146_VTHRESH_4		= 0,
	SAA7146_VTHRESH_8		= 1,
	SAA7146_VTHRESH_16	= 2,
	SAA7146_VTHRESH_32	= 3,
	SAA7146_ATHRESH_1		= 0,
	SAA7146_ATHRESH_4		= 1,
	SAA7146_ATHRESH_8		= 2,
	SAA7146_ATHRESH_16	= 3
	};

enum BurstLength7146
	{
	SAA7146_BURST_1	= 0,
	SAA7146_BURST_2	= 1,
	SAA7146_BURST_4	= 2,
	SAA7146_BURST_8	= 3,
	SAA7146_BURST_16	= 4,
	SAA7146_BURST_32	= 5,
	SAA7146_BURST_64	= 6,
	SAA7146_BURST_128	= 7
	};



// Initial settings of DD1 port
#define SAA7146REG_INIT_DD1			0x50
#define SAA7146IDX_LLC_A				31
#define SAA7146REG_LLC_A				SAA7146REG_INIT_DD1, SAA7146IDX_LLC_A
#define SAA7146IDX_SIO_A				29, 2
#define SAA7146REG_SIO_A				SAA7146REG_INIT_DD1, SAA7146IDX_SIO_A
#define SAA7146IDX_PVO_A				28
#define SAA7146REG_PVO_A				SAA7146REG_INIT_DD1, SAA7146IDX_PVO_A
#define SAA7146IDX_PHO_A				27
#define SAA7146REG_PHO_A				SAA7146REG_INIT_DD1, SAA7146IDX_PHO_A
#define SAA7146IDX_SYNC_A				24, 3
#define SAA7146REG_SYNC_A				SAA7146REG_INIT_DD1, SAA7146IDX_SYNC_A
#define SAA7146IDX_FIDESA				22, 2
#define SAA7146REG_FIDESA				SAA7146REG_INIT_DD1, SAA7146IDX_FIDESA
#define SAA7146IDX_LLC_B				15
#define SAA7146REG_LLC_B				SAA7146REG_INIT_DD1, SAA7146IDX_LLC_B
#define SAA7146IDX_SIO_B				13, 2
#define SAA7146REG_SIO_B				SAA7146REG_INIT_DD1, SAA7146IDX_SIO_B
#define SAA7146IDX_PVO_B				12
#define SAA7146REG_PVO_B				SAA7146REG_INIT_DD1, SAA7146IDX_PVO_B
#define SAA7146IDX_PHO_B				11
#define SAA7146REG_PHO_B				SAA7146REG_INIT_DD1, SAA7146IDX_PHO_B
#define SAA7146IDX_SYNC_B				 8, 3
#define SAA7146REG_SYNC_B				SAA7146REG_INIT_DD1, SAA7146IDX_SYNC_B
#define SAA7146IDX_FIDESB				 6, 2
#define SAA7146REG_FIDESB				SAA7146REG_INIT_DD1, SAA7146IDX_FIDESB

// LLC values
#define SAA7146_LLC_INPUT				0
#define SAA7146_LLC_OUTPUT				1

// Sync IO values
enum SyncIO7146
	{
	SAA7146_HS_VS_INPUT		= 0,
	SAA7146_HS_VS_HPS			= 1,   // HS and VS are those of HPS syncs
	SAA7146_HS_VS_FIELD_MEM	= 2,   // HS and VS for field memory mode
	SAA7146_HS_VS_BRS			= 3    // HS and VS are those of BRS syncs
	};

// Polarity values
#define SAA7146_POL_DIRECT				0   // direct polarity
#define SAA7146_POL_INVERTED			1   // inverted polarity

// Sync edge and field detect values
enum SyncDetect7146
	{
	SAA7146_SYNC_VRISE_FDIRECT		= 0,
	SAA7146_SYNC_VFALL_FDIRECT		= 1,
	SAA7146_SYNC_VRISE_FFORCED		= 2,
	SAA7146_SYNC_VFALL_FFORCED		= 3,
	SAA7146_SYNC_VRISE_FFREE		= 4,
	SAA7146_SYNC_VFALL_FFREE		= 5,
	SAA7146_SYNC_VFRAME_FDIRECT	= 6,
	SAA7146_SYNC_SAV_EAV				= 7
	};

// Field identification interrupt values
enum FieldInterrupt7146
	{
	SAA7146_FID_INT_NONE		= 0,
	SAA7146_FID_INT_RISING	= 1,
	SAA7146_FID_INT_FALLING	= 2,
	SAA7146_FID_INT_BOTH		= 3
	};



// Video data stream handling
#define SAA7146REG_DATA_PORT			0x54
#define SAA7146IDX_VID_A				30, 2
#define SAA7146REG_VID_A				SAA7146REG_DATA_PORT, SAA7146IDX_VID_A
#define SAA7146IDX_Y8C_A				29
#define SAA7146REG_Y8C_A				SAA7146REG_DATA_PORT, SAA7146IDX_Y8C_A
#define SAA7146IDX_PFID_A				26
#define SAA7146REG_PFID_A				SAA7146REG_DATA_PORT, SAA7146IDX_PFID_A
#define SAA7146IDX_VID_B				14, 2
#define SAA7146REG_VID_B				SAA7146REG_DATA_PORT, SAA7146IDX_VID_B
#define SAA7146IDX_Y8C_B				13
#define SAA7146REG_Y8C_B				SAA7146REG_DATA_PORT, SAA7146IDX_Y8C_B
#define SAA7146IDX_PFID_B				10
#define SAA7146REG_PFID_B				SAA7146REG_DATA_PORT, SAA7146IDX_PFID_B

// Video port data selection values
enum VideoPortData7146
	{
	SAA7146_PORT_INPUT			= 0,
	SAA7146_PORT_OUT_FROM_BRS	= 2,
	SAA7146_PORT_OUT_FROM_HPS	= 3
	};

// Y8C code values
#define SAA7146_Y8C_NO_SAV_EAV		0
#define SAA7146_Y8C_WITH_SAV_EAV		1

// Polarity of field detection result
#define SAA7146_PORT_FID_DIRECT		0
#define SAA7146_PORT_FID_INVERTED	1



// BRS control
#define SAA7146REG_BRS_CTRL1			0x58
#define SAA7146IDX_BRSDATASEL			30, 2
#define SAA7146REG_BRSDATASEL			SAA7146REG_BRS_CTRL1, SAA7146IDX_BRSDATASEL
#define SAA7146IDX_BRSSYNCSEL			29
#define SAA7146REG_BRSSYNCSEL			SAA7146REG_BRS_CTRL1, SAA7146IDX_BRSSYNCSEL
#define SAA7146IDX_BYO					19, 10
#define SAA7146REG_BYO					SAA7146REG_BRS_CTRL1, SAA7146IDX_BYO
#define SAA7146IDX_BRS_V				17, 2
#define SAA7146REG_BRS_V				SAA7146REG_BRS_CTRL1, SAA7146IDX_BRS_V
#define SAA7146IDX_BXO					 7, 10
#define SAA7146REG_BXO					SAA7146REG_BRS_CTRL1, SAA7146IDX_BXO
#define SAA7146IDX_BRS_H				 4, 3
#define SAA7146REG_BRS_H				SAA7146REG_BRS_CTRL1, SAA7146IDX_BRS_H
#define SAA7146IDX_READMODE			 2, 2
#define SAA7146REG_READMODE			SAA7146REG_BRS_CTRL1, SAA7146IDX_READMODE
#define SAA7146IDX_PCI_FORMAT			 0, 2
#define SAA7146REG_PCI_FORMAT			SAA7146REG_BRS_CTRL1, SAA7146IDX_PCI_FORMAT

// BRS data selection values
enum BRSSource7146
	{
	SAA7146_BRS_SRC_A		= 0,
	SAA7146_BRS_SRC_B		= 1,
	SAA7146_BRS_SRC_MEM	= 3
	};

// BRS sync selection values
#define SAA7146_BRS_SYNC_FROM_A		0
#define SAA7146_BRS_SYNC_FROM_B		1

// BRS scaling factor values (vertical: 8 not available)
enum BRSScaleFactor7146
	{
	SAA7146_BRS_SCALE_NONE	= 0,
	SAA7146_BRS_SCALE_BY2	= 1,
	SAA7146_BRS_SCALE_BY4	= 3,
	SAA7146_BRS_SCALE_BY8	= 7
	};

// BRS read mode values
enum BRSReadMode7146
	{
	SAA7146_BRS_LINE_MODE	= 0,
	SAA7146_BRS_FIELD_MODE	= 1,
	SAA7146_BRS_DIRECT_MODE	= 2,
	SAA7146_BRS_GREY_MODE	= 3
	};

// BRS PCI format values
enum BRSPCIFormat7146
	{
	SAA7146_BRS_YUV16				= 0,
	SAA7146_BRS_Y8_LUMINANCE	= 1,
	SAA7146_BRS_Y2					= 2,
	SAA7146_BRS_Y1					= 3
	};



// HPS control
#define SAA7146REG_HPS_CTRL			0x5c
#define SAA7146IDX_HPSDATASEL			30, 2
#define SAA7146IDX_MIRROR				29
#define SAA7146IDX_HPSSYNCSEL			28
#define SAA7146IDX_HYO					12, 12

enum HPSSource7146   // HPS data source
	{
	SAA7146_HPS_SRC_A		= 0,
	SAA7146_HPS_SRC_B		= 1,
	SAA7146_HPS_SRC_YB	= 2,
	SAA7146_HPS_SRC_YA	= 3
	};

enum HPSSyncs7146   // HPS sync selection
	{
	SAA7146_HPS_A_SYNCS	= 0,
	SAA7146_HPS_B_SYNCS	= 1
	};



// HPS vertical scale
#define SAA7146REG_HPS_VERTSCALE		0x60
#define SAA7146IDX_YACM					31
#define SAA7146IDX_YSCI					21, 10
#define SAA7146IDX_YACL					15, 6
#define SAA7146IDX_YPO					 8, 7
#define SAA7146IDX_YPE					 1, 7



// HPS vertical scale & gain (refer to 7146 specification for programming)
#define SAA7146REG_HPS_VERTGAIN		0x64
#define SAA7146IDX_PFY					28, 4
#define SAA7146IDX_PFUV					24, 4
#define SAA7146IDX_DCGY					16, 3
#define SAA7146IDX_CYA					 8, 8
#define SAA7146IDX_CYB					 0, 8



// HPS prescale (refer to 7146 specification for programming)
#define SAA7146REG_HPS_PRESCALE		0x68
#define SAA7146IDX_DCGX					27, 3
#define SAA7146IDX_XPSC					18, 6
#define SAA7146IDX_XACM					17
#define SAA7146IDX_CXY					 8, 8
#define SAA7146IDX_CXUV					 0, 8



// HPS fine scale (refer to 7146 specification for programming)
#define SAA7146REG_HPS_FINE_SCALE	0x6c
#define SAA7146IDX_XIM					31
#define SAA7146IDX_XP					24, 7
#define SAA7146IDX_XSCI					12, 12
#define SAA7146IDX_HXO					 0, 12



// BCS control
#define SAA7146REG_BCS_CTRL			0x70
#define SAA7146IDX_BRIG					24, 8
#define SAA7146IDX_CONT					16, 8
#define SAA7146IDX_SATN					 0, 8



// Chroma key range
#define SAA7146REG_CHROMA_KEY			0x74
#define SAA7146IDX_VL					24, 8
#define SAA7146IDX_VU					16, 8
#define SAA7146IDX_UL					 8, 8
#define SAA7146IDX_UU					 0, 8



// HPS output format and clip control
#define SAA7146REG_HPS_OUTPUT			0x78
#define SAA7146IDX_MATRIX				30, 2
#define SAA7146IDX_OUTFORMAT			24, 4
#define SAA7146IDX_SHIFT				17
#define SAA7146IDX_DITHER				16
#define SAA7146IDX_CLIPCK				 8, 2
#define SAA7146IDX_CLIPMODE			 4, 3
#define SAA7146IDX_RECINTERL			 3
#define SAA7146IDX_CLIPOUT				 0, 2

// YUV to RGB conversion values
#define SAA7146_NO_RGB					0
#define SAA7146_RGB_LINEAR				2
#define SAA7146_RGB_GAMMA				3

// Output format values
#define SAA7146_YUV422					0
#define SAA7146_YUV444					1
#define SAA7146_YUV411					3
#define SAA7146_YUV2						4
#define SAA7146_Y8_MONOCHROME			6
#define SAA7146_YUV8						7
#define SAA7146_YUV444_DECOMPOSED	8
#define SAA7146_YUV422_DECOMPOSED	9
#define SAA7146_YUV420_DECOMPOSED	10
#define SAA7146_YUV9_DECOMPOSED		11
#define SAA7146_Y1						13
#define SAA7146_Y2						14
#define SAA7146_YUV1						15
#define SAA7146_RGB565					0
#define SAA7146_RGB24					1
#define SAA7146_RGB32					2
#define SAA7146_RGB1555					3
#define SAA7146_RGB5515					4
#define SAA7146_RGB332					7

// Chroma key clipping values
#define SAA7146_NO_CK_ALPHA			0
#define SAA7146_NO_CK_INVERT_ALPHA	1
#define SAA7146_CLIP_CK					2
#define SAA7146_CLIP_INVERT_CK		3

// Clipping with DMA2 values
#define SAA7146_NO_CLIP					0
#define SAA7146_CLIP_ALPHA				1
#define SAA7146_CLIP_RECTS				4
#define SAA7146_CLIP_INVERT_RECTS	5
#define SAA7146_CLIP_MASK				6
#define SAA7146_CLIP_INVERT_MASK		7

// Clipping status output values
#define SAA7146_NO_CLIP_OUTPUT		0
#define SAA7146_WRITE_CHROMA			1
#define SAA7146_WRITE_USED_MASK		2
#define SAA7146_WRITE_APPLIED			3



// DEBI configuration
#define SAA7146REG_DEBI_CONFIG		0x7c
#define SAA7146IDX_XIRQ_EN				31
#define SAA7146IDX_XRESUME				30
#define SAA7146IDX_FAST					28
#define SAA7146IDX_TIMEOUT				22, 4
#define SAA7146IDX_SWAP					20, 2
#define SAA7146IDX_SLAVE16				19
#define SAA7146IDX_INCREMENT			18
#define SAA7146IDX_INTEL				17
#define SAA7146IDX_TIEN					16

// DEBI bus style values
enum DEBIBusStyle7146
	{
	SAA7146_MOTOROLA_STYLE	= 0,
	SAA7146_INTEL_STYLE		= 1
	};

// DEBI command
#define SAA7146REG_DEBI_COMMAND		0x80
#define SAA7146IDX_BLOCKLENGTH		17, 15
#define SAA7146IDX_WRITE_N				16
#define SAA7146IDX_A16_IN				 0, 16

// DEBI page table
#define SAA7146REG_DEBI_PAGE			0x84
#define SAA7146IDX_PAGE_EN				11

// DEBI data and address pointer
#define SAA7146REG_DEBI_AD				0x88



// IC transfer
#define SAA7146REG_IICTFR				0x8c
#define SAA7146IDX_BYTE2				24, 8
#define SAA7146IDX_BYTE1				16, 8
#define SAA7146IDX_BYTE0				 8, 8
#define SAA7146IDX_ATTR2				 6, 2
#define SAA7146IDX_ATTR1				 4, 2
#define SAA7146IDX_ATTR0				 2, 2
#define SAA7146IDX_ATTR0				 2, 2

#define SAA7146IDX_I2CBYTE(x)			(8*x+8), 8

// Attribute values
#define SAA7146_IICA_START				3
#define SAA7146_IICA_CONT				2
#define SAA7146_IICA_STOP				1
#define SAA7146_IICA_NOP				0

// Read/write bit
#define SAA7146_IIC_WRITE				0
#define SAA7146_IIC_READ				1

// IC status
#define SAA7146REG_IICSTA				0x90
#define SAA7146IDX_IICCC				 8, 3
#define SAA7146IDX_SPERR				 6
#define SAA7146IDX_APERR				 5
#define SAA7146IDX_DTERR				 4
#define SAA7146IDX_DRERR				 3
#define SAA7146IDX_AL					 2
#define SAA7146IDX_ERR					 1   // also available in IICTFR
#define SAA7146IDX_BUSY					 0   // also available in IICTFR

// Bit rate selection values
enum IICClockRate7146
	{
	SAA7146_IIC_CLK_120	= 0,
	SAA7146_IIC_CLK_3200	= 1,
	SAA7146_IIC_CLK_80	= 2,
	SAA7146_IIC_CLK_60	= 3,
	SAA7146_IIC_CLK_480	= 4,
	SAA7146_IIC_CLK_6400	= 5,
	SAA7146_IIC_CLK_320	= 6,
	SAA7146_IIC_CLK_240	= 7
	};



// Audio 1 input DMA control
#define SAA7146REG_BASEA1_IN			0x94

#define SAA7146REG_PROTA1_IN			0x98

#define SAA7146REG_BASEPAGEA1_IN		0x9c
#define SAA7146IDX_PAGEA1_IN			12, 20
#define SAA7146REG_PAGEA1_IN			SAA7146REG_BASEPAGEA1_IN, SAA7146IDX_PAGEA1_IN
#define SAA7146IDX_MEA1_IN				11
#define SAA7146REG_MEA1_IN				SAA7146REG_BASEPAGEA1_IN, SAA7146IDX_MEA1_IN
#define SAA7146IDX_LIMITA1_IN			4, 4
#define SAA7146REG_LIMITA1_IN			SAA7146REG_BASEPAGEA1_IN, SAA7146IDX_LIMITA1_IN
#define SAA7146IDX_PVA1_IN				3
#define SAA7146REG_PVA1_IN				SAA7146REG_BASEPAGEA1_IN, SAA7146IDX_PVA1_IN



// Audio 1 output DMA control
#define SAA7146REG_BASEA1_OUT			0xa0

#define SAA7146REG_PROTA1_OUT			0xa4

#define SAA7146REG_BASEPAGEA1_OUT	0xa8
#define SAA7146IDX_PAGEA1_OUT			12, 20
#define SAA7146REG_PAGEA1_OUT			SAA7146REG_BASEPAGEA1_OUT, SAA7146IDX_PAGEA1_OUT
#define SAA7146IDX_MEA1_OUT			11
#define SAA7146REG_MEA1_OUT			SAA7146REG_BASEPAGEA1_OUT, SAA7146IDX_MEA1_OUT
#define SAA7146IDX_LIMITA1_OUT		4, 4
#define SAA7146REG_LIMITA1_OUT		SAA7146REG_BASEPAGEA1_OUT, SAA7146IDX_LIMITA1_OUT
#define SAA7146IDX_PVA1_OUT			3
#define SAA7146REG_PVA1_OUT			SAA7146REG_BASEPAGEA1_OUT, SAA7146IDX_PVA1_OUT



// Audio 2 input DMA control
#define SAA7146REG_BASEA2_IN			0xac

#define SAA7146REG_PROTA2_IN			0xb0

#define SAA7146REG_BASEPAGEA2_IN		0xb4
#define SAA7146IDX_PAGEA2_IN			12, 20
#define SAA7146REG_PAGEA2_IN			SAA7146REG_BASEPAGEA2_IN, SAA7146IDX_PAGEA2_IN
#define SAA7146IDX_MEA2_IN				11
#define SAA7146REG_MEA2_IN				SAA7146REG_BASEPAGEA2_IN, SAA7146IDX_MEA2_IN
#define SAA7146IDX_LIMITA2_IN			4, 4
#define SAA7146REG_LIMITA2_IN			SAA7146REG_BASEPAGEA2_IN, SAA7146IDX_LIMITA2_IN
#define SAA7146IDX_PVA2_IN				3
#define SAA7146REG_PVA2_IN				SAA7146REG_BASEPAGEA2_IN, SAA7146IDX_PVA2_IN



// Audio 2 output DMA control
#define SAA7146REG_BASEA2_OUT			0xb8

#define SAA7146REG_PROTA2_OUT			0xbc

#define SAA7146REG_BASEPAGEA2_OUT	0xc0
#define SAA7146IDX_PAGEA2_OUT			12, 20
#define SAA7146REG_PAGEA2_OUT			SAA7146REG_BASEPAGEA2_OUT, SAA7146IDX_PAGEA2_OUT
#define SAA7146IDX_MEA2_OUT			11
#define SAA7146REG_MEA2_OUT			SAA7146REG_BASEPAGEA2_OUT, SAA7146IDX_MEA2_OUT
#define SAA7146IDX_LIMITA2_OUT		4, 4
#define SAA7146REG_LIMITA2_OUT		SAA7146REG_BASEPAGEA2_OUT, SAA7146IDX_LIMITA2_OUT
#define SAA7146IDX_PVA2_OUT			3
#define SAA7146REG_PVA2_OUT			SAA7146REG_BASEPAGEA2_OUT, SAA7146IDX_PVA2_OUT



// RPS page registers
#define SAA7146REG_RPS_PAGE_REG0		0xc4
#define SAA7146IDX_RPS_PAGE0			12, 20
#define SAA7146REG_RPS_PAGE0			SAA7146REG_RPS_PAGE_REG0, SAA7146IDX_RPS_PAGE0
#define SAA7146IDX_ERPSP0				 0
#define SAA7146REG_ERPSP0				SAA7146REG_RPS_PAGE_REG0, SAA7146IDX_ERPSP0

#define SAA7146REG_RPS_PAGE_REG1		0xc8
#define SAA7146IDX_RPS_PAGE1			12, 20
#define SAA7146REG_RPS_PAGE1			SAA7146REG_RPS_PAGE_REG1, SAA7146IDX_RPS_PAGE1
#define SAA7146IDX_ERPSP1				 0
#define SAA7146REG_ERPSP1				SAA7146REG_RPS_PAGE_REG1, SAA7146IDX_ERPSP1



// HBI threshold
#define SAA7146REG_RPS_THRESH0		0xcc
#define SAA7146IDX_TLCS0				28
#define SAA7146REG_TLCS0				SAA7146REG_RPS_THRESH0, SAA7146IDX_TLCS0
#define SAA7146IDX_TLCT0				16, 12
#define SAA7146REG_TLCT0				SAA7146REG_RPS_THRESH0, SAA7146IDX_TLCT0
#define SAA7146IDX_SLCS0				12
#define SAA7146REG_SLCS0				SAA7146REG_RPS_THRESH0, SAA7146IDX_SLCS0
#define SAA7146IDX_SLCT0				 0, 12
#define SAA7146REG_SLCT0				SAA7146REG_RPS_THRESH0, SAA7146IDX_SLCT0

#define SAA7146REG_RPS_THRESH1		0xd0
#define SAA7146IDX_TLCS1				28
#define SAA7146REG_TLCS1				SAA7146REG_RPS_THRESH1, SAA7146IDX_TLCS1
#define SAA7146IDX_TLCT1				16, 12
#define SAA7146REG_TLCT1				SAA7146REG_RPS_THRESH1, SAA7146IDX_TLCT1
#define SAA7146IDX_SLCS1				12
#define SAA7146REG_SLCS1				SAA7146REG_RPS_THRESH1, SAA7146IDX_SLCS1
#define SAA7146IDX_SLCT1				 0, 12
#define SAA7146REG_SLCT1				SAA7146REG_RPS_THRESH1, SAA7146IDX_SLCT1



// RPS time out
#define SAA7146REG_RPS_TOV0			0xd4
#define SAA7146IDX_V_TO0				31
#define SAA7146REG_V_TO0				SAA7146REG_RPS_TOV0, SAA7146IDX_V_TO0
#define SAA7146IDX_C_TO0				30
#define SAA7146REG_C_TO0				SAA7146REG_RPS_TOV0, SAA7146IDX_C_TO0
#define SAA7146IDX_V_ABN0				29
#define SAA7146REG_V_ABN0				SAA7146REG_RPS_TOV0, SAA7146IDX_V_ABN0
#define SAA7146IDX_VSYNC_CNT0			24, 4
#define SAA7146REG_VSYNC_CNT0			SAA7146REG_RPS_TOV0, SAA7146IDX_VSYNC_CNT0
#define SAA7146IDX_PCI_CNT0			0, 24
#define SAA7146REG_PCI_CNT0			SAA7146REG_RPS_TOV0, SAA7146IDX_PCI_CNT0

#define SAA7146REG_RPS_TOV1			0xd8
#define SAA7146IDX_V_TO1				31
#define SAA7146REG_V_TO1				SAA7146REG_RPS_TOV1, SAA7146IDX_V_TO1
#define SAA7146IDX_C_TO1				30
#define SAA7146REG_C_TO1				SAA7146REG_RPS_TOV1, SAA7146IDX_C_TO1
#define SAA7146IDX_V_ABN1				29
#define SAA7146REG_V_ABN1				SAA7146REG_RPS_TOV1, SAA7146IDX_V_ABN1
#define SAA7146IDX_VSYNC_CNT1			24, 4
#define SAA7146REG_VSYNC_CNT1			SAA7146REG_RPS_TOV1, SAA7146IDX_VSYNC_CNT1
#define SAA7146IDX_PCI_CNT1			0, 24
#define SAA7146REG_PCI_CNT1			SAA7146REG_RPS_TOV1, SAA7146IDX_PCI_CNT1

// Which port to get RPS VSYNC time out from.
#define SAA7146_RPS_VTO_FROM_B		0
#define SAA7146_RPS_VTO_FROM_A		1



// Interrupt enable
#define SAA7146REG_IER					0xdc

// Interrupt and primary status bits
#define SAA7146IDX_PPEF					31
#define SAA7146IDX_PABO					30
#define SAA7146IDX_PPED					29
#define SAA7146IDX_RPS_I1				28
#define SAA7146IDX_RPS_I0				27
#define SAA7146IDX_RPS_LATE1			26
#define SAA7146IDX_RPS_LATE0			25
#define SAA7146IDX_RPS_E1				24
#define SAA7146IDX_RPS_E0				23
#define SAA7146IDX_RPS_TO1				22
#define SAA7146IDX_RPS_TO0				21
#define SAA7146IDX_UPLD					20
#define SAA7146IDX_DEBI_S				19
#define SAA7146IDX_DEBI_E				18
#define SAA7146IDX_IIC_S				17
#define SAA7146IDX_IIC_E				16
#define SAA7146IDX_A2_IN				15
#define SAA7146IDX_A2_OUT				14
#define SAA7146IDX_A1_IN				13
#define SAA7146IDX_A1_OUT				12
#define SAA7146IDX_AFOU					11
#define SAA7146IDX_V_PE					10
#define SAA7146IDX_VFOU					 9
#define SAA7146IDX_FIDA					 8
#define SAA7146IDX_FIDB					 7
#define SAA7146IDX_PIN3					 6
#define SAA7146IDX_PIN2					 5
#define SAA7146IDX_PIN1					 4
#define SAA7146IDX_PIN0					 3
#define SAA7146IDX_ECS					 2
#define SAA7146IDX_EC3S					 1
#define SAA7146IDX_EC0S					 0

// Grouping for faster IRQ dispatch
#define SAA7146IDX_IRQPCI				29, 3
#define SAA7146IDX_IRQRPS				20, 9
#define SAA7146IDX_IRQDEBI				18, 2
#define SAA7146IDX_IRQI2C				16, 2
#define SAA7146IDX_IRQAUDIO			11, 5
#define SAA7146IDX_IRQVIDEO			 7, 4
#define SAA7146IDX_IRQGPIO				 3, 4
#define SAA7146IDX_IRQEC				 0, 3

#define SAA7146_GPIO_IN(x)				(SAA7146IDX_PIN0+x)



// GPIO
#define SAA7146REG_GPIO_CTRL			0xe0
#define SAA7146IDX_GPIOC(x)			(8*x), 8
#define SAA7146REG_GPIO(x)				SAA7146REG_GPIO_CTRL, SAA7146IDX_GPIOC(x)

enum GPIOMode7146
	{
	SAA7146_GPIO_IN_NOINT		= 0x00,
	SAA7146_GPIO_IN_RISING		= 0x10,
	SAA7146_GPIO_IN_FALLING		= 0x20,
	SAA7146_GPIO_IN_BOTH			= 0x30,
	SAA7146_GPIO_OUT_LOW			= 0x40,
	SAA7146_GPIO_OUT_HIGH		= 0x50,
	SAA7146_GPIO_OUT_MONITOR	= 0xc0
	};

#define SAA7146_GPIO_MONITOR(s)	(0xc0 | (s))



// Event counters
#define SAA7146REG_EC1R					0x118   // read only
#define SAA7146IDX_EC2					22, 10
#define SAA7146REG_EC2					SAA7146REG_EC1R_read, SAA7146IDX_EC2
#define SAA7146IDX_EC1					12, 10
#define SAA7146REG_EC1					SAA7146REG_EC1R_read, SAA7146IDX_EC1
#define SAA7146IDX_EC0					 0, 12
#define SAA7146REG_EC0					SAA7146REG_EC1R_read, SAA7146IDX_EC0

#define SAA7146REG_EC2R					0x11c
#define SAA7146IDX_EC5					22, 10
#define SAA7146REG_EC5					SAA7146REG_EC2R, SAA7146IDX_EC5
#define SAA7146IDX_EC4					12, 10
#define SAA7146REG_EC4					SAA7146REG_EC2R, SAA7146IDX_EC4
#define SAA7146IDX_EC3					 0, 12
#define SAA7146REG_EC3					SAA7146REG_EC2R, SAA7146IDX_EC3

#define SAA7146REG_EC1SSR_read		0xe4
#define SAA7146REG_EC1SSR_write		0xe4
#define SAA7146IDX_ECS2					18, 6
#define SAA7146IDX_ECEN2				17
#define SAA7146IDX_ECCLR2				16
#define SAA7146IDX_ECS1					10, 6
#define SAA7146IDX_ECEN1				9
#define SAA7146IDX_ECCLR1				8
#define SAA7146IDX_ECS0					2, 6
#define SAA7146IDX_ECEN0				1
#define SAA7146IDX_ECCLR0				0

#define SAA7146REG_EC2SSR				0xe8
#define SAA7146IDX_ECS5					18, 6
#define SAA7146IDX_ECEN5				17
#define SAA7146IDX_ECCLR5				16
#define SAA7146IDX_ECS4					10, 6
#define SAA7146IDX_ECEN4				9
#define SAA7146IDX_ECCLR4				8
#define SAA7146IDX_ECS3					2, 6
#define SAA7146IDX_ECEN3				1
#define SAA7146IDX_ECCLR3				0

#define SAA7146REG_ECT1R				0xec
#define SAA7146IDX_ECT2					22, 10
#define SAA7146IDX_ECT1					12, 10
#define SAA7146IDX_ECT0					0, 12

#define SAA7146REG_ECT2R				0xf0
#define SAA7146IDX_ECT5					22, 10
#define SAA7146IDX_ECT4					12, 10
#define SAA7146IDX_ECT3					0, 12

// Counting events

enum CountEvent7146
	{
	SAA7146_CE_PPEF		= 0x00,
	SAA7146_CE_PABO		= 0x01,
	SAA7146_CE_PPED		= 0x02,
	SAA7146_CE_RPS_I1		= 0x03,
	SAA7146_CE_RPS_I0		= 0x04,
	SAA7146_CE_RPS_LATE1	= 0x05,
	SAA7146_CE_RPS_LATE0	= 0x06,
	SAA7146_CE_RPS_E1		= 0x07,
	SAA7146_CE_RPS_E0		= 0x08,
	SAA7146_CE_RPS_TO1	= 0x09,
	SAA7146_CE_RPS_TO0	= 0x0a,
	SAA7146_CE_UPLD		= 0x0b,
	SAA7146_CE_DEBI_S		= 0x0c,
	SAA7146_CE_DEBI_E		= 0x0d,
	SAA7146_CE_IIC_S		= 0x0e,
	SAA7146_CE_IIC_E		= 0x0f,
	SAA7146_CE_A2_IN		= 0x10,
	SAA7146_CE_A2_OUT		= 0x11,
	SAA7146_CE_A1_IN		= 0x12,
	SAA7146_CE_A1_OUT		= 0x13,
	SAA7146_CE_AFOU		= 0x14,
	SAA7146_CE_V_PE		= 0x15,
	SAA7146_CE_VFOU		= 0x16,
	SAA7146_CE_FIDA		= 0x17,
	SAA7146_CE_FIDB		= 0x18,
	SAA7146_CE_PIN3		= 0x19,
	SAA7146_CE_PIN2		= 0x1a,
	SAA7146_CE_PIN1		= 0x1b,
	SAA7146_CE_PIN0		= 0x1c,
	SAA7146_CE_ECS			= 0x1d,
	SAA7146_CE_EC3S		= 0x1e,
	SAA7146_CE_EC0S		= 0x1f,
	SAA7146_CE_PRQ			= 0x20,
	SAA7146_CE_PMA			= 0x21,
	SAA7146_CE_RPS_RE1	= 0x22,
	SAA7146_CE_RPS_PE1	= 0x23,
	SAA7146_CE_RPS_A1		= 0x24,
	SAA7146_CE_RPS_RE0	= 0x25,
	SAA7146_CE_RPS_PE0	= 0x26,
	SAA7146_CE_RPS_A0		= 0x27,
	SAA7146_CE_DEBI_TO	= 0x28,
	SAA7146_CE_DEBI_EF	= 0x29,
	SAA7146_CE_IIC_EA		= 0x2a,
	SAA7146_CE_IIC_EW		= 0x2b,
	SAA7146_CE_IIC_ER		= 0x2c,
	SAA7146_CE_IIC_EL		= 0x2d,
	SAA7146_CE_IIC_EF		= 0x2e,
	SAA7146_CE_V3P			= 0x2f,
	SAA7146_CE_V2P			= 0x30,
	SAA7146_CE_V1P			= 0x31,
	SAA7146_CE_VF3			= 0x32,
	SAA7146_CE_VF2			= 0x33,
	SAA7146_CE_VF1			= 0x34,
	SAA7146_CE_AF2_IN		= 0x35,
	SAA7146_CE_AF2_OUT	= 0x36,
	SAA7146_CE_AF1_IN		= 0x37,
	SAA7146_CE_AF1_OUT	= 0x38,
	SAA7146_CE_VGT			= 0x3a,
	SAA7146_CE_LNQG		= 0x3b,
	SAA7146_CE_EC5S		= 0x3c,
	SAA7146_CE_EC4S		= 0x3d,
	SAA7146_CE_EC2S		= 0x3e,
	SAA7146_CE_EC1S		= 0x3f
	};



// Audio configuration 1
#define SAA7146REG_ACON1				0xf4
#define SAA7146IDX_AUDIO_MODE			29, 3
#define SAA7146IDX_MAXLEVEL			22, 7
#define SAA7146IDX_A1_SWAP				21
#define SAA7146IDX_A2_SWAP				20
#define SAA7146IDX_WS0_CTRL			18, 2
#define SAA7146IDX_WS0_SYNC			16, 2
#define SAA7146IDX_WS1_CTRL			14, 2
#define SAA7146IDX_WS1_SYNC			12, 2
#define SAA7146IDX_WS2_CTRL			10, 2
#define SAA7146IDX_WS2_SYNC			 8, 2
#define SAA7146IDX_WS3_CTRL			 6, 2
#define SAA7146IDX_WS3_SYNC			 4, 2
#define SAA7146IDX_WS4_CTRL			 2, 2
#define SAA7146IDX_WS4_SYNC			 0, 2



// Audio configuration 2
#define SAA7146REG_ACON2				0xf8
#define SAA7146IDX_A1_CLKSRC			27, 5
#define SAA7146IDX_A2_CLKSRC			22, 7
#define SAA7146IDX_INVERT_BCLK1		21
#define SAA7146IDX_INVERT_BCLK2		20
#define SAA7146IDX_BCLK1_OEN			19
#define SAA7146IDX_BCLK2_OEN			18



// Main control 1
#define SAA7146REG_MC1					0xfc
#define SAA7146IDX_MRST_N				15
#define SAA7146IDX_ERPS1				13
#define SAA7146IDX_ERPS0				12
#define SAA7146IDX_EDP					11
#define SAA7146IDX_EVP					10
#define SAA7146IDX_EAP					 9
#define SAA7146IDX_EI2C					 8
#define SAA7146IDX_TR_E_DEBI			 7
#define SAA7146IDX_TR_E_1				 6
#define SAA7146IDX_TR_E_2				 5
#define SAA7146IDX_TR_E_3				 4
#define SAA7146IDX_TR_E_A2_OUT		 3
#define SAA7146IDX_TR_E_A2_IN			 2
#define SAA7146IDX_TR_E_A1_OUT		 1
#define SAA7146IDX_TR_E_A1_IN			 0

#define SAA7146_MC_MASKSHIFT			16   // also for MC2 register



// Main control 2
#define SAA7146REG_MC2					0x100
#define SAA7146IDX_RPS_SIG4			15
#define SAA7146IDX_RPS_SIG3			14
#define SAA7146IDX_RPS_SIG2			13
#define SAA7146IDX_RPS_SIG1			12
#define SAA7146IDX_RPS_SIG0			11
#define SAA7146IDX_UPLD_D1_A			10
#define SAA7146IDX_UPLD_D1_B			 9
#define SAA7146IDX_UPLD_BRS			 8
#define SAA7146IDX_UPLD_HPS_C			 7
#define SAA7146IDX_UPLD_HPS_H			 6
#define SAA7146IDX_UPLD_HPS_V			 5
#define SAA7146IDX_UPLD_DMA3			 4
#define SAA7146IDX_UPLD_DMA2			 3
#define SAA7146IDX_UPLD_DMA1			 2
#define SAA7146IDX_UPLD_DEBI			 1
#define SAA7146IDX_UPLD_IIC			 0



// RPS address registers
#define SAA7146REG_RPS_ADDR0			0x104

#define SAA7146REG_RPS_ADDR1			0x108



// Interrupt status, bit layout like interrupt enable register
#define SAA7146REG_ISR					0x10c



// Primary status register, bit layout like interrupt registers
#define SAA7146REG_PSR					0x110



// Secondary status register
#define SAA7146REG_SSR					0x114
#define SAA7146IDX_PRQ					31
#define SAA7146IDX_PMA					30
#define SAA7146IDX_RPS_RE1				29
#define SAA7146IDX_RPS_PE1				28
#define SAA7146IDX_RPS_A1				27
#define SAA7146IDX_RPS_RE0				26
#define SAA7146IDX_RPS_PE0				25
#define SAA7146IDX_RPS_A0				24
#define SAA7146IDX_DEBI_TO				23
#define SAA7146IDX_DEBI_EF				22
#define SAA7146IDX_IIC_EA				21
#define SAA7146IDX_IIC_EW				20
#define SAA7146IDX_IIC_ER				19
#define SAA7146IDX_IIC_EL				18
#define SAA7146IDX_IIC_EF				17
#define SAA7146IDX_V3P					16
#define SAA7146IDX_V2P					15
#define SAA7146IDX_V1P					14
#define SAA7146IDX_VF3					13
#define SAA7146IDX_VF2					12
#define SAA7146IDX_VF1					11
#define SAA7146IDX_AF2_IN				10
#define SAA7146IDX_AF2_OUT				 9
#define SAA7146IDX_AF1_IN				 8
#define SAA7146IDX_AF1_OUT				 7
#define SAA7146IDX_VGT					 5
#define SAA7146IDX_LNQG					 4
#define SAA7146IDX_EC5S					 3
#define SAA7146IDX_EC4S					 2
#define SAA7146IDX_EC2S					 1
#define SAA7146IDX_EC1S					 0



// DMA pointers, read-only
#define SAA7146REG_VDP1					0x120
#define SAA7146REG_VDP2					0x124
#define SAA7146REG_VDP3					0x128
#define SAA7146REG_ADP1					0x12c
#define SAA7146REG_ADP2					0x130
#define SAA7146REG_ADP3					0x134
#define SAA7146REG_ADP4					0x138
#define SAA7146REG_DDP					0x13c



// Audio input level monitoring
#define SAA7146REG_LEVEL_REPORT		0x140



// Feed back buffers
#define SAA7146REG_FB_BUFFER1			0x144

#define SAA7146REG_FB_BUFFER2			0x148



#endif // SAA7146R_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\pcibrdge\specific\saa7146\rps7146.h ===
// FILE:			library\hardware\pcibridge\specific\saa7146\rps7146.h
// AUTHOR:		D. Heidrich, U. Sigmund
// COPYRIGHT:	(c) 1996 VIONA Development GmbH.  All Rights Reserved.
// CREATED:		02.10.96
//
// PURPOSE:		Class for 7146 RPS programs.
//
// HISTORY:

#ifndef RPS7146_H
#define RPS7146_H

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"
#include "library\lowlevel\dmabuffr.h"



// RPS commands. Don't forget to append the data DWORDs after LDREG_SEQ.
#define RPS_PAUSE(flags)					0x20000000UL | (DWORD)(flags)
#define RPS_UPLOAD(upflags)				0x40000000UL | (DWORD)(upflags)
#define RPS_CHECK_LATE(flags)				0x30000000UL | (DWORD)(flags)
#define RPS_CLR_SIGNAL(flags)				0x00000000UL | (DWORD)(flags)
#define RPS_NOP								0x00000000UL
#define RPS_SET_SIGNAL(flags)				0x10000000UL | (DWORD)(flags)
#define RPS_INTERRUPT(flags)				0x60000000UL | (DWORD)(flags)
#define RPS_STOP(flags)						0x50000000UL | (DWORD)(flags)
#define RPS_JUMP(flags, dest)				0x80000000UL | (DWORD)(flags), (DWORD)(dest)
#define RPS_LDREG(reg, val)				0x90000100UL | (DWORD)(reg>>2), (DWORD)(val)   // no multiple data support
#define RPS_LDREG_SEQ(reg, length)		0x90000000UL | (DWORD)(reg>>2) | (DWORD)(length<<8)
#define RPS_STREG(reg, addr)				0xa0000100UL | (DWORD)(reg>>2), (DWORD)(addr)
#define RPS_MASKLOAD(reg, mask, val)	0xc0000000UL | (DWORD)(reg>>2), (DWORD)(mask), (DWORD)(val)
#define RPS_DONE								0xffffffffUL

// RPS flags
#define RPSB_OAN				27
#define RPSF_OAN				MKFLAG(RPSB_OAN)
#define RPSB_INV				26
#define RPSF_INV				MKFLAG(RPSB_INV)
#define RPSB_SIG4				25
#define RPSF_SIG4				MKFLAG(RPSB_SIG4)
#define RPSB_SIG3				24
#define RPSF_SIG3				MKFLAG(RPSB_SIG3)
#define RPSB_SIG2				23
#define RPSF_SIG2				MKFLAG(RPSB_SIG2)
#define RPSB_SIG1				22
#define RPSF_SIG1				MKFLAG(RPSB_SIG1)
#define RPSB_SIG0				21
#define RPSF_SIG0				MKFLAG(RPSB_SIG0)
#define RPSB_GPIO3			20
#define RPSF_GPIO3			MKFLAG(RPSB_GPIO3)
#define RPSB_GPIO2			19
#define RPSF_GPIO2			MKFLAG(RPSB_GPIO2)
#define RPSB_GPIO1			18
#define RPSF_GPIO1			MKFLAG(RPSB_GPIO1)
#define RPSB_GPIO0			17
#define RPSF_GPIO0			MKFLAG(RPSB_GPIO0)
#define RPSB_HT				16
#define RPSF_HT				MKFLAG(RPSB_HT)
#define RPSB_HS				15
#define RPSF_HS				MKFLAG(RPSB_HS)
#define RPSB_O_FID_B			14
#define RPSF_O_FID_B			MKFLAG(RPSB_O_FID_B)
#define RPSB_E_FID_B			13
#define RPSF_E_FID_B			MKFLAG(RPSB_E_FID_B)
#define RPSB_O_FID_A			12
#define RPSF_O_FID_A			MKFLAG(RPSB_O_FID_A)
#define RPSB_E_FID_A			11
#define RPSF_E_FID_A			MKFLAG(RPSB_E_FID_A)
#define RPSB_VBI_A			10
#define RPSF_VBI_A			MKFLAG(RPSB_VBI_A)
#define RPSB_VBI_B			9
#define RPSF_VBI_B			MKFLAG(RPSB_VBI_B)
#define RPSB_BRS_DONE		8
#define RPSF_BRS_DONE		MKFLAG(RPSB_BRS_DONE)
#define RPSB_HPS_LINE_DONE	6
#define RPSF_HPS_LINE_DONE	MKFLAG(RPSB_HPS_LINE_DONE)
#define RPSB_HPS_DONE		5
#define RPSF_HPS_DONE		MKFLAG(RPSB_HPS_DONE)
#define RPSB_VTD3				4
#define RPSF_VTD3				MKFLAG(RPSB_VTD3)
#define RPSB_VTD2				3
#define RPSF_VTD2				MKFLAG(RPSB_VTD2)
#define RPSB_VTD1				2
#define RPSF_VTD1				MKFLAG(RPSB_VTD1)
#define RPSB_DEBID			1
#define RPSF_DEBID			MKFLAG(RPSB_DEBID)
#define RPSB_IICD				0
#define RPSF_IICD				MKFLAG(RPSB_IICD)

// UPLOAD flags
#define RPSB_UPLD_D1_A			10
#define RPSF_UPLD_D1_A			MKFLAG(RPSB_UPLD_D1_A)
#define RPSB_UPLD_D1_B			9
#define RPSF_UPLD_D1_B			MKFLAG(RPSB_UPLD_D1_B)
#define RPSB_UPLD_BRS			8
#define RPSF_UPLD_BRS			MKFLAG(RPSB_UPLD_BRS)
#define RPSB_UPLD_HPS_CTRL		6
#define RPSF_UPLD_HPS_CTRL		MKFLAG(RPSB_UPLD_HPS_CTRL)
#define RPSB_UPLD_HPS_SCALE	5
#define RPSF_UPLD_HPS_SCALE	MKFLAG(RPSB_UPLD_HPS_SCALE)
#define RPSB_UPLD_DMA3			4
#define RPSF_UPLD_DMA3			MKFLAG(RPSB_UPLD_DMA3)
#define RPSB_UPLD_DMA2			3
#define RPSF_UPLD_DMA2			MKFLAG(RPSB_UPLD_DMA2)
#define RPSB_UPLD_DMA1			2
#define RPSF_UPLD_DMA1			MKFLAG(RPSB_UPLD_DMA1)
#define RPSB_UPLD_DEBI			1
#define RPSF_UPLD_DEBI			MKFLAG(RPSB_UPLD_DEBI)
#define RPSB_UPLD_IIC			0
#define RPSF_UPLD_IIC			MKFLAG(RPSB_UPLD_IIC)



class RPSProgram
	{
	friend class SAA7146;

	private:
		ContinuousDMABuffer *buffer;
		DWORD __huge *dataMem;
		DWORD __huge *codeMem;

		WORD dataSize;
		DWORD codeSize;
		DWORD codeEnd;
		BOOL valid;

		WORD nLabels;
		DWORD __far *labels;

		WORD nLabeledJumps, lastLabeled;
		DWORD __far *labeledJumps;

		Error AppendFix (DWORD __far *com, BOOL patching);

	public:
		// dataSize and codeSize are measured in DWORDs.
		RPSProgram (WORD dataSize, DWORD codeSize, WORD nLabels, WORD nLabeledJumps);
		virtual ~RPSProgram (void);

		Error __cdecl Build (DWORD commands, ...);
		Error __cdecl Append (DWORD commands, ...);
		Error __cdecl Patch (WORD labelNumber, DWORD commands, ...);
		Error CalculateJumps (void);

		Error SetLabel (WORD labelNumber);
		Error GetLabelAddress (WORD labelNumber, DWORD __far &physical);
		Error GetLabelPtr (WORD labelNumber, FPTR __far &fptr);

		Error ReadValue (WORD at, DWORD __far &data) {data = dataMem[at]; GNRAISE_OK;}
		Error WriteValue (WORD at, DWORD data) {dataMem[at] = data; GNRAISE_OK;}
		Error GetDataAddress (WORD at, DWORD __far &physical);

		Error GetPhysicalCodeAddress (DWORD __far &physical);
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\pcibrdge\specific\zivapc\zivapc.h ===
// FILE:      library\hardware\pcibridge\specific\i20\i20.h
// AUTHOR:    S. Herr
// COPYRIGHT: (c) 1998 VIONA Development GmbH.  All Rights Reserved.
// CREATED:   17.03.98
//
// PURPOSE:   
//
// HISTORY:

#ifndef ZIVAPC_H
#define ZIVAPC_H

#include "library\hardware\mpeg2dec\specific\ccubdvd1.h"
#include "library\lowlevel\intrctrl.h"
#include "library\lowlevel\dmachanl.h"
#include "library\lowlevel\hwbusio.h"
//#include "library\lowlevel\irqdebug.h"
#include "library\hardware\videodma\generic\colctrlr.h"

#include "zivapcrg.h"

#define	GNR_ILLEGAL_DMA_BUFFER_SIZE	MKERR(ERROR, DMA, PARAMS, 0x010)
	// The size of the dma buffer was not in the supported range

// Move this definition to somewhere more common
enum PowerState {VD_POWER_D0, VD_POWER_D1, VD_POWER_D2, VD_POWER_D3, VD_POWER_D4, VD_POWER_D5};

#define SCATTER_GATHER_DMA 1

class ZiVAPCDVDDecoder;
class ZiVADMAChannel;

class ZiVAPC : public ColorController {
	friend class ZiVAPCIntServer;
	friend class ZiVAPCDVDDecoder;
	private:
		ColorControlValues clrCtrl;
		volatile BOOL	doVSYNCJob;

	protected:           
		volatile DWORD				intStatus, intShadow;	// IRQ status from bridge chip IRQ flags
		volatile DWORD				decoderIntStatus;			// IRQ status of decoder part
		volatile	BOOL				decoderIntEnabled;
		volatile	DWORD				decoderIrqMask;
		volatile DWORD				shadowDecoderIntStatus;
		int							chipRevision;

		ZiVAPCDVDDecoder		*	mpegDecoder;

		void UpdateColorControlValues();
	public:
		//
		// Config space port
		// 
		//
		IndexedInOutPort		*	configPort;
		
		
		//
		// Host I/O Memory area
		//
		IndexedInOutPort		*	hostPort;
		
		//
		// I2C bus supported by the ZiVA-PC
		//
		ByteInOutBus			*	i2c;
		
		//
		// General I/O pins
		//
		BitIndexedInOutPort	*	genPPort;
	
   	//
   	// DVD decoder host I/O port
   	//
		ByteIndexedInOutPort	*	decoderPort;

		//
		// Interrupts
		//		
		InterruptServer		*	decoderIRQ;


		//
		// DMA channels
		//
		ZiVADMAChannel			*	muxChannel;	// channel for muxed data or video
		ZiVADMAChannel			*	extChannel;	// channel for audio

		ZiVAPC(IndexedInOutPort * hostPort, IndexedInOutPort * configPort);
		~ZiVAPC(void);

		Error ReInitialize(void);

		void SetMPEGDecoder(ZiVAPCDVDDecoder * decoder);
		
#if 0	// WDM_VERSION
		DWORD	GetDecoderIntStatus() {return decoderIntStatus;}
		// The function above was simplified from:
		//{decoderIntStatus |= shadowDecoderIntStatus; shadowDecoderIntStatus = 0; return decoderIntStatus;}
		// to avoid a late reset of the shadowDecoderIntStatus
#else
		DWORD	GetDecoderIntStatus() {decoderIntStatus |= shadowDecoderIntStatus; shadowDecoderIntStatus = 0; return decoderIntStatus;}
#endif
		void	ClearDecoderIntStatus() {decoderIntStatus = 0;}

		Error SetInterruptMask(DWORD irqMask);
		Error EnableDecoderInts();
		Error DisableDecoderInts();

		//
		// Initialize the ZiVA-PC
		//		
		virtual Error BuildPorts(void);		

		//
		// Configure code dma
		//
//		virtual Error ConfigureCodeDMA(int no, int reg, int trshld);
		
		//
		// To be called in the isr
		//
		virtual void Interrupt(void);
		InterruptServeType CheckInterrupt(void);
		
		// Function which is executed in the VSYNC IRQ of the DVD decoder part
		virtual void ExecuteVSYNCJob();

		//
		// Power management functions
		//
		Error SetPowerState(PowerState state);

		// Color Controller functions
		WORD  GetColorControl();
		Error SetColorControlValues(ColorControlValues __far & clrCtrl);

		Error	InitializeColorControl();
	};
      

class ZiVADMAChannel : public QueuedDMAChannel
	{
	friend class ZiVAPCDVDDecoder;
	friend class ZiVAPC;
	private:
		IndexedInOutPort * hostPort;

		int				channel;

		volatile DWORD	stateFlags;
		
		volatile DWORD	dmaBufferBase;
		volatile DWORD	dmaBufferSize;
		volatile DWORD dmaBufferStep;
		volatile DWORD dmaBufferOffset;
		volatile int	dmaChannel;

		ColorControlValues clrCtrl;
		volatile BOOL	doVSYNCJob;

		volatile	int	buffCount;

		Error InitTransfer(DMABuffer * buffer, DWORD start, DWORD size);
#if !SCATTER_GATHER_DMA
		Error InitCircularTransfer(DMABuffer * buffer, DWORD start, DWORD reportStep);
#endif

		Error StartTransfer(void);
		Error StopTransfer(void);
		Error EndTransfer(void);   
		
#if !SCATTER_GATHER_DMA
		Error StartNextDMAPacket(void);
#endif
		Error DMAPacketFinished(BOOL queueEmpty);
		
		long GetTransferLocation(void);
		void SetTransferLocation(long pos);
#if SCATTER_GATHER_DMA
		BOOL AcceptsData();
#endif

	public:
		ZiVADMAChannel(IndexedInOutPort * hostPort, int channel);
	};


class ZiVAPCDVDDecoder : public CCubeDVD1Decoder
	{
	friend class ZiVAPC;
	private:
		ZiVAPC * ziva;
		DWORD		irqMask;
	protected :
		// Coming from CCubeDVD1Decoder class
		DWORD	GetIRQStatus();
		void	ClearIRQStatus();
		Error	SetInterruptMask(DWORD mask) {GNRAISE(ziva->SetInterruptMask(mask));}

		void	PackSyncClear();

		void	ExecuteVSYNCJob();

	public :
		ZiVAPCDVDDecoder(Profile							*	profile,
							  ZiVAPC								*	ziva,
							  DualASyncOutStream				*	strm,
							  ProgrammableClockGenerator	*	audioClock,
							  VirtualAudioDAC					*	dac,
							  VirtualUnit						*	videoBus,  
							  VirtualUnit						*	audioBus,
							  VideoStandard						videoStandard,
							  BOOL                           lpcmSpdifOut,
							  BOOL									isZiVAPC) : CCubeDVD1Decoder(ziva->decoderPort, ziva->decoderIRQ, strm, audioClock,
							  																				  dac, videoBus, audioBus, NULL,
							  																				  NULL, NULL, videoStandard,
							  																				  lpcmSpdifOut)
			{
			this->ziva = ziva;
			irqMask = 0;
			SetProfile(profile);
			SetIsZiVAPC(isZiVAPC);
			}
	};

inline DWORD ZiVAPCDVDDecoder::GetIRQStatus() 
	{
	return ziva->GetDecoderIntStatus();
	}

inline void ZiVAPCDVDDecoder::ClearIRQStatus()
	{
	ziva->ClearDecoderIntStatus();
	}

	//
	// Interrupt server for Ziva interrupt
	//	
class ZiVAPCIntServer : public InterruptServer {
	private:
		int		intCtrlBit;	// bit in the interrupt control registers
		ZiVAPC	*	ziva;
	protected:
		Error EnableInt(void);
		Error DisableInt(void);		
	public:
		ZiVAPCIntServer(ZiVAPC * ziva, int intCtrlBit) : InterruptServer()
			{this->ziva = ziva; this->intCtrlBit = intCtrlBit;}
	};                                                                                          

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\remote\generic\remotedefs.h ===
// FILE:      remotedefs.h
// AUTHOR:    D.Heidrich
// COPYRIGHT: (c) 1999 VIONA Development GmbH.  All Rights Reserved.
// CREATED:   21.08.99
//
// PURPOSE:   Generic definitions for remote controls.
//
// HISTORY:

#ifndef REMDEFS_H
#define REMDEFS_H

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"
#include "library\common\winports.h"

class GenericRemote
	{
	protected:
		WinPort *winPort;

		int sendCounter, receiveCounter;

		DWORD currentMessage, previousMessage, failedMessage;
		DWORD currentButtonTime, failedTime;   // milliseconds
		DWORD releaseTime;
		DWORD releaseDelay;   // in ticks of 64us
		BOOL sendingRelease;

	public:
		GenericRemote (WinPort *winPort, DWORD releaseDelay);   // delay in microseconds
		virtual ~GenericRemote (void) {}

		virtual Error Initialize (void) = 0;

		virtual void SetWinPort (WinPort *newPort);

		virtual void Interrupt (void) = 0;

		virtual void ButtonPress (DWORD ceMsg);

		// This function must be called periodically to send the button events to the winPort.
		virtual void ProcessButtons (void);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\ports\specific\necserial.h ===
// FILE:			library\hardware\port\specific\necserial.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1999 VIONA Development GmbH & Co. KG.  All Rights Reserved.
// CREATED:		05.08.1999
//
// PURPOSE:		Serial Bidirectional byte port for NEC devices
//
// HISTORY:

#ifndef NECSERIAL_H
#define NECSERIAL_H

#include "library\lowlevel\hardwrio.h"
#include "library\common\krnlsync.h"

class NECSerialBidirectionalPort : public ByteIndexedInOutPort, public VDMutex
	{
	private:
		BitOutputPort	* strobe;
		BitOutputPort	* clk;
		BitInOutPort	* dio;

		Error ShiftByteOut(BYTE b);
		Error ShiftByteIn(BYTE __far & b);
	public:
		NECSerialBidirectionalPort(BitOutputPort * strobe, BitOutputPort * clk, BitInOutPort * dio);

		Error OutByte(BYTE data);		
		Error OutByte(int at, BYTE data); 
		Error OutBytes(int at, int inc, BYTE __far * data, int num);		
		Error OutByteSeqA(int at, int inc, int __far* data);

		Error InByte(BYTE __far &data);
		Error InByte(int at, BYTE __far &data);
		Error InBytes(BYTE __far * data, int num);
		Error InBytes(int at, int inc, BYTE __far * data, int num);		

	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\remote\specific\rs232remote.h ===
// FILE:      rs232remote.h
// AUTHOR:    B. Pruden
// COPYRIGHT: (c) 1999 Ravisent Technologies.  All Rights Reserved.
// CREATED:   10.28.99
//
// PURPOSE:   Receive remote control commands via RS232 serial port.
//
// HISTORY:

#ifndef RS232REMOTE_H
#define RS232REMOTE_H

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"
#include "library\common\winports.h"

#include "driver\dvdpldrv\win32\dvdpld32.h"

class Rs232Remote
	{
	private:
		WinPort *winPort;
 		UnitSet commUnit;		// handle to the virtual cinemaster units
		task_t* commRemoteThread;
		DWORD code;

  public:
		Rs232Remote (WinPort *winPort, UnitSet commUnit);
		~Rs232Remote (void);

		Error Initialize (void);

		void ThreadEntry (void);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\remote\specific\panadvd.h ===
// FILE:      panadvd.h
// AUTHOR:    H.Horak
// COPYRIGHT: (c) 1998 VIONA Development GmbH.  All Rights Reserved.
// CREATED:   11.09.98
//
// PURPOSE:   SW decoder for Panasonic DVD IR remote control.
//
// HISTORY:

#ifndef REMPANAS_H
#define REMPANAS_H

#include "library\common\gnerrors.h"
#include "library\common\winports.h"
#include "library\lowlevel\timer.h"
#include "library\hardware\remote\generic\remotedefs.h"

class PanasonicRemote : public GenericRemote
	{
	private:
		clock_t lastTime, errorTime;
		DWORD bitCount;
		DWORD group;
		WORD code;

		enum {
			IDLE,
			HIGH_HEADER,
			LOW_HEADER,
			CLOCK,
			DECODE,
			ERROR
			} state;

	public:
		PanasonicRemote (WinPort *winPort);
		virtual ~PanasonicRemote (void);

		virtual Error Initialize (void);

		virtual void Interrupt (void);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\remote\specific\vesteldvd.h ===
// FILE:      vesteldvd.h
// AUTHOR:    H.Horak
// COPYRIGHT: (c) 1998 VIONA Development GmbH.  All Rights Reserved.
// CREATED:   11.09.98
//
// PURPOSE:   SW decoder for Vestel DVD IR remote control.
//
// HISTORY:

#ifndef VESTELDVD_H
#define VESTELDVD_H

#include "library\common\gnerrors.h"
#include "library\common\winports.h"
#include "library\lowlevel\timer.h"
#include "library\hardware\remote\generic\remotedefs.h"

class VestelRemote : public GenericRemote
	{
	private:
		clock_t lastTime, errorTime;
		int bitCount;
		BOOL bit, decode, check;
		DWORD data, group, code;

		// States of decoding state machine.
		enum RemoteState
			{
			ERROR,
			IDLE,
			HIGH_HEADER,
			LOW_HEADER,
			STARTUP,
			DECODE,
			RESYNC
			} state;

	public:
		VestelRemote (WinPort *winPort);
		virtual ~VestelRemote (void);

		virtual Error Initialize (void);

		virtual void Interrupt (void);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\tuner\specific\FI1236X.H ===
// FILE:			library\hardware\tuner\generic\FI1236X.h
// AUTHOR:		Stefan Herr
// COPYRIGHT:	(c) 1995 Viona Development.  All Rights Reserved.
// CREATED:		19.07.95
//
// PURPOSE:		Definition of class for Philips FI1236 tuner with sound extension as available
//					on the H20 Debug board.
//
// HISTORY:

#ifndef FI1236X_H
#define FI1236X_H

#include "..\generic\tvtuner.h"

#ifndef ONLY_EXTERNAL_VISIBLE

#define I2C_FI1236_UNIT0	0xc0	// The 1236's I2C base addresses. Up to 4 units possible.
#define I2C_FI1236_UNIT1	0xc2	// This is the default.
#define I2C_FI1236_UNIT2	0xc4									
#define I2C_FI1236_UNIT3	0xc6									

#define	STATIONGOODTHRESHOLD	2*(1000/5)	// if the result of CheckLevel() is >= this value,
														// the reception of a station on the current freq.
														// is OK.
														// Philips docu says it's a 5 level A/D converter.
														// 2 is 0 kHz, whatever this means...

#define LOCKPLLTIMEOUT		3000 				// timeout is 3000ms = 3s, after that the PLL should have
														// locked. Remark: Locking takes quite a long time when
														// switching between bands (> 1000 ms).

							
class VirtualFI1236XTuner;

/////////////////////////////////////////////////////////////////////////////////////////////
// Class FI1236XTuner definition (physical unit)
/////////////////////////////////////////////////////////////////////////////////////////////
class FI1236XTuner : public TVTuner {
	friend class VirtualFI1236XTuner;
	protected:                 
		ByteInOutPort*	i2cPort;
		BitOutputPort*	stereoPort;
		BitOutputPort* mutePort;
		BitInputPort*	signalPort;

		VirtualUnit	*	audioBus;			

		BOOL				pllDisable, mute, chargePump, stereo;
		DWORD				lastFreq,
							visionIF;

		DWORD				startFreq;

		BYTE				ctrlWordByte1, ctrlWordByte2;

		DWORD				stepSize;
		DWORD				bigJump;
		DWORD				minStepsValid,	maxStepsValid;
		DWORD				upperLimit, lowerLimit;

		Error Lock(VirtualUnit * unit);
		Error Unlock(VirtualUnit * unit);		

		Error	ScanStation(Direction dir, DWORD __far & freq);						// Scan for next station.
		Error	StartStepScan(Direction dir) {GNRAISE_OK;}
		Error ScanStep(ScanResult __far & 	result,
							DWORD __far & 			curFreq,
							WORD	__far & 			curLevel,
						   ScanState __far & 	curState);
		
		Error	CheckInputLevel(WORD __far & level);									// Check signal level of station on current frequency.
		virtual Error CheckScanInputLevel(WORD __far & level);

		Error Update(void);																	// Central function for updating the tuner settings.

		virtual Error	ProgramFrequency(DWORD freq, DWORD __far & lastFreq);	// Program desired frequency into the FI1236
		virtual Error	WaitLockPLL(void);												// Helper function for waiting for the PLL to lock
															
		virtual Error	SetChargePump(BOOL chargePump);								// *** Debugging purposes only
		virtual Error	SetPLLDisable(BOOL pllDisable);								// *** Debugging purposes only

		virtual Error	SetMute(BOOL mute);
		virtual Error	SetStereo(BOOL stereo);											// Switch between mono and stereo       

		virtual Error	GetBand(DWORD freq, TVTunerBands __far & band);			// Get band for current frequency.

		virtual void InitControlWordBytes();
		virtual Error GetSignal(BIT __far & signal);
	public:
		FI1236XTuner(ByteInOutPort *	i2cPort,			// I2C port to FI1236
	  				  	 BitOutputPort *	stereoPort,		// Port for stereo/mono switch
						 BitOutputPort	* 	mutePort,		// Port for mute on/off
						 BitInputPort	*	signalPort,		// Port for detecting the video signal level
	  				  	 VirtualUnit	*	audioBus			// Audio bus for multiplexing between MPEG and video
					 );

		VirtualUnit * CreateVirtual(void);

	};


/////////////////////////////////////////////////////////////////////////////////////////////
// Class VirtualFI1236XTuner definition (virtual unit)
/////////////////////////////////////////////////////////////////////////////////////////////

class VirtualFI1236XTuner : public VirtualTVTuner {

	private:
		FI1236XTuner* tuner;

	protected:		
		BOOL				pllDisable,
							chargePump,
							mute,
							stereo;
							
		BOOL				idleUnit;
		
	protected:
		virtual Error DoPreempt(VirtualUnit * previous);

	public:
		VirtualFI1236XTuner(FI1236XTuner * physical, BOOL idleUnit);
		
	 	Error	Configure (TAG __far *tags);
		Error Preempt(VirtualUnit * previous);
		
		Error ScanStation(Direction dir);							// Used for automatic station scanning.
		Error ScanStep(ScanResult __far & 	result,					// Scan stepwise
						   DWORD	__far & 			curFreq,
						   WORD __far & 			curLevel);
	};

#endif // of ONLY_EXTERNAL_VISIBLE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\tuner\specific\alpstsbh.h ===
// FILE:			library\hardware\tuner\generic\AlpsTSBH.h
// AUTHOR:		Stefan Herr
// COPYRIGHT:	(c) 1995 Viona Development.  All Rights Reserved.
// CREATED:		19.07.95
//
// PURPOSE:		Definition of class for Alps TSBH1 tuner with sound extension as available
//					on the Buster board.
//
// HISTORY:

#ifndef ALPSTSBH_H
#define ALPSTSBH_H

#include "..\generic\tvtuner.h"


#ifndef ONLY_EXTERNAL_VISIBLE

//#define	STATIONGOODTHRESHOLD	2*(1000/5)	
//#define LOCKPLLTIME			300 

#define I2C_ADDR_ALPSTSBH1	0xc2				// I2C address

/////////////////////////////////////////////////////////////////////////////////////////////
// Class AlpsTSBH1Tuner definition (physical unit)
/////////////////////////////////////////////////////////////////////////////////////////////
class AlpsTSBH1Tuner : public TVTuner {
	friend class VirtualAlpsTSBH1Tuner;
	private:
		ByteInOutPort*	i2cPort;
		BitOutputPort*	stereoPort;
		BitInputPort*	signalPort;
  	 	BitInputPort*	aftPort;
  	 	BitInputPort*	rfaPort;
  	 	BitInputPort*	ifaPort;

		BYTE				ctrlWordByte1, ctrlWordByte2;
		BOOL				pllDisable, chargePump, stereo;
		DWORD				lastFreq,
							visionIF;

		VirtualUnit	*	audioBus;			

	protected:                 
		Error Lock(VirtualUnit * unit);
		Error Unlock(VirtualUnit * unit);		
	
		Error Update(void);														// Central function for updating the tuner settings.

		Error	ProgramFrequency(DWORD freq, DWORD __far & lastFreq);	// Program desired frequency into the FI1236
		Error	WaitLockPLL(void);												// Helper function for waiting for the PLL to lock
															
		Error	SetChargePump(BOOL chargePump);								// *** Debugging purposes only
		Error	SetPLLDisable(BOOL pllDisable);								// *** Debugging purposes only

		Error	SetStereo(BOOL stereo);											// Switch between mono and stereo       
		
		Error ScanStation(Direction dir, DWORD __far & freq);			// Scan for next station.
		Error	StartStepScan(Direction dir) {GNRAISE_OK;}
		Error ScanStep(ScanResult __far & result,
							DWORD __far & curFreq,
							WORD	__far & curLevel,
						   ScanState __far & curState);

		Error CheckInputLevel(WORD __far & level);						// Check signal level of station on current frequency.

		Error	GetBand(DWORD freq, TVTunerBands __far & band);			// Get band for current frequency.

	public:
		AlpsTSBH1Tuner(ByteInOutPort	*	i2cPort,			// I2C port to FI1236
	  				  	 	BitOutputPort	*	stereoPort,		// Port for stereo/mono switch
						 	BitInputPort	*	signalPort,		// Port for detecting the video signal level
	  				  	 	VirtualUnit		*	audioBus,		// Audio bus for multiplexing between MPEG and video
	  				  	 	BitInputPort	*	aftPort,			// Port for detecting AFT level.
	  				  	 	BitInputPort	*	rfaPort,			// Port for detecting RFA level.
	  				  	 	BitInputPort	*	ifaPort			// Port for detecting IFA level.
					 	  );
					 	  
		VirtualUnit * CreateVirtual(void);					 	 
	};


/////////////////////////////////////////////////////////////////////////////////////////////
// Class VirtualAlpsTSBH1Tuner definition (virtual unit)
/////////////////////////////////////////////////////////////////////////////////////////////

class VirtualAlpsTSBH1Tuner : public VirtualTVTuner {

	private:
		AlpsTSBH1Tuner* tuner;
		
		BOOL				pllDisable, 
							chargePump,
							stereo;
							
		BOOL				idleUnit;
				
	public:
		VirtualAlpsTSBH1Tuner(AlpsTSBH1Tuner * physical, BOOL idleUnit);
		
	 	Error	Configure (TAG __far *tags);
		Error Preempt(VirtualUnit * previous);
		
		Error ScanStation	(Direction dir);								// Used for automatic station scanning.
		Error ScanStep(ScanResult __far & 	result,					// Scan stepwise
						   DWORD	__far & 			curFreq,
						   WORD __far & 			curLevel);
	};

#endif // of ONLY_EXTERNAL_VISIBLE

		
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\tuner\generic\tvtuner.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:			library\hardware\tuner\generic\tvtuner.h
// AUTHOR:		Stefan Herr
// COPYRIGHT:	(c) 1995 Viona Development.  All Rights Reserved.
// CREATED:		17.07.95
//
// PURPOSE:		Definition of abstract base class for TV tuners
//
// HISTORY:

#ifndef TVTUNER_H
#define TVTUNER_H

#include "library\common\gnerrors.h"
#include "library\common\tags.h"
#include "library\common\tagunits.h"
#include "library\common\hooks.h"
#include "library\hardware\audio\generic\stereodc.h"

#ifndef ONLY_EXTERNAL_VISIBLE

#include "library\lowlevel\hardwrio.h"
#include "library\common\virtunit.h"

#endif


/////////////////////////////////////////////////////////////////////////////////////////////
// Definitions of helper data structures
/////////////////////////////////////////////////////////////////////////////////////////////

// number of available TV standards
#define STDS_NUM 10

// This struct defines the necessary properties of a TV standard for the purposes of
// this low-level driver
typedef struct
	{
	DWORD		minFreq;			// minimal allowed frequency
	DWORD		lowLimit,		// frequency limit for the LOW band [10^2 Hz]
				midLimit,		// frequency limit for the MID band [10^2 Hz]
				highLimit;		// frequency limit for the HIGH band [10^2 Hz]
	DWORD		visionIF;		// IF frequency [10^2 Hz]
	DWORD		stepSize;		// Scan step size.
	}  TVStdProperty;

// Define directions for automatic station search
enum Direction {SCAN_UP, SCAN_DOWN};	// SCAN_UP: search towards higher frequencies
													// SCAN_DOWN: search towards lower frequencies

// Defines which TV standards are available
enum TVTunerTVStandard { MIN_TV_STD = 0,
								 PAL_AIR=0, PAL_CABLE,
								 NTSC_AIR,  NTSC_CABLE,
				   			 SECAM_AIR, SECAM_CABLE,
				   			 JAPAN_AIR, JAPAN_CABLE,
				   			 PAL_I_AIR, PAL_I_CABLE,
				   			 MAX_TV_STD = PAL_I_CABLE };

// Define bands
enum TVTunerBands { MIN_BAND		=	0,
						  BAND_LOW		=	0,
						  BAND_MID,
						  BAND_HIGH,
						  MAX_TV_BAND	=	BAND_HIGH,
						  BAND_FM,							// Extension for tuners with FM reception capability
						  MAX_BAND		=	BAND_FM
						};


// Result of stepwise scan function (StepScan)
enum ScanResult {STATION_FOUND,				// A station was found during the last step
					  NO_STATION,					// No station was found.
					  UPPER_LIMIT,					// Upper limit of frequency range reached.
					  LOWER_LIMIT					// Lower limit reached.
					 };

// Step ratio for tuner
enum StepRatioSelect {STEP_AUTOMATIC,		// Step is chosen according to FM enable
							 STEP_SIZE_50,			// One step is 50		kHz, used for FM and PAL TV
							 STEP_SIZE_31_25,		//					31.25	kHz, currently NOT SUPPORTED!!
							 STEP_SIZE_62_5		//					62.5	kHz, used for NTSC TV
							};

/////////////////////////////////////////////////////////////////////////////////////////////
// Definition of callback hook for station scans
/////////////////////////////////////////////////////////////////////////////////////////////

struct TVScanMsg
	{
	DWORD				frequency;
	WORD				level;
	};

MKHOOK(TVScan, TVScanMsg)

typedef TVScanHook __far * TVScanHookPtr;

/////////////////////////////////////////////////////////////////////////////////////////////
// Tag definitions for TV tuners
/////////////////////////////////////////////////////////////////////////////////////////////

MKTAG (TVT_TVSTANDARD,		TV_TUNER_UNIT, 0x0001, TVTunerTVStandard)	// used to set TV standard
MKTAG (TVT_FREQUENCY ,		TV_TUNER_UNIT, 0x0002, DWORD)					// current frequency for channel (10^2 Hz units)
MKTAG (TVT_SIGNAL_LEVEL,	TV_TUNER_UNIT, 0x0004, WORD)					// Tag to get the signal level of the station
																							// on the current frequency. Not always supported.
																							// Value range 0 - 10000.
MKTAG (TVT_CHARGEPUMP,		TV_TUNER_UNIT, 0x1001, BOOL)					// 1: fast tuning, 0: slow but
																							// more precise tuning
MKTAG (TVT_PLLDISABLE,		TV_TUNER_UNIT, 0x1002, BOOL)					// 1: manual tuning, 0: normal op.
MKTAG (TVT_STEREO,	   	TV_TUNER_UNIT, 0x1003, BOOL)					// 1: Stereo,  0: Mono
MKTAG (TVT_MUTE,		   	TV_TUNER_UNIT, 0x1004, BOOL)					// 1: sound off,  0: sound on

MKTAG (TVT_STEPSIZE,			TV_TUNER_UNIT, 0x1008, StepRatioSelect)	// Default: automatic
MKTAG (TVT_FMENABLE,			TV_TUNER_UNIT, 0x1009, BOOL)					// Switch to FM band. Default: FALSE
MKTAG	(TVT_MODEDETECT,		TV_TUNER_UNIT, 0x100a, SignalMode)			// Used to inquire signal type
MKTAG (TVT_MODESELECT,		TV_TUNER_UNIT, 0x100b, SignalMode)			// Used to force certain reception mode

/////////////////////////////////////////////////////////////////////////////////////////////
// Error definitions for CTVTuner
/////////////////////////////////////////////////////////////////////////////////////////////

// An illegal TV standard was supported by the caller
#define GNR_TVT_ILLEGAL_TV_STD		MKERR(ERROR, TVTUNER, BOUNDS, 0x01)

// The provided frequency is not in the valid range for the given TV standard
#define GNR_TVT_ILLEGAL_FREQUENCY	MKERR(ERROR, TVTUNER, BOUNDS, 0x02)

// It was not possible to lock the PLL. Certainly this message will occur, if the PLL is
// disabled
#define GNR_TVT_PLL_NOT_LOCKED		MKERR(ERROR, TVTUNER, BUSY,   0x03)

// It is not possible to execute the action because this virtual unit is not the "current"
// one possessing the hardware
#define GNR_TVT_NOT_CURRENT			MKERR(ERROR, TVTUNER, INACTIVE, 0x04)

// Function not yet implemented.
#define GNR_TVT_NOT_IMPLEMENTED		MKERR(ERROR, TVTUNER, GENERAL, 0x05)

// ScanStation couldn't find a station.
#define GNR_TVT_NO_STATION_FOUND		MKERR(ERROR, TVTUNER, GENERAL, 0x06)

// ScanStaion with SCAN_DOWN reached the lower limit.
#define GNR_TVT_LOWER_LIMIT			MKERR(ERROR, TVTUNER, BOUNDS, 0x07)

// ScanStaion with SCAN_UP reached the upper limit.
#define GNR_TVT_UPPER_LIMIT			MKERR(ERROR, TVTUNER, BOUNDS, 0x08)

// Tells that the station scan was canceled by the user.
#define GNR_TVT_SCAN_CANCELED			MKERR(ERROR, TVTUNER, GENERAL, 0x09)

// Dialog box could not be opened
#define GNR_TVT_NO_DIALOG_BOX			MKERR(ERROR, TVTUNER, GENERAL, 0x0a)


#ifndef ONLY_EXTERNAL_VISIBLE

enum ScanState {SCAN_COARSE, SCAN_FINE, SCAN_SIGNAL_CHECK, SCAN_FINE_FORWARD};


/////////////////////////////////////////////////////////////////////////////////////////////
// Class TVTuner definition (realizes physical unit)
/////////////////////////////////////////////////////////////////////////////////////////////
class TVTuner : public PhysicalUnit {
	friend class VirtualTVTuner;

	protected:
		Direction		scanDir;
		ScanState		scanState;

		DWORD				changed;

		TVStdProperty	tvStdProperties[STDS_NUM];						// stores the properties of TV standards

		DWORD				freq;

		TVTunerTVStandard	tvStd;

		TVTuner();

		virtual 	Error SetTVStandard(TVTunerTVStandard tvStd);
		virtual 	Error SetFrequency(DWORD freq);

		virtual	Error SetScanDir(Direction dir);
		virtual	Error	SetScanState(ScanState state);

		virtual 	Error CheckInputLevel(WORD __far & level) = 0;
		virtual	Error	ScanStation(Direction dir, DWORD __far & freq) = 0;
		virtual	Error	StartStepScan(Direction dir) = 0;
		virtual	Error ScanStep(ScanResult __far & result,
										DWORD __far & curFreq,
										WORD	__far & curLevel,
									   ScanState __far & curState) = 0;

		virtual	Error Update(void) = 0;
	};


/////////////////////////////////////////////////////////////////////////////////////////////
// Class VirtualTVTuner definition (realizes virtual unit)
/////////////////////////////////////////////////////////////////////////////////////////////
class VirtualTVTuner : public VirtualUnit {
	private:
		TVTuner*					tuner;					// Pointer to the physical unit.
	protected:
		DWORD						freq;						// Current frequency of channel (10^2 Hz units)
		TVTunerTVStandard		tvStd;					// Stores the current TV standard of this virtual unit

		Direction				scanDir;
		ScanState				scanState;

	public:
		VirtualTVTuner(TVTuner* physical);

		virtual Error Configure(TAG __far * tags);
		virtual Error Preempt(VirtualUnit * previous);
																				// Standard configuration function
		virtual Error ScanStation(Direction dir);					// Search for the next available station and
																				// set the current frequency to its value if one was found.
		virtual Error StartStepScan(Direction dir);				// Initialize stepwise scan

		virtual Error ScanStep(ScanResult __far & 	result,	// Scan stepwise
									  DWORD	__far & 			curFreq,
									  WORD __far & 			curLevel);

		virtual Error CheckInputLevel(WORD __far & level);	// Check the signal strength of the station on the
																				// current frequency.
	};

#endif // of ONLY_EXTERNAL_VISIBLE


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\uproc\specific\st55xx\cpu5505r.h ===
// FILE:      library\hardware\uproc\specific\st55xx\cpu5505r.h
// AUTHOR:    D. Heidrich
// COPYRIGHT: (c) 1998 Viona Development.  All Rights Reserved.
// CREATED:   22.05.98
//
// PURPOSE:   Register definitions for the STi5505 chip.
//
// HISTORY:

#ifndef CPU5505R_H
#define CPU5505R_H

// Include common register definitions
#include "cpu55xxr.h"


// MPEG video decoder.

#define ST5505REG_MPEG_VIDEO_SIZEOF	0x80
#define ST5505REG_MPEG_VIDEO_BASE2	0x1000
#define ST5505REG_MPEG_VIDEO_BASE3	0x1080
#define ST5505REG_MPEG_VIDEO_BASE4	0x1100
#define ST5505REG_MPEG_VIDEO_BASE5	0x1180



// MPEG audio decoder.

#define ST5505REG_MPEG_AUDIO_SIZEOF	0x80
#define ST5505REG_MPEG_AUDIO_BASE2	0x1200
#define ST5505REG_MPEG_AUDIO_BASE3	0x1280
#define ST5505REG_MPEG_AUDIO_BASE4	0x1300
#define ST5505REG_MPEG_AUDIO_BASE5	0x1380



// MPEG subpicture decoder.

#define ST5505REG_MPEG_SUB_SIZEOF	0x80
#define ST5505REG_MPEG_SUB_BASE2		0x1400
#define ST5505REG_MPEG_SUB_BASE3		0x1480
#define ST5505REG_MPEG_SUB_BASE4		0x1500
#define ST5505REG_MPEG_SUB_BASE5		0x1580



// Video encoder.

#define ST5505REG_DENC_SIZEOF			0x80
#define ST5505REG_DENC_BASE2			0x1600
#define ST5505REG_DENC_BASE3			0x1680
#define ST5505REG_DENC_BASE4			0x1700
#define ST5505REG_DENC_BASE5			0x1780



// Front end.

#define ST5505REG_FRAM_DMA_BASE		0x20002000
#define ST5505REG_FRAM_DMA_SIZEOF	0x1000



// DMA controller.

#define ST5505REG_DMACTRL_SIZEOF		0x1000

#define ST5505REG_MPEGDMA0_BASE		0x20020000
#define ST5505REG_MPEGDMA1_BASE		0x20021000
#define ST5505REG_MPEGDMA2_BASE		0x20022000

#define ST5505REG_MPEGDMA_BURSTSIZE		0x00
#define ST5505REG_MPEGDMA_HOLDOFF		0x04
#define ST5505REG_MPEGDMA_SUSPEND		0x08
#define ST5505REG_MPEGDMA_DECODERSEL	0x0c

// Teletext

#define ST5505REG_TELETEXT_BASE		0x20024000

// Block Move

#define ST5505REG_BLOCKMOVE_BASE		0x20026000


// Synchronous Serial Channel.

#define ST5505REG_SSC_BASE				0x20009000
#define ST5505REG_SSC_SIZEOF			0x20



// Asynchronous Serial Channel.

#define ST5505REG_ASC_BASE(x)				(0x20003000 + 0x00001000 * x)
#define ST5505REG_ASC0_BASE				ST5505REG_ASC_BASE(0)
#define ST5505REG_ASC1_BASE				ST5505REG_ASC_BASE(1)
#define ST5505REG_ASC2_BASE				ST5505REG_ASC_BASE(2)
#define ST5505REG_ASC3_BASE				ST5505REG_ASC_BASE(3)
#define ST5505REG_ASC_SIZEOF				0x18



// PIO.

#define ST5505REG_PIO0_BASE			0x2000c000
#define ST5505REG_PIO1_BASE			0x2000d000
#define ST5505REG_PIO2_BASE			0x2000e000
#define ST5505REG_PIO3_BASE			0x2000f000
#define ST5505REG_PIO4_BASE			0x20010000
#define ST5505REG_PIO_SIZEOF			0x70



// The IRQ numbers are fixed. The interrupt level controller maps them onto 8 IRQ levels.

#define IRQ_NUM_PORT0			0
#define IRQ_NUM_PORT1			1
#define IRQ_NUM_PORT2			2
#define IRQ_NUM_PORT3			3
#define IRQ_NUM_PORT4			4
#define IRQ_NUM_SSC				5
#define IRQ_NUM_ASC3				6
#define IRQ_NUM_ASC2				7
#define IRQ_NUM_ASC1				8
#define IRQ_NUM_ASC0				9
#define IRQ_NUM_PWM				10
#define IRQ_NUM_TELETEXT		11
#define IRQ_NUM_FRONTDMA		12
#define IRQ_NUM_MPEG_VIDEO		14
#define IRQ_NUM_MPEG_AUDIO		15
#define IRQ_NUM_PPC_DMA			16
#define IRQ_NUM_PPC_MAILBOX	17
#define IRQ_NUM_PIN0				18
#define IRQ_NUM_SECTORPROC		19
#define IRQ_NUM_PIN1				20



// ST20 cache control registers

#define ST5505REG_CACHE_CONTROL_BASE			0x4000
#define ST5505REG_CACHE_CONTROL_SIZEOF			0x600

#define ST5505REG_CACHE_CACHABILITY_CONTROL	0x0
#define ST5505IDX_CACHE_BLOCK7					7
#define ST5505IDX_CACHE_BLOCK6					6
#define ST5505IDX_CACHE_BLOCK5					5
#define ST5505IDX_CACHE_BLOCK4					4
#define ST5505IDX_CACHE_BLOCK3					3
#define ST5505IDX_CACHE_BLOCK2					2
#define ST5505IDX_CACHE_BLOCK1					1
#define ST5505IDX_CACHE_BLOCK0					0

#define ST5505REG_CACHE_SELECTION				0x100
#define ST5505IDX_CACHE_USE_ICACHE				1
#define ST5505IDX_CACHE_USE_DCACHE				0

#define ST5505REG_CACHE_INVALIDATE_DCACHE		0x200
#define ST5505REG_CACHE_INVALIDATE_ICACHE		0x300
#define ST5505IDX_CACHE_INVALIDATE				0

#define ST5505REG_CACHE_FLUSH_DCACHE			0x400
#define ST5505IDX_CACHE_FLUSH						0

#define ST5505REG_CACHE_LOCK_CONFIGURATION	0x500
#define ST5505IDX_CACHE_LOCK						0

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\uproc\specific\st55xx\cpu5505.h ===
// FILE:      library\hardware\uproc\specific\st55xx\cpu5505.h
// AUTHOR:    D. Heidrich
// COPYRIGHT: (c) 1998 Viona Development.  All Rights Reserved.
// CREATED:   22.05.98
//
// PURPOSE:   Classes for the STi5505 chip.
//
// HISTORY:

#ifndef CPU5505_H
#define CPU5505_H

#include "cpu55xx.h"
#include "library\general\asncstrm.h"
#include "library\hardware\clocks\generic\clocks.h"


class STi5505ClockGenerator;


class STi5505 : public STi55xx
	{
	friend class STi5505ClockGenerator;
	protected:
		DWORD	fvcoFreq;

		Error ProgramClockGenerator(STi5505Clock clock, BOOL external, DWORD freq);
		Error StopClockGenerator (STi5505Clock clock);

	public:
		STi5505ClockGenerator	*	memClock;
		STi5505ClockGenerator	*	audClock;
		STi5505ClockGenerator	*	auxClock;
		STi5505ClockGenerator	*	lnkClock;

		STi5505 (void);

		virtual Error Initialize (int i2cTaskPriority, DWORD serialPortNum);
		Error InitClockGenerator(STi5505ClockSource source, WORD nominator, WORD denominator, DWORD freq);

		virtual void InterruptI2C (void);
		virtual void InterruptFrontDMA (void);

		BOOL CheckInterrupt (void);
	};



class DMAOutStream5505 : public ASyncOutStream
	{
	private:
		MemoryMappedIO *mem;
		int channelNum;
		DWORD location;
		BOOL transferAllowed;

		DWORD ReadWordHL (WORD offset);

	public:
		DMAOutStream5505 (MemoryMappedIO *mem, int channelNumber)
			{this->mem = mem; channelNum = channelNumber; location = 0; transferAllowed = FALSE;}

      virtual Error Initialize (void);
		virtual Error WriteData (HPTR data, DWORD size, DWORD __far &done);
		virtual DWORD AvailSpace (void);
		virtual DWORD AvailData (void);
		virtual DWORD GetTransferLocation (void);
		virtual void SetTransferLocation (DWORD pos);
		virtual Error StartTransfer (void);
		virtual Error StopTransfer (void);
		virtual Error SyncTransfer (void);
		virtual Error CompleteTransfer(void);
		virtual Error FlushBuffer (void);
	};


///////////////////////////////////////////////////////////////////////////////
// ST5505 Internal Programmable Clock Generator (PLL) class
///////////////////////////////////////////////////////////////////////////////

class STi5505ClockGenerator : public ProgrammableClockGenerator
	{
	friend class STi5505;
	protected:
		STi5505		*	cpu;
		STi5505Clock	clock;
	public:
		STi5505ClockGenerator (STi5505 * cpu, STi5505Clock clock)
			{
			this->cpu = cpu;
			this->clock = clock;
			}

		Error ProgramFrequency (DWORD freq);
		Error StopClock (void) {return cpu->StopClockGenerator (clock);}
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\uproc\specific\st55xx\cpu5508r.h ===
// FILE:      library\hardware\uproc\specific\st55xx\cpu5508r.h
// AUTHOR:    S. Herr
// COPYRIGHT: (c) 2000 VIONA Development GmbH & Co. KG.  All Rights Reserved.
// CREATED:   02.05.2000
//
// PURPOSE:   Register definitions for the STi5508 chip.
//
// HISTORY:

#ifndef CPU5508R_H
#define CPU5508R_H

// Include common register definitions
#include "cpu55xxr.h"

// MPEG video decoder.

#define ST5505REG_MPEG_VIDEO_SIZEOF	0x100
#define ST5508REG_MPEG_VIDEO_BASE	0x0
// For backward compatibility:
#define ST5505REG_MPEG_VIDEO_BASE2	0x0
#define ST5505REG_MPEG_VIDEO_BASE3	0x0
#define ST5505REG_MPEG_VIDEO_BASE4	0x0
#define ST5505REG_MPEG_VIDEO_BASE5	0x0


// MPEG audio decoder.

#define ST5505REG_MPEG_AUDIO_SIZEOF	0x80

#define ST5508REG_MPEG_AUDIO_BASE	0x200

// For backward compatibility:
#define ST5505REG_MPEG_AUDIO_BASE2	0x200
#define ST5505REG_MPEG_AUDIO_BASE3	0x200
#define ST5505REG_MPEG_AUDIO_BASE4	0x200
#define ST5505REG_MPEG_AUDIO_BASE5	0x200


// Karaoke processor


#define ST5508REG_KARAOKE_SIZEOF		0x30
#define ST5508REG_KARAOKE_BASE		0x700


// MPEG subpicture decoder.

#define ST5505REG_MPEG_SUB_SIZEOF	0x80
#define ST5508REG_MPEG_SUB_BASE		0x400

// For backward compatibility:
#define ST5505REG_MPEG_SUB_BASE2		0x400
#define ST5505REG_MPEG_SUB_BASE3		0x400
#define ST5505REG_MPEG_SUB_BASE4		0x400
#define ST5505REG_MPEG_SUB_BASE5		0x400


// Video encoder.

#define ST5505REG_DENC_SIZEOF			0x80

#define ST5508REG_DENC_BASE			0x600

// For backward compatibility:
#define ST5505REG_DENC_BASE2			0x600
#define ST5505REG_DENC_BASE3			0x600
#define ST5505REG_DENC_BASE4			0x600
#define ST5505REG_DENC_BASE5			0x600



// Front end.

#define ST5505REG_FRAM_DMA_BASE		0x20038000
#define ST5505REG_FRAM_DMA_SIZEOF	0x1000



// DMA controller.

#define ST5505REG_DMACTRL_SIZEOF		0x1000

#define ST5505REG_MPEGDMA0_BASE		0x20024000
#define ST5505REG_MPEGDMA1_BASE		0x20025000
#define ST5505REG_MPEGDMA2_BASE		0x20030000

#define ST5505REG_MPEGDMA_BURSTSIZE	0x00
#define ST5505REG_MPEGDMA_HOLDOFF	0x04
#define ST5505REG_MPEGDMA_ABORT		0x08
#define ST5505REG_MPEGDMA_WHICHDEC	0x0c
#define ST5505REG_MPEGDMA_STATUS		0x10
#define ST5505REG_MPEGDMA_INTACK		0x14
#define ST5505REG_MPEGDMA_SRCADD		0x18
#define ST5505REG_MPEGDMA_CNTRL		0x1c
#define ST5505REG_MPEGDMA_BLSIZE		0x20


// Teletext

#define ST5505REG_TELETEXT_BASE		0x2000a000


// Block Move

#define ST5505REG_BLOCKMOVE_BASE		0x20026000


// Synchronous Serial Channel.

#define ST5505REG_SSC_BASE				0x20009000
#define ST5505REG_SSC_SIZEOF			0x20

// Asynchronous Serial Channel.

#define ST5505REG_ASC_BASE(x)			(0x20003000 + 0x00001000 * x)
#define ST5505REG_ASC0_BASE			ST5505REG_ASC_BASE(0)
#define ST5505REG_ASC1_BASE			ST5505REG_ASC_BASE(1)
#define ST5505REG_ASC2_BASE			ST5505REG_ASC_BASE(2)
#define ST5505REG_ASC3_BASE			ST5505REG_ASC_BASE(3)
#define ST5505REG_ASC_SIZEOF			0x18


// PIO.

#define ST5505REG_PIO0_BASE			0x2000c000
#define ST5505REG_PIO1_BASE			0x2000d000
#define ST5505REG_PIO2_BASE			0x2000e000
#define ST5505REG_PIO3_BASE			0x2000f000
#define ST5505REG_PIO4_BASE			0x20010000
#define ST5505REG_PIO_SIZEOF			0x70



// IRQ

#define ST5508REG_INT_CONTROLLER_BASE				0x20000000
#define ST5508REG_INT_CONTROLLER_SIZEOF			0x200

#define ST5508REG_INT_LEVELCONTROLLER_BASE		0x20011000
#define ST5508REG_INT_LEVELCONTROLLER_SIZEOF		0x80


// The IRQ numbers are fixed. The interrupt level controller maps them onto 8 IRQ levels.

#define IRQ_NUM_PORT0			0
#define IRQ_NUM_PORT1			1
#define IRQ_NUM_PORT2			2
#define IRQ_NUM_PORT3			3
#define IRQ_NUM_PORT4			4

#define IRQ_NUM_SSC				5

#define IRQ_NUM_UNUSED			6

#define IRQ_NUM_ASC3				7
#define IRQ_NUM_ASC2				8
#define IRQ_NUM_ASC1				9
#define IRQ_NUM_ASC0				10

#define IRQ_NUM_PWM				11

#define IRQ_NUM_MPEG_DMA0		12
#define IRQ_NUM_MPEG_DMA1		13
#define IRQ_NUM_MPEG_DMA2		14

#define IRQ_NUM_BLOCK_MOVE		15

#define IRQ_NUM_MOIDEM_DMA		16

#define IRQ_NUM_EXTERNAL0		17
#define IRQ_NUM_EXTERNAL1		18
#define IRQ_NUM_EXTERNAL2		19

#define IRQ_NUM_AUDIO			20
#define IRQ_NUM_VIDEO			21

#define IRQ_NUM_SECTOR_PROC	22

#define IRQ_NUM_LINK				23


// 5508 cache control registers

#define ST5505REG_CACHE_CONTROL_BASE			0x4000
#define ST5505REG_CACHE_CONTROL_SIZEOF			0x1000

#define ST5508REG_CACHE_CACHABILITY_CONTROL0	0x0
#define ST5508REG_CACHE_CACHABILITY_CONTROL1	0x100
#define ST5508REG_CACHE_CACHABILITY_CONTROL2	0x200
#define ST5508REG_CACHE_CACHABILITY_CONTROL3	0x300

#define ST5508IDX_CACHE_BLOCK7					7
#define ST5508IDX_CACHE_BLOCK6					6
#define ST5508IDX_CACHE_BLOCK5					5
#define ST5508IDX_CACHE_BLOCK4					4
#define ST5508IDX_CACHE_BLOCK3					3
#define ST5508IDX_CACHE_BLOCK2					2
#define ST5508IDX_CACHE_BLOCK1					1
#define ST5508IDX_CACHE_BLOCK0					0

#define ST5508REG_DCACHE_NOT_SRAM				0x400

#define ST5508REG_CACHE_INVALIDATE_DCACHE		0x500
#define ST5508IDX_CACHE_INVALIDATE				0

#define ST5508REG_CACHE_FLUSH_DCACHE			0x600
#define ST5508IDX_CACHE_FLUSH						0

#define ST5508REG_CACHE_ENABLE_ICACHE			0x700

#define ST5508REG_CACHE_INVALIDATE_ICACHE		0x800

#define ST5508REG_CACHE_STATUS					0x900

#define ST5508REG_CACHE_LOCK_CONFIGURATION	0xa00
#define ST5508IDX_CACHE_LOCK						0


// Clock generator incl. Frequency Synthesizer

#define ST5508REG_CLOCK_GENERATOR_BASE			0x100
#define ST5508REG_CLOCK_GENERATOR_SIZEOF		0x100


// MPEG AV buffer control register

#define ST5508REG_MPEG_CONTROL_BASE				0xe000
#define ST5508REG_MPEG_CONTROL_SIZEOF			0x10


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\uproc\specific\st55xx\cpu55xx.h ===
// FILE:      library\hardware\uproc\specific\st55xx\cpu55xx.h
// AUTHOR:    D. Heidrich, S. Herr
// COPYRIGHT: (c) 2000 VIONA Development GmbH & Co. KG.  All Rights Reserved.
// CREATED:   02.05.2000
//
// PURPOSE:   Classes for STi55xx chips.
//
// HISTORY:

#ifndef CPU55XX_H
#define CPU55XX_H

#include "library\lowlevel\hwbusio.h"
#include "library\lowlevel\memmpdio.h"
#include "library\lowlevel\intrctrl.h"


enum STi5505ClockSource   // for CKG_PLL register
	{
	S55CS_PIXCLK		= 0,
	S55CS_POWERDOWN	= 2,
	S55CS_PCMCLK		= 1
	};

enum STi5505Clock
	{
	S55CL_AUDCLK,
	S55CL_AUXCLK,
	S55CL_SMCCLK,
	S55CL_LNKCLK,
	S55CL_MEMCLK
	};



// This is a rather dummy implementation of an Interrupt Server

class Int55xxServer : public InterruptServer
	{
	protected:
		virtual Error EnableInt (void);
		virtual Error DisableInt (void);

	public:
		Int55xxServer (void)
			{
			}
	};

inline Error Int55xxServer::EnableInt (void)
	{
	GNRAISE_OK;
	}

inline Error Int55xxServer::DisableInt (void)
	{
	GNRAISE_OK;
	}


class STi55xx
	{
	public:
		// The following objects are not initialized by construction of an object
		// of this class! They are here to describe the common memory ranges of ST55xx
		// chips.

		AsyncByteInOutBus		*i2c;

		InterruptServer		*mpegVideoIRQ;
		InterruptServer		*mpegAudioIRQ;

		MemoryMappedIO			*dmaCtrl0;
		MemoryMappedIO			*dmaCtrl1;

		MemoryMappedIO		*mpegMem;
		MemoryMappedIO		*spuMem;
		MemoryMappedIO		*encMem;
		MemoryMappedIO		*mpegAudioMem;
		MemoryMappedIO		*framLinkMem;
		MemoryMappedIO		*commMem;
		MemoryMappedIO		*pio0Mem;
		MemoryMappedIO		*pio1Mem;
		MemoryMappedIO		*pio2Mem;
		MemoryMappedIO		*pio3Mem;
		MemoryMappedIO		*pio4Mem;

		STi55xx (void);

		virtual Error Initialize (int i2cTaskPriority, DWORD serialPortNum) = 0;

		virtual void InterruptI2C (void) = 0;

		virtual void InterruptMPEGVideo (void);
		virtual void InterruptMPEGAudio (void);

		virtual BOOL CheckInterrupt (void);
	};


///////////////////////////////////////////////////////////////////////////////
// ST55xx GPIO based bit output ports
///////////////////////////////////////////////////////////////////////////////

class GPIOBitOutputPort : public BitOutputPort
	{
	private:
		MemoryMappedIO *	ioMem;
		int					at;
		DWORD					mask;
		BOOL					invertedLogic;
	public :
		Error OutBit(BIT data);

		GPIOBitOutputPort(MemoryMappedIO * ioMem, int at, BOOL invertedLogic = FALSE);
	};

///////////////////////////////////////////////////////////////////////////////
// ST55xx GPIO based bit input ports
///////////////////////////////////////////////////////////////////////////////

class GPIOBitInputPort : public BitInputPort
	{
	private:
		MemoryMappedIO *	ioMem;
		int					at;
	public :
		Error InBit(BIT __far &data);

		GPIOBitInputPort(MemoryMappedIO * ioMem, int at);
	};

///////////////////////////////////////////////////////////////////////////////
// ST55xx GPIO based bit inout ports (bidirectional)
///////////////////////////////////////////////////////////////////////////////

class GPIOBitInOutPort : public BitInOutPort
	{
	private:
		MemoryMappedIO *	ioMem;
		int					at;
		DWORD					mask;
	public :
		Error OutBit(BIT data);
		Error OutBitStroke(BIT data, DWORD micros);
		Error InBit(BIT __far &data);

		GPIOBitInOutPort(MemoryMappedIO * ioMem, int at);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\uproc\specific\st55xx\cpu55xxr.h ===
// FILE:      library\hardware\uproc\specific\st55xx\cpu55xxr.h
// AUTHOR:    D. Heidrich, S. Herr
// COPYRIGHT: (c) 2000 Viona Development.  All Rights Reserved.
// CREATED:   02.05.2000
//
// PURPOSE:   Register definitions for the STi55xx chips.
//
// HISTORY:

#ifndef CPU55XXR_H
#define CPU55XXR_H

#include "library\common\prelude.h"

// Front end.

// Register offset to the base.
#define I5505REG_FEI_GFC		0x790
#define I5505REG_FEI_SLG		0x798
#define I5505REG_FEI_REV		0x79c
#define I5505REG_FEI_SUB		0x788
#define I5505REG_FEI_SFF		0x78c

#define I5505REG_DEC_IDX		0x784
#define I5505REG_DEC_STA		0x784
#define I5505REG_DEC_DAT		0x780

#define I5505REG_DMA_ITM		0x580
#define I5505REG_DMA_ADH		0x600
#define I5505REG_DMA_ADL		0x680
#define I5505REG_DMA_ITS		0xf84
#define I5505REG_DMA_PLG		0xf88
#define I5505REG_DMA_MOD		0xf90
#define I5505REG_DMA_ENA		0xfc0
#define I5505REG_DMA_STAT		0xf80
#define I5505REG_DMA_TMO		0xf8c
#define I5505REG_DMA_ARS		0xfb0
#define I5505REG_DMA_STE		0xf00

#define I5505REG_SP_RST			0x800   // sector processor

// Synchronous Serial Channel.

#define ST5505REG_SSC_BAUDRATE		0x00

#define ST5505REG_SSC_TXBUFFER		0x04

#define ST5505REG_SSC_RXBUFFER		0x08

#define ST5505REG_SSC_CONTROL			0x0c
#define ST5505IDX_SSC_LOOPBACK		10
#define ST5505IDX_SSC_ENABLE			9
#define ST5505IDX_SSC_MASTERSEL		8
#define ST5505IDX_SSC_CLKPOLARITY	6
#define ST5505IDX_SSC_CLKPHASE		5
#define ST5505IDX_SSC_HEADCONTROL	4
#define ST5505IDX_SSC_DATAWIDTH		0, 4

#define ST5505REG_SSC_INTENABLE		0x10
#define ST5505IDX_SSC_PHASEERRORIE	4
#define ST5505IDX_SSC_RXERRORIE		3
#define ST5505IDX_SSC_TXBUFEMPTYIE	1
#define ST5505IDX_SSC_RXBUFFULLIE	0

#define ST5505REG_SSC_STATUS			0x14
#define ST5505IDX_SSC_PHASEERROR		4
#define ST5505IDX_SSC_RXERROR			3
#define ST5505IDX_SSC_TXBUFEMPTY		1
#define ST5505IDX_SSC_RXBUFFULL		0



// Asynchronous Serial Channel.

#define ST5505REG_ASC_BAUDRATE			0x00

#define ST5505REG_ASC_TXBUFFER			0x04

#define ST5505REG_ASC_RXBUFFER			0x08

#define ST5505REG_ASC_CONTROL				0x0c
#define ST5505IDX_ASC_SCENABLE			9
#define ST5505IDX_ASC_RXENABLE			8
#define ST5505IDX_ASC_RUN					7
#define ST5505IDX_ASC_LOOPBACK			6
#define ST5505IDX_ASC_PARITYODD			5
#define ST5505IDX_ASC_STOPBITS			3, 2
#define ST5505IDX_ASC_MODE					0, 3

#define ST5505REG_ASC_INTENABLE			0x10
#define ST5505IDX_ASC_OVERRUNERRORIE	5
#define ST5505IDX_ASC_FRAMEERRORIE		4
#define ST5505IDX_ASC_PARITYERRORIE		3
#define ST5505IDX_ASC_TXBUFEMPTYIE		2
#define ST5505IDX_ASC_TXEMPTYIE			1
#define ST5505IDX_ASC_RXBUFFULLIE		0

#define ST5505REG_ASC_STATUS				0x14
#define ST5505IDX_ASC_OVERRUNERROR		5
#define ST5505IDX_ASC_FRAMEERROR			4
#define ST5505IDX_ASC_PARITYERROR		3
#define ST5505IDX_ASC_TXBUFEMPTY			2
#define ST5505IDX_ASC_TXEMPTY				1
#define ST5505IDX_ASC_RXBUFFULL			0



// PIO.

#define ST5505REG_PIO_POUT				0x00
#define ST5505REG_PIO_SET_POUT		0x04
#define ST5505REG_PIO_CLR_POUT		0x08

#define ST5505REG_PIO_PIN				0x10

#define ST5505REG_PIO_PC0				0x20
#define ST5505REG_PIO_SET_PC0			0x24
#define ST5505REG_PIO_CLR_PC0			0x28

#define ST5505REG_PIO_PC1				0x30
#define ST5505REG_PIO_SET_PC1			0x34
#define ST5505REG_PIO_CLR_PC1			0x38

#define ST5505REG_PIO_PC2				0x40
#define ST5505REG_PIO_SET_PC2			0x44
#define ST5505REG_PIO_CLR_PC2			0x48

#define ST5505REG_PIO_PCOMP			0x50
#define ST5505REG_PIO_SET_PCOMP		0x54
#define ST5505REG_PIO_CLR_PCOMP		0x58

#define ST5505REG_PIO_PMASK			0x60
#define ST5505REG_PIO_SET_PMASK		0x64
#define ST5505REG_PIO_CLR_PMASK		0x68



// EMI.

#define ST5505REG_EMI_BANK0			0x40000000
#define ST5505REG_EMI_BANK1			0x50000000
#define ST5505REG_EMI_BANK2			0x60000000
#define ST5505REG_EMI_BANK3			0x70000000



// DMA channels.

#define ST5505REG_MPEG0_DMA			0x80000020
#define ST5505REG_MPEG1_DMA			0x80000024
#define ST5505REG_MPEG2_DMA			0x80000028
#define ST5505REG_BLOCKMOVE_DMA		0x80000034



// The SDRAM.

#define ST5505REG_SDRAM					0xC0000000

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\tuner\specific\fr1236.h ===
// FILE:			library\hardware\tuner\generic\FR1236.h
// AUTHOR:		Stefan Herr
// COPYRIGHT:	(c) 1996 Viona Development.  All Rights Reserved.
// CREATED:		31.07.96
//
// PURPOSE:		Definition of class for Philips FR1236 tuner (TV and FM radio support)
//
// HISTORY:

#ifndef FR1236_H
#define FR1236_H

#include "library\hardware\audio\generic\stereodc.h"
#include "library\hardware\videodma\generic\pip.h"
#include "library\hardware\video\generic\videnc.h"
#include "fi1236x.h"					// The FR1236 is an extended FI1236

// Minimum and maximum frequency for the FM band in 10^2 Hz
#define FM_LOW_LIMIT 	875000
#define FM_HIGH_LIMIT	1080000

#ifndef ONLY_EXTERNAL_VISIBLE

#define I2C_FR1236_UNIT0	0xc0	// The 1236's I2C base addresses. Up to 4 units possible.
#define I2C_FR1236_UNIT1	0xc2
#define I2C_FR1236_UNIT2	0xc4									
#define I2C_FR1236_UNIT3	0xc6									

class VirtualFR1236Tuner;

/////////////////////////////////////////////////////////////////////////////////////////////
// Class FR1236Tuner definition (physical unit)
/////////////////////////////////////////////////////////////////////////////////////////////
class FR1236Tuner : public FI1236XTuner {
	friend class VirtualFR1236Tuner;
	private:
		BOOL				fmEnable;
		BOOL				autoStep;
		SignalMode		mode;

		VirtualVideoEncoder		*fmVideoEnc;
		VirtualPIP					*fmPIP;

		VirtualStereoDecoder		*fmDecoder;
		VirtualStereoDecoder		*tvDecoder;
		
		WordInputPort	*fmSignalPort;
		BitOutputPort	*fmSelectPort;
	protected:                 
		void InitControlWordBytes();

		Error	ProgramFrequency(DWORD freq, DWORD __far & lastFreq);	// Program desired frequency into the FI1236
		Error	GetBand(DWORD freq, TVTunerBands __far & band);			// Get band for current frequency.

		Error	SetPLLDisable(BOOL pllDisable);								// *** Debugging purposes only

		virtual Error ActivateStereoDecoders();
		virtual Error PassivateStereoDecoders();

		virtual Error SetStepSize(StepRatioSelect stepSize);			// Set step size for scanning
		virtual Error SetFMEnable(BOOL fmEnable);							// Switch between TV/FM reception
		virtual Error GetMode(SignalMode __far & mode);
		virtual Error SetMode(SignalMode mode);

		Error	StartStepScan(Direction dir);
		Error ScanStep(ScanResult	__far & result,
							DWORD 		__far & curFreq,
							WORD			__far & curLevel,
						   ScanState 	__far & curState);

		Error Update(void);
		Error CheckScanInputLevel(WORD __far & level);
		Error GetSignal(BIT __far & signal);

 		Error SetFrequency(DWORD freq);
	public:
		FR1236Tuner(ByteInOutPort				*	i2cPort,					// I2C port to FR1236
						BitInputPort				*	signalPort,				// Port to video signal detection
	  				  	VirtualUnit					*	audioBus,				// Audio bus for multiplexing between MPEG and video
						VirtualStereoDecoder		*	tvDecoder,				// Access to TV stereo decoder
						VirtualStereoDecoder		*	fmDecoder,				// Access to FM stereo decoder
						WordInputPort				*	fmSignalPort,			// Port to FM signal/level detection
						BitOutputPort				*	fmSelectPort,			// Port to switch between FM/TV for external periphery,
						VirtualPIP					*	fmPIP,					// Will be activated when switching to FM
						VirtualVideoEncoder		*	fmVideoEnc				//   "        "             "           "
					 );

		VirtualUnit * CreateVirtual(void);

	};


/////////////////////////////////////////////////////////////////////////////////////////////
// Class VirtualFR1236Tuner definition (virtual unit)
/////////////////////////////////////////////////////////////////////////////////////////////

class VirtualFR1236Tuner : public VirtualFI1236XTuner {

	private:
		FR1236Tuner	*tuner;

		BOOL					fmEnable;
		StepRatioSelect	stepSize;
		SignalMode			mode;
		
	protected:
		Error DoPreempt(VirtualUnit * previous);

	public:
		VirtualFR1236Tuner(FR1236Tuner * physical, BOOL idleUnit);

		Error StartStepScan(Direction dir);
		
	 	Error	Configure (TAG __far *tags);
	};

#endif // of ONLY_EXTERNAL_VISIBLE

		
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\uproc\specific\pd4995\pd4995r.h ===
// FILE:      library\hardware\uproc\specific\pd4995\pd4995r.h
// AUTHOR:
// COPYRIGHT: (c) 1999 Ravisent Technologies. All Rights Reserved.
// CREATED:   21.09.99
//
// PURPOSE:   Definitions for Pioneer PD4995 controller for front end, panel etc.
//
// HISTORY:

#ifndef PD4995R_H
#define PD4995R_H



#define PD4995REG_FP_BASE				0x60000100
#define PD4995REG_FP_SIZEOF			0xab



#define PD4995REG_MODE_SET			0x00	// Mode Setting Register

#define PD4995IDX_CDDVD				0		// CD/DVD		0 : DVD  1 : CD
#define PD4995IDX_SINGLE_WR		1		// Single WR/RD	0 : read 1 : write
#define PD4995IDX_VDI				2		// Video DMA interface
													// 0 : asynchronous bus mode
													// 1 : synchronous pulse mode
#define PD4995IDX_VDT				3 		// Video DMA terminal
													// 0 : output terminals are high impedance
													// 1 : terminal outputs are valid
#define PD4995IDX_RCS				4, 2	// Refresh Cycle Selection
#define PD4995IDX_S_RW_BREAK		6		// Single R/W Break En
#define PD4995IDX_SPINDLE_RS		7		// Spindle Reg. Sel
													// 0: sub CPU 1: main CPU writes to the spindle servo control reg


#define PD4995REG_INIT				0x01	// Initializing Register

#define PD4995IDX_C_DMA_RESET		2		// CPU_DMA Reset
#define PD4995IDX_A_DMA_RESET		3		// Audio_DMA Reset
#define PD4995IDX_V_DMA_RESET		4		// Video_DMA Reset
#define PD4995IDX_C1_RESET			5		// C1 Reset
#define PD4995IDX_C2_RESET			6		// C2 Reset
#define PD4995IDX_MASTER_RESET	7		// Master Reset


#define PD4995REG_IRM_A						0x02	// Interrupt Mask Register A

#define PD4995IDX_ID							0		// reading ID    (for DVD)
#define PD4995IDX_SUB_Q						0		// reading Subcode Q data (for CD)
#define PD4995IDX_FIRST_LINE_END			1		// First Line End
#define PD4995IDX_BLOCK_END				2		// Block End
#define PD4995IDX_C_DMA_END				3		// CPU_DMA End
#define PD4995IDX_V_DMA_PTR_READY		4		// Video_DMA Pointer Ready
#define PD4995IDX_A_DMA_PTR_READY		5		// Audio_DMA Pointer Ready
#define PD4995IDX_RECEIVE_BUF_FULL		6		// Receive Buffer Full
#define PD4995IDX_TRANSFER_BUF_EMPTY	7		// Transfer Buffer Empty


#define PD4995REG_IRM_B				0x03	// Interrupt Mask Register B

#define PD4995IDX_FG_INT			0		// spindle FG Interrupt
#define PD4995IDX_A_FRAME			1		// Audio Block Interrupt
#define PD4995IDX_C1_BLOCK_END	2		// DVD: C1 block read operation completed -> C2 correction start
													// CD: sector read operation completed
#define PD4995IDX_V_DMA_END		4		// Video DMA competed
#define PD4995IDX_A_DMA_FIFO		5		// Audio DMA completed, FIFO empty
#define PD4995IDX_END_DETECT		6		// MPEG sequence end code detected
#define PD4995IDX_END_SST			7		// End of Synchronous Serial Transfer


#define PD4995REG_IRF_A				0x04	// Interrupt Factor Register A
// bits are same as PD4995REG_IRM_A

#define PD4995REG_IRF_B				0x05	// Interrupt Factor Register B
// bits are same as PD4995REG_IRM_B

#define PD4995REG_ITS_A				0x06	// Interrupt Terminal Selection Register A/Version Register
// bits are same as PD4995REG_IRM_A

#define PD4995REG_ITS_B				0x07	// Interrupt Terminal Selection Register B
// bits are same as PD4995REG_IRM_B


// Mapping for DVD mode.

#define PD4995REG_ID_0				0x08	// ID Register First ID Byte
#define PD4995REG_ID_8				0x09	// ID Register Second ID Byte/PLL synchronous clear (WR)
#define PD4995REG_ID_16				0x0a	// ID Register Third ID Byte
#define PD4995REG_ID_24				0x0b	// ID Register Fourth ID Byte

#define PD4995REG_ID_EDC			0x0c	// EDC Result of ID read (0x08-0x0b)

#define PD4995IDX_C1_CRCTN_INH	0		// C1 Correction Inhibited
#define PD4995IDX_C2_CRCTN_INH	1		// C2 Correction Inhibited
#define PD4995IDX_DSCRMBL_INH		2		// Descramble Inhibited
#define PD4995IDX_CORRECTED		6		// in case of error: correction successful
#define PD4995IDX_ID_EDC_OK		7		// an EDC of an ID detected no error
#define PD4995IDX_EDC_STATUS		6, 2	// EDC Status of ID


// Mapping for CD mode.

#define PD4995REG_SUBCODE_CONT	0x08	// Sub Code Control Register
#define PD4995IDX_SUB_Q_CRC		0		// Subcode Q data CRC check OK
#define PD4995IDX_SUBCODE_DMA		1		// Subcode R-W DMA enabled
#define PD4995IDX_EDC_MODE_SEL	2		// EDC Mode Selection
#define PD4995IDX_EDC_RESULT		4		// EDC Result
#define PD4995IDX_CDROM_RESYNC	5, 2	// CDROM Resync Mode

#define PD4995REG_SUBCODE_R-W		0x09
#define PD4995IDX_SUBCODE_W		0
#define PD4995IDX_SUBCODE_V		1
#define PD4995IDX_SUBCODE_U		2
#define PD4995IDX_SUBCODE_T		3
#define PD4995IDX_SUBCODE_S		4
#define PD4995IDX_SUBCODE_R		5

#define PD4995REG_SUBCODE_S0		0x0a	// writing triggers a Reed-Solomon syndrom calculation
#define PD4995REG_SUBCODE_S1		0x0b	// writing initializes this

#define PD4995REG_SUBCODE_Q		0x0c	// Subcode Q data Read Register


#define PD4995REG_SUB_CPU			0x0d	// Sub CPU Data Transfer/Reception Register (check sum)

#define PD4995REG_SCPU_STAT		0x0e	// Sub CPU Status Register
#define PD4995IDX_ATN				0		// Attention: communication request of the sub CPU / error in multibyte transfer
#define PD4995IDX_BUSY				1		// sub CPU is processing an operation
#define PD4995IDX_READY				2		// player ready to play the disk
#define PD4995IDX_COMM_BUSY		3
#define PD4995IDX_PLAYER_TYPE		5, 2	// Type of player

#define PD4995REG_MCPU_STAT		0x0f	// Main CPU Status Register
// bits 0 and 1 are analog to PD4995REG_SCPU_ST

#define PD4995REG_BYTE_RW			0x10	// CPU Single Byte Read/Write Register

#define PD4995REG_BYTE_RW_BS		0x11	// CPU Single Byte Read/Write BLOCK Setting
#define PD4995IDX_B_ADDRESS		0, 7	// Block Address
#define PD4995IDX_RAMRQ0			7		// RAMRQ0

#define PD4995REG_BYTE_RW_V		0x12	// CPU Single Byte Read/Write Address Setting (V Address)
#define PD4995REG_BYTE_RW_H		0x13	// CPU Single Byte Read/Write Address Setting (H Address)

#define PD4995REG_PD_TC						0x14	// Playback Data Transfer Control Register
#define PD4995IDX_DISK_RD_ENABLE			0		// DISK_RD Enable
#define PD4995IDX_POINTER_READY			1		// Pointer Ready
#define PD4995IDX_DISK_RD_BUSY			2		// DISK_RD Busy
#define PD4995IDX_NEXT_BLOCK_ENABLE		3		// Next Block Enable
#define PD4995IDX_SECTOR_NO				4, 4	// Sector No.

#define PD4995REG_PD_TBS			0x15	// Playback Data Transfer Block Specification/Playback End Block
#define PD4995IDX_BLOCK_NUMBER	0, 7	// Block Number


#define PD4995REG_PD_EDC_8			0x16	// Playback Data EDC Register
#define PD4995IDX_SECTOR_8			0		// EDC Result of Sector 8
#define PD4995IDX_SECTOR_9			1		// EDC Result of Sector 9
#define PD4995IDX_SECTOR_10		2		// EDC Result of Sector 10
#define PD4995IDX_SECTOR_11		3		// EDC Result of Sector 11
#define PD4995IDX_SECTOR_12		4		// EDC Result of Sector 12
#define PD4995IDX_SECTOR_13		5		// EDC Result of Sector 13
#define PD4995IDX_SECTOR_14		6		// EDC Result of Sector 14
#define PD4995IDX_SECTOR_15		7		// EDC Result of Sector 15

#define PD4995REG_PD_EDC_0			0x17	// Playback Data EDC Register
#define PD4995IDX_SECTOR_0			0		// EDC Result of Sector 0
#define PD4995IDX_SECTOR_1			1		// EDC Result of Sector 1
#define PD4995IDX_SECTOR_2			2		// EDC Result of Sector 2
#define PD4995IDX_SECTOR_3			3		// EDC Result of Sector 3
#define PD4995IDX_SECTOR_4			4		// EDC Result of Sector 4
#define PD4995IDX_SECTOR_5			5		// EDC Result of Sector 5
#define PD4995IDX_SECTOR_6			6		// EDC Result of Sector 6
#define PD4995IDX_SECTOR_7			7		// EDC Result of Sector 7

// CD Mode for the above two registers should be added later

// register definition for 0x18 - 0x4f will be added here later


#define PD4995REG_V_DMA_CONTROL				0x20

#define PD4995IDX_DMA_ENABLE					0
#define PD4995IDX_V_POINTER_READY			1
#define PD4995IDX_MAX_TRANSFER_RATE			5
#define PD4995IDX_XWR_TERMINAL_DUTY_RATE	6


#define PD4995REG_V_DMA_BLOCK				0x21

#define PD4995REG_V_DMA_ADDRESS_V		0x22
#define PD4995REG_V_DMA_ADDRESS_H		0x23

#define PD4995REG_V_DMA_BYTECOUNT8		0x24
#define PD4995REG_V_DMA_BYTECOUNT0		0x25


#define PD4995REG_CD_SHOCKMODE			0x46

#define PD4995IDX_RESET_SHOCK_MODE		0


// 0x50 - 0x5e not specified


#define PD4995REG_SETUP_MEDIA				0x5f

#define PD4995IDX_ASDATA_EN				2		// validate terminal outputs
#define PD4995IDX_CDDA_SEL					7		// select CD/DA


#define PD4995REG_COMMAND			0x60
#define PD4995REG_PARAMETER_0		0x61
#define PD4995REG_PARAMETER_1		0x62
#define PD4995REG_PARAMETER_2		0x63
#define PD4995REG_PARAMETER_3		0x64
#define PD4995REG_PARAMETER_4		0x65
#define PD4995REG_PARAMETER_5		0x66
#define PD4995REG_PARAMETER_6		0x67


#define PD4995REG_SSP_CPS			 	0x68	// Synchronous Serial Port Clock and Prescalar Setting Register
#define PD4995IDX_DIVIDING_VALUE 	0, 6	// Dividing Value

#define PD4995REG_SSP_IC			 	0x69	// Synchronous Serial Port Interrupt Control Register
#define PD4995IDX_SCI_CH0_EOT	 		0		// SCI CH0 End of Transfer
#define PD4995IDX_SCI_CH1_EOT	 		1		// SCI CH1 End of Transfer
#define PD4995IDX_SCI_CH2_EOT	 		2		// SCI CH2 End of Transfer
#define PD4995IDX_SCI_CH0_INT_MASK	4		// SCI CH0 INT Mask
#define PD4995IDX_SCI_CH1_INT_MASK	5		// SCI CH1 INT Mask
#define PD4995IDX_SCI_CH2_INT_MASK	6		// SCI CH2 INT Mask


// Register definitions for 0x6a - 0x6f will be added here later

#define PD4995REG_PFS					0x70	// Pin Function Setup Register
#define PD4995IDX_PAPORT				0		// PA Port Main/Sub
#define PD4995IDX_PBPORT				1		// PB Port Main/Sub
#define PD4995IDX_PCPORT				2		// PC Port Main/Sub
#define PD4995IDX_PBSELECT				3		// PB Select Ned/Port
#define PD4995IDX_PCSELECT				4		// PC Select Stat/Port

#define PD4995REG_PA_PORT_DD			0x71	// PA Port Data Direction Register
#define PD4995REG_PB_PORT_DD			0x72	// PB Port Data Direction Register
#define PD4995REG_PC_PORT_DD			0x73	// PC Port Data Direction Register
#define PD4995IDX_DIR0					0		// Direction for port bit 0
#define PD4995IDX_DIR1					1		// Direction for port bit 1
#define PD4995IDX_DIR2					2		// Direction for port bit 2
#define PD4995IDX_DIR3					3		// Direction for port bit 3
#define PD4995IDX_DIR4					4		// Direction for port bit 4
#define PD4995IDX_DIR5					5		// Direction for port bit 5
#define PD4995IDX_DIR6					6		// Direction for port bit 6
#define PD4995IDX_DIR7					7		// Direction for port bit 7

#define PD4995REG_PA_PORT_DATA		0x74	// PA Port Data
#define PD4995REG_PB_PORT_DATA		0x75	// PB Port Data
#define PD4995REG_PC_PORT_DATA		0x76	// PC Port Data

// 0x77 not specified
// Register definitions for 0x78 - 0x7f will be added here later


/*** Register definitions for Front Panel ***/

// For front panel registers, you must add PD4995REG_FP_BASEADDRESS, which is now 0x100
// this will be changed to 0x00 with the next hardware revision

#define PD4995REG_DATA_0				0x80
#define PD4995REG_DATA_1				0x81
#define PD4995REG_DATA_2				0x82
#define PD4995REG_DATA_3				0x83
#define PD4995REG_DATA_4				0x84
#define PD4995REG_DATA_5				0x85
#define PD4995REG_DATA_6				0x86
#define PD4995REG_DATA_7				0x87
#define PD4995REG_DATA_8				0x88
#define PD4995REG_DATA_9				0x89
#define PD4995REG_DATA_A				0x8a
#define PD4995REG_DATA_B				0x8b
#define PD4995REG_DATA_C				0x8c
#define PD4995REG_ECHO					0x8d
#define PD4995REG_DATA_E				0x8e
#define PD4995REG_CHECKSUM				0x8f


#define PD4995REG_TX_MODE_SETUP		0xa0	// Transmission Mode Setup
#define PD4995REG_TX_CONTROL			0xa1	// Transmission Control

#define PD4995REG_TX_LENGTH			0xa3	// Transmission Length
#define PD4995REG_TX_CLOCK				0xa4	// Transmission Clock
#define PD4995REG_TX_PORT_CONTROL	0xa8	// Transmission Port Control
#define PD4995REG_TX_IRQ_EOT			0xa9	// IRQ for End of Transmission

#define PD4995REG_PA_PORT_CONT		0xaa	// Control of PA Port
#define PD4995IDX_PA_LSB				0		// LSB first
#define PD4995IDX_PA6_ALTERNATE		1		// Alternate function (use serial data)
#define PD4995IDX_PA7_ALTERNATE		2		// Alternate function (use serial clock)
#define PD4995IDX_PA_CLOCK				3, 2	// Set up of the clock
#define PD4995IDX_PA_RESET				7		// Port reset

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\uproc\specific\st55xx\Dcy.h ===
#ifndef DECRYPTION_H
#define DECRYPTION_H

#define VIONA_VERSION			1
#undef ONLY_EXTERNAL_VISIBLE

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"

#define ONLY_EXTERNAL_VISIBLE	1

#include "library\hardware\mpeg2dec\generic\mpeg2dec.h"

Error GlobalDoAu (MPEG2DVDAuthenticationCommand com, DWORD sector, BYTE * key, BYTE * resultKey);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\uproc\specific\st55xx\frnt5505.h ===
// FILE:      library\hardware\uproc\specific\st55xx\frnt5505.h
// AUTHOR:    D. Heidrich, H. Horak
// COPYRIGHT: (c) 1998 Viona Development.  All Rights Reserved.
// CREATED:   13.08.98
//
// PURPOSE:   STi5505 front-end.
//
// HISTORY:

#ifndef FRNT5505_H
#define FRNT5505_H

#include "library\lowlevel\memmpdio.h"
#include "library\common\krnlsync.h"

#include <semaphor.h>



enum FrontEnd5505DataSource
	{
	// Source port of incoming data.
	FE5505DS_FEC, FE5505DS_PARALLEL,
	FE5505DS_FEC_TMM   // special mode with bug fixes
	};



enum FrontEnd5505BufferStatus
	{
	FE5505BSTAT_FREE,			// no restrictions
	FE5505BSTAT_LOCKED,		// locked buffers don't receive new data
	FE5505BSTAT_UNLOCKED		// buffers was just unlocked and cannot contain new data
	};



class STi5505FrontEnd : public VDMutex
	{
	private:
		MemoryMappedIO *mem;
		int irqLevel;
		FrontEnd5505DataSource dataSource;
		BOOL driveIsTMM, cdModeIsTMM;

		BYTE chipVersion;

		DWORD config;
		enum {
			DECRYPT_RESET, DECRYPT_RUNNING, DECRYPT_STOPPED
			} decryptionState;

		DWORD startSector, endSector;
		int sectorsToTransfer;
		int maxTimeout;

		int startBufferNumber;
		int currentBuffer;

		int sectorsLeft;
		DWORD firstTarget;

		BOOL streamingIn;   // TRUE if data is coming in from the startSector
		BOOL readingFirst;

		int stoppedCount;

		DWORD dmaAdhStart, dmaAdlStart;
		DWORD dmaAdh, dmaAdl;
		DWORD safeAdh, safeAdl;

		// Track buffer mapping table.
		DWORD *bufferMap;
		int bufferMapEntries;
		int sectorSize;
		int totalSectors;
		BOOL dvdMode;
		int defaultDVDSectorSize;
		BYTE *overflowArea;

		FrontEnd5505BufferStatus *bufferStatus;

		void InternalStopTransfer (void);

	public:
		STi5505FrontEnd (MemoryMappedIO *mem, int irqLevel, int defaultDVDSectorSize, FrontEnd5505DataSource source);
		virtual ~STi5505FrontEnd (void);

		virtual Error Initialize (void);

		virtual Error InitTrackBufferMapping (semaphore_t *wakeUp, BYTE *trackBuffer,
		                                      int sectorOffset, int totalSectors, int sectorSize,
		                                      FrontEnd5505BufferStatus *bufferStatusMap,
		                                      BYTE *overflowArray = NULL, int overflowSectors = 0,
		                                      BOOL linearMapping = FALSE);

		// Note: At least five sectors should be requested.
		Error StartTransfer (int bufferNum, DWORD startSector, int nSectors);

		void StopTransfer (void);

		void RedirectAndWait (BYTE *buffer);

		// Note: Call this only if at least two buffers are not successful yet.
		Error AddTransferBuffers (int nBuffers);

		BOOL IsValidSector (BYTE *sector, DWORD &sectorNumber);

		Error ResetDecryption (void);

		void SuspendDecryption (void);
		void ResumeDecryption (void);

		Error StartAuthentication (DWORD sector);
		Error ReadChallengeKey (BYTE *key);
		Error WriteBusKey (BYTE *key);
		Error WriteChallengeKey (BYTE *key);
		Error ReadBusKey (BYTE *key);
		Error WriteDiskKey (BYTE *key);
		Error WriteTitleKey (BYTE *key);

		void InterruptDMA (void);


		// only for prototype!!!
		int sectorsTransferred;   // counts successfully read sectors
		semaphore_t *wakeUp;   // to signal the receiver
		BOOL stopped;
		BOOL dmaActive;
		int arOverflows, validOverflows;
		int eofCount;
		void PrintDebugStat (void);
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\video\generic\VIDCHIP.H ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


// FILE:      library\hardware\video\generic\vidchip.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   24.03.95
//
// PURPOSE: The abstract class for video decoder/encoder chip programming.
//
// HISTORY:

#ifndef VIDEOCHIP_H
#define VIDEOCHIP_H

#include "library\common\gnerrors.h"
#include "library\common\tags.h"
#include "library\common\tagunits.h"

#ifndef ONLY_EXTERNAL_VISIBLE
#include "library\common\virtunit.h"
#endif

#include "vidtypes.h"


MKTAG (VID_VIDEOSTANDARD,				VIDEO_CHIP_UNIT, 0x0001, VideoStandard)
MKTAG (VID_MODE,							VIDEO_CHIP_UNIT, 0x0002, VideoMode    )
MKTAG (VID_EXTSYNC,						VIDEO_CHIP_UNIT, 0x0003, BOOL         )
MKTAG (VID_PAL_VIDEOSUBSTANDARD,		VIDEO_CHIP_UNIT, 0x0004, PALVideoSubStandard)
MKTAG (VID_NTSC_VIDEOSUBSTANDARD,	VIDEO_CHIP_UNIT, 0x0005, NTSCVideoSubStandard)


#ifndef ONLY_EXTERNAL_VISIBLE

class VideoChip : public PhysicalUnit {
	public:
		virtual Error SetVideoStandard(VideoStandard std) = 0;
		virtual Error SetMode(VideoMode mode) = 0;
		virtual Error SetExtSync(BOOL extsync) = 0;
		virtual Error SetPALVideoSubStandard(PALVideoSubStandard palSubStandard) {GNRAISE_OK;}
		virtual Error SetNTSCVideoSubStandard(NTSCVideoSubStandard ntscSubStandard) {GNRAISE_OK;}
	};

class VirtualVideoChip : public VirtualUnit {
	protected:
		VideoStandard			standard;
#if TEST_PAL_TO_NTSC
		MovingImageStandard	movingImageStandard;		// current moving Image standard
#endif
		PALVideoSubStandard	palSubStandard;
		NTSCVideoSubStandard	ntscSubStandard;
		VideoMode		mode;
		BOOL				extSync;
		VideoChip	*	chip;

		Error Preempt(VirtualUnit *previous);
	public:
		VirtualVideoChip (VideoChip *physical);
		Error Configure(TAG __far * tags);
	};



#endif // ONLY_EXTERNAL_VISIBLE




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\video\generic\viddec.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


// FILE:      library\hardware\video\generic\viddec.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   24.03.95
//
// PURPOSE: The abstract class for video decoder programming.
//
// HISTORY:

#ifndef VIDEODECODER_H
#define VIDEODECODER_H

#include "library\common\gnerrors.h"
#include "vidchip.h"


#ifndef ONLY_EXTERNAL_VISIBLE

#include "library\lowlevel\hardwrio.h"

#endif

#define MAX_Brightness  10000
#define MAX_Contrast    10000
#define MAX_Saturation  10000
#define MAX_Hue         10000


#define VIDDEC_InputNameMaxSize  40

struct VideoDecoderInputEntry
	{
	TCHAR name[VIDDEC_InputNameMaxSize];
	};


// Note that the tag enumeration must start after those of VideoChipClass !

MKTAG (DEC_INPUT_NUMBER, VIDEO_DECODER_UNIT, 0x0001001, WORD)
MKTAG (DEC_INPUT_NAMES,  VIDEO_DECODER_UNIT, 0x0001002, VideoDecoderInputEntry __far *)
MKTAG (DEC_INPUT,        VIDEO_DECODER_UNIT, 0x0001003, WORD)
// Each decoder has its own number of input lines. For flexibility, you ask
// for the number of input lines by GET_DEC_INPUT_NUMBER, then allocate enough
// space to hold DEC_INPUT_NUMBER times a struct VideoDecoderInputEntry,
// then call DEC_INPUT_NAMES to get an array of these structs filled
// with DEC_INPUT_NUMBER entries.

MKTAG (DEC_BRIGHTNESS, VIDEO_DECODER_UNIT, 0x0001004, WORD)
MKTAG (DEC_CONTRAST,   VIDEO_DECODER_UNIT, 0x0001005, WORD)
MKTAG (DEC_SATURATION, VIDEO_DECODER_UNIT, 0x0001006, WORD)
MKTAG (DEC_HUE,        VIDEO_DECODER_UNIT, 0x0001007, WORD)

MKTAG (DEC_DETECT_STD, VIDEO_DECODER_UNIT, 0x0001008, VideoStandard)
MKTAG (DEC_SAMPLEMODE, VIDEO_DECODER_UNIT, 0x0001009, VideoSampleMode)
MKTAG (DEC_TELETEXT,   VIDEO_DECODER_UNIT, 0x0002001, BOOL)


// Errors from the video decoder.

#define GNR_VDEC_PARAMS		MKERR(ERROR, VDECODER, PARAMS,   0x01)
	// illegal parameters

#define GNR_VDEC_NODETECT	MKERR(ERROR, VDECODER, PARAMS,   0x02)
	// video standard not detected



#ifndef ONLY_EXTERNAL_VISIBLE


class VideoDecoder : public VideoChip
	{
	friend class VirtualVideoDecoder;

	protected:
		VirtualUnit	*videoBus;
		WORD numInputs;
		VideoDecoderInputEntry __far *inputNames;

		Error Lock (VirtualUnit *unit);
		Error Unlock (VirtualUnit *unit);

	public:
		BitInputPort *signalPort;

		VideoDecoder (VirtualUnit *videoBus, WORD numInputs = 0, VideoDecoderInputEntry __far *inputNames = NULL)
			{
			this->videoBus   = videoBus;
			this->numInputs  = numInputs;
			this->inputNames = inputNames;
			this->signalPort = NULL;
			}

		virtual Error SetInput (WORD input) = 0;
		virtual Error SetBrightness (WORD brightness) = 0;
		virtual Error SetContrast (WORD contrast) = 0;
		virtual Error SetSaturation (WORD saturation) = 0;
		virtual Error SetHue (WORD hue) = 0;
		virtual Error SetSampleMode (VideoSampleMode mode) = 0;
		virtual Error SetTeletextMode (BOOL mode) {GNRAISE_OK;}

		virtual Error DetectVideoStandard (VideoStandard __far &std) = 0;
	};


class VirtualVideoDecoder : public VirtualVideoChip
	{
	protected:
		VideoDecoder	*	decoder;

		WORD 					input;
		WORD					brightness;
		WORD					contrast;
		WORD					saturation;
		WORD					hue;
		VideoSampleMode	sampleMode;
		BOOL					teletext;

		Error Preempt(VirtualUnit *previous);

	public:
		VirtualVideoDecoder(VideoDecoder *physical);
		Error Configure(TAG __far * tags);
	};



#endif // ONLY_EXTERNAL_VISIBLE



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\uproc\specific\st55xx\i2c5505.h ===
// FILE:      library\hardware\uproc\specific\st55xx\i2c5505.h
// AUTHOR:    D. Heidrich
// COPYRIGHT: (c) 1998 Viona Development.  All Rights Reserved.
// CREATED:   22.05.98
//
// PURPOSE:   I2C classes for the STi5505 chip.
//
// HISTORY:

#ifndef I2C5505_H
#define I2C5505_H

#include "library\common\prelude.h"
#include "library\general\lists.h"
#include "library\lowlevel\hwbusio.h"
#include "library\lowlevel\memmpdio.h"



class I2CRequest5505;


class I2CBus5505 : public AsyncByteInOutBus
	{
	friend class I2CRequest5505;

	public:
		// Members of ByteInputBus.
		virtual Error InByte (int unit, int reg, BYTE __far &data);
		virtual Error InByte (int unit, BYTE __far &data);
		virtual Error InBytes (int unit, int reg, int inc, BYTE __far *data, int num);
		virtual Error InBytes (int unit, BYTE __far *data, int num);

		// Members of ByteOutputBus.
		virtual Error OutByte (int unit, int reg, BYTE data);
		virtual Error OutByte (int unit, BYTE data);
		virtual Error OutBytes (int unit, int reg, int inc, BYTE __far *data, int num);
		virtual Error OutBytes (int unit, BYTE __far *data, int num);
		virtual Error OutByteSeqA (int unit, int reg, int inc, int __far *data);
		virtual Error OutByteSeqA (int unit, int __far *data);
		virtual Error OutBytePairsA (int unit, int __far *data);

		// Members of AsyncIODevice.
		virtual Error AllocateRequest (AsyncIORequest __far * __far &request);
		virtual Error FreeRequest (AsyncIORequest __far *request);

		// Members of AsyncByteInputBus.
		virtual Error AsyncInByte (int unit, AsyncIORequest __far *request, int reg, BYTE __far &data);
		virtual Error AsyncInByte (int unit, AsyncIORequest __far *request, BYTE __far &data);
		virtual Error AsyncInBytes (int unit, AsyncIORequest __far *request, int reg, int inc, BYTE __far *data, int num);
		virtual Error AsyncInBytes (int unit, AsyncIORequest __far *request, BYTE __far *data, int num);

		// Members of AsyncByteOutputBus.
		virtual Error AsyncOutByte (int unit, AsyncIORequest __far *request, int reg, BYTE data);
		virtual Error AsyncOutByte (int unit, AsyncIORequest __far *request, BYTE data);
		virtual Error AsyncOutBytes (int unit, AsyncIORequest __far *request, int reg, int inc, BYTE __far *data, int num);
		virtual Error AsyncOutBytes (int unit, AsyncIORequest __far *request, BYTE __far *data, int num);
		virtual Error AsyncOutByteSeqA (int unit, AsyncIORequest __far *request, int reg, int inc, int __far *data);
		virtual Error AsyncOutByteSeqA (int unit, AsyncIORequest __far *request, int __far *data);
		virtual Error AsyncOutBytePairsA (int unit, AsyncIORequest __far *request, int __far *data);

		// New members.
		I2CBus5505 (MemoryMappedIO *mem, MemoryMappedIO *pio);
		~I2CBus5505 (void);

		Error Initialize (int taskPriority);

		void HandlerTask (void);

		void Interrupt (void);   // interrupt function

	private:
		BOOL initialized;
		MemoryMappedIO *mem;
		MemoryMappedIO *pio;

		// This list contains the IO requests. Access is controlled with a mutex.
		I2CRequest5505 volatile *currentRequest;   // is not in the list
		semaphore_t mutex;        // grants exclusive list access
		List ioRequestList;
		semaphore_t newRequest;   // signals handler task there's a new request or a request done

		Error ResetBus (void);
		void SendStart (void);
		void SendStop (void);
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\video\generic\VIDENC.H ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


// FILE:      library\hardware\video\generic\videnc.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   24.03.95
//
// PURPOSE: The abstract class for video encoder programming.
//
// HISTORY:

#ifndef VIDEOENCODER_H
#define VIDEOENCODER_H

#include "library\common\gnerrors.h"

#ifndef ONLY_EXTERNAL_VISIBLE
#include "library\common\profiles.h"
#include "library\lowlevel\intrctrl.h"
#endif

#include "vidchip.h"
#include "l21recvr.h"



MKTAG (ENC_SAMPLEMODE,						VIDEO_ENCODER_UNIT, 0x1001, VideoSampleMode)
MKTAG (ENC_HOFFSET,							VIDEO_ENCODER_UNIT, 0x1002, int)
MKTAG (ENC_VOFFSET,							VIDEO_ENCODER_UNIT, 0x1003, int)

// The idle screen mapping depends on the specific video encoder. First ask
// for the number of entries via GET_ENC_IDLE_NUMBER, then allocate enough
// space to hold ENC_IDLE_NUMBER times a struct VideoEncoderIdleEntry,
// then call GET_ENC_IDLE_ENTRY to get an array of these structs filled
// with ENC_IDLE_NUMBER entries.

#define VIDENC_IdleNameMaxSize  40

struct __far VideoEncoderIdleEntry
	{
	int number;   // in increasing order
	TCHAR name[VIDENC_IdleNameMaxSize];
	};

MKTAG (ENC_IDLESCREEN,						VIDEO_ENCODER_UNIT, 0x1004, int)   // global for all units
MKTAG (ENC_IDLE_NUMBER,						VIDEO_ENCODER_UNIT, 0x1005, int)   // global for all units
MKTAG (ENC_IDLE_ENTRY,						VIDEO_ENCODER_UNIT, 0x1006, VideoEncoderIdleEntry __far *)   // global for all units

MKTAG (ENC_COPY_PROTECTION,				VIDEO_ENCODER_UNIT, 0x1007, int)

MKTAG (ENC_CHROMA_FILTER,					VIDEO_ENCODER_UNIT, 0x1008, DWORD)

MKTAG (ENC_SVIDEO_ACTIVE,					VIDEO_ENCODER_UNIT, 0x1009, BOOL)

enum OutputSelect
	{
	ENC_TV,
	ENC_VCR,
	VCR_TV
	};

MKTAG (ENC_SET_OUTPUT,						VIDEO_ENCODER_UNIT, 0x1000a, OutputSelect)
MKTAG (ENC_SET_PRESENTATION_MODE,		VIDEO_ENCODER_UNIT, 0x1000b, VideoPresentationMode)

enum ComponentOutputMode
	{
	VCOMPOM_DEFAULT,	// let the Video Encoder implementation decide
	VCOMPOM_DISABLE,	// force to no output
	VCOMPOM_YUV,
	VCOMPOM_RGB
	};

// Selects which type of component output to use
MKTAG (ENC_COMPONENT_OUTPUT,				VIDEO_ENCODER_UNIT, 0x1020, ComponentOutputMode)

// Used for CGMS information
MKTAG (ENC_COPY_MODE,						VIDEO_ENCODER_UNIT, 0x1025, VideoCopyMode)

// Set the following from 0 to 10000. 5000 is neutral (default) setting
MKTAG (ENC_BRIGHTNESS,						VIDEO_ENCODER_UNIT, 0x1030, WORD)
MKTAG (ENC_CONTRAST,							VIDEO_ENCODER_UNIT, 0x1031, WORD)
MKTAG (ENC_SATURATION,						VIDEO_ENCODER_UNIT, 0x1032, WORD)
MKTAG (ENC_HUE,								VIDEO_ENCODER_UNIT, 0x1033, WORD)

MKTAG (ENC_ACTIVE_MUX_SRC,					VIDEO_ENCODER_UNIT, 0x3000, VideoMuxSource)
	// VIDEOMUXSRC_INTERNAL or VIDEOMUXSRC_EXTERNAL
MKTAG (ENC_LINE_MODE,						VIDEO_ENCODER_UNIT, 0x3001, VideoLineMode)
	// VLM_PROGRESSIVE or VLM_INTERLACED
MKTAG (ENC_PIXCLK_MODE,						VIDEO_ENCODER_UNIT, 0x3002, VideoPixClockMode)
	// VIDEOPIXCLK_INTERNAL or VIDEOPIXCLK_EXTERNAL
MKTAG (ENC_EMBEDDED_SYNC,					VIDEO_ENCODER_UNIT, 0x3003, BOOL)
MKTAG (ENC_HSYNC_POLARITY,					VIDEO_ENCODER_UNIT, 0x3005, BOOL)
MKTAG (ENC_VSYNC_POLARITY,					VIDEO_ENCODER_UNIT, 0x3006, BOOL)
MKTAG (ENC_STARTACTIVEPIXEL_DELAY,		VIDEO_ENCODER_UNIT, 0x3007, int)

// Errors from the video encoder.

#define GNR_VENC_PARAMS						MKERR(ERROR, VENCODER, PARAMS,  0x01)
	// illegal parameters
#define GNR_MACROVISION_NOT_SUPPORTED	MKERR(ERROR, VENCODER, GENERAL, 0x02)

#define GNR_CC_NOT_SUPPORTED				MKERR(ERROR, VENCODER, GENERAL, 0x03)

#ifndef ONLY_EXTERNAL_VISIBLE


class VideoEncoder : public VideoChip
	{
	friend class VirtualVideoEncoder;

	protected:
		GenericProfile *profile;
		int idleScreen;
		int nIdleScreens;
		VideoEncoderIdleEntry __far *idleEntries;
		BOOL svideoActive;

	public:
		VideoEncoder (GenericProfile *profile = NULL, int nIdleScreens = 0,
		              VideoEncoderIdleEntry __far *idleEntries = NULL);

		// Dynamic type conversion routine to InterruptHandeler
		virtual InterruptHandler * ToInterruptHandler(void)	{return NULL;}
#if TEST_PAL_TO_NTSC
		virtual Error SetVideoStandard (VideoStandard standard)			{GNRAISE_OK;}
		virtual Error SetMovingImageStandard (MovingImageStandard mis)	{GNRAISE_OK;}
#endif
		virtual Error SetSampleMode (VideoSampleMode mode) = 0;
		virtual Error SetHOffset (int offset) = 0;
		virtual Error SetVOffset (int offset) = 0;
		virtual Error SetIdleScreen (int idleScreen);
		virtual Error SetCopyProtection(int protection)					{GNRAISE_OK;}
		virtual Error SetChromaFilter(DWORD frequency)					{GNRAISE_OK;}
		virtual Error SetSVideoActive (BOOL active)						{GNRAISE_OK;}
		virtual Error SetComponentOut (ComponentOutputMode compOut)	{GNRAISE_OK;}
		virtual void DeactivateOutputs (void) = 0;
		virtual void ReactivateOutputs (void) = 0;
	};


class VirtualVideoEncoder : public VirtualVideoChip
	{
	protected:
		VideoEncoder			*encoder;
		VideoSampleMode		sampleMode;
		int						hOffset, vOffset;   // from 7110/7111 timing
		int						copyProtection;
		DWORD						chromaFilterFrequency;
		ComponentOutputMode	compOut;

		Error Preempt (VirtualUnit *previous);
	public:
		VirtualVideoEncoder (VideoEncoder *encoder);
		Error Configure (TAG __far * tags);

		// Dynamic type conversion routine to Line21Receiver
		virtual Line21Receiver * ToLine21Receiver(void) {return NULL;}
	};

#endif // ONLY_EXTERNAL_VISIBILE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\video\generic\ccapvenc.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef CCAPVENC_H
#define CCAPVENC_H

#include "videnc.h"

#ifndef ONLY_EXTERNAL_VISIBLE

#define CCENCBUFFERSIZE	512

class CloseCaptionVideoEncoder : public VideoEncoder, public InterruptHandler
	{
	protected:
		virtual Error GetCCStatus(BOOL __far & first, BOOL __far & second) = 0;
		virtual Error PutCCData(BOOL field, BYTE d1, BYTE d2) = 0;
		virtual Error EnableCCTransfer(void) = 0;
		virtual Error DisableCCTransfer(void) = 0;

		char	ccbuffer[CCENCBUFFERSIZE];
		int	ccfirst, cclast;
		BOOL	cctransfer;
		BOOL	ccLastField;
		BOOL	ccflushed;
		BOOL	ccflushing;
		int	ccflushcnt;

	public:
		CloseCaptionVideoEncoder(GenericProfile * profile = NULL, int nIdleScreens = 0,
		                         VideoEncoderIdleEntry __far * idleEntries = NULL);

		// Dynamic type conversion routine to InterruptHandeler
		virtual InterruptHandler * ToInterruptHandler(void) {return this;}

		virtual void Interrupt(void);

		virtual Error AddCloseCaptionData(BOOL startField, BYTE __far * data, int num);
		virtual Error FlushCloseCaptionBuffer(void);
		virtual Error StartCloseCaptionTransfer(void);
		virtual Error StopCloseCaptionTransfer(void);
	};

class VirtualCloseCaptionVideoEncoder : public VirtualVideoEncoder, public Line21Receiver
	{
	private:
		CloseCaptionVideoEncoder	*	encoder;

	protected:
		BOOL	cctransfer;

		Error Preempt(VirtualUnit * previous);
	public:
		VirtualCloseCaptionVideoEncoder(CloseCaptionVideoEncoder * encoder);

		// Dynamic type conversion routine to Line21Receiver
		virtual Line21Receiver * ToLine21Receiver(void) {return this;}

		virtual Error AddCloseCaptionData(BOOL startField, BYTE __far * data, int num);
		virtual Error FlushCloseCaptionBuffer(void);
		virtual Error StartCloseCaptionTransfer(void);
		virtual Error StopCloseCaptionTransfer(void);
	};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\video\generic\l21recvr.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:			library\hardware\video\generic\l21recvr.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 2000 VIONA Development.  All Rights Reserved.
// CREATED:		02.03.2000
//
// PURPOSE:		Line 21 Data Stream Receiver Base Class
//
// HISTORY:

#ifndef L21RECVR_H
#define L21RECVR_H

#include "library/common/prelude.h"

#ifndef ONLY_EXTERNAL_VISIBLE

class Line21Receiver
	{
	public:
		virtual Error AddCloseCaptionData(BOOL startField, BYTE __far * data, int num) = 0;
		virtual Error FlushCloseCaptionBuffer(void) = 0;
		virtual Error StartCloseCaptionTransfer(void) = 0;
		virtual Error StopCloseCaptionTransfer(void) = 0;
	};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\video\generic\videvice.h ===
// FILE:      library\hardware\video\generic\videvice.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1996 Viona Development.  All Rights Reserved.
// CREATED:   09.10.96
//
// PURPOSE: Video device tags define which attributes are available on the video bus.
//
// HISTORY:

#ifndef VIDEVICE_H
#define VIDEVICE_H

#include "..\..\..\common\prelude.h"
#include "..\..\..\common\tags.h"
#include "..\..\..\common\tagunits.h"
#include "..\..\..\common\virtunit.h"
#include "vidtypes.h"

// Video Content Types

// Interlaced material (two fields of a frame independent)
#define	VCT_INTERLACED			MKFLAG(0)
// Progressive material (two fields of a frame identical)
#define	VCT_PROGRESSIVE		MKFLAG(1)
// Material for which 3:2 pulldown may be applied:
#define	VCT_MOVIE				MKFLAG(2)

// Content is a still sequence (stopped/paused)
#define	VCT_STILL_SEQUENCE	MKFLAG(3)
#define	VCT_STOPPED				MKFLAG(4)
#define	VCT_PAUSED				MKFLAG(5)

#define	VCT_HALFWIDTH			MKFLAG(6)
#define	VCT_HALFHEIGHT			MKFLAG(7)


#ifndef ONLY_EXTERNAL_VISIBLE

enum VideoHorizontalReference
	{
	VHR_HSYNC,
	VHR_HREF,
	VHR_HBLANK,
	VHR_CBLANK,
	VHR_CCIR656
	};

enum VideoVerticalReference
	{
	VVR_VSYNC,
	VVR_VREF,
	VVR_VBLANK,
	VVR_ODD_EVEN,
	VVR_CBLANK,
	VVR_CCIR656
	};
	
enum VideoFieldIndication
	{
	VFID_INTERNAL,
	VFID_EXTERNAL_ODD,
	VFID_EXTERNAL_EVEN,
	VFID_INTERNAL_REVERSE_POL   // reverse polarity
	};

MKTAG (VDV_VIDEOSTANDARD,			VIDEO_DEVICE_UNIT, 0x0000001, VideoStandard)
//MKTAG (VDV_COLORSTANDARD,	VIDEO_DEVICE_UNIT, 0x0000002, yet undefined enum)
MKTAG (VDV_SAMPLEMODE,				VIDEO_DEVICE_UNIT, 0x0000003, VideoSampleMode)
MKTAG (VDV_VIDEOFORMAT,				VIDEO_DEVICE_UNIT, 0x0000004, VideoFormat)
MKTAG (VDV_HORIZONTAL_REFERENCE,	VIDEO_DEVICE_UNIT, 0x0000005, VideoHorizontalReference)
MKTAG (VDV_VERTICAL_REFERENCE,	VIDEO_DEVICE_UNIT, 0x0000006, VideoVerticalReference)
MKTAG (VDV_SYNC_MASTER,				VIDEO_DEVICE_UNIT, 0x0000007, BOOL)
MKTAG (VDV_FIELD_INDICATION,		VIDEO_DEVICE_UNIT, 0x0000008, VideoFieldIndication)
MKTAG (VDV_PIXELCLOCK_EDGE,		VIDEO_DEVICE_UNIT, 0x0000009, BOOL)
MKTAG (VDV_VIDEOBUSFORMAT,			VIDEO_DEVICE_UNIT, 0x000000a, VideoBusFormat)
MKTAG (VDV_MODE_OVERRIDE,			VIDEO_DEVICE_UNIT, 0x000000b, BOOL)


	//
	// Offset of the actual video frame relative to an ideal
	// video frame.  This includes black borders around the
	// actual video image.  This is in units of single pixels.
	//
MKTAG (VDV_HOFFSET,					VIDEO_DEVICE_UNIT, 0x0000010, int)
MKTAG (VDV_VOFFSET,					VIDEO_DEVICE_UNIT, 0x0000011, int)

	//
	// In 4 times pixel clk units.
	//
MKTAG (VDV_HTRIGGER,					VIDEO_DEVICE_UNIT, 0x0000020, int)

	//
	// HIGH	: rising edge
	// LOW	: falling edge
	//
MKTAG (VDV_HSYNC_POL,				VIDEO_DEVICE_UNIT, 0x0000021, BIT)
MKTAG (VDV_VSYNC_POL,				VIDEO_DEVICE_UNIT, 0x0000022, BIT)

	//
	// Active display area (esp. not blank) inside the acutal video
	// rectangle.
	//
MKTAG (VDV_ACTIVE_LEFT,				VIDEO_DEVICE_UNIT, 0x0000030, WORD)
MKTAG (VDV_ACTIVE_TOP,				VIDEO_DEVICE_UNIT, 0x0000031, WORD)
MKTAG (VDV_ACTIVE_WIDTH,			VIDEO_DEVICE_UNIT, 0x0000032, WORD)
MKTAG (VDV_ACTIVE_HEIGHT,			VIDEO_DEVICE_UNIT, 0x0000033, WORD)

	//
	// Video out options.
	//
MKTAG (VDV_VOUT_NTSC_SETUP,		VIDEO_DEVICE_UNIT, 0x0000040, BOOL)   // NTSC 7.5 IRE setup
MKTAG (VDV_VOUT_IDLE_VSTANDARD,	VIDEO_DEVICE_UNIT, 0x0000041, VideoStandard)   // idle video standard

	//
	// Information on video content
	//
MKTAG (VDV_STILL_SEQUENCE,			VIDEO_DEVICE_UNIT, 0x0000050, BOOL)

// More than one flag may be set at one time
MKTAG (VDV_CONTENT_TYPE,			VIDEO_DEVICE_UNIT, 0x0000051, DWORD)


#define VDVC_VIDEOSTANDARD		MKFLAG(0)
#define VDVC_SAMPLEMODE			MKFLAG(1)
#define VDVC_VIDEOFORMAT		MKFLAG(2)
#define VDVC_SYNCREF				MKFLAG(3)
#define VDVC_SYNC_MASTER		MKFLAG(4)
#define VDVC_OFFSET				MKFLAG(5)
#define VDVC_ACTIVE_RECT		MKFLAG(6)
#define VDVC_FIELD_INDICATION MKFLAG(7)

class VideoMux : public PhysicalUnit
	{
	protected:
		virtual Error SetVideoStandard(VideoStandard videoStandard) {GNRAISE_OK;}
		virtual Error SetSampleMode(VideoSampleMode videoSampleMode) {GNRAISE_OK;}
		virtual Error SetVideoFormat(VideoFormat videoFormat) {GNRAISE_OK;}
		virtual Error SetHorizontalReference(VideoHorizontalReference horizontalReference) {GNRAISE_OK;}
		virtual Error SetVerticalReference(VideoVerticalReference verticalReference) {GNRAISE_OK;}
		virtual Error SetSyncMaster(BOOL syncMaster) {GNRAISE_OK;}
		virtual Error SetFieldIndication(VideoFieldIndication fieldIndication) {GNRAISE_OK;}
		
		virtual Error SetHOffset(int hoffset) {GNRAISE_OK;}
		virtual Error SetVOffset(int voffset) {GNRAISE_OK;}
		virtual Error SetHTrigger(int htrigger) {GNRAISE_OK;}
		virtual Error SetHSyncPolarity(BIT hsyncPol) {GNRAISE_OK;}
		virtual Error SetVSyncPolarity(BIT vsyncPol) {GNRAISE_OK;}
				
		virtual Error SetActiveLeft(WORD activeLeft) {GNRAISE_OK;}
		virtual Error SetActiveTop(WORD activeTop) {GNRAISE_OK;}
		virtual Error SetActiveWidth(WORD activeWidth) {GNRAISE_OK;}
		virtual Error SetActiveHeight(WORD activeHeight) {GNRAISE_OK;}
	public:
		virtual Error Update(void) {GNRAISE_OK;}
	};
	
class VirtualVideoMux : public VirtualUnit
	{
	private:
		VideoMux	*	mux;
	protected:
		struct {
			VideoStandard					videoStandard;
			VideoSampleMode				videoSampleMode;
			VideoFormat						videoFormat;
			VideoHorizontalReference   horizontalReference;
			VideoVerticalReference		verticalReference;
			BOOL								syncMaster;
			VideoFieldIndication			fieldIndication;
			int								hoffset, voffset;
			int								htrigger;
			BIT								hsyncPol;
			BIT								vsyncPol;
			WORD								activeLeft;
			WORD								activeTop;
			WORD								activeWidth;
			WORD								activeHeight;
			} actual, updated;
		
		DWORD								changed;

		virtual Error UpdateParameters(void);
	public:
		VirtualVideoMux(VideoMux * mux);
		
		Error Configure(TAG __far * tags);
		Error Preempt(VirtualUnit * previous);		
	};

#endif // external visible

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\video\specific\dac624.h ===
// FILE:      library\hardware\video\specific\dac624.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1998 Viona Development.  All Rights Reserved.
// CREATED:   22.03.98
//
// PURPOSE: The class for the IBM RGB624 RAM DAC used as a video encoder.
//
// HISTORY:

#ifndef DAC624_H
#define DAC624_H

#include "library\hardware\video\generic\videnc.h"
#include "library\lowlevel\hardwrio.h"



class VirtualRGB624;



class RGB624 : public VideoEncoder 
	{
	friend class VirtualRGB624;

	protected:
		ByteIndexedInOutPort	*	port;		// communication port

		VideoStandard		standard;		// current video standard
		VideoMode			mode;				// current video mode
		BOOL					extSync;			// current state of extSync

		BOOL					ntscSetup;		// NTSC 7.5 IRE setup

		DWORD					changed;			// state changed ?

		BYTE					ctrlState;

		// Change parameters of physical unit.
		virtual Error SetVideoStandard (VideoStandard std);
		virtual Error SetMode (VideoMode mode);
		virtual Error SetExtSync (BOOL extsync) {GNRAISE_OK;}
		virtual Error SetSampleMode (VideoSampleMode mode) {GNRAISE_OK;}
		virtual Error SetHOffset (int offset) {GNRAISE_OK;}
		virtual Error SetVOffset (int offset) {GNRAISE_OK;}
		virtual Error SetIdleScreen (int idleScreen);

		Error ProcessChanges (void);

		Error SetIdleScreen (void);

		// Program specific encoder mode.
		Error SetInit (void);
		Error SetPattern (void);
		Error SetPlayback (void);
		Error SetCapture (void);

		Error DisableEncoder (void);
		Error EnableEncoder (void);

		Error Configure (TAG __far *tags);

	public:
		RGB624 (ByteIndexedInOutPort *port, Profile *profile = NULL);

		VirtualUnit * CreateVirtual (void);
	};



class VirtualRGB624 : public VirtualVideoEncoder
	{
	friend class RGB624;

	private:
		RGB624	*	rgb624;

	public:
		VirtualRGB624 (RGB624 *physical) 
			: VirtualVideoEncoder (physical) {rgb624 = physical;}

		Error Configure (TAG __far *tags);

	protected:
		Error Preempt (VirtualUnit *previous);
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\video\specific\DEC7110.H ===
// FILE:      library\hardware\video\specific\dec7110.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   20.03.95
//
// PURPOSE: The class for the SAA 7110 video decoder.
//
// HISTORY:

#ifndef DEC7110_H
#define DEC7110_H

#include "library\common\gnerrors.h"
#include "library\hardware\video\generic\viddec.h"


#ifndef ONLY_EXTERNAL_VISIBLE

#include "library\lowlevel\hardwrio.h"

#define I2C_SAA7110  0x9c   // the 7110's I2C bus address



class VirtualSAA7110;   // forward declaration



// For mapping input lines to 7110 input chip modes.

#define SAA7110_MAX_INPUT_LINES  6

enum SAA7110_InputMode
	{
	SAA7110_INPUTMODE_CVBS1, SAA7110_INPUTMODE_CVBS2, SAA7110_INPUTMODE_CVBS3,
	SAA7110_INPUTMODE_CVBS4, SAA7110_INPUTMODE_NONE,  SAA7110_INPUTMODE_CVBS6,
	SAA7110_INPUTMODE_YC1, SAA7110_INPUTMODE_YC2, SAA7110_INPUTMODE_YC3,
	SAA7110_INPUTMODE_YC4,   // for H22
	SAA7110_INPUTMODE_YC5
	};



class SAA7110 : public VideoDecoder
	{
	friend class VirtualSAA7110;
	friend class SAA7110GPSWPort;

	protected:
		Error OutGPSWBit (BIT data);

		ByteIndexedInOutPort *port;
		SAA7110_InputMode lines[SAA7110_MAX_INPUT_LINES];
		BYTE gpsw;

		BYTE brightness;
		BYTE contrast;
		BYTE saturation;
		BYTE hue;

		WORD input;
		VideoStandard standard;
		VideoMode mode;
		BOOL extSync;

		DWORD changed;

		Error SetVideoStandard (VideoStandard std);
		Error SetMode (VideoMode mode);
		Error SetExtSync (BOOL extsync);
		Error SetInput (WORD input);
		Error SetBrightness (WORD brightness);
		Error SetContrast (WORD contrast);
		Error SetSaturation (WORD saturation);
		Error SetHue (WORD hue);
		Error SetSampleMode (VideoSampleMode mode);

		BOOL VideoStandardWasChanged (void);

		virtual Error ProcessChanges (void);

		Error ProgramAll (void);
		Error ProgramInput (void);
		Error ProgramBrightness (void);
		Error ProgramContrast (void);
		Error ProgramSaturation (void);
		Error ProgramHue (void);

		Error ProgramInputNone (void);

		Error Set_RESET (void);

		Error Set_NTSC_TestPattern (void);
		Error Set_PAL_TestPattern (void);
		Error Set_NTSC_Capture (void);
		Error Set_PAL_Capture (void);
		Error Set_SECAM_Capture (void);
		Error Set_NTSC_Playback (void);
		Error Set_PAL_Playback (void);
		Error Set_NTSC_Playback_Ext (void);
		Error Set_PAL_Playback_Ext (void);

		virtual Error DetectVideoStandard (VideoStandard __far &std);

	public:
		// Select the input mode for the six input lines.
		SAA7110 (ByteIndexedInOutPort *port, VirtualUnit *videoBus,
		         WORD numInputs, VideoDecoderInputEntry __far *inputNames,
		         SAA7110_InputMode lines[SAA7110_MAX_INPUT_LINES]);
		~SAA7110 (void);

		VirtualUnit *CreateVirtual (void);

		BitOutputPort *outPort;
	};



class VirtualSAA7110 : public VirtualVideoDecoder
	{
	private:
		SAA7110 *saa7110;

	public:
		VirtualSAA7110 (SAA7110 *physical) : VirtualVideoDecoder (physical)
			{ saa7110 = physical; sampleMode = VSAMOD_SQP;}

		Error Configure (TAG __far *tags);

	protected:
		Error Preempt (VirtualUnit *previous);
	};



#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\video\specific\Enc7120.h ===
// FILE:      library\hardware\video\specific\enc7120.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1997 Viona Development.  All Rights Reserved.
// CREATED:   03.11.97
//
// PURPOSE: The class for the SAA 7120 video encoder.
//
// HISTORY:

#ifndef ENC7120_H
#define ENC7120_H

#include "..\generic\videnc.h"
#include "library\lowlevel\hardwrio.h"



#define I2C_SAA7120   0x88  // the 7120's I2C bus address


class VirtualSAA7120;


class SAA7120 : public VideoEncoder 
	{
	friend class VirtualSAA7120;
	protected:
		ByteIndexedInOutPort	*	port;		// Comunication port

		VideoStandard		standard;		// current video standard
		VideoMode			mode;				// current video mode
		BOOL					extSync;			// current state of extSync

		BOOL					ntscSetup;		// NTSC 7.5 IRE setup

		DWORD					changed;			// state changed ??

		BYTE					ctrlState;
		//
		// Change parameters of physical unit
		//		
		virtual Error SetVideoStandard(VideoStandard std);
		virtual Error SetMode(VideoMode mode);
		virtual Error SetExtSync(BOOL extsync);
		virtual Error SetSampleMode(VideoSampleMode mode);
		virtual Error SetHOffset (int offset) {GNRAISE_OK;}
		virtual Error SetVOffset (int offset) {GNRAISE_OK;}
		virtual Error SetIdleScreen (int idleScreen);

      //
      // Perform the changes
      //
		Error ProcessChanges(void);

		Error SetIdleScreen (void);

		//
		// Program specific encoder mode
		//
		Error SetInit(void);
		Error SetNTSC(void);
		Error SetPAL(void);
		Error SetNTSCPattern(void);
		Error SetPALPattern(void);
		Error SetNTSCPlayback(void);
		Error SetPALPlayback(void);
		Error SetNTSCCapture(void);
		Error SetPALCapture(void);

		Error DisableEncoder(void);
		Error EnableEncoder(void);

		Error Configure(TAG __far * tags);

	public:
		SAA7120 (ByteIndexedInOutPort *port, Profile *profile = NULL);

		VirtualUnit * CreateVirtual(void);
	};


class VirtualSAA7120 : public VirtualVideoEncoder
	{
	friend class SAA7120;
	private:
		SAA7120	*	saa7120;
	public:
		VirtualSAA7120(SAA7120 * physical) 
			: VirtualVideoEncoder(physical) {saa7120 = physical;}

		Error Configure (TAG __far * tags);
	protected:
		Error Preempt (VirtualUnit * previous);
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\video\specific\ENC207.H ===
// FILE:      library\hardware\video\specific\enc207.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   03.04.95
//
// PURPOSE: The class for the MD 0207 video encoder.
//
// HISTORY:

#ifndef ENC207_H
#define ENC207_H

#include "..\generic\videnc.h"
#include "..\..\..\lowlevel\hardwrio.h"



class VirtualMD207;   // forward declaration



class MD207 : public VideoEncoder
	{
	friend class VirtualMD207;

	protected:
		ByteIndexedInOutPort *port;
		
		VideoStandard	standard;
		VideoMode		mode;
		
		BOOL				changed;
		
		Error SetVideoStandard(VideoStandard std);
		Error SetMode(VideoMode mode);
		Error SetExtSync(BOOL extsync);

		Error ProcessChanges(void);

	public:
		MD207 (ByteIndexedInOutPort *port)
			: VideoEncoder() {this->port=port;}
	};



class VirtualMD207 : public VirtualVideoEncoder
	{
	friend class MD207;
   private:
   	MD207		*	md207;
	public:
		VirtualMD207 (MD207 *physical) : VirtualVideoEncoder(physical) {md207 = physical;}

		Error Configure (TAG *tags);

	protected:
		Error Preempt (VirtualUnit *previous);
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\video\generic\VIDTYPES.H ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


// FILE:      library\hardware\video\generic\vidtypes.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   04.04.95
//
// PURPOSE: Video related types.
//
// HISTORY:

#ifndef VIDEOTYPES_H
#define VIDEOTYPES_H

enum VideoStandard
	{
	VSTD_NTSC	 = 0,
	VSTD_PAL		 = 1,
	VSTD_SECAM	 = 2,
	VSTD_HDTV	 = 3,
	VSTD_UNKNOWN = 4,
	VIDEOSTANDARD_MIN = VSTD_NTSC,
	VIDEOSTANDARD_MAX = VSTD_UNKNOWN
	};


enum MovingImageStandard
	{
	MIS_576_25		= 0,
	MIS_480_29_97	= 1
	};

enum PALVideoSubStandard
	{
	PALVIDEOSUBSTANDARD_MIN	= 0,
		PALVSSTD_DEFAULT		= 0,
		PALVSSTD_BDGHI			= 1,
		PALVSSTD_N				= 2,
		PALVSSTD_NC				= 3,
		PALVSSTD_INVALID		= 4,
	PALVIDEOSUBSTANDARD_MAX	= PALVSSTD_NC
	};

enum NTSCVideoSubStandard
	{
	NTSCVIDEOSUBSTANDARD_MIN	= 0,
		NTSCVSSTD_DEFAULT			= 0,
		NTSCVSSTD_NORMAL			= 1,
		NTSCVSSTD_PALM				= 2,
		NTSCVSSTD_443				= 3,
		NTSCVSSTD_JAPAN			= 4,
		NTSCVSSTD_PAL60			= 5,
		NTSCVSSTD_INVALID			= 6,
	NTSCVIDEOSUBSTANDARD_MAX	= NTSCVSSTD_PAL60
	};

enum VideoSource
	{
	VIDEOSOURCE_MIN			= 0,
		VSRC_COMPOSITE			= 0,
		VSRC_SVIDEO				= 1,
		VSRC_SERIAL_DIGITAL	= 2,
		VSRC_RGB					= 3,
	VIDEOSOURCE_MAX	= VSRC_RGB
	};

enum VideoPresentationMode
	{
	VPRM_4_BY_3_NORMAL,
	VPRM_4_BY_3_LETTERBOXED,
	VPRM_16_BY_9_ANAMORPHIC,
	VPRM_RESERVED
	};

enum VideoFormat
	{
	VIDEOFORMAT_MIN = 0,
		VFMT_YUV_422 = 0,
		VFMT_YUV_411 = 1,
		VFMT_YUV_420 = 2,
		VFMT_YUV_444 = 3,
		VFMT_RGB_444 = 4,
	VIDEOFORMAT_MAX = VFMT_RGB_444
	};

enum VideoBusFormat
	{
	VIDEOBUSFORMAT_MIN = 0,
		FBFM_YC16 = 0,
		FBFM_YC8  = 1,
	VIDEOBUSFORMAT_MAX = FBFM_YC8
	};

enum VideoLineMode
	{
	VIDEOLINEMODE_MIN		= 0,
		VLM_PROGRESSIVE	= 0,
		VLM_INTERLACED		= 1,
	VIDEOLINEMODE_MAX		= VLM_INTERLACED
	};

enum VideoMode
	{
	VIDEOMODE_MIN = 0,
		VMOD_RESET    = 0,
		VMOD_PATTERN  = 1,
		VMOD_CAPTURE  = 2,
		VMOD_PLAYBACK = 3,
		VMOD_PATTERNSYNC = 4,
	VIDEOMODE_MAX = VMOD_PATTERNSYNC
//	ModeForceReprogramming   // this one internal use only
	};

enum VideoSampleMode
	{
	VIDEOSAMPLEMODE_MIN = 0,
		VSAMOD_CCIR	= 0,
		VSAMOD_SQP	= 1,
	VIDEOSAMPLEMODE_MAX = VSAMOD_SQP
	};

enum VideoField
	{
	VIDEOFIELD_MIN = 0,
		VFLD_SINGLE = 0,
		VFLD_ODD    = 1,
		VFLD_EVEN   = 2,
	VIDEOFIELD_MAX = VFLD_EVEN
	};

enum VideoMuxSource
	{
	VIDEOMUXSRC_MIN = 0,
		VIDEOMUXSRC_INTERNAL = 0,
		VIDEOMUXSRC_NONE = 1,
		VIDEOMUXSRC_EXTERNAL = 2,
	VIDEOMUXSRC_MAX = VIDEOMUXSRC_EXTERNAL
	};

enum VideoPixClockMode
	{
	VIDEOPIXCLK_MIN = 0,
		VIDEOPIXCLK_INTERNAL = 0,
		VIDEOPIXCLK_EXTERNAL = 1,
	VIDEOPIXCLK_MAX = VIDEOPIXCLK_EXTERNAL
	};

enum VideoCopyMode
	{
	VCPMD_DEFAULT,	// depends on implementation (e.g. "do not indicate on video output"). Use for
						// content that does not contain copyright protection information.

	// Use the following three when the content contains copyright protection information
	VCPMD_COPYING_PERMITTED,		// indicate that copying is always allowed
	VCPMD_ONE_COPY_PERMITTED,		// one copy allowed
	VCPMD_NO_COPYING_PERMITTED		// no copy allowed
	};


// The values of the following two enums are hardware-independent.

enum GrabFormat
	{
	GRABFORMAT_MIN = 0,
		VGRB_MJPEG    = 0,
		VGRB_RGB_888x = 1,
		VGRB_RGB_888  = 2,
		VGRB_RGB_565  = 3,
		VGRB_RGB_555  = 4,
		VGRB_YUV_422  = 5,
	GRABFORMAT_MAX = VGRB_YUV_422
	};

enum PIPFormat
	{
	PIPFORMAT_MIN = 0,
		PFMT_RGB_888x	= 0,
		PFMT_RGB_888	= 1,
		PFMT_RGB_565	= 2,
		PFMT_RGB_555	= 3,
		PFMT_YUV_422	= 4,
		PFMT_UVY_422	= 5,
		PFMT_PALETTE_8	= 6,
		PFMT_OTHER		= 7,
	PIPFORMAT_MAX = PFMT_OTHER
	};


struct HardVideoParams
	{
	int totalWidth,
	    totalHeight,
	    activeWidth,
	    activeHeight;   // activeHeight must be even (interlace)
	BIT hsPol,          // can be 0 or 1
	    vsPol;          // can be 0 or 1
	int hStart,
	    hEnd,           // hEnd = hStart + activeWidth - 1
	    vStart,
	    vEnd;           // vEnd = vStart + activeHeight/2 - 1
	BIT oddFirst;
	};


// These are defines for TV standard (CCIR) dependent sizes.

const HardVideoParams NTSCParams =
	{
	858, 525,
	720, 480,
	0,   0,
	123, 123+720-1,
	20,  20+480-1,
	TRUE
	};

const HardVideoParams PALParams =
	{
	864, 625,
	720, 576,
	0,   0,
	133, 133+720-1,
	46,  46+576-1,
	FALSE
	};


// These are defines for TV standard (square pixel) dependent sizes.

const HardVideoParams NTSCSquareParams =
	{
	780, 525,
	640, 480,
	1,   1,
	75,  75+640-1,
	20,  20+480-1,
	TRUE
	};

const HardVideoParams PALSquareParams =
	{
	944, 625,
	768, 576,
	1,   1,
	83,  83+768-1,
	34,  34+576-1,
	FALSE
	};


// Video Port specific definitions

// Possible video formats on video port (format field in VideoPortCaps struct)
#define VP_FMT_RGB_555		MKFLAG(0)
#define VP_FMT_RGB_565		MKFLAG(1)
#define VP_FMT_CCIR_422		MKFLAG(2)
#define VP_FMT_YUV_411		MKFLAG(3)
#define VP_FMT_YUV_420		MKFLAG(4)
#define VP_FMT_YONLY_400	MKFLAG(5)
#define VP_FMT_RGB_888_24	MKFLAG(6)
#define VP_FMT_RGB_888_32	MKFLAG(7)
#define VP_FMT_RGB_332		MKFLAG(8)
#define VP_FMT_ACCUPAK		MKFLAG(9)
#define VP_FMT_DYUV			MKFLAG(10)

// Protocols
#define VP_PORT_DI_8A		MKFLAG(0)
#define VP_PORT_DIV_8A		MKFLAG(1)
#define VP_PORT_DE_8A		MKFLAG(2)
#define VP_PORT_SI_8A		MKFLAG(3)
#define VP_PORT_SIV_8A		MKFLAG(4)
#define VP_PORT_SE_8A		MKFLAG(5)
#define VP_PORT_16A			MKFLAG(6)
#define VP_PORT_V_16A		MKFLAG(7)
#define VP_PORT_FIREWIRE	MKFLAG(8)
// Use this when creating a dummy Kernel Video Port PIP:
#define VP_PORT_DUMMY		MKFLAG(9)

// generate from the ones above!
//#define VP_PROT_BROOKTREE
//#define VP_PROT_PHILIPS

// Special connection features
#define VP_FEAT_INVERTPOLARITY	MKFLAG(0)
#define VP_FEAT_INTERLACED			MKFLAG(1)
#define VP_FEAT_TELETEXT			MKFLAG(2)
#define VP_FEAT_CLOSEDCAPTION		MKFLAG(3)
#define VP_FEAT_E_HREFH_VREFH		MKFLAG(4)
#define VP_FEAT_E_HREFH_VREFL		MKFLAG(5)
#define VP_FEAT_E_HREFL_VREFH		MKFLAG(6)
#define VP_FEAT_E_HREFL_VREFL		MKFLAG(7)
#define VP_FEAT_COLORCONTROL		MKFLAG(8)
#define VP_FEAT_BOB					MKFLAG(9)
#define VP_FEAT_WEAVE				MKFLAG(10)
// Use this when creating a dummy Kernel Video Port PIP:
#define VP_FEAT_DUMMY					MKFLAG(11)

struct VideoPortCaps
	{
	DWORD	videoFormat;		// Video format on port connection

	DWORD	protocol;			// Communication protocol(s)
	DWORD	connFeatures;		// Special features for the connection

	DWORD	fieldWidth;			// Maximum total transfer width of one field
	DWORD	vbiWidth;			// Maximum transfer width for VBI information
	DWORD	fieldHeight;		// Maximum total transfer height of one field

	DWORD	usPerField;			// Shortest possible time between two VREFs in microseconds
	DWORD	pixelsPerSecond;	// Number of pixels per second

	DWORD	displayOnly;		// The VGA can only display, but not capture.

	DWORD	clrControls;		// Will contain possible color controls
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\video\specific\ENC7185.H ===
// FILE:      library\hardware\video\specific\enc7185.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   27.03.95
//
// PURPOSE: The class for the SAA 7185 video encoder.
//
// HISTORY:

#ifndef ENC7185_H
#define ENC7185_H

#include "..\generic\videnc.h"
#include "library\lowlevel\hardwrio.h"



#define I2C_SAA7185   0x88  // the 7185's I2C bus address


class VirtualSAA7185;


class SAA7185 : public VideoEncoder 
	{
	friend class VirtualSAA7185;
	protected:
		ByteIndexedInOutPort	*	port;		// Comunication port

		VideoStandard		standard;		// current video standard
		VideoMode			mode;				// current video mode
		BOOL					extSync;			// current state of extSync

		BOOL					ntscSetup;		// NTSC 7.5 IRE setup

		DWORD					changed;			// state changed ??

		BYTE					ctrlState;
		//
		// Change parameters of physical unit
		//		
		virtual Error SetVideoStandard(VideoStandard std);
		virtual Error SetMode(VideoMode mode);
		virtual Error SetExtSync(BOOL extsync);
		virtual Error SetSampleMode(VideoSampleMode mode);
		virtual Error SetHOffset (int offset) {GNRAISE_OK;}
		virtual Error SetVOffset (int offset) {GNRAISE_OK;}
		virtual Error SetIdleScreen (int idleScreen);

      //
      // Perform the changes
      //
		Error ProcessChanges(void);

		Error SetIdleScreen (void);

		//
		// Program specific encoder mode
		//
		Error SetInit(void);
		Error SetNTSC(void);
		Error SetPAL(void);
		Error SetNTSCPattern(void);
		Error SetPALPattern(void);
		Error SetNTSCPlayback(void);
		Error SetPALPlayback(void);
		Error SetNTSCCapture(void);
		Error SetPALCapture(void);

		Error DisableEncoder(void);
		Error EnableEncoder(void);

		Error Configure(TAG __far * tags);

	public:
		SAA7185 (ByteIndexedInOutPort *port, Profile *profile = NULL);

		VirtualUnit * CreateVirtual(void);
	};


class VirtualSAA7185 : public VirtualVideoEncoder
	{
	friend class SAA7185;
	private:
		SAA7185	*	saa7185;
	public:
		VirtualSAA7185(SAA7185 * physical) 
			: VirtualVideoEncoder(physical) {saa7185 = physical;}

		Error Configure (TAG __far * tags);
	protected:
		Error Preempt (VirtualUnit * previous);
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\video\specific\enc5505.h ===
// FILE:      library\hardware\video\specific\enc5505.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1998 Viona Development.  All Rights Reserved.
// CREATED:   02.06.98
//
// PURPOSE: The class for the video encoder part in the STi5505.
//
// HISTORY:

#ifndef ENC5505_H
#define ENC5505_H

#include "library\common\virtunit.h"
#include "library\hardware\video\generic\ccapvenc.h"
#include "library\lowlevel\memmpdio.h"

#ifdef WEBDVD
class EncCH7004;
#endif

class VirtualEnc5505;


class Enc5505 : public CloseCaptionVideoEncoder
	{
	friend class VirtualEnc5505;
#ifdef WEBDVD
	friend class EncCH7004;
#endif

	protected:
		MemoryMappedIO	*	mem;
		BitOutputPort	*	videoActivePort;
		BitOutputPort	*	svideoActivePort;

		VideoStandard		standard;		// current video standard
		PALVideoSubStandard	palSubStandard;
		NTSCVideoSubStandard	ntscSubStandard;
		int					idleDisplay;
		VideoMode			mode;				// current video mode
		BOOL					extSync;			// current state of extSync
		int					copyProtection;
		DWORD					chromaFilterFrequency;

		int					vsyncCopyProtection;

		BOOL					ntscSetup;		// NTSC 7.5 IRE setup
		BOOL					videoInverted;
		BOOL					hSyncPol;
		BOOL					vSyncPol;
		int					syncMode;
		BOOL					fixedExtSync;
		int					component;
		BOOL					enableMacrovision;

		BYTE					chipSyncMode;

		DWORD					changed;			// state changed ??

		BYTE					ctrlState;

		// Change parameters of physical unit.
		virtual Error SetVideoStandard (VideoStandard std);
		virtual Error SetMode (VideoMode mode);
		virtual Error SetExtSync (BOOL extsync);
		virtual Error SetPALVideoSubStandard (PALVideoSubStandard palSubStandard);
		virtual Error SetNTSCVideoSubStandard (NTSCVideoSubStandard ntscSubStandard);
		virtual Error SetSampleMode (VideoSampleMode mode);
		virtual Error SetHOffset (int offset) {GNRAISE_OK;}
		virtual Error SetVOffset (int offset) {GNRAISE_OK;}
		virtual Error SetIdleScreen (int idleScreen);

      // Perform the changes
		Error ProcessChanges (void);

		virtual Error SetIdleScreen (void);
		virtual Error SetCopyProtection (int protection);
		virtual Error SetChromaFilter (DWORD frequency);
		virtual Error SetSVideoActive (BOOL active);

		//
		// Program specific encoder mode
		//
		Error ProgramCopyProtection (int protection);

		Error SetInit (void);
		Error SetNTSC (void);
		Error SetPAL (void);
		Error SetNTSCPattern (void);
		Error SetPALPattern (void);
		Error SetNTSCPlayback (void);
		Error SetPALPlayback (void);

		Error DisableEncoder (void);
		Error EnableEncoder (void);

		Error Configure (TAG __far *tags);

		virtual void Interrupt (void);

		Error GetCCStatus(BOOL __far & first, BOOL __far & second);
		Error PutCCData(BOOL field, BYTE d1, BYTE d2);
		Error EnableCCTransfer(void);
		Error DisableCCTransfer(void);		
	public:
		Enc5505 (MemoryMappedIO *mem, GenericProfile *profile = NULL,
		         BitOutputPort *videoActivePort = NULL, BitOutputPort *svideoActivePort = NULL);
		~Enc5505 (void);

		VirtualUnit * CreateVirtual (void);

		void DeactivateOutputs (void);
		void ReactivateOutputs (void);
	};



class VirtualEnc5505 : public VirtualCloseCaptionVideoEncoder
	{
	friend class Enc5505;

	private:
		Enc5505	*enc5505;

	public:
		VirtualEnc5505 (Enc5505 *physical)
			: VirtualCloseCaptionVideoEncoder (physical)
			{enc5505 = physical;}

		Error Configure (TAG __far *tags);

	protected:
		Error Preempt (VirtualUnit *previous);
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\video\specific\dec7111.h ===
// FILE:			library\hardware\video\specific\dec7111.h
// AUTHOR:		S. Herr
// COPYRIGHT:	(c) 1995 Viona Development.  All Rights Reserved.
// CREATED:		23.08.95
//
// PURPOSE: 	Class for SAA 7111 video decoder.
//
// HISTORY:

#ifndef DEC7111_H
#define DEC7111_H

#include "library\common\gnerrors.h"         
#include "..\generic\viddec.h"

#include "library\common\hooks.h"
MKHOOK (DecVBlank, WORD)
MKTAG (DEC_CLOSEDCAPTION, VIDEO_DECODER_UNIT, 0x3000, DecVBlankHook*)

#ifndef ONLY_EXTERNAL_VISIBLE

#include "library\lowlevel\intrctrl.h"
#include "library\lowlevel\hardwrio.h"

#define I2C_SAA7111  0x48   // the 7111's I2C bus address when IICSA pin = LOW
									 // If HIGH, use value 0x4a
                                                         

class VirtualSAA7111;   // forward declaration



// For mapping input lines to 7111 input chip modes.

#define SAA7111_MAX_INPUT_LINES  8

enum SAA7111_InputMode
	{
	SAA7111_INPUTMODE_CVBS0, SAA7111_INPUTMODE_CVBS1, SAA7111_INPUTMODE_CVBS2, SAA7111_INPUTMODE_CVBS3,
	SAA7111_INPUTMODE_YC0, SAA7111_INPUTMODE_YC1, SAA7111_INPUTMODE_YC2, SAA7111_INPUTMODE_YC3,
	SAA7111_INPUTMODE_NONE
	};



enum SAA7111_OutputMode   // don't change: chip specific !
	{
	SAA7111_OUTPUTMODE_RGB565    = 0,
	SAA7111_OUTPUTMODE_YUV_16bit = 1,
	SAA7111_OUTPUTMODE_YUV_12bit = 2,
	SAA7111_OUTPUTMODE_YUV_8bit  = 3
	};



class SAA7111 : public VideoDecoder
	{
	friend class VirtualSAA7111;
	friend class SAA7111GPSWPort;
	friend class SAA7111SignalPort;
	friend class SAA7111VBlankIntHandler;
	
	private:
		//
		// Communication port (typically I2C)
		//		
		ByteIndexedInOutPort *port;
      
		SAA7111_InputMode lines[SAA7111_MAX_INPUT_LINES];

		//
		// State of the "gpsw" bit
		//
		BYTE				gpsw;
		
		//
		// Current image settings in internal format
		//
		WORD				brightness;
		WORD				contrast;
		WORD				saturation;
		BYTE				hue;
      
		BOOL				teletext;
      
		DecVBlankHookHandle		closedHookHandle;
		InterruptServer*	vBlankIntServer;
		SAA7111VBlankIntHandler*	vBlankIntHandler;
		BOOL				closedCaptionRunning;
      //
		// Current input, standard, mode etc.
		//
		WORD				input;
		VideoStandard	standard;
		VideoMode		mode;
		BOOL				extSync;

		SAA7111_OutputMode outputMode;

		void VBlankInterrupt(void);
		//
		// Parameter setting functions		
		//
		Error SetVideoStandard(VideoStandard std);
		Error SetMode(VideoMode mode);
		Error SetExtSync(BOOL extsync);
		Error SetInput(WORD input);
		Error SetBrightness(WORD brightness);
		Error SetContrast(WORD contrast);
		Error SetSaturation(WORD saturation);
		Error SetHue(WORD hue);         
		Error SetSampleMode(VideoSampleMode mode);
		Error SetTeletextMode(BOOL mode);
		Error SetClosedCaptionHook(DecVBlankHook* closedHook);

		//
		// Reprogram chip values
		//		
#if 0
		Error ProgramAll(void);		
#endif		
		Error ProgramInput(void);
		Error ProgramBrightness(void);
		Error ProgramContrast(void);
		Error ProgramSaturation(void);
		Error ProgramHue(void);
		Error ProgramClosedCaption(void);
      
		//
		// Program specific encoder mode
		//
		Error SetInit(void);
		Error SetNTSCPlayback(void);
		Error SetPALPlayback(void);
		Error SetNTSCCapture(void);
		Error SetPALCapture(void);
		Error SetReset(void);
		Error SetNTSCPatternSync (void);
		Error SetPALPatternSync (void);
		
#if 0
		//
		// Set mode and standard
		//
		Error Set_NTSC_TestPattern (void);
		Error Set_PAL_TestPattern (void);
		Error Set_NTSC_Capture (void);
		Error Set_PAL_Capture (void);
		Error Set_SECAM_Capture (void);
		Error Set_NTSC_Playback (void);
		Error Set_PAL_Playback (void);
		Error Set_NTSC_Playback_Ext (void);
		Error Set_PAL_Playback_Ext (void);
		Error	Set_RESET (void);
#endif

		Error StartClosedCaption();
		Error StopClosedCaption();

		BYTE CalcBrightness (void);
		BYTE CalcContrast (void);
		BYTE CalcSaturation (void);

		//
		// Fix the NTSC bug in 7111 first silicon
		//
		Error NTSCSwitchBugFix(void);

	protected:
		virtual Error SetNTSC(void);
		virtual Error SetPAL(void);

		//                         
		// Helper functions for the two included ports
		//
		Error OutGPSWBit(BIT data);
		Error CheckInputSignal(BOOL __far & signal);

		// Check the current video standard
		Error DetectVideoStandard(VideoStandard __far &std);

		// Checks changes in setting, and triggers changes in registers
		virtual Error ProcessChanges(void);

		// Flags, which part of the programming have been changed
		DWORD				changed;

		BOOL VideoStandardWasChanged (void);

		VideoStandard GetVideoStandard(void) {return standard;}

	public:
		SAA7111 (ByteIndexedInOutPort *port, VirtualUnit *videoBus, InterruptServer *vBlankIntServer = NULL,
		         WORD numInputs = 0, VideoDecoderInputEntry __far *inputNames = NULL,
		         SAA7111_InputMode lines[SAA7111_MAX_INPUT_LINES] = NULL);
		~SAA7111 (void);

		VirtualUnit * CreateVirtual(void);

		Error SetOutput (SAA7111_OutputMode output);   // (change to private scope later)

		BitOutputPort	*	outPort;
	};



class VirtualSAA7111 : public VirtualVideoDecoder
	{      
	protected:
		BOOL						teletext;
		DecVBlankHook* closedHookPtr;
	private:
		SAA7111		*	saa7111;
	public:
		VirtualSAA7111 (SAA7111 *physical);

		Error Configure (TAG __far *tags);

	protected:
		Error Preempt (VirtualUnit *previous);
	};


#endif	// of #define ONLY_EXTERNAL_VISIBLE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\video\specific\ENC7187.H ===
// FILE:      library\hardware\video\specific\enc7187.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   27.03.95
//
// PURPOSE: The class for the SAA 7187 video encoder.
//
// HISTORY:

#ifndef ENC7187_H
#define ENC7187_H

#include "library\hardware\video\generic\videnc.h"
#include "library\lowlevel\hardwrio.h"



#define I2C_SAA7187   0x88  // the 7187's I2C bus address



// Sync polarities for the operation modes. Don't alter; chip specific!

enum SAA7187_Sync
	{
	SAA7187_HS_VS_LOW_ACTIVE  = 0x09,
	SAA7187_HS_VS_HIGH_ACTIVE = 0x00,
	SAA7187_HS_LOW_VS_HIGH    = 0x01,
	SAA7187_HS_HIGH_VS_LOW    = 0x08
	};



class VirtualSAA7187;



class SAA7187 : public VideoEncoder 
	{
	friend class VirtualSAA7187;

	protected:
		ByteIndexedInOutPort *port;
		SAA7187_Sync patternSync, captureSync, playbackSync;

		VideoStandard standard;
		VideoMode mode;
		BOOL extSync;
		int hOffset, vOffset;

		BOOL changed;

		virtual Error SetVideoStandard (VideoStandard std);
		virtual Error SetMode (VideoMode mode);
		virtual Error SetExtSync (BOOL extsync);
		virtual Error SetSampleMode(VideoSampleMode mode);
		virtual Error SetHOffset (int offset);
		virtual Error SetVOffset (int offset);
		virtual Error SetIdleScreen (int idleScreen);

		Error ProcessChanges (void);

		Error ProgramAll (void);

		Error SetIdleScreen (void);

		Error Set_NTSC_TestPattern (void);
		Error Set_PAL_TestPattern (void);
		Error Set_NTSC_Capture (void);
		Error Set_PAL_Capture (void);
		Error Set_SECAM_Capture (void);
		Error Set_NTSC_Playback (void);
		Error Set_PAL_Playback (void);
		Error Set_NTSC_Playback_Ext (void);
		Error Set_PAL_Playback_Ext (void);

	public:
		SAA7187 (Profile *profile,
		         ByteIndexedInOutPort *port, SAA7187_Sync patternSync,
		         SAA7187_Sync captureSync, SAA7187_Sync playbackSync);

		VirtualUnit *CreateVirtual (void);
	};



class VirtualSAA7187 : public VirtualVideoEncoder
	{
	friend class SAA7187;

	private:
		SAA7187 *saa7187;

	public:
		VirtualSAA7187(SAA7187 *physical) : VirtualVideoEncoder (physical)
			{saa7187 = physical; sampleMode = VSAMOD_SQP;}

		Error Configure (TAG __far *tags);

	protected:
		Error Preempt (VirtualUnit *previous);
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\video\specific\ENC7199.H ===
// FILE:      library\hardware\video\specific\enc7199.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   27.03.95
//
// PURPOSE: The class for the SAA 7199b video encoder.
//
// HISTORY:

#ifndef ENC7199_H
#define ENC7199_H

#include "library\hardware\video\generic\videnc.h"
#include "library\lowlevel\hardwrio.h"



#define I2C_SAA7199   0xb0  // the 7199's I2C bus address



// Sync polarities for the operation modes. Don't alter; chip specific!

enum SAA7199_Sync
	{
	SAA7199_CSYN_LOW          = 0,
	SAA7199_HS_VS_LOW_ACTIVE  = 1,
	SAA7199_CSYN_HIGH         = 2,
	SAA7199_HS_VS_HIGH_ACTIVE = 3
	};



class VirtualSAA7199;



class SAA7199 : public VideoEncoder 
	{
	friend class VirtualSAA7199;

	protected:
		ByteIndexedInOutPort	*port;
		SAA7199_Sync patternSync, captureSync, playbackSync;

		VideoStandard standard;
		VideoMode mode;
		BOOL extSync;
		int hOffset, vOffset;

		BOOL changed;

		virtual Error SetVideoStandard (VideoStandard std);
		virtual Error SetMode (VideoMode mode);
		virtual Error SetExtSync (BOOL extsync);
		virtual Error SetSampleMode(VideoSampleMode mode);
		virtual Error SetHOffset (int offset);
		virtual Error SetVOffset (int offset);

		Error ProcessChanges (void);

		Error ProgramAll (void);

		Error Set_NTSC_TestPattern (void);
		Error Set_PAL_TestPattern (void);
		Error Set_NTSC_Capture (void);
		Error Set_PAL_Capture (void);
		Error Set_SECAM_Capture (void);
		Error Set_NTSC_Playback (void);
		Error Set_PAL_Playback (void);
		Error Set_NTSC_Playback_Ext (void);
		Error Set_PAL_Playback_Ext (void);

	public:
		SAA7199 (ByteIndexedInOutPort *port, SAA7199_Sync patternSync,
		         SAA7199_Sync captureSync, SAA7199_Sync playbackSync)
			: VideoEncoder ()
			{
			this->port = port;
			this->patternSync = patternSync;
			this->captureSync = captureSync;
			this->playbackSync = playbackSync;
			changed = TRUE;
			standard = VSTD_PAL;
			mode = VMOD_RESET;
			extSync = FALSE;
			}

		VirtualUnit *CreateVirtual (void);
	};



class VirtualSAA7199 : public VirtualVideoEncoder
	{
	friend class SAA7199;

	private:
		SAA7199 *saa7199;

	public:
		VirtualSAA7199 (SAA7199 *physical) : VirtualVideoEncoder (physical)
			{saa7199 = physical; sampleMode = VSAMOD_SQP;}

		Error Configure (TAG __far * tags);

	protected:
		Error Preempt (VirtualUnit * previous);
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\video\specific\ENCBT856.H ===
// FILE:      library\hardware\video\specific\encBT856.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   27.03.95
//
// PURPOSE: The class for the  BT856b video encoder.
//
// HISTORY:

#ifndef ENCBT856_H
#define ENCBT856_H

#include "..\generic\videnc.h"
#include "..\..\..\lowlevel\hardwrio.h"



#define I2C_BT856   0x88  // the BT856's I2C bus address



// Sync polarities for the operation modes. Don't alter; chip specific!


class VirtualBT856;

class BT856 : public VideoEncoder 
	{
	friend class VirtualBT856;

	protected:
		ByteIndexedInOutPort	*port;

		VideoStandard		standard;
		VideoMode 			mode;
		BOOL 					extSync;
		int 					hOffset, vOffset;
		VideoSampleMode   sampleMode;

		BOOL changed;

		virtual Error SetVideoStandard (VideoStandard std);
		virtual Error SetMode (VideoMode mode);
		virtual Error SetExtSync (BOOL extsync);
		virtual Error SetSampleMode(VideoSampleMode mode);
		virtual Error SetHOffset (int offset);
		virtual Error SetVOffset (int offset);

		Error ProcessChanges (void);

		Error ProgramAll (void);

		Error Set_NTSC_TestPattern (void);
		Error Set_PAL_TestPattern (void);
		Error Set_NTSC_Capture (void);
		Error Set_PAL_Capture (void);
		Error Set_NTSC_Playback (void);
		Error Set_PAL_Playback (void);
		Error Set_NTSC_Playback_Ext (void);
		Error Set_PAL_Playback_Ext (void);

	public:
		BT856 (ByteIndexedInOutPort *port) : VideoEncoder ()
			{
			this->port = port;
			changed = TRUE;
			standard = VSTD_PAL;
			mode = VMOD_RESET;
			extSync = FALSE;
			hOffset = 0; vOffset = 0; 
			sampleMode = VSAMOD_CCIR;
			}

		VirtualUnit *CreateVirtual (void);
	};



class VirtualBT856 : public VirtualVideoEncoder
	{
	friend class BT856;

	private:
		BT856 *	bt856;

	public:
		VirtualBT856 (BT856 *physical) : VirtualVideoEncoder (physical) {bt856 = physical; }

		Error Configure (TAG __far * tags);

	protected:
		Error Preempt (VirtualUnit * previous);
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\video\specific\enc8172.h ===
// FILE:      library\hardware\video\specific\enc8172.h
// AUTHOR:    M. Stephan
// COPYRIGHT: (c) 1999 Viona Development.  All Rights Reserved.
// CREATED:   23.6.99
//
// PURPOSE: The class for the  HMP8172 video encoder
//
// HISTORY:

#ifndef ENC8172_H
#define ENC8172_H

#include "..\generic\videnc.h"

class VirtualHMP8172;

class HMP8172 : public VideoEncoder 
	{
	friend class VirtualHMP8172;

	protected:
		
	public:
		HMP8172(void);
		~HMP8172(void);
	};



class VirtualHMP8172 : public VirtualVideoEncoder
	{
	friend class HMP8172;

	private:
		HMP8172 *	hmp8172;

	public:
		VirtualHMP8172 (HMP8172 * physical) : VirtualVideoEncoder (physical) {hmp8172 = physical;}
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\video\specific\encCH7004.h ===
// FILE:      library\hardware\video\specific\encCH7004.h
// AUTHOR:    Sam Frantz
// COPYRIGHT: (c) 2000 Ravisent Technologies, Inc.  All Rights Reserved.
// CREATED:   10-MAR-2000
//
// PURPOSE: The class for the Chrontel 7004C video encoder
//
// HISTORY:

#ifndef ENCCH7004_H
#define ENCCH7004_H

#include "library\common\virtunit.h"
#include "library\hardware\video\generic\ccapvenc.h"
#include "library\lowlevel\memmpdio.h"
#include "library\lowlevel\i2c.h"
#include "encCH7004reg.h"
#include "library\hardware\video\specific\enc5505.h"

#define MUX_SRC_EXTERNAL		1	// for WEBDVD: PIO1 bit6 - high
#define MUX_SRC_INTERNAL		0	// for WEBDVD: PIO1 bit6 - low


class VirtualEncCH7004;

typedef struct
	{
	// reg10H: MVEN, EOFP, VBIP, CSP
	BYTE	bMVEN, bEOFP, bVBIP, bCSP;
	// reg04H&05H BPWD[8:0], reg01H&02H BPST1[9:0]
	WORD	wBPWD, wBPST1;
	// reg08H BPED1[4:0]
	BYTE	bBPED1; 
	// reg0EH&0CH BPST2[9:0], reg17H&16H BPED2[9:0]
	WORD	wBPST2, wBPED2;
	// reg2BH ADBST
	BYTE	bADBST; 
	// reg2BH&2CH Z1S[8:0], reg2BH&2DH Z2S[8:0]
	WORD	wZ1S, wZ2S;
	// reg2BH&2EH ASB[8:0]
	WORD	wASB;
	// reg11H PZ[3:1] 
	BYTE	bPZ;
	// reg12H: P1L[1:0], P2L[1:0], P3L[1:0], P4L[1:0], P5L[1:0]
	BYTE	bP1L, bP2L, bP3L, bP4L, bP5L;
	// reg13H LPCS[2:0], reg0DH CSPF[3:0], reg0FH CSSP[5:0]
	BYTE	bLPCS, bCSPF, bCSSP;
	// reg2FH FL1F[6:0]
	BYTE	bFL1F;
	// reg2FH&30H FL2F[8:0], reg19H&18H F1SP[5:0], reg19H&1AH F2SP[5:0]
	WORD 	wFL2F, wF1SP, wF2SP;
	// reg2BH&31H PSLA[8:0], reg2BH&32H PSLB[8:0]
	WORD	wPSLA, wPSLB;
	// reg2AH AGCD[6:0]
	BYTE	bAGCD;
	// reg33H PSDA[6:0], reg34H PSDB[6:0]
	BYTE	bPSDA, bPSDB;
	// reg2BH&35H PSSA[8:0], reg2BH&36H PSSB[8:0]
	WORD	wPSSA, wPSSB;
	// reg3BH PSCA[7:0], reg3CH PSCB[7:0]
	BYTE	bPSCA, bPSCB;
	// reg37H&38H PSON[14:0], reg39H&3AH PSFM[14:0]
	WORD	wPSON, wPSFM;
	// reg3DH: VAMP, HAMP, AGCY
	BYTE	bVAMP, bHAMP, bAGCY;
	} EncCH7004MacrovisionSettings;


class EncCH7004 : public CloseCaptionVideoEncoder
	{
	friend class VirtualEncCH7004;

	protected:
		Enc5505					*internalEncoder;
		VirtualEncCH7004			*defaultVEncoder;

		// physical ports
		MemoryMappedIO				*mem;
		BitOutputPort				*videoActivePort;
		BitOutputPort				*svideoActivePort;
		BitOutputPort				*muxPort;
		AsyncByteInOutBus			*i2c;

		// general state parameters
		DWORD							changed;	// state changed
		BOOL							ignoreErrors;
		
		// Chrontel 7004 register values
		BYTE					encoderVersionId;
		int					displayMode;	// Table 16 - Mode selection
		int					inputDataFormat;	// Table 21, p. 35 in CH7004C
		int					pllm, plln;	// Table 25 - PLL M and N values
		int					pllcap;		// Table 30 - PLL capacitor setting
		int					blackLevel;	// Black Level
		int					clockMode;	// master/slave+divider, p.36, table 22
		int					calculatedIncrement;	// p. 44, 1 for slave, 0 for master
		int					syncPolarity;	// p. 38, symbol SPR
		int					videoBandwidth; // p. 34, register 0x03
		int					flickerFilterMode; // p. 33, register 0x01
		int					pmScart;	// Power Management - SCART control
		int					subCarrierFrequency;
		int					startActiveVideoPixelDelay; 
		
		// These four are part of the VirtualVideoChip class
		VideoStandard			standard;		// current video standard
		PALVideoSubStandard	palSubStandard;
		NTSCVideoSubStandard	ntscSubStandard;
		VideoMode			mode;				// current video mode
		BOOL					extSync;			// current state of extSync
	
		// These four are part of the VirtualVideoEncoder class
		int					copyProtection;
		DWORD					chromaFilterFrequency;
		int					hOffset;
		int					vOffset;
		
		//what is this?		BOOL	ntscSetup;		// NTSC 7.5 IRE setup
		BOOL					videoInverted;
		BOOL					hSyncPol;
		BOOL					vSyncPol;
		int					syncMode;
		BOOL					fixedExtSync;
		int					component;
		int					vsyncCopyProtection;
		BOOL					enableMacrovision;
		
		VideoMuxSource		muxSetting;	// VIDEOMUXSRC_INTERNAL or VIDEOMUXSRC_EXTERNAL
		VideoLineMode		lineMode;	// VLM_PROGRESSIVE or VLM_INTERLACED
		VideoPixClockMode	pixclkMode;	// VIDEOPIXCLK_INTERNAL or VIDEOPIXCLK_EXTERNAL
		BOOL					embeddedSync;
		int					idleDisplay;

		// Change parameters of physical unit.
#ifdef DUMP_VIDEO_REGISTERS
		void ReadAllRegisters(void);
#endif
		virtual Error SetVideoStandard (VideoStandard std);
		virtual Error SetMode (VideoMode mode);
		virtual Error SetExtSync (BOOL extsync);
		virtual Error SetPALVideoSubStandard (PALVideoSubStandard palSubStandard);
		virtual Error SetNTSCVideoSubStandard (NTSCVideoSubStandard ntscSubStandard);
		virtual Error SetSampleMode (VideoSampleMode mode);
		virtual Error SetHOffset (int offset);
		virtual Error SetVOffset (int offset);
		virtual Error SetIdleScreen (int idleScreen);
		virtual Error SetIdleScreen (void);
		virtual Error SetCopyProtection (int protection);
		virtual Error ApplyCopyProtection(EncCH7004MacrovisionSettings *p);
		virtual Error SetChromaFilter (DWORD frequency);
		virtual Error SetSVideoActive (BOOL active);
		virtual Error SetMuxSetting(VideoMuxSource muxSetting);
		virtual Error SetLineMode(VideoLineMode lineMode);
		virtual Error SetPixclkMode(VideoPixClockMode pixclkMode);
		virtual Error SetEmbeddedSync(BOOL embeddedSync);
		virtual Error SetHSyncPol(BOOL hSyncPol);
		virtual Error SetVSyncPol(BOOL vSyncPol);
		virtual Error SetStartActiveVideoPixelDelay(int startActiveVideoPixelDelay);
		virtual Error SetVideoStandardDependentParameters();

      // Perform the changes
		Error ProcessChanges (void);

		// Program specific encoder modes
		Error ProgramCopyProtection (int protection);

		Error SetInit (void);
		Error DisableEncoder (void);
		Error EnableEncoder (void);
		Error ConfigureClockMode();
		Error ConfigureMuxMode();
		Error ConfigureSyncMode();
		Error ConfigureVideoMode();

		Error Configure (TAG __far *tags);

		virtual void Interrupt (void);

		Error GetCCStatus(BOOL __far & first, BOOL __far & second);
		Error PutCCData(BOOL field, BYTE d1, BYTE d2);
		Error EnableCCTransfer(void);
		Error DisableCCTransfer(void);		
		Error CopySettingsToInternalEncoder(void);
	public:
		EncCH7004 (MemoryMappedIO *mem, GenericProfile *profile = NULL,
			BitOutputPort *videoActivePort = NULL, 
			BitOutputPort *svideoActivePort = NULL, 
			AsyncByteInOutBus *i2c = NULL,
			BitOutputPort *muxPort = NULL,
			Enc5505 *enc5505 = NULL);
		~EncCH7004 (void);

		VirtualUnit * CreateVirtual (void);

		void DeactivateOutputs (void);
		void ReactivateOutputs (void);
	};



class VirtualEncCH7004 : public VirtualCloseCaptionVideoEncoder
	{
	friend class EncCH7004;

	private:
		EncCH7004	*ch7004;
		int		instance;
		
		// VideoStandard			standard;		// current video standard
		// PALVideoSubStandard	palSubStandard;
		// NTSCVideoSubStandard	ntscSubStandard;
		// VideoMode				mode;	// current video mode
		// BOOL						extSync;			// current state of extSync
	
		// These four are also part of the VirtualVideoEncoder class
		// int					copyProtection;
		// DWORD					chromaFilterFrequency;
		// int					hOffset;
		// int					vOffset;
	
		// These members are specific to the EncCH7004 class
		VideoMuxSource		muxSetting;	// VIDEOMUXSRC_INTERNAL or VIDEOMUXSRC_EXTERNAL
		VideoLineMode		lineMode;	// VLM_PROGRESSIVE or VLM_INTERLACED
		VideoPixClockMode	pixclkMode;	// VIDEOPIXCLK_INTERNAL or VIDEOPIXCLK_EXTERNAL
		BOOL					embeddedSync;
		BOOL					hSyncPol; 
		BOOL					vSyncPol; 
		int					startActiveVideoPixelDelay; 
		
		int					component;
		BOOL					enableMacrovision;
		int					vsyncCopyProtection;
		BOOL					svideoActive;
		int					idleDisplay;

		BOOL					ignoreErrors;
		DWORD					changed;	// state changed

	// protected:
		// Error PreemptStopPrevious(VirtualUnit * previous);
		// Error PreemptStartNew(VirtualUnit * previous);
      // Error PreemptChange(VirtualUnit * previous);
		
	public:
		VirtualEncCH7004 (EncCH7004 *physical, BOOL interlaced=TRUE, BOOL returnOK=TRUE, int instance=0);
		Error Configure (TAG __far *tags);

	protected:
		Error Preempt (VirtualUnit *previous);
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\video\specific\encbt864.h ===
// FILE:      library\hardware\video\specific\encBT864.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   27.03.95
//
// PURPOSE: The class for the  BT864b video encoder.
//
// HISTORY:

#ifndef ENCBT864_H
#define ENCBT864_H

#include "..\generic\ccapvenc.h"
#include "library\lowlevel\hardwrio.h"



#define I2C_BT864   0x88  // the BT864's I2C bus address



// Sync polarities for the operation modes. Don't alter; chip specific!


class VirtualBT864;

class BT864 : public CloseCaptionVideoEncoder 
	{
	friend class VirtualBT864;

	protected:
		ByteIndexedInOutPort	*port;

		VideoStandard			standard;
		PALVideoSubStandard	palSubStandard;
		NTSCVideoSubStandard	ntscSubStandard;

		VideoMode 			mode;
		BOOL 					extSync;
		BOOL					modeOverride;
		int 					hOffset, vOffset;
		VideoSampleMode   sampleMode;
		int					copyProtection;		
		VideoBusFormat		videoBusFormat;
		
		BYTE					shadow0xce, shadow0xbc, vidForm;
		BOOL					palNBit;
		BOOL					setupDis;

		DWORD changed;

		virtual Error SetVideoStandard (VideoStandard std);
		virtual Error SetPALVideoSubStandard(PALVideoSubStandard palSubStandard);
		virtual Error SetNTSCVideoSubStandard(NTSCVideoSubStandard ntscSubStandard);
		virtual Error SetMode (VideoMode mode);
		virtual Error SetExtSync (BOOL extsync);
		virtual Error SetSampleMode(VideoSampleMode mode);
		virtual Error SetHOffset (int offset);
		virtual Error SetVOffset (int offset);
		virtual Error SetCopyProtection (int copyProtection);
		virtual Error SetIdleScreen (int idleScreen);

		Error GetCCStatus(BOOL __far & first, BOOL __far & second);
		Error PutCCData(BOOL field, BYTE d1, BYTE d2);
		Error EnableCCTransfer(void);
		Error DisableCCTransfer(void);		

		Error ProcessChanges (void);

		Error ProgramAll (void);

		Error Set_NTSC_TestPattern (void);
		Error Set_PAL_TestPattern (void);
		Error Set_NTSC_Capture (void);
		Error Set_PAL_Capture (void);
		Error Set_NTSC_Playback (void);
		Error Set_PAL_Playback (void);
		Error Set_NTSC_Playback_Ext (void);
		Error Set_PAL_Playback_Ext (void);
		Error Set_CopyProtection (void);
		
		Error Configure(TAG __far * tags);
	public:
		BT864 (ByteIndexedInOutPort *port, Profile * profile = NULL);

		Error	ReInitialize(void);

		VirtualUnit *CreateVirtual (void);
	};



class VirtualBT864 : public VirtualCloseCaptionVideoEncoder
	{
	friend class BT864;

	private:
		BT864 *	bt864;

	public:
		VirtualBT864 (BT864 * physical) : VirtualCloseCaptionVideoEncoder (physical) {bt864 = physical; }

		Error Configure (TAG __far * tags);

	protected:
		Error Preempt (VirtualUnit * previous);
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\video\specific\encch7004reg.h ===
// FILE:      library\hardware\video\specific\encCH7004reg.h
// AUTHOR:    Sam Frantz
// COPYRIGHT: (c) 2000 Ravisent Technologies, Inc.  All Rights Reserved.
// CREATED:   10-MAR-2000
//
// PURPOSE: The class for the Chrontel 7004C video encoder
//
// HISTORY:

#ifndef ENC7004REG_H
#define ENC7004REG_H

// Device addresses
#define CH_DAB_ADDR0		(0xEC)		// ADDR pin low 
#define CH_DAB_ADDR1		(0xEA)		// ADDR pin high
// #define CH_DAB_ADDR0		(0x76)		// ADDR pin low 
// #define CH_DAB_ADDR1		(0x75)		// ADDR pin high

#define I2C_CH7004_ADDR_LOW	CH_DAB_ADDR0
#define I2C_CH7004_ADDR_HIGH	CH_DAB_ADDR1
 
// Register addresses
#define CH_DM			(0x00)		// Display Mode 
#define CH_FF			(0x01)		// Flicker Filter 
#define CH_VBW			(0x03)		// Video Bandwidth 
#define CH_IDF			(0x04)		// Input Data Format 
#define CH_CM			(0x06)		// Clock Mode 
#define CH_SAV			(0x07)		// Start Active Video 
#define CH_PO			(0x08)		// Position Overflow 
#define CH_BL			(0x09)		// Black Level 
#define CH_HP			(0x0A)		// Horizontal Position 
#define CH_VP			(0x0B)		// Vertical Position 
#define CH_SP			(0x0D)		// Sync Polarity 
#define CH_PM			(0x0E)		// Power Management 
#define CH_CD			(0x10)		// Connection Detect 
#define CH_CE			(0x11)		// Contrast Enhancement 
#define CH_MNE			(0x13)		// PLL M and N extra bits 
#define CH_PLLM			(0x14)		// PLL-M Value 
#define CH_PLLN			(0x15)		// PLL-N Value 
#define CH_BCO			(0x17)		// Buffered Clock 
#define CH_FSCI0		(0x18)		// Subcarrier Frequency Adjust FSCI[31:28] 
#define CH_FSCI1		(0x19)		// Subcarrier Frequency Adjust FSCI[27:24] 
#define CH_FSCI2		(0x1A)		// Subcarrier Frequency Adjust FSCI[23:20] 
#define CH_FSCI3		(0x1B)		// Subcarrier Frequency Adjust FSCI[19:16] 
#define CH_FSCI4		(0x1C)		// Subcarrier Frequency Adjust FSCI[15:12] 
#define CH_FSCI5		(0x1D)		// Subcarrier Frequency Adjust FSCI[11:8] 
#define CH_FSCI6		(0x1E)		// Subcarrier Frequency Adjust FSCI[7:4] 
#define CH_FSCI7		(0x1F)		// Subcarrier Frequency Adjust FSCI[3:0] 
#define CH_PLLC			(0x20)		// PLL and Memory Control 
#define CH_CIVC			(0x21)		// CIV Control 
#define CH_CIV0			(0x22)		// Calculated Fsc Increment Value CIV[23:16] 
#define CH_CIV1			(0x23)		// Calculated Fsc Increment Value CIV[15:8] 
#define CH_CIV2			(0x24)		// Calculated Fsc Increment Value CIV[7:0] 
#define CH_VID			(0x25)		// Version ID 
#define CH_TEST0		(0x26)		// Test - undocumented 
#define CH_TEST1		(0x27)		// Test - undocumented 
#define CH_TEST2		(0x28)		// Test - undocumented 
#define CH_TEST3		(0x29)		// Test - undocumented 
#define CH_A			(0x2A)		// Address 

// Macrovision registers
#define CH_MV_VERSION_ID		(0x32)		// If not this part, do not play macrovision-protected content
#define CH_MV_BPST1A			(0x01)		// Back Porch AGC Pulse Starting Point1
#define CH_MV_BPST1B			(0x02)		// Back Porch AGC Pulse Starting Point1
#define CH_MV_BPWD1			(0x04)		// Back Porch AGC Pulse Ending Pixel
#define CH_MV_BPWD2			(0x05)		// Back Porch AGC Pulse Ending Pixel
#define CH_MV_BPED1			(0x08)		// Back Porch AGC Pulse Ending Point1
#define CH_MV_BPST2A			(0x0E)		// Back Porch AGC Pulse Starting Point2
#define CH_MV_BPST2B			(0x0C)		// Back Porch AGC Pulse Starting Point2
#define CH_MV_BPED2A			(0x17)		// Back Porch AGC Pulse Ending Point2
#define CH_MV_BPED2B			(0x16)		// Back Porch AGC Pulse Ending Point2

#define CH_MV_PSLA_HI	(0x31)
#define CH_MV_Z1S	(0x2C)
#define CH_MV_Z2S	(0x2D)
#define CH_MV_ASB	(0x2E)
#define CH_MV_PSSA	(0x35)
#define CH_MV_PSSB	(0x36)
#define CH_MV_PSLA	(0x31)
#define CH_MV_PSLB	(0x32)

#define CH_MV_PZ		(0x11)
#define CH_MV_PXL		(0x12)
#define CH_MV_LPCS		(0x13)
#define CH_MV_CSPF		(0x0D)
#define CH_MV_CSSP		(0x0F)
#define CH_MV_FL1F		(0x2F)
#define CH_MV_FL2F		(0x30)
#define CH_MV_F1SPA		(0x19)
#define CH_MV_F1SPB		(0x18)
#define CH_MV_F2SPA		(0x19)
#define CH_MV_F2SPB		(0x1A)
#define CH_MV_AGCD		(0x2A)
#define CH_MV_PSDA		(0x33)
#define CH_MV_PSDB		(0x34)
#define CH_MV_PSCA		(0x3B)
#define CH_MV_PSCB		(0x3C)
#define CH_MV_PSON1		(0x37)
#define CH_MV_PSON2		(0x38)
#define CH_MV_PSFM1		(0x39)
#define CH_MV_PSFM2		(0x3A)
#define CH_MV_AGCY		(0x3D)

// Programmable bit AGCY determines either the normal or static mode for 
// AGC pulses. In the normal mode, all the 60 Active Line AGC pulses remain 
// at the high level (810 mV) for approximately 12 +2/-0.5 seconds, and then 
// decay to blanking level (zero) over 2.5 0.5 seconds. Within 0 to 500 ms 
// of reaching blanking level, the AGC pulses commence the pulsation mode 
// (either A or B) and remain in that mode for 12 1.0 seconds. Then the AGC 
// pulses rise to the high level over another 2.5 0.5 seconds, commencing 
// from pulsation mode state B. The complete cycle takes about 30 seconds.
#define CH_MV_AGCY_CYCLING		(0x04)
#define CH_MV_AGCY_STATIC		(0x00)

// Display Mode - 0x00
#define CH_DM_SR		(0x07)		// Scale ratio 
#define CH_DM_SR_5_4		(0x00)		// Scale 5/4 
#define CH_DM_SR_1_1		(0x01)		// Scale 1/1 
#define CH_DM_SR_7_8		(0x02)		// Scale 7/8 
#define CH_DM_SR_5_6		(0x03)		// Scale 5/6 
#define CH_DM_SR_3_4		(0x04)		// Scale 3/4 
#define CH_DM_SR_7_10		(0x05)		// Scale 7/10 

#define CH_DM_VOS		(0x18)		// Output format 
#define CH_DM_VOS_PAL		(0x00)		// Output PAL 
#define CH_DM_VOS_NTSC		(0x08)		// Output NTSC 
#define CH_DM_VOS_PAL_M		(0x10)		// Output PAL-M 
#define CH_DM_VOS_NTSC_J	(0x18)		// Output NTSC-J 

#define CH_DM_IR		(0xE0)		// Input resolution 
#define CH_DM_IR_512_384	(0x00)		// Input 512x384 
#define CH_DM_IR_720_400	(0x20)		// Input 720x400 
#define CH_DM_IR_640_400	(0x40)		// Input 640x400 
#define CH_DM_IR_640_480	(0x60)		// Input 640x480 
#define CH_DM_IR_800x600	(0x80)		// Input 800x600 
#define CH_DM_IR_720x576	(0xA0)		// Input 720x576 (PAL) CH7004
#define CH_DM_IR_720x480	(0xA0)		// Input 720x480 (NTSC) CH7004

// Flicker Filter - 0x01
#define CH_FF_DEFAULT		(0x32)		// bits are 00110010
#define CH_FF_DVD		(0x02)		// bits are 00000010
#define CH_FF_WEB		(0x28)		// bits are 00101000

#define CH_FF_NONSCALED		(0x03)		// Non-scaled (1:1) modes 
#define CH_FF_0_1_0		(0x00)		// 0:1:0 - No flicker filtering 
#define CH_FF_1_2_1		(0x01)		// 1:2:1 - Moderate filtering 
#define CH_FF_1_3_1		(0x02)		// 1:3:1 - Low filtering 
#define CH_FF_1_1_1		(0x03)		// 1:1:1 - High filtering 

#define CH_FF_SCALED		(0x02)		// Scaled modes 
#define CH_FF_3_LINE		(0x00)		// 3-line filtering  
#define CH_FF_4_LINE		(0x02)		// 4-line filtering  


// Video Bandwidth - 0x03
#define CH_VBW_YCV		(0x01)		// Luma composite bandwidth 
#define CH_VBW_YCV_LOW		(0x00)		// Luma composite low bandwidth 
#define CH_VBW_YCV_HIGH		(0x01)		// Luma composite high bandwidth 

#define CH_VBW_YSV		(0x06)		// Luma S-video bandwidth 
#define CH_VBW_YSV_LOW		(0x00)		// Luma S-video low bandwidth 
#define CH_VBW_YSV_MEDIUM	(0x02)		// Luma S-video medium bandwidth 
#define CH_VBW_YSV_HIGH		(0x04)		// Luma S-video high bandwidth 

#define CH_VBW_YPEAK		(0x08)		// Luma S-video Y-peaking enabled 

#define CH_VBW_CBW		(0x30)		// Chroma composite bandwidth 
#define CH_VBW_CBW_LOW		(0x00)		// Chroma composite low bandwidth 
#define CH_VBW_CBW_MEDIUM	(0x10)		// Chroma composite medium bandwidth 
#define CH_VBW_CBW_MEDHIGH	(0x20)		// Chroma composite med-high bandwidth 
#define CH_VBW_CBW_HIGH		(0x30)		// Chroma composite high bandwidth 

#define CH_VBW_CVBW		(0x40)		// Composite black & white 

#define CH_VBW_FLFF		(0x80)		// 5-line filter in 7/10 scaling 


// Input Data Format - 0x04
#define CH_IDF_FORMAT		(0x0F)		// Input data format 
#define CH_IDF_16_NOMUX_RGB_565	(0x00)		// 16-bit non-muxed RGB (16-bit colour, 5-6-5) input 
#define CH_IDF_16_NOMUX_YCRCB	(0x01)		// 16-bit non-muxed YCrCb (24-bit colour) input (Y non-muxed, CrCb muxed) 
#define CH_IDF_16_MUX_RGB_24	(0x02)		// 16-bit muxed RGB (24-bit colour) input 
#define CH_IDF_15_NOMUX_RGB	(0x03)		// 15-bit non-muxed RGB (15-bit colour, 5-5-5) input 
#define CH_IDF_12_MUX_RGB_24_C	(0x04)		// 12-bit muxed RGB (24-bit colour) input ("C" mux scheme) 
#define CH_IDF_12_MUX_RGB_24_I	(0x05)		// 12-bit muxed RGB (24-bit colour) input ("I" mux scheme) 
#define CH_IDF_8_MUX_RGB_888	(0x06)		// 8-bit muxed RGB (24-bit colour, 8-8-8) input 
#define CH_IDF_8_MUX_RGB_565	(0x07)		// 8-bit muxed RGB (16-bit colour, 5-6-5) input 
#define CH_IDF_8_MUX_RGB_555	(0x08)		// 8-bit muxed RGB (15-bit colour, 5-5-5) input 
#define CH_IDF_8_MUX_YCRCB	(0x09)		// 8-bit muxed YCrCb (24-bit colour) input (Y, Cr and Cb are muxed 

#define CH_IDF_RGBBP		(0x20)		// RGB bypass mode enabled (100-pin package only) 

#define CH_IDF_DACG		(0x40)		// D/A converter gain 
#define CH_IDF_DACG_LOW		(0x00)		// 71uA for NTSC and PAL-M 
#define CH_IDF_DACG_HIGH	(0x40)		// 76uA for PAL and NTSC-J 


// Clock Mode - 0x06
#define CH_CM_CFRB_FREE_RUN	(0x00)		// When ACIV=1, p. 36
#define CH_CM_CFRB_LOCK_TO_VTV	(0x80)		// When ACIV=0, p. 36

#define CH_CM_PCM		(0x03)		// P-Out multiplier 
#define CH_CM_PCM_1X		(0x00)		// P-Out = 1 x pixel clock 
#define CH_CM_PCM_2X		(0x01)		// P-Out = 2 x pixel clock 
#define CH_CM_PCM_3X		(0x02)		// P-Out = 3 x pixel clock 

#define CH_CM_XCM		(0x0C)		// XCLK multiplier 
#define CH_CM_XCM_1X		(0x00)		// XCLK = 1 x pixel clock 
#define CH_CM_XCM_2X		(0x04)		// XCLK = 2 x pixel clock 
#define CH_CM_XCM_3X		(0x08)		// XCLK = 3 x pixel clock 

#define CH_CM_MCP		(0x10)		// Clock polarity 
#define CH_CM_MCP_NEG		(0x00)		// Latch input data on negative edge of clock 
#define CH_CM_MCP_POS		(0x10)		// Latch input data on positive edge of clock 

#define CH_CM_MS		(0x40)		// Master / slave 
#define CH_CM_MS_SLAVE		(0x00)		// Slave clock mode 
#define CH_CM_MS_MASTER		(0x40)		// Master clock mode 

#define CH_CM_CFRB		(0x80)		// Chroma subcarrier free-run or lock 
#define CH_CM_CFRB_FREE		(0x00)		// Chroma subcarrier free-runs              - use when ACIV = 1 
#define CH_CM_CFRB_LOCK		(0x80)		// Chroma subcarrier locked to video signal - use when ACIV = 0 


// Start Active Video - 0x07
 

// Position Overflow - 0x08
#define CH_PO_VP		(0x01)		// MSB of vertical position value 

   // Split overflow bit from 9-bit VP 	
#define CH_PO_VP_W(vp)	\
	(((vp) >> 8) & 0x01)			// CH_PO_VP = VP[8] 

   // Recombine byte and overflow bit 	
#define CH_VP_R(vpo,vp)		\
	((((int)(vpo) & 0x01) << 8)							\
	|(((int)(vp ) & 0xFF) << 0))

#define CH_PO_HP		(0x02)		// MSB of horizontal position value 

   // Split overflow bit from 9-bit HP 
#define CH_PO_HP_W(hp)	\
	(((hp) >> 7) & 0x02)			// CH_PO_HP = HP[8] 

   // Recombine byte and overflow bit
#define CH_HP_R(hpo,hp)	\
	((((int)(hpo) & 0x02) << 7)							\
	|(((int)(hp ) & 0xFF) << 0))

#define CH_PO_SAV		(0x04)		// MSB of start of active video value 

   // Split overflow bit from 9-bit SAV
#define CH_PO_SAV_W(sav)	\
	(((hp) >> 6) & 0x04)			// CH_PO_SAV = SAV[8] 

   // Recombine byte and overflow bit
#define CH_SAV_R(savo,sav)	\
	((((int)(savo) & 0x04) << 6)							\
	|(((int)(sav ) & 0xFF) << 0))


// Black Level - 0x09
#define CH_BL_MIN		(80)		// Minimum black level 
#define CH_BL_MAX		(208)		// Maximum black level 
#define CH_BL_NTSC		(127)		// Recommended value for NTSC 
#define CH_BL_PAL_M		(127)		// Recommended value for PAL-M 
#define CH_BL_PAL		(105)		// Recommended value for PAL 
#define CH_BL_NTSC_J		(100)		// Recommended value for NTSC-J 
#define CH_BL_SCART		(0)		// Must be zero in SCART mode 


// Sync Polarity - 0x0D
#define CH_SP_HSP		(0x01)		// Horizontal sync polarity 
#define CH_SP_HSP_LOW		(0x00)		// Horizontal sync active low 
#define CH_SP_HSP_HIGH		(0x01)		// Horizontal sync active high 

#define CH_SP_VSP		(0x02)		// Vertical sync polarity 
#define CH_SP_VSP_LOW		(0x00)		// Vertical sync active low 
#define CH_SP_VSP_HIGH		(0x02)		// Vertical sync active high 

#define CH_SP_SYO_OUTPUT	(0x04)		// H and V sync are output from CH7003 

#define CH_SP_DES		(0x08)		// Detect embedded sync in pixel stream - YCrCb only 


// Power Management - 0x0E
#define CH_PM_PD		(0x07)		// Power down modes 
#define CH_PM_PD_COMP_OFF	(0x00)		// Composite off - CVBS DAC is powered down 
#define CH_PM_PD_POWER_DOWN	(0x01)		// Power down - most pins and circuitry disabled 
#define CH_PM_PD_SVID_OFF	(0x02)		// S-video off - S-video DACs are powered down 
#define CH_PM_PD_NORMAL		(0x03)		// All circuits and pins are active 
#define CH_PM_PD_FULL_DOWN	(0x04)		// Full power down - all circuitry powered down 

#define CH_PM_NRESET		(0x08)		// Held in soft reset while zero 

#define CH_PM_SCART		(0x10)		// SCART mode - RGB output with composite sync 


// Connection Detect - 0x10
#define CH_CD_SENSE		(0x01)		// Output sense currents - write only 

#define CH_CD_CVBST		(0x02)		// S-video connection detect - reads 0 if connected 

#define CH_CD_CT		(0x04)		// C connection detect - reads 0 if connected 

#define CH_CD_YT		(0x08)		// Y connection detect - reads 0 if connected 


// Contrast Enhancement - 0x11
#define CH_CE_MASK		(0x07)		// Contrast enhancement value 
#define CH_CE_BLACK		(0x00)		// Minimum value - enhances black 
#define CH_CE_NORMAL		(0x03)		// Normal value - no enhancement 
#define CH_CE_WHITE		(0x07)		// Maximum value - enhances white 


// PLL M and N extra bits - 0x13
#define CH_MNE_M		(0x01)		// MSB of PLL M value 

  // Split overflow bit from 9-bit M 	
#define CH_MNE_M_W(m)	\
	(((m) >> 8) & 0x01)			// CH_MNE_M = M[8] 
  // Recombine byte and overflow bit 	
#define CH_M_R(mne,pllm)	\
	((((int)(mne)  & 0x01) << 8)							\
	|(((int)(pllm) & 0xFF) << 0))

#define CH_MNE_N		(0x06)		// MSBs of PLL N value 

  // Split overflow bits from 10-bit N 	
#define CH_MNE_N_W(n)	\
	(((n) >> 7) & 0x06)			// CH_MNE_N = N[9:8] 

  // Recombine byte and overflow bits 	
#define CH_N_R(mne,plln)	\
	((((int)(mne)  & 0x06) << 7)							\
	|(((int)(plln) & 0xFF) << 0))


// PLL-M Value - 0x14
// PLL-N Value - 0x15


// Buffered Clock Output - 0x17
#define CH_BCO_SCO		(0x07)		// Select clock source 
#define CH_BCO_SCO_14MHZ	(0x00)		// 14 MHz crystal 
#define CH_BCO_SCO_VCO_K3	(0x02)		// VCO divided by K3 
#define CH_BCO_SCO_FIELD	(0x03)		// Field ID signal 

#define CH_BCO_SHF		(0x38)		// Value of K3 for CH_BCO_SCO_VCO_K3, above 
#define CH_BCO_SHF_2_5		(0x00)		// K3 = 2.5 
#define CH_BCO_SHF_3_0		(0x08)		// K3 = 3.0 
#define CH_BCO_SHF_3_5		(0x10)		// K3 = 3.5 
#define CH_BCO_SHF_4_0		(0x18)		// K3 = 4.0 
#define CH_BCO_SHF_4_5		(0x20)		// K3 = 4.5 
#define CH_BCO_SHF_5_0		(0x28)		// K3 = 5.0 
#define CH_BCO_SHF_6_0		(0x30)		// K3 = 6.0 
#define CH_BCO_SHF_7_0		(0x38)		// K3 = 7.0 


// Subcarrier Frequency Adjust - 0x18..0x1F

// values from table 28 and table 29 on page 44 of CH7004C
#define CH_FSCI_INTERLACED_NTSC_NORMAL		569408543	// mode 26
#define CH_FSCI_INTERLACED_NTSC_NO_CRAWL	569410927	// mode 26
#define CH_FSCI_INTERLACED_PAL_M_NORMAL	568782819	// mode 26
#define CH_FSCI_INTERLACED_PAL_NORMAL		705268427	// mode 25
#define CH_FSCI_INTERLACED_PAL_N_NORMAL	569807942	// mode 25

#define CH_FSCI_PROGRESSIVE_NTSC_NORMAL_MODE_11	516986804
#define CH_FSCI_PROGRESSIVE_NTSC_NO_CRAWL_MODE_11	516988968
#define CH_FSCI_PROGRESSIVE_PAL_M_NORMAL_MODE_11	516418687

#define CH_FSCI_PROGRESSIVE_PAL_NORMAL_MODE_14		644816848
#define CH_FSCI_PROGRESSIVE_PAL_N_NORMAL_MODE_14	520967262

#define CH_FSCI_PROGRESSIVE_NTSC_NORMAL_MODE_17	545259520
#define CH_FSCI_PROGRESSIVE_NTSC_NO_CRAWL_MODE_17	545261803
#define CH_FSCI_PROGRESSIVE_PAL_M_NORMAL_MODE_17	544660334

#define CH_FSCI_PROGRESSIVE_NTSC_NORMAL_MODE_18	508908885
#define CH_FSCI_PROGRESSIVE_NTSC_NO_CRAWL_MODE_18	508911016
#define CH_FSCI_PROGRESSIVE_PAL_M_NORMAL_MODE_18	508349645

// for mode 25 & 26, see table 25, p. 42 of CH7004C
#define CH_PLLN_INTERLACED_NTSC		31
#define CH_PLLM_INTERLACED_NTSC		33
#define CH_PLLN_INTERLACED_PAL		31
#define CH_PLLM_INTERLACED_PAL		33

// for mode 25 & 26, see table 25, p. 42 of CH7004C
#define CH_PLLN_PROGRESSIVE_NTSC_MODE_11		22
#define CH_PLLM_PROGRESSIVE_NTSC_MODE_11		11
#define CH_PLLN_PROGRESSIVE_PAL_MODE_14			9
#define CH_PLLM_PROGRESSIVE_PAL_MODE_14			4
#define CH_PLLN_PROGRESSIVE_NTSC_MODE_17		126
#define CH_PLLM_PROGRESSIVE_NTSC_MODE_17		63
#define CH_PLLN_PROGRESSIVE_NTSC_MODE_18		190
#define CH_PLLM_PROGRESSIVE_NTSC_MODE_18		89

#define CH_PLLN_PROGRESSIVE_NTSC	CH_PLLN_PROGRESSIVE_NTSC_MODE_11
#define CH_PLLM_PROGRESSIVE_NTSC 	CH_PLLM_PROGRESSIVE_NTSC_MODE_11

#define CH_PLLN_PROGRESSIVE_PAL 	CH_PLLN_PROGRESSIVE_PAL_MODE_14
#define CH_PLLM_PROGRESSIVE_PAL 	CH_PLLM_PROGRESSIVE_PAL_MODE_14

 		// Split 32-bit FSCI value into nibbles
#define CH_FSCI0_W(f)	(((f) >> 28) & 0x0F)	// CH_FSCI0 = FSCI[31:28] 
#define CH_FSCI1_W(f)	(((f) >> 24) & 0x0F)	// CH_FSCI0 = FSCI[27:24] 
#define CH_FSCI2_W(f)	(((f) >> 20) & 0x0F)	// CH_FSCI0 = FSCI[23:20] 
#define CH_FSCI3_W(f)	(((f) >> 16) & 0x0F)	// CH_FSCI0 = FSCI[19:16] 
#define CH_FSCI4_W(f)	(((f) >> 12) & 0x0F)	// CH_FSCI0 = FSCI[15:12] 
#define CH_FSCI5_W(f)	(((f) >>  8) & 0x0F)	// CH_FSCI0 = FSCI[11: 8] 
#define CH_FSCI6_W(f)	(((f) >>  4) & 0x0F)	// CH_FSCI0 = FSCI[ 7: 4] 
#define CH_FSCI7_W(f)	(((f) >>  0) & 0x0F)	// CH_FSCI0 = FSCI[ 3: 0] 

   // Recombine nibbles to make 32-bit word 
#define CH_FSCI_R(f0,f1,f2,f3,f4,f5,f6,f7)	\
	((((int)(f0) & 0x0F) << 28)								\
	|(((int)(f1) & 0x0F) << 24)								\
	|(((int)(f2) & 0x0F) << 20)								\
	|(((int)(f3) & 0x0F) << 16)								\
	|(((int)(f4) & 0x0F) << 12)								\
	|(((int)(f5) & 0x0F) <<  8)								\
	|(((int)(f6) & 0x0F) <<  4)								\
	|(((int)(f7) & 0x0F) <<  0))


// PLL and Memory Control - 0x20
#define CH_PLLC_MEM5V		(0x01)		// Memory supply is 5 volts 

#define CH_PLLC_PLL5VA		(0x02)		// PLL analog supply is 5 volts 

#define CH_PLLC_PLL5VD		(0x04)		// PLL digital supply is 5 volts 

#define CH_PLLC_PLLS		(0x08)		// PLL stages - set if PLL5VA is set 

#define CH_PLLC_PLLCAP		(0x10)		// PLL filter capacitor 

#define CH_PLLC_PLLCHI		(0x20)		// PLL charge pump current - for emergency use only 


// CIV Control - 0x21
#define CH_CIVC_ACIV		(0x01)		// Automatic calculated increment value 

#define CH_CIVC_CIVH_MASK	(0x06)		// CIV hysteresis 
#define CH_CIVC_CIVH_SHIFT	(1)		// Shift left by this and mask with CH_CIVC_CIVH_MASK 


// Calculated Increment Value - 0x22..0x24
			// Split 24-bit CIV value into bytes
#define CH_CIV0_W(civ)	(((civ) >> 16) & 0xFF)	// CH_CIV0 = CIV[23:16] 
#define CH_CIV1_W(civ)	(((civ) >>  8) & 0xFF)	// CH_CIV1 = CIV[15: 8] 
#define CH_CIV2_W(civ)	(((civ) >>  0) & 0xFF)	// CH_CIV2 = CIV[ 7: 0] 

   // Recombine bytes to make 24-bit value 
#define CH_CIV_R(civ0,civ1,civ2)	\
	((((int)(civ0) & 0xFF) << 16)								\
	|(((int)(civ1) & 0xFF) <<  8)								\
	|(((int)(civ2) & 0xFF) <<  0))


// Version ID - 0x25
#define CH_VID_CH7003		(0x00)
#define CH_VID_CH7003A		(0x01)

// macros added for to eliminate constants in Teknema source
#define INITIAL_PAL_POSX			(58)
#define INITIAL_PAL_POSY			(22)
#define INITIAL_NTSC_POSX			(56)	// depends on build settings
#define INITIAL_NTSC_POSY			(-2)	// ?investigate
#define INITIAL_NTSCJ_POSX			(48)	// ?investigate
#define INITIAL_NTSCJ_POSY			(15)	// ?investigate
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\video\specific\SAA7113.H ===
//
// FILE:       library\hardware\video\specific\saa7113.h
// AUTHOR:		Martin Stephan
// COPYRIGHT:	(c) 1999 Viona Development GmbH.  All Rights Reserved.
// CREATED:		29.11.1999
//
// PURPOSE: 	9-bit video input processor SAA 7113 H - interface
//
// HISTORY:
//

#ifndef SAA7113_H
#define SAA7113_H


#include "library\common\gnerrors.h"         
#include "..\generic\viddec.h"
#include "library\lowlevel\intrctrl.h"


class VirtualSAA7113;   // forward declaration


#define SAA7113_MAX_INPUT_LINES  6

//
// SAA 7113 input mode
// four analog inputs, internal analog source selectors, e.g. 4 * CVBS or 2 * Y/C
enum SAA7113_InputMode
	{
	SAA7113_INPUTMODE_CVBS0, SAA7113_INPUTMODE_CVBS1, SAA7113_INPUTMODE_CVBS2, SAA7113_INPUTMODE_CVBS3,
	SAA7113_INPUTMODE_YC0, SAA7113_INPUTMODE_YC1, SAA7113_INPUTMODE_YC2, SAA7113_INPUTMODE_YC3,
	SAA7113_INPUTMODE_NONE
	};

//
// SAA 7113 output mode
// standard ITU 656 YUV 4:2:2 format (8 bit)
enum SAA7113_OutputMode		
	{
	SAA7113_OUTPUTMODE_YUV_8bit    = 0,
	};


class SAA7113 : public VideoDecoder
	{
	friend class VirtualSAA7113;
	friend class SAA7113VBlankIntHandler;
	
	private:
		void VBlankInterrupt(void);
		//
		// Communication port (typically I2C)
		//		
		ByteIndexedInOutPort		*port;

		SAA7113_InputMode lines[SAA7113_MAX_INPUT_LINES];

		WORD				brightness;
		WORD				contrast;
		WORD				saturation;
		BYTE				hue;
      
		//
		// Current input, standard, mode etc.
		//
		WORD				input;
		VideoStandard	standard;
		VideoMode		mode;

		InterruptServer			*vBlankIntServer;
		SAA7113VBlankIntHandler	*vBlankIntHandler;

		SAA7113_OutputMode		outputMode;

		//
		// Parameter setting functions		
		//
		Error SetVideoStandard(VideoStandard std);
		Error SetMode(VideoMode mode);
		Error SetInput(WORD input);
		Error SetBrightness(WORD brightness);
		Error SetContrast(WORD contrast);
		Error SetSaturation(WORD saturation);
		Error SetHue(WORD hue);         
		Error SetSampleMode(VideoSampleMode mode);		// mst: don't know yet what a video sample mode is!

		//
		// Reprogram chip values
		//		
		Error ProgramInput(void);
		Error ProgramBrightness(void);
		Error ProgramContrast(void);
		Error ProgramSaturation(void);
		Error ProgramHue(void);   
		
		//
		// Program specific encoder mode
		//
		Error SetInit(void);
		Error SetNTSCPlayback(void);
		Error SetPALPlayback(void);
		Error SetNTSCCapture(void);
		Error SetPALCapture(void);
		Error SetReset(void);
		Error SetNTSCPatternSync (void);
		Error SetPALPatternSync (void);
		
		BYTE CalcBrightness (void);
		BYTE CalcContrast (void);
		BYTE CalcSaturation (void);

	public:
		SAA7113(ByteIndexedInOutPort *port, VirtualUnit *videoBus, InterruptServer *vBlankIntServer = NULL,
		         WORD numInputs = 0, VideoDecoderInputEntry __far *inputNames = NULL,
		         SAA7113_InputMode lines[SAA7113_MAX_INPUT_LINES] = NULL);
		~SAA7113(void);

		VirtualUnit * CreateVirtual(void);

		Error SetOutput (SAA7113_OutputMode output);   // (change to private scope later)

	protected:
		virtual Error SetNTSC(void);
		virtual Error SetPAL(void);

		// Check the current video standard
		Error DetectVideoStandard(VideoStandard __far &std);

		BOOL VideoStandardWasChanged (void);

		VideoStandard GetVideoStandard(void) {return standard;}

		// Checks changes in setting, and triggers changes in registers
		virtual Error ProcessChanges(void);

		// Flags, which part of the programming have been changed
		DWORD			changed;

	};

class VirtualSAA7113 : public VirtualVideoDecoder
	{      
	private:
		SAA7113		*	saa7113;
	public:
		VirtualSAA7113 (SAA7113 *physical);

		Error Configure (TAG __far *tags);

	protected:
		Error Preempt (VirtualUnit *previous);
	};


#endif // endif SAA7113_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\video\specific\stv0117a.h ===
// FILE:      library\hardware\video\specific\encBT856.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   27.03.95
//
// PURPOSE: The class for the STV0117A video encoder
//
// HISTORY:

#ifndef STV0117A_H
#define STV0117A_H

#include "..\generic\videnc.h"
#include "..\..\..\lowlevel\hardwrio.h"



#define I2C_STV0117A   0x40 



class VirtualVideoEncoderSTV0117A;

class VideoEncoderSTV0117A : public VideoEncoder 
	{
	friend class VirtualVideoEncoderSTV0117A;

	protected:
		ByteIndexedInOutPort	*port;

		VideoStandard		standard;
		VideoMode 			mode;
		int 					hOffset, vOffset;
		int					copyProtection;        
		VideoSampleMode   sampleMode;

		DWORD changed;

		virtual Error SetVideoStandard (VideoStandard std);
		virtual Error SetMode (VideoMode mode);
		virtual Error SetExtSync (BOOL sync);
		virtual Error SetSampleMode(VideoSampleMode mode);
		virtual Error SetHOffset (int offset);
		virtual Error SetVOffset (int offset);
		virtual Error SetCopyProtection (int copyProtection);

		Error ProcessChanges (void);

		Error ProgramAll (void);

		Error Set_NTSC_TestPattern (void);
		Error Set_PAL_TestPattern (void);
		Error Set_NTSC_Capture (void);
		Error Set_PAL_Capture (void);
		Error Set_NTSC_Playback (void);
		Error Set_PAL_Playback (void);
		
		Error Set_CopyProtection (void);
	public:
		VideoEncoderSTV0117A (ByteIndexedInOutPort *port) : VideoEncoder ()
			{
			this->port = port;
			changed = 0xffffffff;
			standard = VSTD_PAL;
			mode = VMOD_RESET;
			hOffset = 0; vOffset = 0; 
			sampleMode = VSAMOD_CCIR;
			copyProtection = 0;
			}

		VirtualUnit *CreateVirtual (void);
	};



class VirtualVideoEncoderSTV0117A : public VirtualVideoEncoder
	{
	friend class VideoEncoderSTV0117A;

	private:
		VideoEncoderSTV0117A * device;

	public:
		VirtualVideoEncoderSTV0117A (VideoEncoderSTV0117A *physical) : VirtualVideoEncoder (physical) 
			{device = physical; }

		Error Configure (TAG __far * tags);

	protected:
		Error Preempt (VirtualUnit * previous);
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\videodma\generic\clrkeymg.h ===
// FILE:      library\hardware\videodma\generic\clrkeymg.h
// AUTHOR:    S. Herr
// COPYRIGHT: (c) 1997 Viona Development GmbH. All Rights Reserved.
// CREATED:   12.08.97
//
// PURPOSE:   Direct Draw Color Key Management Class
//
// HISTORY:

#ifndef CLRKEYMG_H
#define CLRKEYMG_H

#ifndef ONLY_EXTERNAL_VISIBLE

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"
#include "ddraw.h"
#include "library\support\VDSup32\VDSup32.h"

class DDColorkeyManager
	{
	protected:
		DWORD	keyIndex;
		DWORD	keyColor;
		DWORD	keyColorRGB;
		DWORD	keyColorIndex;

		BOOL	GetDDInfo(void);
		DWORD ConvertKeyIndex(DWORD __far & colorIndex);
		DWORD ConvertKeyColor(DWORD colorRGB);
	public:
		DDSURFACEDESC	ddSfcDesc;
		
		BOOL	ddAvailable;
		
		DDColorkeyManager(void);

		BOOL SetDDColorkeyColor(DWORD color);
		BOOL SetDDColorkeyIndex(DWORD index);
		
		Error DrawColorkey(HWND win);
		Error DrawBlack(HWND win);
	};

#endif // ONLY_EXTERNAL_VISIBLE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\video\specific\saa7113r.h ===
//
// FILE:       library\hardware\video\specific\saa7113r.cpp
// AUTHOR:		Martin Stephan
// COPYRIGHT:	(c) 1999 Viona Development GmbH.  All Rights Reserved.
// CREATED:		01.12.1999
//
// PURPOSE: 	9-bit video input processor SAA 7113 register definitions
//
// HISTORY:
//

#ifndef SAA7113R_H
#define SAA7113R_H

#define SAA7113_INIT_START_AT				0x02
#define SAA7113_IDX_MODE_0						0
#define SAA7113_IDX_MODE_1						1
#define SAA7113_IDX_MODE_2						2
#define SAA7113_IDX_MODE_3						3
#define SAA7113_IDX_GUDL_0						4
#define SAA7113_IDX_GUDL_1						5
#define SAA7113_IDX_FUSE_0						6
#define SAA7113_IDX_FUSE_1						7
#define SAA7113_HOR_SYNC_START			0x06
#define SAA7113_IDX_HSB_0						0
#define SAA7113_IDX_HSB_1						1
#define SAA7113_IDX_HSB_2						2
#define SAA7113_IDX_HSB_3						3
#define SAA7113_IDX_HSB_4						4
#define SAA7113_IDX_HSB_5						5
#define SAA7113_IDX_HSB_6						6
#define SAA7113_IDX_HSB_7						7
#define SAA7113_HOR_SYNC_STOP				0x07
#define SAA7113_SYNC_CONTROL				0x08
#define SAA7113_IDX_VNOI_0						0
#define SAA7113_IDX_VNOI_1						1
#define SAA7113_IDX_HPLL						2
#define SAA7113_IDX_HTC_0						3
#define SAA7113_IDX_HTC_1						4
#define SAA7113_IDX_FOET						5
#define SAA7113_IDX_FSEL						6
#define SAA7113_IDX_AUFD						7
#define SAA7113_LUMINANCE_CONTROL		0x09
#define SAA7113_BRIGHTNESS					0x0A
#define SAA7113_CONTRAST					0x0B
#define SAA7113_SATURATION					0x0C
#define SAA7113_HUE							0x0D
#define SAA7113_CHROMA_CONTROL			0x0E
#define SAA7113_CHROMA_GAIN_CONTROL		0x0F
#define SAA7113_FORMAT_DELAY_CONTROL	0x10
#define SAA7113_IDX_YDEL_0						0
#define SAA7113_IDX_YDEL_1						1
#define SAA7113_IDX_YDEL_2						2
#define SAA7113_IDX_VRLN						3
#define SAA7113_IDX_HDEL_0						4
#define SAA7113_IDX_HDEL_1						5
#define SAA7113_IDX_OFTS_0						6
#define SAA7113_IDX_OFTS_1						7
#define SAA7113_OUT_CONTROL_1				0x11
#define SAA7113_IDX_COLO						0
#define SAA7113_IDX_VIPB						1
#define SAA7113_IDX_OERT						2
#define SAA7113_IDX_OEYC						3
#define SAA7113_IDX_HLSEL						4
#define SAA7113_IDX_GPSW0						5
#define SAA7113_IDX_CM_99						6
#define SAA7113_IDX_GPSW_1						7
#define SAA7113_OUT_CONTROL_2				0x12
#define SAA7113_OUT_CONTROL_3				0x13
#define SAA7113_STATUS_VIDEO_DECODER	0x1F
#define SAA7113_IDX_RDCAP_CODE				0
#define SAA7113_IDX_COPRO_SLTCA				1
#define SAA7113_IDX_WIPA						2
#define SAA7113_IDX_GLIMB						3
#define SAA7113_IDX_GLIMT						4
#define SAA7113_IDX_FIDT						5
#define SAA7113_IDX_HLVLN_HLCK				6
#define SAA7113_IDX_INTL						7

#endif // SAA7113R_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\videodma\generic\DCIDDI.H ===
// FILE:		   library\hardware\videodme\generic\dciddi.h
// AUTHOR:		Viona
// COPYRIGHT:	(c) 1995 Viona Development.  All Rights Reserved.
// CREATED:		05.12.96
//
// PURPOSE: 	
//
// HISTORY:
/*******************************************************************
 *
 *	FILE:		dciddi.h
 *	
 *	DESCRIPTION:	definitions for MS/Intel-defined DCI interface
 *
 *	Copyright (C) 1994 Intel/Microsoft Corporation.  All Rights Reserved.
 *
 *******************************************************************/

/* This file had to be changed for use with C++ by SH. Otherwise MSVC++ would have generated a
   syntax error because LPDCISURFACEINFO was used before it was defined.
*/

#ifndef _INC_DCIDDI
#define _INC_DCIDDI

#ifdef __cplusplus
extern "C" {
#endif

/* DCI Command Escapes */                                                               
#define DCICOMMAND			3075
#define DCI_VERSION			0x0100

#define DCICREATEPRIMARYSURFACE		1 
#define DCICREATEOFFSCREENSURFACE       2 
#define DCICREATEOVERLAYSURFACE         3
#define DCIENUMSURFACE                  4 
#define DCIESCAPE                       5

/* DCI-Defined error codes */
#define DCI_OK                              	0 /* success */

/* Hard errors -- DCI will be unavailable */
#define DCI_FAIL_GENERIC                     -1
#define DCI_FAIL_UNSUPPORTEDVERSION          -2
#define DCI_FAIL_INVALIDSURFACE              -3
#define DCI_FAIL_UNSUPPORTED                 -4    

/* Soft errors -- DCI may be available later */
#define DCI_ERR_CURRENTLYNOTAVAIL           -5
#define DCI_ERR_INVALIDRECT                 -6
#define DCI_ERR_UNSUPPORTEDFORMAT           -7
#define DCI_ERR_UNSUPPORTEDMASK             -8
#define DCI_ERR_TOOBIGHEIGHT                -9
#define DCI_ERR_TOOBIGWIDTH                 -10
#define DCI_ERR_TOOBIGSIZE                  -11
#define DCI_ERR_OUTOFMEMORY                 -12
#define DCI_ERR_INVALIDPOSITION             -13
#define DCI_ERR_INVALIDSTRETCH              -14
#define DCI_ERR_INVALIDCLIPLIST             -15
#define DCI_ERR_SURFACEISOBSCURED           -16
#define DCI_ERR_XALIGN			    -17
#define DCI_ERR_YALIGN			    -18
#define DCI_ERR_XYALIGN			    -19
#define DCI_ERR_WIDTHALIGN		    -20
#define DCI_ERR_HEIGHTALIGN		    -21
											 
/* success messages -- DCI call succeeded, but specified item changed */
#define DCI_STATUS_POINTERCHANGED           1
#define DCI_STATUS_STRIDECHANGED            2
#define DCI_STATUS_FORMATCHANGED            4
#define DCI_STATUS_SURFACEINFOCHANGED       8
#define DCI_STATUS_CHROMAKEYCHANGED        16				
#define DCI_STATUS_WASSTILLDRAWING         32


/* DCI Capability Flags */
#define DCI_SURFACE_TYPE			0x0000000F
#define DCI_PRIMARY                 		0x00000000
#define DCI_OFFSCREEN               		0x00000001
#define DCI_OVERLAY                 		0x00000002

#define DCI_VISIBLE                 		0x00000010
#define DCI_CHROMAKEY               		0x00000020
#define DCI_1632_ACCESS             		0x00000040
#define DCI_DWORDSIZE               		0x00000080
#define DCI_DWORDALIGN              		0x00000100
#define DCI_WRITEONLY               		0x00000200
#define DCI_ASYNC                   		0x00000400

#define DCI_CAN_STRETCHX            		0x00001000
#define DCI_CAN_STRETCHY            		0x00002000
#define DCI_CAN_STRETCHXY           		(DCI_CAN_STRETCHX | DCI_CAN_STRETCHY)

#define DCI_CAN_STRETCHXN           		0x00004000
#define DCI_CAN_STRETCHYN           		0x00008000
#define DCI_CAN_STRETCHXYN          		(DCI_CAN_STRETCHXN | DCI_CAN_STRETCHYN)


#define DCI_CANOVERLAY                          0x00010000

/*
 * Win32 RGNDATA structure.  This will be used for  cliplist info. passing.
 */
#if (WINVER < 0x0400)

#ifndef RDH_RECTANGLES

typedef struct tagRECTL
{                      
   LONG     left;      
   LONG     top;       
   LONG     right;     
   LONG     bottom;    
} RECTL;               
typedef RECTL*       PRECTL; 
typedef RECTL NEAR*  NPRECTL; 
typedef RECTL FAR*   LPRECTL;  
typedef const RECTL FAR* LPCRECTL;

#define RDH_RECTANGLES  0

typedef struct tagRGNDATAHEADER {
   DWORD   dwSize;                              /* size of structure             */
   DWORD   iType;                               /* Will be RDH_RECTANGLES        */
   DWORD   nCount;                              /* # of clipping rectangles      */
   DWORD   nRgnSize;                            /* size of buffer -- can be zero */
   RECTL   rcBound;                             /* bounding  rectangle for region*/
} RGNDATAHEADER;
typedef RGNDATAHEADER*       PRGNDATAHEADER;
typedef RGNDATAHEADER NEAR*  NPRGNDATAHEADER;
typedef RGNDATAHEADER FAR*   LPRGNDATAHEADER;
typedef const RGNDATAHEADER FAR* LPCRGNDATAHEADER;

typedef struct tagRGNDATA {
   RGNDATAHEADER   rdh;
   char            Buffer[1];
} RGNDATA;
typedef RGNDATA*       PRGNDATA;
typedef RGNDATA NEAR*  NPRGNDATA;
typedef RGNDATA FAR*   LPRGNDATA;
typedef const RGNDATA FAR* LPCRGNDATA;

#endif
#endif

typedef int     DCIRVAL;                /* return for callbacks */

/**************************************************************************
 *	input structures
 **************************************************************************/

/*
 * Used by a DCI client to provide input parameters for the 
 * DCICREATEPRIMARYSURFACE escape.
 */
typedef struct _DCICMD {
	DWORD	dwCommand;
	DWORD	dwParam1;
	DWORD 	dwParam2;
	DWORD	dwVersion;
	DWORD	dwReserved;
} DCICMD;

/*
 * This structure is used by a DCI client to provide input parameters for 
 * the DCICREATE... calls.  The fields that are actually relevant differ for 
 * each of the three calls.  Details are in the DCI Spec chapter providing 
 * the function specifications.
 */
typedef struct _DCICREATEINPUT {
	DCICMD	cmd;							/* common header structure */
	DWORD   dwCompression;          		/* format of surface to be created                      */
	DWORD   dwMask[3];                      /* for  nonstandard RGB (e.g. 5-6-5, RGB32) */
	DWORD   dwWidth;                        /* height of the surface to be created          */
	DWORD   dwHeight;                       /* width of input surfaces                                      */
	DWORD	dwDCICaps;						/* capabilities of surface wanted */
	DWORD	dwBitCount;					/* bit depth of format to be created */
	LPVOID  lpSurface;                      /* pointer to an associated surface             */      
} DCICREATEINPUT, FAR *LPDCICREATEINPUT;
		


/**************************************************************************
 *	surface info. structures
 **************************************************************************/

/*
 * This structure is used to return information about available support
 * during a DCIEnumSurface call.  It is also used to create a primary 
 * surface, and as a member of the larger structures returned by the 
 * offscreen and overlay calls.
 */
 typedef struct _DCISURFACEINFO {
	DWORD   dwSize;                 	/* size of structure                                            */
	DWORD   dwDCICaps;                  /* capability flags (stretch, etc.)             */
	DWORD   dwCompression;          	/* format of surface to be created                      */
	DWORD   dwMask[3];                  /* for BI_BITMASK surfaces                                      */

	DWORD   dwWidth;                    /* width of surface                                             */
	DWORD   dwHeight;                   /* height of surface                                            */
	LONG    lStride;                    /* distance in bytes betw. one pixel            */
										/* and the pixel directly below it                      */
	DWORD   dwBitCount;                 /* Bits per pixel for this dwCompression    */
	DWORD   dwOffSurface;               /* offset of surface pointer                            */
	WORD    wSelSurface;                /* selector of surface pointer                          */
	WORD    wReserved;					

	DWORD   dwReserved1;                /* reserved for provider */
	DWORD   dwReserved2;                /* reserved for DCIMAN */     
	DWORD   dwReserved3;                /* reserved for future */     
        DCIRVAL (CALLBACK *BeginAccess) (LPVOID, LPRECT);    /* BeginAccess callback         */
	void (CALLBACK *EndAccess) (LPVOID);                   /* EndAcess callback            */      
	void (CALLBACK *DestroySurface) (LPVOID);               /* Destroy surface callback     */
} DCISURFACEINFO, FAR *LPDCISURFACEINFO;


/*
 * This structure is used by a DCI client to provide input parameters for the 
 * DCIEnumSurface call.
 */
typedef struct _DCIENUMINPUT {
	DCICMD	cmd;							/* common header structure */
	RECT    rSrc;                           /* source rect. for stretch  */
	RECT    rDst;                           /* dest. rect. for stretch       */
	void    (CALLBACK *EnumCallback)(LPDCISURFACEINFO, LPVOID);        /* callback for supported formats */
	LPVOID  lpContext;
} DCIENUMINPUT, FAR *LPDCIENUMINPUT;

/*
 * This structure must be allocated and returned by the DCI provider in 
 * response to a DCICREATEPRIMARYSURFACE call.
 */
 typedef DCISURFACEINFO DCIPRIMARY, FAR *LPDCIPRIMARY;
								   
/*
 * This structure must be allocated and returned by the DCI provider in 
 * response to a DCICREATEOFFSCREENSURFACE call.
 */
 typedef struct _DCIOFFSCREEN {

	DCISURFACEINFO  dciInfo;                                                           /* surface info                  */
        DCIRVAL (CALLBACK *Draw) (LPVOID);                                            /* copy to onscreen buffer   */
        DCIRVAL (CALLBACK *SetClipList) (LPVOID, LPRGNDATA);          /* SetCliplist callback              */
        DCIRVAL (CALLBACK *SetDestination) (LPVOID, LPRECT, LPRECT);  /* SetDestination callback       */
} DCIOFFSCREEN, FAR *LPDCIOFFSCREEN;


/*
 * This structure must be allocated and returned by the DCI provider in response
 * to a DCICREATEOVERLAYSURFACE call.
 */
 typedef struct _DCIOVERLAY{

	DCISURFACEINFO  dciInfo;                                                /* surface info                  */
	DWORD   dwChromakeyValue;                                               /* chromakey color value                 */
	DWORD   dwChromakeyMask;                                                /* specifies valid bits of value */
} DCIOVERLAY, FAR *LPDCIOVERLAY;


/* DCI FOURCC def.s for extended DIB formats */                    

#ifndef YVU9
#define YVU9                        mmioFOURCC('Y','V','U','9')
#endif
#ifndef Y411
#define Y411                        mmioFOURCC('Y','4','1','1')                                             
#endif
#ifndef YUY2
#define YUY2                        mmioFOURCC('Y','U','Y','2')
#endif
#ifndef YVYU
#define YVYU                        mmioFOURCC('Y','V','Y','U')
#endif
#ifndef UYVY
#define UYVY                        mmioFOURCC('U','Y','V','Y')
#endif
#ifndef Y211
#define Y211                        mmioFOURCC('Y','2','1','1')
#endif

#ifdef __cplusplus
}
#endif

#endif // _INC_DCIDDI
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\videodma\generic\GFXCFGRC.H ===
// FILE:		   library\hardware\videodme\generic\gfxcfgrc.h
// AUTHOR:		Viona
// COPYRIGHT:	(c) 1995 Viona Development.  All Rights Reserved.
// CREATED:		05.12.96
//
// PURPOSE: 	
//
// HISTORY:
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by GFXCONFG.RC
//
#define IDD_DIALOG1                     101
#define IDD_ADDRESSDLG                  101
#define IDC_ADDRESS                     1000
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\videodma\generic\DMAPIP.H ===
// FILE:      library\hardware\videodma\generic\dmapip.h
// AUTHOR:    Ulrich Sigmund, S. Herr
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   08.04.95
//
// PURPOSE: The PIP-related classes.
//
// HISTORY:

#ifndef DMAPIP_H
#define DMAPIP_H

#include "pip.h"

#if !NT_KERNEL && !VXD_VERSION
#include "..\generic\clrkeymg.h"
#endif


MKTAG (PIP_OVERLAY_IN_USE,				PIP_UNIT, 0x00000020, BOOL)   // overlay instead of inlay in use right now ?



#ifndef ONLY_EXTERNAL_VISIBLE

#include "rectmap.h"

#if !NT_KERNEL && !VXD_VERSION
#include "library\common\winports.h"
#if VIONA_VERSION
#include "library\common\profiles.h"
#include "library\support\VDSup32\VDSup32.h"
#include "library\lowlevel\dmabuffr.h"
#endif

struct HookData {
        LPARAM lParam;
        WPARAM wParam;
        unsigned message;               
        HWND hwnd;      
};
#endif



#if !NT_KERNEL && !VXD_VERSION
class DMAPIP : public PIP, public DDColorkeyManager
#else
class DMAPIP : public PIP
#endif
	{
	friend class VirtualDMAPIP;
	protected:
		enum DMAPIPState
			{
			DPS_IDLE,
			DPS_INLAY,
			DPS_OVERLAY,
			DPS_COPYOVERLAY,
			DPS_CLIPPEROVERLAY,
			DPS_OFFSCREEN
			} state;
		
		BOOL			dmaRunning;
		BOOL			maskRebuild;

#if NT_KERNEL || VXD_VERSION
		WinDesc	*	wd;

		BOOL			colorKeyed;
		DWORD			keyIndex;
		BOOL			alwaysOverlay;
#else
#if VIONA_VERSION
		DDAccess		ddAccess;
		BOOL			colorKeyed;
		BOOL			copyOverlayEnabled;
		BOOL			dmaOverlayEnabled;

		BOOL			noDDClipper;				// Prevents using DirectDraw Clipper Objects
		
		RECT			keyPaintRect;
		
		DWORD			keyColor;
		DWORD			keyIndex;
		DWORD			keyColorRGB;
		DWORD			keyColorIndex;

		Profile		*profile;
		
		BOOL			alwaysOverlay;
		BOOL			overlayPossible, forceOverlay;
		
		WORD			screenWidth, screenHeight;

		DDSURFACEDESC	desc;
#endif
		HWND			win;
		HHOOK 		hook;
		HINSTANCE	hinst;
#endif
	
	   int			dstLeft, dstTop, dstWidth, dstHeight;	   
	   BOOL		 	pipEnabled;           
	   BOOL			adaptClientSize;
		BOOL			screenDest;
		BOOL			destAspectRatio;
					   
		BOOL			changed;
		
		BOOL			offscreenOverride;
		FPTR			offscreenBase;
		DWORD			offscreenPhysicalBase;
		WORD			offscreenBPR;
		PIPFormat	offscreenFormat;
	
		// DMA sizes are the destination sizes aligned to what the DMA needs (e.g. dmaLeft <= dstLeft).
		int			dmaLeft, dmaTop, dmaWidth, dmaHeight;
		int			dispLeft, dispTop, dispWidth, dispHeight;
				
		virtual Error StartDMA(void) = 0;
		virtual Error StopDMA(void) = 0;
        
		Error DrawBlack(void) 
			{
#if !NT_KERNEL && !VXD_VERSION
			GNRAISE(DDColorkeyManager::DrawBlack(win));
#else
			GNRAISE_OK;
#endif
			}
        
		// Functions to build a clip mask.
	   virtual Error BuildDMARegion (void);
		virtual Error InitDMARegion(int left, int top, int width, int height) = 0;
		virtual Error AddDMAClipRect(int left, int top, int width, int height) = 0;	// make rect invisible
		virtual Error RemDMAClipRect(int left, int top, int width, int height) = 0;	// make rect visible
		virtual Error CompleteDMARegion(void) = 0;
#if NT_KERNEL || VXD_VERSION
	public:
		virtual Error SetOffscreenDMARegion (DWORD physical, DWORD stride, PIPFormat format,
		                                     int left, int top, int width, int height)
			{GNRAISE(GNR_UNIMPLEMENTED);}
		virtual Error SetOffscreenDMA (DWORD physical);
		virtual Error CheckForOverlay (WORD targetWidth, WORD targetHeight, WORD &maxDMAWidth, WORD &maxDMAHeight);
#else
		virtual Error SetOffscreenDMARegion(DWORD physical, DWORD stride, PIPFormat format,
		                                    int left, int top, int width, int height)
			{GNRAISE(GNR_UNIMPLEMENTED);}
#endif

	protected:

#if VIONA_VERSION
		virtual int MaxOverlayDestWidth(void) {return MaxDestWidth();}
		virtual int MaxInlayDestWidth(void) {return MaxDestWidth();}

#if !NT_KERNEL && ! VXD_VERSION
		DWORD ConvertKeyColor(DWORD colorRGB, LPDDSURFACEDESC desc);
		DWORD ConvertKeyIndex(DWORD __far & colorIndex);
#endif

#endif		
		virtual int MaxDestWidth(void) = 0;
		virtual int MaxDestHeight(void) = 0;

		virtual int HorizontalPixelsPerMaskBit (void) = 0;
		virtual int VerticalPixelsPerMaskBit (void) = 0;

#if NT_KERNEL || VXD_VERSION
		Error SetWinDesc(WinDesc * wd);
#else
		Error SetWindow(HWND win);
#endif
		Error SetScreenDest(BOOL screenDest);
		Error SetDestRect(int left, int top, int width, int height);
		Error SetAdaptClientSize(BOOL adaptClientSize);

		int GetDisplayLeft(void);
		int GetDisplayTop(void);
		int GetDisplayWidth(void);
		int GetDisplayHeight(void);

#if VIONA_VERSION
#if !NT_KERNEL && ! VXD_VERSION
		Error GetColorkeyed(BOOL __far & keyed);
		Error SetColorkeyColor(DWORD color);
		Error SetColorkeyIndex(DWORD index);
		Error SetAlwaysOverlay(BOOL alwaysOverlay);
#endif
#endif

		Error SetOffscreenOverride(BOOL offscreen);
		Error SetOffscreenBase(FPTR base);
		Error SetOffscreenBytesPerRow(WORD bpr);
		Error SetOffscreenPixelFormat(PIPFormat format);
		
		Error EnablePIP(BOOL enable);
		
		virtual Error Update(void);
		
		Error UpdateDisplay(void);

		int	numVirtualUnits;
		
		Error NotifyUnitCreate(void);
		Error NotifyUnitDelete(void);
	public:

#if NT_KERNEL || VXD_VERSION
		DMAPIP(void);
#else
#if VIONA_VERSION
		DMAPIP(HINSTANCE	hinst, Profile * profile = NULL);
#else
		DMAPIP(HINSTANCE	hinst);
#endif
#endif
		~DMAPIP(void);

		Error	Initialize(void);
		Error ReInitialize(void);

#if !NT_KERNEL	&& !VXD_VERSION

#if VIONA_VERSION
		virtual Error Reconfigure(void);
		virtual BOOL ScreenModeChanged(void);
#endif

		friend int AffectsMask(HookData __far * hd);
		friend DWORD FAR PASCAL SizeHookProc(WORD code, WPARAM wParam, LPARAM lParam);
		friend void DMARegionChanged();

		int   	maskMsgReceived;
#endif
	};



#if NT_KERNEL || VXD_VERSION

class VirtualDMAPIP : public VirtualPIP
	{
	private:
		DMAPIP	*	unit;
	public:
		VirtualDMAPIP(DMAPIP * physical) : VirtualPIP(physical) {unit = physical; unit->NotifyUnitCreate();}
		~VirtualDMAPIP(void) {unit->NotifyUnitDelete();}

		Error Configure (TAG __far *tags);

		virtual Error GetDMASizes (int &dmaLeft, int &dmaTop, int &dmaWidth, int &dmaHeight)
			{
			dmaLeft   = unit->dmaLeft;
			dmaTop    = unit->dmaTop;
			dmaWidth  = unit->dmaWidth;
			dmaHeight = unit->dmaHeight;
			GNRAISE_OK;
			}
	};

#else

class VirtualDMAPIP : public VirtualPIP, public WinPort {
	private:
		DMAPIP	*	unit;

	   void Message(WPARAM wParam, LPARAM dParam);
	public:
		VirtualDMAPIP(DMAPIP * physical) : VirtualPIP(physical), WinPort(physical->hinst) {unit = physical; unit->NotifyUnitCreate();}		
		~VirtualDMAPIP(void) {unit->NotifyUnitDelete();}

		Error Configure (TAG __far *tags);
	};

#endif



class MaskDMAPIP : public DMAPIP {
	friend class VirtualMaskDMAPIP;
	private:
		RectBitMap	*	dmaMap;		
	protected:               
		virtual Error SetMask(RectBitMap * map) = 0;
		
		virtual int HorizontalAlign(void) {return 1;}
		virtual int VerticalAlign(void) {return 1;}
		
		virtual int HorizontalPixelsPerMaskBit(void) {return 1;}
		virtual int VerticalPixelsPerMaskBit(void) {return 1;}

		virtual RectBitMap* CreateDMAMap(int left, int top, int width, int height)
			{return new RectBitMap(left, top, width, height);}									// Default is a non-inverse bitmap!
				
		Error InitDMARegion(int left, int top, int width, int height);
		Error AddDMAClipRect(int left, int top, int width, int height);
		Error RemDMAClipRect(int left, int top, int width, int height);
		Error CompleteDMARegion(void);
		
	public:
#if NT_KERNEL || VXD_VERSION
		MaskDMAPIP(void) : DMAPIP() {dmaMap = NULL; dmaLeft = 0; dmaTop = 0; dmaHeight = 0; dmaWidth = 0;}
#else
#if VIONA_VERSION
		MaskDMAPIP(HINSTANCE hinst, Profile * profile) : DMAPIP(hinst, profile) {dmaMap = NULL; hook = NULL; dmaLeft = 0; dmaTop = 0; dmaHeight = 0; dmaWidth = 0;}
#else
		MaskDMAPIP(HINSTANCE hinst) : DMAPIP(hinst) {dmaMap = NULL; hook = NULL; dmaLeft = 0; dmaTop = 0; dmaHeight = 0; dmaWidth = 0;}
#endif
#endif
		~MaskDMAPIP(void);
	};
	
class VirtualMaskDMAPIP : public VirtualDMAPIP {
	public:
		VirtualMaskDMAPIP(MaskDMAPIP * physical) : VirtualDMAPIP(physical) {}		
	};
	
#endif // ONLY_EXTERNAL_VISIBLE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\video\specific\vidde848.h ===
// FILE:		   library\hardware\video\specific\vidde848.h
// AUTHOR:		P.C.Straasheijm
// COPYRIGHT:	(c) 1995 Viona Development.  All Rights Reserved.
// CREATED:		10.10.96
//
// PURPOSE: 	Class for BT848 video decoder.
//
// HISTORY:

#ifndef VIDDE848_H
#define VIDDE848_H

#include "library\common\gnerrors.h"         
#include "library\hardware\video\generic\viddec.h" 
#include "library\hardware\video\generic\vidtypes.h"
#include "library\common\hooks.h"

#ifndef ONLY_EXTERNAL_VISIBLE
#include "library\hardware\pcibrdge\specific\bt848\bt848reg.h"
#endif

MKHOOK (DecVBlank, WORD)
MKTAG (DEC_CLOSEDCAPTION, VIDEO_DECODER_UNIT, 0x3000, DecVBlankHook*)

#ifndef ONLY_EXTERNAL_VISIBLE

#include "library\lowlevel\intrctrl.h"
#include "library\lowlevel\hardwrio.h"
#include "library\lowlevel\memmpdio.h"

class VirtualVideoDecoder848;   // forward declaration

class VideoDecoder848 : public VideoDecoder
	{
	friend class VirtualVideoDecoder848;
	friend class VideoDecoder848VBlankIntHandler;
	friend class BT848SignalPort;
	
	private:
		
		//
		// Current image settings in internal format
		//
		BYTE				brightness;
		WORD				contrast;
		WORD				saturation;
		BYTE				hue;
		BOOL				teletext;
		BOOL				autoselect;
      
		MemoryMappedIO		*	io;
		
//		DecVBlankHookHandle		closedHookHandle;
		InterruptServer						*vBlankIntServer;
		VideoDecoder848VBlankIntHandler	*vBlankIntHandler;
//		BOOL					closedCaptionRunning;
      //
		// Current input, standard, mode etc.
		//
		WORD					input;
		VideoStandard		standard;
		VideoMode			mode;
		BOOL					extSync;
      BOOL					autoformat;
		//
		// Flags, which part of the programming have been changed
		//		
		DWORD				changed;

		void VBlankInterrupt(void);
		//
		// Parameter setting functions		
		//                                   +#
		
		Error SetVideoStandard(VideoStandard std);
		Error SetMode(VideoMode mode);
		Error SetExtSync(BOOL extsync);
		Error SetInput(WORD input);
		Error SetBrightness(WORD brightness);
		Error SetContrast(WORD contrast);
		Error SetSaturation(WORD saturation);
		Error SetHue(WORD hue);         
		Error SetSampleMode(VideoSampleMode mode);
//		Error SetTeletextMode(BOOL mode);
		Error SetClosedCaptionHook(DecVBlankHook* closedHook);
		
		//
		// Checks changes in setting, and triggers changes in registers
		//
		Error ProcessChanges(void);

		//
		// Reprogram chip values
		//		
		Error ProgramAll(void);		
		Error ProgramInput(void);
		Error ProgramBrightness(void);
		Error ProgramContrast(void);
		Error ProgramSaturation(void);
		Error ProgramHue(void);
		Error ProgramClosedCaption(void);
      Error CheckInputSignal(BOOL __far & signal);
		//
		// Set mode and standard
		//
		Error Set_NTSC_TestPattern (void);
		Error Set_PAL_TestPattern (void);
		Error Set_NTSC_Capture (void);
		Error Set_PAL_Capture (void);
		Error Set_SECAM_Capture (void);
		Error Set_NTSC_Playback (void);
		Error Set_PAL_Playback (void);
		Error Set_NTSC_Playback_Ext (void);
		Error Set_PAL_Playback_Ext (void);
		Error Set_RESET (void);

//		Error StartClosedCaption();
//		Error StopClosedCaption();
		//
		// Check the current video standard
		//		
		Error DetectVideoStandard(VideoStandard __far &std);

	public:
		VideoDecoder848 (MemoryMappedIO *io, InterruptServer * vBlankIntServer = NULL, VirtualUnit * videoBus = NULL);
		~VideoDecoder848 (void);

		VirtualUnit 		* 	CreateVirtual(void);

	};



class VirtualVideoDecoder848 : public VirtualVideoDecoder
	{      
	protected:
		BOOL						teletext;
		DecVBlankHook		*	closedHookPtr;
	private:
		VideoDecoder848	*	videodecoder;
	public:
		VirtualVideoDecoder848 (VideoDecoder848 *physical);

		Error Configure (TAG __far *tags);

	protected:
		Error Preempt (VirtualUnit *previous);
	};


#endif	// of #define ONLY_EXTERNAL_VISIBLE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\videodma\generic\colctrlr.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// FILE:      library\hardware\videodma\generic\colctrlr.h
// AUTHOR:    S. Herr
// COPYRIGHT: (c) 1998 VIONA Development GmbH. All Rights Reserved.
// CREATED:   05.06.1998
//
// PURPOSE:   Abstract Color Controller class
//
// HISTORY:

#ifndef COLCTRLR_H
#define COLCTRLR_H

#include "library/common/prelude.h"

#define PCCF_BRIGHTNESS					0x00000001l
#define PCCF_CONTRAST					0x00000002l
#define PCCF_HUE							0x00000004l
#define PCCF_SATURATION					0x00000008l
#define PCCF_SHARPNESS					0x00000010l
#define PCCF_GAMMA						0x00000020l
#define PCCF_RED_BRIGHTNESS			0x00001000l
#define PCCF_BLUE_BRIGHTNESS			0x00002000l
#define PCCF_GREEN_BRIGHTNESS			0x00004000l

#ifndef ONLY_EXTERNAL_VISIBLE

struct ColorControlValues
	{
	WORD ccBrightness;
	WORD ccContrast;
	WORD ccSaturation;
	WORD ccHue;
	WORD ccGamma;
	WORD ccSharpness;
	BOOL ccColorEnable;
	WORD ccRedBrightness;
	WORD ccGreenBrightness;
	WORD ccBlueBrightness;
	};

class ColorController
	{
	public:
		virtual WORD  GetColorControl() = 0;
		virtual Error SetColorControlValues(ColorControlValues __far & clrCtrl) = 0;
	};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\videodma\generic\GFXCONFG.H ===
//
// FILE:      library\hardware\videodma\generic\gfxconfg.h
// AUTHOR:    U. Sigmund, S. Herr
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   22.03.95
//
// PURPOSE:   Configuration class for graphic board format etc.
//
// HISTORY:
//
// Date			Author	Comment
// --------		------	-------
//	28.07.95		SH			addition of QueryGraphicConfig()

#ifndef GFXCONFG_H
#define GFXCONFG_H

#include <windows.h> 
#include <windowsx.h>
#include <mmsystem.h>
#include <msvideo.h>
#include <msviddrv.h>
#include <mmreg.h>
#include "dciddi.h"	// Use C++ corrected version!
#include <dciman.h>

#include "..\..\..\common\prelude.h"
#include "..\..\..\common\gnerrors.h"
#include "..\..\..\lowlevel\pci.h"
#include "..\..\video\generic\vidtypes.h"
#include "..\..\..\common\profiles.h"

#if VIONA_VERSION
#include "..\..\..\support\VDSup32\vdsup32.h"
#endif

#define TESTAREASIZE 0x800000		// 8 MB test area size!


enum OffsetFormat {OF_INVALID,
						 OF_DCI,
						 OF_PCI,
						 OF_VESA,
						 OF_DIRECTDRAW };

class GraphicConfig {
	protected:
		Profile		 * profile;				// Object reference for INI file configuration.
		
		struct DMADescriptor {					// Needed for access to virtual DMA services.
			DWORD			regionSize;
			DWORD			offset;
			WORD			selector;
			WORD			bufferID;
			DWORD			physical;
			} dds;
			
		HINSTANCE		instanceHandle;		// Instance handle of using DLL or application
		HWND				parentWindow;			// Handle of parent window for dialog boxes.
		
		PCIBus* 			mainBus;					// PCI bus object.
                                   	
		PCIDevice*		gfxBoard;				// Graphics board for which we examine the properties.

		DWORD				baseAddress;			// Necessary to store the physical base address for dialogs.
		DWORD				presetBaseAddress;
		DWORD				startOffset;			// Stores offset from the PCI or other physical start address
														// of frame buffer. May contain 0.
		OffsetFormat	offsetFormat;

		HBRUSH 			hbrGrey;

#if VIONA_VERSION
		DDSURFACEDESC	sfcDescr;
		BOOL				ddSuccess;
#endif		
		char				messageTitle[32];

		BOOL				retest;					// Flag for "Run compatibility test again".

		Error FindStartLocation(BOOL offsetAvailable);		// Tries to find the address of the framebuffer's first byte
		Error DetermineGfxBoard(List* gfxBoardList, PCIDevice* device);	// Determines, which board to take if there
																								// are more than one in the computer.
		Error DetermineOffsetViaGDI(DWORD physicalBase, DWORD __far & offset);	// Uses direct access to frame buffer to find
																								// offset to physical start address.
		BOOL MaskedPatternSearch(WORD _huge* destination,						// Pattern search routine with masked pattern
										  WORD * pattern,									// values.
										  WORD * mask,
										  DWORD startPos, DWORD bufferSize,
										  DWORD __far & endposition);
		Error FindStride(WORD _huge* destination,									// Used to determine stride by searching the
							 WORD * pattern,												// pattern in the next scan line after the
							 WORD * mask,													// pattern's first occurrence.
							 WORD bitsPerPixel,
							 DWORD position, WORD __far & stride);
      Error MakeWindow(POINT __far & point, HWND __far & window);							// Create test window for pattern search.
      Error ThrowAwayWindow(HWND __far & window);										// Delete test window.
		void  ProcessMessages();														// Processes test window messages.
		Error CheckAddressValidity(DWORD address,
											WORD* pattern,
											WORD* mask, BOOL& valid);
		BOOL 	DrawTest(void);
      Error	DrawWhiteAndBlackBoxes(void);											// Draws directly into the frame buffer mem.

		BOOL	RetrieveAndCompareProperties(void);									// Reads current properties from INI file and
																								// checks if they are still valid
		void	StoreProperties(void);

	public:
//		enum PixelFormat {RGB_888, RGB_888x, RGB_555, RGB_565, OTHER};
		
		BOOL				overlayPossible;		// Indicates, if overlay possible in current video mode.
		BOOL				flatModelPossible;	// Tells, if video mode/graphics card allows flat model.

      HDC					dciProvider;		// Device context of DCI Provider
		LPDCISURFACEINFO	surfaceInfo;		// Structure with information about primary display surface

		BOOL				buffWriteOnly;			// Indicates if buffer may be read or not

		WORD				xSize;					// Number of pixels per scan line
		WORD				ySize;					// Number of lines of display
		
		PIPFormat		pixelFormat;			// Arrangement of pixels in frame buffer memory
		WORD				bitsPerPixel;
		WORD				bytesPerPixel;
		WORD				bytesPerRow;

		DWORD				startLocation;			// Physical 32 bit address of frame buffer start. Contains 0 if
														// DMA access is not possible.
		DWORD				buffSize;				// Size of memory for frame buffer (in bytes)

		WORD				deviceID;				// Device ID of graphics board
		WORD				vendorID;				// Vendor ID of graphics board

      GraphicConfig(HINSTANCE instance, Profile* profile);	// Needs DLL or program instance handle
      ~GraphicConfig(void);
      
		Error	QueryGraphicConfig(void);		// Get metrics and physical address of current windows screen.
      Error Check15Or16(WORD __far & bistPerPixel);	// Determine true bit depth for 15/16 bit.
	
		int	ProcessDlgMessage(HWND hwnd, WPARAM message, WPARAM wParam, LONG lParam);
	};

#define GNR_NO_PCI_GFX_BOARD		MKERR(ERROR, GFC, GENERAL,	0x01)
#define GNR_PATTERN_NOT_FOUND		MKERR(ERROR, GFC, GENERAL, 0x02)
#define GNR_NO_TESTWINDOW			MKERR(ERROR, GFC, GENERAL, 0x03)
#define GNR_STRIDE_NOT_FOUND		MKERR(ERROR, GFC, GENERAL, 0x04)
#define GNR_MODE_NOT_SUITABLE		MKERR(ERROR, GFC, GENERAL, 0x05)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\videodma\generic\krnvppip.h ===
// FILE:      library\hardware\videodma\generic\krnvppip.h
// AUTHOR:    S. Herr
// COPYRIGHT: (c) 1997 Viona Development GmbH. All Rights Reserved.
// CREATED:   05.11.1997
//
// PURPOSE:   Kernel Mode Video Port PIP class
//
// HISTORY:

#ifndef KRNVPPIP_H
#define KRNVPPIP_H

#include "library\common\prelude.h"
#include "library\common\hooks.h"
#include "pip.h"
#include "library\hardware\video\generic\videvice.h"


//
//	Definition of tags
// 

// Defined VP events

#define VP_EVENT_ACTIVATE_PORT				MKFLAG(0)
#define VP_EVENT_PASSIVATE_PORT				MKFLAG(1)
#define VP_EVENT_CHANGED_PORT_PARAMS		MKFLAG(2)
#define VP_EVENT_CHANGED_STILL_SEQUENCE	MKFLAG(3)
#define VP_EVENT_CHANGED_CONTENT_TYPE		MKFLAG(4)

struct VPEventMsg
	{
	DWORD		vpEvent;
	DWORD		data0, data1, data2, data3;
	DWORD		signalEvent;
	};
	
MKHOOK(VPEvent, VPEventMsg);

MKTAG (PIP_VP_EVENT_HOOK,		PIP_UNIT, 0x0060, VPEventHook *)

// See vidtypes.h for an explanation of types
MKTAG (PIP_VP_AVAIL_PROTOCOLS,		PIP_UNIT, 0x0061, DWORD)
MKTAG (PIP_VP_PROTOCOL,					PIP_UNIT, 0x0062, DWORD)
MKTAG (PIP_VP_AVAIL_CONNFEATURES,	PIP_UNIT, 0x0063, DWORD)
MKTAG (PIP_VP_CONNFEATURES,			PIP_UNIT, 0x0064, DWORD)

#define UMDLL_VERSION_1		0
#define UMDLL_VERSION_2		1

MKTAG	(PIP_VP_USERMODEDLL_VERSION,	PIP_UNIT, 0x0065, DWORD)

#ifndef ONLY_EXTERNAL_VISIBLE

class KernelVideoPortPIP : public PIP
	{
	friend class VirtualKernelVideoPortPIP;

	protected:
		KEVENT	signalEvent;

		BOOL	changed;

		BOOL	userDLLVersion;

		BOOL	pipEnabled;
		BOOL	transferRunning;

		BOOL	adaptSourceSize;
		BOOL	adaptClientSize;
		
		int	srcLeft, srcTop;												// Source rectangle dimensions
		WORD  srcWidth, srcHeight;
	   int	dstLeft, dstTop, dstWidth, dstHeight;					// Destination rectangle dimensions

		int	srcCropLeft, srcCropTop, srcCropRight, srcCropBottom;

		VideoSampleMode			sampleMode;
		VideoStandard				curVideoStd;

		int							hOffset, vOffset;
		WORD							activeLeft, activeTop, activeWidth, activeHeight;	// Active (i.e. usable) part of input field
		int							hTrigger;
		BIT							hsyncPol, vsyncPol;
		VideoFieldIndication		fieldIndication;
		BOOL							pixelClockEdge;
		BOOL							stillSequence;
		DWORD							contentType;

		const HardVideoParams *	curVideoParams;

		VPEventHookHandle			vpEventHook;

		ColorControlValues		clrCtrl;

		DWORD	availConnFeatures;
		DWORD availProtocols;

		DWORD	connFeatures;
		DWORD	protocol;

		BOOL	vpAlwaysEnabled;

		ColorController * colorController;

		Error SetVideoStandard(VideoStandard std);
		Error SetSampleMode(VideoSampleMode mode);

		Error SetHOffset(int offset);
		Error SetVOffset(int offset);

		Error SetAdaptClientSize(BOOL adaptClientSize);
		Error SetAdaptSourceSize(BOOL adaptSourceSize);

		Error SetSourceRect(int left, int top, int width, int height);
		Error SetDestRect(int left, int top, int width, int height);

		int	GetDisplayLeft(void) {return (int) dstLeft;}
		int	GetDisplayTop(void)  {return (int) dstTop;}
		int	GetDisplayWidth(void) {return (int) dstWidth;}
		int	GetDisplayHeight(void) {return (int) dstHeight;}
		
		Error EnablePIP(BOOL enable);

		Error VirtuallyEnablePIP(BOOL enable);
		Error VideoStreamOn();
		Error VideoStreamOff();

		Error Update(void);
		Error UpdateDisplay(void);

		Error GrabFrame(FPTR base, WORD width, WORD height, 
		                WORD stride, GrabFormat fmt) {GNRAISE_OK;}
		
		Error SetScreenDest(BOOL screenDest) {GNRAISE_OK;}

		Error SetWinDesc(WinDesc * wd) {GNRAISE_OK;}

		Error SetOffscreenOverride(BOOL offscreen)			{GNRAISE_OK;}
		Error SetOffscreenBase(FPTR base)						{GNRAISE_OK;}
		Error SetOffscreenBytesPerRow(WORD bpr)				{GNRAISE_OK;}
		Error SetOffscreenPixelFormat(PIPFormat format)		{GNRAISE_OK;}

		Error SetSourceCrop(int left, int top, int right, int bottom);

		Error StartGrabYStream (YStreamCaptureHookHandle hook, int left, int top, WORD width, WORD height) {GNRAISE_OK;}
		Error StopGrabYStream (void) {GNRAISE_OK;}

		Error NotifyUnitCreate(void);
		Error NotifyUnitDelete(void);

		virtual Error StartVideoDisplay(void) = 0;
		virtual Error StopVideoDisplay(void) = 0;

		virtual DWORD GetAvailableProtocols() {return availProtocols;}
		virtual DWORD GetAvailableConnFeatures() {return availConnFeatures;}

		virtual Error SetUserDLLVersion(DWORD userDLLVersion) {this->userDLLVersion = userDLLVersion; GNRAISE_OK;}

		virtual Error SetProtocol(DWORD protocol);
		virtual Error SetConnFeatures(DWORD connFeatures);

		virtual Error SetVPEventHook(VPEventHookHandle vpEventHook) {this->vpEventHook = vpEventHook; changed = TRUE; GNRAISE_OK;}

		virtual WORD  GetColorControl();
		virtual Error SetColorControlValues(ColorControlValues __far & clrCtrl);

		virtual Error StillSequenceChanged(void);
		virtual Error ContentTypeChanged(void);
	public:
		KernelVideoPortPIP(BOOL vpAlwaysEnabled,
								 DWORD availConnFeatures,
								 DWORD availProtocols,
								 ColorController * colorController = NULL);

		~KernelVideoPortPIP();
		VirtualUnit * CreateVirtual(void);

		Error Configure(TAG __far * tags);

		virtual Error Reconfigure(void) {GNRAISE_OK;}

		Error ReInitialize(void);

		HardVideoParams 			ntscSQP, palSQP, ntscCCIR, palCCIR;
	};


	
class VirtualKernelVideoPortPIP : public VirtualPIP
	{
	friend class KernelVideoPortPIP;
	
	private:
		KernelVideoPortPIP	*	unit;

		BOOL	userDLLVersion;
		
		DWORD protocol;
		DWORD connFeatures;

		ColorControlValues clrCtrl;

	public:
		VPEventHookHandle vpEventHook;
		KEVENT activateDoneEvent;

		VirtualKernelVideoPortPIP(KernelVideoPortPIP	* unit);
		~VirtualKernelVideoPortPIP(void) {unit->NotifyUnitDelete();}

		Error Configure(TAG __far * tags);

      Error PreemptStopPrevious(VirtualUnit * previous);
      Error PreemptChange(VirtualUnit * previous);
      Error PreemptStartNew(VirtualUnit * previous);

		Error GetDMASizes (int &dmaLeft, int &dmaTop, int &dmaWidth, int &dmaHeight) {GNRAISE_OK;}

		Error PassivateDone();
	};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\videodma\generic\RECTMAP.H ===
//
// FILE:      library\hardware\videodma\generic\rectmap.h
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   21.03.95
//
// PURPOSE:   Single plane bitmap operations, for video masks
//
// HISTORY:

#ifndef RECTMAP_H
#define RECTMAP_H

#include	"..\..\..\common\prelude.h"



// RectBitMap lines are aligned to DWORD boundary. The bit layout is
// selectable via enum BitLayout:
//
// BITLAYOUT_FIRST_BIT0         BITLAYOUT_FIRST_BIT7
//
// Byte   Bit   Pixel#          Byte   Bit   Pixel#
//   0     0     0                0     0     7
//   0     1     1                0     1     6
//   0     2     2                0     2     5
//   0     3     3                0     3     4
//   0     4     4                0     4     3
//   0     5     5                0     5     2
//   0     6     6                0     6     1
//   0     7     7                0     7     0
//   1     0     8                1     0    15
//   1     1     9                1     1    14
//   1     2    10                1     2    13
//   1     3    11                1     3    12
//   1     4    12                1     4    11
//   1     5    13                1     5    10
//   1     6    14                1     6     9
//   1     7    15                1     7     8
//   2     0    16                2     0    23
// etc.

class RectBitMap
	{
	protected:
		DWORD *leftMaskPtr, *rightMaskPtr;

	public:
		DWORD __far * data;
		int 	width, height;
		int 	left, top;  
		int 	dwpr;			// DWORDs per row

		enum BitLayout
			{
			BITLAYOUT_FIRST_BIT0, BITLAYOUT_FIRST_BIT7
			};

		BitLayout bitLayout;

		//
		// Create with size and offset. Prefill with bit pattern.
		//
		RectBitMap(int x, int y, int w, int h, DWORD fillBrush=0L, BitLayout layout=BITLAYOUT_FIRST_BIT0);
		~RectBitMap(void);
		
		//
		// Add a rectangle to the bitmap, i.e. set the bits to one.
		//
		virtual void AddRect(int x, int y, int w, int h);
		
		//
		// Remove a rectangle from the bitmap, i.e. set the bits to zero.
		//
		virtual void RemRect(int x, int y, int w, int h);
		
		//
		// Compare two bitmaps.
		//
		BOOL Equal(RectBitMap * m);
	};



// This is the same as above, except that it draws inverse.

class InverseRectBitMap : public RectBitMap
	{
	public:
		InverseRectBitMap (int x, int y, int w, int h, BitLayout layout=BITLAYOUT_FIRST_BIT0)
			: RectBitMap (x, y, w, h, 0xffffffff, layout)
			{}

		void AddRect(int x, int y, int w, int h) {RectBitMap::RemRect(x, y, w, h);}
		void RemRect(int x, int y, int w, int h) {RectBitMap::AddRect(x, y, w, h);}
	};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\videodma\specific\clcvppip.h ===
// FILE:      library\hardware\videodma\generic\clcvppip.h
// AUTHOR:    S. Herr
// COPYRIGHT: (c) 1998 Viona Development GmbH. All Rights Reserved.
// CREATED:   08.04.1998
//
// PURPOSE:   Cinemaster C LC specific Kernel Mode Video Port PIP class
//
// HISTORY:

#ifndef CLCVPPIP_H
#define CLCVPPIP_H

#include "..\generic\krnvppip.h"
#include "library\lowlevel\hardwrio.h"

class CinemasterCLCKernelVideoPortPIP : public KernelVideoPortPIP
	{
	private:
		ByteIndexedInOutPort	*	hostPort;
		ByteIndexedInOutPort	*	configPort;

	protected:
		Error StartVideoDisplay(void);
		Error StopVideoDisplay(void);

	public:
		CinemasterCLCKernelVideoPortPIP(	BOOL							vpAlwaysEnabled,
													DWORD							availConnFeatures,
													DWORD							availProtocols,
													ByteIndexedInOutPort	*	hostPort,
													ByteIndexedInOutPort	*	configPort,
													ColorController * colorController = NULL);

		~CinemasterCLCKernelVideoPortPIP(void);

		virtual Error Initialize(void);

		Error	ReInitialize(void);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\videodma\specific\cm2vppip.h ===
// FILE:      library\hardware\videodma\generic\cm2vppip.h
// AUTHOR:    S. Herr
// COPYRIGHT: (c) 1997 Viona Development GmbH. All Rights Reserved.
// CREATED:   05.11.1997
//
// PURPOSE:   Cinemaster 2 specific Kernel Mode Video Port PIP class
//
// HISTORY:

#ifndef CM2VPPIP_H
#define CM2VPPIP_H

#include "..\generic\krnvppip.h"
#include "library\lowlevel\hardwrio.h"

class Cinemaster2KernelVideoPortPIP : public KernelVideoPortPIP
	{
	private:
		 BitOutputPort				*vbmsel0Port;
		 BitOutputPort				*vbmsel1Port;
		 BitIndexedOutputPort	*vidSyncPolPort;
		 BitIndexedOutputPort	*horizSyncPort;
		 BitOutputPort				*vpTimingPort;

	protected:
		Error StartVideoDisplay(void);
		Error StopVideoDisplay(void);

	public:
		Cinemaster2KernelVideoPortPIP(BOOL							vpAlwaysEnabled,
												DWORD							availConnFeatures,
												DWORD							availProtocols,
												BitOutputPort				*vbmsel0Port,
												BitOutputPort				*vbmsel1Port,
												BitIndexedOutputPort		*vidSyncPolPort,
												BitIndexedOutputPort		*horizSyncPort,
												BitOutputPort				*vpTimingPort);

		~Cinemaster2KernelVideoPortPIP();

		virtual Error Initialize();
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\videodma\generic\PIP.H ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


// FILE:      library\hardware\videodma\generic\pip.h
// AUTHOR:    Ulrich Sigmund, S. Herr
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   08.04.95
//
// PURPOSE: The PIP-related classes.
//
// HISTORY:

#ifndef PIP_H
#define PIP_H

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"
#include "library\common\tags.h"
#include "library\common\tagunits.h"
#include "library\common\hooks.h"
#include "library\hardware\video\generic\vidtypes.h"

#ifndef ONLY_EXTERNAL_VISIBLE
#include "library\common\virtunit.h"
#include "library\general\queues.h"
#include "library\lowlevel\kernlmem.h"
#endif

MKTAG(PIP_VIDEOSTANDARD,	PIP_UNIT,	0x00000001, VideoStandard)
#if !NT_KERNEL && !VXD_VERSION
MKTAG(PIP_WINDOW,				PIP_UNIT,	0x00000002, HWND)
#endif

	//
	// Source region, relative to active display
	//
MKTAG(PIP_SOURCE_LEFT,		PIP_UNIT,	0x00000003, int)
MKTAG(PIP_SOURCE_TOP,		PIP_UNIT,	0x00000004, int)
MKTAG(PIP_SOURCE_WIDTH,		PIP_UNIT,   0x00000005, int)
MKTAG(PIP_SOURCE_HEIGHT,	PIP_UNIT,   0x00000006, int)

	//
	// Destination region, relative to current window
	//
MKTAG(PIP_DEST_LEFT,			PIP_UNIT,	0x00000007, int)
MKTAG(PIP_DEST_TOP,			PIP_UNIT,	0x00000008, int)
MKTAG(PIP_DEST_WIDTH,		PIP_UNIT,   0x00000009, int)
MKTAG(PIP_DEST_HEIGHT,		PIP_UNIT,   0x0000000A, int)

MKTAG(PIP_ADAPT_CLIENT_SIZE, PIP_UNIT, 0x0000000B, BOOL)
MKTAG(PIP_ADAPT_SOURCE_SIZE, PIP_UNIT, 0x0000000C, BOOL)
MKTAG(PIP_SCREEN_DEST,     PIP_UNIT,   0x0000000D, BOOL)
MKTAG(PIP_SAMPLEMODE,		PIP_UNIT,	0x0000000E, VideoSampleMode)
MKTAG(PIP_HOFFSET,			PIP_UNIT,	0x0000000F, int)
MKTAG(PIP_VOFFSET,			PIP_UNIT,	0x00000010, int)
MKTAG(PIP_ALWAYS_OVERLAY,	PIP_UNIT,	0x00000011, BOOL)
MKTAG(PIP_COLORKEY_COLOR,	PIP_UNIT,	0x00000012, DWORD)
MKTAG(PIP_COLORKEYED,		PIP_UNIT,	0x00000013, BOOL)

	//
	// Display region, relative to the destination rectangle
	//
MKTAG(PIP_DISPLAY_LEFT,		PIP_UNIT,	0x00000014, short)
MKTAG(PIP_DISPLAY_TOP,		PIP_UNIT,	0x00000015, short)
MKTAG(PIP_DISPLAY_WIDTH,	PIP_UNIT,	0x00000016, short)
MKTAG(PIP_DISPLAY_HEIGHT,	PIP_UNIT,	0x00000017, short)

MKTAG(PIP_COLORKEY_INDEX,	PIP_UNIT,	0x00000018, DWORD)

// Make sure to set physical, bytesPerRow and pixelFormat at the same time when enabling this:
MKTAG (PIP_OFFSCREEN_OVERRIDE,		PIP_UNIT, 0x00000019, BOOL)
MKTAG (PIP_OFFSCREEN_BASE,				PIP_UNIT, 0x0000001a, void __far *)
MKTAG (PIP_OFFSCREEN_BASE_LINEAR,	PIP_UNIT, 0x0000001b, DWORD)		// Use a 32bit flat pointer
MKTAG (PIP_OFFSCREEN_BYTES_PER_ROW,	PIP_UNIT, 0x0000001c, WORD)
MKTAG (PIP_OFFSCREEN_PIXEL_FORMAT,	PIP_UNIT, 0x0000001d, PIPFormat)

struct FieldDisplayMsg
	{
	DWORD	fieldCnt;
	};

MKHOOK(FieldDisplay, FieldDisplayMsg);

MKTAG (PIP_FIELD_DISPLAY_HOOK,		PIP_UNIT, 0x0000001e, FieldDisplayHook *)

MKTAG (PIP_IS_POSSIBLE,					PIP_UNIT, 0x0000001f, BOOL)


#include "library\hardware\videodma\generic\colctrlr.h"

MKTAG (PIP_COLORCONTROL,				PIP_UNIT, 0x00000020, WORD)			// Get only tag to query color control support
MKTAG (PIP_BRIGHTNESS,					PIP_UNIT, 0x00000021, WORD)
MKTAG (PIP_CONTRAST,						PIP_UNIT, 0x00000022, WORD)
MKTAG (PIP_SATURATION,					PIP_UNIT, 0x00000023, WORD)
MKTAG (PIP_HUE,							PIP_UNIT, 0x00000024, WORD)
MKTAG (PIP_GAMMA,							PIP_UNIT, 0x00000025, WORD)			// Gamma correction
MKTAG (PIP_SHARPNESS,					PIP_UNIT, 0x00000026, WORD)
MKTAG (PIP_COLORENABLE,					PIP_UNIT, 0x00000027, BOOL)			// Used to toggle between B/W and color

// Use these to adjust brightness individually for R/G/B (only works with special VGAs)
MKTAG (PIP_RED_BRIGHTNESS,				PIP_UNIT, 0x00000028, WORD)
MKTAG (PIP_BLUE_BRIGHTNESS,			PIP_UNIT, 0x00000029, WORD)
MKTAG (PIP_GREEN_BRIGHTNESS,			PIP_UNIT, 0x0000002a, WORD)

// Used to crop the source rectangle when ADAPT_SOURCE_SIZE is TRUE
MKTAG (PIP_SOURCE_CROP_LEFT,			PIP_UNIT, 0x0000002b, WORD)
MKTAG (PIP_SOURCE_CROP_TOP,			PIP_UNIT, 0x0000002c, WORD)
MKTAG (PIP_SOURCE_CROP_RIGHT,			PIP_UNIT, 0x0000002d, WORD)
MKTAG (PIP_SOURCE_CROP_BOTTOM,		PIP_UNIT, 0x0000002e, WORD)



// Error definitions.
#define GNR_DMA_PIP_NOT_POSSIBLE			MKERR(ERROR, PIP, GENERAL, 0x01)		// Current screen mode does not allow DMA PIP
#define GNR_VIDEO_STD_NOT_SUPPORTED		MKERR(ERROR, PIP, GENERAL, 0x02)		// Desired video standard (e.g. SECAM) not supported.
#define GNR_PIP_NOT_RUNNING				MKERR(ERROR, PIP, GENERAL, 0x03)		// PIP is not running when trying to execute OptimizeBuffer()
#define GNR_NO_OPTIMAL_MINPIX				MKERR(ERROR, PIP, GENERAL, 0x04)		// No optimal minPix value could be found by OptimizeBuffer()
#define GNR_DEST_RECT_SIZE					MKERR(ERROR, PIP, GENERAL, 0x05)		// Destination rectangle too small or too big.
#define GNR_WRONG_GRAB_SIZE				MKERR(ERROR, PIP, GENERAL, 0x06)		// Dimensions of frame to grab are too big.
#define GNR_NO_VBLANK_IRQ					MKERR(ERROR, PIP, GENERAL, 0x07)		// An expected VBlank IRQ did not occur.
#define GNR_GRAB_TIMEOUT					MKERR(ERROR, PIP, GENERAL, 0x08)		// A timeout occurred during grabbing a frame.
#define GNR_WRONG_GRAB_FORMAT				MKERR(ERROR, PIP, GENERAL, 0x09)		// An unsupported capture format was requested
#define GNR_SAMPLEMODE_NOT_SUPPORTED	MKERR(ERROR, PIP, GENERAL, 0x0a)		// Desired video sample mode not supported
#define GNR_VP_ERROR							MKERR(ERROR, PIP, GENERAL, 0x0b)		// General error with Video Port
#define GNR_VP_NO_PORT_MATCH				MKERR(ERROR, PIP, GENERAL, 0x0c)		// Video source does not match Video Port
#define GNR_VP_HARDWARE_IN_USE			MKERR(ERROR, PIP, GENERAL, 0x0d)		// Video Port Hardware in use
#define GNR_VPM_ERROR						MKERR(ERROR, PIP, GENERAL, 0x0e)		// General error with VPM services
#define GNR_VPE_ERROR						MKERR(ERROR, PIP, GENERAL, 0x0f)		// General error with DirectX5/VPE services
#define GNR_NOT_ENOUGH_VIDEO_MEMORY		MKERR(ERROR, PIP, MEMORY,  0x10)
#define GNR_NO_OVERLAY_HARDWARE			MKERR(ERROR, PIP, GENERAL, 0x11)
#define GNR_OVERLAY_BUSY					MKERR(ERROR, PIP, BUSY,    0x12)
#define GNR_PRIMARY_NOT_AVAILABLE		MKERR(ERROR, PIP, BUSY,		0x13)



#if NT_KERNEL || VXD_VERSION || DRVDLL

struct WinDescRect
	{
	BOOL	include;
	RECT	pos;
	};

typedef struct WinDesc
	{
	RECT				frame;
	int				clips;
	WinDescRect	*	clip;
	} * WinDescPtr;

MKTAG(PIP_WINDOW_DESC,		PIP_UNIT,	0x00000102, WinDescPtr)

#endif



typedef struct StreamCaptureMsgStruct
	{
	FPTR bufferInfo;
	FPTR userData;
	DWORD captureTime;
	} StreamCaptureMsg;

MKHOOK(StreamCapture, StreamCaptureMsg);



typedef struct YStreamCaptureMsgStruct
	{
	FPTR bufferInfo;
	FPTR userData;
	WORD yCaptureCounter;
	} YStreamCaptureMsg;

MKHOOK(YStreamCapture, YStreamCaptureMsg);



#ifndef ONLY_EXTERNAL_VISIBLE



	class PrepInfoPIP : public LinkedQueueElement
		{
		// Extend this class to add more preparation info.
		public:
			KernelMemory kernelMem;
			FPTR bufferPtr;   // Kernel space
			FPTR userData;

			PrepInfoPIP (void) {}
			virtual ~PrepInfoPIP (void) {Unprepare ();}

			virtual Error Prepare (FPTR buffer, DWORD size);
			virtual Error Unprepare (void);

			FPTR KernelSpace (void) {return kernelMem.KernelSpace();}
		};



class PIP : public PhysicalUnit
	{
	friend class VirtualPIP;

	protected:
		BOOL pipIsPossible;

		virtual Error SetVideoStandard(VideoStandard std) = 0;
		virtual Error SetSampleMode(VideoSampleMode mode) = 0;
		virtual Error SetHOffset(int offset) = 0;
		virtual Error SetVOffset(int offset) = 0;
#if !NT_KERNEL && !VXD_VERSION
		virtual Error SetWindow(HWND win) = 0;
#endif
		virtual Error SetSourceRect(int left, int top, int width, int height) = 0;
		virtual Error SetDestRect(int left, int top, int width, int height) = 0;

		virtual int GetDisplayLeft(void) = 0;
		virtual int GetDisplayTop(void) = 0;
		virtual int GetDisplayWidth(void) = 0;
		virtual int GetDisplayHeight(void) = 0;

		virtual Error EnablePIP(BOOL enable) = 0;
#if WDM_VERSION
		virtual Error VirtuallyEnablePIP(BOOL enable) = 0;
		virtual Error VideoStreamOn() = 0;
		virtual Error VideoStreamOff() = 0;
#endif
		virtual Error GrabFrame(FPTR base, WORD width, WORD height,
		                        WORD stride, GrabFormat fmt) = 0;
		virtual Error SetAdaptClientSize(BOOL adaptClientSize) = 0;
		virtual Error SetAdaptSourceSize(BOOL adaptSourceSize) = 0;
		virtual Error SetScreenDest(BOOL screenDest) = 0;

#if NT_KERNEL || VXD_VERSION
		virtual Error SetWinDesc(WinDesc * wd) = 0;
#endif

#if !NT_KERNEL && !VXD_VERSION
		virtual Error SetColorkeyColor(DWORD color) {GNRAISE_OK;}
		virtual Error SetColorkeyIndex(DWORD index) {GNRAISE_OK;}
		virtual Error GetColorkeyed(BOOL __far & keyed) {keyed = FALSE; GNRAISE_OK;}
		virtual Error SetAlwaysOverlay(BOOL alwaysOverlay) {GNRAISE_OK;}
#endif
		virtual Error SetOffscreenOverride(BOOL offscreen) = 0;
		virtual Error SetOffscreenBase(FPTR base) = 0;
		virtual Error SetOffscreenBytesPerRow(WORD bpr) = 0;
		virtual Error SetOffscreenPixelFormat(PIPFormat format) = 0;
		virtual Error SetFieldDisplayHook(FieldDisplayHookHandle hook) {if (hook) GNRAISE(GNR_UNIMPLEMENTED); else GNRAISE_OK;}

		virtual Error SetSourceCrop(int left, int top, int right, int bottom) = 0;

		virtual Error Update(void);


		// Streaming capture mechanism.
		virtual Error InitGrabStream (StreamCaptureHookHandle hook, DWORD milliSecPerFrame,
		                              WORD width, WORD height, WORD stride, GrabFormat format);
		virtual Error FinishGrabStream (void);
		virtual Error PrepareGrabBuffer (FPTR buffer, DWORD size, FPTR __far &info);
		virtual Error UnprepareGrabBuffer (FPTR info);
		virtual Error AddStreamGrabBuffer (FPTR info, FPTR userData);
		virtual Error StartGrabStream (void);
		virtual Error StopGrabStream (void);
		virtual PrepInfoPIP *CreatePrepInfo (void);

		typedef struct CaptureParameters
			{
			StreamCaptureHookHandle hook;
			DWORD milliSecPerFrame;
			WORD width, height, stride;
			GrabFormat format;
			LinkedQueue capturePipe;
			int nBuffers;
			BOOL grabRunning;
			BOOL firstFrameIsHere;
			DWORD nextFrameNum;
			DWORD nextFrameTime;
			};
		CaptureParameters capture;


		// Y capture streaming.
		virtual Error StartGrabYStream (YStreamCaptureHookHandle hook, int left, int top, WORD width, WORD height) = 0;
		virtual Error StopGrabYStream (void) = 0;
		Error YDequeue (LinkedQueueElement __far * __far &element);


		virtual Error UpdateDisplay(void);
	public:
		PIP (void) {pipIsPossible = TRUE;}

		virtual Error Initialize(void);
		virtual Error ReInitialize(void) {GNRAISE_OK;}

		virtual Error SuspendDMA(void) {GNRAISE_OK;}
		virtual Error ResumeDMA(void) {GNRAISE_OK;}
	};



class VirtualPIP : public VirtualUnit
	{
	friend class PIP;

	protected:
		VideoStandard		standard;

#if NT_KERNEL || VXD_VERSION
		WinDesc			*	windesc;
#else
		HWND					window;
#endif

		int					sourceLeft, sourceTop, sourceWidth, sourceHeight;
		int					destLeft, destTop, destWidth, destHeight;
		WORD					sourceCropLeft, sourceCropTop, sourceCropRight, sourceCropBottom;
		BOOL					pipEnabled;
		BOOL					adaptClientSize;
		BOOL					adaptSourceSize;
		BOOL					screenDest;

#if !NT_KERNEL && !VXD_VERSION
		HANDLE				saveImage;
#else
		FPTR					saveImage;
#endif

		VideoSampleMode   sampleMode;
		int hOffset, vOffset;

		LinkedQueue yCapturePipe;
		YStreamCaptureHookHandle grabYHook;
		int 					grabYLeft;
		int 					grabYTop;
		WORD 					grabYWidth;
		WORD					grabYHeight;

		BOOL					alwaysOverlay;
		DWORD					keyColor;
		DWORD					keyIndex;

#if NT_KERNEL
		BOOL					virtualEnable;
#endif

		BOOL					offscreenOverride;
		FPTR					offscreenBase;
		WORD					offscreenBPR;
		PIPFormat			offscreenFormat;

		FieldDisplayHookHandle	fieldDisplayHook;

		virtual Error PreserveDisplay(void);
	private:
		PIP*				unit;
	public:
		VirtualPIP(PIP* physical);
		~VirtualPIP(void);

		Error Configure(TAG __far * tags);
		Error Preempt(VirtualUnit* previous);
		Error EnablePIP(BOOL enable);

#if NT_KERNEL
		Error VirtuallyEnablePIP(BOOL enable);
		Error VideoStreamOn();
		Error VideoStreamOff();
#endif

		Error GrabFrame(FPTR base, WORD width, WORD height,
		                WORD stride, GrabFormat fmt);

		Error AdaptClientSize(int destLeft, int destTop, int destWidth, int destHeight);
		Error AdaptSourceSize(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight);


		Error InitGrabStream (StreamCaptureHook *hook, DWORD milliSecPerFrame,
		                      WORD width, WORD height, WORD stride, GrabFormat format);
		Error FinishGrabStream (void);
		Error PrepareGrabBuffer (FPTR buffer, DWORD size, FPTR __far &info)
			{return unit->PrepareGrabBuffer (buffer, size, info);}
		Error UnprepareGrabBuffer (FPTR info)
			{return unit->UnprepareGrabBuffer (info);}
		Error AddStreamGrabBuffer (FPTR info, FPTR userData);
		Error StartGrabStream (void);
		Error StopGrabStream (void);


		virtual Error InitGrabYStream (void);
		virtual Error FinishGrabYStream (void);
		Error StartGrabYStream (YStreamCaptureHook *hook, int left, int top, WORD width, WORD height);
		Error StopGrabYStream(void);
		Error SupplyYStreamGrabBuffer (FPTR info, FPTR userData);


#if NT_KERNEL || VXD_VERSION
		virtual Error GetDMASizes (int &dmaLeft, int &dmaTop, int &dmaWidth, int &dmaHeight) = 0;
		virtual Error UpdateDisplay(FPTR & rDIB, BOOL & rAdaptClientSize, int & rDestLeft, int & rDestTop, int & rDestWidth, int & rDestHeight);
#if WDM_VERSION
		virtual Error PassivateDone() = 0;
#endif
#else
		virtual Error UpdateDisplay(void);
#endif
	};



inline Error VirtualPIP::AdaptClientSize(int destLeft, int destTop, int destWidth, int destHeight)
	{
	if (destLeft   != this->destLeft  ||
	    destTop    != this->destTop   ||
	    destWidth  != this->destWidth ||
	    destHeight != this->destHeight)
		{
		this->destLeft = destLeft;
		this->destTop = destTop;
		this->destWidth = destWidth;
		this->destHeight = destHeight;

		if (GetState() == current)
			GNREASSERT(unit->SetDestRect(destLeft, destTop, destWidth, destHeight));
		}

	GNRAISE_OK;
	}



inline Error VirtualPIP::AdaptSourceSize(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight)
	{
	if (sourceLeft   != this->sourceLeft  ||
	    sourceTop    != this->sourceTop   ||
	    sourceWidth  != this->sourceWidth ||
	    sourceHeight != this->sourceHeight)
		{
		this->sourceLeft = sourceLeft;
		this->sourceTop = sourceTop;
		this->sourceWidth = sourceWidth;
		this->sourceHeight = sourceHeight;

		if (GetState() == current)
			GNREASSERT(unit->SetSourceRect(sourceLeft, sourceTop, sourceWidth, sourceHeight));
		}

	GNRAISE_OK;
	}



#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\videodma\generic\vportpip.h ===
// FILE:      library\hardware\videodma\generic\vportpip.h
// AUTHOR:    S. Herr
// COPYRIGHT: (c) 1997 Viona Development GmbH. All Rights Reserved.
// CREATED:   23.04.97
//
// PURPOSE:   Base PIP class for Video Port based live video display.
//
// HISTORY:

#ifndef VPORTPIP_H
#define VPORTPIP_H

#include "pip.h"
#include "library\hardware\video\generic\videvice.h"
#include "library\lowlevel\intrctrl.h"

#if !NT_KERNEL && !VXD_VERSION
#include "library\support\VDSup32\VDSup32.h"
#include "library\common\winports.h"
#include "..\generic\clrkeymg.h"
#endif

#define VP_VBLANK_TIMEOUT 100				// Time in [ms] until a VSYNC IRQ must have occurred.
#define VP_GRAB_TIMEOUT	  1000			// Time in [ms] until grabbing of one frame must be finished.

class VideoPortController
	{
	public:
		virtual Error EnableVideoPort(const VideoPortCaps __far & caps) = 0;
		virtual Error DisableVideoPort(void) = 0;		
	};
	
class VideoPortPIP : public PIP, public DDColorkeyManager
	{
	friend class VirtualVideoPortPIP;
	friend class VPPIPVBlankIntHandler;

	protected:
		friend DWORD _export FAR PASCAL VPSizeHookProc(WORD code, WPARAM wParam, LPARAM lParam);

		VideoPortController	*	videoPortController;
		
		BOOL	changed, displayChanged;

		BOOL	pipEnabled;
		BOOL	transferRunning;

		BOOL	adaptSourceSize;
		BOOL	adaptClientSize;
		
		int	srcLeft, srcTop;												// Source rectangle dimensions
		WORD  srcWidth, srcHeight;
	   int	dstLeft, dstTop, dstWidth, dstHeight;					// Destination rectangle dimensions

		int	srcCropLeft, srcCropTop, srcCropRight, srcCropBottom;

		VideoSampleMode			sampleMode;
		VideoStandard				curVideoStd;

		int							hOffset, vOffset;
		WORD							activeLeft, activeTop, activeWidth, activeHeight;	// Active (i.e. usable) part of input field
		int							hTrigger;
		BIT							hsyncPol, vsyncPol;
		VideoFieldIndication		fieldIndication;
		BOOL							pixelClockEdge;
		BOOL							stillSequence;
		DWORD							contentType;

		const HardVideoParams *	curVideoParams;

#if NT_KERNEL || VXD_VERSION
		WinDesc	*	wd;
#else
		HWND			win;
		HHOOK			hook;
		HINSTANCE	hinst;
#endif

		FieldDisplayHookHandle	fieldDisplayHook;

		Error SetVideoStandard(VideoStandard std);
		Error SetSampleMode(VideoSampleMode mode);
		Error SetHOffset(int offset);
		Error SetVOffset(int offset);

		Error SetAdaptClientSize(BOOL adaptClientSize);
		Error SetAdaptSourceSize(BOOL adaptSourceSize);

		Error SetSourceRect(int left, int top, int width, int height);
		Error SetDestRect(int left, int top, int width, int height);

#if !NT_KERNEL && !VXD_VERSION
  		BOOL	colorKeyed;

		Error SetColorkeyColor(DWORD color);
		Error SetColorkeyIndex(DWORD index);
		Error GetColorkeyed(BOOL __far & keyed);

		Error SetAlwaysOverlay(BOOL alwaysOverlay) {GNRAISE_OK;}

		Error DrawColorkey(void) {GNRAISE(DDColorkeyManager::DrawColorkey(win));}
		Error DrawBlack(void) {GNRAISE(DDColorkeyManager::DrawBlack(win));}
		virtual Error RedrawBackground(void) {return DrawColorkey();}
#endif

		Error SetScreenDest(BOOL screenDest)					{GNRAISE_OK;}
		Error SetOffscreenOverride(BOOL offscreen)			{GNRAISE_OK;}
		Error SetOffscreenBase(FPTR base)						{GNRAISE_OK;}
		Error SetOffscreenBytesPerRow(WORD bpr)				{GNRAISE_OK;}
		Error SetOffscreenPixelFormat(PIPFormat format)		{GNRAISE_OK;}

		Error SetFieldDisplayHook(FieldDisplayHookHandle hook);

#if !NT_KERNEL && !VXD_VERSION
		Error SetWindow(HWND win);
#endif
#if NT_KERNEL || VXD_VERSION
		Error SetWinDesc(WinDesc * wd);
#endif

		Error SetSourceCrop(int left, int top, int right, int bottom);

		Error EnablePIP(BOOL enable);

		Error Update(void);
		Error UpdateDisplay(void);

   	// IRQ Handling
		VPPIPVBlankIntHandler	* vbiHandler;			// VBlank handler.
		InterruptServer 			* vbiServer;
		DWORD volatile 			vBlankCount;			// Tells us, how many vertical blank IRQs happened.

		virtual void VBlankInterrupt(void);				// VBlank (VSYNC) IRQ routine.
  		Error WaitVBlankIRQ(WORD count);					// Wait for the number of "count" VSYNC IRQs to occur.


		//
		// Functions to be defined in successors:
		//
		virtual Error StartVideoDisplay(void) = 0;
		virtual Error StopVideoDisplay(void) = 0; 
		virtual Error MovePIP(void) = 0;
		virtual Error SizePIP(void) = 0;

		virtual WORD  GetColorControl() = 0;
		virtual Error SetColorControlValues(ColorControlValues __far & clrCtrl) = 0;
		
		virtual Error StillSequenceChanged(void) {GNRAISE_OK;}
		virtual Error ContentTypeChanged(void)	{GNRAISE_OK;}

/*
		virtual Error SetCCBrightness(WORD ccBrightness) = 0;
		virtual Error SetCCContrast(WORD ccContrast) = 0;
		virtual Error SetCCSaturation(WORD ccSaturation) = 0;
		virtual Error SetCCHue(WORD ccHue) = 0;
		virtual Error SetCCGamma(WORD ccGamma) = 0;
		virtual Error SetCCColorEnable(BOOL ccColorEnable) = 0;
*/		
		virtual Error NotifyUnitCreate(void) = 0;
		virtual Error NotifyUnitDelete(void) = 0;
	public:
		BOOL	canSendDisplayChange;
	
		VideoPortPIP(HINSTANCE hinst, InterruptServer * vBlankIntServer,
						 VideoPortController	*	videoPortController = 0);
		~VideoPortPIP();
		VirtualUnit * CreateVirtual(void);

		Error Configure(TAG __far * tags);

		virtual Error Reconfigure(void) = 0;
		virtual Error RegainSurface(void) {GNRAISE_OK;}

		// Use this to get a valid connection to the port. If error, then the port PIP cannot be used.
		virtual Error MatchPortCaps(const VideoPortCaps __far & inCaps, VideoPortCaps __far & usedCaps) = 0;

		Error ReInitialize(void);

		HardVideoParams 			ntscSQP, palSQP, ntscCCIR, palCCIR;
	};


	
class VirtualVideoPortPIP : public VirtualPIP, public WinPort
	{
	friend class VideoPortPIP;
	
	private:
		VideoPortPIP	*	unit;
	
	protected:
		void Message(WPARAM wParam, LPARAM dParam);
		
		ColorControlValues clrCtrl;
		
	public:
		VirtualVideoPortPIP(VideoPortPIP	* unit);
		~VirtualVideoPortPIP(void) {unit->NotifyUnitDelete();}

		Error Configure(TAG __far * tags);

      Error PreemptStopPrevious(VirtualUnit * previous);
      Error PreemptChange(VirtualUnit * previous);
      Error PreemptStartNew(VirtualUnit * previous);
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\videodma\specific\bt848pip.h ===
// FILE:      videodma (BT848)/ VIDMABTR.H
// AUTHOR:    P.C.Straasheijm
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   09.10.96
//
// PURPOSE: The PIP-related classes.
//
// HISTORY:

#ifndef BT848PIP_H
#define BT848PIP_H

#ifndef ONLY_EXTERNAL_VISIBLE

#include "library\lowlevel\memmpdio.h"
#include "library\lowlevel\dmabuffr.h"      
#include "library\lowlevel\intrctrl.h"
#include "library\common\profiles.h"    
#include "library\support\gfxdebug\gfxdebug.h"
#include "library\general\lists.h" 

#if !NT_KERNEL
#include "library\hardware\videodma\generic\gfxconfg.h"
#else
#include "library\lowlevel\kernlmem.h"
#endif

#include "library\hardware\videodma\generic\dmapip.h"
#include "library\hardware\pcibrdge\specific\bt848\bt848reg.h" 
#include "library\hardware\pcibrdge\specific\bt848\framlist.h"

#endif


//
// Maximum values for destination rectangle size.
//
#define PIP_WIDTH_MAX   768
#define PIP_HEIGHT_MAX  576  


#ifndef ONLY_EXTERNAL_VISIBLE

//
//number of riscinstructionbytes-prefetch of Brooktree
//

#define PREFETCH 0x20;

//
// Number of test cases for minPix detection.
//
#define NUM_TEST_CASES 3

//
// Structures for BT848 PIP DMA configuration.
//
struct BT848PIPConfig
	{
	WORD threshold;
	WORD burstlength;
	};
          

struct BT848PIPSingleConfig
	{
	WORD threshold;
	WORD burstlength;
	};

// for grabstream routines ;

#endif	 

//
// PIP Display Mode (also valid for grabbing).
//
enum PIPDisplayMode
	{
	PDMD_MIN 						= 0,
	PDMD_EMULATED_INTERLACED	= 0,		// Interlaced display.
	PDMD_SINGLE_FIELD,						// Single field display.
	PDMD_AUTOMATIC,							// Automatic decision of display mode.
	PDMD_MAX = PDMD_AUTOMATIC
	};

enum PIPErrDiffusion
	{
	PIP_ED_ON 	= 0,
	PIP_ED_OFF 	= 1,
	PIP_ED_AUTOMATIC
	};
          
          
enum PIPHFilterType          
	{
	AUTO_HFILT 	=0,
	CIF			=1,
	QCIF			=2,
	ICON			=3
	};
	
// Error definitions.
#define GNR_DMA_PIP_NOT_POSSIBLE		MKERR(ERROR, PIP, GENERAL, 0x01)		// Current screen mode does not allow DMA PIP
#define GNR_VIDEO_STD_NOT_SUPPORTED	MKERR(ERROR, PIP, GENERAL, 0x02)		// Desired video standard (e.g. SECAM) not supported.
#define GNR_PIP_NOT_RUNNING			MKERR(ERROR, PIP, GENERAL, 0x03)		// PIP is not running when trying to execute OptimizeBuffer()
#define GNR_NO_OPTIMAL_MINPIX			MKERR(ERROR, PIP, GENERAL, 0x04)		// No optimal minPix value could be found by OptimizeBuffer()
#define GNR_DEST_RECT_SIZE				MKERR(ERROR, PIP, GENERAL, 0x05)		// Destination rectangle too small or too big.
#define GNR_WRONG_GRAB_SIZE			MKERR(ERROR, PIP, GENERAL, 0x06)		// Dimensions of frame to grab are too big.
#define GNR_NO_VBLANK_IRQ				MKERR(ERROR, PIP, GENERAL, 0x07)		// An expected VBlank IRQ did not occur.
#define GNR_GRAB_TIMEOUT				MKERR(ERROR, PIP, GENERAL, 0x08)		// A timeout occurred during grabbing a frame.
#define GNR_WRONG_GRAB_FORMAT			MKERR(ERROR, PIP, GENERAL, 0x09)		// An unsupported capture format was requested
#define GNR_SAMPLEMODE_NOT_SUPPORTED	MKERR(ERROR, PIP, GENERAL, 0x0a)		// Desired video sample mode not supported

#ifndef ONLY_EXTERNAL_VISIBLE

#define VBLANK_TIMEOUT 100				// Time in [ms] until a VSYNC IRQ must have occurred.
#define GRAB_TIMEOUT	  1000			// Time in [ms] until grabbing of one frame must be finished.

struct BT848PIPSetting {
	BYTE			hdelay_O;
	BYTE			vdelay_O;
	BYTE			hactive_O;
	BYTE	      vactive_O;   
	BYTE			msbcrobb_O;
	BYTE			hhscaling_O;
	BYTE			lhscaling_O;
	BYTE			hvscaling_O;
	BYTE			lvscaling_O;
	BYTE			color_fm;   
	BYTE			capturecontrol;
   BYTE			vert_filter;
	WORD			GPIODMAControl;
   DWORD			DMABase;
	};



class BT848PrepInfoPIP : public PrepInfoPIP
	{
	friend class BT848PIP;
	protected:
		WORD width, height;
		DWORD bytesPerLine;
		ContinuousDMABuffer *riscbuffer;
		ScatteredDMABuffer *ram;
		DWORD riscphysical;
		DWORD __huge *risclogicjmp;
		BT848PIP		*ptr848;
	public:
		BT848PrepInfoPIP (BT848PIP *ptr848, WORD width, WORD height, DWORD bytesPerLine);

		virtual Error Prepare (FPTR buffer, DWORD size);
		virtual Error Unprepare (void);
	};


	
class BT848PIPVBlankIntHandler;			// Forward declaration of IRQ handler class.

//
// Physical BT848 Masked DMA PIP class.
//
class BT848PIP : public DMAPIP	
	{
	friend class VirtualBT848PIP;
	friend class BT848PIPVBlankIntHandler;

	protected:
		MemoryMappedIO			*	io;						// IO object for I20 PIP registers.
                                 
#if NT_KERNEL
#else
		GraphicConfig			*	gfxConfig;				// Stores information about current graphics card and screen mode.
#endif
		FrameList				* framelist;
		DWORD						riscPhysical;

		BT848PIPConfig			* config;					// Stores configuration information (MinPix etc.)
		Profile					* profile;

		PIPDisplayMode			dispMode;					// Current display mode (interlace / single field)
		BOOL						dupField;					// Source interlaced or both fields equal.
		PIPErrDiffusion		errDiffusion;				// not in config file !

		VirtualUnit 			* videoBus;
		
		BOOL						fieldToggle;				// Tells if interlaced should be simulated by toggling fields
		BOOL						fieldToggleRunning;
      
		BOOL						maskEnabled;				// Indicates use of mask information. If false, the DMA window
																	// is always on top.
      BOOL						grabMode;					// The PIP object is in grabbing mode, when this flag is TRUE.
      BOOL						autoOverride;
      
		HardVideoParams	* 	curVideoParams;		// Pointer to the settings of the current video standard.

		VideoStandard 			curVideoStd;			// Contains the current video standard.
		VideoSampleMode		sampleMode;
		int						hOffset, vOffset;
      
		PIPHFilterType			horizFilter;
		
		BOOL						minPixAuto;
		int 						minPix;
		
		BOOL	extFieldInd;								// External field indication.
		BOOL	topField;									// Top field indication.
		
		int	srcLeft, srcTop;
		WORD  srcWidth, srcHeight;							// Dimensions of the source rectangle.

		WORD	ConvertGrabFormat(GrabFormat format);		// Converts destination format to the YUV2RGB register value. 
		WORD	ConvertPIPFormat(PIPFormat format);			// Same for PIP format. In both functions packed24 is set
															// in respect to 24 or 32 bit mode.
		int	GetPixelSize (GrabFormat type);					// Get size of a pixel for a certain format.

		Error WaitVBlankIRQ(WORD count);					// Wait for the number of "count" VSYNC IRQs to occur.

		BOOL	adaptSourceSize;							// Tells, if the source rectangle is adapted to the video
															// standard.
		BT848PIPVBlankIntHandler	* vBlankIntHandler;			// VBlank handler.
		InterruptServer 				* vBlankIntServer;			// Interrupt server.

		BT848PIPSetting				pipSetting, grabSetting;		
		BT848PIPSetting	__far	*	currentPIPSetting;
		
		PIPFormat					overrPixelFormat;
		
		ContinuousDMABuffer	*	captureDMA;
		FPTR							captureDMABuffer;
		DWORD							captureDMADWordsPerRow;
		
		WORD							captureHeight;
				
		DWORD						__huge  *riscjumpadd;
			
		DWORD							captureDWordsPerRow;

		BOOL							capturedInBuffer;

#if NT_KERNEL || VXD_VERSION
		KernelMemory				captureKHandle;
		HPTR							captureKBuffer;
#endif

		StreamCaptureHookHandle			captureHook;
		YStreamCaptureHookHandle		yCaptureHook;
		WORD							yCaptureCounter;
		
	   ContinuousDMABuffer		*riscBuffer;
	   
	   DWORD							overrPhysicalBase;
	   WORD							overrBytesPerRow;
	   DWORD							physicalBase;
		WORD							bytesPerRow;
		PIPFormat					pixelFormat;
#if VIONA_VERSION		      
		BOOL							offscreenOverride;
		DWORD							offscreenPhysicalBase, offscreenBytesPerRow;
		PIPFormat					offscreenPixelFormat;
				
		WORD							maxOverlayBytesPerRow[PIPFORMAT_MAX + 1];
#endif      

	protected:
		int dmaSuspended;									// Internal DMA suspension flag.

		void  VBlankInterrupt(void);						// VBlank (VSYNC) IRQ routine.
		DWORD volatile vBlankCount;							// Tells us, how many vertical blank IRQs happened.

		Error StopDMA(void);								// Stops DMA.
		Error StartDMA(void);								// Starts DMA.
		Error EnablePIP(BOOL enable);						// Enables PIP in general.

		Error Update(void);									// Updates all PIP parameters.
		
		virtual Error CalculateSettings(BT848PIPSetting __far &setting, 
													DWORD dstBase, DWORD bytesPerRow,
													PIPFormat pixelFormat,
													BOOL mask,
													int left, int top,
													WORD width, WORD height);

		Error CalculatePIPSettings(void);
		Error ProgramSettings(BT848PIPSetting __far &setting);
		Error SetMask(FrameList * map);                               
#if VIONA_VERSION		
		Error SetOffscreenDMARegion(DWORD physical, DWORD stride, PIPFormat format,
		                            int left, int top, int width, int height);
#endif
		Error SetSourceRect(int left, int top, int width, int height); 
		Error SetVideoStandard(VideoStandard std);	 			
		Error SetSampleMode(VideoSampleMode sampleMode);
		Error SetHOffset(int offset);
		Error SetVOffset(int offset);
		Error SetHorizFilter(PIPHFilterType horizFilter);
		Error SetDispMode(PIPDisplayMode dispMode);
		Error SetDupField(BOOL dupField);
		Error SetErrDiffusion(PIPErrDiffusion errDiffusion);
		Error SetMinPix(int minPix);
//		Error SetMaskEnable(BOOL enable);
		Error SetAdaptSourceSize(BOOL adaptSourceSize);
		Error SetExtFieldInd(BOOL enable);
		Error SetTopField(BOOL field);
		Error SetMinPixAuto(BOOL minPixAuto);
		Error SetFieldToggle(BOOL fieldToggle);

		Error SetAutoOverride(BOOL autoOverride);
		Error SetPhysical(void __far * physicalBase);
		Error SetPhysicalLinear(DWORD physicalBaseLinear);
		Error SetBytesPerRow(WORD bytesPerRow);
		Error SetPixelFormat(PIPFormat pixelFormat);

		Error GetPhysicalFromPointer(WORD selector, DWORD offset, DWORD __far& physical);
				
		Error OptimizeBuffer(int __far & minPixVal);	// Calculates an optimal minpix value for the current
																	// PIP parameters. DMA must be on when calling this function.
		Error DetectMinPix(int __far & minPixVal) {GNRAISE_OK;}	// Helper subroutine for minpix detection.
		Error ExtendedOptimization(BT848PIPSingleConfig & config){GNRAISE_OK;}		// Extended Optimization routine.
		Error GrabFrame(FPTR base, WORD width,  WORD height, 		   // Grab a single frame from the running picture.
		                        	WORD stride, GrabFormat fmt); 


		virtual Error InitGrabStream (StreamCaptureHookHandle hook, DWORD milliSecPerFrame,
		                              WORD width, WORD height, WORD stride, GrabFormat format);
		virtual Error FinishGrabStream (void);
		virtual Error StartGrabStream (void);
		virtual Error StopGrabStream (void);
		virtual PrepInfoPIP *CreatePrepInfo (void);

		typedef struct CaptureParameters2
			{
			DWORD bytesPerLine;
			BT848PrepInfoPIP *captureBuffer;
			BOOL capturedInBuffer;
			DWORD next;
			BT848PrepInfoPIP *captureBufferNext;
			BT848PrepInfoPIP *last;
			BOOL NewBuffer;
			DWORD captureTime;
			};
		CaptureParameters2 capture2;

      HPTR  captureBuffer;	
		Error SupplyStreamGrabBuffer(HPTR buffer);
		
		FPTR	GetStreamGrabBuffer(void);
							             
		Error StartGrabYStream(YStreamCaptureHookHandle hook,
		                       int left, int top,
		                       WORD width, WORD height);

		Error StopGrabYStream(void);		
		Error StartFieldToggle(void){GNRAISE_OK;}
		Error StopFieldToggle(void){GNRAISE_OK;}
		
		Error	StoreConfig(BT848PIPConfig* config);		// Store configuration
		Error RetrieveConfig(BT848PIPConfig* config);	// Retrieve configuration

 		int   HorizontalAlign(void);						// Delivers the alignment for BT848PIP (destination is always
																	// DWORD aligned, so e.g. 24 bit modes need a different alignment
																	// than 16 or 15 bit).
		int   VerticalAlign(void);							// Same for vertical.

		int 	MaxDestWidth(void) {return srcWidth;}		// Returns maximum horizontal size of the destination rectangle.
		int 	MaxDestHeight(void) {return srcHeight;}		// Maximum vertical size of the destination rectangle.
		
		Error InitDMARegion(int left, int top, int width, int height);
		Error AddDMAClipRect(int left, int top, int width, int height);
		Error RemDMAClipRect(int left, int top, int width, int height);
		Error CompleteDMARegion(DWORD __huge* &riscjumpadd);
		Error CompleteDMARegion(void) {return CompleteDMARegion(riscjumpadd);}
		int 	HorizontalPixelsPerMaskBit (void);
		int 	VerticalPixelsPerMaskBit (void);		
		
			
	public:
#if NT_KERNEL
		BT848PIP (MemoryMappedIO *io, InterruptServer * vblankIntServer,
				  Profile * profile, 
				  DWORD physicalBase, WORD bytesPerRow, PIPFormat pixelFormat);
#else
		BT848PIP (HINSTANCE hinst, MemoryMappedIO *io, InterruptServer * vblankIntServer,
				  Profile * profile);
#endif
		~BT848PIP(void);

		Error CompleteDMARAM(FPTR base, WORD bytesPerRow, WORD height, DWORD buffSize, ContinuousDMABuffer *riscbuffer, 
   							   ScatteredDMABuffer *ram, DWORD __far &riscphysical, DWORD __huge* __far &risclogicjmp);

		
		VirtualUnit * CreateVirtual(void);
		
		Error Initialize(void);								// Initializes the BT848 PIP. Call after the object was constructed.
		
		Error SuspendDMA(void);								// Nested DMA disabe.
		Error ResumeDMA(void);								// Nested DMA enable.

		HardVideoParams 			ntscSQP, palSQP, ntscCCIR, palCCIR; 
		BIT							vclkPolarity;									// VCLK polarity.
	};


//
// Virtual BT848 PIP.
//
class VirtualBT848PIP : public VirtualDMAPIP 
	{
	friend class BT848PIP;

	private:
		BT848PIP* unit;

	protected:
		PIPHFilterType 	horizFilter;
		PIPDisplayMode 	dispMode;

		BOOL 					dupField;
		int 					minPix;
		PIPErrDiffusion	errDiffusion;
		BOOL					maskEnabled;
		BOOL					extFieldInd;
		BOOL					topField;
		BOOL					minPixAuto;
		BOOL					fieldToggle;
		BOOL					autoOverride;
   
		void __far *		physicalBase;
		DWORD					physicalBaseLinear;
		WORD					bytesPerRow;
		PIPFormat			pixelFormat;

   
		Error Preempt (VirtualUnit* previous);
	public:
		VirtualBT848PIP (BT848PIP* physical);
		Error Configure (TAG __far * tags);
		
		Error OptimizeBuffer(int __far& minPixVal);	// Runs an optimization for the BT848 FIFO buffer size.
																	// Returns an optimal value for the PIP_MIN_PIX tag parameter.
	};


#endif // ONLY_EXTERNAL_VISIBLE


// BT848 PIP specific tags                     
MKTAG (PIP_H_FILTER,     	PIP_UNIT, 0x00000030, PIPHFilterType)	// Horizontal filter type selection.
MKTAG (PIP_DISPLAY_MODE, 	PIP_UNIT, 0x00000031, PIPDisplayMode) 	// DispMode selection.
MKTAG (PIP_DUP_FIELD,    	PIP_UNIT, 0x00000032, BOOL)				// DupField switch.
MKTAG (PIP_ERR_DIFFUSION,	PIP_UNIT, 0x00000034, PIPErrDiffusion)	// Error diffusion type selection.
MKTAG (PIP_MIN_PIX,      	PIP_UNIT, 0x00000035, int)					// MinPix value (FIFO threshold).
MKTAG (PIP_MASK_ENABLE,	 	PIP_UNIT, 0x00000036, BOOL)				// Mask enable/disable switch.
MKTAG (PIP_EXT_FIELD_IND,  PIP_UNIT, 0x00000037, BOOL)				// ExtFI mode selection.
MKTAG (PIP_TOP_FIELD,      PIP_UNIT, 0x00000038, BOOL)				// Top field interpretation selection.
MKTAG (PIP_MINPIX_AUTO,		PIP_UNIT, 0x00000039, BOOL)				// Automatic adaption of MinPix to picture size.
MKTAG (PIP_FIELDTOGGLE,		PIP_UNIT, 0x0000003a, BOOL)				// Simulate interlaced with single field by toggling fields

// Make sure to set physical, bytesPerRow and pixelFormat at the same time when enabling this:
MKTAG (PIP_AUTO_OVERRIDE,	PIP_UNIT, 0x0000003b, BOOL)
MKTAG (PIP_PHYSICAL_BASE,	PIP_UNIT, 0x0000003c, void __far *)
MKTAG (PIP_PHYSICAL_BASE_LINEAR,	PIP_UNIT, 0x0000003d, DWORD)		// Use a 32bit flat pointer
MKTAG (PIP_BYTES_PER_ROW,	PIP_UNIT, 0x0000003e, WORD)
MKTAG (PIP_PIXEL_FORMAT,	PIP_UNIT, 0x0000003f, PIPFormat)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\videodma\specific\I20PIP.H ===
// FILE:      library\hardware\videodma\specific\i20pip.h
// AUTHOR:    Dietmar Heidrich, S. Herr
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   08.04.95
//
// PURPOSE: The PIP-related classes.
//
// HISTORY:

#ifndef I20PIP_H
#define I20PIP_H

#ifndef ONLY_EXTERNAL_VISIBLE

#include "..\..\..\lowlevel\memmpdio.h"
#include "..\..\..\lowlevel\dmabuffr.h"      
#include "..\..\..\lowlevel\intrctrl.h"
#include "..\..\..\common\profiles.h"
#include "..\..\video\generic\videvice.h"

#if NT_KERNEL || VXD_VERSION
#include "..\..\..\lowlevel\kernlmem.h"
#else
#include "..\generic\gfxconfg.h"
#endif

#endif


#include "..\generic\dmapip.h"

//
// Maximum values for destination rectangle size.
//
#define PIP_WIDTH_MAX   768
#define PIP_HEIGHT_MAX  576

//
// Number of test cases for minPix detection.
//
#define NUM_TEST_CASES 3

//
// Structures for I20 PIP DMA configuration.
//
struct I20PIPConfig
	{ 
	int	minPixMasked[NUM_TEST_CASES],
			minPixNoMask[NUM_TEST_CASES],
			latencyMasked[NUM_TEST_CASES],
			latencyNoMask[NUM_TEST_CASES];
	};

struct I20PIPSingleConfig
	{ 
	int	minPixMasked,
			minPixNoMask,
			latencyMasked,
			latencyNoMask;
	};

//
// PIP Display Mode (also valid for grabbing).
//
enum PIPDisplayMode
	{
	PDMD_MIN 						= 0,
	PDMD_EMULATED_INTERLACED	= 0,		// Interlaced display.
	PDMD_SINGLE_FIELD,						// Single field display.
	PDMD_AUTOMATIC,							// Automatic decision of display mode.
	PDMD_MAX = PDMD_AUTOMATIC
	};

//
// HFilter type (valid for PIP and grabbing).
//
enum PIPHFilterType
	{
	PIP_HF_CHOOSE_BEST 	= -1,				// Automatic selection of filter type.
	PIP_HF_L0C3  			= 0,				// The enum values correspond to the values of I20's HFilter register.
	PIP_HF_L3C3				= 1,
	PIP_HF_L4C4a 			= 2,
	PIP_HF_L5C4  			= 3,
	PIP_HF_L4C4b 			= 4,
	PIP_HFILTER_MIN 		= -1,
	PIP_HFILTER_MAX 		= 4
	};

enum PIPErrDiffusion
	{
	PIP_ED_ON 	= 0,
	PIP_ED_OFF 	= 1,
	PIP_ED_AUTOMATIC
	};


#ifndef ONLY_EXTERNAL_VISIBLE

#define VBLANK_TIMEOUT 100				// Time in [ms] until a VSYNC IRQ must have occurred.
#define GRAB_TIMEOUT	  1000			// Time in [ms] until grabbing of one frame must be finished.

struct I20PIPSetting {
	DWORD			htiming;
	DWORD			vtiming;
	DWORD			vidconfig;
	DWORD	      vidtopbase;
	DWORD			vidbotbase;
	DWORD			dispgrab;
	DWORD			vidwin;
	DWORD			masktopbase;       
	DWORD			maskbotbase;
	DWORD			maskctrl;
	};
	
class I20PIPVBlankIntHandler;			// Forward declaration of IRQ handler class.

//
// Physical I20 Masked DMA PIP class.
//
class I20PIP : public MaskDMAPIP	
	{
	friend class VirtualI20PIP;
	friend class I20PIPVBlankIntHandler;

	protected:
		MemoryMappedIO			*	io;						// IO object for I20 PIP registers.
                                 
#if NT_KERNEL || VXD_VERSION
#else
		GraphicConfig			*	gfxConfig;				// Stores information about current graphics card and screen mode.
#endif
		ContinuousDMABuffer 		maskBuffer;				// mask DMA buffer
		DWORD							maskPhysical;

		I20PIPConfig			*	config;					// Stores configuration information (MinPix etc.)
		Profile					*	profile;

		PIPHFilterType				horizFilter;			// Current horizontal filter type for PIP or grabbing.
		PIPDisplayMode				dispMode;				// Current display mode (interlace / single field)
		BOOL							dupField;				// Source interlaced or both fields equal.
		PIPErrDiffusion			errDiffusion;			// not in config file !
		int 							minPix;					// Default FIFO threshold value (Minimum number of DWORDs).
		BOOL							minPixAuto;				// Tells if automatic MinPix adaption desired.

		BOOL							fieldToggle;			// Tells if interlaced should be simulated by toggling fields
		BOOL							fieldToggleRunning;

		BOOL 							maskEnabled;			// Indicates use of mask information. If false, the DMA window
																	// is always on top.
      BOOL							grabMode;				// The PIP object is in grabbing mode, when this flag is TRUE.
      
		const HardVideoParams* 	curVideoParams;		// Pointer to the settings of the current video standard.

		VideoStandard 				curVideoStd;			// Contains the current video standard.
		VideoSampleMode			sampleMode;
		int							hOffset, vOffset;
		WORD							activeLeft, activeTop, activeWidth, activeHeight;
		int							hTrigger;
		BIT							hsyncPol, vsyncPol;
		VideoFieldIndication		fieldIndication;
		BOOL							pixelClockEdge;
		      
		DWORD							dispgrab;		
		DWORD							lastStopTime;
		WORD	curMaskDwpr;									// Number of DWORDs per mask row.

		BOOL	extFieldInd;									// External field indication.
		BOOL	topField;										// Top field indication.
		
		int	srcLeft, srcTop;
		WORD  srcWidth, srcHeight;							// Dimensions of the source rectangle.

		WORD	ConvertGrabFormat(GrabFormat format);	// Converts destination format to the YUV2RGB register value. 
		WORD	ConvertPIPFormat(PIPFormat format);		// Same for PIP format. In both functions packed24 is set
																	// in respect to 24 or 32 bit mode.
		int	GetPixelSize (GrabFormat type);			// Get size of a pixel for a certain format.

		int	srcCropLeft, srcCropTop, srcCropRight, srcCropBottom;

		Error WaitVBlankIRQ(WORD count);					// Wait for the number of "count" VSYNC IRQs to occur.

		BOOL	adaptSourceSize;								// Tells, if the source rectangle is adapted to the video
																	// standard.
		I20PIPVBlankIntHandler	* vBlankIntHandler;	// VBlank handler.
		InterruptServer 			* vBlankIntServer;	// Interrupt server.

		I20PIPSetting				pipSetting, grabSetting;		
		I20PIPSetting	__far	*	currentPIPSetting;

		
		ContinuousDMABuffer	*	captureDMA;
		
		FPTR							captureDMABuffer;
		DWORD							captureDMADWordsPerRow;

		PrepInfoPIP					*captureBuffer;
		DWORD							captureDWordsPerRow;

		BOOL							capturedInBuffer;

		StreamCaptureHookHandle		captureHook;


#if NT_KERNEL || VXD_VERSION
		KernelMemory				yCaptureKHandle;
		HPTR							yCaptureKBuffer;
#endif
		DWORD							yCaptureDMADWordsPerRow;
//		DWORD							yCaptureDWordsPerRow;
		WORD							yCaptureHeight;
		FPTR							yCaptureBuffer;
		YStreamCaptureHookHandle	yCaptureHook;
		WORD							yCaptureCounter;
		
		BOOL							tritonFix;

	   DWORD							physicalBase;
		WORD							bytesPerRow;
		PIPFormat					pixelFormat;
      
#if VIONA_VERSION		      
		BOOL							offscreenOverride;
		DWORD							offscreenPhysicalBase, offscreenBytesPerRow;
		PIPFormat					offscreenPixelFormat;
		BOOL							offscreenBobbing;
				
		BOOL							forceSingleField;				
		WORD							maxOverlayBytesPerRow[PIPFORMAT_MAX + 1];
#endif
		FieldDisplayHookHandle	fieldDisplayHook;
	protected:
		int dmaSuspended;										// Internal DMA suspension flag.

		void 	VBlankInterrupt(void);						// VBlank (VSYNC) IRQ routine.
		DWORD volatile vBlankCount;						// Tells us, how many vertical blank IRQs happened.

		Error StopDMA(void);									// Stops DMA.
		Error StartDMA(void);								// Starts DMA.
		Error EnablePIP(BOOL enable);						// Enables PIP in general.

		Error Update(void);									// Updates all PIP parameters.
		
		virtual Error CalculateSettings(I20PIPSetting __far &setting, 
													DWORD dstBase, DWORD bytesPerRow,
													PIPFormat pixelFormat,
													BOOL mask,
													int left, int top,
													WORD width, WORD height,
													BOOL bobbing = FALSE);
		Error CalculatePIPSettings(void);													

		Error ProgramSettings(I20PIPSetting __far &setting);
		
		Error ProgramAll(void);								// Reprograms all DMA PIP/grab registers of the I20.

		Error SetMask(RectBitMap * map);

#if NT_KERNEL || VXD_VERSION
	public:
#endif
#if VIONA_VERSION
		Error SetOffscreenDMARegion(DWORD physical, DWORD stride, PIPFormat format,
		                            int left, int top, int width, int height);
#endif
		
	protected:
		Error SetSourceRect(int left, int top, int width, int height);
		Error SetVideoStandard(VideoStandard std);	
		Error SetSampleMode(VideoSampleMode sampleMode);
		Error SetHOffset(int offset);
		Error SetVOffset(int offset);
		Error SetHorizFilter(PIPHFilterType horizFilter);
		Error SetDispMode(PIPDisplayMode dispMode);
		Error	SetDupField(BOOL dupField);
		Error SetErrDiffusion(PIPErrDiffusion errDiffusion);
		Error	SetMinPix(int minPix);
		Error SetMaskEnable(BOOL enable);
		Error SetAdaptSourceSize(BOOL adaptSourceSize);
		Error SetExtFieldInd(BOOL enable);
		Error SetTopField(BOOL field);
		Error SetMinPixAuto(BOOL minPixAuto);
		Error SetFieldToggle(BOOL fieldToggle);
		Error SetFieldDisplayHook(FieldDisplayHookHandle hook);

		Error SetSourceCrop(int left, int top, int right, int bottom);

		Error GetPhysicalFromPointer(WORD selector, DWORD offset, DWORD __far& physical);
				
		Error	OptimizeBuffer(int __far & minPixVal);	// Calculates an optimal minpix value for the current
																	// PIP parameters. DMA must be on when calling this function.
		Error DetectMinPix(int __far & minPixVal);	// Helper subroutine for minpix detection.
		Error ExtendedOptimization(I20PIPSingleConfig & config);		// Extended Optimization routine.

		Error GrabFrame(FPTR base, WORD width,  WORD height, 		   // Grab a single frame from the running picture.
		                        	WORD stride, GrabFormat fmt);


		virtual Error InitGrabStream (StreamCaptureHookHandle hook, DWORD milliSecPerFrame,
		                              WORD width, WORD height, WORD stride, GrabFormat format);
		virtual Error FinishGrabStream (void);
		virtual Error StartGrabStream (void);
		virtual Error StopGrabStream (void);


		virtual Error StartGrabYStream (YStreamCaptureHookHandle hook, int left, int top, WORD width, WORD height);
		virtual Error StopGrabYStream (void);


		Error StartFieldToggle(void);
		Error StopFieldToggle(void);
		
		Error	StoreConfig(I20PIPConfig* config);		// Store configuration
		Error RetrieveConfig(I20PIPConfig* config);	// Retrieve configuration

		int   HorizontalAlign(void);						// Delivers the alignment for I20 PIP (destination is always
																	// DWORD aligned, so e.g. 24 bit modes need a different alignment
																	// than 16 or 15 bit).
		int   VerticalAlign(void);							// Same for vertical.

#if VIONA_VERSION
		int MaxOverlayDestWidth(void);
		int MaxInlayDestWidth(void);
		int MaxDestWidth(void) {return MaxInlayDestWidth();}
#else
		int MaxDestWidth(void) {return (activeWidth ? min(activeWidth, srcWidth) : srcWidth) - srcCropLeft - srcCropRight;}
#endif
		int MaxDestHeight(void);
		
		RectBitMap* CreateDMAMap(int left, int top, int width, int height)
			{return new InverseRectBitMap(left, top, width, height);}			// We need an inverse bitmap for the I20!
	public:
#if NT_KERNEL || VXD_VERSION
		I20PIP (MemoryMappedIO *io, InterruptServer * vblankIntServer,
				  Profile * profile, BOOL tritonFix,
				  DWORD physicalBase, WORD bytesPerRow, PIPFormat pixelFormat);
#else
		I20PIP (HINSTANCE hinst, MemoryMappedIO *io, InterruptServer * vblankIntServer,
				  Profile * profile, BOOL tritonFix);
#endif
		~I20PIP(void);

		Error Configure(TAG __far * tags);
		
		VirtualUnit * CreateVirtual(void);
		
		Error Initialize(void);								// Initializes the I20 PIP. Call after the object was constructed.
		
		Error SuspendDMA(void);								// Nested DMA disabe.
		Error ResumeDMA(void);								// Nested DMA enable.

#if NT_KERNEL || VXD_VERSION
		virtual Error SetPIPBases (DWORD physicalBase, WORD bytesPerRow, PIPFormat pixelFormat);
#elif VIONA_VERSION		
		Error Reconfigure(void);
		BOOL	ScreenModeChanged(void);
#endif

		HardVideoParams 			ntscSQP, palSQP, ntscCCIR, palCCIR; 
		BIT							vclkPolarity;									// VCLK polarity.
	};


//
// Virtual I20 PIP.
//
class VirtualI20PIP : public VirtualMaskDMAPIP 
	{
	friend class I20PIP;

	private:
		I20PIP* unit;

	protected:
		PIPHFilterType 	horizFilter;
		PIPDisplayMode 	dispMode;

		BOOL 					dupField;
		int 					minPix;
		PIPErrDiffusion	errDiffusion;
		BOOL					maskEnabled;
		BOOL					extFieldInd;
		BOOL					topField;
		BOOL					minPixAuto;
		BOOL					fieldToggle;
   
		Error Preempt (VirtualUnit* previous);
	public:
		VirtualI20PIP (I20PIP* physical);
		Error Configure (TAG __far * tags);
		
		Error OptimizeBuffer(int __far& minPixVal);	// Runs an optimization for the I20 FIFO buffer size.
																	// Returns an optimal value for the PIP_MIN_PIX tag parameter.

#if WDM_VERSION
		Error PassivateDone() {GNRAISE_OK;}
#endif
	};


#endif // ONLY_EXTERNAL_VISIBLE


// I20 PIP specific tags                     
MKTAG (PIP_H_FILTER,     	PIP_UNIT, 0x00000030, PIPHFilterType)	// Horizontal filter type selection.
MKTAG (PIP_DISPLAY_MODE, 	PIP_UNIT, 0x00000031, PIPDisplayMode) 	// DispMode selection.
MKTAG (PIP_DUP_FIELD,    	PIP_UNIT, 0x00000032, BOOL)				// DupField switch.
MKTAG (PIP_ERR_DIFFUSION,	PIP_UNIT, 0x00000034, PIPErrDiffusion)	// Error diffusion type selection.
MKTAG (PIP_MIN_PIX,      	PIP_UNIT, 0x00000035, int)					// MinPix value (FIFO threshold).
MKTAG (PIP_MASK_ENABLE,	 	PIP_UNIT, 0x00000036, BOOL)				// Mask enable/disable switch.
MKTAG (PIP_EXT_FIELD_IND,  PIP_UNIT, 0x00000037, BOOL)				// ExtFI mode selection.
MKTAG (PIP_TOP_FIELD,      PIP_UNIT, 0x00000038, BOOL)				// Top field interpretation selection.
MKTAG (PIP_MINPIX_AUTO,		PIP_UNIT, 0x00000039, BOOL)				// Automatic adaption of MinPix to picture size.
MKTAG (PIP_FIELDTOGGLE,		PIP_UNIT, 0x0000003a, BOOL)				// Simulate interlaced with single field by toggling fields


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\videodma\specific\kmdmypip.h ===
// FILE:      library\hardware\videodma\specific\kmdmypip.h
// AUTHOR:    Viona
// COPYRIGHT: (c) 1998 Viona Development.  All Rights Reserved.
// CREATED:   27.11.98
//
// PURPOSE:   
//
// HISTORY:
#ifndef KMDMYPIP_H
#define KMDMYPIP_H

#include <library\hardware\videodma\generic\krnvppip.h>


class KernelDummyPIP : public KernelVideoPortPIP
	{	

	protected:
		Error StartVideoDisplay(void);
		Error StopVideoDisplay(void);

	public:
		KernelDummyPIP(void) : KernelVideoPortPIP(FALSE,VP_FEAT_DUMMY,VP_PORT_DUMMY,NULL) {;}
		~KernelDummyPIP(void);	
	};
	

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\videodma\specific\I22pip.h ===
// FILE:      library\hardware\videodma\specific\i22pip.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1996 Viona Development.  All Rights Reserved.
// CREATED:   05.03.96
//
// PURPOSE: The I22 PIP related classes.
//
// HISTORY:

#ifndef I22PIP_H
#define I22PIP_H

#include "i20pip.h"
#include "library\hardware\jpeg\specific\jcod050.h"



#ifndef ONLY_EXTERNAL_VISIBLE



class I22PIP : public I20PIP
	{
	friend class VirtualI22PIP;

	private:
		JCoder050 *jpegCoder;
		int vBlankIntBit;
		BOOL ccirMode;

		ContinuousDMABuffer *bitmapBuffer;
		WORD nStripes, stripeWidth;

	protected:
		Error GrabExpandFrame (FPTR base, WORD sourceWidth, WORD sourceHeight,   // grab a single frame from the running picture
		                       WORD width,  WORD height,
		                       WORD stride, GrabFormat fmt);

	public:
#if NT_KERNEL || VXD_VERSION
		I22PIP (MemoryMappedIO *io, InterruptServer *vblankIntServer,
		        Profile *profile, BOOL ccirMode, BOOL tritonFix, JCoder050 *jpegCoder, int vBlankIntBit,
				  DWORD physicalBase, WORD bytesPerRow, PIPFormat pixelFormat);
#else
		I22PIP (HINSTANCE hinst, MemoryMappedIO *io, InterruptServer *vblankIntServer,
		        Profile *profile, BOOL ccirMode, BOOL tritonFix, JCoder050 *jpegCoder, int vBlankIntBit);
#endif
		~I22PIP (void);

		VirtualUnit *CreateVirtual (void);

		Error Initialize (void);   // Call after the object was constructed
	};



class VirtualI22PIP : public VirtualI20PIP
	{
	friend class I22PIP;

	protected:
		I22PIP *i22pip;

	public:
		VirtualI22PIP (I22PIP *physical);

		Error Configure (TAG __far *tags);
		Error Preempt (VirtualUnit *previous);

		Error VirtualI22PIP::GrabExpandFrame (FPTR base, WORD sourceWidth, WORD sourceHeight, WORD width, WORD height,
		                                      WORD stride, GrabFormat fmt);
	};



#endif // ONLY_EXTERNAL_VISIBLE



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\videodma\specific\dummypip.h ===
//
// FILE:      library\hardware\videodma\specific\dummypip.h
// AUTHOR:    Viona
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   05.12.95
//
// PURPOSE:   
//
// HISTORY:
#ifndef DUMMYPIP_H
#define DUMMYPIP_H

#include "..\generic\pip.h"

class DummyPIP : public PIP
	{
	private:
		BOOL			changed;
		int			dstLeft, dstTop, dstWidth, dstHeight;
		HWND			win;
		BOOL			adaptClientSize;
		BOOL			enabled;
		HINSTANCE   hinst;
	protected:
		Error SetDestRect(int left, int top, int width, int height);
		Error SetWindow(HWND win);
		Error Update(void);       
		Error UpdateDisplay(void);
		Error SetAdaptClientSize(BOOL adaptClientSize);
		Error EnablePIP(BOOL enable);

		int GetDisplayLeft(void) {return 0;}
		int GetDisplayTop(void) {return 0;}
		int GetDisplayWidth(void) {return dstWidth;}
		int GetDisplayHeight(void) {return dstHeight;}

		Error SetVideoStandard(VideoStandard std) {GNRAISE_OK;}
		Error SetSampleMode(VideoSampleMode mode) {GNRAISE_OK;}
		Error SetHOffset(int offset) {GNRAISE_OK;}
		Error SetVOffset(int offset) {GNRAISE_OK;}
		Error SetSourceRect(int left, int top, int width, int height) {GNRAISE_OK;}
		Error GrabFrame(FPTR base, WORD width, WORD height, 
		                        WORD stride, GrabFormat fmt) {GNRAISE_OK;}
		Error SetAdaptSourceSize(BOOL adaptSourceSize) {GNRAISE_OK;}
		Error SetScreenDest(BOOL screenDest) {GNRAISE_OK;}

		Error SetSourceCrop(int left, int top, int right, int bottom) {GNRAISE_OK;}

		virtual Error SetOffscreenOverride(BOOL offscreen) {GNRAISE_OK;}
		virtual Error SetOffscreenBase(FPTR base) {GNRAISE_OK;}
		virtual Error SetOffscreenBytesPerRow(WORD bpr) {GNRAISE_OK;}
		virtual Error SetOffscreenPixelFormat(PIPFormat format) {GNRAISE_OK;}

		virtual Error InitGrabStream (StreamCaptureHookHandle hook, DWORD milliSecPerFrame,
		                              WORD width, WORD height, WORD stride, GrabFormat format) {GNRAISE_OK;}
		virtual Error FinishGrabStream (void) {GNRAISE_OK;}
		virtual Error StartGrabStream (void) {GNRAISE_OK;}
		virtual Error StopGrabStream (void) {GNRAISE_OK;}
		
		FPTR GetStreamGrabBuffer() {GNRAISE_OK;}
	
		Error StartGrabYStream(YStreamCaptureHookHandle hook,
		                               int left, int top,
		                               WORD width, WORD height) {GNRAISE_OK;}
		Error StopGrabYStream(void) {GNRAISE_OK;}		
		Error SupplyStreamGrabBuffer(HPTR buffer) {GNRAISE_OK;}
		
		VirtualUnit * CreateVirtual(void);
	public:
		DummyPIP(HINSTANCE hinst) {this->hinst = hinst;}
	};
	

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\videodma\specific\S7146pip.h ===
// FILE:      library\hardware\videodma\specific\s7146pip.h
// AUTHOR:    Dietmar Heidrich, S. Herr
// COPYRIGHT: (c) 1996 Viona Development.  All Rights Reserved.
// CREATED:   03.10.96
//
// PURPOSE: The PIP-related classes for the SAA7146.
//
// HISTORY:

#ifndef SAA7146PIP_H
#define SAA7146PIP_H

#ifndef ONLY_EXTERNAL_VISIBLE

#include "library\lowlevel\memmpdio.h"
#include "library\lowlevel\dmabuffr.h"
#include "library\hardware\videodma\generic\gfxconfg.h"
#include "library\lowlevel\intrctrl.h"
#include "library\hardware\pcibrdge\specific\saa7146\saa7146.h"
#include "library\hardware\pcibrdge\specific\saa7146\rps7146.h"

#endif


#include "library\hardware\videodma\generic\dmapip.h"
#include "library\hardware\pcibrdge\specific\saa7146\saa7146r.h"



// Maximum values for destination rectangle size.

#define PIP_WIDTH_MAX   720
#define PIP_HEIGHT_MAX  576



// DMA configuration. Entries are measured in DWORDs.

class DMAConfig7146
	{
	public:
		int dataThreshold, dataBurst;   // video data channel
		int maskThreshold, maskBurst;   // mask data channel

		DMAConfig7146 (void) {dataThreshold = 32; dataBurst = 64; maskThreshold = 32; maskBurst = 64;}
	};



enum PIPDisplayMode
	{
	PDMD_AUTOMATIC
	};



// Error definitions.

#define GNR_DMA_PIP_NOT_POSSIBLE		MKERR(ERROR, PIP, GENERAL, 0x01)		// current screen mode does not allow DMA PIP
#define GNR_VIDEO_STD_NOT_SUPPORTED	MKERR(ERROR, PIP, GENERAL, 0x02)		// desired video standard (e.g. SECAM) not supported
#define GNR_PIP_NOT_RUNNING			MKERR(ERROR, PIP, GENERAL, 0x03)		// PIP is not running when trying to execute OptimizeBuffer()
#define GNR_NO_OPTIMAL_MINPIX			MKERR(ERROR, PIP, GENERAL, 0x04)		// no optimal minPix value could be found by OptimizeBuffer()
#define GNR_DEST_RECT_SIZE				MKERR(ERROR, PIP, GENERAL, 0x05)		// destination rectangle too small or too big
#define GNR_WRONG_GRAB_SIZE			MKERR(ERROR, PIP, GENERAL, 0x06)		// dimensions of frame to grab are too big
#define GNR_NO_VBLANK_IRQ				MKERR(ERROR, PIP, GENERAL, 0x07)		// expected VBlank IRQ did not occur
#define GNR_GRAB_TIMEOUT				MKERR(ERROR, PIP, GENERAL, 0x08)		// timeout occurred during frame grab
#define GNR_WRONG_GRAB_FORMAT			MKERR(ERROR, PIP, GENERAL, 0x09)		// unsupported capture format was requested
#define GNR_SAMPLEMODE_NOT_SUPPORTED	MKERR(ERROR, PIP, GENERAL, 0x0a)		// desired video sample mode not supported

#ifndef ONLY_EXTERNAL_VISIBLE



#define VBLANK_TIMEOUT 100				// milliseconds
#define GRAB_TIMEOUT	  1000			// milliseconds



class SAA7146PIPSetting
	{
	public:
		DWORD ctrl, vertScale, vertGain, preScale, fineScale, output, bcsCtrl;   // HPS registers
		DWORD baseOdd1, baseEven1, protAddr1, pitch1, basePage1, lineByte1;  // video DMA 1 registers
		DWORD baseOdd2, baseEven2, protAddr2, pitch2, basePage2, lineByte2;  // video DMA 2 registers
		BOOL switchOn;
		BOOL useMask;
		BOOL useMMU;   // target is mapped by MMU pages
		BOOL invertFieldPolarity;

		// Page table stuff (if "useMMU").
		SAA7146PageTable *pageTable;
		DWORD pageTablePhysical;

		SAA7146PIPSetting (void)
			{
			switchOn = FALSE;
			useMMU = FALSE;
			pageTable = NULL;
			pageTablePhysical = NULL;
			}

		~SAA7146PIPSetting (void)
			{
			delete pageTable;
			pageTable = NULL;
			pageTablePhysical = NULL;
			}

		void Free (void)
			{
			delete pageTable;
			pageTable = NULL;
			pageTablePhysical = NULL;
			}
	};



class PrepInfoPIP7146 : public PrepInfoPIP
	{
	protected:
		class SAA7146PIP *pip;
		SAA7146PIPSetting setting;
		PIPFormat pipFormat;
		WORD width, height;
		DWORD bytesPerLine;
		RPSProgram *rps;
	public:
		PrepInfoPIP7146 (class SAA7146PIP *pip, PIPFormat pipFormat, WORD width, WORD height, DWORD bytesPerLine);

		virtual Error Prepare (FPTR buffer, DWORD size);
		virtual Error Unprepare (void);

		Error GetPhysicalCodeAddress (DWORD __far &physical) {return rps->GetPhysicalCodeAddress (physical);}

		DWORD captureTime;
	};



class SAA7146PIPVBlankIntHandler;



// Physical SAA7146 Masked DMA PIP class.

class SAA7146PIP : public MaskDMAPIP
	{
	friend class VirtualSAA7146PIP;
	friend class SAA7146PIPVBlankIntHandler;
	friend class PrepInfoPIP7146;

	protected:
		SAA7146 *saa7146;
		MemoryMappedIO *io;					// SAA7146 registers
		Profile *profile;

		// Screen parameters.
		GraphicConfig *gfxConfig;			// info about current graphics board and screen mode
	   DWORD physicalBase;
		WORD bytesPerRow;
		PIPFormat pixelFormat;

		// Masking.
		ContinuousDMABuffer maskBuffer;
		FPTR maskDataPointer;
		DWORD maskPhysical;
		WORD maskRowDWords;									// DWORDs per mask row


		BOOL							grabMode;				// The PIP object is in grabbing mode, when this flag is TRUE.

		HardVideoParams 			ntscSQP, palSQP, ntscCCIR, palCCIR;
		const HardVideoParams* 	curVideoParams;		// Pointer to the settings of the current video standard.

		VideoStandard 				curVideoStd;			// Contains the current video standard.
		VideoSampleMode			sampleMode;
		int							hOffset, vOffset;
		DWORD							dispgrab;



		int srcLeft, srcTop;
		WORD srcWidth, srcHeight;			// source rectangle dimensions


		// 7146 specific parameters.
		HPSSource7146 dataSource;
		HPSSyncs7146 syncSource;
		BOOL useDither;						// for 16 and 15 bit modes
		BOOL maskEnabled;						// if FALSE, DMA is always on top

		DMAConfig7146 dmaConfig;


		WORD	ConvertGrabFormat(GrabFormat format);	// Converts destination format to the YUV2RGB register value. 
		WORD	ConvertPIPFormat(PIPFormat format);		// Same for PIP format. In both functions packed24 is set
																	// in respect to 24 or 32 bit mode.
		int	GetPixelSize (GrabFormat type);			// Get size of a pixel for a certain format.

		Error WaitVBlankIRQ(WORD count);					// Wait for the number of "count" VSYNC IRQs to occur.

		BOOL	adaptSourceSize;								// Tells, if the source rectangle is adapted to the video
																	// standard.
		SAA7146PIPVBlankIntHandler	* vBlankIntHandler;	// VBlank handler.
		InterruptServer 			* vBlankIntServer;	// Interrupt server.

		SAA7146PIPSetting				pipSetting, grabSetting;
		SAA7146PIPSetting	__far	*	currentPIPSetting;

		ContinuousDMABuffer	*	captureDMA;

		FPTR							captureDMABuffer;
		DWORD							captureDMADWordsPerRow;

		HPTR							captureBuffer;
		DWORD							captureDWordsPerRow;

		WORD							captureHeight;

		StreamCaptureHook		*	captureHook;
		YStreamCaptureHook	*	yCaptureHook;

	protected:
		int dmaSuspended;										// Internal DMA suspension flag.

		void 	VBlankInterrupt(void);						// VBlank (VSYNC) IRQ routine.
		DWORD volatile vBlankCount;						// Tells us, how many vertical blank IRQs happened.

		Error StopDMA(void);									// Stops DMA.
		Error StartDMA(void);								// Starts DMA.
		Error EnablePIP(BOOL enable);						// Enables PIP in general.

		Error Update(void);									// Updates all PIP parameters.

		virtual Error CalculateSettings (SAA7146PIPSetting __far &setting, FPTR dstLogical,
													DWORD dstPhysical, DWORD bytesPerLine, WORD lines,
													PIPFormat pixelFormat,
													BOOL targetIsDIB, BOOL useMask, WORD maskDWordsPerRow,
													BOOL singleShot,
													int left, int top, WORD width, WORD height);

		Error ProgramSettings (SAA7146PIPSetting __far &setting, BOOL startLater = FALSE);

		Error ProgramAll(void);								// Reprograms all DMA PIP/grab registers of the SAA7146.

		Error SetMask(RectBitMap * map);
		Error SetSourceRect(int left, int top, int width, int height);
		Error SetVideoStandard(VideoStandard std);
		Error SetSampleMode(VideoSampleMode sampleMode);
		Error SetHOffset(int offset);
		Error SetVOffset(int offset);
		Error SetAdaptSourceSize(BOOL adaptSourceSize);

		Error SetDataSource (HPSSource7146 dataSource);
		Error SetSyncSource (HPSSyncs7146 syncSource);
		Error SetUseDither (BOOL useDither);
		Error SetMaskEnable (BOOL enable);

		Error SetSourceCrop (int left, int top, int right, int bottom);

		Error GrabFrame (FPTR base, WORD width, WORD height, WORD stride, GrabFormat format);

		Error GrabExpandFrame (FPTR base, WORD width, WORD height, WORD stride, GrabFormat format,
		                       RPSProgram *playProgram, BOOL allowMultipleRun);


		virtual Error InitGrabStream (StreamCaptureHookHandle hook, DWORD milliSecPerFrame,
		                              WORD width, WORD height, WORD stride, GrabFormat format);
		virtual Error FinishGrabStream (void);
		virtual Error StartGrabStream (void);
		virtual Error StopGrabStream (void);
		virtual PrepInfoPIP *CreatePrepInfo (void);

		typedef struct CaptureParameters2
			{
			PIPFormat pipFormat;
			DWORD bytesPerLine;
			PrepInfoPIP7146 *captureBuffer;
			BOOL capturedInBuffer;
			BOOL singleField;
			LinkedQueue activePipe;
			int nextBuffer, lastBuffer;
			int nBuffers;   // active buffers
			DWORD irqCounter;
			};
		CaptureParameters2 capture2;
		RPSProgram *grabProgram;
		RPSProgram *screenPrg;


		FPTR	GetStreamGrabBuffer (void);

		Error StartGrabYStream(YStreamCaptureHookHandle hook,
		                       int left, int top,
		                       WORD width, WORD height);
		Error StopGrabYStream(void);
		Error SupplyStreamGrabBuffer(HPTR buffer);

		Error	StoreConfig (DMAConfig7146 *config);
		Error RetrieveConfig (DMAConfig7146 *config);

		int HorizontalAlign (void);		// alignment for SAA7146 PIP in pixels (DWORD aligned, e.g. 24 bit
													// modes need a different alignment than 16 or 15 bit)
		int VerticalAlign (void);

		int MaxDestWidth(void) {return srcWidth;}		// maximum horizontal size of the destination rectangle
		int MaxDestHeight(void) {return srcHeight;}	// maximum vertical size of the destination rectangle

		// For the SAA7146, we need a bitmap with first pixel represented by the MSB.
		RectBitMap *CreateDMAMap (int left, int top, int width, int height)
			{return new RectBitMap (left, top, width, height, 0L, RectBitMap::BITLAYOUT_FIRST_BIT7);}

	public:
		SAA7146PIP (HINSTANCE hinst, SAA7146 *saa7146, MemoryMappedIO *io, InterruptServer *vblankIntServer,
		            Profile *profile);
		~SAA7146PIP(void);

		VirtualUnit *CreateVirtual (void);

		Error ReadConfig (char *filename);				// Allows to read advanced parameters from a configuration file.
		Error Initialize(void);								// Initializes the SAA7146 PIP. Call after the object was constructed.

		Error SuspendDMA(void);								// Nested DMA disabe.
		Error ResumeDMA(void);								// Nested DMA enable.

#if NT_KERNEL || VXD_VERSION
		virtual Error SetPIPBases (DWORD physicalBase, WORD bytesPerRow, PIPFormat pixelFormat);
#elif VIONA_VERSION		
		Error Reconfigure(void);
		BOOL	ScreenModeChanged(void);
#endif
	};



// Virtual SAA7146 PIP.

class VirtualSAA7146PIP : public VirtualMaskDMAPIP 
	{
	friend class SAA7146PIP;

	private:
		SAA7146PIP *unit;

	protected:
		HPSSource7146 dataSource;
		HPSSyncs7146 syncSource;
		BOOL useDither;   // for 16 and 15 bit modes
		BOOL maskEnabled;

		Error Preempt (VirtualUnit *previous);

	public:
		VirtualSAA7146PIP (SAA7146PIP *physical);

		Error Configure (TAG __far *tags);

		Error GrabExpandFrame (FPTR base, WORD width, WORD height, WORD stride, GrabFormat fmt,
		                       RPSProgram *playProgram);
	};



#endif // ONLY_EXTERNAL_VISIBLE



// SAA7146 PIP specific tags.

MKTAG (PIP_DATA_SOURCE,		PIP_UNIT, 0x00000030, HPSSource7146)	// port A or B or combined
MKTAG (PIP_SYNC_SOURCE,		PIP_UNIT, 0x00000031, HPSSyncs7146) 	// port A or B
MKTAG (PIP_USE_DITHER,		PIP_UNIT, 0x00000032, BOOL)				// use dither for 15/16 bit ?
MKTAG (PIP_MASK_ENABLE,		PIP_UNIT, 0x00000033, BOOL)				// mask enable/disable switch
MKTAG (PIP_DISPLAY_MODE, 	PIP_UNIT, 0x00000034, PIPDisplayMode) 	// DispMode selection
MKTAG (PIP_EXT_FIELD_IND,  PIP_UNIT, 0x00000035, BOOL)				// ExtFI mode selection



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\videodma\specific\vpmpip.h ===
// FILE:      library\hardware\videodma\generic\vpmpip.h
// AUTHOR:    S. Herr
// COPYRIGHT: (c) 1997 Viona Development GmbH. All Rights Reserved.
// CREATED:   25.04.97
//
// PURPOSE:   PIP class for VPM controlled video ports.
//
// HISTORY:

#ifndef VPMPIP_H
#define VPMPIP_H

#if !NT_KERNEL && !VXD_VERSION
#include <windows.h>
#endif

#include "..\generic\vportpip.h"

//#include "vpm.h"
#include "y:\vpmsdk\vpm.h"
#include "library\common\profiles.h"

class VPMPIP : public VideoPortPIP
	{
	friend class VirtualVPMPIP;

	private:
#if !NT_KERNEL && !VXD_VERSION
		HINSTANCE		vpmHandle;
		LPVPMDRIVERPROC vpmProc;

		DDSURFACEDESC	desc;

		BOOL				alwaysOverlay;

		VideoPortCaps	decoderCaps;

		LPVPMPROVIDER	vpmProvider;
		LPVPMSTREAM		stream;			// The VPM stream
		VPMCONFIG		streamConfig;	// The valid VPM configuration for our stream

		DWORD				globalCapFlags;
		DWORD				usedPort;
		
		char				messageTitle[32];
#endif
		BOOL				embeddedSyncs;

		int 				transferSuspended;
                     
		PrepInfoPIP		*captureBuffer;

		DWORD				yCaptureDMADWordsPerRow;
//		DWORD				yCaptureDWordsPerRow;
		WORD				yCaptureHeight;
		FPTR				yCaptureBuffer;

		YStreamCaptureHookHandle	yCaptureHook;
		
		StreamCaptureHookHandle		captureHook;

		long				dispLeft, dispTop, dispWidth, dispHeight;

		long				dWidth, dHeight;
		long				xOffset, yOffset;

		WORD				screenWidth, screenHeight;
		
		Profile			*profile;
		
		BOOL				vpmDisplayRunning;
		
		BOOL				verticalOffset;
		BOOL				tsengSpecials;
		BOOL				s3Specials;
		BOOL				enableColorControl;
	protected:
		int GetDisplayLeft(void);
		int GetDisplayTop(void);
		int GetDisplayWidth(void);
		int GetDisplayHeight(void);
		
		Error GrabFrame(FPTR base, WORD width, WORD height, WORD stride, GrabFormat fmt);

		// Y capture streaming.
		Error StartGrabYStream (YStreamCaptureHookHandle hook, int left, int top, WORD width, WORD height);
		Error StopGrabYStream (void);

		Error Update(void);

		Error StartVPMDisplay(void);
		Error StopVPMDisplay(void);
		
		Error StartVideoDisplay(void);
		Error StopVideoDisplay(void);
		Error MovePIP(void);
		Error SizePIP(void);

		// VPM Helper functions
		Error	CalculateVPMSettings(void);
		void	CalculateVPMSrcRect(void);

		Error AdaptNSetVPMSettings(void);

		BOOL	KillAField(void);

		long 	HalveWidth();
		long 	HalveHeight();
		long	ReduceMemoryConsumption();

		Error FindPortMatch(VPMCONFIG __far & inConfig,
								  VPMCONFIG __far & outConfig,
								  const VideoPortCaps __far & inCaps,
								  VideoPortCaps __far & usedCaps);
		
		BOOL	CheckPort(DWORD type, VPMCONFIG __far & inConfig, VPMCONFIG __far & outConfig);

		WORD  GetColorControl();
		Error SetColorControlValues(ColorControlValues __far & clrCtrl);

		int	numVirtualUnits;

		Error NotifyUnitCreate(void);
		Error NotifyUnitDelete(void);
	public:
		VPMPIP(HINSTANCE hinst, InterruptServer * vblankIntServer, Profile * profile);
		~VPMPIP(void);

		VirtualUnit * CreateVirtual(void);

		virtual Error Reconfigure(void);

		// Use this to get a valid connection to the port. If error, then the port PIP cannot be used.
		virtual Error MatchPortCaps(const VideoPortCaps __far & inCaps, VideoPortCaps __far & usedCaps);

		Error Initialize(void);
		
		Error SuspendDMA(void);
		Error ResumeDMA(void);
	};


	
class VirtualVPMPIP : public VirtualVideoPortPIP
	{
	friend class VPMPIP;
	
	private:
		VPMPIP	*	unit;
	
	public:
		VirtualVPMPIP(VPMPIP	* unit) : VirtualVideoPortPIP(unit) {this->unit = unit;}
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\wavelet\generic\Wcore.h ===
// FILE:      library\hardware\wavelet\generic\wcore.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1996 Viona Development.  All Rights Reserved.
// CREATED:   07.05.96
//
// PURPOSE: The virtualized Wavelet core.
//
// HISTORY:

#ifndef WAVELETCORE_H
#define WAVELETCORE_H

#include "library\common\prelude.h"
#include "library\common\gnerrors.h"
#include "library\common\tags.h"
#include "library\common\hooks.h"
#include "library\common\virtunit.h"
#include "library\hardware\jpeg\generic\jpegdefs.h"



#ifndef ONLY_EXTERNAL_VISIBLE



class WaveletManager : public PhysicalUnit
	{
	public:
		virtual void Start (void) = 0;
		virtual void Stop  (void) = 0;
	};



class VirtualWaveletUnit : public VirtualUnit
	{
	public:
		VirtualWaveletUnit (WaveletManager *physical);
		virtual ~VirtualWaveletUnit (void);

		virtual Error Configure (TAG __far *tags);

		virtual Error PrepareBuffer (FPTR buffer, DWORD size, FPTR __far &info) = 0;
		virtual Error UnprepareBuffer (FPTR info) = 0;

		virtual Error ExpandToRGB (FPTR src, DWORD size, FPTR dst, WORD dstWidth, WORD dstHeight, GrabFormat bitFormat) = 0;
		virtual BOOL IsValidExpansionScaling (WORD srcWidth, WORD srcHeight, WORD dstWidth, WORD dstHeight, GrabFormat bitFormat) = 0;

		virtual Error CompressFromRGB (FPTR src, FPTR dst, DWORD maxSize, DWORD __far &size, BOOL bits32) = 0;
		virtual BOOL IsValidCompression (WORD width, WORD height, BOOL bits32) = 0;

		// These are allowed only after locking and activating the unit.
		virtual Error InitCapture (JPEGCaptureHook __far *hook) = 0;
		virtual Error FinishCapture (void) = 0;
		virtual Error AddVideoBuffer (FPTR info, FPTR userData, DWORD size) = 0;
		virtual Error Start (void);
		virtual Error Stop  (void);
		virtual Error AllocateVideoBuffer (DWORD size, FPTR __far &info, FPTR __far &data) = 0;
		virtual Error FreeVideoBuffer (FPTR info) = 0;
		virtual Error InitPlayback (JPEGPlaybackHook __far *hook) = 0;
		virtual Error FinishPlayback (void) = 0;
		virtual Error FlushPlayback (DWORD bufferSize) = 0;
		virtual Error PlayBuffer (FPTR info, DWORD size) = 0;

	protected:
		virtual Error Preempt (VirtualUnit *previous) = 0;

		BOOL changed;      // TRUE if Configure() changed a variable
		BOOL compress;
		BOOL stillMode;
		int top, left;
		WORD width, height;
	};



#endif // ONLY_EXTERNAL_VISIBLE



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\videodma\specific\vpepip.h ===
// FILE:      library\hardware\videodma\specific\vpepip.h
// AUTHOR:    S. Herr
// COPYRIGHT: (c) 1997 Viona Development GmbH. All Rights Reserved.
// CREATED:   12.08.97
//
// PURPOSE:   PIP class for DirectX 5/VPE controlled video ports. Implementation.
//
// HISTORY:

#ifndef VPEPIP_H
#define VPEPIP_H

#if !NT_KERNEL && !VXD_VERSION
#include <windows.h>
#include "library\lowlevel\memmpdio.h"
#endif

#include "..\generic\vportpip.h"
#include "..\generic\clrkeymg.h"
#include "library\common\krnlsync.h"

#include "library\common\profiles.h"

class VPEPIP : public VideoPortPIP
	{
	friend class VirtualVPEPIP;

	private:
#if !NT_KERNEL && !VXD_VERSION
		DDSURFACEDESC	desc;
		DDAccess			ddAccess;

		BOOL				colorKeyed;
		BOOL				alwaysOverlay;

		VideoPortCaps	decoderCaps;
		
		char				messageTitle[32];
#endif
		BOOL				embeddedSyncs;

		int 				transferSuspended;
                     
		PrepInfoPIP		*captureBuffer;

		DWORD				yCaptureDMADWordsPerRow;
//		DWORD				yCaptureDWordsPerRow;
		WORD				yCaptureHeight;
		FPTR				yCaptureBuffer;

		YStreamCaptureHookHandle	yCaptureHook;
		
		StreamCaptureHookHandle		captureHook;

		long				dispLeft, dispTop, dispWidth, dispHeight;

		long				dWidth, dHeight;
		long				xOffset, yOffset;

		WORD				screenWidth, screenHeight;
		
		Profile			*profile;
		
		BOOL				vpeDisplayRunning;
		BOOL				restartVPE;
		BOOL				vpeDisplayInUse;
		
		MemoryMappedIO	nvidiaRegs;
		BOOL				nvidiaColorPatch;
		WORD				nvidiaBrightness;
		WORD				nvidiaRedBrightness;
		WORD				nvidiaBlueBrightness;
		WORD				nvidiaGreenBrightness;
		int				nvidiaBaseR;
		int				nvidiaBaseG;
		int				nvidiaBaseB;
		BOOL				nvidiaTable;
		BOOL				nvidiaDelayTime;
		BOOL				permedia2Patch;
		
		BOOL				needPaintMsg;
		
		BOOL				nvidiaFixBob;

		int				numVirtualUnits;
		
		ColorController	* colorController;
	protected:
		int GetDisplayLeft(void);
		int GetDisplayTop(void);
		int GetDisplayWidth(void);
		int GetDisplayHeight(void);
		
		Error GrabFrame(FPTR base, WORD width, WORD height, WORD stride, GrabFormat fmt);

		// Y capture streaming.
		Error StartGrabYStream (YStreamCaptureHookHandle hook, int left, int top, WORD width, WORD height);
		Error StopGrabYStream (void);

		Error Update(void);

		Error DeferedStartVPEDisplay(void);
		Error StartVPEDisplay(void);
		Error StopVPEDisplay(void);   
		
		Error RegainSurface(void);
		
		Error StartVideoDisplay(void);
		Error StopVideoDisplay(void);
		Error MovePIP(void);
		Error SizePIP(void);

		WORD  GetColorControl();
		Error SetColorControlValues(ColorControlValues __far & clrCtrl);
		
		Error StillSequenceChanged(void);
		Error ContentTypeChanged(void);
		
		Error NotifyUnitCreate(void);
		Error NotifyUnitDelete(void);

		Error RedrawBackground(void);
		Error PaintNoOverlayMsg(void);
	public:
		VPEPIP(HINSTANCE hinst, InterruptServer * vblankIntServer, Profile * profile,
				 VideoPortController	*	videoPortController = 0,
				 ColorController * colorController = 0);
		~VPEPIP(void);

		VirtualUnit * CreateVirtual(void);

		virtual Error Reconfigure(void);

		// Use this to get a valid connection to the port. If error, then the port PIP cannot be used.
		virtual Error MatchPortCaps(const VideoPortCaps __far & inCaps, VideoPortCaps __far & usedCaps);

		Error Initialize(void);
		
		Error SuspendDMA(void);
		Error ResumeDMA(void);
	};


	
class VirtualVPEPIP : public VirtualVideoPortPIP
	{
	friend class VPEPIP;
	
	private:
		VPEPIP	*	unit;
	
		void Message(WPARAM wParam, LPARAM dParam);
	public:
		VirtualVPEPIP(VPEPIP	* unit) : VirtualVideoPortPIP(unit) {this->unit = unit;}
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\lowlevel\TIMER.H ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


// FILE:      library\lowlevel\timer.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   17.03.95
//
// PURPOSE: The timer class.
//
// HISTORY:

#ifndef TIMER_H
#define TIMER_H

#include "..\common\prelude.h"

class TimerClass {
	private:
		static int timerClassInited;
		static int nanoDelay;
	public:
		TimerClass (void);
		virtual void WaitMicroSecs (DWORD micros);
		virtual void WaitMilliSecs (DWORD millis);
		virtual DWORD GetMilliTicks (void);
		virtual DWORD GetMicroTicks (void);
	};


#if VXD_VERSION

class VxDTimerClass : public TimerClass
	{
	private:
		DWORD	vxdTimerHandle;

	public:
		VxDTimerClass(DWORD vxdTimerHandle) {this->vxdTimerHandle = vxdTimerHandle;}

		void WaitMilliSecs (DWORD millis);
	};

#define Timer (*globalTimer)
extern TimerClass * globalTimer;

#elif NT_KERNEL

#define Timer (*globalTimer)
extern TimerClass * globalTimer;

#else

extern TimerClass Timer;

#endif // VXD_VERSION



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\support\aspi32\WNASPI32.H ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

//***************************************************************************
//
// Name: 	      WNASPI32.H
//
// Description:	ASPI for Win32 definitions ('C' Language)
//
//***************************************************************************

#ifndef WNASPI32_H
#define WNASPI32_H


#ifdef __cplusplus
extern "C" {
#endif

typedef void *LPSRB;
typedef void (*PFNPOST)();

DWORD __cdecl SendASPI32Command    (LPSRB);
DWORD __cdecl GetASPI32SupportInfo (VOID);

#define SENSE_LEN					14			// Default sense buffer length
#define SRB_DIR_SCSI				0x00		// Direction determined by SCSI 															// command
#define SRB_DIR_IN					0x08		// Transfer from SCSI target to 															// host
#define SRB_DIR_OUT					0x10		// Transfer from host to SCSI 															// target
#define SRB_POSTING					0x01		// Enable ASPI posting
#define SRB_EVENT_NOTIFY            0x40        // Enable ASPI event notification
#define SRB_ENABLE_RESIDUAL_COUNT	0x04		// Enable residual byte count 															// reporting
#define SRB_DATA_SG_LIST			0x02		// Data buffer points to 																	// scatter-gather list
#define WM_ASPIPOST					0x4D42		// ASPI Post message
//***************************************************************************
//						 %%% ASPI Command Definitions %%%
//***************************************************************************
#define SC_HA_INQUIRY				0x00		// Host adapter inquiry
#define SC_GET_DEV_TYPE				0x01		// Get device type
#define SC_EXEC_SCSI_CMD			0x02		// Execute SCSI command
#define SC_ABORT_SRB				0x03		// Abort an SRB
#define SC_RESET_DEV				0x04		// SCSI bus device reset
#define SC_GET_DISK_INFO			0x06		// Get Disk information

//***************************************************************************
//								  %%% SRB Status %%%
//***************************************************************************
#define SS_PENDING			0x00		// SRB being processed
#define SS_COMP				0x01		// SRB completed without error
#define SS_ABORTED			0x02		// SRB aborted
#define SS_ABORT_FAIL		0x03		// Unable to abort SRB
#define SS_ERR 				0x04		// SRB completed with error

#define SS_INVALID_CMD		0x80		// Invalid ASPI command
#define SS_INVALID_HA		0x81		// Invalid host adapter number
#define SS_NO_DEVICE		0x82		// SCSI device not installed

#define SS_INVALID_SRB		0xE0		// Invalid parameter set in SRB
#define SS_FAILED_INIT		0xE4		// ASPI for windows failed init
#define SS_ASPI_IS_BUSY		0xE5		// No resources available to execute cmd
#define SS_BUFFER_TO_BIG	0xE6		// Buffer size to big to handle!

//***************************************************************************
//							%%% Host Adapter Status %%%
//***************************************************************************
#define HASTAT_OK					0x00	// Host adapter did not detect an 															// error
#define HASTAT_SEL_TO				0x11	// Selection Timeout
#define HASTAT_DO_DU				0x12	// Data overrun data underrun
#define HASTAT_BUS_FREE				0x13	// Unexpected bus free
#define HASTAT_PHASE_ERR			0x14	// Target bus phase sequence 																// failure
#define HASTAT_TIMEOUT				0x09	// Timed out while SRB was 																	waiting to beprocessed.
#define HASTAT_COMMAND_TIMEOUT 		0x0B	// While processing the SRB, the
															// adapter timed out.
#define HASTAT_MESSAGE_REJECT		0x0D	// While processing SRB, the 																// adapter received a MESSAGE 															// REJECT.
#define HASTAT_BUS_RESET			0x0E	// A bus reset was detected.
#define HASTAT_PARITY_ERROR			0x0F	// A parity error was detected.
#define HASTAT_REQUEST_SENSE_FAILED	0x10	// The adapter failed in issuing
														//   REQUEST SENSE.

//***************************************************************************
//			 %%% SRB - HOST ADAPTER INQUIRY - SC_HA_INQUIRY %%%
//***************************************************************************
typedef struct {
	BYTE	SRB_Cmd;				// ASPI command code = SC_HA_INQUIRY
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// ASPI request flags
	DWORD	SRB_Hdr_Rsvd;			// Reserved, MUST = 0
	BYTE	HA_Count;				// Number of host adapters present
	BYTE	HA_SCSI_ID;				// SCSI ID of host adapter
	BYTE	HA_ManagerId[16];		// String describing the manager
	BYTE	HA_Identifier[16];		// String describing the host adapter
	BYTE	HA_Unique[16];			// Host Adapter Unique parameters
	WORD	HA_Rsvd1;

} SRB_HAInquiry, *PSRB_HAInquiry;

//***************************************************************************
//			  %%% SRB - GET DEVICE TYPE - SC_GET_DEV_TYPE %%%
//***************************************************************************
typedef struct {

	BYTE	SRB_Cmd;				// ASPI command code = SC_GET_DEV_TYPE
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// Reserved
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	BYTE	SRB_Target;				// Target's SCSI ID
	BYTE	SRB_Lun;				// Target's LUN number
	BYTE	SRB_DeviceType;			// Target's peripheral device type
	BYTE	SRB_Rsvd1;

} SRB_GDEVBlock, *PSRB_GDEVBlock;

//***************************************************************************
//		  %%% SRB - EXECUTE SCSI COMMAND - SC_EXEC_SCSI_CMD %%%
//***************************************************************************

typedef struct {
	BYTE	SRB_Cmd;				// ASPI command code = SC_EXEC_SCSI_CMD
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// ASPI request flags
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	BYTE	SRB_Target;				// Target's SCSI ID
	BYTE	SRB_Lun;				// Target's LUN number
	WORD 	SRB_Rsvd1;				// Reserved for Alignment
	DWORD	SRB_BufLen;				// Data Allocation Length
	BYTE	*SRB_BufPointer;		// Data Buffer Pointer
	BYTE	SRB_SenseLen;			// Sense Allocation Length
	BYTE	SRB_CDBLen;				// CDB Length
	BYTE	SRB_HaStat;				// Host Adapter Status
	BYTE	SRB_TargStat;			// Target Status
	void	*SRB_PostProc;			// Post routine
	void	*SRB_Rsvd2;				// Reserved
	BYTE	SRB_Rsvd3[16];			// Reserved for alignment
	BYTE	CDBByte[16];			// SCSI CDB
	BYTE	SenseArea[SENSE_LEN+2];	// Request Sense buffer

} SRB_ExecSCSICmd, *PSRB_ExecSCSICmd;

//***************************************************************************
//				  %%% SRB - ABORT AN SRB - SC_ABORT_SRB %%%
//***************************************************************************
typedef struct {

	BYTE	SRB_Cmd;				// ASPI command code = SC_EXEC_SCSI_CMD
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// Reserved
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	void	*SRB_ToAbort;			// Pointer to SRB to abort

} SRB_Abort, *PSRB_Abort;

//***************************************************************************
//				%%% SRB - BUS DEVICE RESET - SC_RESET_DEV %%%
//***************************************************************************
typedef struct {

	BYTE	SRB_Cmd;				// ASPI command code = SC_EXEC_SCSI_CMD
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// Reserved
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	BYTE	SRB_Target;				// Target's SCSI ID
	BYTE	SRB_Lun;				// Target's LUN number
	BYTE 	SRB_Rsvd1[12];			// Reserved for Alignment
	BYTE	SRB_HaStat;				// Host Adapter Status
	BYTE	SRB_TargStat;			// Target Status
	void 	*SRB_PostProc;			// Post routine
	void	*SRB_Rsvd2;				// Reserved
	BYTE	SRB_Rsvd3[16];			// Reserved
	BYTE	CDBByte[16];			// SCSI CDB

} SRB_BusDeviceReset, *PSRB_BusDeviceReset;

//***************************************************************************
//				%%% SRB - GET DISK INFORMATION - SC_GET_DISK_INFO %%%
//***************************************************************************
typedef struct {

	BYTE	SRB_Cmd;				// ASPI command code = SC_EXEC_SCSI_CMD
	BYTE	SRB_Status;				// ASPI command status byte
	BYTE	SRB_HaId;				// ASPI host adapter number
	BYTE	SRB_Flags;				// Reserved
	DWORD	SRB_Hdr_Rsvd;			// Reserved
	BYTE	SRB_Target;				// Target's SCSI ID
	BYTE	SRB_Lun;				// Target's LUN number
	BYTE 	SRB_DriveFlags;			// Driver flags
	BYTE	SRB_Int13HDriveInfo;	// Host Adapter Status
	BYTE	SRB_Heads;				// Preferred number of heads translation
	BYTE	SRB_Sectors;			// Preferred number of sectors translation
	BYTE	SRB_Rsvd1[20];			// Reserved
} SRB_GetDiskInfo, *PSRB_GetDiskInfo;


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\wavelet\specific\601regs.h ===
// FILE:      library\hardware\wavelet\specific\601regs.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1996 Viona Development.  All Rights Reserved.
// CREATED:   08.05.96
//
// PURPOSE:   Register definitions for the ADV601 wavelet chip.
// 
// HISTORY:

#ifndef ADV601REGS_H
#define ADV601REGS_H



#define ADV601_NBLOCKS	42





// Indirect register access

#define ADV601REG_INDIRECT		0x00
#define ADV601REG_REGDATA		0x04
#define ADV601REG_COMPDATA		0x08



// Interrupt mask and status register

#define ADV601REG_IRQ			0x0C
#define ADV601IDX_IE_MEMERROR	14
#define ADV601IDX_IE_FIFOSTP	13
#define ADV601IDX_IE_FIFOERR	12
#define ADV601IDX_IE_FIFOSRQ	11
#define ADV601IDX_IE_LCODE		10
#define ADV601IDX_IE_STATR		9
#define ADV601IDX_IE_CCIRER	8
#define ADV601IDX_MEMERROR		6
#define ADV601IDX_FIFOSTP		5
#define ADV601IDX_FIFOERR		4
#define ADV601IDX_FIFOSRQ		3
#define ADV601IDX_LCODE			2
#define ADV601IDX_STATR			1
#define ADV601IDX_CCIRER		0





// Now the indirect 16 bit registers:



// Mode control

#define ADV601REG_MODECONTROL	0x00
#define ADV601IDX_PHIRQ			13
#define ADV601IDX_PHSYNC		12
#define ADV601IDX_SWR			11
#define ADV601IDX_DSP			10
#define ADV601IDX_BUC			9
#define ADV601IDX_SPE			8
#define ADV601IDX_ED				7
#define ADV601IDX_PN				6
#define ADV601IDX_MS				5
#define ADV601IDX_VCLK2			4
#define ADV601IDX_VIF			0, 4

// video interface format (VIF) values
#define ADV601_CCIR656		0x0
#define ADV601_MLTPX			0x2
#define ADV601_PHILIPS		0x3
#define ADV601_GRAYSCALE	0x8



// FIFO control

#define ADV601REG_FIFOCONTROL	0x01
#define ADV601IDX_NES			4, 4
#define ADV601IDX_NFS			0, 4



// Video area registers

#define ADV601REG_HSTART		0x02
#define ADV601REG_HEND			0x03
#define ADV601REG_VSTART		0x04
#define ADV601REG_VEND			0x05



// Compression ratio

#define ADV601REG_COMPRATIO	0x06
#define ADV601IDX_COMPRATIO	0, 8



// 42 Reciprocal bin width and 42 bin width registers.

#define ADV601REG_RBW(i)		(0x100+2*(i))
#define ADV601REG_BW(i)			(0x101+2*(i))





// Now the indirect 32 bit registers:

#define ADV601REG_SUM_SQUARES(i)		(0x80+(i))   // 42 sum of squares registers
#define ADV601REG_SUM_LUMA		0xAA
#define ADV601REG_SUM_CB		0xAB
#define ADV601REG_SUM_CR		0xAC
#define ADV601REG_MIN_LUMA		0xAD
#define ADV601REG_MAX_LUMA		0xAE
#define ADV601REG_MIN_CB		0xAF
#define ADV601REG_MAX_CB		0xB0
#define ADV601REG_MIN_CR		0xB1
#define ADV601REG_MAX_CR		0xB2



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\hardware\wavelet\specific\Wcor601.h ===
// FILE:      library\hardware\wavelet\specific\wcor601.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1996 Viona Development.  All Rights Reserved.
// CREATED:   07.05.96
//
// PURPOSE: The virtualized Wavelet core for the ADV601.
//
// HISTORY:

#ifndef WAVELET601_H
#define WAVELET601_H

#include "library\hardware\wavelet\generic\wcore.h"
#include "library\lowlevel\hardwrio.h"
#include "library\lowlevel\memmpdio.h"
#include "library\lowlevel\dmabuffr.h"
#include "library\lowlevel\dmachanl.h"
#include "library\lowlevel\intrctrl.h"

#include "library\hardware\pcibrdge\specific\saa7146\saa7146.h"
#include "library\hardware\pcibrdge\specific\saa7146\rps7146.h"
#include "library\hardware\videodma\specific\s7146pip.h"
#include "library\hardware\pcibrdge\specific\saa7146\scatdma.h"



#ifndef ONLY_EXTERNAL_VISIBLE



class VirtualWaveletUnit601;
class WaveletEndIntHandler;
class VBlankIntHandler;
class PortAccess601;



class WaveletManager601 : public WaveletManager
	{
	friend class VirtualWaveletUnit601;

	public:
		WaveletManager601 (IndexedInOutPort *io, Profile *profile,
		                   InterruptServer *waveletIRQ, InterruptServer *vblankIRQ,
		                   SAA7146 *saa7146,
		                   BitOutputPort *resetEncoderPort,
		                   BitOutputPort *reset601Port,
		                   BitOutputPort *slaveMode601Port,  // bit to set 601 to slave mode
		                   BitOutputPort *frontEndEnable,    // bit to enable video bus front end in Wavelet core
		                   BitOutputPort *stillOutEnable,    // bit to enable still mode output
		                   BitOutputPort *slowClockEnable,   // bit to enable 1/8th clock for 601
		                   BitOutputPort *sync601Enable,     // bit to enable 601 sync in Wavelet core
		                   BitOutputPort *data601Enable,     // bit to enable 601 data on video bus
		                   BitOutputPort *decouple601,       // bit to decouple 601 from video bus
		                   BitOutputPort *frameLastcode,     // bit to get LCODE each frame instead of field
		                   BitOutputPort *stopReadEnable,    // bit to stop read transfer for field/frame separation
		                   VirtualUnit *blankUnit);
		virtual ~WaveletManager601 (void);

		virtual VirtualUnit *CreateVirtual (void);

		virtual void Start (void);
		virtual void Stop  (void);
		virtual void Reset (void);

		void WaveletEndInterrupt (void);
		void VBlankInterrupt (void);

	protected:
		VirtualWaveletUnit601 *GetCurrent (void) {return (VirtualWaveletUnit601 *)(WaveletManager::GetCurrent());}

		Error InitOperation (void);
		Error StartIRQs (void);
		Error StopIRQs  (void);

		PortAccess601 *io;
		Profile *profile;
		InterruptServer *waveletIRQ;
		InterruptServer *vblankIRQ;
		SAA7146 *saa7146;
		BitOutputPort *resetEncoderPort;
		BitOutputPort *reset601Port;
		BitOutputPort *slaveMode601Port;
		BitOutputPort *frontEndEnable;
		BitOutputPort *stillOutEnable;
		BitOutputPort *slowClockEnable;
		BitOutputPort *sync601Enable;
		BitOutputPort *data601Enable;
		BitOutputPort *decouple601;
		BitOutputPort *frameLastcode;
		BitOutputPort *stopReadEnable;
		VirtualUnit *blankUnit;

		VirtualWaveletUnit601 *operatingUnit;

		DataInOutPort *codePort;
		DMAChannel *readChannel, *writeChannel;
		WaveletEndIntHandler *waveletEndIntHandler;
		VBlankIntHandler *vblankIntHandler;

		ContinuousDMABuffer *dmaBuffer;
		DWORD dmaSize;
		FPTR dmaDataPtr;
		class WaveletTransferRequest *dmaRequest;

		int encodeThreshold, decodeThreshold;

		BOOL endHandlerEnabled, vBlankHandlerEnabled;
	};



class VirtualWaveletUnit601 : public VirtualWaveletUnit
	{
	friend class WaveletManager601;

	public:
		VirtualWaveletUnit601 (WaveletManager601 *physical, VirtualSAA7146PIP *pip);
		virtual ~VirtualWaveletUnit601 (void);

		virtual Error Configure (TAG __far *tags);

		virtual Error PrepareBuffer (FPTR buffer, DWORD size, FPTR __far &info);
		virtual Error UnprepareBuffer (FPTR info);

		virtual Error ExpandToRGB (FPTR src, DWORD size, FPTR dst, WORD dstWidth, WORD dstHeight, GrabFormat bitFormat);
		virtual BOOL IsValidExpansionScaling (WORD srcWidth, WORD srcHeight, WORD dstWidth, WORD dstHeight, GrabFormat bitFormat);

		virtual Error CompressFromRGB (FPTR src, FPTR dst, DWORD maxSize, DWORD __far &size, BOOL bits32);
		virtual BOOL IsValidCompression (WORD width, WORD height, BOOL bits32);

		// These are allowed only after locking and activating the unit.
		virtual Error InitCapture (JPEGCaptureHook __far *hook);
		virtual Error FinishCapture (void);
		virtual Error AddVideoBuffer (FPTR info, FPTR userData, DWORD size);
		virtual Error Start (void);
		virtual Error Stop  (void);

		virtual Error AllocateVideoBuffer (DWORD size, FPTR __far &info, FPTR __far &data);
		virtual Error FreeVideoBuffer (FPTR info);
		virtual Error InitPlayback (JPEGPlaybackHook __far *hook);
		virtual Error FinishPlayback (void);
		virtual Error FlushPlayback (DWORD bufferSize);
		virtual Error PlayBuffer (FPTR info, DWORD size);

	protected:
		virtual Error Preempt (VirtualUnit *previous);

//		Error CompressField (FPTR src, WORD numberOfBlocks, FPTR dst, DWORD maxSize, DWORD __far &size);

		void WaveletEndInterrupt (void);
		void VBlankInterrupt (void);

		void CalculateBinWidths (DWORD currentSize);

		virtual Error InternalAddVideoBuffer (FPTR info, FPTR userData, DWORD size);

		WaveletManager601 *manager;
		VirtualSAA7146PIP *pip;

		FPTR dummyCaptureData;
		FPTR dummyCaptureInfo;
		DWORD dummyCapSize;

		FPTR playBackupData;
		FPTR playBackupInfo;
		DWORD playBackupSize;

		JPEGCaptureHookHandle capHook;
		JPEGPlaybackHookHandle playHook;
		JPEGMessageHookHandle preemptHook;
		volatile int nextBuffer;   // already processed buffer
		int lastBuffer;   // entry for providing new buffer
		volatile int nBuffers;
		DWORD frameNum;
		DWORD fieldNum, calculatedFieldNum;
		WORD lastFieldCnt;
		JPEGCaptureMsg buffers[4];
		volatile int stoppingCapture;
		BOOL running;
		BOOL playAddAllowed;

		RPSProgram *rpsPlaySlots;
		int lastScatter;

		RPSProgram *rpsPlayTransfer;
		ScatteredBuffer7146::PlayParametersRPS rpsPlayPhysical;
		Error CreatePlayTransfer (void);

		volatile BOOL irqSecondField;   // only for playback
		volatile BOOL transferRunning;

		RPSProgram *rpsCapTransfer;
		Error CreateCaptureTransfer (void);

		ContinuousDMABuffer *capCycleBuffer;
		FPTR capBufferPtr;
		DWORD capPhysical;
		RPSProgram *rpsCapture;
		int nCapPages;
		int startPage;
		DWORD __huge *startPagePtr;
		DWORD __huge *capSrc;
		DWORD __huge *capDst;
		DWORD bytesCaptured;
		DWORD lastFrameSize;
		DWORD rbwOffsetRPS, rbwBlockSize;   // in DWORD units
		BOOL noDestination;

		DWORD nextFrameTime;
		DWORD milliSecPerFrame;
		BOOL singleFrame;

		VideoStandard vStandard;
		VideoFormat vFormat;
		VideoField fieldOrder;
		BOOL thumbnail;
		BOOL filtersOn;

		DWORD totalCodeVolume;
	};



#endif // ONLY_EXTERNAL_VISIBLE



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\support\AVDataBase\AVDataBaseProfiles.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "AVDataBaseProfiles.h"

AVDataBase::AVDataBase(KernelString swcmcfgdll, KernelString product, KernelString version, int displayDeviceID, int soundDeviceID) :
	legacyProfile("RAVISENT", product, version)
	{
	this->displayDeviceID = displayDeviceID;
	this->soundDeviceID = soundDeviceID;
	openCount = 1;

	// First try to find the specified config library
	dataBaseInstance = ::LoadLibrary(swcmcfgdll);
	if (NULL == dataBaseInstance)
		{
		// Try previous dll name
		dataBaseInstance = ::LoadLibrary("SWCMCFG.dll");
		}
	if (dataBaseInstance)
		{
		(FARPROC &)DBInitialize = GetProcAddress(dataBaseInstance, "_SWCMCFG_Initialize@0");
		(FARPROC &)OpenDB       = GetProcAddress(dataBaseInstance, "_SWCMCFG_OpenDB@4");
		(FARPROC &)CloseDB      = GetProcAddress(dataBaseInstance, "_SWCMCFG_CloseDB@4");
		(FARPROC &)GetDBInt     = GetProcAddress(dataBaseInstance, "_SWCMCFG_GetInt@24");

		if (DBInitialize && OpenDB && CloseDB && GetDBInt)
			{
			if (DBInitialize() != 0)
				{
				dataBase = OpenDB(product + __TEXT("\\") + version);
				if (dataBase == 0)
					{
					::FreeLibrary(dataBaseInstance);
					dataBaseInstance = NULL;
					}
				}
			else
				{
				::FreeLibrary(dataBaseInstance);
				dataBaseInstance = NULL;
				}
			}
		else
			{
			::FreeLibrary(dataBaseInstance);
			dataBaseInstance = NULL;
			}
		}
	}

AVDataBase::~AVDataBase(void)
	{
	if (dataBaseInstance)
		::FreeLibrary(dataBaseInstance);
	}

Error AVDataBase::GetInt(KernelString name, int & value, int deflt)
	{
	if (dataBaseInstance)
		{
		if (GetDBInt(dataBase, name, deflt, displayDeviceID, soundDeviceID, value) != 0)
			GNRAISE_OK;
		else
			GNRAISE(GNR_PROFILE_READ);
		}
	else
		GNRAISE(GNR_PROFILE_READ);
	}

Error AVDataBase::GetString(KernelString name, KernelString & value, KernelString deflt)
	{
	GNREASSERT(legacyProfile.Read("DevDB", name, value, deflt));

	GNRAISE_OK;
	}


AVDataBaseProfile::AVDataBaseProfile(KernelString swcmcfgdll, KernelString product, KernelString version, int displayDevice, int soundDevice)
	{
	mainSection = "";
	avDataBase = new AVDataBase(swcmcfgdll, product, version, displayDevice, soundDevice);
	}

AVDataBaseProfile::AVDataBaseProfile(AVDataBaseProfile * parent, KernelString section)
	{
	mainSection = parent->mainSection + section + ".";
	avDataBase = parent->avDataBase;
	avDataBase->Obtain();
	}

AVDataBaseProfile::~AVDataBaseProfile(void)
	{
	avDataBase->Release();
	}


Error AVDataBaseProfile::WriteDirect(KernelString entry, int value)
	{
	GNRAISE_OK;
	}

Error AVDataBaseProfile::ReadDirect(KernelString entry, int __far & value, int deflt)
	{
	value = deflt;

	GNREASSERT(avDataBase->GetInt(mainSection + entry, value, deflt));

	GNRAISE_OK;
	}

Error AVDataBaseProfile::WriteDirect(KernelString entry, bool value)
	{
	GNRAISE_OK;
	}

Error AVDataBaseProfile::ReadDirect(KernelString entry, bool __far & value, bool deflt)
	{
	int iv;

	value = deflt;

	GNREASSERT(avDataBase->GetInt(mainSection + entry, iv, deflt));

	value = iv != 0;

	GNRAISE_OK;
	}

Error AVDataBaseProfile::ReadDirect(KernelString entry, long __far & value, long deflt)
	{
	int iv;

	value = deflt;

	GNREASSERT(avDataBase->GetInt(mainSection + entry, iv, deflt));

	value = (long)iv;

	GNRAISE_OK;
	}

Error AVDataBaseProfile::WriteDirect(KernelString entry, WORD value, int base)
	{
	GNRAISE_OK;
	}

Error AVDataBaseProfile::ReadDirect(KernelString entry, WORD __far & value, int base, WORD deflt)
	{
	int iv;

	value = deflt;

	GNREASSERT(avDataBase->GetInt(mainSection + entry, iv, deflt));

	value = (WORD)iv;

	GNRAISE_OK;
	}

Error AVDataBaseProfile::WriteDirect(KernelString entry, DWORD value, int base)
	{
	GNRAISE_OK;
	}

Error AVDataBaseProfile::ReadDirect(KernelString entry, DWORD __far & value, int base, DWORD deflt)
	{
	int iv;

	value = deflt;

	GNREASSERT(avDataBase->GetInt(mainSection + entry, iv, deflt));

	value = (DWORD)iv;

	GNRAISE_OK;
	}

Error AVDataBaseProfile::WriteDirect(KernelString entry, KernelString value)
	{
	GNRAISE_OK;
	}

Error AVDataBaseProfile::ReadDirect(KernelString entry, KernelString & value, KernelString deflt)
	{
	value = deflt;

	GNREASSERT(avDataBase->GetString(mainSection + entry, value, deflt));

	GNRAISE_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\support\AVDataBase\swcmcfg.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
//  $Workfile: SWCMCFG.h $
//
//  Copyright (c) 1999  Quadrant International, Inc.
//  All Rights Reserved.
//
//////////////////////////////////////////////////////////////////////////////
//
// $Archive: /Tproj/library/support/AVDataBase/SWCMCFG.h $
// $Author: Fhermanson $
// $Modtime: 12/21/00 11:58a $
// $Date: 2/01/01 2:10p $
// $Revision: 2 $
//
////////////////////////////////////$NoKeywords: $////////////////////////////

#ifndef __SWCMCFG_H
#define __SWCMCFG_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef SWCMCFG_EXPORTS
#define SWCMCFG_API __declspec(dllexport)
#else
#define SWCMCFG_API __declspec(dllimport)
#endif

typedef int HCFGDB;

///////////////////////////////////////////////////////////////////////////////
//
// SWCMCFG_Initialize()
//
// Description:  This function sets the Software CineMaster configuration
//               data according to the following system information:
//
//                   Display Devices (VGA Card(s))
//                   Sound Devices
//                   CPU Type
//                   CPU Speed
//
//               This must be called before using any of the configuration
//               access functions.
//               It may be called more than once (e.g. on device change)
//
// Arguments:    void -
//
// Return:       SWCMCFG_API int  - Error value
//                          0 = Failed
//                          1 = Success
//
///////////////////////////////////////////////////////////////////////////////
SWCMCFG_API int WINAPI SWCMCFG_Initialize(void);

///////////////////////////////////////////////////////////////////////////////
//
// SWCMCFG_OpenDB()
//
// Description:  Returns a handle to a specific database for using GetInt
//
// Arguments:    LPCTSTR lpszDBName - Name of database
//                      (e.g. "Software Cinemaster\\2.0")
//
// Return:       SWCMCFG_API HCFGDB - >0 if successfull
//
///////////////////////////////////////////////////////////////////////////////
SWCMCFG_API HCFGDB WINAPI SWCMCFG_OpenDB(LPCTSTR lpszDBName);

///////////////////////////////////////////////////////////////////////////////
//
// int SWCMCFG_CloseDB()
//
// Arguments:    HCFGDB hDB - Handle to open DB
//
// Return:       SWCMCFG_API int - Error value
//                          0 = Failed
//                          1 = Success
//
///////////////////////////////////////////////////////////////////////////////
SWCMCFG_API int WINAPI SWCMCFG_CloseDB(HCFGDB hDB);

///////////////////////////////////////////////////////////////////////////////
//
// SWCMCFG_GetInt()
//
//
// Description:  Gets the value of the specified Software CineMaster
//               configuration item.
//
// Arguments:    HCFGDB  hDB - handle returned from SWCMCFG_OpenDB().
//               LPCTSTR lpszCfgItemName - Name of config item
//                                         (e.g. "VideoDecoder.PerformanceClass")
//               int nDefValue - this value is returned if no other value is found
//               int nDisplayDev - If this configuration item is
//                      related to the Display Device (VGA card), then this
//                      value is used to select either a default value or
//                      a value from the VGA card database for the specified
//                      VGA device.
//                         0 - This specifies to use the default value (as if
//                             the VGA card was NOT known.
//                         >= 1 - This specifies which VGA card (if multiple)
//                            to retrieve the value for (this is the DDRAW
//                            DevEnum + 1).
//                            If the vga card is not recognized, a default
//                            value will be returned.
//                      If the configuration item is NOT display (VGA)
//                      dependent, then this parameter has no effect.
//               int nSoundDev - If this configuration item is
//                      related to the Sound Card, then this
//                      value is used to select either a default value or
//                      a value from a Sound Card database for the specified
//                      Sound device.
//                         0 - This specifies to use the default value (as if
//                             the Sound card was NOT known.
//                         >= 1 - This specifies which Sound card (if multiple)
//                            to retrieve the value for (this is the DSOUND
//                            DevEnum + 1).
//                            If the sound card is not recognized, a default
//                            value will be returned.
//                      If the configuration item is NOT Sound card
//                      dependent, then this parameter has no effect.
//               int& nValue - This is the returned value if successful.
//
// Return:       SWCMCFG_API int  - Error value
//                          0 = Failed
//                          1 = Success
//
///////////////////////////////////////////////////////////////////////////////
SWCMCFG_API  int WINAPI SWCMCFG_GetInt(HCFGDB hDB, LPCTSTR lpszCfgItemName,
                                int nDefValue, int nDisplayDev, int nSoundDev,
                                int& nValue);

#ifdef __cplusplus
}   // extern "C" {
#endif

#endif // __SWCMCFG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\support\AVDataBase\AVDataBaseProfiles.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef AVDATABASEPROFILES_H
#define AVDATABASEPROFILES_H

#include "library\common\profiles.h"
#include "swcmcfg.h"

class AVDataBase
	{
	private:
		int			openCount;

		HCFGDB		dataBase;
		HINSTANCE	dataBaseInstance;

		int			displayDeviceID;
		int			soundDeviceID;

		HCFGDB (WINAPI* OpenDB)(LPCTSTR);
		int	 (WINAPI* DBInitialize)();
		int	 (WINAPI* CloseDB)(HCFGDB);
		int	 (WINAPI* GetDBInt)(HCFGDB, LPCTSTR, int, int, int, int&);

		Profile		legacyProfile;
	public:
		AVDataBase(KernelString swcmcfgdll, KernelString product, KernelString version, int displayDeviceID = 1, int soundDeviceID = 1);
		~AVDataBase(void);

		BOOL IsValid(void) {return dataBaseInstance != NULL;}

		void Obtain(void) {openCount++;}
		void Release(void) {openCount--; if (!openCount) delete this;}

		Error GetInt(KernelString name, int & value, int deflt);
		Error GetString(KernelString name, KernelString & value, KernelString deflt);
	};


class AVDataBaseProfile : public GenericProfile
	{
	private:
		KernelString	mainSection;
		AVDataBase	*	avDataBase;
	public:
		AVDataBaseProfile(KernelString swcmcfgdll, KernelString product, KernelString version, int displayDevice = 1, int soundDevice = 1);
		AVDataBaseProfile(AVDataBaseProfile * parent, KernelString section);
		~AVDataBaseProfile(void);

		BOOL IsValid(void) {return avDataBase->IsValid();}
		GenericProfile * CreateSection(KernelString section) {return new AVDataBaseProfile(this, section);}

		Error WriteDirect(KernelString entry, int value);
		Error ReadDirect(KernelString entry, int __far & value, int deflt);
		Error ReadDirect(KernelString entry, int __far & value) {return ReadDirect(entry, value, value);}

		Error WriteDirect(KernelString entry, bool value);
		Error ReadDirect(KernelString entry, bool __far & value, bool deflt);
		Error ReadDirect(KernelString entry, bool __far & value) {return ReadDirect(entry, value, value);}

		Error ReadDirect(KernelString entry, long __far & value, long deflt);
		Error ReadDirect(KernelString entry, long __far & value) {return ReadDirect(entry, value, value);}

		Error WriteDirect(KernelString entry, WORD value, int base);
		Error ReadDirect(KernelString entry, WORD __far & value, int base, WORD deflt);
		Error ReadDirect(KernelString entry, WORD __far & value, int base) {return ReadDirect(entry, value, base, value);}

		Error WriteDirect(KernelString entry, DWORD value, int base);
		Error ReadDirect(KernelString entry, DWORD __far & value, int base, DWORD deflt);
		Error ReadDirect(KernelString entry, DWORD __far & value, int base) {return ReadDirect(entry, value, base, value);}

		Error WriteDirect(KernelString entry, KernelString value);
		Error ReadDirect(KernelString entry, KernelString & value, KernelString deflt);
		Error ReadDirect(KernelString entry, KernelString & value) {return ReadDirect(entry, value, value);}
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\support\vdsup32\win32\VDCommon.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef VDCOMMON_H
#define VDCOMMON_H

#include <xtl.h>
#include "library\common\vddebug.h"
#include "library\support\aspi32\wnaspi32.h"

typedef struct VDASPIStruct
	{
	HANDLE		event;

	DWORD (__cdecl * xSendASPI32Command )   (LPSRB);
	DWORD (__cdecl * xGetASPI32SupportInfo) (VOID);

	}	*	VDASPIHandle;



#if !WINNT
#define DllEXPORT	__declspec( dllexport )
#else
#define DllEXPORT

#endif


extern "C"
	{
	DllEXPORT void		WINAPI VD32_VOID();
	DllEXPORT HANDLE	WINAPI VD32_OpenFile(const char * name, BOOL readWrite);
	DllEXPORT HANDLE	WINAPI VD32_CreateFile(const char * name);
	DllEXPORT void		WINAPI VD32_CloseFile(HANDLE file);
	DllEXPORT DWORD	WINAPI VD32_ReadFile(HANDLE file, void * data, DWORD size);
	DllEXPORT DWORD	WINAPI VD32_WriteFile(HANDLE file, void * data, DWORD size);
	DllEXPORT void		WINAPI VD32_SeekFile(HANDLE file, DWORD &low, DWORD &high);
	DllEXPORT void		WINAPI VD32_GetFileSize(HANDLE file, DWORD &low, DWORD &high);

	DllEXPORT BOOL		WINAPI VD32_GetPrivateProfileString(char * section, char * entry, char * initBuff, char * buff,
	                                      int size, char * fileName);
	DllEXPORT BOOL		WINAPI VD32_WritePrivateProfileString(char * section, char * entry, char * value, char * fileName);
	DllEXPORT BOOL		WINAPI VD32_GetPrivateProfileDWORD(char * section, char * entry, DWORD init, DWORD * buff,
	                                                 char * fileName);
	DllEXPORT BOOL		WINAPI VD32_WritePrivateProfileDWORD(char * section, char * entry, DWORD value, char * fileName);

#if !WINNT
	DllEXPORT void		WINAPI VD32_Sleep(DWORD millisecs);
	DllEXPORT VDASPIHandle		WINAPI VD32_OpenASPI(void);
	DllEXPORT void		WINAPI VD32_CloseASPI(VDASPIHandle handle);
	DllEXPORT DWORD		WINAPI VD32_GetASPISupportInfo(VDASPIHandle handle);
	DllEXPORT BOOL		WINAPI VD32_SendASPICommand(VDASPIHandle handle, SRB_ExecSCSICmd * cmd, void * buffer);
	DllEXPORT BOOL		WINAPI VD32_GetASPIDiskInfo(VDASPIHandle handle, SRB_GetDiskInfo * info);
#endif
	}


#endif // VDCOMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\support\WinSock\SOCKCORE.CPP ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// Adapted for XBOX from.....

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\support\WinSock\SOCKCORE.H ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __SOCKCORE_H_
#define __SOCKCORE_H_


#define XASSERT(x) if( !(x) ) _asm int 3

	#include <xtl.h>

#define FD_READ_BIT      0
#define FD_READ          (1 << FD_READ_BIT)

#define FD_WRITE_BIT     1
#define FD_WRITE         (1 << FD_WRITE_BIT)

#define FD_OOB_BIT       2
#define FD_OOB           (1 << FD_OOB_BIT)

#define FD_ACCEPT_BIT    3
#define FD_ACCEPT        (1 << FD_ACCEPT_BIT)

#define FD_CONNECT_BIT   4
#define FD_CONNECT       (1 << FD_CONNECT_BIT)

#define FD_CLOSE_BIT     5
#define FD_CLOSE         (1 << FD_CLOSE_BIT)

#define FD_QOS_BIT       6
#define FD_QOS           (1 << FD_QOS_BIT)

#define FD_GROUP_QOS_BIT 7
#define FD_GROUP_QOS     (1 << FD_GROUP_QOS_BIT)

#define FD_ROUTING_INTERFACE_CHANGE_BIT 8
#define FD_ROUTING_INTERFACE_CHANGE     (1 << FD_ROUTING_INTERFACE_CHANGE_BIT)

#define FD_ADDRESS_LIST_CHANGE_BIT 9
#define FD_ADDRESS_LIST_CHANGE     (1 << FD_ADDRESS_LIST_CHANGE_BIT)

#define FD_MAX_EVENTS    10
#define FD_ALL_EVENTS    ((1 << FD_MAX_EVENTS) - 1)



/////////////////////////////////////////////////////////////////////////////
// CAsyncSocket

class CAsyncSocket
{
protected:
	HANDLE	m_hInstSOCK;
	int		m_nSockTerm;
	HANDLE	m_hSocketWindow;
	SOCKET	m_hSocket;

	void SocketTerm(void);

// Construction
public:
	CAsyncSocket();
	~CAsyncSocket();
	BOOL SocketInit(WSADATA* lpwsaData = NULL);

	BOOL Create(UINT nSocketPort = 0, int nSocketType=SOCK_STREAM,
		long lEvent = FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE,
		LPCTSTR lpszSocketAddress = NULL);

	operator SOCKET() const
		{ return m_hSocket; }

	BOOL Attach(SOCKET hSocket, long lEvent =
		FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE);
	SOCKET Detach();

	BOOL GetPeerName(LPSTR& rPeerAddress, UINT& rPeerPort);
	BOOL GetPeerName(SOCKADDR* lpSockAddr, int* lpSockAddrLen)
		{ return (SOCKET_ERROR != getpeername(m_hSocket, lpSockAddr, lpSockAddrLen)); }

	BOOL GetSockName(LPSTR& rSocketAddress, UINT& rSocketPort);
	BOOL GetSockName(SOCKADDR* lpSockAddr, int* lpSockAddrLen)
		{ return (SOCKET_ERROR != getsockname(m_hSocket, lpSockAddr, lpSockAddrLen)); }

	BOOL SetSockOpt(int nOptionName, const void* lpOptionValue, int nOptionLen, int nLevel = SOL_SOCKET)
		{ return (SOCKET_ERROR != setsockopt(m_hSocket, nLevel, nOptionName, (LPCSTR)lpOptionValue, nOptionLen)); }
	BOOL GetSockOpt(int nOptionName, void* lpOptionValue, int* lpOptionLen, int nLevel = SOL_SOCKET)
		{ return (SOCKET_ERROR != getsockopt(m_hSocket, nLevel, nOptionName, (LPSTR)lpOptionValue, lpOptionLen)); }

//	static CAsyncSocket* PASCAL FromHandle(SOCKET hSocket)
//		{ return LookupHandle(hSocket, FALSE); }

//	static CAsyncSocket* PASCAL LookupHandle(SOCKET hSocket, BOOL f)
//		{ return FALSE; }

	static int PASCAL GetLastError()
		{ return WSAGetLastError(); }


// Operations
public:

	virtual BOOL Accept(CAsyncSocket& rConnectedSocket,
		SOCKADDR* lpSockAddr = NULL, int* lpSockAddrLen = NULL);

	BOOL Bind(UINT nSocketPort, LPCTSTR lpszSocketAddress = NULL);
	BOOL Bind (const SOCKADDR* lpSockAddr, int nSockAddrLen)
		{ return (SOCKET_ERROR != bind(m_hSocket, lpSockAddr, nSockAddrLen)); }

	virtual void Close();

	BOOL Connect(LPCTSTR lpszHostAddress, UINT nHostPort);
	BOOL Connect(const SOCKADDR* lpSockAddr, int nSockAddrLen)
		{ return ConnectHelper(lpSockAddr, nSockAddrLen); }

	BOOL IOCtl(long lCommand, DWORD* lpArgument)
		{ return (SOCKET_ERROR != ioctlsocket(m_hSocket, lCommand, lpArgument)); }

	BOOL Listen(int nConnectionBacklog=5)
		{ return (SOCKET_ERROR != listen(m_hSocket, nConnectionBacklog)); }

	virtual int Receive(void* lpBuf, int nBufLen, int nFlags = 0);

	int ReceiveFrom(void* lpBuf, int nBufLen, LPSTR& rSocketAddress, UINT& rSocketPort, int nFlags = 0);
	int ReceiveFrom(void* lpBuf, int nBufLen,	SOCKADDR* lpSockAddr, int* lpSockAddrLen, int nFlags = 0)
		{ return ReceiveFromHelper(lpBuf, nBufLen, lpSockAddr, lpSockAddrLen, nFlags); }

	enum { receives = 0, sends = 1, both = 2 };
	BOOL ShutDown(int nHow = sends)
		{ return (SOCKET_ERROR != shutdown(m_hSocket,nHow)); }

	virtual int Send(const void* lpBuf, int nBufLen, int nFlags = 0);

	int SendTo(const void* lpBuf, int nBufLen, UINT nHostPort, LPCTSTR lpszHostAddress = NULL, int nFlags = 0);
	int SendTo(const void* lpBuf, int nBufLen, const SOCKADDR* lpSockAddr, int nSockAddrLen, int nFlags = 0)
		{ return SendToHelper(lpBuf, nBufLen, lpSockAddr, nSockAddrLen, nFlags); }


	BOOL AsyncSelect(long lEvent =
		FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE);

// Overridable callbacks
protected:
	virtual void OnReceive(int nErrorCode);
	virtual void OnSend(int nErrorCode);
	virtual void OnOutOfBandData(int nErrorCode);
	virtual void OnAccept(int nErrorCode);
	virtual void OnConnect(int nErrorCode);
	virtual void OnClose(int nErrorCode);

// Implementation
public:
//	static CAsyncSocket* PASCAL LookupHandle(SOCKET hSocket, BOOL bDead = FALSE);
//	static void PASCAL AttachHandle(SOCKET hSocket, CAsyncSocket* pSocket, BOOL bDead = FALSE);
//	static void PASCAL DetachHandle(SOCKET hSocket, BOOL bDead = FALSE);
//	static void PASCAL KillSocket(SOCKET hSocket, CAsyncSocket* pSocket);
//	static void PASCAL DoCallBack(WPARAM wParam, LPARAM lParam);

	BOOL Socket(int nSocketType=SOCK_STREAM, long lEvent =
		FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE,
		int nProtocolType = 0, int nAddressFormat = PF_INET);

#ifdef _DEBUG
//	virtual void AssertValid() const;
#endif

protected:
	friend class CSocketWnd;

	virtual BOOL ConnectHelper(const SOCKADDR* lpSockAddr, int nSockAddrLen);
	virtual int ReceiveFromHelper(void* lpBuf, int nBufLen,
		SOCKADDR* lpSockAddr, int* lpSockAddrLen, int nFlags);
	virtual int SendToHelper(const void* lpBuf, int nBufLen,
		const SOCKADDR* lpSockAddr, int nSockAddrLen, int nFlags);
};

/////////////////////////////////////////////////////////////////////////////
// CSocket

class CSocket : public CAsyncSocket
{
//	DECLARE_DYNAMIC(CSocket);
private:
	CSocket(const CSocket& rSrc);         // no implementation
	void operator=(const CSocket& rSrc);  // no implementation

// Construction
public:
	CSocket();
	BOOL Create(UINT nSocketPort = 0, int nSocketType=SOCK_STREAM, LPCTSTR lpszSocketAddress = NULL)
		{ return CAsyncSocket::Create(nSocketPort, nSocketType, FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE, lpszSocketAddress); }

// Attributes
public:
	BOOL IsBlocking()
		{ return (m_pbBlocking != NULL); }

//	static CSocket* PASCAL FromHandle(SOCKET hSocket)
//		{ return (CSocket*)CAsyncSocket::LookupHandle(hSocket, FALSE); }

	BOOL Attach(SOCKET hSocket)
		{ return Attach(hSocket); }

// Operations
public:
	void CancelBlockingCall();

// Overridable callbacks
protected:
//	virtual BOOL OnMessagePending();

// Implementation
public:
	int m_nTimeOut;

	virtual ~CSocket();

	static int PASCAL ProcessAuxQueue();

	virtual BOOL Accept(CAsyncSocket& rConnectedSocket,
		SOCKADDR* lpSockAddr = NULL, int* lpSockAddrLen = NULL);
	virtual void Close();
	virtual int Receive(void* lpBuf, int nBufLen, int nFlags = 0);
	virtual int Send(const void* lpBuf, int nBufLen, int nFlags = 0);

	int SendChunk(const void* lpBuf, int nBufLen, int nFlags);

protected:
	BOOL* m_pbBlocking;
	int m_nConnectError;

	virtual BOOL ConnectHelper(const SOCKADDR* lpSockAddr, int nSockAddrLen);
	virtual int ReceiveFromHelper(void* lpBuf, int nBufLen,
		SOCKADDR* lpSockAddr, int* lpSockAddrLen, int nFlags);
	virtual int SendToHelper(const void* lpBuf, int nBufLen,
		const SOCKADDR* lpSockAddr, int nSockAddrLen, int nFlags);
//
//	static void PASCAL AuxQueueAdd(UINT message, WPARAM wParam, LPARAM lParam);
//
//	virtual BOOL PumpMessages(UINT uStopFlag);
//
//#ifdef _DEBUG
//	virtual void AssertValid() const;
//#endif
};


#endif // __SOCKCORE_H_

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\library\support\vdsup32\win32\vdcommon.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "vdcommon.h"



HINSTANCE		ASPIHandle;
bool				ASPIPossible		= TRUE;
VDASPIStruct *	ASPIStructHandle;
int				ASPICount			= 0;



void __stdcall VD32_VOID()
	{
	}

void  __stdcall VD32_Sleep(DWORD millisecs)
	{
	Sleep(millisecs);
	}

///////////////////////////////////////////////////////////////////////////////
// 32 Bit File Access
///////////////////////////////////////////////////////////////////////////////

HANDLE __stdcall VD32_OpenFile(const char * name, BOOL readWrite)
	{
	DP("Open File");
	if (readWrite)
		return CreateFile(name,
		                  GENERIC_READ | GENERIC_WRITE,
								0,
								NULL,
								OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
								NULL);
	else
		return CreateFile(name,
		                  GENERIC_READ,
								FILE_SHARE_READ,
								NULL,
								OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
								NULL);
	}

HANDLE __stdcall VD32_CreateFile(const char * name)
	{
	return CreateFile(name,
		               GENERIC_READ | GENERIC_WRITE,
							0,
							NULL,
							CREATE_ALWAYS,
							FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
							NULL);
	}

void  __stdcall VD32_CloseFile(HANDLE file)
	{
	CloseHandle(file);
	}

DWORD __stdcall VD32_ReadFile(HANDLE file, void * data, DWORD size)
	{
	ReadFile(file, data, size, &size, NULL);

	return size;
	}

DWORD __stdcall VD32_WriteFile(HANDLE file, void * data, DWORD size)
	{
	WriteFile(file, data, size, &size, NULL);

	return size;
	}

void __stdcall VD32_SeekFile(HANDLE file, DWORD &low, DWORD &high)
	{
	low = SetFilePointer(file, low, &(LONG &)high, FILE_BEGIN);
	}

void __stdcall VD32_GetFileSize(HANDLE file, DWORD &low, DWORD &high)
	{
	low = GetFileSize(file, &high);
	}


///////////////////////////////////////////////////////////////////////////////
// 32Bit ASPI Support
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\win32inc\Afx.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFX_H__
#define __AFX_H__

#ifndef __cplusplus
	#error MFC requires C++ compilation (use a .cpp suffix)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#include <afxver_.h>        // Target version control

#ifndef _AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#ifndef _AFXDLL
	#ifndef _UNICODE
		#ifdef _DEBUG
			#pragma comment(lib, "nafxcwd.lib")
#else
			#pragma comment(lib, "nafxcw.lib")
		#endif
#else
		#ifdef _DEBUG
			#pragma comment(lib, "uafxcwd.lib")
#else
			#pragma comment(lib, "uafxcw.lib")
		#endif
	#endif
#else
	#ifndef _UNICODE
		#ifdef _DEBUG
			#pragma comment(lib, "mfc42d.lib")
			#pragma comment(lib, "mfcs42d.lib")
#else
			#pragma comment(lib, "mfc42.lib")
			#pragma comment(lib, "mfcs42.lib")
		#endif
#else
		#ifdef _DEBUG
			#pragma comment(lib, "mfc42ud.lib")
			#pragma comment(lib, "mfcs42ud.lib")
#else
			#pragma comment(lib, "mfc42u.lib")
			#pragma comment(lib, "mfcs42u.lib")
		#endif
	#endif
#endif

#ifdef _DLL
	#if !defined
		#pragma comment(lib, "msvcrtd.lib")
#else
		#pragma comment(lib, "msvcrt.lib")
	#endif
#else
#ifdef _MT
	#if !defined
		#pragma comment(lib, "libcmtd.lib")
#else
		#pragma comment(lib, "libcmt.lib")
	#endif
#else
	#if !defined
		#pragma comment(lib, "libcd.lib")
#else
		#pragma comment(lib, "libc.lib")
	#endif
#endif
#endif

#pragma comment(lib, "kernel32.lib")
#pragma comment(lib, "user32.lib")
#pragma comment(lib, "gdi32.lib")
#pragma comment(lib, "comdlg32.lib")
#pragma comment(lib, "winspool.lib")
#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "shell32.lib")
#pragma comment(lib, "comctl32.lib")

// force inclusion of NOLIB.OBJ for /disallowlib directives
#pragma comment(linker, "/include:__afxForceEXCLUDE")

// force inclusion of DLLMODUL.OBJ for _USRDLL
#ifdef _USRDLL
#pragma comment(linker, "/include:__afxForceUSRDLL")
#endif

// force inclusion of STDAFX.OBJ for precompiled types
#ifdef _AFXDLL
#pragma comment(linker, "/include:__afxForceSTDAFX")
#endif

#endif //!_AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////
// Classes declared in this file
//   in addition to standard primitive data types and various helper macros

struct CRuntimeClass;          // object type information

class CObject;                        // the root of all objects classes

	class CException;                 // the root of all exceptions
		class CArchiveException;      // archive exception
		class CFileException;         // file exception
		class CSimpleException;
			class CMemoryException;       // out-of-memory exception
			class CNotSupportedException; // feature not supported exception

	class CFile;                      // raw binary file
		class CStdioFile;             // buffered stdio text/binary file
		class CMemFile;               // memory based file

// Non CObject classes
class CString;                        // growable string type
class CTimeSpan;                      // time/date difference
class CTime;                          // absolute time/date
struct CFileStatus;                   // file status information
struct CMemoryState;                  // diagnostic memory support

class CArchive;                       // object persistence tool
class CDumpContext;                   // object diagnostic dumping

/////////////////////////////////////////////////////////////////////////////
// Other includes from standard "C" runtimes

#ifndef _INC_STRING
	#include <string.h>
#endif
#ifndef _INC_STDIO
	#include <stdio.h>
#endif
#ifndef _INC_STDLIB
	#include <stdlib.h>
#endif
#ifndef _INC_TIME
	#include <time.h>
#endif
#ifndef _INC_LIMITS
	#include <limits.h>
#endif
#ifndef _INC_STDDEF
	#include <stddef.h>
#endif
#ifndef _INC_STDARG
	#include <stdarg.h>
#endif

#ifndef _AFX_NO_DEBUG_CRT
#ifndef _INC_CRTDBG
	#include <crtdbg.h>
#endif
#endif // _AFX_NO_DEBUG_CRT

#ifdef _AFX_OLD_EXCEPTIONS
// use setjmp and helper functions instead of C++ keywords
#ifndef _INC_SETJMP
	#pragma warning(disable: 4611)
	#include <setjmp.h>
#endif
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// Basic types

// abstract iteration position
struct __POSITION { };
typedef __POSITION* POSITION;

struct _AFX_DOUBLE  { BYTE doubleBits[sizeof(double)]; };
struct _AFX_FLOAT   { BYTE floatBits[sizeof(float)]; };

// Standard constants
#undef FALSE
#undef TRUE
#undef NULL

#define FALSE   0
#define TRUE    1
#define NULL    0

/////////////////////////////////////////////////////////////////////////////
// Diagnostic support

#ifdef _DEBUG

BOOL AFXAPI AfxAssertFailedLine(LPCSTR lpszFileName, int nLine);

void AFX_CDECL AfxTrace(LPCTSTR lpszFormat, ...);
// Note: file names are still ANSI strings (filenames rarely need UNICODE)
void AFXAPI AfxAssertValidObject(const CObject* pOb,
				LPCSTR lpszFileName, int nLine);
void AFXAPI AfxDump(const CObject* pOb); // Dump an object from CodeView

#define TRACE              ::AfxTrace
#define THIS_FILE          __FILE__
#define ASSERT(f) \
	do \
	{ \
	if (!(f) && AfxAssertFailedLine(THIS_FILE, __LINE__)) \
		AfxDebugBreak(); \
	} while (0) \

#define VERIFY(f)          ASSERT(f)
#define ASSERT_VALID(pOb)  (::AfxAssertValidObject(pOb, THIS_FILE, __LINE__))
#define DEBUG_ONLY(f)      (f)

// The following trace macros are provided for backward compatiblity
//  (they also take a fixed number of parameters which provides
//   some amount of extra error checking)
#define TRACE0(sz)              ::AfxTrace(_T("%s"), _T(sz))
#define TRACE1(sz, p1)          ::AfxTrace(_T(sz), p1)
#define TRACE2(sz, p1, p2)      ::AfxTrace(_T(sz), p1, p2)
#define TRACE3(sz, p1, p2, p3)  ::AfxTrace(_T(sz), p1, p2, p3)

// These AFX_DUMP macros also provided for backward compatibility
#define AFX_DUMP0(dc, sz)   dc << _T(sz)
#define AFX_DUMP1(dc, sz, p1) dc << _T(sz) << p1

#else

#define ASSERT(f)          ((void)0)
#define VERIFY(f)          ((void)(f))
#define ASSERT_VALID(pOb)  ((void)0)
#define DEBUG_ONLY(f)      ((void)0)
inline void AFX_CDECL AfxTrace(LPCTSTR, ...) { }
#define TRACE              1 ? (void)0 : ::AfxTrace
#define TRACE0(sz)
#define TRACE1(sz, p1)
#define TRACE2(sz, p1, p2)
#define TRACE3(sz, p1, p2, p3)

#endif // !_DEBUG

#define ASSERT_POINTER(p, type) \
	ASSERT(((p) != NULL) && AfxIsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_NULL_OR_POINTER(p, type) \
	ASSERT(((p) == NULL) || AfxIsValidAddress((p), sizeof(type), FALSE))

/////////////////////////////////////////////////////////////////////////////
// Turn off warnings for /W4
// To resume any of these warning: #pragma warning(default: 4xxx)
// which should be placed after the AFX include files
#ifndef ALL_WARNINGS
// warnings generated with common MFC/Windows code
#pragma warning(disable: 4127)  // constant expression for TRACE/ASSERT
#pragma warning(disable: 4134)  // message map member fxn casts
#pragma warning(disable: 4201)  // nameless unions are part of C++
#pragma warning(disable: 4511)  // private copy constructors are good to have
#pragma warning(disable: 4512)  // private operator= are good to have
#pragma warning(disable: 4514)  // unreferenced inlines are common
#pragma warning(disable: 4710)  // private constructors are disallowed
#pragma warning(disable: 4705)  // statement has no effect in optimized code
#pragma warning(disable: 4191)  // pointer-to-function casting
// warnings caused by normal optimizations
#ifndef _DEBUG
#pragma warning(disable: 4701)  // local variable *may* be used without init
#pragma warning(disable: 4702)  // unreachable code caused by optimizations
#pragma warning(disable: 4791)  // loss of debugging info in release version
#pragma warning(disable: 4189)  // initialized but unused variable
#pragma warning(disable: 4390)  // empty controlled statement
#endif
// warnings specific to _AFXDLL version
#ifdef _AFXDLL
#pragma warning(disable: 4204)  // non-constant aggregate initializer
#endif
#ifdef _AFXDLL
#pragma warning(disable: 4275)  // deriving exported class from non-exported
#pragma warning(disable: 4251)  // using non-exported as public in exported
#endif
#endif //!ALL_WARNINGS

#ifdef _DEBUG
#define UNUSED(x)
#else
#define UNUSED(x) x
#endif
#define UNUSED_ALWAYS(x) x

/////////////////////////////////////////////////////////////////////////////
// Other implementation helpers

#define BEFORE_START_POSITION ((POSITION)-1L)

/////////////////////////////////////////////////////////////////////////////
// explicit initialization for general purpose classes

BOOL AFXAPI AfxInitialize(BOOL bDLL = FALSE, DWORD dwVersion = _MFC_VER);

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// Basic object model

struct CRuntimeClass
{
// Attributes
	LPCSTR m_lpszClassName;
	int m_nObjectSize;
	UINT m_wSchema; // schema number of the loaded class
	CObject* (PASCAL* m_pfnCreateObject)(); // NULL => abstract class
#ifdef _AFXDLL
	CRuntimeClass* (PASCAL* m_pfnGetBaseClass)();
#else
	CRuntimeClass* m_pBaseClass;
#endif

// Operations
	CObject* CreateObject();
	BOOL IsDerivedFrom(const CRuntimeClass* pBaseClass) const;

// Implementation
	void Store(CArchive& ar) const;
	static CRuntimeClass* PASCAL Load(CArchive& ar, UINT* pwSchemaNum);

	// CRuntimeClass objects linked together in simple list
	CRuntimeClass* m_pNextClass;       // linked list of registered classes
};

/////////////////////////////////////////////////////////////////////////////
// Strings

#ifndef _OLEAUTO_H_
#ifdef OLE2ANSI
	typedef LPSTR BSTR;
#else
	typedef LPWSTR BSTR;// must (semantically) match typedef in oleauto.h
#endif
#endif

struct CStringData
{
	long nRefs;             // reference count
	int nDataLength;        // length of data (including terminator)
	int nAllocLength;       // length of allocation
	// TCHAR data[nAllocLength]

	TCHAR* data()			// TCHAR* to managed data
		{ return (TCHAR*)(this+1); }
};

class CString
{
public:
// Constructors

	// constructs empty CString
	CString();
	// copy constructor
	CString(const CString& stringSrc);
	// from a single character
	CString(TCHAR ch, int nRepeat = 1);
	// from an ANSI string (converts to TCHAR)
	CString(LPCSTR lpsz);
	// from a UNICODE string (converts to TCHAR)
	CString(LPCWSTR lpsz);
#if _MFC_VER>=0x0600
	// subset of characters from an ANSI string (converts to TCHAR)
	CString(LPCSTR lpch, int nLength);
	// subset of characters from a UNICODE string (converts to TCHAR)
	CString(LPCWSTR lpch, int nLength);
#else
	// subset of characters from a string (converts to TCHAR)
	CString(LPCTSTR lpch, int nLength);
#endif
	// from unsigned characters
	CString(const unsigned char* psz);

// Attributes & Operations

	// get data length
	int GetLength() const;
	// TRUE if zero length
	BOOL IsEmpty() const;
	// clear contents to empty
	void Empty();

	// return single character at zero-based index
	TCHAR GetAt(int nIndex) const;
	// return single character at zero-based index
	TCHAR operator[](int nIndex) const;
	// set a single character at zero-based index
	void SetAt(int nIndex, TCHAR ch);
	// return pointer to const string
	operator LPCTSTR() const;

	// overloaded assignment

	// ref-counted copy from another CString
    const CString& operator=(const CString& stringSrc);
	// set string content to single character
	const CString& operator=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator=(char ch);
#endif
	// copy string content from ANSI string (converts to TCHAR)
	const CString& operator=(LPCSTR lpsz);
	// copy string content from UNICODE string (converts to TCHAR)
	const CString& operator=(LPCWSTR lpsz);
	// copy string content from unsigned chars
	const CString& operator=(const unsigned char* psz);

	// string concatenation

	// concatenate from another CString
	const CString& operator+=(const CString& string);

	// concatenate a single character
	const CString& operator+=(TCHAR ch);
#ifdef _UNICODE
	// concatenate an ANSI character after converting it to TCHAR
	const CString& operator+=(char ch);
#endif
	// concatenate a UNICODE character after converting it to TCHAR
	const CString& operator+=(LPCTSTR lpsz);

	friend CString AFXAPI operator+(const CString& string1,
			const CString& string2);
	friend CString AFXAPI operator+(const CString& string, TCHAR ch);
	friend CString AFXAPI operator+(TCHAR ch, const CString& string);
#ifdef _UNICODE
	friend CString AFXAPI operator+(const CString& string, char ch);
	friend CString AFXAPI operator+(char ch, const CString& string);
#endif
	friend CString AFXAPI operator+(const CString& string, LPCTSTR lpsz);
	friend CString AFXAPI operator+(LPCTSTR lpsz, const CString& string);

	// string comparison

	// straight character comparison
	int Compare(LPCTSTR lpsz) const;
	// compare ignoring case
	int CompareNoCase(LPCTSTR lpsz) const;
	// NLS aware comparison, case sensitive
	int Collate(LPCTSTR lpsz) const;
#if _MFC_VER>=0x0600
	// NLS aware comparison, case insensitive
	int CollateNoCase(LPCTSTR lpsz) const;
#endif

	// simple sub-string extraction

	// return nCount characters starting at zero-based nFirst
	CString Mid(int nFirst, int nCount) const;
	// return all characters starting at zero-based nFirst
	CString Mid(int nFirst) const;
	// return first nCount characters in string
	CString Left(int nCount) const;
	// return nCount characters from end of string
	CString Right(int nCount) const;

	//	characters from beginning that are also in passed string
	CString SpanIncluding(LPCTSTR lpszCharSet) const;
	// characters from beginning that are not also in passed string
	CString SpanExcluding(LPCTSTR lpszCharSet) const;

	// upper/lower/reverse conversion

	// NLS aware conversion to uppercase
	void MakeUpper();
	// NLS aware conversion to lowercase
	void MakeLower();
	// reverse string right-to-left
	void MakeReverse();

	// trimming whitespace (either side)

	// remove whitespace starting from right edge
	void TrimRight();
	// remove whitespace starting from left side
	void TrimLeft();

#if _MFC_VER>=0x0600
	// trimming anything (either side)

	// remove continuous occurrences of chTarget starting from right
	void TrimRight(TCHAR chTarget);
	// remove continuous occcurrences of characters in passed string,
	// starting from right
	void TrimRight(LPCTSTR lpszTargets);
	// remove continuous occurrences of chTarget starting from left
	void TrimLeft(TCHAR chTarget);
	// remove continuous occcurrences of characters in
	// passed string, starting from left
	void TrimLeft(LPCTSTR lpszTargets);

	// advanced manipulation

	// replace occurrences of chOld with chNew
	int Replace(TCHAR chOld, TCHAR chNew);
	// replace occurrences of substring lpszOld with lpszNew;
	// empty lpszNew removes instances of lpszOld
	int Replace(LPCTSTR lpszOld, LPCTSTR lpszNew);
	// remove occurrences of chRemove
	int Remove(TCHAR chRemove);
	// insert character at zero-based index; concatenates
	// if index is past end of string
	int Insert(int nIndex, TCHAR ch);
	// insert substring at zero-based index; concatenates
	// if index is past end of string
	int Insert(int nIndex, LPCTSTR pstr);
	// delete nCount characters starting at zero-based index
	int Delete(int nIndex, int nCount = 1);
#endif

	// searching

	// find character starting at left, -1 if not found
	int Find(TCHAR ch) const;
	// find character starting at right
	int ReverseFind(TCHAR ch) const;
#if _MFC_VER>=0x0600
	// find character starting at zero-based index and going right
	int Find(TCHAR ch, int nStart) const;
#endif
	// find first instance of any character in passed string
	int FindOneOf(LPCTSTR lpszCharSet) const;
	// find first instance of substring
	int Find(LPCTSTR lpszSub) const;
#if _MFC_VER>=0x0600
	// find first instance of substring starting at zero-based index
	int Find(LPCTSTR lpszSub, int nStart) const;
#endif

	// simple formatting

	// printf-like formatting using passed string
	void AFX_CDECL Format(LPCTSTR lpszFormat, ...);
	// printf-like formatting using referenced string resource
	void AFX_CDECL Format(UINT nFormatID, ...);
#if _MFC_VER<0x0600
protected:
#endif
	// printf-like formatting using variable arguments parameter
	void FormatV(LPCTSTR lpszFormat, va_list argList);
#if _MFC_VER<0x0600
public:
#endif

	// formatting for localization (uses FormatMessage API)

	// format using FormatMessage API on passed string
	void AFX_CDECL FormatMessage(LPCTSTR lpszFormat, ...);
	// format using FormatMessage API on referenced string resource
	void AFX_CDECL FormatMessage(UINT nFormatID, ...);

	// input and output
#ifdef _DEBUG
	friend CDumpContext& AFXAPI operator<<(CDumpContext& dc,
				const CString& string);
#endif
	friend CArchive& AFXAPI operator<<(CArchive& ar, const CString& string);
	friend CArchive& AFXAPI operator>>(CArchive& ar, CString& string);

	// load from string resource
	BOOL LoadString(UINT nID);

#ifndef _UNICODE
	// ANSI <-> OEM support (convert string in place)

	// convert string from ANSI to OEM in-place
	void AnsiToOem();
	// convert string from OEM to ANSI in-place
	void OemToAnsi();
#endif

#ifndef _AFX_NO_BSTR_SUPPORT
	// OLE BSTR support (use for OLE automation)

	// return a BSTR initialized with this CString's data
	BSTR AllocSysString() const;
	// reallocates the passed BSTR, copies content of this CString to it
	BSTR SetSysString(BSTR* pbstr) const;
#endif

	// Access to string implementation buffer as "C" character array

	// get pointer to modifiable buffer at least as long as nMinBufLength
	LPTSTR GetBuffer(int nMinBufLength);
	// release buffer, setting length to nNewLength (or to first nul if -1)
	void ReleaseBuffer(int nNewLength = -1);
	// get pointer to modifiable buffer exactly as long as nNewLength
	LPTSTR GetBufferSetLength(int nNewLength);
	// release memory allocated to but unused by string
	void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off

	// turn refcounting back on
	LPTSTR LockBuffer();
	// turn refcounting off
	void UnlockBuffer();

// Implementation
public:
	~CString();
	int GetAllocLength() const;

protected:
	LPTSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CStringData* GetData() const;
	void Init();
	void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
	void CopyBeforeWrite();
	void AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CStringData* pData);
	static int PASCAL SafeStrlen(LPCTSTR lpsz);
#if _MFC_VER>=0x0600
	static void FASTCALL FreeData(CStringData* pData);
#endif
};

// Compare helpers
bool AFXAPI operator==(const CString& s1, const CString& s2);
bool AFXAPI operator==(const CString& s1, LPCTSTR s2);
bool AFXAPI operator==(LPCTSTR s1, const CString& s2);
bool AFXAPI operator!=(const CString& s1, const CString& s2);
bool AFXAPI operator!=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator!=(LPCTSTR s1, const CString& s2);
bool AFXAPI operator<(const CString& s1, const CString& s2);
bool AFXAPI operator<(const CString& s1, LPCTSTR s2);
bool AFXAPI operator<(LPCTSTR s1, const CString& s2);
bool AFXAPI operator>(const CString& s1, const CString& s2);
bool AFXAPI operator>(const CString& s1, LPCTSTR s2);
bool AFXAPI operator>(LPCTSTR s1, const CString& s2);
bool AFXAPI operator<=(const CString& s1, const CString& s2);
bool AFXAPI operator<=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator<=(LPCTSTR s1, const CString& s2);
bool AFXAPI operator>=(const CString& s1, const CString& s2);
bool AFXAPI operator>=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator>=(LPCTSTR s1, const CString& s2);

// conversion helpers
int AFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, UINT count);
int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, UINT count);

// Globals
extern AFX_DATA TCHAR afxChNil;
#if _MFC_VER>=0x0600
#ifdef _AFXDLL
const CString& AFXAPI AfxGetEmptyString();
#define afxEmptyString AfxGetEmptyString()
#else
extern LPCTSTR _afxPchNil;
#define afxEmptyString ((CString&)*(CString*)&_afxPchNil)
#endif
#else
const CString& AFXAPI AfxGetEmptyString();
#define afxEmptyString AfxGetEmptyString()
#endif  // _MFC_VER

/////////////////////////////////////////////////////////////////////////////
// class CObject is the root of all compliant objects

#ifdef _AFXDLL
class CObject
#else
class AFX_NOVTABLE CObject
#endif
{
public:

// Object model (types, destruction, allocation)
	virtual CRuntimeClass* GetRuntimeClass() const;
	virtual ~CObject();  // virtual destructors are necessary

	// Diagnostic allocations
	void* PASCAL operator new(size_t nSize);
	void* PASCAL operator new(size_t, void* p);
	void PASCAL operator delete(void* p);
#if _MSC_VER>=1200
	void PASCAL operator delete(void* p, void* pPlace);
#endif

#if defined
	// for file name/line number tracking using DEBUG_NEW
	void* PASCAL operator new(size_t nSize, LPCSTR lpszFileName, int nLine);
#if _MFC_VER>=0x0600 && _MSC_VER>=1200
	void PASCAL operator delete(void *p, LPCSTR lpszFileName, int nLine);
#endif
#endif

	// Disable the copy constructor and assignment by default so you will get
	//   compiler errors instead of unexpected behaviour if you pass objects
	//   by value or assign objects.
protected:
	CObject();
private:
	CObject(const CObject& objectSrc);              // no implementation
	void operator=(const CObject& objectSrc);       // no implementation

// Attributes
public:
	BOOL IsSerializable() const;
	BOOL IsKindOf(const CRuntimeClass* pClass) const;

// Overridables
	virtual void Serialize(CArchive& ar);

#if _MFC_VER<0x0600 || defined
	// Diagnostic Support
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Implementation
public:
	static const AFX_DATA CRuntimeClass classCObject;
#ifdef _AFXDLL
	static CRuntimeClass* PASCAL _GetBaseClass();
#endif
};

// Helper macros
#define RUNTIME_CLASS(class_name) ((CRuntimeClass*)(&class_name::class##class_name))
#define ASSERT_KINDOF(class_name, object) \
	ASSERT((object)->IsKindOf(RUNTIME_CLASS(class_name)))

// RTTI helper macros/functions
const CObject* AFX_CDECL AfxDynamicDownCast(CRuntimeClass* pClass, const CObject* pObject);
CObject* AFX_CDECL AfxDynamicDownCast(CRuntimeClass* pClass, CObject* pObject);
#define DYNAMIC_DOWNCAST(class_name, object) \
	(class_name*)AfxDynamicDownCast(RUNTIME_CLASS(class_name), object)

#ifdef _DEBUG
const CObject* AFX_CDECL AfxStaticDownCast(CRuntimeClass* pClass, const CObject* pObject);
CObject* AFX_CDECL AfxStaticDownCast(CRuntimeClass* pClass, CObject* pObject);
#define STATIC_DOWNCAST(class_name, object) \
	((class_name*)AfxStaticDownCast(RUNTIME_CLASS(class_name), object))
#else
#define STATIC_DOWNCAST(class_name, object) ((class_name*)object)
#endif

//////////////////////////////////////////////////////////////////////////////
// Helper macros for declaring CRuntimeClass compatible classes

#ifdef _AFXDLL
#define DECLARE_DYNAMIC(class_name) \
protected: \
	static CRuntimeClass* PASCAL _GetBaseClass(); \
public: \
	static const AFX_DATA CRuntimeClass class##class_name; \
	virtual CRuntimeClass* GetRuntimeClass() const; \

#define _DECLARE_DYNAMIC(class_name) \
protected: \
	static CRuntimeClass* PASCAL _GetBaseClass(); \
public: \
	static AFX_DATA CRuntimeClass class##class_name; \
	virtual CRuntimeClass* GetRuntimeClass() const; \

#else
#define DECLARE_DYNAMIC(class_name) \
public: \
	static const AFX_DATA CRuntimeClass class##class_name; \
	virtual CRuntimeClass* GetRuntimeClass() const; \

#define _DECLARE_DYNAMIC(class_name) \
public: \
	static AFX_DATA CRuntimeClass class##class_name; \
	virtual CRuntimeClass* GetRuntimeClass() const; \

#endif

// not serializable, but dynamically constructable
#define DECLARE_DYNCREATE(class_name) \
	DECLARE_DYNAMIC(class_name) \
	static CObject* PASCAL CreateObject();

#define _DECLARE_DYNCREATE(class_name) \
	_DECLARE_DYNAMIC(class_name) \
	static CObject* PASCAL CreateObject();

#define DECLARE_SERIAL(class_name) \
	_DECLARE_DYNCREATE(class_name) \
	AFX_API friend CArchive& AFXAPI operator>>(CArchive& ar, class_name* &pOb);

// generate static object constructor for class registration
#if _MFC_VER>=0x600
void AFXAPI AfxClassInit(CRuntimeClass* pNewClass);
struct AFX_CLASSINIT
	{ AFX_CLASSINIT(CRuntimeClass* pNewClass) { AfxClassInit(pNewClass); } };
struct AFX_CLASSINIT_COMPAT
	{ AFX_CLASSINIT_COMPAT(CRuntimeClass* pNewClass); };
#else
struct AFX_CLASSINIT
	{ AFX_CLASSINIT(CRuntimeClass* pNewClass); };
#endif

#ifdef _AFXDLL
#define IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, pfnNew) \
	CRuntimeClass* PASCAL class_name::_GetBaseClass() \
		{ return RUNTIME_CLASS(base_class_name); } \
	AFX_COMDAT const AFX_DATADEF CRuntimeClass class_name::class##class_name = { \
		#class_name, sizeof(class class_name), wSchema, pfnNew, \
			&class_name::_GetBaseClass, NULL }; \
	CRuntimeClass* class_name::GetRuntimeClass() const \
		{ return RUNTIME_CLASS(class_name); } \

#define _IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, pfnNew) \
	CRuntimeClass* PASCAL class_name::_GetBaseClass() \
		{ return RUNTIME_CLASS(base_class_name); } \
	AFX_COMDAT AFX_DATADEF CRuntimeClass class_name::class##class_name = { \
		#class_name, sizeof(class class_name), wSchema, pfnNew, \
			&class_name::_GetBaseClass, NULL }; \
	CRuntimeClass* class_name::GetRuntimeClass() const \
		{ return RUNTIME_CLASS(class_name); } \

#else
#define IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, pfnNew) \
	AFX_COMDAT const AFX_DATADEF CRuntimeClass class_name::class##class_name = { \
		#class_name, sizeof(class class_name), wSchema, pfnNew, \
			RUNTIME_CLASS(base_class_name), NULL }; \
	CRuntimeClass* class_name::GetRuntimeClass() const \
		{ return RUNTIME_CLASS(class_name); } \

#define _IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, pfnNew) \
	AFX_DATADEF CRuntimeClass class_name::class##class_name = { \
		#class_name, sizeof(class class_name), wSchema, pfnNew, \
			RUNTIME_CLASS(base_class_name), NULL }; \
	CRuntimeClass* class_name::GetRuntimeClass() const \
		{ return RUNTIME_CLASS(class_name); } \

#endif

#define IMPLEMENT_DYNAMIC(class_name, base_class_name) \
	IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, 0xFFFF, NULL)

#define IMPLEMENT_DYNCREATE(class_name, base_class_name) \
	CObject* PASCAL class_name::CreateObject() \
		{ return new class_name; } \
	IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, 0xFFFF, \
		class_name::CreateObject)

#if _MFC_VER>=0x0600
#define IMPLEMENT_SERIAL(class_name, base_class_name, wSchema) \
	CObject* PASCAL class_name::CreateObject() \
		{ return new class_name; } \
	_IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, \
		class_name::CreateObject) \
	AFX_CLASSINIT _init_##class_name(RUNTIME_CLASS(class_name)); \
	CArchive& AFXAPI operator>>(CArchive& ar, class_name* &pOb) \
		{ pOb = (class_name*) ar.ReadObject(RUNTIME_CLASS(class_name)); \
			return ar; } \

#else

#define IMPLEMENT_SERIAL(class_name, base_class_name, wSchema) \
	CObject* PASCAL class_name::CreateObject() \
		{ return new class_name; } \
	_IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, \
		class_name::CreateObject) \
	static const AFX_CLASSINIT _init_##class_name(RUNTIME_CLASS(class_name)); \
	CArchive& AFXAPI operator>>(CArchive& ar, class_name* &pOb) \
		{ pOb = (class_name*) ar.ReadObject(RUNTIME_CLASS(class_name)); \
			return ar; } \

#endif

// optional bit for schema number that enables object versioning
#define VERSIONABLE_SCHEMA  (0x80000000)

/////////////////////////////////////////////////////////////////////////////
// other helpers

// zero fill everything after the vtbl pointer
#define AFX_ZERO_INIT_OBJECT(base_class) \
	memset(((base_class*)this)+1, 0, sizeof(*this) - sizeof(class base_class));


/////////////////////////////////////////////////////////////////////////////
// Exceptions

#ifdef _AFXDLL
class CException : public CObject
#else
class AFX_NOVTABLE CException : public CObject
#endif
{
	// abstract class for dynamic type checking
	DECLARE_DYNAMIC(CException)

public:
// Constructors
	CException();   // sets m_bAutoDelete = TRUE
	CException(BOOL bAutoDelete);   // sets m_bAutoDelete = bAutoDelete

// Operations
	void Delete();  // use to delete exception in 'catch' block

	virtual BOOL GetErrorMessage(LPTSTR lpszError, UINT nMaxError,
		PUINT pnHelpContext = NULL);
	virtual int ReportError(UINT nType = MB_OK, UINT nMessageID = 0);

// Implementation (setting m_bAutoDelete to FALSE is advanced)
public:
	virtual ~CException();
	BOOL m_bAutoDelete;
#ifdef _DEBUG
	void PASCAL operator delete(void* pbData);
#if _MSC_VER>=1200 && _MFC_VER>=0x0600
	void PASCAL operator delete(void* pbData, LPCSTR lpszFileName, int nLine);
#endif
protected:
	BOOL m_bReadyForDelete;
#endif
};

#ifdef _AFXDLL
class CSimpleException : public CException
#else
class AFX_NOVTABLE CSimpleException : public CException
#endif
{
	// base class for resource-critical MFC exceptions
	// handles ownership and initialization of an error message

public:
// Constructors
	CSimpleException();
	CSimpleException(BOOL bAutoDelete);

// Operations
	virtual BOOL GetErrorMessage(LPTSTR lpszError, UINT nMaxError,
		PUINT pnHelpContext = NULL);

// Implementation (setting m_bAutoDelete to FALSE is advanced)
public:
	virtual ~CSimpleException();
	BOOL m_bAutoDelete;

	void InitString();      // used during MFC initialization

protected:
	BOOL m_bInitialized;
	BOOL m_bLoaded;
	TCHAR m_szMessage[128];
	UINT m_nResourceID;

#ifdef _DEBUG
	BOOL m_bReadyForDelete;
#endif
};

// helper routines for non-C++ EH implementations
#ifdef _AFX_OLD_EXCEPTIONS
	BOOL AFXAPI AfxCatchProc(CRuntimeClass* pClass);
	void AFXAPI AfxThrow(CException* pException);
#else
	// for THROW_LAST auto-delete backward compatiblity
	void AFXAPI AfxThrowLastCleanup();
#endif

// other out-of-line helper functions
void AFXAPI AfxTryCleanup();

#ifndef _AFX_JUMPBUF
// Use portable 'jmp_buf' defined by ANSI by default.
#define _AFX_JUMPBUF jmp_buf
#endif

// Placed on frame for EXCEPTION linkage, or CException cleanup
struct AFX_EXCEPTION_LINK
{
#ifdef _AFX_OLD_EXCEPTIONS
	union
	{
		_AFX_JUMPBUF m_jumpBuf;
		struct
		{
			void (PASCAL* pfnCleanup)(AFX_EXCEPTION_LINK* pLink);
			void* pvData;       // extra data follows
		} m_callback;       // callback for cleanup (nType != 0)
	};
	UINT m_nType;               // 0 for setjmp, !=0 for user extension
#endif //!_AFX_OLD_EXCEPTIONS

	AFX_EXCEPTION_LINK* m_pLinkPrev;    // previous top, next in handler chain
	CException* m_pException;   // current exception (NULL in TRY block)

	AFX_EXCEPTION_LINK();       // for initialization and linking
	~AFX_EXCEPTION_LINK()       // for cleanup and unlinking
		{ AfxTryCleanup(); };
};

// Exception global state - never access directly
struct AFX_EXCEPTION_CONTEXT
{
	AFX_EXCEPTION_LINK* m_pLinkTop;

	// Note: most of the exception context is now in the AFX_EXCEPTION_LINK
};

#ifndef _PNH_DEFINED
typedef int (__cdecl * _PNH)( size_t );
#define _PNH_DEFINED
#endif

_PNH AFXAPI AfxGetNewHandler();
_PNH AFXAPI AfxSetNewHandler(_PNH pfnNewHandler);
int AFX_CDECL AfxNewHandler(size_t nSize);

void AFXAPI AfxAbort();

#ifdef _AFX_OLD_EXCEPTIONS

// Obsolete and non-portable: setting terminate handler
//  use CWinApp::ProcessWndProcException for Windows apps instead
//  can also use set_terminate which is part of C++ standard library
//      (these are provided for backward compatibility)
void AFXAPI AfxTerminate();
typedef void (AFXAPI* AFX_TERM_PROC)();
AFX_TERM_PROC AFXAPI AfxSetTerminate(AFX_TERM_PROC);

#endif

/////////////////////////////////////////////////////////////////////////////
// Exception macros using try, catch and throw
//  (for backward compatibility to previous versions of MFC)

#ifndef _AFX_OLD_EXCEPTIONS

#define TRY { AFX_EXCEPTION_LINK _afxExceptionLink; try {

#define CATCH(class, e) } catch (class* e) \
	{ ASSERT(e->IsKindOf(RUNTIME_CLASS(class))); \
		_afxExceptionLink.m_pException = e;

#define AND_CATCH(class, e) } catch (class* e) \
	{ ASSERT(e->IsKindOf(RUNTIME_CLASS(class))); \
		_afxExceptionLink.m_pException = e;

#define END_CATCH } }

#define THROW(e) throw e
#define THROW_LAST() (AfxThrowLastCleanup(), throw)

// Advanced macros for smaller code
#define CATCH_ALL(e) } catch (CException* e) \
	{ { ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); \
		_afxExceptionLink.m_pException = e;

#define AND_CATCH_ALL(e) } catch (CException* e) \
	{ { ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); \
		_afxExceptionLink.m_pException = e;

#define END_CATCH_ALL } } }

#define END_TRY } catch (CException* e) \
	{ ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); \
		_afxExceptionLink.m_pException = e; } }

#else

/////////////////////////////////////////////////////////////////////////////
// Exception macros using setjmp and longjmp
//  (for portability to compilers with no support for C++ exception handling)

#define TRY \
	{ AFX_EXCEPTION_LINK _afxExceptionLink; \
	if (::setjmp(_afxExceptionLink.m_jumpBuf) == 0)

#define CATCH(class, e) \
	else if (::AfxCatchProc(RUNTIME_CLASS(class))) \
	{ class* e = (class*)_afxExceptionLink.m_pException;

#define AND_CATCH(class, e) \
	} else if (::AfxCatchProc(RUNTIME_CLASS(class))) \
	{ class* e = (class*)_afxExceptionLink.m_pException;

#define END_CATCH \
	} else { ::AfxThrow(NULL); } }

#define THROW(e) AfxThrow(e)
#define THROW_LAST() AfxThrow(NULL)

// Advanced macros for smaller code
#define CATCH_ALL(e) \
	else { CException* e = _afxExceptionLink.m_pException;

#define AND_CATCH_ALL(e) \
	} else { CException* e = _afxExceptionLink.m_pException;

#define END_CATCH_ALL } }

#define END_TRY }

#endif //_AFX_OLD_EXCEPTIONS

/////////////////////////////////////////////////////////////////////////////
// Standard Exception classes

class CMemoryException : public CSimpleException
{
	DECLARE_DYNAMIC(CMemoryException)
public:
	CMemoryException();

// Implementation
public:
	CMemoryException(BOOL bAutoDelete);
	CMemoryException(BOOL bAutoDelete, UINT nResourceID);
	virtual ~CMemoryException();
};

class CNotSupportedException : public CSimpleException
{
	DECLARE_DYNAMIC(CNotSupportedException)
public:
	CNotSupportedException();

// Implementation
public:
	CNotSupportedException(BOOL bAutoDelete);
	CNotSupportedException(BOOL bAutoDelete, UINT nResourceID);
	virtual ~CNotSupportedException();
};

class CArchiveException : public CException
{
	DECLARE_DYNAMIC(CArchiveException)
public:
	enum {
		none,
		generic,
		readOnly,
		endOfFile,
		writeOnly,
		badIndex,
		badClass,
		badSchema
	};

// Constructor
	CArchiveException(int cause = CArchiveException::none,
		LPCTSTR lpszArchiveName = NULL);

// Attributes
	int m_cause;
	CString m_strFileName;

// Implementation
public:
	virtual ~CArchiveException();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual BOOL GetErrorMessage(LPTSTR lpszError, UINT nMaxError,
		PUINT pnHelpContext = NULL);
};

class CFileException : public CException
{
	DECLARE_DYNAMIC(CFileException)

public:
	enum {
		none,
		generic,
		fileNotFound,
		badPath,
		tooManyOpenFiles,
		accessDenied,
		invalidFile,
		removeCurrentDir,
		directoryFull,
		badSeek,
		hardIO,
		sharingViolation,
		lockViolation,
		diskFull,
		endOfFile
	};

// Constructor
	CFileException(int cause = CFileException::none, LONG lOsError = -1,
		LPCTSTR lpszArchiveName = NULL);

// Attributes
	int     m_cause;
	LONG    m_lOsError;
	CString m_strFileName;

// Operations
	// convert a OS dependent error code to a Cause
	static int PASCAL OsErrorToException(LONG lOsError);
	static int PASCAL ErrnoToException(int nErrno);

	// helper functions to throw exception after converting to a Cause
	static void PASCAL ThrowOsError(LONG lOsError, LPCTSTR lpszFileName = NULL);
	static void PASCAL ThrowErrno(int nErrno, LPCTSTR lpszFileName = NULL);

// Implementation
public:
	virtual ~CFileException();
#ifdef _DEBUG
	virtual void Dump(CDumpContext&) const;
#endif
	virtual BOOL GetErrorMessage(LPTSTR lpszError, UINT nMaxError,
		PUINT pnHelpContext = NULL);
};

/////////////////////////////////////////////////////////////////////////////
// Standard exception throws

void AFXAPI AfxThrowMemoryException();
void AFXAPI AfxThrowNotSupportedException();
void AFXAPI AfxThrowArchiveException(int cause,
	LPCTSTR lpszArchiveName = NULL);
void AFXAPI AfxThrowFileException(int cause, LONG lOsError = -1,
	LPCTSTR lpszFileName = NULL);

/////////////////////////////////////////////////////////////////////////////
// File - raw unbuffered disk file I/O

class CFile : public CObject
{
	DECLARE_DYNAMIC(CFile)

public:
// Flag values
	enum OpenFlags {
		modeRead =          0x0000,
		modeWrite =         0x0001,
		modeReadWrite =     0x0002,
		shareCompat =       0x0000,
		shareExclusive =    0x0010,
		shareDenyWrite =    0x0020,
		shareDenyRead =     0x0030,
		shareDenyNone =     0x0040,
		modeNoInherit =     0x0080,
		modeCreate =        0x1000,
		modeNoTruncate =    0x2000,
		typeText =          0x4000, // typeText and typeBinary are used in
		typeBinary =   (int)0x8000 // derived classes only
		};

	enum Attribute {
		normal =    0x00,
		readOnly =  0x01,
		hidden =    0x02,
		system =    0x04,
		volume =    0x08,
		directory = 0x10,
		archive =   0x20
		};

	enum SeekPosition { begin = 0x0, current = 0x1, end = 0x2 };

	enum { hFileNull = -1 };

// Constructors
	CFile();
	CFile(INT_PTR hFile);
	CFile(LPCTSTR lpszFileName, UINT nOpenFlags);

// Attributes
	UINT_PTR m_hFile;
	operator HFILE() const;

	virtual DWORD GetPosition() const;
	BOOL GetStatus(CFileStatus& rStatus) const;
	virtual CString GetFileName() const;
	virtual CString GetFileTitle() const;
	virtual CString GetFilePath() const;
	virtual void SetFilePath(LPCTSTR lpszNewName);

// Operations
	virtual BOOL Open(LPCTSTR lpszFileName, UINT nOpenFlags,
		CFileException* pError = NULL);

	static void PASCAL Rename(LPCTSTR lpszOldName,
				LPCTSTR lpszNewName);
	static void PASCAL Remove(LPCTSTR lpszFileName);
	static BOOL PASCAL GetStatus(LPCTSTR lpszFileName,
				CFileStatus& rStatus);
	static void PASCAL SetStatus(LPCTSTR lpszFileName,
				const CFileStatus& status);

	DWORD SeekToEnd();
	void SeekToBegin();

	// backward compatible ReadHuge and WriteHuge
	DWORD ReadHuge(void* lpBuffer, DWORD dwCount);
	void WriteHuge(const void* lpBuffer, DWORD dwCount);

// Overridables
	virtual CFile* Duplicate() const;

	virtual LONG Seek(LONG lOff, UINT nFrom);
	virtual void SetLength(DWORD dwNewLen);
	virtual DWORD GetLength() const;

	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);

	virtual void LockRange(DWORD dwPos, DWORD dwCount);
	virtual void UnlockRange(DWORD dwPos, DWORD dwCount);

	virtual void Abort();
	virtual void Flush();
	virtual void Close();

// Implementation
public:
	virtual ~CFile();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	enum BufferCommand { bufferRead, bufferWrite, bufferCommit, bufferCheck };
	virtual UINT GetBufferPtr(UINT nCommand, UINT nCount = 0,
		void** ppBufStart = NULL, void** ppBufMax = NULL);

protected:
	BOOL m_bCloseOnDelete;
	CString m_strFileName;
};

/////////////////////////////////////////////////////////////////////////////
// STDIO file implementation

class CStdioFile : public CFile
{
	DECLARE_DYNAMIC(CStdioFile)

public:
// Constructors
	CStdioFile();
	CStdioFile(FILE* pOpenStream);
	CStdioFile(LPCTSTR lpszFileName, UINT nOpenFlags);

// Attributes
	FILE* m_pStream;    // stdio FILE
						// m_hFile from base class is _fileno(m_pStream)

// Operations
	// reading and writing strings
	virtual void WriteString(LPCTSTR lpsz);
	virtual LPTSTR ReadString(LPTSTR lpsz, UINT nMax);
	virtual BOOL ReadString(CString& rString);

// Implementation
public:
	virtual ~CStdioFile();
#ifdef _DEBUG
	void Dump(CDumpContext& dc) const;
#endif
	virtual DWORD GetPosition() const;
	virtual BOOL Open(LPCTSTR lpszFileName, UINT nOpenFlags,
		CFileException* pError = NULL);
	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);
	virtual LONG Seek(LONG lOff, UINT nFrom);
	virtual void Abort();
	virtual void Flush();
	virtual void Close();

	// Unsupported APIs
	virtual CFile* Duplicate() const;
	virtual void LockRange(DWORD dwPos, DWORD dwCount);
	virtual void UnlockRange(DWORD dwPos, DWORD dwCount);
};

////////////////////////////////////////////////////////////////////////////
// Memory based file implementation

class CMemFile : public CFile
{
	DECLARE_DYNAMIC(CMemFile)

public:
// Constructors
	CMemFile(UINT nGrowBytes = 1024);
	CMemFile(BYTE* lpBuffer, UINT nBufferSize, UINT nGrowBytes = 0);

// Operations
	void Attach(BYTE* lpBuffer, UINT nBufferSize, UINT nGrowBytes = 0);
	BYTE* Detach();

// Advanced Overridables
protected:
	virtual BYTE* Alloc(DWORD nBytes);
	virtual BYTE* Realloc(BYTE* lpMem, DWORD nBytes);
	virtual BYTE* Memcpy(BYTE* lpMemTarget, const BYTE* lpMemSource, UINT nBytes);
	virtual void Free(BYTE* lpMem);
	virtual void GrowFile(DWORD dwNewLen);

// Implementation
protected:
	UINT m_nGrowBytes;
	DWORD m_nPosition;
	DWORD m_nBufferSize;
	DWORD m_nFileSize;
	BYTE* m_lpBuffer;
	BOOL m_bAutoDelete;

public:
	virtual ~CMemFile();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif
	virtual DWORD GetPosition() const;
	BOOL GetStatus(CFileStatus& rStatus) const;
	virtual LONG Seek(LONG lOff, UINT nFrom);
	virtual void SetLength(DWORD dwNewLen);
	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);
	virtual void Abort();
	virtual void Flush();
	virtual void Close();
	virtual UINT GetBufferPtr(UINT nCommand, UINT nCount = 0,
		void** ppBufStart = NULL, void** ppBufMax = NULL);

	// Unsupported APIs
	virtual CFile* Duplicate() const;
	virtual void LockRange(DWORD dwPos, DWORD dwCount);
	virtual void UnlockRange(DWORD dwPos, DWORD dwCount);
};

////////////////////////////////////////////////////////////////////////////
// Local file searches

class CFileFind : public CObject
{
public:
	CFileFind();
	virtual ~CFileFind();

// Attributes
public:
	DWORD GetLength() const;
#if defined
	__int64 GetLength64() const;
#endif
	virtual CString GetFileName() const;
	virtual CString GetFilePath() const;
	virtual CString GetFileTitle() const;
	virtual CString GetFileURL() const;
	virtual CString GetRoot() const;

	virtual BOOL GetLastWriteTime(FILETIME* pTimeStamp) const;
	virtual BOOL GetLastAccessTime(FILETIME* pTimeStamp) const;
	virtual BOOL GetCreationTime(FILETIME* pTimeStamp) const;
	virtual BOOL GetLastWriteTime(CTime& refTime) const;
	virtual BOOL GetLastAccessTime(CTime& refTime) const;
	virtual BOOL GetCreationTime(CTime& refTime) const;

	virtual BOOL MatchesMask(DWORD dwMask) const;

	virtual BOOL IsDots() const;
	// these aren't virtual because they all use MatchesMask(), which is
	BOOL IsReadOnly() const;
	BOOL IsDirectory() const;
	BOOL IsCompressed() const;
	BOOL IsSystem() const;
	BOOL IsHidden() const;
	BOOL IsTemporary() const;
	BOOL IsNormal() const;
	BOOL IsArchived() const;

// Operations
	void Close();
	virtual BOOL FindFile(LPCTSTR pstrName = NULL, DWORD dwUnused = 0);
	virtual BOOL FindNextFile();

protected:
	virtual void CloseContext();

// Implementation
protected:
	void* m_pFoundInfo;
	void* m_pNextInfo;
	HANDLE m_hContext;
	BOOL m_bGotLast;
	CString m_strRoot;
	TCHAR m_chDirSeparator;     // not '\\' for Internet classes

#ifdef _DEBUG
	void Dump(CDumpContext& dc) const;
	void AssertValid() const;
#endif

	DECLARE_DYNAMIC(CFileFind)
};

/////////////////////////////////////////////////////////////////////////////
// CTimeSpan and CTime

class CTimeSpan
{
public:

// Constructors
	CTimeSpan();
	CTimeSpan(time_t time);
	CTimeSpan(LONG lDays, int nHours, int nMins, int nSecs);

	CTimeSpan(const CTimeSpan& timeSpanSrc);
	const CTimeSpan& operator=(const CTimeSpan& timeSpanSrc);

// Attributes
	// extract parts
	LONG_PTR GetDays() const;   // total # of days
	LONG_PTR GetTotalHours() const;
	int GetHours() const;
	LONG_PTR GetTotalMinutes() const;
	int GetMinutes() const;
	LONG_PTR GetTotalSeconds() const;
	int GetSeconds() const;

// Operations
	// time math
	CTimeSpan operator-(CTimeSpan timeSpan) const;
	CTimeSpan operator+(CTimeSpan timeSpan) const;
	const CTimeSpan& operator+=(CTimeSpan timeSpan);
	const CTimeSpan& operator-=(CTimeSpan timeSpan);
	BOOL operator==(CTimeSpan timeSpan) const;
	BOOL operator!=(CTimeSpan timeSpan) const;
	BOOL operator<(CTimeSpan timeSpan) const;
	BOOL operator>(CTimeSpan timeSpan) const;
	BOOL operator<=(CTimeSpan timeSpan) const;
	BOOL operator>=(CTimeSpan timeSpan) const;

#ifdef _UNICODE
	// for compatibility with MFC 3.x
	CString Format(LPCSTR pFormat) const;
#endif
	CString Format(LPCTSTR pFormat) const;
	CString Format(UINT nID) const;

	// serialization
#ifdef _DEBUG
	friend CDumpContext& AFXAPI operator<<(CDumpContext& dc,CTimeSpan timeSpan);
#endif
	friend CArchive& AFXAPI operator<<(CArchive& ar, CTimeSpan timeSpan);
	friend CArchive& AFXAPI operator>>(CArchive& ar, CTimeSpan& rtimeSpan);

private:
	time_t m_timeSpan;
	friend class CTime;
};

class CTime
{
public:

// Constructors
	static CTime PASCAL GetCurrentTime();

	CTime();
	CTime(time_t time);
	CTime(int nYear, int nMonth, int nDay, int nHour, int nMin, int nSec,
		int nDST = -1);
	CTime(WORD wDosDate, WORD wDosTime, int nDST = -1);
	CTime(const CTime& timeSrc);

	CTime(const SYSTEMTIME& sysTime, int nDST = -1);
	CTime(const FILETIME& fileTime, int nDST = -1);
	const CTime& operator=(const CTime& timeSrc);
	const CTime& operator=(time_t t);

// Attributes
	struct tm* GetGmtTm(struct tm* ptm = NULL) const;
	struct tm* GetLocalTm(struct tm* ptm = NULL) const;
#if _MFC_VER>=0x0600
	BOOL GetAsSystemTime(SYSTEMTIME& timeDest) const;
#endif

	time_t GetTime() const;
	int GetYear() const;
	int GetMonth() const;       // month of year (1 = Jan)
	int GetDay() const;         // day of month
	int GetHour() const;
	int GetMinute() const;
	int GetSecond() const;
	int GetDayOfWeek() const;   // 1=Sun, 2=Mon, ..., 7=Sat

// Operations
	// time math
	CTimeSpan operator-(CTime time) const;
	CTime operator-(CTimeSpan timeSpan) const;
	CTime operator+(CTimeSpan timeSpan) const;
	const CTime& operator+=(CTimeSpan timeSpan);
	const CTime& operator-=(CTimeSpan timeSpan);
	BOOL operator==(CTime time) const;
	BOOL operator!=(CTime time) const;
	BOOL operator<(CTime time) const;
	BOOL operator>(CTime time) const;
	BOOL operator<=(CTime time) const;
	BOOL operator>=(CTime time) const;

	// formatting using "C" strftime
	CString Format(LPCTSTR pFormat) const;
	CString FormatGmt(LPCTSTR pFormat) const;
	CString Format(UINT nFormatID) const;
	CString FormatGmt(UINT nFormatID) const;

#ifdef _UNICODE
	// for compatibility with MFC 3.x
	CString Format(LPCSTR pFormat) const;
	CString FormatGmt(LPCSTR pFormat) const;
#endif

	// serialization
#ifdef _DEBUG
	friend CDumpContext& AFXAPI operator<<(CDumpContext& dc, CTime time);
#endif
	friend CArchive& AFXAPI operator<<(CArchive& ar, CTime time);
	friend CArchive& AFXAPI operator>>(CArchive& ar, CTime& rtime);

private:
	time_t m_time;
};

/////////////////////////////////////////////////////////////////////////////
// File status

struct CFileStatus
{
	CTime m_ctime;          // creation date/time of file
	CTime m_mtime;          // last modification date/time of file
	CTime m_atime;          // last access date/time of file
	LONG m_size;            // logical size of file in bytes
	BYTE m_attribute;       // logical OR of CFile::Attribute enum values
	BYTE _m_padding;        // pad the structure to a WORD
	TCHAR m_szFullName[_MAX_PATH]; // absolute path name

#ifdef _DEBUG
	void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// Diagnostic memory management routines

// Low level sanity checks for memory blocks
BOOL AFXAPI AfxIsValidAddress(const void* lp,
			UINT_PTR nBytes, BOOL bReadWrite = TRUE);
BOOL AFXAPI AfxIsValidString(LPCWSTR lpsz, int nLength = -1);
BOOL AFXAPI AfxIsValidString(LPCSTR lpsz, int nLength = -1);

#if defined

// Memory tracking allocation
void* AFX_CDECL operator new(size_t nSize, LPCSTR lpszFileName, int nLine);
#define DEBUG_NEW new(THIS_FILE, __LINE__)
#if _MSC_VER>=1200 && _MFC_VER>=0x0600
void AFX_CDECL operator delete(void* p, LPCSTR lpszFileName, int nLine);
#endif

void* AFXAPI AfxAllocMemoryDebug(size_t nSize, BOOL bIsObject,
	LPCSTR lpszFileName, int nLine);
void AFXAPI AfxFreeMemoryDebug(void* pbData, BOOL bIsObject);

// Dump any memory leaks since program started
BOOL AFXAPI AfxDumpMemoryLeaks();

// Return TRUE if valid memory block of nBytes
BOOL AFXAPI AfxIsMemoryBlock(const void* p, UINT nBytes,
	LONG* plRequestNumber = NULL);

// Return TRUE if memory is sane or print out what is wrong
BOOL AFXAPI AfxCheckMemory();

#define afxMemDF _crtDbgFlag

enum AfxMemDF // memory debug/diagnostic flags
{
	allocMemDF          = 0x01,         // turn on debugging allocator
	delayFreeMemDF      = 0x02,         // delay freeing memory
	checkAlwaysMemDF    = 0x04          // AfxCheckMemory on every alloc/free
};

#ifdef _UNICODE
#define AfxOutputDebugString(lpsz) \
	do \
	{ \
    USES_CONVERSION; \
		_RPT0(_CRT_WARN, W2CA(lpsz)); \
	} while (0)
#else
#define AfxOutputDebugString(lpsz) _RPT0(_CRT_WARN, lpsz)
#endif

// turn on/off tracking for a short while
BOOL AFXAPI AfxEnableMemoryTracking(BOOL bTrack);

// Advanced initialization: for overriding default diagnostics
BOOL AFXAPI AfxDiagnosticInit(void);

// A failure hook returns whether to permit allocation
typedef BOOL (AFXAPI* AFX_ALLOC_HOOK)(size_t nSize, BOOL bObject, LONG lRequestNumber);

// Set new hook, return old (never NULL)
AFX_ALLOC_HOOK AFXAPI AfxSetAllocHook(AFX_ALLOC_HOOK pfnAllocHook);

// Debugger hook on specified allocation request - Obsolete
void AFXAPI AfxSetAllocStop(LONG lRequestNumber);

// Memory state for snapshots/leak detection
struct CMemoryState
{
// Attributes
	enum blockUsage
	{
		freeBlock,    // memory not used
		objectBlock,  // contains a CObject derived class object
		bitBlock,     // contains ::operator new data
		crtBlock,
		ignoredBlock,
		nBlockUseMax  // total number of usages
	};

	_CrtMemState m_memState;
	LONG_PTR m_lCounts[nBlockUseMax];
	LONG_PTR m_lSizes[nBlockUseMax];
	LONG_PTR m_lHighWaterCount;
	LONG_PTR m_lTotalCount;

	CMemoryState();

// Operations
	void Checkpoint();  // fill with current state
	BOOL Difference(const CMemoryState& oldState,
					const CMemoryState& newState);  // fill with difference
	void UpdateData();

	// Output to afxDump
	void DumpStatistics() const;
	void DumpAllObjectsSince() const;
};

// Enumerate allocated objects or runtime classes
void AFXAPI AfxDoForAllObjects(void (AFX_CDECL *pfn)(CObject* pObject, void* pContext),
	void* pContext);
void AFXAPI AfxDoForAllClasses(void (AFX_CDECL *pfn)(const CRuntimeClass* pClass,
	void* pContext), void* pContext);

#else

// non-_DEBUG_ALLOC version that assume everything is OK
#define DEBUG_NEW new
#define AfxCheckMemory() TRUE
#define AfxIsMemoryBlock(p, nBytes) TRUE
#define AfxEnableMemoryTracking(bTrack) FALSE
#define AfxOutputDebugString(lpsz) ::OutputDebugString(lpsz)

// diagnostic initialization
#ifndef _DEBUG
#define AfxDiagnosticInit() TRUE
#else
BOOL AFXAPI AfxDiagnosticInit(void);
#endif

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Archives for serializing CObject data

// needed for implementation
class CPtrArray;
class CMapPtrToPtr;
class CDocument;

class CArchive
{
public:
// Flag values
	enum Mode { store = 0, load = 1, bNoFlushOnDelete = 2, bNoByteSwap = 4 };

	CArchive(CFile* pFile, UINT nMode, int nBufSize = 4096, void* lpBuf = NULL);
	~CArchive();

// Attributes
	BOOL IsLoading() const;
	BOOL IsStoring() const;
	BOOL IsByteSwapping() const;
	BOOL IsBufferEmpty() const;

	CFile* GetFile() const;
	UINT GetObjectSchema(); // only valid when reading a CObject*
	void SetObjectSchema(UINT nSchema);

	// pointer to document being serialized -- must set to serialize
	//  COleClientItems in a document!
	CDocument* m_pDocument;

// Operations
	UINT Read(void* lpBuf, UINT nMax);
	void Write(const void* lpBuf, UINT nMax);
	void Flush();
	void Close();
	void Abort();   // close and shutdown without exceptions

	// reading and writing strings
	void WriteString(LPCTSTR lpsz);
	LPTSTR ReadString(LPTSTR lpsz, UINT nMax);
	BOOL ReadString(CString& rString);

public:
	// Object I/O is pointer based to avoid added construction overhead.
	// Use the Serialize member function directly for embedded objects.
	friend CArchive& AFXAPI operator<<(CArchive& ar, const CObject* pOb);

	friend CArchive& AFXAPI operator>>(CArchive& ar, CObject*& pOb);
	friend CArchive& AFXAPI operator>>(CArchive& ar, const CObject*& pOb);

	// insertion operations
	CArchive& operator<<(BYTE by);
	CArchive& operator<<(WORD w);
	CArchive& operator<<(LONG l);
	CArchive& operator<<(DWORD dw);
	CArchive& operator<<(ULONGLONG qw);
	CArchive& operator<<(float f);
	CArchive& operator<<(double d);

	CArchive& operator<<(int i);
	CArchive& operator<<(short w);
	CArchive& operator<<(char ch);
	CArchive& operator<<(unsigned u);

	// extraction operations
	CArchive& operator>>(BYTE& by);
	CArchive& operator>>(WORD& w);
	CArchive& operator>>(DWORD& dw);
	CArchive& operator>>(LONG& l);
	CArchive& operator>>(ULONGLONG& qw);
	CArchive& operator>>(float& f);
	CArchive& operator>>(double& d);

	CArchive& operator>>(int& i);
	CArchive& operator>>(short& w);
	CArchive& operator>>(char& ch);
	CArchive& operator>>(unsigned& u);

	// object read/write
	CObject* ReadObject(const CRuntimeClass* pClass);
	void WriteObject(const CObject* pOb);
	// advanced object mapping (used for forced references)
	void MapObject(const CObject* pOb);

	// advanced versioning support
	void WriteClass(const CRuntimeClass* pClassRef);
	CRuntimeClass* ReadClass(const CRuntimeClass* pClassRefRequested = NULL,
		UINT* pSchema = NULL, DWORD* pObTag = NULL);
	void SerializeClass(const CRuntimeClass* pClassRef);

	// advanced operations (used when storing/loading many objects)
	void SetStoreParams(UINT nHashSize = 2053, UINT nBlockSize = 128);
	void SetLoadParams(UINT nGrowBy = 1024);

// Implementation
public:
	BOOL m_bForceFlat;  // for COleClientItem implementation (default TRUE)
	BOOL m_bDirectBuffer;   // TRUE if m_pFile supports direct buffering
	void FillBuffer(UINT nBytesNeeded);
	void CheckCount();  // throw exception if m_nMapCount is too large

	// special functions for reading and writing (16-bit compatible) counts
	DWORD_PTR ReadCount();
	void WriteCount(DWORD_PTR dwCount);

	// public for advanced use
	UINT m_nObjectSchema;
	CString m_strFileName;

protected:
	// archive objects cannot be copied or assigned
	CArchive(const CArchive& arSrc);
	void operator=(const CArchive& arSrc);

	BOOL m_nMode;
	BOOL m_bUserBuf;
	int m_nBufSize;
	CFile* m_pFile;
	BYTE* m_lpBufCur;
	BYTE* m_lpBufMax;
	BYTE* m_lpBufStart;

	// array/map for CObject* and CRuntimeClass* load/store
	UINT m_nMapCount;
	union
	{
		CPtrArray* m_pLoadArray;
		CMapPtrToPtr* m_pStoreMap;
	};
	// map to keep track of mismatched schemas
	CMapPtrToPtr* m_pSchemaMap;

	// advanced parameters (controls performance with large archives)
	UINT m_nGrowSize;
	UINT m_nHashSize;
};

/////////////////////////////////////////////////////////////////////////////
// Diagnostic dumping

#if _MFC_VER>=0x0600
// Note: AfxDumpStack is available in release builds, although it is always
//	statically linked so as to not negatively affect the size of MFC42.DLL.

#define AFX_STACK_DUMP_TARGET_TRACE			0x0001
#define AFX_STACK_DUMP_TARGET_CLIPBOARD	0x0002
#define AFX_STACK_DUMP_TARGET_BOTH			0x0003
#define AFX_STACK_DUMP_TARGET_ODS			0x0004
#ifdef _DEBUG
#define AFX_STACK_DUMP_TARGET_DEFAULT		AFX_STACK_DUMP_TARGET_TRACE
#else
#define AFX_STACK_DUMP_TARGET_DEFAULT		AFX_STACK_DUMP_TARGET_CLIPBOARD
#endif

void AFXAPI AfxDumpStack(DWORD dwFlags = AFX_STACK_DUMP_TARGET_DEFAULT);
#endif

class CDumpContext
{
public:
	CDumpContext(CFile* pFile = NULL);

// Attributes
	int GetDepth() const;      // 0 => this object, 1 => children objects
	void SetDepth(int nNewDepth);

// Operations
	CDumpContext& operator<<(LPCTSTR lpsz);
#ifdef _UNICODE
	CDumpContext& operator<<(LPCSTR lpsz);  // automatically widened
#else
	CDumpContext& operator<<(LPCWSTR lpsz); // automatically thinned
#endif
	CDumpContext& operator<<(const void* lp);
	CDumpContext& operator<<(const CObject* pOb);
	CDumpContext& operator<<(const CObject& ob);
	CDumpContext& operator<<(BYTE by);
	CDumpContext& operator<<(WORD w);
	CDumpContext& operator<<(UINT u);
	CDumpContext& operator<<(LONG l);
	CDumpContext& operator<<(DWORD dw);
	CDumpContext& operator<<(float f);
	CDumpContext& operator<<(double d);
	CDumpContext& operator<<(int n);
#ifdef _WIN64
    CDumpContext& operator<<(__int64 n);
    CDumpContext& operator<<(unsigned __int64 n);
#endif
	void HexDump(LPCTSTR lpszLine, BYTE* pby, int nBytes, int nWidth);
	void Flush();

// Implementation
protected:
	// dump context objects cannot be copied or assigned
	CDumpContext(const CDumpContext& dcSrc);
	void operator=(const CDumpContext& dcSrc);
	void OutputString(LPCTSTR lpsz);

	int m_nDepth;

public:
	CFile* m_pFile;
};

#ifdef _DEBUG
extern AFX_DATA CDumpContext afxDump;
extern AFX_DATA BOOL afxTraceEnabled;
#endif

/////////////////////////////////////////////////////////////////////////////
// Special include for Win32s compatibility

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifndef __AFXCOLL_H__
	#include <afxcoll.h>
	#ifndef __AFXSTATE_H__
		#include <afxstat_.h> // for _AFX_APP_STATE and _AFX_THREAD_STATE
	#endif
#endif

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_ENABLE_INLINES
#define _AFX_INLINE AFX_INLINE

#if !defined
#define _AFX_PUBLIC_INLINE AFX_INLINE
#else
#define _AFX_PUBLIC_INLINE
#endif

#include <afx.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\win32inc\AfxVer_.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// afxver_.h - target version/configuration control

/////////////////////////////////////////////////////////////////////////////
// Master version numbers

#define _AFX     1      // Microsoft Application Framework Classes

#ifndef _MFC_VER
#define _MFC_VER 0x0421 // Microsoft Foundation Classes version 4.21
#endif

/////////////////////////////////////////////////////////////////////////////
// Default swap tuning for AFX library

#define _TEXTSEG(name)  ".text$" #name

// Most segments are tuned via function order list (DLL version)
#ifndef _AFX_FUNCTION_ORDER
#define AFX_CORE1_SEG   _TEXTSEG(AFX_CORE1) // core functionality
#define AFX_CORE2_SEG   _TEXTSEG(AFX_CORE2) // more core functionality
#define AFX_CORE3_SEG   _TEXTSEG(AFX_CORE3) // more core functionality
#define AFX_CORE4_SEG   _TEXTSEG(AFX_CORE4) // more core functionality
#define AFX_AUX_SEG     _TEXTSEG(AFX_AUX)   // auxilliary functionality
#define AFX_CMNCTL_SEG  _TEXTSEG(AFX_CMNCTL)// most common controls
#define AFX_COLL_SEG    _TEXTSEG(AFX_COL1)  // collections
#define AFX_COLL2_SEG   _TEXTSEG(AFX_COL2)  // more collections
#define AFX_INET_SEG    _TEXTSEG(AFX_INET)  // Internet client-side stuff
#define AFX_OLE_SEG     _TEXTSEG(AFX_OLE1)  // OLE support
#define AFX_OLE2_SEG    _TEXTSEG(AFX_OLE2)  // more OLE support
#define AFX_OLE3_SEG    _TEXTSEG(AFX_OLE3)  // and more OLE support
#define AFX_OLE4_SEG    _TEXTSEG(AFX_OLE4)  // and more OLE support
#define AFX_OLE5_SEG    _TEXTSEG(AFX_OLE5)  // and even more OLE support
#define AFX_OLERA_SEG   _TEXTSEG(AFX_OLERA) // (reserved for future use)
#define AFX_PRINT_SEG   _TEXTSEG(AFX_PRNT)  // Printing functionality
#define AFX_DBG1_SEG    _TEXTSEG(AFX_DBG1)  // inlines go here in _DEBUG
#define AFX_DBG2_SEG    _TEXTSEG(AFX_DBG2)  // inlines go here in _DEBUG
#define AFX_VDEL_SEG    _TEXTSEG(AFX_VDEL)  // vector deleting destructors
#define AFX_TERM_SEG    _TEXTSEG(AFX_TERM)  // cleanup routines
#define AFX_MAPI_SEG    _TEXTSEG(AFX_MAPI)  // simple MAPI support
#define AFX_SOCK_SEG    _TEXTSEG(AFX_SOCK)  // windows sockets support
#else
#define AFX_CORE1_SEG                       // core functionality
#define AFX_CORE2_SEG                       // more core functionality
#define AFX_CORE3_SEG                       // more core functionality
#define AFX_CORE4_SEG                       // more core functionality
#define AFX_AUX_SEG                         // auxilliary functionality
#define AFX_CMNCTL_SEG                      // most common controls
#define AFX_COLL_SEG                        // collections
#define AFX_COLL2_SEG                       // more collections
#define AFX_INET_SEG                        // Internet client-side stuff
#define AFX_OLE_SEG                         // OLE support
#define AFX_OLE2_SEG                        // more OLE support
#define AFX_OLE3_SEG                        // and more OLE support
#define AFX_OLE4_SEG                        // and more OLE support
#define AFX_OLE5_SEG                        // and even more OLE support
#define AFX_OLERA_SEG                       // (reserved for future use)
#define AFX_PRINT_SEG                       // Printing functionality
#define AFX_DBG1_SEG                        // inlines go here in _DEBUG
#define AFX_DBG2_SEG                        // inlines go here in _DEBUG
#define AFX_VDEL_SEG                        // vector deleting destructors
#define AFX_TERM_SEG                        // cleanup routines
#define AFX_MAPI_SEG                        // simple MAPI support
#define AFX_SOCK_SEG                        // windows sockets support
#endif

// AFX_INIT_SEG is hand tuned even in DLL version
#define AFX_INIT_SEG    _TEXTSEG(AFX_INIT)  // initialization

/////////////////////////////////////////////////////////////////////////////
// turn off reference tracking for certain often used symbols

#ifndef _AFX_PORTABLE
#pragma component(browser, off, references, "ASSERT")
#pragma component(browser, off, references, "AfxAssertFailedLine")
#pragma component(browser, off, references, "AfxDebugBreak")
#pragma component(browser, off, references, "BOOL")
#pragma component(browser, off, references, "BYTE")
#pragma component(browser, off, references, "DECLSPEC_IMPORT")
#pragma component(browser, off, references, "DWORD")
#pragma component(browser, off, references, "FALSE")
#pragma component(browser, off, references, "FAR")
#pragma component(browser, off, references, "LPSTR")
#pragma component(browser, off, references, "LPTSTR")
#pragma component(browser, off, references, "LPCSTR")
#pragma component(browser, off, references, "LPCTSTR")
#pragma component(browser, off, references, "NULL")
#pragma component(browser, off, references, "PASCAL")
#pragma component(browser, off, references, "THIS_FILE")
#pragma component(browser, off, references, "TRUE")
#pragma component(browser, off, references, "UINT")
#pragma component(browser, off, references, "WINAPI")
#pragma component(browser, off, references, "WORD")
#endif  //!_AFX_PORTABLE

/////////////////////////////////////////////////////////////////////////////
// For target version (one of)
//   _CUSTOM   : for custom configurations (causes afxv_cfg.h to be included)
//
// Additional build options:
//  _DEBUG              debug versions (full diagnostics)
//  _AFXDLL             use shared MFC DLL
//  _AFXEXT             extension DLL version, implies _AFXDLL
//  _USRDLL             create regular DLL (_AFXDLL is valid too)
//

#ifndef _DEBUG
    #undef _AFX_ENABLE_INLINE
	#define _AFX_ENABLE_INLINES
#endif

#define _AFX_NO_NESTED_DERIVATION

/////////////////////////////////////////////////////////////////////////////
// Special configurations

// _AFXEXT implies _AFXDLL
#if defined
	#define _AFXDLL
#endif

#if defined
	#error Please use the /MD switch for _AFXDLL builds
#endif

#if defined
	#error Please use the /MD switch (multithreaded DLL C-runtime)
#endif

/////////////////////////////////////////////////////////////////////////////
// special include files

#ifndef AFX_INLINE
    #define AFX_INLINE inline  /* __forceinline*/
#endif

#include <afxv_w32.h>

// Include any non-Intel platform specific items
#ifndef _X86_
	#include <afxv_cpu.h>
#endif

#ifdef _X86_
	#define _AFX_MINREBUILD
#endif

#ifdef _CUSTOM
// Put any custom configuration items in afxv_cfg.h
	#include <afxv_cfg.h>
#endif

// setup default packing value
#ifndef _AFX_PACKING
	#define _AFX_PACKING    4   // default packs structs at 4 bytes
#endif

#ifdef _AFXDLL
	#include <afxv_dll.h>
#endif

// Define this virtual key for use by status bar
#ifndef VK_KANA
#define VK_KANA             0x15
#endif

/////////////////////////////////////////////////////////////////////////////
// Special AfxDebugBreak: used to break into debugger at critical times

#ifndef AfxDebugBreak
#ifdef _AFX_NO_DEBUG_CRT
// by default, debug break is asm int 3, or a call to DebugBreak, or nothing
#if defined
#define AfxDebugBreak() _asm { int 3 }
#else
#define AfxDebugBreak() DebugBreak()
#endif
#else
#define AfxDebugBreak() _CrtDbgBreak()
#endif
#endif

#ifndef _DEBUG
#ifdef AfxDebugBreak
#undef AfxDebugBreak
#endif
#define AfxDebugBreak()
#endif  // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Standard preprocessor symbols if not already defined
/////////////////////////////////////////////////////////////////////////////

// SIZE_T_MAX is used by the collection classes
#ifndef SIZE_T_MAX
	#define SIZE_T_MAX  UINT_MAX
#endif

// PASCAL is used for static member functions
#ifndef PASCAL
	#define PASCAL  __stdcall
#endif

// FASTCALL is used for static member functions with little or no params
#ifndef FASTCALL
	#define FASTCALL __fastcall
#endif

// CDECL and EXPORT are defined in case WINDOWS.H doesn't
#ifndef CDECL
	#define CDECL __cdecl
#endif

#ifndef EXPORT
	#define EXPORT
#endif

// UNALIGNED is used for unaligned data access (in CArchive mostly)
#ifndef UNALIGNED
	#define UNALIGNED
#endif

// AFXAPI is used on global public functions
#ifndef AFXAPI
	#define AFXAPI __stdcall
#endif

// AFXOLEAPI is used for some special OLE functions
#ifndef AFXOLEAPI
	#define AFXOLEAPI __stdcall
#endif

// AFX_CDECL is used for rare functions taking variable arguments
#ifndef AFX_CDECL
	#define AFX_CDECL __cdecl
#endif

// AFX_EXPORT is used for functions which need to be exported
#ifndef AFX_EXPORT
	#define AFX_EXPORT EXPORT
#endif

#ifndef AFX_STATIC
	#define AFX_STATIC extern
	#define AFX_STATIC_DATA extern __declspec(selectany)
#endif

// The following macros are used to enable export/import

// for data
#ifndef AFX_DATA_EXPORT
	#define AFX_DATA_EXPORT __declspec(dllexport)
#endif
#ifndef AFX_DATA_IMPORT
	#define AFX_DATA_IMPORT __declspec(dllimport)
#endif

// for classes
#ifndef AFX_CLASS_EXPORT
	#define AFX_CLASS_EXPORT __declspec(dllexport)
#endif
#ifndef AFX_CLASS_IMPORT
	#define AFX_CLASS_IMPORT __declspec(dllimport)
#endif

// for global APIs
#ifndef AFX_API_EXPORT
	#define AFX_API_EXPORT __declspec(dllexport)
#endif
#ifndef AFX_API_IMPORT
	#define AFX_API_IMPORT __declspec(dllimport)
#endif

// This macro is used to reduce size requirements of some classes
#ifndef AFX_ALWAYS_VTABLE
#ifndef AFX_NOVTABLE
#if _MSC_VER>=1100 && !defined
#define AFX_NOVTABLE __declspec(novtable)
#else
#define AFX_NOVTABLE
#endif
#endif
#endif

// for global data that should be in COMDATs (packaged data)
#ifndef AFX_COMDAT
	#define AFX_COMDAT
#endif

// The following macros are used on data declarations/definitions
//  (they are redefined for extension DLLs and the shared MFC DLL)
#define AFX_DATA
#define AFX_DATADEF
#define AFX_API

// used when building the "core" MFC42.DLL
#ifndef AFX_CORE_DATA
	#define AFX_CORE_DATA
	#define AFX_CORE_DATADEF
#endif

// used when building the MFC/OLE support MFCO42.DLL
#ifndef AFX_OLE_DATA
	#define AFX_OLE_DATA
	#define AFX_OLE_DATADEF
#endif

// used when building the MFC/DB support MFCD42.DLL
#ifndef AFX_DB_DATA
	#define AFX_DB_DATA
	#define AFX_DB_DATADEF
#endif

// used when building the MFC/NET support MFCN42.DLL
#ifndef AFX_NET_DATA
	#define AFX_NET_DATA
	#define AFX_NET_DATADEF
#endif

// used when building extension DLLs
#ifndef AFX_EXT_DATA
	#define AFX_EXT_DATA
	#define AFX_EXT_DATADEF
	#define AFX_EXT_CLASS
	#define AFX_EXT_API
#endif

// BASED_XXXX macros are provided for backward compatibility
#ifndef BASED_CODE
	#define BASED_CODE
#endif

#ifndef BASED_DEBUG
	#define BASED_DEBUG
#endif

#ifndef BASED_STACK
	#define BASED_STACK
#endif

// setup default code segment
#ifdef AFX_DEF_SEG
	#pragma code_seg(AFX_DEF_SEG)
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\win32inc\Afxv_W32.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// afxv_w32.h - target version/configuration control for Win32

#ifdef _WINDOWS_
	#error WINDOWS.H already included.  MFC apps must not #include <windows.h>
#endif

// STRICT is the only supported option (NOSTRICT is no longer supported)
#ifndef STRICT
#define STRICT 1
#endif

// certain parts of WINDOWS.H are necessary
#undef NOKERNEL
#undef NOGDI
#undef NOUSER
#undef NODRIVERS
#undef NOLOGERROR
#undef NOPROFILER
#undef NOMEMMGR
#undef NOLFILEIO
#undef NOOPENFILE
#undef NORESOURCE
#undef NOATOM
#undef NOLANGUAGE
#undef NOLSTRING
#undef NODBCS
#undef NOKEYBOARDINFO
#undef NOGDICAPMASKS
#undef NOCOLOR
#undef NOGDIOBJ
#undef NODRAWTEXT
#undef NOTEXTMETRIC
#undef NOSCALABLEFONT
#undef NOBITMAP
#undef NORASTEROPS
#undef NOMETAFILE
#undef NOSYSMETRICS
#undef NOSYSTEMPARAMSINFO
#undef NOMSG
#undef NOWINSTYLES
#undef NOWINOFFSETS
#undef NOSHOWWINDOW
#undef NODEFERWINDOWPOS
#undef NOVIRTUALKEYCODES
#undef NOKEYSTATES
#undef NOWH
#undef NOMENUS
#undef NOSCROLL
#undef NOCLIPBOARD
#undef NOICONS
#undef NOMB
#undef NOSYSCOMMANDS
#undef NOMDI
#undef NOCTLMGR
#undef NOWINMESSAGES


#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE         // UNICODE is used by Windows headers
#endif
#endif

#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE        // _UNICODE is used by C-runtime/MFC headers
#endif
#endif

#ifdef VC_EXTRALEAN
#define WIN32_EXTRA_LEAN
#define NOSERVICE
#define NOMCX
#define NOIME
#define NOSOUND
#define NOCOMM
#define NOKANJI
#define NORPC
#define NOPROXYSTUB
#define NOIMAGE
#define NOTAPE

#ifndef NO_ANSIUNI_ONLY
#ifdef _UNICODE
#define UNICODE_ONLY
#else
#define ANSI_ONLY
#endif
#endif //!NO_ANSIUNI_ONLY

#endif //VC_EXTRALEAN

/////////////////////////////////////////////////////////////////////////////
// Turn off warnings for /W4
// To resume any of these warning: #pragma warning(default: 4xxx)
// which should be placed after the AFX include files

#ifndef ALL_WARNINGS
#pragma warning(disable: 4201)  // winnt.h uses nameless structs
#endif

#if _MFC_VER>=0x0600
#define _WIN32_WINDOWS 0x0500
#endif
#include <windows.h>

#undef WM_MOUSELAST
#define WM_MOUSELAST 0x0209

#include <zmouse.h>

struct HKEY__;
typedef struct HKEY__ *HKEY;

#ifndef _INC_COMMCTRL
	#include <commctrl.h>

	// Note: We must avoid using TB_ADDBUTTONW and TB_INSERTBUTTONW in the Unicode
	//  build or else MFC42U.DLL will not be compatible with pre-IE4 versions of
	//  COMCTL32.DLL.
	#ifdef TB_ADDBUTTONSA
		#undef TB_ADDBUTTONS
		#define TB_ADDBUTTONS TB_ADDBUTTONSA
	#endif

	#ifdef TB_INSERTBUTTONA
		#undef TB_INSERTBUTTON
		#define TB_INSERTBUTTON TB_INSERTBUTTONA
	#endif
#endif

#ifndef EXPORT
#define EXPORT
#endif

#ifndef _INC_TCHAR
	#include <tchar.h>      // used for ANSI v.s. UNICODE abstraction
#endif
#ifdef _MBCS
#ifndef _INC_MBCTYPE
	#include <mbctype.h>
#endif
#ifndef _INC_MBSTRING
	#include <mbstring.h>
#endif
#endif

#ifdef _WIN64
#define _AFX_NO_CTL3D_SUPPORT
#endif

/////////////////////////////////////////////////////////////////////////////
// Now for the Windows API specific parts

// WM_CTLCOLOR for 16 bit API compatability
#define WM_CTLCOLOR     0x0019

// Win32 uses macros with parameters for this, which breaks C++ code.
#ifdef GetWindowTask
#undef GetWindowTask
#ifdef _WIN32
AFX_INLINE HTASK GetWindowTask(HWND hWnd)
	{ return (HTASK)(DWORD_PTR)::GetWindowThreadProcessId(hWnd, NULL); }
#endif
#endif

// Win32 uses macros with parameters for this, which breaks C++ code.
#ifdef GetNextWindow
#undef GetNextWindow
AFX_INLINE HWND GetNextWindow(HWND hWnd, UINT nDirection)
	{ return ::GetWindow(hWnd, nDirection); }
#endif

// Avoid Win95 mapping CToolBar::DrawState to DrawState[A/W]
#ifdef DrawState
#undef DrawState
AFX_INLINE BOOL WINAPI DrawState(HDC hdc, HBRUSH hbr, DRAWSTATEPROC lpOutputFunc,
	LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT fuFlags)
#ifdef UNICODE
	{ return ::DrawStateW(hdc, hbr, lpOutputFunc, lData, wData, x, y, cx, cy,
		fuFlags); }
#else
	{ return ::DrawStateA(hdc, hbr, lpOutputFunc, lData, wData, x, y, cx, cy,
		fuFlags); }
#endif
#endif

// Avoid Win95 mapping CStatusBar::DrawStatusText to DrawStatusText[A/W]
#ifdef DrawStatusText
#undef DrawStatusText
AFX_INLINE void WINAPI DrawStatusText(HDC hDC, LPRECT lprc, LPCTSTR szText,
	UINT uFlags)
#ifdef UNICODE
	{ ::DrawStatusTextW(hDC, lprc, szText, uFlags); }
#else
	{ ::DrawStatusTextA(hDC, lprc, szText, uFlags); }
#endif
#endif

// FreeResource is not required on Win32 platforms
#undef FreeResource
AFX_INLINE BOOL WINAPI FreeResource(HGLOBAL) { return TRUE; }
// UnlockResource is not required on Win32 platforms
#undef UnlockResource
AFX_INLINE int WINAPI UnlockResource(HGLOBAL) { return 0; }

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\Apps\xbDVD\INC\win32inc\RPC.H ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

/*++

Copyright 1991-1998 Microsoft Corporation

Module Name:

    rpc.h

Abstract:

    Master include file for RPC applications.

--*/

#if !defined
//#include <windows.h>
#endif // RPC_NO_WINDOWS_H

#ifndef __RPC_H__
#define __RPC_H__

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------------------------
// platform specific defines
//-------------------------------------------------------------

//-------------------  MAC ---------------------------
#if defined

#define __RPC_MAC__
// Set the packing level for RPC structures.

#include <pshpack2.h>

//-------------------  WIN32 ---------------------------
#else

#define __RPC_WIN32__

#endif


#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

typedef void * I_RPC_HANDLE;
typedef long RPC_STATUS;

#ifndef _MAC
#define RPC_UNICODE_SUPPORTED
#endif //_MAC


#ifdef __RPC_MAC__
#	define __RPC_FAR
#	define __RPC_API
#	define __RPC_USER
#	define __RPC_STUB
#	define RPC_ENTRY
#elif _MSC_VER>=800 || defined
#	define __RPC_FAR
#	define __RPC_API  __stdcall
#	define __RPC_USER __stdcall
#	define __RPC_STUB __stdcall
#	define  RPC_ENTRY __stdcall
#else
#	define __RPC_FAR
#	define __RPC_API
#	define __RPC_USER
#	define __RPC_STUB
#endif

// Some RPC platforms don't define DECLSPEC_IMPORT
#if !defined
#if defined
#define DECLSPEC_IMPORT __declspec(dllimport)
#else
#define DECLSPEC_IMPORT
#endif
#endif

#if !defined
#define RPCRTAPI DECLSPEC_IMPORT
#else
#define RPCRTAPI
#endif

#if !defined
#define RPCNSAPI DECLSPEC_IMPORT
#else
#define RPCNSAPI
#endif

#ifdef IN
#undef IN
#undef OUT
#undef OPTIONAL
#endif /* IN */

#ifdef __RPC_MAC__

#include <setjmp.h>

#define RPCXCWORD (sizeof(jmp_buf)/sizeof(int))

#pragma warning( disable: 4005 )
#include <rpcdce.h>
#include <rpcnsi.h>
#include <rpcerr.h>
#include <rpcmac.h>
#pragma warning( default :  4005 )

typedef void  (RPC_ENTRY *MACYIELDCALLBACK)(/*OSErr*/ short *) ;
RPC_STATUS RPC_ENTRY
RpcMacSetYieldInfo(
	MACYIELDCALLBACK pfnCallback) ;

#if !defined
#define UNALIGNED
#endif

#include <poppack.h>

#else

#include <rpcdce.h>
#include <rpcnsi.h>
#include <rpcnterr.h>
#include <excpt.h>
#include <winerror.h>

#define RpcTryExcept \
    __try \
        {

// trystmts

#define RpcExcept(expr) \
        } \
    __except (expr) \
        {

// exceptstmts

#define RpcEndExcept \
        }

#define RpcTryFinally \
    __try \
        {

// trystmts

#define RpcFinally \
        } \
    __finally \
        {

// finallystmts

#define RpcEndFinally \
        }

#define RpcExceptionCode() GetExceptionCode()
#define RpcAbnormalTermination() AbnormalTermination()

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcImpersonateClient (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcRevertToSelfEx (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcRevertToSelf (
    );

RPCRTAPI
long
RPC_ENTRY
I_RpcMapWin32Status (
    IN RPC_STATUS Status
    );

#endif // __RPC_MAC__

// Definitions which depend on windows.h
#if !defined

#include <rpcasync.h>

#endif