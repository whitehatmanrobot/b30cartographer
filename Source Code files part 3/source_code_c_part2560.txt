 platform the driver is offering?

      if (pNext->Includes(*pPlatform))  // if yes, we're all set
	    return TRUE;
	}
  while (pos);

  // if we fall through, this test cannot be run on the proposed platform

	return FALSE;
}

int CTest::GetType(void)
{
	return m_nType;
}

#if 0	// Removed for global Sleep Override...
void CTest::Sleep(DWORD msec)
{
    WaitStepInstructions("Sleep for %d msecs", msec);
    ::Sleep(msec);
}
#endif

// WriteLog is provided for backward compatibility only
// GetLog()->RecordCompare should be used instead
void CTest::WriteLog(int LT, LPCSTR szFmt, ...)
{
	char szBuf[1024+1];
	va_list marker;

	va_start( marker, szFmt );
	_vsnprintf( szBuf, 1024, szFmt, marker );
	va_end( marker );

	GetLog()->RecordCompare(LT == PASSED, szBuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Subsuite\vertex.cpp ===
/////////////////////////////////////////////////////////////////////////////
// vertex.cpp
//
// email	date		change
// briancr	06/15/95	created
//
// copyright 1995 Microsoft

// Implementation of the CVertex class

#include "stdafx.h"
#include "vertex.h"

#define new DEBUG_NEW

///////////////////////////////////////////////////////////////////////////////
// CVertex class

IMPLEMENT_DYNAMIC(CVertex, CObject);

LPCSTR CVertex::AccelEdVertexNames[]	= { "AccelEdBegin",		"AccelEdOpen",			NULL };
LPCSTR CVertex::BitmapEdVertexNames[]	= { "BitmapEdBegin",	"BitmapEdOpen",			NULL };
LPCSTR CVertex::CursorEdVertexNames[]	= { "CursorEdBegin",	"CursorEdOpen",			NULL };
LPCSTR CVertex::DebuggerVertexNames[]	= { "DebuggerBegin",	"DebuggerDebugging",	NULL };
LPCSTR CVertex::DialogEdVertexNames[]	= { "DialogEdBegin",	"DialogEdOpen",			NULL };
LPCSTR CVertex::IconEdVertexNames[]		= { "IconEdBegin",		"IconEdOpen",			NULL };
LPCSTR CVertex::MenuEdVertexNames[]		= { "MenuEdBegin",		"MenuEdOpen",			NULL };
LPCSTR CVertex::ProjectVertexNames[]	= { "ProjectBegin",		"ProjectOpen",			"ProjectBuilt" };
LPCSTR CVertex::ResScriptVertexNames[]	= { "ResScriptBegin",	"ResScriptOpen",		NULL };
LPCSTR CVertex::SourceEdVertexNames[]	= { "SourceEdBegin",	"SourceEdOpen",			NULL };
LPCSTR CVertex::StringEdVertexNames[]	= { "StringEdBegin",	"StringEdOpen",			NULL };
LPCSTR CVertex::ToolbarEdVertexNames[]	= { "ToolbarEdBegin",	"ToolbarEdOpen",		NULL };
LPCSTR CVertex::VersionEdVertexNames[]	= { "VersionEdBegin",	"VersionEdOpen",		NULL };
LPCSTR CVertex::NullVertexNames[]		= { "NullVertex",		NULL,					NULL };

LPCSTR* CVertex::VertexNames[] = {	CVertex::AccelEdVertexNames,
									CVertex::BitmapEdVertexNames,
									CVertex::CursorEdVertexNames,
									CVertex::DebuggerVertexNames,
									CVertex::DialogEdVertexNames,
									CVertex::IconEdVertexNames,
									CVertex::MenuEdVertexNames,
									CVertex::ProjectVertexNames,
									CVertex::ResScriptVertexNames,
									CVertex::SourceEdVertexNames,
									CVertex::StringEdVertexNames,
									CVertex::ToolbarEdVertexNames,
									CVertex::VersionEdVertexNames,
									CVertex::NullVertexNames
									};


CVertex::CVertex(void)
: m_Category(Null),
  m_Vertex(V_Null)
{
}

CVertex::CVertex(Category category, int vertex)
: m_Category(category),
  m_Vertex(vertex)
{
}

CVertex::CVertex(const CVertex& vertex)
: m_Category(vertex.m_Category),
  m_Vertex(vertex.m_Vertex)
{
}

CVertex::~CVertex()
{
}

int CVertex::GetVertex(void)
{
	return m_Vertex;
}

CVertex::Category CVertex::GetCategory(void)
{
	return m_Category;
}

CVertex& CVertex::operator=(const CVertex& vertex)
{
	m_Category = vertex.m_Category;
	m_Vertex = vertex.m_Vertex;

	return *this;
}

BOOL CVertex::operator==(const CVertex& vertex)
{
	// two vertices are equal if the vertex and category match
	return (m_Vertex == vertex.m_Vertex) && (m_Category == vertex.m_Category);
}

BOOL CVertex::operator!=(const CVertex& vertex)
{
	return !(operator==(vertex));
}

LPCSTR CVertex::GetName(void)
{
	return VertexNames[m_Category][m_Vertex];
}

///////////////////////////////////////////////////////////////////////////////
// CVertex constants

// null vertices
const CVertex NullVertex(CVertex::Null, CVertex::V_Null);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\applog.cpp ===
/////////////////////////////////////////////////////////////////////////////
// applog.cpp
//
// email	date		change
// briancr	02/06/95	created
//
// copyright 1994 Microsoft

// Implementation of the application logging system

#include "stdafx.h"
#include <io.h>
#include "applog.h"

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CAppLog

// global declaration, since we want access to this object throughout CAFE
CAppLog applog;

const DWORD CAppLog::m_dwMaxLength = 30000;

CAppLog::CAppLog(void)
{
	char acFilename[MAX_PATH];
	char acDrive[_MAX_DRIVE];
	char acDir[_MAX_DIR];
	char acFname[_MAX_FNAME];
	UINT nOpenFlags;
	CFileStatus status;

	// get the filename of the current application
	if (::GetModuleFileName(NULL, acFilename, MAX_PATH)) {
		_splitpath(acFilename, acDrive, acDir, acFname, NULL);
		
		m_strFilename = CString(acDrive) + CString(acDir) + CString(acFname) + ".log";

		// define open mode for the file
		nOpenFlags = CFile::modeReadWrite | CFile::modeNoInherit | CFile::typeText | CFile::shareDenyWrite;
		// if the file doesn't exist, create it (MFC doesn't do this for us)
		if (!CFile::GetStatus(m_strFilename, status)) {
			nOpenFlags |= CFile::modeCreate;
		}

		// open the file
		if (m_file.Open(m_strFilename, nOpenFlags)) {
			// if the file is too big, truncate it
			if (m_file.GetLength() > m_dwMaxLength) {
				m_file.SetLength(0);
				TRACE("AppLog::AppLog: truncating the application log file.");
			}
			// move the file pointer to the end of the file
			m_file.SeekToEnd();
		}
		else {
			TRACE("AppLog::AppLog: unable to open the application log (%d), not recording.", ::GetLastError());
		}
	}
	else {
		TRACE("AppLog::AppLog: unable to get a valid filename for the application log, not recording.");
	}

	// initialize the critical section object we'll use to make this thread safe
	::InitializeCriticalSection(&m_critsec);
}

CAppLog::~CAppLog()
{
	// be sure the file is open
	if (m_file.m_pStream) {
		// close the file
		m_file.Close();
	}

	// delete the critical section object
	::DeleteCriticalSection(&m_critsec);
}

BOOL CAppLog::Write(LPCSTR szFormat, ...)
{
	// make this thread safe by only allowing one thread to write at a time
	EnterCriticalSection(&m_critsec);

	// parse var args
	const ccBuf = 4096;
	char acBuf[ccBuf];
	va_list marker;
	va_start(marker, szFormat);
	_vsnprintf(acBuf, ccBuf, szFormat, marker);
	va_end(marker);

	// append \n
	strcat(acBuf, "\n");

	// be sure the file is open
	if (m_file.m_pStream) {

		// write the resulting string to the log
		m_file.WriteString(acBuf);
		m_file.Flush();
	}

	TRACE("CAFE Log message: %s", acBuf);

	// we're done being thread safe
	LeaveCriticalSection(&m_critsec);

	return TRUE;
}

BOOL CAppLog::Read(LPSTR pacBuf, DWORD* pccBuf)
{
	DWORD ccBuf = 0;
	DWORD ccLine;
	int nResult = TRUE;

	// make this thread safe by only allowing one thread to write at a time
	EnterCriticalSection(&m_critsec);

	// the pointer to the buffer must not be NULL
	ASSERT(pacBuf);

	// be sure the file is open
	if (m_file.m_pStream) {

		// fill the buffer with each line from the file
		const ccLineBuf = 1024;
		char acLine[ccLineBuf];

		// start at the beginning of the file
		m_file.SeekToBegin();
		while (m_file.ReadString(acLine, ccLineBuf-2)) {
			// get the length of the line
			ccLine = strlen(acLine);
			// end the line with \r\n (instead of just \n)
			acLine[ccLine-1] = '\r';
			acLine[ccLine] = '\n';
			acLine[ccLine+1] = '\0';
			// get the length of the line
			ccLine = strlen(acLine);
			// will this line fit in the buffer?
			if (ccBuf+ccLine <= *pccBuf) {
				// copy this line into the buffer
				strcat(pacBuf, acLine);
				ccBuf += ccLine;
				pacBuf += ccLine;
			}
			else {
				// the buffer's too small
				*pccBuf = m_file.GetLength();
				nResult = FALSE;
				break;
			}
		}
		// reset the file pointer to the end of the file
		m_file.SeekToEnd();
	}
	else {
		nResult = FALSE;
	}

	// we're done being thread safe
	LeaveCriticalSection(&m_critsec);

	return nResult;
}

BOOL CAppLog::Clear(void)
{
	// make this thread safe by only allowing one thread to write at a time
	EnterCriticalSection(&m_critsec);

	// be sure the file is open
	if (m_file.m_pStream) {
		// set the length to zero
		m_file.SetLength(0);
		// position the file pointer
		m_file.SeekToEnd();
	}

	// we're done being thread safe
	LeaveCriticalSection(&m_critsec);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\envpage.cpp ===
/////////////////////////////////////////////////////////////////////////////
// envpage.cpp
//
// email	date		change
// briancr	11/04/94	created
//
// copyright 1994 Microsoft

// Implementation of the CEnvPage class

#include "stdafx.h"
#include "toolset.h"
#include "envpage.h"

#define new DEBUG_NEW

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEnvPage property page

IMPLEMENT_DYNCREATE(CEnvPage, CPropertyPage)

CEnvPage::CEnvPage(CSettings* pSettings /*= NULL*/)
: CPropertyPage(CEnvPage::IDD),
  m_pSettings(pSettings)
{
	//{{AFX_DATA_INIT(CEnvPage)
		m_strEnvvar = _T("");
	//}}AFX_DATA_INIT
}

CEnvPage::~CEnvPage()
{
}

void CEnvPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEnvPage)
	DDX_Control(pDX, IDL_Envvars, m_lbEnv);
	DDX_Control(pDX, IDC_Envvar, m_cbEnvvars);
	DDX_CBString(pDX, IDC_Envvar, m_strEnvvar);
	//}}AFX_DATA_MAP
}


BOOL CEnvPage::OnSetActive(void)
{
	int i;

	// call the base class
	if (!CPropertyPage::OnSetActive()) {
		return FALSE;
	}

	// the settings object must exist
	ASSERT(m_pSettings);

	// fill the environment var combo box
	for (i = 0; !CToolset::m_strEnvvars[i].IsEmpty(); i++) {
		m_cbEnvvars.AddString(CToolset::m_strEnvvars[i]);
	}

	// select the first item in this combo box
	m_cbEnvvars.SetCurSel(0);

	// copy the settings into the appropriate variables
	UpdateData(TRUE);

	// fill the envvar list box with the settings of this envvar
	FillEnvvarList();

	return TRUE;
}

void CEnvPage::OnOK(void)
{
	// call the base class
	CPropertyPage::OnOK();

	// the settings object must exist
	ASSERT(m_pSettings);

	// set envvar setting to current envvar list box
	SetEnvvar();

	// write settings to the registry
	m_pSettings->WriteRegistry();
}

BOOL CEnvPage::FillEnvvarList(void)
{
	CString strValue;
	int nSeparate;

	// clear the envvar list box
	m_lbEnv.ResetContent();

	// get the envvar value from the settings object
	strValue = m_pSettings->GetTextValue(m_strEnvvar);

	// separate the value at ;
	for (BOOL bDone = FALSE; !bDone; ) {
		// find the separating ;
		nSeparate = strValue.Find(';');
		// if there is no ;, then assume the end of the string and we're done
		if (nSeparate == -1) {
			nSeparate = strValue.GetLength();
		}
		// only insert if the substring is not empty (iSeparate > 0)
		if (nSeparate > 0) {
			// insert the string in the list box
			m_lbEnv.AddString(strValue.Left(nSeparate));
		}

		// if the separator is at the end of the string, then we're done
		if (nSeparate == strValue.GetLength()) {
			bDone = TRUE;
		}
		// remove the inserted string from the value
		else {
			// remove the inserted envvar from the string
			// +1 to skip the ;
			strValue = strValue.Mid(nSeparate+1);
		}
	}

	// add a blank line to the end of the envvar list box
	m_lbEnv.AddString("");

	// select the first line in the list box
	m_lbEnv.SetCurSel(0);

	// update UI
	OnSelchangeEnvvars();
	
	return TRUE;
}

BOOL CEnvPage::SetEnvvar(void)
{
	CString strValue;
	CString strTemp;
	int i;

	// build the value of the envvar from the list box
	for (i = 0; i < m_lbEnv.GetCount()-1; i++) {
		m_lbEnv.GetText(i, strTemp);
		strValue += strTemp + ";";
	}

	// remove the trailing ;
	if (!strValue.IsEmpty()) {
		strValue = strValue.Left(strValue.GetLength()-1);
	}

	// store this envvar in the settings object
	m_pSettings->SetTextValue(m_strEnvvar, strValue);

	return TRUE;
}

BEGIN_MESSAGE_MAP(CEnvPage, CPropertyPage)
	//{{AFX_MSG_MAP(CEnvPage)
	ON_BN_CLICKED(IDB_EnvvarEdit, OnEnvvarEdit)
	ON_BN_CLICKED(IDB_EnvvarsAdd, OnEnvvarsAdd)
	ON_BN_CLICKED(IDB_EnvvarsMoveUp, OnEnvvarsMoveUp)
	ON_BN_CLICKED(IDB_EnvvarsRemove, OnEnvvarsRemove)
	ON_BN_CLICKED(IDC_EnvvarsMoveDown, OnEnvvarsMoveDown)
	ON_CBN_SELCHANGE(IDC_Envvar, OnSelchangeEnvvar)
	ON_LBN_SELCHANGE(IDL_Envvars, OnSelchangeEnvvars)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CEnvPage message handlers


void CEnvPage::OnEnvvarEdit() 
{
	CAddDlg dlgAddValue;
	int nSel;

	nSel = m_lbEnv.GetCurSel();
	if(nSel<0 || nSel>=m_lbEnv.GetCount()-1) //can't deal with the last one
		return; //no selection
	m_lbEnv.GetText(nSel, dlgAddValue.m_strNewValue);
	if (dlgAddValue.DoModal() == IDOK) {
		// update the string
		m_lbEnv.DeleteString(nSel);
		nSel = m_lbEnv.InsertString(nSel, dlgAddValue.m_strNewValue);

		// update UI
		OnSelchangeEnvvars();
	}	
}

void CEnvPage::OnEnvvarsAdd() 
{
	CAddDlg dlgAddValue;
	int nSel;
	
	// display the add new directory dialog
	if (dlgAddValue.DoModal() == IDOK) {

		// get the currently selected dir
		nSel = m_lbEnv.GetCurSel();

		// insert the string
		nSel = m_lbEnv.InsertString(nSel, dlgAddValue.m_strNewValue);

		// select the next item
		m_lbEnv.SetCurSel(nSel+1);
		
		// update UI
		OnSelchangeEnvvars();
	}
}

void CEnvPage::OnEnvvarsMoveUp() 
{
	int nSel;
	CString strSel;

	// get the currently selected item in the envvar list box
	nSel = m_lbEnv.GetCurSel();
	m_lbEnv.GetText(nSel, strSel);

	// remove the selected item from the list box
	m_lbEnv.DeleteString(nSel);

	// insert the string up one position
	nSel = m_lbEnv.InsertString(nSel-1, strSel);

	// select the item
	m_lbEnv.SetCurSel(nSel);

	// update UI
	OnSelchangeEnvvars();
}

void CEnvPage::OnEnvvarsRemove() 
{
	int nSel;

	// get the currently selected item in the dir list box
	nSel = m_lbEnv.GetCurSel();

	// remove the selected item from the list box
	m_lbEnv.DeleteString(nSel);

	// select the item in the list box (which was the next item)
	m_lbEnv.SetCurSel(nSel);

	// update UI
	OnSelchangeEnvvars();
}

void CEnvPage::OnEnvvarsMoveDown() 
{
	int nSel;
	CString strSel;

	// get the currently selected item in the envvar list box
	nSel = m_lbEnv.GetCurSel();
	m_lbEnv.GetText(nSel, strSel);

	// remove the selected item from the list box
	m_lbEnv.DeleteString(nSel);

	// insert the string down one position
	nSel = m_lbEnv.InsertString(nSel+1, strSel);

	// select the item
	m_lbEnv.SetCurSel(nSel);

	// update UI
	OnSelchangeEnvvars();
}

void CEnvPage::OnSelchangeEnvvar() 
{
	// write previous envvar to the registry
	SetEnvvar();

	// update data
	UpdateData(TRUE);

	// fill the envvar list from the registry
	FillEnvvarList();
}

void CEnvPage::OnSelchangeEnvvars() 
{
	// get pointers to the Move Up, Move Down, and Delete buttons
	CWnd *pMoveUp = GetDlgItem(IDB_EnvvarsMoveUp);
	CWnd *pMoveDown = GetDlgItem(IDC_EnvvarsMoveDown);
	CWnd *pDelete = GetDlgItem(IDB_EnvvarsRemove);

	// enable the buttons
	pMoveUp->EnableWindow();
	pMoveDown->EnableWindow();
	pDelete->EnableWindow();

	// if the first item in the envvar list box is selected, disable the Move Up button
	if (m_lbEnv.GetCurSel() == 0) {
		pMoveUp->EnableWindow(FALSE);
	}

	// if the last item (the blank line) in the envvar list box
	// is selected, disable Move Up, Move Down, and Delete
	// -1 because GetCurSel() is zero-based
	if (m_lbEnv.GetCurSel() == m_lbEnv.GetCount()-1) {
		pMoveUp->EnableWindow(FALSE);
		pMoveDown->EnableWindow(FALSE);
		pDelete->EnableWindow(FALSE);
	}

	// if the second to the last item in the directory list box
	// is selected, disable Move Down
	if (m_lbEnv.GetCurSel() == m_lbEnv.GetCount()-2) {
		pMoveDown->EnableWindow(FALSE);
	}
}


/////////////////////////////////////////////////////////////////////////////
// CAddDlg dialog


CAddDlg::CAddDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CAddDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddDlg)
	m_strNewValue = _T("");
	//}}AFX_DATA_INIT
}

void CAddDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddDirDlg)
	DDX_Text(pDX, IDE_AddValue, m_strNewValue);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAddDlg, CDialog)
	//{{AFX_MSG_MAP(CAddDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddDlg message handlers

BOOL CAddDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// set the focus to the new directory edit box
	GotoDlgCtrl(GetDlgItem(IDE_AddValue));
		
	return FALSE; // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		BrianCr				09/06/94
//
//	Description :
//		source file that includes just the standard includes
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\envpage.h ===
/////////////////////////////////////////////////////////////////////////////
// envpage.h
//
// email	date		change
// briancr	11/04/94	created
//
// copyright 1994 Microsoft

// Interface of the CEnvPage class

#include "resource.h"
#include "settings.h"

/////////////////////////////////////////////////////////////////////////////
// CEnvPage dialog

class CEnvPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CEnvPage)

// Construction
public:
	CEnvPage(CSettings* pSettings = NULL);
	~CEnvPage();

// Dialog Data
	//{{AFX_DATA(CEnvPage)
	enum { IDD = IDD_ToolsetEnvironment };
	CListBox	m_lbEnv;
	CComboBox	m_cbEnvvars;
	CString		m_strEnvvar;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CEnvPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
	virtual BOOL OnSetActive(void);
	virtual void OnOK(void);

// operations (internal)
protected:
	BOOL FillEnvvarList(void);
	BOOL SetEnvvar(void);

// data
protected:
	CSettings* m_pSettings;

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CEnvPage)
	afx_msg void OnEnvvarEdit();
	afx_msg void OnEnvvarsAdd();
	afx_msg void OnEnvvarsMoveUp();
	afx_msg void OnEnvvarsRemove();
	afx_msg void OnEnvvarsMoveDown();
	afx_msg void OnSelchangeEnvvar();
	afx_msg void OnSelchangeEnvvars();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CAddDlg dialog

class CAddDlg : public CDialog
{
// Construction
public:
	CAddDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddDlg)
	enum { IDD = IDD_AddDlg };
	CString	m_strNewValue;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\platform.cpp ===
/*
    PLATFORM.CPP
    ============

    Copyright 1995 Microsoft Corp.


    History:

    Who      When       What
    ---------------------------
    CFlaat   5-30-95   Created
    CFlaat   6-25-95   Finished creating
    CFlaat   6-27-95   Added Win32s as subtype of Win32Intel


      This file represents the implementation of the CPlatform
	class, a mechanism by which CAFE tests and toolsets can
	indicate their hardware, OS, and language properties.

*/


#include "stdafx.h"
#include "platform.h"





/*

    The following are the currently defined OS constants for Visual C++.
  Each OS has a particular numeric range, such that a more specific
  description falls into the more general range.  For example, Win32MIPS
  falls within the Win32 range, but Mac68K does not.
  
    In other words, we're describing a tree by allocating a certain set
  of values to the leaves, and giving the parent of a set of nodes the
  whole range of values of its children, much like with a B-tree.

    Using a combination of OS & language description, platforms can be
  described in significant detail in a useful form.
*/


/*
     >>> WARNING <<<

Be advised that the arrays must precede the OS & language definitions;
otherwise, you will have construction chaos.
*/


// storage for all platforms & languages

CPlatform::COSArray CPlatform::s_aryOS;
CPlatform::CLangArray CPlatform::s_aryLang;



//   ctor params:                                 NAME             SHORT NMAE      ID's                     ABSTRACT?

  // this includes all OS's
CPlatform::COS const CPlatform::AnyOS                 ("Any OS",         "Any",          0x00000001, UINT_MAX,    TRUE);

  // this includes all Win32 OS's
CPlatform::COS const CPlatform::Win32             ("Win32",          "Win32",        0x10000000, 0x1fffffff,  TRUE);
CPlatform::COS const CPlatform::Win32Mips       ("Win32 MIPS",     "win32_mips",   0x10002000, 0x10002fff,  FALSE);
CPlatform::COS const CPlatform::Win32Alpha      ("Win32 Alpha",    "win32_alpha",  0x10003000, 0x10003fff,  FALSE);
CPlatform::COS const CPlatform::Win32PowerPC    ("Win32 PowerPC",  "win32_ppc",    0x10004000, 0x10004fff,  FALSE);
CPlatform::COS const CPlatform::Win32Intel      ("Win32 Intel",    "win32_x86",    0x10001000, 0x10001fff,  FALSE);
CPlatform::COS const CPlatform::Win32s          ("Win32s",         "win32s_x86",   0x10001010, 0x1000101f,  FALSE);

  // this includes all Mac OS's
CPlatform::COS const CPlatform::Mac             ("Mac",            "Mac",          0x20000000, 0x2fffffff,  TRUE);
CPlatform::COS const CPlatform::Mac68K          ("68K Mac",        "mac_68k",      0x20001000, 0x20001fff,  FALSE);
CPlatform::COS const CPlatform::MacPowerPC      ("PowerMac",       "mac_ppc",      0x20002000, 0x20002fff,  FALSE);
CPlatform::COS const CPlatform::Xbox           ("Xbox",            "xbox",      0x90000000, 0x90001fff,  FALSE);


/*

    The following are the currently defined language constants for Visual 
  C++.  Each language has a unique numeric value.

*/

//   ctor params:                                   NAME			ID          DBCS?   ABSTRACT?

CPlatform::CLanguage const CPlatform::AnyLanguage	("Any",			0x00000001, FALSE,  TRUE);
CPlatform::CLanguage const CPlatform::English		("English",		0x00010001, FALSE,  FALSE);
CPlatform::CLanguage const CPlatform::German		("German",		0x00020001, FALSE,  FALSE);
CPlatform::CLanguage const CPlatform::Japanese		("Japanese",	0x00030001, TRUE,   FALSE);


// CPlatform::COS members

CPlatform::COS::COS(LPCSTR szName, LPCSTR szShortName, unsigned const uLowerLimit, unsigned const uUpperLimit, BOOL bAbstract)
  : m_uLowerLimit(uLowerLimit), 
    m_uUpperLimit(uUpperLimit),
    m_strName(szName),
    m_strShortName(szShortName),
    m_bAbstract(bAbstract)
{
  AssertValid();

  CPlatform::RegisterOS(this);
}

int CPlatform::COS::operator ==(const CPlatform::COS &rOS) const
{
  AssertValid();
  rOS.AssertValid();

  return ((m_uLowerLimit == rOS.m_uLowerLimit) && (m_uUpperLimit == rOS.m_uUpperLimit));
}

int CPlatform::COS::operator !=(const CPlatform::COS &rOS) const
{
  AssertValid();
  rOS.AssertValid();

  return !(this->operator==(rOS));  // we'll define it as the negation of our operator ==
}

BOOL CPlatform::COS::Includes(const CPlatform::COS &rOS) const
{
  AssertValid();
  rOS.AssertValid();

  return ((m_uLowerLimit <= rOS.m_uLowerLimit) && (m_uUpperLimit >= rOS.m_uUpperLimit));
}

BOOL CPlatform::COS::IsAbstract(void) const
{
   return m_bAbstract; 
}

void CPlatform::COS::AssertValid(void) const
{
  ASSERT(!m_strName.IsEmpty());

  ASSERT(m_uLowerLimit && m_uUpperLimit && (m_uLowerLimit < m_uUpperLimit));

//    the following line causes infinite assertion checks!!
//  ASSERT(AnyOS.Includes(*this));
}


// CPlatform::CLanguage members

CPlatform::CLanguage::CLanguage(LPCSTR szName, unsigned const uID, BOOL bDBCS, BOOL bAbstract)
  : m_strName(szName),
    m_uID(uID),
    m_bDBCS(bDBCS),
    m_bAbstract(bAbstract)
{
  AssertValid();

  CPlatform::RegisterLanguage(this);
}

int CPlatform::CLanguage::operator ==(const CLanguage &rLang) const
{
  AssertValid();
  rLang.AssertValid();

  return (m_uID == rLang.m_uID);
}

int CPlatform::CLanguage::operator !=(const CLanguage &rLang) const
{
  AssertValid();
  rLang.AssertValid();

  return !(this->operator==(rLang));  // we'll define it as the negation of our operator ==
}

BOOL CPlatform::CLanguage::IsDoubleByte(void) const
{
  AssertValid();

  return m_bDBCS;
}

BOOL CPlatform::CLanguage::IsAbstract(void) const
{
   return m_bAbstract; 
}


void CPlatform::CLanguage::AssertValid(void) const
{
  ASSERT(m_uID);
}




// CPlatform members

CPlatform::CPlatform(const COS &rOS, const CLanguage &rLang)
  : m_rOS(rOS), m_rLang(rLang)
{
  AssertValid();
  rLang.AssertValid();
}


CPlatform::CPlatform(const CPlatform &rPlatform)  // copy ctor
  : m_rOS(rPlatform.m_rOS), m_rLang(rPlatform.m_rLang)
{
  rPlatform.AssertValid();
  AssertValid();
}


int CPlatform::operator ==(const CPlatform &rP) const
{
  AssertValid();
  rP.AssertValid();

  return ((m_rLang == rP.m_rLang) && (m_rOS == rP.m_rOS));
}

int CPlatform::operator !=(const CPlatform &rP) const
{
  AssertValid();
  rP.AssertValid();

  return !(this->operator==(rP));  // we'll define it as the negation of our operator ==
}

BOOL CPlatform::Includes(const CPlatform &rP) const
{
  AssertValid();
  rP.AssertValid();

  return (((m_rLang == rP.m_rLang) || m_rLang == AnyLanguage)
	   && (m_rOS.Includes(rP.m_rOS)));
}

void CPlatform::AssertValid(void) const
{
  m_rOS.AssertValid();
  m_rLang.AssertValid();

  s_aryOS.AssertValid();
}


// static member:

const CPlatform::COSArray *CPlatform::GetOSArray(void)
{
  return &s_aryOS;
}

// static member:

const CPlatform::CLangArray *CPlatform::GetLangArray(void)
{
  return &s_aryLang;
}


// static member:

void CPlatform::RegisterOS(COS *pOS)
{
  if (!pOS->IsAbstract())
    s_aryOS.Add(pOS);
}

// static member:

void CPlatform::RegisterLanguage(CLanguage *pLang)
{
  if (!pLang->IsAbstract())
    s_aryLang.Add(pLang);
}



// misc. helpers

CPlatform::COS TOOLSET_API *GetOSFromShortName(LPCSTR szShortName)
{
    const CPlatform::COSArray *paryOS = CPlatform::GetOSArray();
    int nSize = paryOS -> GetSize();
    CString str(szShortName);

    int i;
    CPlatform::COS *pOS;

    for (i = 0; i < nSize; i++)
    {
      pOS = paryOS->GetAt(i);
      if (!str.CompareNoCase(pOS->GetShortName()))
	return pOS;
    }

    return 0;
}

CPlatform::CLanguage TOOLSET_API *GetLangFromName(LPCSTR szName)
{
    const CPlatform::CLangArray *paryLang = CPlatform::GetLangArray();
    int nSize = paryLang -> GetSize();
    CString str(szName);

    int i;
    CPlatform::CLanguage *pLang;

    for (i = 0; i < nSize; i++)
    {
      pLang = paryLang->GetAt(i);
      if (!str.CompareNoCase(pLang->GetName()))
	return pLang;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by toolset.rc
//
#define IDS_ToolsetOptions              1
#define IDS_ERROR_CANT_OPEN             2
#define IDD_ToolsetIDE                  101
#define IDD_TargetIDE                   101
#define IDD_AddDlg                      124
#define IDD_ToolsetEnvironment          141
#define IDC_Envvar                      143
#define IDL_Envvars                     144
#define IDB_EnvvarsAdd                  145
#define IDB_EnvvarsRemove               146
#define IDB_EnvvarsMoveUp               147
#define IDC_EnvvarsMoveDown             148
#define IDB_EnvvarsMoveDown             148
#define IDB_EnvvarEdit                  149
#define IDE_AddSetting                  151
#define IDE_AddValue                    151
#define IDC_IDENewApp                   1000
#define IDE_IDEFilename                 1001
#define IDC_IDEDebug                    1002
#define IDC_IDEClose                    1003
#define IDC_IDEDebugProcess             1004
#define IDE_IDECmdLine                  1005
#define IDE_IDEWorkDir                  1006
#define IDE_IDEKey                      1007
#define IDC_IDEUseKey                   1010
#define IDS_IDEKeyText                  1011
#define IDB_IDEConnections              1013

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1014
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		BrianCr				09/06/94
//
//	Description :
//		Precompiled header for all of the core MFC files
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\settings.cpp ===
/////////////////////////////////////////////////////////////////////////////
// settings.cpp
//
// email	date		change
// briancr	11/02/94	created
//
// copyright 1994 Microsoft

// Implementation of the CSettings class

#include "stdafx.h"
#include "settings.h"

#define new DEBUG_NEW

CString CSettings::strKeyClass = "CAFE";

///////////////////////////////////////////////////////////////////////////////
// CSettings

///////////////////////////////////////////////////////////////////////////////
// ctor/dtor

CSettings::~CSettings()
{
	CString strSetting;
	CString strValue;
	POSITION pos;

	// interate through the map and delete all the settings
	for (pos = m_mapSettings.GetStartPosition(); pos != NULL; ) {
		m_mapSettings.GetNextAssoc(pos, strSetting, strValue);
		Delete(strSetting);
	}
}

///////////////////////////////////////////////////////////////////////////////
// operations

BOOL CSettings::IsDefined(CString strSetting)
{
	CString strValue;

	// the setting must not be empty
	ASSERT(!strSetting.IsEmpty());

	// no case sensitivity
	strSetting.MakeUpper();

	// is the setting defined?
	return m_mapSettings.Lookup(strSetting, strValue);
}

BOOL CSettings::SetKey(CString strKey)
{
	// the read only flag must not be set
	ASSERT(!m_bReadOnly);

	if (m_bReadOnly) {
		TRACE("CSettings::SetKey: attempt to write to read-only CSettings object denied");
		return FALSE;
	}

	m_strKey = strKey;

	return TRUE;
}

BOOL CSettings::SetTextValue(CString strSetting, CString strValue, BOOL bOverride /*= TRUE*/)
{
	CString strOldValue;

	// the read only flag must not be set
	ASSERT(!m_bReadOnly);

	if (m_bReadOnly) {
		TRACE("CSettings::Set: attempt to write to read-only CSettings object denied");
		return FALSE;
	}

	// the setting string must not be empty
	ASSERT(!strSetting.IsEmpty());

	// no case sensitivity for switches
	strSetting.MakeUpper();

	// if the setting is already set and we're not to override, just return
	if (m_mapSettings.Lookup(strSetting, strOldValue) && !bOverride) {
		return FALSE;
	}

	// add switch/value pair to the map
	m_mapSettings.SetAt(strSetting, strValue);

	return TRUE;
}

CString CSettings::GetTextValue(CString strSetting, CString strDefault /*= ""*/)
{
	CString strValue;

	// the setting string must not be empty
	ASSERT(!strSetting.IsEmpty());

	// no case sensitivity for switches
	strSetting.MakeUpper();

	// look up the setting's value
	if (m_mapSettings.Lookup(strSetting, strValue)) {
		return strValue;
	}

	// the setting does not exist
	return strDefault;
}

BOOL CSettings::SetBooleanValue(CString strSetting, BOOL bValue, BOOL bOverride /*= TRUE*/)
{
	CString strValue;

	// convert the boolean to a string
	if (bValue) {
		strValue = "true";
	}
	else {
		strValue = "false";
	}
	return SetTextValue(strSetting, strValue, bOverride);
}

BOOL CSettings::GetBooleanValue(CString strSetting, BOOL bDefault /*= FALSE*/)
{
	CString strValue;

	// the setting string must not be empty
	ASSERT(!strSetting.IsEmpty());

	// no case sensitivity for switches
	strSetting.MakeUpper();

	// look up the setting's value
	if (m_mapSettings.Lookup(strSetting, strValue)) {
		return InterpretBooleanValue(strValue, bDefault);
	}

	// the setting does not exist
	return bDefault;
}

BOOL CSettings::SetIntValue(CString strSetting, int nValue, BOOL bOverride /*= TRUE*/)
{
	CString strValue;

	// convert the int to a string
	itoa(nValue, strValue.GetBuffer(255), 10);
	strValue.ReleaseBuffer();

	return SetTextValue(strSetting, strValue, bOverride);
}

int CSettings::GetIntValue(CString strSetting, int nDefault /*= 0*/)
{
	CString strValue;

	// the setting string must not be empty
	ASSERT(!strSetting.IsEmpty());

	// no case sensitivity for switches
	strSetting.MakeUpper();

	// look up the setting's value
	if (m_mapSettings.Lookup(strSetting, strValue)) {
		return atoi(strValue);
	}

	// the setting does not exist
	return nDefault;
}

BOOL CSettings::Delete(CString strSetting)
{
	CString strValue;

	// the read only flag must not be set
	ASSERT(!m_bReadOnly);

	if (m_bReadOnly) {
		TRACE("CSettings::Delete: attempt to write to read-only CSettings object denied");
		return FALSE;
	}

	// the setting string must not be empty
	ASSERT(!strSetting.IsEmpty());

	// no case sensitivity for switches
	strSetting.MakeUpper();

	// is this setting in the map?
	if (m_mapSettings.Lookup(strSetting, strValue)) {
		// remove the entry from the map
		m_mapSettings.RemoveKey(strSetting);

		return TRUE;
	}
	return FALSE;
}

BOOL CSettings::ReadRegistry(void)
{
	DWORD dwDisposition;
	HKEY hKey;
	DWORD dwIndex;
	CString strSetting;
	DWORD dwSettingSize;
	CString strValue;
	DWORD dwValueSize;

	// the key name must not be empty
	ASSERT(!m_strKey.IsEmpty());

	if (m_strKey.IsEmpty()) {
		return FALSE;
	}

	// open the registry subkey
	if (RegCreateKeyEx(HKEY_CURRENT_USER, cstrKeyRoot + m_strKey, 0, strKeyClass.GetBuffer(0), REG_OPTION_NON_VOLATILE, KEY_READ, NULL, &hKey, &dwDisposition) == ERROR_SUCCESS) {

		// iterate through all values in the current registry subkey
		for (dwIndex = 0, dwSettingSize = 1023, dwValueSize = 1023; RegEnumValue(hKey, dwIndex, strSetting.GetBuffer(dwSettingSize), &dwSettingSize, 0, NULL, (unsigned char *)strValue.GetBuffer(dwValueSize), &dwValueSize) != ERROR_NO_MORE_ITEMS; dwIndex++) {
			strSetting.ReleaseBuffer(dwSettingSize);
			strValue.ReleaseBuffer(dwValueSize);

			// add these entries to the map
			SetTextValue(strSetting, strValue);

			dwSettingSize = 1023;
			dwValueSize = 1023;
		}

		RegCloseKey(hKey);
		return TRUE;
	}

	return FALSE;
}

BOOL CSettings::WriteRegistry(void)
{
	CString strSetting;
	CString strValue;
	POSITION pos;
	BOOL bResult = TRUE;
	
	// the key name must not be empty
	ASSERT(!m_strKey.IsEmpty());

	if (m_strKey.IsEmpty()) {
		return FALSE;
	}

	// iterate through all entries in the map and write them to the registry
	for (pos = m_mapSettings.GetStartPosition(); pos != NULL; ) {
		m_mapSettings.GetNextAssoc(pos, strSetting, strValue);

		bResult &= WriteRegistryValue(strSetting, strValue);
	}

	return bResult;
}



///////////////////////////////////////////////////////////////////////////////
// operations (internal)

// InterpretBooleanValue
//
// Description: This function interprets the given value into a boolean value.
//   No value is interpreted as true
//   FALSE, NO, OFF, and 0 are interpreted as FALSE.
//   TRUE, YES, ON, 1, and no value are interpreted as TRUE.
//
// Return value: boolean value of the switch (or nDefault if switch not defined)
BOOL CSettings::InterpretBooleanValue(CString &strValue, BOOL bDefault /*=FALSE*/)
{
	CString strFalse[] = { "0", "NO", "FALSE", "OFF", "" };
	CString strTrue[] = { "1", "YES", "TRUE", "ON", "" };

	// if there is no value, the value is TRUE
	if (strValue == "") {
		return TRUE;
	}

	// remove case sensitivity for boolean checks
	strValue.MakeUpper();

	int i;
	// check for FALSE interpretation
	for (i = 0; strFalse[i] != ""; i++) {
		if (strValue == strFalse[i]) {
			return FALSE;
		}
	}

	// check for TRUE interpretation
	for (i = 0; strTrue[i] != ""; i++) {
		if (strValue == strTrue[i]) {
			return TRUE;
		}
	}

	return bDefault;
}

BOOL CSettings::WriteRegistryValue(CString strSetting, CString strValue)
{
	DWORD dwDisposition;
	HKEY hKey;
	BOOL bResult = FALSE;

	// the key name must not be empty
	ASSERT(!m_strKey.IsEmpty());

	if (m_strKey.IsEmpty()) {
		return FALSE;
	}

	// the setting string must not be empty
	ASSERT(!strSetting.IsEmpty());

	// open the registry subkey
	if (RegCreateKeyEx(HKEY_CURRENT_USER, cstrKeyRoot + m_strKey, 0, strKeyClass.GetBuffer(0), REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dwDisposition) == ERROR_SUCCESS) {

		// write the value to the registry
		bResult = (RegSetValueEx(hKey, strSetting, 0, REG_SZ, (const unsigned char*)(LPCTSTR)strValue, strValue.GetLength()) == ERROR_SUCCESS);

		// close the registry
		RegCloseKey(hKey);
	}

	if (!bResult) {
		TRACE("CSettings::WriteRegistryValue: unable to write setting, value (%s, %s) to registry\n", strSetting, strValue);
	}
	return bResult;
}

CString CSettings::ReadRegistryValue(CString strSetting)
{
	DWORD dwDisposition;
	HKEY hKey;
	BOOL bResult = FALSE;
	CString strValue;
	DWORD dwValueSize = 1023;

	// the key name must not be empty
	ASSERT(!m_strKey.IsEmpty());

	if (m_strKey.IsEmpty()) {
		strValue.Empty();
		return strValue;
	}

	// the setting string must not be empty
	ASSERT(!strSetting.IsEmpty());

	// open the registry subkey
	if (RegCreateKeyEx(HKEY_CURRENT_USER, cstrKeyRoot + m_strKey, 0, strKeyClass.GetBuffer(0), REG_OPTION_NON_VOLATILE, KEY_READ, NULL, &hKey, &dwDisposition) == ERROR_SUCCESS) {

		// read the value from the registry
		bResult = (RegQueryValueEx(hKey, strSetting.GetBuffer(0), 0, NULL, (unsigned char*)strValue.GetBuffer(dwValueSize), &dwValueSize) == ERROR_SUCCESS);
		strValue.ReleaseBuffer();

		// close the registry
		RegCloseKey(hKey);
	}

	if (!bResult) {
		TRACE("CSettings::ReadRegistryValue: unable to read setting (%s) from registry\n", strSetting);
		strValue.Empty();
	}

	return strValue;
}

BOOL CSettings::DeleteRegistryValue(CString strSetting)
{
	DWORD dwDisposition;
	HKEY hKey;
	BOOL bResult = FALSE;

	// the key name must not be empty
	ASSERT(!m_strKey.IsEmpty());

	if (m_strKey.IsEmpty()) {
		return FALSE;
	}

	// the setting string must not be empty
	ASSERT(!strSetting.IsEmpty());

	// open the registry subkey
	if (RegCreateKeyEx(HKEY_CURRENT_USER, cstrKeyRoot + m_strKey, 0, strKeyClass.GetBuffer(0), REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dwDisposition) == ERROR_SUCCESS) {

		// delete the setting from the registry
		bResult = (RegDeleteValue(hKey, strSetting.GetBuffer(0)) == ERROR_SUCCESS);

		// close the registry
		RegCloseKey(hKey);
	}

	if (!bResult) {
		TRACE("CSettings::DeleteRegistryValue: unable to delete setting (%s) from registry\n", strSetting);
	}

	return bResult;
}

#ifdef _DEBUG
void CSettings::DumpSettings(CString strDesc)
{
	CString strSetting;
	CString strValue;
	POSITION pos;

	TRACE("Dumping %s:\n", strDesc);

	// interate through the map
	for (pos = m_mapSettings.GetStartPosition(); pos != NULL; ) {
		m_mapSettings.GetNextAssoc(pos, strSetting, strValue);
		TRACE("  %s = %s\n", (LPCTSTR)strSetting, (LPCTSTR)strValue);
	}
	TRACE("End of dump\n");
}
#endif // _DEBUG


TARGET_DATA BOOL gbLastSubSuite = FALSE;
TARGET_DATA BOOL gbPersistTarget = FALSE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\w32repl.cpp ===
///////////////////////////////////////////////////////////////////////////////
// 
// File: W32Repl.cpp
//
// Description: This file provides the implementations for overriddene Win32 
//              API calls.
///////////////////////////////////////////////////////////////////////////////
#include "w32repl.h"

#undef Sleep
#undef WaitForInputIdle

TARGET_DATA UINT g_nSleepModifier;		// Increases sleeps by this percentage.  100 = default behavior.
TARGET_DATA BOOL g_bInfiniteIdleWaits;	// If true, WaitForInputIdles are INFINITE.

VOID CAFE_Sleep(DWORD cMilliseconds)
{
	if (g_nSleepModifier == 100)	// Don't bother with the rest if we're at default.
		::Sleep(cMilliseconds);
	else
	{
		DWORD adj_msec = (g_nSleepModifier * cMilliseconds) / 100; // Not concerned about overload, but it's theoretically possible, though unlikely with DWORDs.

		::Sleep(adj_msec);	
	}
}

DWORD CAFE_WaitForInputIdle(HANDLE hProcess, DWORD dwTimeout)
{
	return ::WaitForInputIdle(hProcess, g_bInfiniteIdleWaits? INFINITE: dwTimeout);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\toolset.cpp ===
/////////////////////////////////////////////////////////////////////////////
// toolset.cpp
//
// email	date		change
// briancr	11/04/94	created
//
// copyright 1994 Microsoft

// Implementation of the CToolset class

#include "stdafx.h"
#include "afxdllx.h"
//#include "resource.h"
#include "settings.h"
#include "envpage.h"
#include "target.h"
#include "toolset.h"
#include "guiv1.h"
#include "idetarg.h"
#include "bldtools.h"

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CToolset
/*
CString CToolset::m_strToolsets[] = { "Visual C++ for x86",
										"Visual C++ for Macintosh",
										"Visual C++ for PowerMac",
										"Visual C++ for MIPS",
										"Visual C++ for Alpha",
										"Visual C++ for Win32s",
										"Visual C++ for PowerPC",
										"" };

CString CToolset::m_strToolsetSwitches[] = { "win32_x86",
											"mac_68k",
											"mac_ppc",
											"win32_mips",
											"win32_alpha",
											"win32s_x86",
											"win32_ppc",
											"" };

CString CToolset::m_strLanguage[] = { "English",
										"Japanese",
										"" };

*/

CString CToolset::m_strBuildType[] = { "Debug",
										"Retail",
										"" };

CString CToolset::m_strEnvvars[] = { "Path",
									"Include",
									"Lib",
									"" };


CToolset::CToolset(BUILD_TYPE nBuildType, HANDLE hOutput)
: m_strLang("\\English"),
  m_strDebug("\\" + m_strBuildType[m_nBuildType = nBuildType]),
  m_hOutput(hOutput),
  m_pLog(NULL),
  m_lang(TL_ENGLISH)
{
}

CToolset::~CToolset()
{
	// delete the settings object
	if (m_psettingsEnv) {
		delete m_psettingsEnv;
	}
	if (m_psettingsToolset) {
		delete m_psettingsToolset;
	}

	FreeLibrary(m_hStringsDll);
}

BOOL CToolset::ToolsetOptions(void)
{
	CTarget* pTool;
	POSITION pos;
	int i;

	// display the options dialog

	// create the tabbed options dialog
	CPropertySheet psToolset(IDS_ToolsetOptions);

	// create the standard toolset pages
	// create the environment page
	CEnvPage pageEnv(m_psettingsEnv);

	// add each page to the sheet
	psToolset.AddPage(&pageEnv);
	for (pos = m_listTools.GetHeadPosition(); pos != NULL; ) {
		pTool = m_listTools.GetNext(pos);
		psToolset.AddPage(pTool->GetPage());
	}

	// bring up the tabbed dialog
	psToolset.DoModal();

	// remove the tool pages from the sheet
	for (pos = m_listTools.GetHeadPosition(); pos != NULL; ) {
		pTool = m_listTools.GetNext(pos);
		psToolset.RemovePage(pTool->GetPage());
	}

	// set the environment settings in each target
	for (pos = m_listTools.GetHeadPosition(); pos != NULL; ) {
		pTool = m_listTools.GetNext(pos);
		for (i = 0; !m_strEnvvars[i].IsEmpty(); i++) {
			pTool->SetEnvironmentVar(m_strEnvvars[i], m_psettingsEnv->GetTextValue(m_strEnvvars[i]));
		}
	}
	return TRUE;
}

BOOL CToolset::AddTool(CTarget *pTool)
{
	// the target and the page cannot be NULL
	ASSERT(pTool);
	if (!pTool) {
		return FALSE;
	}

	// add it to the list of tools
	m_listTools.AddTail(pTool);

	return TRUE;
}

BOOL CToolset::ApplySettings(CSettings* pSettings)
{
	CTarget* pTool;
	POSITION pos;
	BOOL bResult = TRUE;

	// the settings object must be valid
	ASSERT(pSettings);

	// is the language defined?
	if (pSettings->IsDefined(settingLanguage)) {
		// if so, adjust the registry key we use
		m_psettingsToolset->SetTextValue(settingLanguage, pSettings->GetTextValue(settingLanguage));
		m_psettingsToolset->SetTextValue(settingLanguageKey, "\\" + m_psettingsToolset->GetTextValue(settingLanguage));
	}

	// set the key to use and initialize the settings for that key
	m_psettingsEnv->SetKey(m_strBaseKey + m_psettingsToolset->GetTextValue(settingLanguageKey) + m_psettingsToolset->GetTextValue(settingDebugBuildKey));
	InitializeEnvSettings();

	// apply these settings to all the targets
	// apply the cmd line to all targets
	for (pos = m_listTools.GetHeadPosition(); pos != NULL; ) {
		pTool = m_listTools.GetNext(pos);
		bResult &= pTool->ApplySettings(pSettings);
	}

	return bResult;
}

BOOL CToolset::InitializeSettings(void)
{
	return InitializeEnvSettings() & InitializeToolsetSettings();
}

BOOL CToolset::InitializeEnvSettings(void)
{
	int i;
	CString strEnvvar;
	BOOL bResult = TRUE;
	CTarget *pTool;

	// the environment settings object must be valid
	ASSERT(m_psettingsEnv);
	if (!m_psettingsEnv) {
		return FALSE;
	}

	// initialize environment settings
	for (i = 0; !m_strEnvvars[i].IsEmpty(); i++) {
		bResult &= (GetEnvironmentVariable(m_strEnvvars[i], strEnvvar.GetBuffer(1024), 1023) != 0);
		strEnvvar.ReleaseBuffer();
		if (bResult) {	
			m_psettingsEnv->SetTextValue(m_strEnvvars[i], strEnvvar);
		}
	}

	// load settings from the registry
	bResult &= m_psettingsEnv->ReadRegistry();
	// write the settings back out to initialize registry
	bResult &= m_psettingsEnv->WriteRegistry();

	// set the environment settings in each target
	for (POSITION pos = m_listTools.GetHeadPosition(); pos != NULL; ) {
		pTool = m_listTools.GetNext(pos);
		for (i = 0; !m_strEnvvars[i].IsEmpty(); i++) {
			pTool->SetEnvironmentVar(m_strEnvvars[i], m_psettingsEnv->GetTextValue(m_strEnvvars[i]));
		}
	}

	return bResult;
}

BOOL CToolset::InitializeToolsetSettings(void)
{
	BOOL bResult = TRUE;

	// the toolset settings object must be valid
	ASSERT(m_psettingsToolset);
	if (!m_psettingsToolset) {
		return FALSE;
	}

	// intialize toolset settings
	bResult &= m_psettingsToolset->SetTextValue(settingLanguage, "English");
	bResult &= m_psettingsToolset->SetTextValue(settingDebugBuildKey, m_strDebug);
	bResult &= m_psettingsToolset->SetTextValue(settingLanguageKey, "\\" + m_psettingsToolset->GetTextValue(settingLanguage));

	return bResult;
}

BOOL CToolset::SetLog(CLog* pLog)
{
	CTarget *pTool;

	// shouldn't set the log to NULL
	ASSERT(pLog);

	// store the toolset's log
	m_pLog = pLog;

	// set the log for each target
	for (POSITION pos = m_listTools.GetHeadPosition(); pos != NULL; ) {
		pTool = m_listTools.GetNext(pos);
		pTool->SetLog(m_pLog);
	}

	return TRUE;
}

CLog* CToolset::GetLog()
{
  return m_pLog;
}

const CToolPtrList& CToolset::GetToolList()
{
  return m_listTools;
}

BOOL CToolset::SetLanguage(CToolset::ToolsetLangs lang)
{
	// store the language
	m_lang = lang;

	// REVIEW(briancr): when the class hierarchy is rearranged
	// so that CO classes can get access to their parent and their
	// toolset, we won't need to set the language in the support
	// system; the CO class or whatever needs to know the language
	// can query the toolset.

	// the name of the dll that contains all the localized ide strings.
	CString cstrStringsDllName;

	// set the language for the support system.
	switch(m_lang)
	{
		case TL_ENGLISH:
		{
			SetLang(CAFE_LANG_ENGLISH);
			cstrStringsDllName = "StringsEnglish.dll";
			break;
		}
		case TL_GERMAN: 
		{
			SetLang(CAFE_LANG_GERMAN);
			cstrStringsDllName = "StringsGerman.dll";
			break;
		}
		case TL_JAPANESE: 
		{
			SetLang(CAFE_LANG_JAPANESE);
			cstrStringsDllName = "StringsJapanese.dll";
			break;
		}
		default: 
		{
			return FALSE;
			break;
		}
	}

	// load the library that contains the localized ide strings.
	m_hStringsDll = LoadLibrary(cstrStringsDllName);
	// store the handle so that the support layer can call GetLangDllHandle() to get it.
	SetLangDllHandle(m_hStringsDll);
	return TRUE;
}

CToolset::ToolsetLangs CToolset::GetLanguage(void)
{
	return m_lang;
}

/////////////////////////////////////////////////////////////////////////////
// CDevTools

CDevTools::CDevTools()
: m_pIDE(NULL),
  m_pCompilerDriver(NULL),
  m_pExecutable(NULL)
{
}

CDevTools::CDevTools(BUILD_TYPE nBuildType, HANDLE hOutput)
: CToolset(nBuildType, hOutput),
  m_pIDE(NULL),
  m_pCompilerDriver(NULL),
  m_pExecutable(NULL)
{
}

CDevTools::~CDevTools()
{
	if (m_pIDE)
		delete m_pIDE;
  if (m_pCompilerDriver)
    delete m_pCompilerDriver;
  if (m_pExecutable)
    delete m_pExecutable;
}

/////////////////////////////////////////////////////////////////////////////
// CVCTools

CExecutable* CVCTools::GetExecutable(LPCSTR szExeName)
{
	m_pExecutable->SetFileName(szExeName);
  return m_pExecutable;
}


/////////////////////////////////////////////////////////////////////////////
// CX86Tools

BOOL CX86Tools::Initialize(CString strBaseKey)
{
	BOOL bResult = TRUE;

	// set key for X86Tools and create settings object
	strBaseKey += "\\"+strX86ToolsKey;
	// save the base key for this toolset
	m_strBaseKey = strBaseKey;

	// create a new environment settings object
	m_psettingsEnv = new CSettings(m_strBaseKey + m_strLang + m_strDebug);
	// create a new toolset settings object
	m_psettingsToolset = new CSettings(m_strBaseKey);

	// create an IDE
	m_pIDE = new CX86IDE;
	bResult &= AddTool(m_pIDE);

	// create a compiler driver
	m_pCompilerDriver = new CX86CompilerDriver(m_hOutput);
	bResult &= AddTool(m_pCompilerDriver);

	// create an executable
	m_pExecutable = new CX86Executable(m_hOutput);
	AddTool(m_pExecutable);

	//TODO(CFlaat): implement prop page for executable
	//	bResult &= AddTool(m_pExecutable);

	//TODO(CFlaat): add compiler/executable class for other toolsets

	// initialize settings object
	bResult &= InitializeSettings();

	// initialize the target objects.
	m_pIDE->Initialize(m_nBuildType, m_strBaseKey);
	m_pCompilerDriver->Initialize(m_nBuildType, m_strBaseKey);
	m_pExecutable->Initialize(m_nBuildType, m_strBaseKey);

	return bResult;
}


/////////////////////////////////////////////////////////////////////////////
// CWin32sTools
BOOL CWin32sTools::Initialize(CString strBaseKey)
{
	BOOL bResult = TRUE;

	// set key for Win32sTools and create settings object
	strBaseKey += "\\"+strWin32sToolsKey;
	// save the base key for this toolset
	m_strBaseKey = strBaseKey;

	// create a new environment settings object
	m_psettingsEnv = new CSettings(m_strBaseKey + m_strLang + m_strDebug);
	// create a new toolset settings object
	m_psettingsToolset = new CSettings(m_strBaseKey);

	// create an IDE
	m_pIDE = new CWin32sIDE;
	bResult &= AddTool(m_pIDE);

	// initialize settings object
	bResult &= InitializeSettings();

	// initialize the target object
	m_pIDE->Initialize(m_nBuildType, m_strBaseKey);

	return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// C68KTools

BOOL C68KTools::Initialize(CString strBaseKey)
{
	BOOL bResult = TRUE;

	// set key for 68KTools and create settings object
	strBaseKey += "\\"+str68KToolsKey;
	// save the base key for this toolset
	m_strBaseKey = strBaseKey;

	// create a new environment settings object
	m_psettingsEnv = new CSettings(m_strBaseKey + m_strLang + m_strDebug);
	// create a new toolset settings object
	m_psettingsToolset = new CSettings(m_strBaseKey);

	// create an IDE
	m_pIDE = new C68KIDE;
	bResult &= AddTool(m_pIDE);

	// initialize settings object
	bResult &= InitializeSettings();

	// initialize the target object
	m_pIDE->Initialize(m_nBuildType, m_strBaseKey);

	return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// CPMacTools

BOOL CPMacTools::Initialize(CString strBaseKey)
{
	BOOL bResult = TRUE;

	// set key for PMacTools and create settings object
	strBaseKey += "\\"+strPMacToolsKey;
	// save the base key for this toolset
	m_strBaseKey = strBaseKey;

	// create a new environment settings object
	m_psettingsEnv = new CSettings(m_strBaseKey + m_strLang + m_strDebug);
	// create a new toolset settings object
	m_psettingsToolset = new CSettings(m_strBaseKey);

	// create an IDE
	m_pIDE = new CPMacIDE;
	bResult &= AddTool(m_pIDE);

	// initialize settings object
	bResult &= InitializeSettings();

	// initialize the target object
	m_pIDE->Initialize(m_nBuildType, m_strBaseKey);

	return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// CMIPSTools

BOOL CMIPSTools::Initialize(CString strBaseKey)
{
	BOOL bResult = TRUE;

	// set key for MIPSTools and create settings object
	strBaseKey += "\\"+strMIPSToolsKey;
	// save the base key for this toolset
	m_strBaseKey = strBaseKey;

	// create a new environment settings object
	m_psettingsEnv = new CSettings(m_strBaseKey + m_strLang + m_strDebug);
	// create a new toolset settings object
	m_psettingsToolset = new CSettings(m_strBaseKey);

	// create an IDE
	m_pIDE = new CMIPSIDE;
	bResult &= AddTool(m_pIDE);

	// initialize settings object
	bResult &= InitializeSettings();

	// initialize the target object
	m_pIDE->Initialize(m_nBuildType, m_strBaseKey);


	return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// CAlphaTools

BOOL CAlphaTools::Initialize(CString strBaseKey)
{
	BOOL bResult = TRUE;

	// set key for AlphaTools and create settings object
	strBaseKey += "\\"+strAlphaToolsKey;
	// save the base key for this toolset
	m_strBaseKey = strBaseKey;

	// create a new environment settings object
	m_psettingsEnv = new CSettings(m_strBaseKey + m_strLang + m_strDebug);
	// create a new toolset settings object
	m_psettingsToolset = new CSettings(m_strBaseKey);

	// create an IDE
	m_pIDE = new CAlphaIDE;
	bResult &= AddTool(m_pIDE);

	// initialize settings object
	bResult &= InitializeSettings();

	// intialize the target object
	m_pIDE->Initialize(m_nBuildType, m_strBaseKey);

	return bResult;
}
/////////////////////////////////////////////////////////////////////////////
// CPowerPCTools

BOOL CPowerPCTools::Initialize(CString strBaseKey)
{
	BOOL bResult = TRUE;

	// set key for PowerPCTools and create settings object
	strBaseKey += "\\"+strPowerPCToolsKey;
	// save the base key for this toolset
	m_strBaseKey = strBaseKey;

	// create a new environment settings object
	m_psettingsEnv = new CSettings(m_strBaseKey + m_strLang + m_strDebug);
	// create a new toolset settings object
	m_psettingsToolset = new CSettings(m_strBaseKey);

	// create an IDE
	m_pIDE = new CPowerPCIDE;
	bResult &= AddTool(m_pIDE);

	// initialize settings object
	bResult &= InitializeSettings();

	// intialize the target object
	m_pIDE->Initialize(m_nBuildType, m_strBaseKey);


	return bResult;
}


// toolset creation

__declspec(dllexport) CToolset * CreateToolset(CPlatform::COS *pOS, CPlatform::CLanguage *pLang, CToolset::BUILD_TYPE eBT, HANDLE hOutput)
{
    CToolset *pToolset;

    if (*pOS == CPlatform::Mac68K)
        pToolset = new C68KTools(eBT, hOutput);
    else if (*pOS == CPlatform::MacPowerPC)
        pToolset = new CPMacTools(eBT, hOutput);
    else if (*pOS == CPlatform::Win32Mips) 
        pToolset = new CMIPSTools(eBT, hOutput);
    else if (*pOS == CPlatform::Win32Alpha)
        pToolset = new CAlphaTools(eBT, hOutput);
    else if (*pOS == CPlatform::Win32PowerPC)
        pToolset = new CPowerPCTools(eBT, hOutput);
    else if (*pOS == CPlatform::Win32s)
        pToolset = new CWin32sTools(eBT, hOutput);
    else // win32s will just be x86 for now
        pToolset = new CX86Tools(eBT, hOutput);


// TODO(CFlaat): axe CToolset::TL_ENGLISH, etc. & use CPlatform::CLanguage

    if (*pLang == CPlatform::English)
    {
        pToolset->SetLanguage(CToolset::TL_ENGLISH);
    }
    else if (*pLang == CPlatform::German)
    {
        pToolset->SetLanguage(CToolset::TL_GERMAN);
    }
    else if (*pLang == CPlatform::Japanese)
    {
        pToolset->SetLanguage(CToolset::TL_JAPANESE);
    }

    return pToolset;

}



///////////////////////////////////////////////////////////////////////////////
//	DLL support

static AFX_EXTENSION_MODULE extensionDLL = { NULL, NULL };

extern "C" __declspec(dllexport) int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("Toolset DLL Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(extensionDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(extensionDLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("Toolset DLL Terminating!\n");
		// Terminate the library before destructors are called
		AfxTermExtensionModule(extensionDLL);

	}
	return 1;   // ok

	UNREFERENCED_PARAMETER(lpReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\testxcpt.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	testxcpt.cpp
//
//	Created by :			Date :
//		BrianCr				11/29/94
//
//	Description :
//		Implementation of the CTestException class
//

#include "stdafx.h"
// #include "test.h"
#include "testxcpt.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

#pragma message("Working around Olympus bugs 3244 and 3245.")

/*
IMPLEMENT_DYNAMIC(CTestException, CException)
*/

CTestException::CTestException(CString strMsg /*= ""*/, CTestException::TestExceptionCause cause /*= CTestException::causeUnknown*/, LPCSTR lpszFileName /*= NULL*/, int nLine /*= -1*/)
: m_strMsg(strMsg),
  m_cause(cause),
  m_file(lpszFileName),
  m_line(nLine)
{
}

//////////////////////////////////////////////////////////////////////////////
//	Debug CTestException functions

#ifdef _DEBUG
// character strings to use for dumping CTestException
static char BASED_CODE szUnknown[] = "unknown";
static char BASED_CODE szGeneric[] = "generic";
static char BASED_CODE szOperationFail[] = "operation failed";
static char BASED_CODE szAssumptionFail[] = "assumption failed";
static char BASED_CODE szExpectFail[] = "expectation failed";
static char BASED_CODE szSafetyFail[] = "safety failed";
static char BASED_CODE szTargetGone[] = "target gone";
static char BASED_CODE szTargetAssert[] = "target assert";
static char BASED_CODE szTargetGPF[] = "target crash";

static LPCSTR BASED_CODE rgszCTestExceptionCause[CTestException::NUM_CAUSES] =
{
	szUnknown,
	szGeneric,
	szOperationFail,
	szAssumptionFail,
	szExpectFail,
	szSafetyFail,
	szTargetGone,
	szTargetAssert,
	szTargetGPF
};
#endif //_DEBUG

/*
#ifdef _DEBUG
void CTestException::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "msg = " << m_strMsg << "; cause = " << rgszCTestExceptionCause[m_cause];
}
#endif //_DEBUG
*/

//////////////////////////////////////////////////////////////////////////////
//	Other CTestException functions
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\BldTools\bldtools.cpp ===
#include "stdafx.h"
#include "afxdllx.h"
#include "bldtools.h"

#define new DEBUG_NEW

///////////////////////////////////////////////////////////////////////////////
//	DLL support

static AFX_EXTENSION_MODULE extensionDLL = { NULL, NULL };

extern "C" __declspec(dllexport) int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("Build Tools DLL Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(extensionDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(extensionDLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("Build Tools DLL Terminating!\n");
		// Terminate the library before destructors are called
		AfxTermExtensionModule(extensionDLL);
	}
	return 1;   // ok

	UNREFERENCED_PARAMETER(lpReserved);
}



// REVIEW(CFlaat): can this function be generalized to handle profiling?
BOOL CConsoleTarget::CreateTargetProcess(LPCSTR szCmdLine, DWORD dwCreationFlags, LPCSTR szEnvBlock, LPCSTR szWorkDir)
{
  char chReadBuffer[2000];  /* pipe read buffer */
  BOOL bSuccess;  /* BOOL return code for APIs */
  /* handles to the anonymous pipe */
  HANDLE hReadPipe, hWritePipe, hWritePipe2;
  DWORD cchReadBuffer;  /* number of bytes read or to be written */
  STARTUPINFO si;  /* for CreateProcess call */
  PROCESS_INFORMATION pi;  /* for CreateProcess call */
  SECURITY_ATTRIBUTES saPipe;  /* security for anonymous pipe */

  /* set up the security attributes for the anonymous pipe */
  saPipe.nLength = sizeof(SECURITY_ATTRIBUTES);
  saPipe.lpSecurityDescriptor = NULL;
  /* In order for the child to be able to write to the pipe, the handle */
  /* must be marked as inheritable by setting this flag: */
  saPipe.bInheritHandle = TRUE;

  /* create the anonymous pipe */
  bSuccess = CreatePipe(&hReadPipe,  /* read handle */
      &hWritePipe,  /* write handle, used as stdout by child */
      &saPipe,  /* security descriptor */
      0);  /* pipe buffer size */

  /* Now we need to change the inheritable property for the readable
  end of the pipe so that the child will not inherit that handle as
  a "garbage" handle. This will keep us from having extra,
  unclosable handles to the pipe. Alternatively, we could have
  opened the pipe with saPipe.bInheritHandle = FALSE and changed the
  inherit property on the *write* handle of the pipe to TRUE. */

  bSuccess = DuplicateHandle(GetCurrentProcess(), /* source process */
      hReadPipe, /* handle to duplicate */
      GetCurrentProcess(), /* destination process */
      NULL, /* new handle - don't want one, change original handle */
      0, /* new access flags - ignored since DUPLICATE_SAME_ACCESS */
      FALSE, /* make it *not* inheritable */
      DUPLICATE_SAME_ACCESS);

  /* I most cases you can get away with using the same anonymous
  pipe write handle for both the child's standard output and
  standard error, but this may cause problems if the child app
  explicitly closes one of its standard output or error handles. If
  that happens, the anonymous pipe will close, since the child's
  standard output and error handles are really the same handle. The
  child won't be able to write to the other write handle since the
  pipe is now gone, and parent reads from the pipe will return
  ERROR_BROKEN_PIPE and child output will be lost. To solve this
  problem, simply duplicate the write end of the pipe to create
  another distinct, separate handle to the write end of the pipe.
  One pipe write handle will serve as standard out, the other as
  standard error. Now *both* write handles must be closed before the
  write end of the pipe actually closes. */

  bSuccess = DuplicateHandle(GetCurrentProcess(), /* source process */
      hWritePipe, /* handle to duplicate */
      GetCurrentProcess(), /* destination process */
      &hWritePipe2, /* new handle, used as stderr by child */
      0, /* new access flags - ignored since DUPLICATE_SAME_ACCESS */
      TRUE, /* it's inheritable */
      DUPLICATE_SAME_ACCESS);

  /* Set up the STARTUPINFO structure for the CreateProcess() call */
  memset(&si, 0, sizeof(si));
  si.cb = sizeof(si);

  /* If using the STARTUPINFO STARTF_USESTDHANDLES flag, be sure to
  set the CreateProcess fInheritHandles parameter too TRUE so that
  the file handles specified in the STARTUPINFO structure will be
  inheritied by the child. Note that we don't specify a standard
  input handle; the child will not inherit a valid input handle, so
  if it reads from stdin, it will encounter errors. */

  si.hStdOutput = hWritePipe; /* write end of the pipe */
  si.hStdError = hWritePipe2; /* duplicate of write end of the pipe */
  si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
  si.wShowWindow = SW_HIDE;

  /* Now create the child process, inheriting handles */

  bSuccess = CreateProcess(NULL,  /* filename */
      (LPTSTR)szCmdLine,  /* full command line for child */
      NULL,  /* process security descriptor */
      NULL,  /* thread security descriptor */
      TRUE,  /* inherit handles? Also use if STARTF_USESTDHANDLES */
      dwCreationFlags,  /* creation flags */
      (void*)szEnvBlock,  /* inherited environment address */
      szWorkDir,  /* startup dir; NULL = start in current */
      &si,  /* pointer to startup info (input) */
      &pi);  /* pointer to process info (output) */

  #ifdef _DEBUG
  
  DWORD dwError = GetLastError();

  #endif

  /* We can close the returned child process handle and thread
  handle as we won't be needing them; you could, however, wait on
  the process handle to wait until the child process terminates. */


  /* We need to close our instances of the inheritable pipe write
  handle now that it's been inherited so that all open handles to
  the pipe are closed when the child process ends and closes its
  handles to the pipe. */

  bSuccess = CloseHandle(hWritePipe);
  bSuccess = CloseHandle(hWritePipe2);

  CString strInfo, strExeName;
  static const char cMark = '\xff';

  m_psettingsTarget -> GetTextValue(settingFilename, strExeName);

  strInfo.Format("%c5[Begin '%s']\n%c1",cMark, szCmdLine, cMark);

  WriteFile(
    m_hViewport,
    (LPCSTR)strInfo,
    strInfo.GetLength(),
    &cchReadBuffer,
    0);


  m_bufOutput.ResetContents();

  //TODO(CFlaat): make this code resistant to hangs; determine timeout limit

  /* read from the pipe until we get an ERROR_BROKEN_PIPE */
  while (1)
  {
    bSuccess = ReadFile(hReadPipe,  /* read handle */
        chReadBuffer,  /* buffer for incoming data */
        sizeof(chReadBuffer),  /* number of bytes to read */
        &cchReadBuffer,  /* number of bytes actually read */
        NULL);  /* no overlapped reading */
    if (!bSuccess && (GetLastError() == ERROR_BROKEN_PIPE))
      break;  /* child has died */
    if (bSuccess && cchReadBuffer)
    {
      /* write the data from the child to the file */
      bSuccess = WriteFile(m_hViewport,  /* write handle */
          chReadBuffer,  /* buffer to write */
          cchReadBuffer,  /* number of bytes to write */
          &cchReadBuffer,  /* number of bytes actually written */
          NULL);  /* no overlapped writing */

      m_bufOutput.Append(chReadBuffer, cchReadBuffer);  // append to our internal buffer
    }
  }

  CloseHandle(hReadPipe);

  strInfo.Format("%c6[End '%s']\n",cMark, szCmdLine, cMark);

  WriteFile(
    m_hViewport,
    (LPCSTR)strInfo,
    strInfo.GetLength(),
    &cchReadBuffer,
    0);


  DWORD dw = WaitForSingleObject(pi.hProcess, 60000);

  if (WAIT_OBJECT_0 != dw)
  {
    dw = GetLastError();
//    ASSERT(FALSE);
    return FALSE;
  }

  if (!GetExitCodeProcess(pi.hProcess, &m_dwExitCode))
  {
    ASSERT(FALSE);
    return FALSE;
  }
  

  bSuccess = CloseHandle(pi.hThread);
  bSuccess &= CloseHandle(pi.hProcess);

  // REVIEW(CFlaat): we should use bSuccess more than we presently do
  return bSuccess;
}


LPCSTR CConsoleTarget::GetLastOutput(void)
{
  return m_bufOutput.GetAsSZ();
}

LPCSTR CConsoleTarget::GetLastCmdLine(void)
{
  return m_strLastCmdLine;
}


void CConsoleTarget::COutputBuffer::ResetContents(void)
{
  m_pcNext = m_acBuf;
  m_bFull = FALSE;
}

LPCSTR CConsoleTarget::COutputBuffer::GetAsSZ(void)
{
  ASSERT((m_pcNext - m_acBuf) < BufSize);  // ensure we're not past the end
  ASSERT(m_pcNext);
  *m_pcNext = '\0';
  return m_acBuf;
}

BOOL CConsoleTarget::COutputBuffer::Append(LPCSTR szText, UINT cbRequested)
{
  if (m_bFull)
    return FALSE;

  static LPCSTR szTrunc = " <Output truncated>";
  static UINT cbTrunc = strlen(szTrunc);
  UINT cbAvail = BufSize - (m_pcNext - m_acBuf) - cbTrunc - 1;  // we save space for the truncation message
  UINT cbToWrite;

  if (cbAvail < cbRequested)  // if we don't have enough space available
  {
    cbToWrite = cbAvail;
    memcpy(m_pcNext, szText, cbAvail);  // do the copy
    m_pcNext += cbAvail;
    memcpy(m_pcNext, szTrunc, cbTrunc); // add the truncation notification message
    m_pcNext += cbTrunc;
    m_bFull = TRUE;
    return TRUE;
  }
  else
  {
    cbToWrite = cbRequested; // otherwise, write all that's requested
    memcpy(m_pcNext, szText, cbToWrite);  // do the copy
    m_pcNext += cbToWrite;
    return TRUE;
  }
}

BOOL CConsoleTarget::COutputBuffer::IsEmpty(void)
{
  return (m_acBuf == m_pcNext);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\BldTools\comppage.cpp ===
// comppage.cpp : implementation file
//

#include "stdafx.h"
#include "bldtools.h"
#include "comppage.h"

#define new DEBUG_NEW

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCompilerDriverPage property page

IMPLEMENT_DYNCREATE(CCompilerDriverPage, CPropertyPage)

CCompilerDriverPage::CCompilerDriverPage(CSettings* pSettings /*= NULL*/) : CPropertyPage(CCompilerDriverPage::IDD)
{
	//{{AFX_DATA_INIT(CCompilerDriverPage)
	m_strCmdLine = _T("");
	m_strFilename = _T("");
	m_strWorkDir = _T("");
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CCompilerDriverPage::~CCompilerDriverPage()
{
}

void CCompilerDriverPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCompilerDriverPage)
	DDX_Text(pDX, IDE_CompilerCmdLine, m_strCmdLine);
	DDX_Text(pDX, IDE_CompilerFilename, m_strFilename);
	DDX_Text(pDX, IDE_CompilerWorkDir, m_strWorkDir);
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCompilerDriverPage, CPropertyPage)
	//{{AFX_MSG_MAP(CCompilerDriverPage)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CCompilerDriverPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\BldTools\compiler.cpp ===
/*
    COMPILER.CPP

    Copyright 1994-95, Microsoft Corp.

    This file contains the implementation of the CCompilerDriver class.

    Edit history:
      1] CFlaat / 1-1-95 / finished creation

*/


#include "stdafx.h"
#include "bldtools.h"
#include "comppage.h"

#define new DEBUG_NEW

BOOL CCompilerDriver::CompileOnly(LPCSTR szSrcFile, LPCSTR szCompileArgs)                         // CL -c [...]
{
  CString strCmdLine;

  // TODO: use permanent compiler switches

  strCmdLine.Format("-c %s %s", szSrcFile, szCompileArgs);

  m_psettingsTarget->SetTextValue(settingCmdLine, strCmdLine);

  if (!Launch())
    return FALSE;

  return !GetExitCode();
}

BOOL CCompilerDriver::CompileAndLink(LPCSTR szSrcFile, LPCSTR szCompileArgs, LPCSTR szLinkArgs) // CL [...] -link [...]
{
  CString strCmdLine;

  // TODO: use permanent compiler and linker switches

  strCmdLine.Format("%s %s -link %s", szSrcFile, szCompileArgs, szLinkArgs);

  m_psettingsTarget->SetTextValue(settingCmdLine, strCmdLine);

  if (!Launch())
    return FALSE;

  return !GetExitCode();
}

BOOL CCompilerDriver::LinkOnly(LPCSTR szObjFile, LPCSTR szLinkArgs)                               // CL -link [...]
{
  CString strCmdLine;

  // TODO: use permanent linker switches

  strCmdLine.Format("-link %s %s", szObjFile, szLinkArgs);

  m_psettingsTarget->SetTextValue(settingCmdLine, strCmdLine);

  if (!Launch())
    return FALSE;

  return !GetExitCode();
}


BOOL CCompilerDriver::Initialize(CToolset::BUILD_TYPE nBuildType, CString strKey)
{
	// instantiate the settings object for this target
	strKey += "\\";
  strKey += "CompilerDriver";
	m_psettingsTarget = new CSettings(strKey);

	// instantiate the property page for this target
	m_ppageTarget = new CCompilerDriverPage(m_psettingsTarget);

	// initialize settings
	return InitializeSettings();
}

BOOL CCompilerDriver::ApplySettings(CSettings* pSettings)
{
	// call the base class
	CConsoleTarget::ApplySettings(pSettings);

	// TODO(CFlaat): apply command line overrides

	return TRUE;
}


BOOL CCompilerDriver::InitializeSettings(void)
{
	CString strDrive;
	CString strDir;

	char cl_path[256],*pcl_exe=NULL;

	BOOL bResult = TRUE;

	// call the base class
	bResult &= CConsoleTarget::InitializeSettings();

	// initialize  default settings
	m_psettingsTarget->SetTextValue(settingFilename, "cl.exe");
	m_psettingsTarget->SetTextValue(settingWorkingDir, "e:\\cafe\\v3\\sd2\\testdir");

	m_strFileName = m_psettingsTarget->GetTextValue(settingFilename);
  //REVIEW(chriskoz): I've no idea about these bogus, hardcoded paths. The path shld be taken from ENV, I supose.
	BOOL bPath;
	bPath = m_mapEnv.Lookup( "PATH", /*CObject*&*/m_strPath); // = "d:\\v3\\bin\\";
	if(bPath)
		bPath = ::SearchPath(m_strPath, m_strFileName, NULL, 1024, cl_path, &pcl_exe);
	if(bPath && pcl_exe)
	{
		*pcl_exe=0; //cut the exe name which is not supposed to be in m_strPath
		m_strPath = cl_path;
	}
//	else //no path found, but leave it bogus (emptying it often means do not fail on bogus state)
//		m_strPath.Empty(); 
#if 0  //TODO(CFlaat): figure out why this doesn't work!
	// load settings from the registry
	bResult &= m_psettingsTarget->ReadRegistry();
	// write the settings back out to initialize registry
	bResult &= m_psettingsTarget->WriteRegistry();
#endif

	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\target.cpp ===
/////////////////////////////////////////////////////////////////////////////
// target.cpp
//
// email	date		change
// briancr	11/04/94	created
//
// copyright 1994 Microsoft

// Implementation of the CTarget class

#include "stdafx.h"
#include "afxdllx.h"
#include "applog.h"
#include "testxcpt.h"
#include "target.h"

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CTarget

const LPCTSTR CTarget::eventTerminate = "Terminate ";
const LPCTSTR CTarget::eventTargetSuccess = "Success ";
const LPCTSTR CTarget::eventTargetFail = "Fail ";

int CTarget::nCount = 0;



CTarget::CTarget()
:	m_hthreadDebug(NULL),
	m_ppageTarget(NULL),
	m_psettingsTarget(NULL),
	m_bInitProcess(FALSE),
	m_nExpectedLeaks(0)
{

	// set up unique id used for creating unique for system objects
	m_nId = ::GetTickCount()+nCount++;

	m_procinfoTarget.hProcess = 0;
	m_procinfoTarget.hThread = 0;
	m_procinfoTarget.dwProcessId = 0;
	m_procinfoTarget.dwThreadId = 0;

	// each target has a default environment
	InitEnv();

//save the handle to the current thread in hTestthread for suspenssion
	if(::DuplicateHandle(::GetCurrentProcess(), GetCurrentThread(), ::GetCurrentProcess(), &m_hTestthread, 0, FALSE, DUPLICATE_SAME_ACCESS)==0)
		m_hTestthread=NULL;
	m_hEventThread=NULL;
	m_handlemsgs=FALSE;
	m_nWndtoHandle=0;
}

CTarget::~CTarget()
{
	const char* const THIS_FUNCTION = "CTarget::~CTarget";
	
	// if the thread was created...
	if (m_hTerminate && (m_hthreadDebug || m_hEventThread))
	{
		// terminate the threads
		::SetEvent(m_hTerminate);

		// wait for the threads to terminate
		if (m_hthreadDebug && WaitForSingleObject(m_hthreadDebug, 2000) != WAIT_OBJECT_0) {
			TRACE("%s: unable to terminate debug thread (%lx) by request; forcing termination\n", THIS_FUNCTION, m_hthreadDebug);
			TerminateThread(m_hthreadDebug, DWORD(-1));
		}
		if (m_hEventThread && WaitForSingleObject(m_hEventThread, 2000) != WAIT_OBJECT_0) {
			TRACE("%s: unable to terminate event thread (%lx) by request; forcing termination\n", THIS_FUNCTION, m_hEventThread);
			TerminateThread(m_hEventThread, DWORD(-1));
		}
		::CloseHandle(m_hTerminate);
	}
	//close the handles, ::CreateProcess() bumped up their count to 2
	//we couldn't close these handles until now after debug thread has terminated
	if(m_procinfoTarget.hProcess)
		::CloseHandle(m_procinfoTarget.hProcess);
	if(m_procinfoTarget.hThread)
		::CloseHandle(m_procinfoTarget.hThread);

	// delete the property page associated with this target
	if (m_ppageTarget) {
		delete m_ppageTarget;
	}

	// delete the settings object associated with this target
	if (m_psettingsTarget) {
		delete m_psettingsTarget;
	}
	if(m_hTestthread!=NULL)
		::CloseHandle(m_hTestthread);
	if(m_hEventThread!=NULL)
		::CloseHandle(m_hEventThread);
}

BOOL CTarget::Launch(void)
{
	const char* const THIS_FUNCTION = "CTarget::Launch";
	HANDLE hTargetSuccess;
	HANDLE hTargetFail;
	HANDLE hthreadDebug;
	DWORD dwWaitResult;
	CString strMsg;

	APPLOG("%s: launching target '%s'...", THIS_FUNCTION, (LPCSTR)GetFileName());

	m_EnableExceptionMessageHandling = TRUE;

	// create an event for signalling the worker threads
	m_hTerminate = ::CreateEvent(NULL, TRUE, FALSE, eventTerminate + GetUniqueName());

	// create events for successful/failed launching
	hTargetSuccess = ::CreateEvent(NULL, FALSE, FALSE, eventTargetSuccess + GetUniqueName());
	hTargetFail = ::CreateEvent(NULL, FALSE, FALSE, eventTargetFail + GetUniqueName());

	// Event handles must be valid
	ASSERT(m_hTerminate && hTargetSuccess && hTargetFail);
	if (!m_hTerminate || !hTargetSuccess || !hTargetFail) {
		strMsg.Format("%s: unable to create events to launch target '%s'.", THIS_FUNCTION, (LPCSTR)GetFileName());
		APPLOG(strMsg);
		throw CTestException(strMsg, CTestException::causeOperationFail);
	}

	// create a worker thread to launch the target
	DWORD dwThreadId;
	m_hthreadDebug = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)CTarget::WrapLaunchTarget, this, 0, &dwThreadId);
	if (!m_hthreadDebug) {
		strMsg.Format("%s: unable to create a thread to launch the target '%s'. GetLastError = %d.", THIS_FUNCTION, (LPCSTR)GetFileName(), GetLastError());
		APPLOG(strMsg);
		throw CTestException(strMsg, CTestException::causeOperationFail);
	}

	// create a duplicate handle to the debug thread
	// if the thread terminates, all handles to it go away and it's invalid
	::DuplicateHandle(::GetCurrentProcess(), m_hthreadDebug, ::GetCurrentProcess(), &hthreadDebug, 0, FALSE, DUPLICATE_SAME_ACCESS);

	// wait for either success or failure for 30 seconds.  That should be long enough.
	HANDLE hObjects[] = { hTargetSuccess, hTargetFail, m_hthreadDebug };
	dwWaitResult = ::WaitForMultipleObjects(sizeof(hObjects)/sizeof(HANDLE), hObjects, FALSE, 30000);

	// if launching was not successful
	if (dwWaitResult != WAIT_OBJECT_0) {
		if (dwWaitResult == WAIT_TIMEOUT) {
			strMsg.Format("timeout waiting for the target '%s' to launch.", (LPCSTR)GetFileName());
		}
		else {
			// get the result from the debug thread
			strMsg = GetThreadResult(hthreadDebug);
		}
		strMsg = CString(THIS_FUNCTION) + strMsg;
		APPLOG(strMsg);
		throw CTestException(strMsg, CTestException::causeOperationFail);
	}

	DWORD dwEventThreadId;
	m_hEventThread=::CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)CTarget::WrapEventHandler, this, 0, &dwEventThreadId);
	
	// close handle to thread
	::CloseHandle(hthreadDebug);

	// close handles to events
	::CloseHandle(hTargetSuccess);
	::CloseHandle(hTargetFail);

	return (dwWaitResult == WAIT_OBJECT_0);
}

BOOL CTarget::Attach(void)
{
	const char* const THIS_FUNCTION = "CTarget::Attach";
	HANDLE hTargetSuccess;
	HANDLE hTargetFail;
	HANDLE hthreadDebug;
	DWORD dwWaitResult;
	CString strMsg;

	APPLOG("%s: attaching to target '%s'...", THIS_FUNCTION, GetFileName());

	// the process handle must be valid
	ASSERT(m_procinfoTarget.hProcess);
	if (!m_procinfoTarget.hProcess) {
		strMsg.Format("%s: process handle (%lx) is invalid; unable to attach to target '%s'.", THIS_FUNCTION, m_procinfoTarget.hProcess, (LPCSTR)GetFileName());
		APPLOG(strMsg);
		throw CTestException(strMsg, CTestException::causeOperationFail);
	}

	// create an event for signalling the worker thread
	m_hTerminate = ::CreateEvent(NULL, TRUE, FALSE, eventTerminate + GetUniqueName());

	// create events for successful/failed launching
	hTargetSuccess = ::CreateEvent(NULL, FALSE, FALSE, eventTargetSuccess + GetUniqueName());
	hTargetFail = ::CreateEvent(NULL, FALSE, FALSE, eventTargetFail + GetUniqueName());

	// the event handle must be valid
	ASSERT(m_hTerminate && hTargetSuccess && hTargetFail);
	if (!m_hTerminate || !hTargetSuccess || !hTargetFail) {
		strMsg.Format("%s: unable to create events to attach to target '%s'.", THIS_FUNCTION, (LPCSTR)GetFileName());
		APPLOG(strMsg);
		throw CTestException(strMsg, CTestException::causeOperationFail);
	}

	// create a worker thread to attach to the target
	DWORD dwThreadId;
	m_hthreadDebug = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)CTarget::WrapAttachTarget, this, 0, &dwThreadId);
	if (!m_hthreadDebug) {
		strMsg.Format("%s: unable to create a thread to attach to the target '%s'. GetLastError = %d.", THIS_FUNCTION, (LPCSTR)GetFileName(), GetLastError());
		APPLOG(strMsg);
		throw CTestException(strMsg, CTestException::causeOperationFail);
	}

	// create a duplicate handle to the debug thread
	// if the thread terminates, all handles to it go away and it's invalid
	::DuplicateHandle(::GetCurrentProcess(), m_hthreadDebug, ::GetCurrentProcess(), &hthreadDebug, 0, FALSE, DUPLICATE_SAME_ACCESS);

	// wait for either success or failure
	HANDLE hObjects[] = { hTargetSuccess, hTargetFail, m_hthreadDebug };
	dwWaitResult = ::WaitForMultipleObjects(sizeof(hObjects)/sizeof(HANDLE), hObjects, FALSE, INFINITE);

	// did the target launch successfully?
	if (dwWaitResult != WAIT_OBJECT_0) {
		// get the result from the debug thread
		strMsg = GetThreadResult(hthreadDebug);
		TRACE("CTarget::Attach: %s\n", (LPCTSTR)strMsg);
		throw CTestException(strMsg, CTestException::causeOperationFail);
	}
	DWORD dwEventThreadId;
	m_hEventThread=::CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)CTarget::WrapEventHandler, this, 0, &dwEventThreadId);

	// close handle to thread
	::CloseHandle(hthreadDebug);

	// close handles to events
	::CloseHandle(hTargetSuccess);
	::CloseHandle(hTargetFail);

	return (dwWaitResult == WAIT_OBJECT_0);
}

BOOL CTarget::Exit(void)
{
	const char* const THIS_FUNCTION = "CTarget::Exit";
	// wait for the target to exit (or 5 minutes)
	if(m_psettingsTarget->GetBooleanValue(settingClose))
	{ //REVIEW(chriskoz) we rely on the settingClose be correct 
	//we do not terminate event handler (settingClose never be false when the target really shuts down) 
		if(::WaitForSingleObject(m_procinfoTarget.hProcess, 5*60000) == WAIT_TIMEOUT)
		{
			// if we are persisting the target between subsuites, we only want to exit the target after the last subsuite.
			if(!gbPersistTarget || gbLastSubSuite)
			{
				char acBuf[255];
				sprintf(acBuf, "Time out waiting for target (%s) to shut down. Process id:%x still in memory.", (LPCSTR)GetFileName(), m_procinfoTarget.dwProcessId);
				m_pLog->RecordFailure(acBuf);
				APPLOG(acBuf);
				// clear the process information
				m_procinfoTarget.hProcess = 0;
				m_procinfoTarget.hThread = 0;
				m_procinfoTarget.dwProcessId = 0;
				m_procinfoTarget.dwThreadId = 0;
			}
		}
		//Terminate the Event handler thread explicitly (don't rely on it to shut down itself
		//I think we don't need to terminate the Debug thread as it shuts down itself when the Target thread is gone
		if (m_hTerminate && m_hEventThread)
		{
			::SetEvent(m_hTerminate);
			if(WaitForSingleObject(m_hEventThread, 2000) != WAIT_OBJECT_0) {
				TRACE("%s: unable to terminate event thread (%lx) by request; forcing termination\n", THIS_FUNCTION, m_hEventThread);
				TerminateThread(m_hEventThread, DWORD(-1));
			}
			::CloseHandle(m_hEventThread);
			m_hEventThread=NULL;
			ResetEvent(m_hTerminate); //reuse the event if target is launched once again
		}
	}
	return TRUE;
}

BOOL CTarget::ApplySettings(CSettings* pSettings)
{
	// launch as a debug process
	m_psettingsTarget->SetBooleanValue(settingDebugProcess, pSettings->GetBooleanValue(settingDebugProcess, m_psettingsTarget->GetBooleanValue(settingDebugProcess)));

	return TRUE;
}

BOOL CTarget::SetEnvironmentVar(LPCSTR pszEnvVar, LPCSTR pszValue)
{
	CString strEnvVar = pszEnvVar;

	// upper case the variable name
	strEnvVar.MakeUpper();
	m_mapEnv.SetAt(strEnvVar, pszValue);
	return TRUE;
}

CString CTarget::GetPath(void)
{
	return m_strPath;
}

CString CTarget::GetFileName(void)
{
	return m_strFileName;
}

BOOL CTarget::InitEnv(void)
{
	// default set of environment vars
	LPCSTR aszEnvVars[] = { "ComSpec", "Include", "Lib", "OS", "Path", "PROCESSOR_ARCHITECTURE", "PROCESSOR_LEVEL", "Source", "SystemRoot", "SystemDrive", "windir", "TMP", NULL };
	const ccBuf = 1024;
	char acValue[ccBuf];
	DWORD dwResult;

	// fill in the environment vars map
	for (int i = 0; aszEnvVars[i] != NULL; i++) {
		// get the env var's value
		dwResult = ::GetEnvironmentVariable(aszEnvVars[i], acValue, ccBuf);
		if (dwResult > 0 && dwResult <= ccBuf) {
			// set the env var's value in the map
			SetEnvironmentVar(aszEnvVars[i], acValue);
		}
		else if(strcmp(aszEnvVars[i],"PROCESSOR_ARCHITECTURE")==0)
			SetEnvironmentVar(aszEnvVars[i], "x86");
		else
		{
			
			if (dwResult == 0) {
				TRACE("Environment variable (%s) not defined.", aszEnvVars[i]);
			}
			else {
				TRACE("Error getting value for environment variable (%s): the buffer is too small.", aszEnvVars[i]);
			}
		}
	}

	// add the current directory for each drive (=X:=current dir)
	char acDrives[ccBuf];
	LPCSTR pcDrive = acDrives;
	char acDrive[] = "=X:";

	// get the list of drives
	dwResult = ::GetLogicalDriveStrings(ccBuf, acDrives);
	if (dwResult > 0 && dwResult <= ccBuf) {
		// iterate through each drive
		while (pcDrive[0]) {
			// copy the drive letter
			acDrive[1] = pcDrive[0];
			// get the value for this drive
			dwResult = ::GetEnvironmentVariable(acDrive, acValue, ccBuf);
			if (dwResult > 0 && dwResult <= ccBuf) {
				// set this drive's value in the map
				SetEnvironmentVar(acDrive, acValue);
			}
			else {
				if (dwResult == 0) {
					TRACE("Drive (%s) not defined.", acDrive);
				}
				else {
					TRACE("Error getting value for drive (%s): the buffer is too small.", acDrive);
				}
			}
			// move to the next drive
			pcDrive += strlen(pcDrive) + 1;
		}
	}
	else {
		if (dwResult == 0) {
			TRACE("Error getting the list of logical drives (%d).", ::GetLastError());
		}
		else {
			TRACE("Error getting the list of logical drives: the buffer's too small.");
		}
	}
	return TRUE;
}


CString CTarget::GetFullCmdLine(void)
{
	m_strLastCmdLine = GetPath() + GetFileName() + " " + m_psettingsTarget->GetTextValue(settingCmdLine);

	return m_strLastCmdLine;
}

CString CTarget::GetEnvBlock(void)
{
	CStringList listEnvVars;
	CString strVar;
	CString strValue;
	CString strEnvVar;
	CString strCur;
	POSITION posMap;
	POSITION posList;
	POSITION posCur;
	BOOL bInserted;


	// iterate through all env vars in the map and sort them
	for (posMap = m_mapEnv.GetStartPosition(); posMap != NULL; ) {
		m_mapEnv.GetNextAssoc(posMap, strVar, strValue);
		// build the environment var string (envvar=value)
		strEnvVar = strVar + "=" + strValue;
		// insert it into the list
		// find its sorted position
		bInserted = FALSE;
		for (posList = listEnvVars.GetHeadPosition(); posList != NULL; ) {
			posCur = posList;
			strCur = listEnvVars.GetNext(posList);
			// does this env var belong before the current env var?
			if (strEnvVar < strCur) {
				listEnvVars.InsertBefore(posCur, strEnvVar);
				bInserted = TRUE;
				break;
			}
		}
		// if the env var was inserted, add it to the end of the list
		if (!bInserted) {
			listEnvVars.AddTail(strEnvVar);
		}
	}

	APPLOG("Using the following environment for target (%s):", (LPCSTR)GetFileName());

	CString strEnvBlock;
	char* pEnvBlockStart;
	char* pEnvBlock;

	// get a pointer to a large buffer for the environment
	pEnvBlockStart = strEnvBlock.GetBuffer(10000);
	pEnvBlock = pEnvBlockStart;

	// iterate through the list of sorted environment variables
	for (posList = listEnvVars.GetHeadPosition(); posList != NULL; ) {
		strEnvVar = listEnvVars.GetNext(posList);
		// add the env var to the block
		pEnvBlock = strcpy(pEnvBlock, strEnvVar);
		pEnvBlock += strEnvVar.GetLength() + 1;
		APPLOG("    %s", strEnvVar);
	}

	// add final \0
	pEnvBlock = strncpy(pEnvBlock, "\0", 1);
	pEnvBlock += 1;

	strEnvBlock.ReleaseBuffer(pEnvBlock - pEnvBlockStart);

	return strEnvBlock;
}

UINT CTarget::WrapLaunchTarget(LPVOID pParam)  // static member
{

	TRACE1("WrapLaunchTarget: Starting thread 0x%X\n", GetCurrentThreadId());
	DWORD ret=((CTarget*)pParam)->LaunchTarget();
	TRACE1("WrapLaunchTarget: Exiting thread 0x%X\n",GetCurrentThreadId());
	return ret;
}


// BEGIN_HELP_COMMENT
// Function: HWND CTarget::LaunchTarget() 
// Description: The target thread procedure. Runs the Debug events loop if we attach to the target as debugger. Otherwise returns immediately after having launched the target.
// Return: dtr_success: if target launched successfully.
// END_HELP_COMMENT
UINT CTarget::LaunchTarget(void)
{
	HANDLE hTerminate;
	HANDLE hTargetSuccess;
	HANDLE hTargetFail;

	CString strCmdLine;
	CString strEnv;
	CString strWorkDir;

	DWORD dwCreate;

	BOOL bProcess;

	UINT nResult;

	// open the termination event
	hTerminate = ::OpenEvent(EVENT_ALL_ACCESS, FALSE, eventTerminate + GetUniqueName());

	// the handle must be valid
	ASSERT(hTerminate);
	if (!hTerminate) {
		TRACE("CTarget::LaunchTarget: unable to open the terminate event\n");
		return dtr_invalidevent;
	}

	// open the events for launch success/fail
	hTargetSuccess = ::OpenEvent(EVENT_ALL_ACCESS, FALSE, eventTargetSuccess + GetUniqueName());
	hTargetFail = ::OpenEvent(EVENT_ALL_ACCESS, FALSE, eventTargetFail + GetUniqueName());

	// the handles must valid
	ASSERT(hTargetSuccess && hTargetFail);
	if (!hTargetSuccess || !hTargetFail) {
		TRACE("CTarget::LaunchTarget: unable to open the launch event(s)\n");
		::CloseHandle(hTerminate);
		return dtr_invalidevent;
	}

	// launch the target

	// get the target's full command line (path\filename params)
	strCmdLine = GetFullCmdLine();
	// an empty command line means the target wasn't found
	if (strCmdLine.IsEmpty()) {
		return dtr_exenotfound;
	}

	// get the target's environment
	strEnv = GetEnvBlock();

	// get the target's working directory
	strWorkDir = GetSettings()->GetTextValue(settingWorkingDir);

	// determine creation flags for CreateProcess
	dwCreate = NORMAL_PRIORITY_CLASS | (GetSettings()->GetBooleanValue(settingDebugProcess) ? DEBUG_ONLY_THIS_PROCESS : 0);

  // create the process
  // bProcess = CreateTargetProcess(strCmdLine, dwCreate, strEnv, strWorkDir);
  bProcess = CreateTargetProcess(strCmdLine, dwCreate, NULL, strWorkDir);

	// based on the success of CreateProcess(), set an event to indicate the
	// target's starting or not starting
	if (bProcess) {
		// set event to indicate launch successful
		::SetEvent(hTargetSuccess);
		
		// handle the debug events if we're debugging
		if (GetSettings()->GetBooleanValue(settingDebugProcess)) {
			HandleDebugEvents();
		}

		nResult = dtr_success;
	}
	else {
		// set event to indicate launch not successful
		::SetEvent(hTargetFail);

		nResult = dtr_invalidexe;
	}

	// close handles
	::CloseHandle(hTargetFail);
	::CloseHandle(hTargetSuccess);
	::CloseHandle(hTerminate);

	return nResult;
}


UINT CTarget::WrapAttachTarget(LPVOID pParam)  // static member
{
	TRACE1("WrapAttachTarget: Starting thread 0x%X\n", GetCurrentThreadId());
	DWORD ret=((CTarget*)pParam)->AttachTarget();
	TRACE1("WrapAttachTarget: Exiting thread 0x%X\n",GetCurrentThreadId());
	return ret;
}


// BEGIN_HELP_COMMENT
// Function: HWND CTarget::AttachTarget() 
// Description: The target thread procedure. Runs the Debug events loop if we attach to the target as debugger. Otherwise returns immediately after having attached to the target.
// Return: dtr_success: if target Attached.
// END_HELP_COMMENT
UINT CTarget::AttachTarget(void)
{
	HANDLE hTerminate;
	HANDLE hTargetSuccess;
	HANDLE hTargetFail;

	UINT nResult;

	// open the termination event
	hTerminate = ::OpenEvent(EVENT_ALL_ACCESS, FALSE, eventTerminate + GetUniqueName());

	// the handle must be valid
	ASSERT(hTerminate);
	if (!hTerminate) {
		TRACE("CTarget::AttachTarget: unable to open the terminate event\n");
		return dtr_invalidevent;
	}

	// open the events for launch success/fail
	hTargetSuccess = ::OpenEvent(EVENT_ALL_ACCESS, FALSE, eventTargetSuccess + GetUniqueName());
	hTargetFail = ::OpenEvent(EVENT_ALL_ACCESS, FALSE, eventTargetFail + GetUniqueName());

	// the handles must valid
	ASSERT(hTargetSuccess && hTargetFail);
	if (!hTargetSuccess || !hTargetFail) {
		TRACE("CTarget::AttachTarget: unable to open the launch event(s)\n");
		::CloseHandle(hTerminate);
		return dtr_invalidevent;
	}


	// are we debugging the target application?
	if (GetSettings()->GetBooleanValue(settingDebugProcess)) {

		// attach to the target application as a debugger by calling DebugActiveProcess
		if (::DebugActiveProcess(m_procinfoTarget.dwProcessId)) {

			// set event to indicate attach successful
			::SetEvent(hTargetSuccess);
	
			// handle the debug events
			HandleDebugEvents();

			nResult = dtr_success;
		}
		else {
			// set event to indicate attach failed
			::SetEvent(hTargetFail);

			nResult = dtr_exenotfound;
		}
	}
	else {
		::SetEvent(hTargetSuccess);

		nResult = dtr_success;
	}

	// close handles
	::CloseHandle(hTargetFail);
	::CloseHandle(hTargetSuccess);
	::CloseHandle(hTerminate);

	return nResult;
}


UINT CTarget::WrapEventHandler(LPVOID pParam)  // static member
{
	TRACE1("WrapEventHandler: Starting thread 0x%X\n", GetCurrentThreadId());
	DWORD ret=((CTarget*)pParam)->EventHandler();
	TRACE1("WrapEventHandler: Exiting thread 0x%X\n",GetCurrentThreadId());
	return ret;
}




//REVIEW(chriskoz) these are ugly ESDed globals but it's just a proof of concept.
//After everything is smoothed out, they should endup as members of CTarget
#define MAX_CLASS 256
#define MAX_TITLE 256

void CTarget::SetHandleMsgTitle(CString &title)
{
	for(int i=0;i<m_nWndtoHandle;i++)
		if(m_HandleMsgTitles[i]==title)
			return;
	ASSERT(m_nWndtoHandle<5);//arbitrary number, maybe increased
	if(m_nWndtoHandle>=5)return;
	m_HandleMsgTitles[m_nWndtoHandle]=title;
	m_nWndtoHandle++; //I don't think the thread safety is an issue here
}



// BEGIN_HELP_COMMENT
// Function: HWND CTarget::FindAssertText() 
// Description: CALLBACK function: searches for the text inside the ASSERTION dialog
// Return: FALSE: found 
// END_HELP_COMMENT
BOOL CALLBACK CTarget::FindAssertText(HWND hAssert, CTarget *_this) //static function
{
	CHAR szClassName[MAX_CLASS];
	CHAR szTitleName[MAX_TITLE];
	memset(szTitleName, 0, sizeof(szTitleName)); //NULL the title
	::GetWindowText(hAssert, szTitleName, MAX_TITLE-1);
	::GetClassName(hAssert, szClassName, MAX_CLASS);
	if(strstr(szTitleName, _this->m_AssertionMsgText)==szTitleName)
	{
		_this->m_AssertionMsgText= //REVIEW(chriskoz) I think the thread sefety issue does not apply here
			szTitleName+_this->m_AssertionMsgText.GetLength(); //skip the known part of the text
		return FALSE; //found
	}
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: HWND CTarget::FindExceptionText() 
// Description: CALLBACK function: searches for the text inside the EXCEPTION dialog
// Return: FALSE: found 
// END_HELP_COMMENT
BOOL CALLBACK CTarget::FindExceptionText(HWND hAssert, char buffer[MAX_TITLE]) //static function
{
	CHAR szClassName[MAX_CLASS];
	CHAR szTitleName[MAX_TITLE];
	memset(szTitleName, 0, sizeof(szTitleName)); //NULL the title
	::GetWindowText(hAssert, szTitleName, MAX_TITLE-1);
	::GetClassName(hAssert, szClassName, MAX_CLASS);
	if(strlen(szTitleName)>40 //what a shame! I think this strlength is accurate
	&& strcmp(szClassName,"Static")==0) //must be static text
	{
		strncpy(buffer, szTitleName, MAX_TITLE);
		return FALSE; //found
	}
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: HWND CTarget::FindMsgToHandle() 
// Description: CALLBACK function: searches enumerated windows in a search for ASSERTION dialog & other dialogs for be handled automatically
// Return: FALSE: ASSERTION found 
// END_HELP_COMMENT
BOOL CALLBACK CTarget::FindMsgToHandle(HWND hwnd, CTarget *_this) //static function
{
	CHAR szClassName[MAX_CLASS];
	CHAR szTitleName[MAX_TITLE];
	DWORD idThread,idProcess;
	BOOL isException=FALSE;
	idThread=::GetWindowThreadProcessId(hwnd, &idProcess);
	::GetClassName(hwnd, szClassName, MAX_CLASS);
	if(idProcess!=_this->m_procinfoTarget.dwProcessId)
	{//this window does not belong to our process
		if(!IsWindowVisible(hwnd))
			return TRUE; //saves lots of calls (and how about doing this on all windows?)
		if(strstr(szClassName,"#32770")==NULL)
			return TRUE;  //it's not an exception
		::GetWindowText(hwnd, szTitleName, MAX_TITLE);
		if(strstr(szTitleName, " - Application Error")!=NULL)//TODO make it into LOCALE
		{ //definitely found an exception window
	#if 0 //TODO: disabled this extra care right now, because the overall code appears to be too complicated & unstable. Requires more testing before it's enabled
			CString strTitle=szTitleName;
			strTitle.MakeLower();
			//TODO: so much confusion because of Debug/Non-debug differenciation here
			BOOL bIsDebug=_this->m_psettingsTarget->GetBooleanValue(settingDebugBuild);
			CString strmodule=_this->m_psettingsTarget->GetTextValue(bIsDebug?settingDebugFilename:settingFilename);
			strTitle.MakeLower();
			if(strTitle.Find(strmodule)!=-1)
	#endif
			{//found an EXCEPTION: stop enumeration
				_this->m_hAssert=hwnd;
				_this->m_AssertionMsgTitle = szTitleName; //TODO remove this hack when "- Application error" message ready
				return FALSE;
			}
		}
		return TRUE; //not a true EXCEPTION
	}
//we have the window belonging to our process
	::GetWindowText(hwnd, szTitleName, MAX_TITLE);
	if(strstr(szClassName,"#32770")!=NULL)
	{
		if(strcmp(szTitleName, _this->m_AssertionMsgTitle)==0)
		{ //found an ASSERTION: stop enumeration
			_this->m_hAssert=hwnd;
			return FALSE;
		}
	}
//automatically handle all dialogs to be handled by hitting ESC without stopping enumeration
if(_this->m_handlemsgs) //only in case when test thread does not want to handle them.
	for(int i=0; i<_this->m_nWndtoHandle; i++) //arbitrary number, maybe increased
	{
		if(strcmp(szTitleName, _this->m_HandleMsgTitles[i])==0) //REVIEW(chriskoz): do we need to allow partial match?
		{ //found Find Symbols dialog: dismiss it without any question
			SetForegroundWindow(hwnd);
			keybd_event(VK_ESCAPE, 0,0,0);
			keybd_event(VK_ESCAPE, 0,KEYEVENTF_KEYUP,0);
			_this->m_pLog->RecordInfo("Dialog '%s' detected. ESC-handled by default", szTitleName);
			break;
		}
	}
	return TRUE;	
}



// BEGIN_HELP_COMMENT
// Function: HWND CTarget::EventHandler() 
// Description: Events thread. Runs the loop which handles unexpected dialogs: ASSERTION & dialogs set by SetHandleMsgTitle(). Currently, it's implemented by polling all top-level windows every .5sec. When AAccessibility is avail, we can switch to it. 
// Return: 0 if thread exits clean (without TerminateThread() help from the driver).
// END_HELP_COMMENT
UINT CTarget::EventHandler(void)
{
	BOOL bClickIgnore = GetSettings()->GetBooleanValue(settingIgnoreASSERT);
	BOOL bBreak = GetSettings()->GetBooleanValue(settingBreakASSERT);

	// open the termination event
	HANDLE hTerminate = ::OpenEvent(EVENT_ALL_ACCESS, FALSE, eventTerminate + GetUniqueName());
	do{
		Sleep(500); //randomly selected value. Do we need to tune it?
		m_hAssert=NULL;
	
		//TODO: remove this hack when the storage for Exception is ready
		TCHAR szAssertTitle[MAX_TITLE];
		strncpy(szAssertTitle, m_AssertionMsgTitle, MAX_TITLE); //save the original text, to be changed by FindAssertText callback
		::EnumWindows((WNDENUMPROC)FindMsgToHandle, (LPARAM)this); //enum all windows as EnumChildWindows(m_UIMainFrame) does not return popup Dialogs
		if(m_hAssert)
		{
			if(strcmp(szAssertTitle, m_AssertionMsgTitle)==0)
				HandleAssertion(bClickIgnore, bBreak);
			else
			{//TODO: we pass an info about Exception in this whako way here
				HandleExceptionDlg(bClickIgnore, bBreak, m_AssertionMsgTitle);
				m_AssertionMsgTitle=szAssertTitle;//restore the original title
			}
		}
		if (::WaitForSingleObject(hTerminate, 0) == WAIT_OBJECT_0)
		{ //main thread setup the terminate event
			CloseHandle(hTerminate);
			return 0;
		}
		if(m_procinfoTarget.hProcess &&
			::WaitForSingleObject(m_procinfoTarget.hProcess, 0) == WAIT_OBJECT_0)
		{ //the target process exited unexpectedly
			CloseHandle(hTerminate);
			return 0;
		}
	}while(1);
}


// BEGIN_HELP_COMMENT
// Function: HWND CTarget::HandleAssertion() 
// Description: Logs the ASSERTION data & handles the ASSETION dialog according to the user settings. Suspends the test thread while handling the ASSERTION
// Param: bClickIgnore - handle by clicking "Ignore"
// Param: bBreak - suspend the test run & display the modal message about assertion
// Return: void
// END_HELP_COMMENT
void CTarget::HandleAssertion(BOOL bClickIgnore, BOOL bBreak)
{
	DWORD dsuspendcount=0xFFFFFFFF;
	if(m_hTestthread)
	{
		dsuspendcount=::SuspendThread(m_hTestthread);
		TRACE1("Suspend test thread returned: %d\n", dsuspendcount);
	}
	TCHAR szAssertText[MAX_TITLE];
	strncpy(szAssertText, m_AssertionMsgText, MAX_TITLE); //save the original text, to be changed by FindAssertText callback
	::EnumChildWindows(m_hAssert, (WNDENUMPROC)FindAssertText, (LPARAM)this); //sets the text
	m_pLog->RecordFailure("ASSERTION dialog detected: %s",
		m_AssertionMsgText);
	if(bBreak)
	{
		char messageText[512];
		sprintf(messageText,"Test [***FAILED***]:\nProcess (%d) hit an unexpected assertion:\n", m_procinfoTarget.dwProcessId);
		strcat(messageText, m_AssertionMsgText);
		if(bClickIgnore)
			strcat(messageText, "\nDialog will be handled by clicking Ignore.\n");
		else
			strcat(messageText, "\nDialog will not be handled!!!\n");
		strcat(messageText, "Continue the test?");
		::MessageBox(NULL, messageText, AfxGetAppName(), MB_ICONWARNING|MB_TOPMOST|MB_YESNO);
	}
	m_AssertionMsgText=szAssertText; //REVIEW(chriskoz) I think the thread sefety issue does not apply here
	if(bClickIgnore && ::IsWindow(m_hAssert)) //make sure the ASSERT window is still there
	{
		SetForegroundWindow(m_hAssert);
		keybd_event(VK_MENU, 0,0,0);
		keybd_event(LOBYTE(VkKeyScan('i')), 0,0,0);
		keybd_event(LOBYTE(VkKeyScan('i')), 0,KEYEVENTF_KEYUP,0);
		keybd_event(VK_MENU, 0,KEYEVENTF_KEYUP,0);
		Sleep(500); //randomly selected value. Do we need to tune it?
	}
	if(m_hTestthread && dsuspendcount!=0xFFFFFFFF)
	{
		dsuspendcount=::ResumeThread(m_hTestthread);
		TRACE1("Resume test thread returned: %d\n", dsuspendcount);
	}
}

// BEGIN_HELP_COMMENT
// Function: HWND CTarget::HandleExceptionDlg() 
// Description: Logs the EXCEPTION data & handles the EXECPTION dialog according to the user settings. Suspends the test thread while handling the EXCEPTION
// Param: bIgnore - do not handle: just let it run
// Param: bBreak - suspend the test run & display the modal message about exception
// Param: msgTilte - if != NULL - means the dialog is valid, else: no dialog (the exception was caught by CAFE running as a debugger
// Return: void
// END_HELP_COMMENT
void CTarget::HandleExceptionDlg(BOOL bIgnore, BOOL bBreak, LPCSTR msgTitle)
{
	DWORD dsuspendcount=0xFFFFFFFF;
	if(m_hTestthread)
	{
		dsuspendcount=::SuspendThread(m_hTestthread);
		TRACE1("Suspend test thread returned: %d\n", dsuspendcount);
	}
	if(msgTitle  && m_EnableExceptionMessageHandling)
	{ //called when EXCEPTION window is displayed
		TCHAR szExceptText[MAX_TITLE];
		::EnumChildWindows(m_hAssert, (WNDENUMPROC)FindExceptionText, (LPARAM)szExceptText); //sets the text
		m_pLog->RecordFailure("EXCEPTION dialog detected: %s",
			szExceptText);
		if(bBreak)
		{
			char messageText[512];
			sprintf(messageText,"Test [***FAILED***]:\nException dialog detected:\n%s\n%s",
				msgTitle, szExceptText);
			if(!bIgnore)
				strcat(messageText, "\nDialog will be handled by clicking Enter.\n");
			else
				strcat(messageText, "\nDialog will not be handled!!!\n");
			strcat(messageText, "Continue the test?");
			::MessageBox(NULL, messageText, AfxGetAppName(), MB_ICONWARNING|MB_TOPMOST|MB_YESNO);
		}
		if(!bIgnore && ::IsWindow(m_hAssert)) //make sure the ASSERT window is still there
		{
			SetForegroundWindow(m_hAssert);
			keybd_event(VK_RETURN, 0,0,0);
			keybd_event(VK_RETURN, 0,KEYEVENTF_KEYUP,0);
			Sleep(500); //randomly selected value. Do we need to tune it?
		}
	}
	else
	{ //called when no window is displayed
		//TODO fill this later
	}
	if(m_hTestthread && dsuspendcount!=0xFFFFFFFF)
	{
		dsuspendcount=::ResumeThread(m_hTestthread);
		TRACE1("Resume test thread returned: %d\n", dsuspendcount);
	}
}



BOOL CTarget::InitializeSettings(void)
{
	BOOL bResult = TRUE;

	// initialize general default settings
	// filename
	m_psettingsTarget->SetTextValue(settingFilename, "filename");
	// cmd line
	m_psettingsTarget->SetTextValue(settingCmdLine, "cmd line");
	// working dir
	m_psettingsTarget->SetTextValue(settingWorkingDir, ".");
	// launch as debug process
	m_psettingsTarget->SetBooleanValue(settingDebugProcess, TRUE);

	return bResult;
}

CString CTarget::GetThreadResult(HANDLE hThread)
{
	DWORD dwThreadResult;
	CString strMsg;

	// wait for the debug thread to terminate
	::WaitForSingleObject(hThread, INFINITE);

	// get the exit code from the thread
	if (!::GetExitCodeThread(hThread, &dwThreadResult)) {
		TRACE("CTarget::GetDebugThreadResult: unable to retrieve thread's exit code, error: %d\n", ::GetLastError());
	}

	// prepare message based on termination value
	switch ((DebugThreadResult)dwThreadResult) {
		case dtr_success : {
			strMsg.Empty();
			break;
		}
		case dtr_invalidevent : {
			strMsg.Format("Unable to create thread to launch target (%s).", (LPCTSTR)GetFileName());
			break;
		}
		case dtr_exenotfound : {
			strMsg.Format("Unable to find target (%s) on path.", (LPCTSTR)GetFileName());
			break;
		}
		case dtr_invalidexe : {
			strMsg.Format("Invalid EXE (%s).", (LPCTSTR)GetFileName());
			break;
		}
		default : {
			strMsg.Format("Unknown failure launching target (%s).", (LPCTSTR)GetFileName());
			break;
		}
	}

	return strMsg;
}

CString CTarget::GetUniqueName(void)
{
	CString strName;

	strName.Format("Target %d", m_nId);

	return strName;
}

BOOL CTarget::SetLog(CLog* pLog)
{
	// the log shouldn't be set to NULL
	ASSERT(pLog);

	// set the target's log
	m_pLog = pLog;

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CTarget debug event handlers

#if defined(_M_MRX000)
CArray<HANDLE, HANDLE> tid_handle;
#endif

void CTarget::HandleDebugEvents(void)
{
	DEBUG_EVENT DebugEvent;
	DWORD dwContinue;
	HANDLE hTerminate;

	// open the termination event
	hTerminate = ::OpenEvent(EVENT_ALL_ACCESS, FALSE, eventTerminate + GetUniqueName());

	// the handle must be valid
	ASSERT(hTerminate);
	if (!hTerminate) {
		TRACE("CTarget::HandleDebugEvent: unable to open the terminate event\n");
		return;
	}

#if defined(_M_MRX000)
	tid_handle.RemoveAll();
#endif
	do {
		// handle any debug events that are waiting
		if (::WaitForDebugEvent(&DebugEvent, 1000)) {

			// handle the debug event
			switch(DebugEvent.dwDebugEventCode)
			{
				case EXCEPTION_DEBUG_EVENT:
					dwContinue = HandleException(DebugEvent);
					break;
				case CREATE_THREAD_DEBUG_EVENT:
					dwContinue = HandleCreateThread(DebugEvent);
					break;
				case CREATE_PROCESS_DEBUG_EVENT:
					dwContinue = HandleCreateProcess(DebugEvent);
					break;
				case EXIT_THREAD_DEBUG_EVENT:
					dwContinue = HandleExitThread(DebugEvent);
					break;
				case EXIT_PROCESS_DEBUG_EVENT:
					dwContinue = HandleExitProcess(DebugEvent);
					break;
				case LOAD_DLL_DEBUG_EVENT:
					dwContinue = HandleLoadDLL(DebugEvent);
					break;
				case UNLOAD_DLL_DEBUG_EVENT:
					dwContinue = HandleUnloadDLL(DebugEvent);
					break;
				case OUTPUT_DEBUG_STRING_EVENT:
					dwContinue = HandleOutputDebugString(DebugEvent);
					break;
				case RIP_EVENT:
					dwContinue = HandleRIP(DebugEvent);
					break;
			}
			VERIFY(::ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, dwContinue));
		}
		else {
			if (::WaitForSingleObject(hTerminate, 0) == WAIT_OBJECT_0) {
				::CloseHandle(hTerminate);
				return;
			}
		}
	}
	// if the process being debugged exits, we should exit
	while (!(DebugEvent.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT && DebugEvent.dwProcessId == m_procinfoTarget.dwProcessId));

	// close handles
	::CloseHandle(hTerminate);
}

DWORD CTarget::HandleException(const DEBUG_EVENT& DebugEvent)
{
	// apparently there is a breakpoint exception that is thrown when a process (just the IDE?)
	// starts up. We need to ignore this exception the first time. (m_bInitProcess == TRUE the first time.)

	// is it a breakpoint exception?
	if(DebugEvent.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_BREAKPOINT && m_bInitProcess) {
		m_bInitProcess = FALSE;

#if defined(_M_MRX000)
		HANDLE hThread;
		DWORD idx = DebugEvent.dwThreadId;
		if (INVALID_HANDLE_VALUE != (hThread = tid_handle[idx])) {
			CONTEXT ctx;
			ctx.ContextFlags = CONTEXT_CONTROL;
			if (!GetThreadContext(hThread, &ctx)) {
				return(DBG_EXCEPTION_NOT_HANDLED);
			}
			ctx.Fir += 4; // skip over breakpoint
			if (!SetThreadContext(hThread, &ctx)) {
				return(DBG_EXCEPTION_NOT_HANDLED);
			}
		}
#endif

		// we handled this special case exception
		return DBG_CONTINUE;
	}
	// is it a second chance exception?
	else if (DebugEvent.u.Exception.dwFirstChance == 0) {
		// we got an exception
		// generate a description
		char acBuf[255];
		sprintf(acBuf, "Detected an exception (%s) in process (0x%X) at address (0x%X).",
			GetExceptionDescription(DebugEvent.u.Exception.ExceptionRecord.ExceptionCode),
			DebugEvent.dwProcessId, DebugEvent.u.Exception.ExceptionRecord.ExceptionAddress);
		// log the exception
		m_pLog->RecordFailure(acBuf);
		
		BOOL bIgnore = GetSettings()->GetBooleanValue(settingIgnoreASSERT);
		BOOL bBreak = GetSettings()->GetBooleanValue(settingBreakASSERT);
		if(!bIgnore && bBreak)
		{
			strcat(acBuf, "Attach the JIT debugger?");
			::MessageBox(NULL, acBuf, AfxGetAppName(), MB_ICONWARNING|MB_TOPMOST|MB_YESNO);
		}

		APPLOG(acBuf);
		return DBG_EXCEPTION_NOT_HANDLED;
	}

	// by default we don't handle exceptions
	return DBG_EXCEPTION_NOT_HANDLED;
}

DWORD CTarget::HandleCreateThread(const DEBUG_EVENT& DebugEvent)
{
#if defined(_M_MRX000)
	tid_handle.SetAtGrow(DebugEvent.dwThreadId, DebugEvent.u.CreateThread.hThread);
#else
	UNREFERENCED_PARAMETER(DebugEvent);
#endif
	return DBG_CONTINUE;

}

DWORD CTarget::HandleCreateProcess(const DEBUG_EVENT& DebugEvent)
{
	// no memory leaks detected yet
	m_nLeaks = 0;

	// apparently there is a breakpoint exception that is thrown when a process (just the IDE?)
	// starts up. We need to ignore this exception the first time.
	m_bInitProcess = TRUE;

#if defined(_M_MRX000)
	tid_handle.SetAtGrow(DebugEvent.dwThreadId, DebugEvent.u.CreateProcessInfo.hThread);
#else
	UNREFERENCED_PARAMETER(DebugEvent);
#endif
	return DBG_CONTINUE;

}

DWORD CTarget::HandleExitThread(const DEBUG_EVENT& DebugEvent)
{
#if defined(_M_MRX000)
	tid_handle[DebugEvent.dwThreadId] = INVALID_HANDLE_VALUE;
#else
	UNREFERENCED_PARAMETER(DebugEvent);
#endif
	return DBG_CONTINUE;
}

DWORD CTarget::HandleExitProcess(const DEBUG_EVENT& DebugEvent)
{
	return DBG_CONTINUE;

	UNREFERENCED_PARAMETER(DebugEvent);
}

DWORD CTarget::HandleLoadDLL(const DEBUG_EVENT& DebugEvent)
{
	return DBG_CONTINUE;

	UNREFERENCED_PARAMETER(DebugEvent);
}

DWORD CTarget::HandleUnloadDLL(const DEBUG_EVENT& DebugEvent)
{
	return DBG_CONTINUE;

	UNREFERENCED_PARAMETER(DebugEvent);
}

DWORD CTarget::HandleOutputDebugString(const DEBUG_EVENT& DebugEvent)
{
	static bLeakDump = FALSE;
	static LPCSTR szAssert = "Assertion Failed:";
	static LPCSTR szLeakBegin = "Dumping objects ->";
	static LPCSTR szLeakEnd = "Object dump complete";
	static const char cLeak1 = '{';
	static const char cLeak2 = '}';

	m_strDebugOutput += GetOutputDebugString(DebugEvent);

	// Wait till we get a full string.
	if (strchr(m_strDebugOutput, '\n') || strchr(m_strDebugOutput, '\r')) {

		char* psz = m_strDebugOutput.GetBuffer(m_strDebugOutput.GetLength());

		// If the debug string starts with "$CafeLog" and DebugOutput is turned
		// on, then log the message.
		if (m_pLog->GetLogDebugOutput() && strstr(psz, "$CafeLog") == 0) {
			// Strip off any trailing newlines.
			char* p;
			if (p = strchr(psz, '\n'))
				*p = '\0';

			if (p = strchr(psz, '\r'))
				*p = '\0';

			m_pLog->RecordInfo("DbgMsg - %s", psz);
		}

		m_strDebugOutput.ReleaseBuffer();

		char acBuf[1024];

		// dump memory leaks
		if (bLeakDump) {
			// when bLeakDump is set, dump string until terminating line.
			if (strncmp(m_strDebugOutput, szLeakEnd, sizeof(szLeakEnd) - 1) == 0) {
				// generate a message for the end of the memory leaks
				sprintf(acBuf, "Detected %d memory leaks in the application.", m_nLeaks);
				// log the number of memory leaks
				m_pLog->RecordInfo(acBuf);
//				m_pLog->RecordInfo("View memory leaks in the application log (log toolbar button).");
				APPLOG(acBuf);
// log a failure if the number of leaks is greater than expected
// log an info if any leaks are detected but expected
// do not log anything if m_nExpectedLeaks == -1 (turned off)
				if (m_nExpectedLeaks != -1) {
					if (m_nLeaks > m_nExpectedLeaks) {
						m_pLog->RecordFailure("The number of memory leaks detected in the application (%d) is greater than the expected number of leaks (%d).", m_nLeaks, m_nExpectedLeaks);
					}
					else if (m_nLeaks < m_nExpectedLeaks) {
						m_pLog->RecordInfo("The number of memory leaks detected in the application (%d) is less than the expected number of leaks (%d).", m_nLeaks, m_nExpectedLeaks);
						m_pLog->RecordInfo("Please contact the sniff owner to adjust the expected number of memory leaks.");
					}
				}
				
				bLeakDump = FALSE;
			}
			else {
				// log the memory leak
				m_strDebugOutput.TrimRight();
				// Make "%" into "%%" for printf, only does the first one (bjoyce)
				m_strDebugOutput.Replace("%", "%%");
				m_pLog->RecordInfo((LPCSTR)m_strDebugOutput);
				APPLOG((LPCSTR)m_strDebugOutput);
				// each memory leak may take multiple lines:
				// each new leak contains a { followed by a } somewhere in the line
				int nLeak1 = m_strDebugOutput.Find(cLeak1);
				int nLeak2 = m_strDebugOutput.Find(cLeak2);
				if (nLeak1 < nLeak2) {
					m_nLeaks++;
				}
			}
		}
		// is this an assert?
		else if (strncmp(m_strDebugOutput, szAssert, sizeof(szAssert) - 1) == 0) {
			// generate a message to describe the assert
			sprintf(acBuf, "Detected an assert: %s.", (LPCSTR)m_strDebugOutput);
			// log the assert
			m_pLog->RecordFailure(acBuf);
			APPLOG(acBuf);

			// REVIEW(briancr): don't we need to clear the assert message box?
		}
		// is this the beginning of memory leaks?
		else if (strncmp(m_strDebugOutput, szLeakBegin, sizeof(szLeakBegin) - 1) == 0) {
			bLeakDump = TRUE;
			sprintf(acBuf, "Detected the following memory leaks:");
			m_pLog->RecordInfo(acBuf);
			APPLOG(acBuf);
		}

		m_strDebugOutput.Empty();
	}

	return DBG_CONTINUE;
}

DWORD CTarget::HandleRIP(const DEBUG_EVENT& DebugEvent)
{
	// generate a message for the RIP
	char acBuf[255];
	sprintf(acBuf, "Detected a RIP (%s) in process (0x%X) with error value (%d).",
		GetRIPDescription(DebugEvent.u.RipInfo.dwType),
		DebugEvent.dwProcessId, DebugEvent.u.RipInfo.dwError);
	m_pLog->RecordFailure(acBuf);
	APPLOG(acBuf);

	return DBG_CONTINUE;
}

LPCSTR CTarget::GetExceptionDescription(DWORD dwCode)
{
	switch (dwCode) {
// from WINBASE.H
		case EXCEPTION_DATATYPE_MISALIGNMENT:
			return "Datatype misalignment";
		case EXCEPTION_BREAKPOINT:
			return "Breakpoint";
		case EXCEPTION_SINGLE_STEP:
			return "Single step";
		case EXCEPTION_ACCESS_VIOLATION:
			return "Access violation";
		case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
			return "Array bound exceeded";
		case EXCEPTION_FLT_DENORMAL_OPERAND:
			return "Floating-point denormal operand";
		case EXCEPTION_FLT_DIVIDE_BY_ZERO:
			return "Floating-point divide by zero";
		case EXCEPTION_FLT_INEXACT_RESULT:
			return "Floating-point inexact result";
		case EXCEPTION_FLT_INVALID_OPERATION:
			return "Floating-point invalid operation";
		case EXCEPTION_FLT_OVERFLOW:
			return "Floating-point overflow";
		case EXCEPTION_FLT_STACK_CHECK:
			return "Floating-point stack check";
		case EXCEPTION_FLT_UNDERFLOW:
			return "Floating-point underflow";
		case EXCEPTION_INT_DIVIDE_BY_ZERO:
			return "Integer divide by zero";
		case EXCEPTION_INT_OVERFLOW:
			return "Integer overflow";
		case EXCEPTION_PRIV_INSTRUCTION:
			return "Privileged instruction";
		case EXCEPTION_NONCONTINUABLE_EXCEPTION:
			return "Noncontinuable Exception";
/*
// from NTSTATUS.H
		case STATUS_DLL_NOT_FOUND:
			return "DLL not found";
*/
		default:
			return "Unknown exception code";
	}
}

CString& CTarget::GetOutputDebugString(const DEBUG_EVENT& DebugEvent)
{
	static CString str;

	ASSERT(DebugEvent.dwDebugEventCode == OUTPUT_DEBUG_STRING_EVENT);

	const OUTPUT_DEBUG_STRING_INFO* pODSI = &DebugEvent.u.DebugString;
	LPSTR pch = str.GetBufferSetLength(pODSI->nDebugStringLength + 1);
	DWORD dwRead;

	HANDLE hProcess = OpenProcess(PROCESS_VM_READ, FALSE, DebugEvent.dwProcessId);
	if (!ReadProcessMemory( hProcess,					// process to read
							pODSI->lpDebugStringData,	// address to read at
							(LPVOID)pch,				// address to copy to
							pODSI->nDebugStringLength,	// bytes to copy
							&dwRead) 					// bytes actually read
			&& (dwRead > 0) ) {

//		WriteWarning("Problem retrieving OutputDebugString.  Partial read was: %s", pch);
	}
	else {
		if (pch[dwRead] != '\0') {
			pch[dwRead] = '\0';
		}
	}

	str.ReleaseBuffer(-1);

	return str;
}

LPCSTR CTarget::GetRIPDescription(DWORD dwType)
{
	switch (dwType)
	{
		case SLE_ERROR:
			return "Error";
		case SLE_MINORERROR:
			return "Minor error";
		case SLE_WARNING:
			return "Warning";
		default:
			return "0";
	}
}

// BEGIN_HELP_COMMENT
// Function: CString CTarget::GetVersion()
// Return: Returns a string that represents the version number of the target.
// END_HELP_COMMENT
CString CTarget::GetVersion()
{
	DWORD   dwVerInfoSize;
	DWORD   dwVerHnd;
  CString strVersion("Not Available");

	int nPos;
	CString strFullFileName;

	if ((nPos = m_strLastCmdLine.Find(".exe ")) != -1)
		strFullFileName = m_strLastCmdLine.Left(nPos+4);
	else
		strFullFileName = m_strLastCmdLine;

	dwVerInfoSize = GetFileVersionInfoSize((LPSTR)(LPCSTR)strFullFileName, &dwVerHnd);
	if (dwVerInfoSize)
	{
		// If we were able to get the information, process it:
		LPVOID  lpstrVffInfo;
		HANDLE  hMem;
		LPSTR   lpVersion = NULL;       
		UINT    uVersionLen = 0;
	
		hMem = GlobalAlloc(GMEM_MOVEABLE, dwVerInfoSize);
		lpstrVffInfo  = GlobalLock(hMem);
		GetFileVersionInfo((LPSTR)(LPCSTR)strFullFileName, dwVerHnd, dwVerInfoSize, lpstrVffInfo);

		//Todo (ScotF): This is a U.S. English specific query, will not work on Japanese IDE
		if(VerQueryValue(lpstrVffInfo, "\\StringFileInfo\\040904b0\\FileVersion", (LPVOID *)&lpVersion, (UINT *)&uVersionLen))
			strVersion = lpVersion;

		GlobalUnlock(hMem);
		GlobalFree(hMem);
	}

  return strVersion;
}

///////////////////////////////////////////////////////////////////////////////
//	DLL support

static AFX_EXTENSION_MODULE extensionDLL = { NULL, NULL };

extern "C" __declspec(dllexport) int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("Target DLL Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(extensionDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(extensionDLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("Target DLL Terminating!\n");
		// Terminate the library before destructors are called
		AfxTermExtensionModule(extensionDLL);

	}
	return 1;   // ok

	UNREFERENCED_PARAMETER(lpReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\BldTools\execman.cpp ===
/*
    EXECMAN.CPP

    Copyright 1995, Microsoft Corp.

    This file contains the implementation of the CExecutable class and its
    descendants.

    Edit history:
      1] CFlaat / 1-1-95 / created

*/


#include "stdafx.h"
#include "bldtools.h"
#include "execpage.h"

#define new DEBUG_NEW

BOOL CX86Executable::Execute(void)
{
  if (!Launch())
    return FALSE;

  return !GetExitCode();
}

BOOL CX86Executable::Initialize(CToolset::BUILD_TYPE nBuildType, CString strKey)
{
	// instantiate the property page for this target
	m_ppageTarget = new CX86ExecutablePage(m_psettingsTarget);

  return CExecutable::Initialize(nBuildType, strKey);
}

BOOL CExecutable::Initialize(CToolset::BUILD_TYPE nBuildType, CString strKey)
{
	// instantiate the settings object for this target
	strKey += "\\";
  strKey += "ExecManager";
	m_psettingsTarget = new CSettings(strKey);

	// initialize settings
	return InitializeSettings();
}

BOOL CExecutable::ApplySettings(CSettings* pSettings)
{
	// call the base class
	CConsoleTarget::ApplySettings(pSettings);

	// TODO(CFlaat): apply command line overrides

	return TRUE;
}


BOOL CExecutable::InitializeSettings(void)
{
	CString strDrive;
	CString strDir;

	BOOL bResult = TRUE;

	// call the base class
	bResult &= CConsoleTarget::InitializeSettings();

	// initialize  default settings
	m_psettingsTarget->SetTextValue(settingWorkingDir, "e:\\cafe\\v3\\sd2\\testdir");

#if 0  //TODO(CFlaat): figure out why this doesn't work!
	// load settings from the registry
	bResult &= m_psettingsTarget->ReadRegistry();
	// write the settings back out to initialize registry
	bResult &= m_psettingsTarget->WriteRegistry();
#endif

	return bResult;
}


void CExecutable::SetFileName(LPCSTR szExeFile)
{
  CString strDir;
	m_psettingsTarget->GetTextValue(settingWorkingDir, strDir);
	m_psettingsTarget->SetTextValue(settingFilename, strDir + szExeFile);

  m_strFileName = "e:\\cafe\\v3\\sd2\\testdir\\";
  m_strFileName += szExeFile;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\BldTools\comppage.h ===
// comppage.h : header file
//

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CCompilerDriverPage dialog

class CCompilerDriverPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CCompilerDriverPage)

// Construction
public:
	CCompilerDriverPage(CSettings* pSettings = NULL);
	~CCompilerDriverPage();

// Dialog Data
	//{{AFX_DATA(CCompilerDriverPage)
	enum { IDD = IDD_CompDrv };
	CString	m_strCmdLine;
	CString	m_strFilename;
	CString	m_strWorkDir;
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CCompilerDriverPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CCompilerDriverPage)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\BldTools\execpage.cpp ===
// comppage.cpp : implementation file
//

#include "stdafx.h"
#include "bldtools.h"
#include "execpage.h"

#define new DEBUG_NEW

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CX86ExecutablePage property page

IMPLEMENT_DYNCREATE(CX86ExecutablePage, CPropertyPage)

CX86ExecutablePage::CX86ExecutablePage(CSettings* pSettings /*= NULL*/) : CPropertyPage(CX86ExecutablePage::IDD)
{
	//{{AFX_DATA_INIT(CX86ExecutablePage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CX86ExecutablePage::~CX86ExecutablePage()
{
}

void CX86ExecutablePage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CX86ExecutablePage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CX86ExecutablePage, CPropertyPage)
	//{{AFX_MSG_MAP(CX86ExecutablePage)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CX86ExecutablePage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\BldTools\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by bldtools.rc
//
#define IDD_CompDrv                     102
#define IDD_Executable                  103
#define IDE_CompilerFilename            1001
#define IDE_CompilerCmdLine             1005
#define IDE_CompilerWorkDir             1006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\BldTools\stdafx.cpp ===
// for PCH creation

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\BldTools\execpage.h ===
// comppage.h : header file
//

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CX86ExecutablePage dialog

class CX86ExecutablePage : public CPropertyPage
{
	DECLARE_DYNCREATE(CX86ExecutablePage)

// Construction
public:
	CX86ExecutablePage(CSettings* pSettings = NULL);
	~CX86ExecutablePage();

// Dialog Data
	//{{AFX_DATA(CX86ExecutablePage)
	enum { IDD = IDD_Executable };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CX86ExecutablePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CX86ExecutablePage)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\BldTools\stdafx.h ===
// common include files for PCH

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\coclip.h ===
///////////////////////////////////////////////////////////////////////////////
//	COCLIP.H
//
//	Created by :			Date :
//		DavidGa					1/10/94
//
//	Description :
//		Declaration of the COClipboard component object class
//

#ifndef __COCLIP_H__
#define __COCLIP_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "guixprt.h"

///////////////////////////////////////////////////////////////////////////////
// COClipboard class

// BEGIN_CLASS_HELP
// ClassName: COClipboard
// BaseClass: none
// Category: General
// END_CLASS_HELP
class GUI_CLASS COClipboard
{
public:
	COClipboard();

// Data

// Attributes
public:
	CString GetText(void);

// Operations
public:
	BOOL Empty(void);
	BOOL SetText(LPCSTR szTextIn);
};

#endif //__COCLIP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\guitarg.cpp ===
/////////////////////////////////////////////////////////////////////////////
// guitargt.cpp
//
// email	date		change
// briancr	11/04/94	created
//
// copyright 1994 Microsoft

// Implementation of the CTarget class

#include "stdafx.h"
#include "afxdllx.h"
#include "applog.h"
#include "testxcpt.h"
#include "target.h"
#include "mstwrap.h"  // hack hack

//#include "toolset.h"
#include "guitarg.h"

#define new DEBUG_NEW

HANDLE g_hTargetProc;

/////////////////////////////////////////////////////////////////////////////
// CGUITarget

CGUITarget::CGUITarget(const CString &strTitle)
: m_hWnd(NULL), m_strTitle(strTitle)
{
}

CGUITarget::~CGUITarget()
{
	// if the GUI app is still around, exit it
	if (IsLaunched()) {
		Exit();
	}
}

BOOL CGUITarget::Launch(void)
{
	CString strMsg;
	int i;

	// does the user want to launch a new GUI or attach to an existing one
	if (m_psettingsTarget->GetBooleanValue(settingNewApp)) {
		// call the base class to launch
		CTarget::Launch();
		
		// wait for input idle in the GUI
		::WaitForInputIdle(m_procinfoTarget.hProcess, 120000);

		// find the window that matches the process id/handle
		m_hWnd = FindTarget(m_psettingsTarget->GetTextValue(settingWndClass), m_procinfoTarget.dwProcessId);

		// m_hWnd should be filled in at some point here
		if (!::IsWindow(m_hWnd)) {
			// throw exception: unable to successfully launch the target

			strMsg.Format("Unable to successfully launch target (%s).", (LPCTSTR)GetFileName());

			TRACE(strMsg);
			throw CTestException(strMsg, CTestException::causeOperationFail);
		}
	}
	else {
		// do the specific GUI attach work to get the HWND, and, from that, get the process handle and id
		Attach();
		// call the base class to do basic attach stuff, like start the debug event handler
		CTarget::Attach();
	}

	// the HWND must be a valid window
	ASSERT(::IsWindow(m_hWnd));

	// Attach the event handler   EventHandler
//	pEventHandler = new CEventHandler;
//	pEventHandler->Connect();

	// wait until the window is visible (up to twenty seconds)
	for (i = 0; i < 200; i++) {
			MST.DoKeys("{ESC}") ;
			if (::IsWindowVisible(m_hWnd)) {
						return TRUE;
		}
		Sleep(100);
	}

	// window never became visible: this is a critical error
	strMsg.Format("Timeout waiting for target's window to be visible (%s).", (LPCTSTR)GetFileName());
	throw CTestException(strMsg, CTestException::causeOperationFail);
	return FALSE;
}

BOOL CGUITarget::Attach(void)
{
	// find a suitable GUI target
	m_hWnd = FindTarget(m_psettingsTarget->GetTextValue(settingWndClass));

	// the HWND should be valid
	if (!::IsWindow(m_hWnd)) {
		// throw exception: unable to successfully attach to the target
		CString strMsg;

		strMsg.Format("Unable to successfully attach to target (%s).", (LPCTSTR)GetFileName());

		TRACE(strMsg);
		throw CTestException(strMsg, CTestException::causeOperationFail);
	}

	// get the target's process handle and id
	m_procinfoTarget.dwThreadId = ::GetWindowThreadProcessId(m_hWnd, &m_procinfoTarget.dwProcessId);
	m_procinfoTarget.hProcess = ::OpenProcess(PROCESS_ALL_ACCESS, FALSE, m_procinfoTarget.dwProcessId);
	m_procinfoTarget.hThread = 0; //TODO: is there a way to get the handle of dwThreadId?

	return TRUE;
}


// REVIEW(CFlaat): can this function be generalized to handle profiling?
BOOL CGUITarget::CreateTargetProcess(LPCSTR szCmdLine, DWORD dwCreationFlags, LPCSTR szEnvBlock, LPCSTR szWorkDir)
{
  BOOL bResult;

	static STARTUPINFO si = { sizeof(STARTUPINFO),	// size of this structure
							NULL,					// lpReserved
							NULL,					// lpDesktop
							NULL,					// lpTitle
							0, 0,					// dwX, dwY
							0, 0,					// dwXSize, dwYSize
							0, 0,					// dwXCountChars, dwYCountChars
							0,						// dwFillAttribute
							STARTF_USESHOWWINDOW,	// dwFlags
							SW_SHOWMAXIMIZED,		// wShowWindow
							0,						// cbReserved
							NULL,					// lpReserved
							0,						// hStdInput 
							0,						// hStdOutput
							0};						// hStdError

	// spawn the target application
	bResult = CreateProcess(NULL,
								(LPTSTR)szCmdLine,						// command line
								NULL,											// default security attributes of process
								NULL,											// default security attributes of thread
								FALSE,											// don't inherit handles
								dwCreationFlags,										// normal priority, and maybe debug
								(void*)szEnvBlock,						// environment variables
								szWorkDir,										// working directory
								&si,											// startup info
								&m_procinfoTarget);					// process info
	g_hTargetProc = m_procinfoTarget.hProcess;
	return bResult;
}



BOOL CGUITarget::Exit(void)
{
	// do we want to close the target on exit?
	if (m_psettingsTarget->GetBooleanValue(settingClose)) 
	{
		// if we are persisting the target between subsuites, we only want to exit the target after the last subsuite.
		if(!gbPersistTarget || gbLastSubSuite)
		{
			if (::IsWindow(m_hWnd))
			{
				// Disconnect the event handler EventHandler
				//pEventHandler->Disconnect();
				//delete pEventHandler;

				// send the close msg
				::SendMessage(m_hWnd, WM_CLOSE, 0, 0);
			}
		}
	}

	// call the base class
	return CTarget::Exit();
}

BOOL CGUITarget::IsActive(void)
{
	return ::IsWindow(m_hWnd);
}

HWND CGUITarget::FindTarget(CString strClass, DWORD dwProcessId /*= 0*/)
{
	HWND hwnd;
	DWORD dwId;
	CString strActualTitle;
	CString strActualClass;

    ASSERT(!m_strTitle.IsEmpty());

	// find a suitable target by iterating through all the currently running applications
	for (hwnd = ::GetTopWindow(NULL); hwnd != NULL; hwnd = ::GetNextWindow(hwnd, GW_HWNDNEXT)) {

		// get the window title
		::GetWindowText(hwnd, strActualTitle.GetBuffer(255), 255);
		strActualTitle.ReleaseBuffer();
		// get the window class
		::GetClassName(hwnd, strActualClass.GetBuffer(255), 255);
		strActualClass.ReleaseBuffer();
		// do the title and class match what's expected for the target
		// the title and class strings for the target are substrings of
		// what might be found for the entire title or class of the app
		if (strActualTitle.Find(m_strTitle) != -1 && strActualClass.Find(strClass) != -1) {
			// does the process id match?
			::GetWindowThreadProcessId(hwnd, &dwId);
			if (dwProcessId == 0 || dwProcessId == dwId) {
				return hwnd;
			}
		}
	}

	// no target found
	return NULL;
}

BOOL CGUITarget::ApplySettings(CSettings* pSettings)
{
	// call the base class
	CTarget::ApplySettings(pSettings);

	// launch new app
	m_psettingsTarget->SetBooleanValue(settingNewApp, pSettings->GetBooleanValue(settingNewApp, m_psettingsTarget->GetBooleanValue(settingNewApp)));

	// close after test run
	m_psettingsTarget->SetBooleanValue(settingClose, pSettings->GetBooleanValue(settingClose, m_psettingsTarget->GetBooleanValue(settingClose)));

	return TRUE;
}

BOOL CGUITarget::InitializeSettings(void)
{
	// call the base class
	CTarget::InitializeSettings();

	//ASSERTIONs handling
	m_psettingsTarget->SetBooleanValue(settingIgnoreASSERT, TRUE);
	m_psettingsTarget->SetBooleanValue(settingBreakASSERT, FALSE);

	// launch new app
	m_psettingsTarget->SetBooleanValue(settingNewApp, TRUE);

	// close after test run
	m_psettingsTarget->SetBooleanValue(settingClose, TRUE);

	// window class
	m_psettingsTarget->SetTextValue(settingWndClass, "Afx:");

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
//	DLL support

static AFX_EXTENSION_MODULE extensionDLL = { NULL, NULL };

extern "C" __declspec(dllexport) int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("GUI DLL Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(extensionDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(extensionDLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("GUI DLL Terminating!\n");
		// Terminate the library before destructors are called
		AfxTermExtensionModule(extensionDLL);
	}

	return 1;   // ok

	UNREFERENCED_PARAMETER(lpReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\imewrap.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	IMEWRAP.CPP
//
//	Created by :			Date :
//		DavidGa					3/1/94
//
//	Description :
//		Implementation of the CIME class
//

#include "stdafx.h"
#include "mstwrap.h"
#include "guiv1.h"
#include "testutil.h"
#include "imewrap.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// REVIEW(briancr): this object is declared as a global for backward compatibility
// REVIEW(briancr): this is just to make things work. Is there a better way to do this?
// instantiate a global CIME
GUI_DATA CIME IME;

// REVIEW(briancr): we should probably change all these IME functions to take
// a parameter that is the hwnd of the window we want to the settings/attributes
// to be for (instead of using ::GetForegroundWindow()).

/////////////////////////////////////////////////////////////////////////////
// CIME class

IMPLEMENT_DYNCREATE(CIME, CWnd)

BEGIN_MESSAGE_MAP(CIME, CWnd)
	//{{AFX_MSG_MAP(CIME)
	#ifdef OLD_IME_BEHAVIOR
	ON_WM_CREATE()
	#endif // OLD_IME_BEHAVIOR
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


CIME::CIME()
{
	m_hIME = GlobalAlloc (GMEM_MOVEABLE | GMEM_SHARE | GMEM_ZEROINIT, 
			(LONG)sizeof(IMESTRUCT));
	m_hNLSLibrary = LoadLibrary ("USER32.DLL");

	if( m_hNLSLibrary )
	{
		m_lpfnSendIMEMessage = (WORD (FAR WINAPI *)(HWND, LONG))GetProcAddress ((HINSTANCE)m_hNLSLibrary, "SendIMEMessageExA");
		m_lpfnEnableIME = (BOOL (FAR WINAPI *)(HWND, BOOL))GetProcAddress ((HINSTANCE)m_hNLSLibrary, "WINNLSEnableIME");
		m_lpfnGetEnableStatus = (BOOL (FAR WINAPI *)(HWND))GetProcAddress ((HINSTANCE)m_hNLSLibrary, "WINNLSGetEnableStatus");
	}
	else
	{
		GlobalFree(m_hIME);
		m_hIME = NULL;
	}
	IME_UseFlag = FALSE ;

	// determine if we are running on nt/j.
	if(m_bRunningOnNTJ = (GetSystem() & SYSTEM_NT) && (GetSystem() & SYSTEM_JAPAN))
		{	
		// register messages for communicating with the IDE'S IME on nt/j. 
		// see cafe\support\guitools\imehook.cpp - michma 1/1/97.
		m_msgIMESetOpen = RegisterWindowMessage("msgIMESetOpen");
		m_msgIMEGetOpen = RegisterWindowMessage("msgIMEGetOpen");
		m_msgIMESetMode = RegisterWindowMessage("msgIMESetMode");
		m_msgIMEGetMode = RegisterWindowMessage("msgIMEGetMode");
		}
}

CIME::~CIME()
{
}

/////////////////////////////////////////////////////////////////////////////
// CIME diagnostics

#ifdef _DEBUG
void CIME::AssertValid() const
{
	CWnd::AssertValid();
}

void CIME::Dump(CDumpContext& dc) const
{
	CWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CIME message handlers

#ifdef OLD_IME_BEHAVIOR

BOOL CIME::Create(void)
{
	return CWnd::CreateEx(
		WS_EX_DLGMODALFRAME,	// extended style
		AfxRegisterWndClass(CS_GLOBALCLASS),
		"IME Activator Wnd",	// window name
		WS_POPUPWINDOW | WS_VISIBLE,	// style
		50,0,		// window pos
		100, 20,	  //wnd size
		NULL,		// parent window,
		NULL,		// nlDorHMenu
		NULL		// lpPararm
	);
}

int CIME::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if( CWnd::OnCreate(lpCreateStruct) == -1 )
		return -1;
	CRect rcClient;
	GetClientRect( rcClient );
	m_editCtl.Create( WS_CHILD | WS_VISIBLE | ES_AUTOHSCROLL, rcClient, this, 0x0004);

	return 0;
}

#endif // OLD_IME_BEHAVIOR

//  IME Operations

// BEGIN_HELP_COMMENT
// Function: BOOL CIME::Enable(BOOL bEnable /*=TRUE*/)
// Description: Enable or disable the IME for input. The IME must be open to call this function (see CIME::Open).
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: bEnable A Boolean value that specifies whether the enable the IME (TRUE) or disable it. (Default value is TRUE.)
// END_HELP_COMMENT
BOOL CIME::Enable(BOOL bEnable /*=TRUE*/)		//REVIEW(EnriqueP): Do we need to switch focus to window?
{
	BOOL bRet = FALSE;
	IMEInUse(TRUE); // SET in use flag ;

	// REVIEW (michma): on nt/j we do not distinguish between the open status
	// and the enabled status of the IME because we use a different api (Imm functions)
	// which appear not to support the concept.
	// see cafe\support\guitools\imehook.cpp - michma 1/1/97.
	if(m_bRunningOnNTJ)
		{
		WaitStepInstructions("%s IME", bEnable ? "Enable" : "Disable");
		return TRUE;
		}

	if( m_lpfnEnableIME != NULL )
	{
		WaitStepInstructions("%s IME", bEnable ? "Enable" : "Disable");
		
		bRet = (*(m_lpfnEnableIME))(GetDumbWindow(), bEnable);
//		SwitchFocus();

		if( bEnable && !IsEnabled() )	// REVIEW: trying to disable and appearing to fail happens, but is harmless
		{
			Sleep(500);		// sleep half a second
			if( !IsEnabled() )
				LOG->RecordInfo("Unable to %s the IME", bEnable ? "Enable" : "Disable");
		}
	}
	else
		LOG->RecordInfo("No IME found.  Cannot use CIME functions");

	return bRet;
}

// BEGIN_HELP_COMMENT
// Function: BOOL CIME::IsEnabled(void)
// Description: Determine if the IME is enabled.
// Return: A Boolean value that indicates whether the IME is enabled (TRUE) or not.
// END_HELP_COMMENT
BOOL CIME::IsEnabled(void)		//REVIEW(EnriqueP): Do we need to switch focus to window?
{
	BOOL bRet = FALSE;

	// REVIEW (michma): on nt/j we do not distinguish between the open status
	// and the enabled status of the IME because we use a different api (Imm functions)
	// which appear not to support the concept.
	// see cafe\support\guitools\imehook.cpp - michma 1/1/97.
	if(m_bRunningOnNTJ)
		// CIME::IsOpen() on nt/j will return:
		//		-1 if the IME is open.
		//		 0 if the IME is closed.
		return (IsOpen() ? TRUE : FALSE);

	if( m_lpfnEnableIME != NULL )
	{
		#ifdef OLD_IME_BEHAVIOR
			bRet = (*(m_lpfnGetEnableStatus))(NULL);
		#else
			bRet = (*(m_lpfnGetEnableStatus))(GetDumbWindow());
		#endif // OLD_IME_BEHAVIOR
	}

	return bRet;
}

// Flag set when the IME is in use.

void CIME::IMEInUse(bool useFlag)
{
	if(useFlag)
	{
		IME_UseFlag = TRUE ;
	}
	else
		IME_UseFlag = FALSE ;

}
// BEGIN_HELP_COMMENT
// Function: BOOL CIME::Open(BOOL bOpen /*=TRUE*/)
// Description: Open or close the IME. The IME must be open before calling any other IME functions.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: bOpen A Boolean value that specifies whether to open the IME (TRUE) or close it. (Default value is TRUE.)
// END_HELP_COMMENT
BOOL CIME::Open(BOOL bOpen /*=TRUE*/)
{
	LPIMESTRUCT lpIME;
	LRESULT lres = FALSE;

	//ShowWindow(SW_SHOW);
	IMEInUse(TRUE); // SET in use flag ;

	#ifdef OLD_IME_BEHAVIOR
		HWND hwndTop =  ::GetForegroundWindow();
		::SetForegroundWindow(m_hWnd);		 // Set Focus to IME activator Window
	#endif // OLD_IME_BEHAVIOR

	// on nt/j we send a private message to the IDE's subclassed window
	// procedure so we can set the IME open status in-process.
	// see cafe\support\guitools\imehook.cpp - michma 1/1/97.
	if(m_bRunningOnNTJ)
		{
		WaitStepInstructions("%s IME", bOpen ? "Open" : "Close");
		// GetDumbWindow() returns the handle to the IDE's main window.
		// bOpen is passed to the subclassed window procedure as lParam. 
		return ::SendMessage(GetDumbWindow(), m_msgIMESetOpen, 0, bOpen); 		
		}

	if( m_hIME && (lpIME = (LPIMESTRUCT)GlobalLock(m_hIME)) && (m_lpfnSendIMEMessage != NULL) )
	{
		lpIME->fnc = IME_SETOPEN;
		lpIME->wParam = bOpen;
		GlobalUnlock (m_hIME);
		WaitStepInstructions("%s IME", bOpen ? "Open" : "Close");
		lres = (*(m_lpfnSendIMEMessage))(GetDumbWindow(), (LPARAM)m_hIME);

		if( !IsOpen() != !bOpen )
		{
			Sleep(500);		// sleep half a second
			if( !IsOpen() != !bOpen )
				LOG->RecordInfo("Unable to %s the IME", bOpen ? "Open" : "Close");
		}
	}
	else
		LOG->RecordInfo("No IME found.  Cannot use CIME functions");

	#ifdef OLD_IME_BEHAVIOR
		::SetForegroundWindow(hwndTop);		// Set focus back to target app
	#endif // OLD_IME_BEHAVIOR

	return lres;
}

// BEGIN_HELP_COMMENT
// Function: int CIME::IsOpen(void)
// Description: Determine if the IME is open.
// Return: An integer that indicates success. 0 if the IME's not open; -1 if the IME is open with no partial string entry; a positive value of the count of characters entered if the IME is open with a partial string entry.
// END_HELP_COMMENT
int CIME::IsOpen(void)	   //REVIEW(EnriqueP): Do we need to switch focus to window?
{
	LPIMESTRUCT lpIME;
	LRESULT lres = FALSE;

	// on nt/j we send a private message to the IDE's subclassed window
	// procedure so we can get the IME open status in-process.
	// see cafe\support\guitools\imehook.cpp - michma 1/1/97.
	if(m_bRunningOnNTJ)
		// GetDumbWindow() returns the handle to the IDE's main window.
		return ::SendMessage(GetDumbWindow(), m_msgIMEGetOpen, 0, 0);

	if (m_hIME && (lpIME = (LPIMESTRUCT) GlobalLock (m_hIME)))
	{
		lpIME->fnc = IME_GETOPEN;
		GlobalUnlock (m_hIME);
		if (m_lpfnSendIMEMessage != NULL) {
				lres = (*(m_lpfnSendIMEMessage))(GetDumbWindow(), (LPARAM)m_hIME);
//			SwitchFocus();
		}
	}

	if( lres == 0 )
		return 0;		// it's not open
	else if( lpIME->wParam == 0 )
		return -1;				// it is open, with no undetermined string
	else
		return lpIME->wParam;	// it is open, with this many bytes in the undetermined string
}

// BEGIN_HELP_COMMENT
// Function: void CIME::Flush(HWND hwnd)
// Description: Flush any remaining keystrokes to the IME. The IME must be open to call this function (see CIME::Open).
// Return: <none>
// Param: hwnd The HWND of the window using the IME. This parameter is NYI.
// END_HELP_COMMENT
void CIME::Flush(HWND hwnd)		   //REVIEW(EnriqueP): Do we need to switch focus to window?
{
	LPIMESTRUCT lpIME;
	LRESULT lres;

	if (m_hIME && (lpIME = (LPIMESTRUCT) GlobalLock (m_hIME)))
	{
		lpIME->fnc = IME_SENDVKEY;
		lpIME->wParam = VK_DBE_FLUSHSTRING;
		GlobalUnlock (m_hIME);
		if (m_lpfnSendIMEMessage != NULL) {
			lres = (*(m_lpfnSendIMEMessage))(GetDumbWindow(), (LPARAM)m_hIME);
//			SwitchFocus();
		}
	}
}

// BEGIN_HELP_COMMENT
// Function: UINT CIME::GetMode(void)
// Description: Get the current mode of the IME. This value is the combination the current mode of each setting in the IME.
// Return: An unsigned integer that contains the current mode of the IME.
// END_HELP_COMMENT
UINT CIME::GetMode(void)			//REVIEW(EnriqueP): Do we need to switch focus to window?
{
	LPIMESTRUCT lpIME;
	LRESULT lres = 0;

	// on nt/j we send a private message to the IDE's subclassed window
	// procedure so we can get the IME conversion mode in-process.
	// see cafe\support\guitools\imehook.cpp - michma 1/1/97.
	if(m_bRunningOnNTJ)
		// GetDumbWindow() returns the handle to the IDE's main window.
		return ::SendMessage(GetDumbWindow(), m_msgIMEGetMode, 0, 0);

	if (m_hIME && (lpIME = (LPIMESTRUCT) GlobalLock (m_hIME)))
	{
		lpIME->fnc = IME_GETCONVERSIONMODE;
		GlobalUnlock (m_hIME);
		if (m_lpfnSendIMEMessage != NULL) {
			lres = (*(m_lpfnSendIMEMessage))(GetDumbWindow(), (LPARAM)m_hIME);
//			SwitchFocus();
		}
	}
	return lres;
}

// BEGIN_HELP_COMMENT
// Function: UINT CIME::SetMode(UINT flags)
// Description: Set the mode of the IME by value. (See CIME::SetMode(EAlphabets, UINT, BOOL, BOOL) to set by enumeration.)
// Return: An unsigned integer that contains the mode actually set in the IME.
// Param: flags An unsigned integer that specifies the mode to set.
// END_HELP_COMMENT
UINT CIME::SetMode(UINT flags)
{
	LPIMESTRUCT lpIME;
	LRESULT lres = 0;

	IMEInUse(TRUE); // SET in use flag ;

	// on nt/j we send a private message to the IDE's subclassed window
	// procedure so we can set the IME conversion mode in-process.
	// see cafe\support\guitools\imehook.cpp - michma 1/1/97.
	if(m_bRunningOnNTJ)
		{
		WaitStepInstructions("Set IME mode to 0x%08x", flags);
		// GetDumbWindow() returns the handle to the IDE's main window.
		// flags is passed to the subclassed window procedure as lParam. 
		return ::SendMessage(GetDumbWindow(), m_msgIMESetMode, 0, flags);
		}

	#ifdef OLD_IME_BEHAVIOR
		// get the handle of the top level window
		HWND hwndTop =  ::GetForegroundWindow();
		::SetForegroundWindow(m_hWnd);		 // Set Focus to IME activator Window
	#endif // OLD_IME_BEHAVIOR

	if (m_hIME && (lpIME = (LPIMESTRUCT) GlobalLock (m_hIME)))
	{
		lpIME->fnc = IME_SETCONVERSIONMODE;
		lpIME->wParam = flags;
		GlobalUnlock (m_hIME);
		WaitStepInstructions("Set IME mode to 0x%08x", flags);
		if (m_lpfnSendIMEMessage != NULL) {
			lres = (*(m_lpfnSendIMEMessage))(GetDumbWindow(), (LPARAM)m_hIME);
//			SwitchFocus();
		}
	}

	#ifdef OLD_IME_BEHAVIOR
		::SetForegroundWindow(hwndTop);
	#endif // OLD_IME_BEHAVIOR

//	LOG->Comment("SetMode to 0x%08x: 0x%08x", flags, lres);
	return lres;
}

// BEGIN_HELP_COMMENT
// Function: UINT CIME::SetMode(EAlphabets eAlphabet /*=ALPHA*/, UINT nBytes /*=1*/, BOOL bRoman /*=TRUE*/, BOOL bCodeInput /*=FALSE*/)
// Description: Set the mode of the IME by enumeration. (See CIME::SetMode(UINT) to set by value.)
// Return: An unsigned integer that contains the mode actually set in the IME.
// Param: eAlphabet An EAlphabets value that specifies the type of alphabet to set in the IME: DONTCARE, ALPHA, KATAKANA, HIRAGANA. (Default value is ALPHA.)
// Param: nBytes An integer that specifies the number of bytes: SBCS (1) or DBCS (2). (Default value is 1.)
// Param: bRoman A Boolean value that specifies whether to set the IME to Roman mode (TRUE) or NoRoman mode. NoRoman mode has not been found to be useful. (Default value is TRUE.)
// Param: bCodeInput A Boolean value that specifies whether to set the IME to code input mode (TRUE) or no code input mode. Code input mode has not been found to be useful. (Default value is FALSE.)
// END_HELP_COMMENT
UINT CIME::SetMode(EAlphabets eAlphabet /*=ALPHA*/, UINT nBytes /*=1*/, BOOL bRoman /*=TRUE*/, BOOL bCodeInput /*=FALSE*/)
{
	UINT flags = GetMode();
	UINT fAlphabet, fNumBytes, fRoman, fCodeInput;

	// on nt/j we send a private message to the IDE's subclassed window	procedure
	// so we can set the IME conversion mode in-process. The api we	use to access
	// the IME uses different conversion mode values than used on win95, so we 
	// need to create a different "flags" value for  CIME::SetMode(UINT flags).
	// see cafe\support\guitools\imehook.cpp - michma 1/1/97.
	if(m_bRunningOnNTJ)
		{
		if(eAlphabet == ALPHA)
			{
			if(nBytes == 1)
				flags = IME_MODE_SB_ALPHA;	// single-byte alpha.
			else if(nBytes == 2)
				flags = IME_MODE_DB_ALPHA;	// double-byte alpha.
			}	
		else if(eAlphabet == KATAKANA)
			{
			if(nBytes == 1)
				flags = IME_MODE_SB_KATAKANA;	// single-byte katakana.
			else if(nBytes == 2)
				flags = IME_MODE_DB_KATAKANA;	// double-byte katakana.
			}
		else if(eAlphabet == HIRAGANA)	
			{
			if(nBytes == 2)
				flags = IME_MODE_DB_HIRAGANA;	// double-byte hiragana.
			}
 		// this function will send the private message to the IDE' subclassed window procedure.
		return SetMode(flags);	
		}

	if( eAlphabet == ALPHA )						// Use alphabet chosen by user
		fAlphabet = IME_MODE_ALPHANUMERIC;
	else if( eAlphabet == KATAKANA )
		fAlphabet = IME_MODE_KATAKANA;
	else if( eAlphabet == HIRAGANA )
		fAlphabet = IME_MODE_HIRAGANA;
	else											// otherwise, set alphabet
		fAlphabet = flags & IME_MODES_ALPHABET;		// to whatever it already is

	if( nBytes == 1 )								// Set the number of bytes to either
		fNumBytes = IME_MODE_SBCSCHAR;				// SBCS
	else if( nBytes == 2 )							// DBCS
		fNumBytes = IME_MODE_DBCSCHAR;
	else											// or whatever it already is
		fNumBytes = flags & IME_MODES_NUMBYTES;

	if( bRoman )									// Set Roman
		fRoman = IME_MODE_ROMAN;					// I've never seen NoRoman to be useful
	else
		fRoman = IME_MODE_NOROMAN;
		
	if( bCodeInput )								// Set CodeInput
		fCodeInput = IME_MODE_CODEINPUT;			// I've never seen this to be useful
	else
		fCodeInput = IME_MODE_NOCODEINPUT;

	// see if there are any other bits that we didn't know about
	flags &= ~(IME_MODES_ALPHABET | IME_MODES_NUMBYTES | IME_MODES_ROMAN | IME_MODES_INPUT);

	return SetMode( fAlphabet | fNumBytes | fRoman | fCodeInput | flags );		// set new mode
}

// set the conversion mode through the IME setup dialog
// (this is the first button on the IME)
BOOL CIME::SetConversionMode(int nMode)
{
	// the IME should be open
	ASSERT(IsOpen());

	// are we on NT or Win95?
	if (GetSystem() & SYSTEM_WIN) {
		LOG->RecordInfo("Setting the IME conversion mode on Win95...");
		// Win95
		// bring up the IME setup dialog
		MST.DoKeys("^{F10}");
		Sleep(1000);
		MST.DoKeys("{F5}");
		Sleep(1000);
		// wait for the dialog to come up
		if (!MST.WFndWndWait("MS-IME", FW_PART | FW_DIALOG, 5)) {
			LOG->RecordInfo("CIME::SetConversionMode: unable to open the MS IME setup dialog");
			return FALSE;
		}
		Sleep(1000);

		// get to the tab that contains the conversion mode field (two tabs in)
		// tab until the active window is the OK button
		CString strText;
		do {
			MST.DoKeys("{tab}");
			MST.WGetText(MST.WGetFocus(), strText);
		}
		while (strText != "OK");
		// once we're on the OK button, tab twice more to get to the tab
		MST.DoKeys("{tab 2}");

		// move to the third tab
		MST.DoKeys("{right 2}");

		// for some reason ^({tab}) doesn't work in this dialog...
//		MST.DoKeys("^({tab})");
//		MST.DoKeys("^({tab})");

		// select the conversion mode field
		MST.DoKeys("%x{HOME}");
		Sleep(500);
		// select the conversion mode
		char buf[255];
		sprintf(buf, "{DOWN %d}{ENTER}", nMode);
		MST.DoKeys(buf);
		Sleep(500);
		// wait for the dialog to go away
		if (!MST.WFndWndWait("MS-IME", FW_PART | FW_DIALOG | FW_NOEXIST, 5)) {
			LOG->RecordInfo("CIME::SetConversionMode: unable to close the MS IME setup dialog");
			return FALSE;
		}
		LOG->RecordInfo("Successfully set the IME conversion mode on Win95.");
	}
	else if (GetSystem() & SYSTEM_NT) {
		LOG->RecordInfo("Setting the IME conversion mode on NT...");
		// NT
		// set the mode
		// bring up the IME setup dialog
		MST.DoKeys("^{F10}");
		Sleep(1000);
		MST.DoKeys("{F5}");
		Sleep(1000);
		// wait for the dialog to come up
		if (!MST.WFndWndWait("MS-IME", FW_PART | FW_DIALOG, 5)) {
			LOG->RecordInfo("CIME::SetConversionMode: unable to open the MS IME setup dialog");
			return FALSE;
		}
		Sleep(1000);

		// select the conversion mode field
		MST.DoKeys("%x{HOME}");
		Sleep(500);
		// select the conversion mode
		char buf[255];
		sprintf(buf, "{DOWN %d}{ENTER}", nMode);
		MST.DoKeys(buf);
		Sleep(500);
		// wait for the dialog to go away
		if (!MST.WFndWndWait("MS-IME", FW_PART | FW_DIALOG | FW_NOEXIST, 5)) {
			LOG->RecordInfo("CIME::SetConversionMode: unable to close the MS IME setup dialog");
			return FALSE;
		}

		Open(TRUE);
		LOG->RecordInfo("Successfully set the IME conversion mode on NT.");
	}
	else {
		LOG->RecordInfo("CIME::SetConversionMode: unable to set conversion mode; unrecognized OS.");
		return FALSE;
	}
	return TRUE;
}
	
// BEGIN_HELP_COMMENT
// Function: BOOL CIME::SendVKey(UINT vKey)
// Description: Send the IME a virtual keystroke.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: vKey An integer that specifies the virtual key to send to the IME.
// END_HELP_COMMENT
BOOL CIME::SendVKey(UINT vKey)		//REVIEW(EnriqueP): Do we need to switch focus to window?
{
	LPIMESTRUCT lpIME;
	LRESULT lres = 0;

	if (m_hIME && (lpIME = (LPIMESTRUCT) GlobalLock (m_hIME)))
	{
		lpIME->fnc = IME_SENDVKEY;
		lpIME->wParam = vKey;
		lpIME->wCount = vKey;
		GlobalUnlock (m_hIME);
		WaitStepInstructions("Send IME VKey 0x%x", vKey);
		if (m_lpfnSendIMEMessage != NULL) {
			lres = (*(m_lpfnSendIMEMessage))(GetDumbWindow(), (LPARAM)m_hIME);
//			SwitchFocus();
		}
	}
	return lres;
}

//	Because SendIMEMessage requires an HWND, and NULL usually isn't good,
//	the best thing seems to be to send the active window.
//	When we know more, maybe we can adjust this function.
HWND CIME::GetDumbWindow(void)
{
	#ifdef OLD_IME_BEHAVIOR
		return m_editCtl.m_hWnd;
	#else
		CString strTitle;
		CString strClass;

		// get the handle of the top level window
		HWND hwndTop = ::GetTopWindow(NULL);

		// try to find the IDE by iterating through all windows
		for (HWND hwnd = hwndTop; hwnd != NULL; hwnd = ::GetNextWindow(hwnd, GW_HWNDNEXT)) {
			// get the window title
			::GetWindowText(hwnd, strTitle.GetBuffer(255), 255);
			strTitle.ReleaseBuffer();
			// get the window class
			::GetClassName(hwnd, strClass.GetBuffer(255), 255);
			strClass.ReleaseBuffer();
			// do the title and class match the IDE?
			if (strTitle.Find("Microsoft Visual C++") != -1 && strClass.Find("Afx:") != -1) {
				break;
			}
		}

		// was the IDE found?
		if (hwnd != NULL) {
			hwndTop = hwnd;
		}


//		HWND hwndTop = ::GetForegroundWindow();
		::SetFocus(hwndTop);
		return hwndTop;
	#endif // OLD_IME_BEHAVIOR
}

void CIME::SwitchFocus(void)
{
	HWND hwndTop = GetDumbWindow();

	// set focus to the small window
	::SetForegroundWindow(m_editCtl.m_hWnd);
	Sleep(1000);
//	::ShowWindow(m_hWnd, SW_HIDE);

	::SetForegroundWindow(hwndTop);
	Sleep(1000);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\imehook.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	IMEHOOK.CPP
//
//	Created by :			Date :
//		MichMa					1/1/97
//
//	Description :
//		Implementation of the NT/J IME subclassing hook.
//

/***	OVERVIEW	***

this file (built as imehook.dll) is used by cafe to control the ide's ime on nt/j.
since the ime gets instantiated on a per-process basis on nt/j, cafe needs a way
to access it out-of-process. the method we chose was to hook the ide and subclass it
via imehook.dll, and then communicate with that dll via private messages. the
procedure works as follows:

1.	in cafe, the CIDE object gets created. if it is running on nt/j, CIDE::CIDE()
	loads imehook.dll via LoadLibrary() and initializes pointers to 2 functions via
	GetProcAddress(): HookIDE() and	UnhookIDE().

2. 	when imehook.dll is loaded into cafe's address space, DllMain() registers the
	following messages while processing DLL_PROCESS_ATTACH:
	
		msgSubclassIDE
		msgDeSubclassIDE
		msgIMESetOpen
		msgIMEGetOpen
		msgIMESetMode
		msgIMEGetMode

	it also preserves the HINSTANCE in a global variable.

3.	in cafe, the CIME object gets created. if it is running on nt/j, CIME::CIME()
	registers the same messages as imehook.dll's DllMain(), except for
	msgSubclassIDE and msgDeSubclassIDE, which are only used by HookIDE() and
	UnhookIDE(). the other messages are used by CIME routines to communicate
	IME operations to the subclassed IDE's window procedure.

4.	CIDE::Launch() calls HookIDE() after the IDE has come up, passing to it the
	handle to the IDE's main window.

5.	HookIDE() sets a WH_GETMESSAGE hook via SetWindowsHookEx, using the global
	HINSTANCE of imehook.dll preserved by DllMain(), and the IDE's main thread id
	derived from the window handle passed to HookIDE(). the hook procedure is
	CafeIMEHookProc(). the handle to the hook is preserved in a global variable for
	later use by UnhookIDE(). imehook.dll is now loaded into the IDE's address space. 
	DllMain() is called and it does the same registering of messages and preserving
	of its HINSTANCE as was done in cafe's address space.

6.	HookIDE() then posts the msgSubclassIDE message, registered by DllMain(), to the
	IDE. it must post the message rather than send it because WH_GETMESSAGE hooks
	only get called when the hooked app asynchronously processes messages with 
	GetMessage(). the lParam of this message is the hook's handle, returned from
	SetWindowsHookEx.

7.	CafeIMEHookProc() receives the msgSubclassIDE message and uses SetWindowLong to
	subclass the IDE, installing CafeIMEWndProc() as the new window procedure and
	preserving the original window procedure in a global variable for restoration
	later. we need to subclass the window because we want cafe to be able to
	synchronously control the IDE's IME via SendMessage(). a WH_GETMESSAGE hook
	only allows asynchronous communication via GetMessage(). and asynchronous
	communication within cafe can lead to timing problems.

8.	remember that the lParam of the msgSubclassIDE message was set to the hook's
	handle before being posted by HookIDE(). CafeIMEHookProc() saves this value in
	a global variable since it needs it as a parameter to CallNextHookEx(), which
	it calls for every message it receives. remember also that the handle to the hook
	was already preserved in a global variable when the hook was created in HookIDE().
	but that was in cafe's address space, so the global variable in the IDE's address
	space is uninitialized until this point.

9.	with the subclass in place, the CIME routines used for controlling the IDE's IME
	can now communicate IME operations to CafeIMEWndProc by sending messages registered
	in imehook.dll's DllMain() in cafe's address space. CafeIMEWndProc, which is also
	in imehook.dll but used only in the IDE's address space and not cafe's, responds to
	the messages with one or more of the appropriate Imm function calls. all of the
	operations require getting and releasing an IME context via ImmGetContext() and
	ImmReleaseContext(). other functions used are:
	
	Imm function				CafeIMEWndProc() msg		CIME function
	------------				--------------------		-------------
	ImmSetOpenStatus()			msgIMESetOpen				CIME::Open()
	ImmGetOpenStatus()			msgIMEGetOpen				CIME::IsOpen()
	ImmSetConversionMode()		msgIMESetMode				CIME::SetMode()
	ImmGetConversionMode()		msgIMEGetMode				CIME::GetMode()

10.	CIDE::Exit() calls UnhookIDE() before terminating the IDE, passing to it the
	handle to the IDE's main window.

11. UnhookIDE() sends the msgDeSubclassIDE message to CafeIMEWndProc(), which processes
	this message by using SetWindowLong() to restore the IDE's original window procedure,
	which it preserved in a global variable when doing the original subclassing in 
	CafeIMEHookProc().

12. UnhookIDE() then removes the hook via UnhookWindowsHookEx(), passing to it the hook
	handle which was preserved in a global variable when the hook was set in HookIDE().
	this unloads imehook.dll from the IDE's address space.

13. CIDE::~CIDE() unloads imehook.dll from cafe's address space.

*/

#include <windows.h>
#include <stdio.h>		// file i/o for errors.
#include <imm.h>		// standard header file for Imm functions.

// all errors that occur in imehook.dll are written to imehook.log.
FILE *fileLog;
// the handle to the ide hook is first initialized within cafe's 
// address space when it calls HookIDE() from CIDE::Launch() then it is
// immediately communicated to the imehook.dll in the IDE's address 
// space via the lParam of a message posted to the new hook.
HHOOK hCafeIMEHook;
// handle to imehook.dll, initialized in DllMain().
HINSTANCE hIMEHookDll;
// address of the IDE's original window procedure, saved in the hook 
// procedure (CafeIMEHookProc) before subclassing the ide.
LONG IDEWndProc;

// the following messages are used to communicate from cafe and the
// imehook.dll loaded into cafe's address space to the imehook.dll
// loaded into the ide's address space.	they are registered with
// RegisterWindowMessage in DllMain() while processing DLL_PROCESS_ATTACH.

		// posted from HookIDE() informing the hook to subclass the ide.
UINT	msgSubclassIDE,
		// sent from UnhookIDE() informing the subclass window procedure
		// to restore the ide's default window procedure.
		msgDeSubclassIDE,
		// sent from CIME::Open().
		msgIMESetOpen,
		// sent from CIME::IsOpen().
		msgIMEGetOpen,
		// sent from CIME::SetMode().
		msgIMESetMode,
		// sent from CIME::GetMode().
		msgIMEGetMode;


// this function is the subclass window procedure that gets installed for the IDE, via SetWindowProc,
// when the _WH_GETMESSAGE hook procedure (CafeIMEHookProc) is processing the msgSubclassIDE message.
// this window procedure receives all messages sent or posted to the IDE's main window. we only process
// the private messages intended to communicate IME operations from cafe. the rest we pass on to the
// IDE's default window procedure, via CallWindowProc.
LPARAM CALLBACK CafeIMEWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
	
	{
	// sent from CIME::Open().
	if(msg == msgIMESetOpen)
		{
		// get the IME context for the IDE's main window.
		if(HIMC hIMC = ImmGetContext(hwnd))
			{
			// set the open status of the IME.
			// if lParam is TRUE, the IME is opened.
			// if lParam is FALSE, the IME is closed.
			if(ImmSetOpenStatus(hIMC, lParam))
				{
				// release the IME context for the IDE's main window.
				if(ImmReleaseContext(hwnd, hIMC))
					// CIME::Open() returns TRUE if everything passed.
					return TRUE;
				else
					{
					// failed to release the IME context.
					fprintf(fileLog, "IMEHOOK.DLL: error %d releasing IME context "
									 "while processing msgIMESetOpen.", GetLastError());
					return FALSE;
					}
				}
			else
				{
				// failed to set the open status.
				fprintf(fileLog, "IMEHOOK.DLL: error %d setting IME open status "
								 "while processing msgIMESetOpen.", GetLastError());
				return FALSE;
				}
			}
		else
			{
			// failed to get the IME context.
			fprintf(fileLog, "IMEHOOK.DLL: error %d getting IME context "
							 "while processing msgIMESetOpen.", GetLastError());
			return FALSE;
			}
		}

	// sent from CIME::IsOpen().
	else if(msg == msgIMEGetOpen)
		{
		// get the IME context for the IDE's main window.
		if(HIMC hIMC = ImmGetContext(hwnd))
			{
			// get the open status of the IME.
			BOOL bOpenStatus = ImmGetOpenStatus(hIMC);
			// release the IME context for the IDE's main window.
			if(ImmReleaseContext(hwnd, hIMC))
				// CIME::IsOpen() returns one of the following:
				//		 0 if the IME is closed.
  				//		-1 if the IME is open, with no bytes in the buffer.
				//		the number of bytes in the buffer. 
				// REIVEW (michma): third option not currently supported here.
				return bOpenStatus ? -1 : 0;
			else
				{
				// failed to release the IME context. report IME as closed.				
				fprintf(fileLog, "IMEHOOK.DLL: error %d releasing IME context "
								 "while processing msgIMEGetOpen.", GetLastError());
				return 0;
				}
			}
		else
			{
			// failed to get the IME context. report IME as closed.
			fprintf(fileLog, "IMEHOOK.DLL: error %d getting IME context "
							 "while processing msgIMEGetOpen.", GetLastError());
			return 0;
			}
		}

	// sent from CIME::SetMode().
	else if(msg == msgIMESetMode)
		{
		// get the IME context for the IDE's main window.
		if(HIMC hIMC = ImmGetContext(hwnd))
			{
			DWORD dwConversion, dwSentence;
			// setting the conversion mode requires setting the sentence too.
			// we don't want to screw up the sentence, so first we get the current
			// conversion mode and sentence...
			if(ImmGetConversionStatus(hIMC, &dwConversion, &dwSentence))
				{
				// ...then we reset the conversion mode to that passed in by CIME::SetMode().
				dwConversion = (DWORD)lParam;
				// and set the new conversion mode using the old sentence.
				if(ImmSetConversionStatus(hIMC, dwConversion, dwSentence))
					{
					// release the IME context for the IDE's main window.
					if(ImmReleaseContext(hwnd, hIMC))
						// CIME::SetMode() returns the conversion mode actually set.
						return dwConversion;
					else
						{
						// failed to release the IME context. return invalid conversion mode.
						fprintf(fileLog, "IMEHOOK.DLL: error %d releasing IME context "
										 "while processing msgIMESetMode.", GetLastError());
						return 0;
						}
					}
				else
					{
					// failed to set the conversion status. return invalid conversion mode.
					fprintf(fileLog, "IMEHOOK.DLL: error %d setting IME conversion status "
									 "while processing msgIMESetMode.", GetLastError());
					return 0;
					}
				}
			else
				{
				// failed to get the conversion status. return invalid conversion mode. 
				fprintf(fileLog, "IMEHOOK.DLL: error %d getting IME conversion status "
								 "while processing msgIMESetMode.", GetLastError());
				return 0;
				}
			}
		else
			{
			// failed to get the IME context. return invalid conversion mode.
			fprintf(fileLog, "IMEHOOK.DLL: error %d getting IME context "
							 "while processing msgIMESetMode.", GetLastError());
			return 0;
			}
		}

	// sent from CIME::GetMode().
	else if(msg == msgIMEGetMode)
		{
		// get the IME context for the IDE's main window.
		if(HIMC hIMC = ImmGetContext(hwnd))
			{
			DWORD dwConversion, dwSentence;
			// get the conversoin mode (and sentence, which we don't use).
			if(ImmGetConversionStatus(hIMC, &dwConversion, &dwSentence))
				{
				// release the IME context for the IDE's main window.
				if(ImmReleaseContext(hwnd, hIMC))
					// CIME::GetMode() returns the conversion mode.
					return dwConversion;
				else
					{
					// failed to release the IME context.
					fprintf(fileLog, "IMEHOOK.DLL: error %d releasing IME context "
									 "while processing msgIMEGetMode.", GetLastError());
					return 0;
					}
				}
			else
				{
				// failed to get the conversion mode.
				fprintf(fileLog, "IMEHOOK.DLL: error %d getting IME conversion status "
								 "while processing msgIMEGetMode.", GetLastError());
				return 0;
				}
			}
		else
			{
			// failed to get the IME context.
			fprintf(fileLog, "IMEHOOK.DLL: error %d getting IME context "
							 "while processing msgIMEGetMode.", GetLastError());
			return 0;
			}
		}
	
	// sent from UnHookIDE().		
	else if(msg == msgDeSubclassIDE)
		{
		// restore the IDE's original window procedure, which was saved in a global
		// variable while processing msgSubclassIDE in CafeIMEHookProc().
		if(!SetWindowLong(hwnd, GWL_WNDPROC, IDEWndProc))
			fprintf(fileLog, "IMEHOOK.DLL: error %d setting window long "
							 "while processing msgDeSubclassIDE.", GetLastError());

		return 0;
		}

	// if the message isn't from CIME or UnhookIDE(), 
	// pass it on to the IDE's original window procedure.
	return CallWindowProc((int (__stdcall *)(void))IDEWndProc, hwnd, msg, wParam, lParam);
	}


// this function is the WH_GETMESSAGE hook procedure that HookIDE() installs.
// hooking the ide gets imehook.dll loaded into the ide's address space
// so we can access its ime in-process. all this hook does is wait for
// the message from HookIDE to subclass the ide (so CIME can communicate
// synchronously with the ide's imehook.dll).
LRESULT CALLBACK CafeIMEHookProc(int code, WPARAM wParam, LPARAM lParam)
	
	{
	// posted from HookIDE().
	if(((MSG *)lParam)->message == msgSubclassIDE)
		{
		// the hook handle was passed from HookIDE so that the ide's
		// instance of imehook.dll could use it for CallNextHookEx.
		hCafeIMEHook = (HHOOK)(((MSG *)lParam)->lParam);
		// subclass the ide with CafeIMEWndProc while saving the default
		// window procedure for restoration later.
		if(!(IDEWndProc = SetWindowLong(((MSG *)lParam)->hwnd, GWL_WNDPROC, (long)CafeIMEWndProc)))
			fprintf(fileLog, "IMEHOOK.DLL: error %d setting window long "
							 "while processing msgSubclassIDE.", GetLastError());
 		}

	// call the next hook in the chain (if any).
	return CallNextHookEx(hCafeIMEHook, code, wParam, lParam);
	}


// to allow cafe to use non-mangled names when calling
// GetProcAddress() for HookIDE() and UnhookIDE().
extern "C"
{

// this function sets the GetMessage hook in the ide. it then posts a
// user-defined message to that hook informing the hook to subclass the ide.
// we can't simply use a GetMessage hook because then the CIME class would
// only be able to communicate with the ide's imehook.dll asynchronously
// (via PostMessage). for synchronous communication we need SendMessage,
// which requires a subclass.

// hWndIDE is the handle to the ide's main window, passed from CIDE::Launch.
__declspec(dllexport) void HookIDE(HWND hWndIDE)
	{
	// get the thread associated with the ide's main window (required by SetWindowsHookEx).
	if(DWORD idThreadIDE = GetWindowThreadProcessId(hWndIDE, NULL))
		{
		// set the GetMessage hook.
		if(hCafeIMEHook = SetWindowsHookEx(WH_GETMESSAGE, (HOOKPROC)CafeIMEHookProc, hIMEHookDll, idThreadIDE))
			{
			// post a message to the hook informing it to subclass the ide.
			// we send the handle to the hook via lParam because the hook
			// procedure needs to call CallNextHookEx, which requires the handle
			// of the current hook. even though hCafeIMEHook is a global
			// variable, HookIDE is called in cafe's address space, while the
			// the hook procedure is called in the ide's address space.
			if(!PostMessage(hWndIDE, msgSubclassIDE, 0, (LPARAM)hCafeIMEHook))
				{
				fprintf(fileLog, "IMEHOOK.DLL: error %d posting msgSubclassIDE.", GetLastError());
				}
			}
		else
			{
			fprintf(fileLog, "IMEHOOK.DLL: error %d setting ide hook.", GetLastError());
			}
		}
	else
		fprintf(fileLog, "IMEHOOK.DLL: error %d getting ide thread id.", GetLastError());
	}


// this function removes the GetMessage hook from the ide.
// first it sends a message to the subclass window procedure informing
// it to re-instate the default window procedure (saved in IDEWndProc).

// hWndIDE is the handle to the ide's main window, passed from CIDE::Exit.
__declspec(dllexport) void UnhookIDE(HWND hWndIDE)
	{
	// verify that the hook was created.
	if(hCafeIMEHook)
		{
		// tell the subclass procedure to restore the default window procedure.
		SendMessage(hWndIDE, msgDeSubclassIDE, 0, 0);
		// remove the hook from the ide. this will unload imehook.dll from
		// the ide's address space.
		if(!UnhookWindowsHookEx(hCafeIMEHook))
			fprintf(fileLog, "IMEHOOK.DLL: error %d removing hook.", GetLastError());
		}
	}

}	// extern "C"


// remember that this will be called both for the imehook.dll loaded into
// cafe's address space and for the imehook.dll loaded into the ide's
// address space.
INT WINAPI DllMain(HANDLE hInst, ULONG ulRbc, LPVOID lpReserved) 
	
	{
	if(ulRbc == DLL_PROCESS_ATTACH)
		{
		// the imehook.dll loaded into cafe's address just needs the
		// the first two messages. the imehook.dll loaded into the ide's
		// address space needs them all.
		msgSubclassIDE = RegisterWindowMessage("msgSubclassIDE");
		msgDeSubclassIDE = RegisterWindowMessage("msgDeSubclassIDE");
		msgIMESetOpen = RegisterWindowMessage("msgIMESetOpen");
		msgIMEGetOpen = RegisterWindowMessage("msgIMEGetOpen");
		msgIMESetMode = RegisterWindowMessage("msgIMESetMode");
		msgIMEGetMode = RegisterWindowMessage("msgIMEGetMode");
		// the imehook.dll loaded into cafe's address space needs the dll's
		// handle for setting the hook in HookIDE().
		hIMEHookDll = hInst;
		// open the log file, imehook.log, for any errors that may occur.
		// for cafe's instance of imehook.dll, this file will be created in the same dir as cafedrv.exe.
		// for the ide's instance of imehook.dll, this file will be created in the same dir as msdev(d).exe.
		fileLog = fopen("imehook.log", "w");
		// we want all logging written to disk immediately (in case of crashes), so don't use a buffer.
		setvbuf( fileLog, NULL, _IONBF, 0);
		}
	else if(ulRbc == DLL_PROCESS_DETACH)
		// close imehook.log.
		fclose(fileLog);
	
	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		BrianCr				09/06/94
//
//	Description :
//		Precompiled header for all of the core MFC files
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\coclip.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  COCLIP.CPP
//
//  Created by :            Date :
//      DavidGa                 1/11/94
//
//	Description :
//		Implementation of the COClipboard component object class
//

#include "stdafx.h"
#include "testxcpt.h"
#include "coclip.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

///////////////////////////////////////////////////////////////////////////////
//  COClipboard class

COClipboard::COClipboard(void)
{
}

// BEGIN_HELP_COMMENT
// Function: BOOL COClipboard::Empty(void)
// Description: Clear the text on the system clipboard.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL COClipboard::Empty(void)
{
	if( !OpenClipboard( NULL ) )
		EXPECT_EXEC( FALSE, "Cannot open clipboard to empty contents" );
	else if( !EmptyClipboard() )
	{
		CloseClipboard();
		EXPECT_EXEC( FALSE, "Cannot empty clipboard" );
	}
	else
	{
		CloseClipboard();
		return TRUE;
	}
	return FALSE;
}

// BEGIN_HELP_COMMENT
// Function: CString COClipboard::GetText(void)
// Description: Get the text from the system clipboard.
// Return: A CString that contains the text from the system clipboard.
// END_HELP_COMMENT
CString COClipboard::GetText(void)
{
	CString str;

	EXPECT_EXEC( OpenClipboard( NULL ), "Cannot open clipboard to get text" );

	HANDLE hText = GetClipboardData( CF_TEXT );
	if ( !hText )
	{
		CloseClipboard();
		EXPECT_EXEC( FALSE, "Cannot get handle to clipboard text" );
	}
	else
	{
		LPSTR lpText = (LPSTR)GlobalLock( hText );
		if ( !lpText )
		{
			CloseClipboard();
			EXPECT_EXEC( FALSE, "Cannot lock handle for clipboard text" );
		}
		else
		{
			str = lpText;
			GlobalUnlock( hText );
			CloseClipboard();
		}
	}   

	return str;
}

// BEGIN_HELP_COMMENT
// Function: BOOL COClipboard::SetText(LPCSTR szTextIn)
// Description: Set the text in the system clipboard.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: szTextIn A pointer to a string containing the text to put in the clipboard.
// END_HELP_COMMENT
BOOL COClipboard::SetText(LPCSTR szTextIn)
{
    if ( !OpenClipboard( NULL ) )
    {
        EXPECT_EXEC( FALSE, "Could not open clipboard to set text" );
        return FALSE;
    }

    
    HANDLE hText = GlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE, 1+strlen(szTextIn) );


    if ( !hText )
    {
        CloseClipboard();
        EXPECT_EXEC( FALSE, "Could not allocate memory for clipboard text" );
        return FALSE;
    }
    

    LPSTR lpText = (LPSTR)GlobalLock( hText );

    if ( !lpText )
    {
        CloseClipboard();
        GlobalFree(hText);
        EXPECT_EXEC( FALSE, "Could not lock handle for clipboard text" );
        return FALSE;
    }

    strcpy( lpText, szTextIn);

    GlobalUnlock( hText );
    
    HANDLE hData = SetClipboardData( CF_TEXT, hText );

    CloseClipboard();

    if (!hData)
    {
        EXPECT_EXEC( FALSE, "Could not set clipboard data" );
        return FALSE;
    }

 
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		BrianCr				09/06/94
//
//	Description :
//		source file that includes just the standard includes
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\mstwrap.cpp ===
///////////////////////////////////////////////////////////////////////////////
//      TESTWRAP.CPP
//
//      Created by :                    Date :
//              DavidGa                                 8/14/93
//
//      Description :
//              Implementation of the CMSTest class
//

#include "stdafx.h"
#include "mstwrap.h"
#include "guiv1.h"
#include "guitarg.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// REVIEW(briancr): this object is declared as a global for backward compatibility
// REVIEW(briancr): this is just to make things work. Is there a better way to do this?
// instantiate a global CMSTest
GUI_DATA CMSTest MST;

#define BUFFER          256             // arbitrary size of CString buffers

#define CMDBAR 1

// temporary variables
WNDPOS          g_WndPos;
WNDSIZ          g_WndSiz;
WNDPOSSIZ       g_WndPosSiz;

#if CMDBAR
static UINT DSM_TESTMENU = RegisterWindowMessage("DevStudioTestMenu");
static const int cMenuMenu=0;
static const int cMenuExists=1;
// static const int cMenuGrayed=2; // for some reason, these two aren't implemented.
// static const int cMenuChecked=3;
static const int cMenuEnabled=4;
static const int cMenuCount=5;
static const int cMenuText=6;
static const int cMenuEnd=7;
static const int cMenuRealChecked=8;
#endif

/////////////////////////////////////////////////////////////////////////////
// TEST struct conversions

// WNDPOS <==> CPoint
inline void CMSTest::Convert(WNDPOS const wndpos, CPoint& pt)
	{       pt.x = wndpos.left;
		pt.y = wndpos.top; }
inline void CMSTest::Convert(CPoint const pt, WNDPOS& wndpos)
	{       wndpos.left = pt.x;
		wndpos.top = pt.y; }
inline CPoint CMSTest::Convert(WNDPOS const wndpos)
	{       return CPoint(wndpos.left, wndpos.top); }

// WNDSIZ <==> CSize
inline void CMSTest::Convert(WNDSIZ const wndsiz, CSize& size)
	{       size.cx = wndsiz.width;
		size.cy = wndsiz.height; }
inline void CMSTest::Convert(CSize const size, WNDSIZ& wndsiz)
	{       wndsiz.width = size.cx;
		wndsiz.height = size.cy; }
inline CSize CMSTest::Convert(WNDSIZ const wndsiz)
	{       return CSize(wndsiz.width, wndsiz.height); }

// WNDPOSSIZ <==> CRect
inline void CMSTest::Convert(WNDPOSSIZ const wndpossiz, CRect& rc)
	{       rc.left = wndpossiz.left;
		rc.top = wndpossiz.top;
		rc.right = rc.left + wndpossiz.width;
		rc.bottom = rc.top + wndpossiz.height; }
inline void CMSTest::Convert(CRect const rc, WNDPOSSIZ& wndpossiz)
	{       wndpossiz.left = rc.left;
		wndpossiz.top = rc.top;
		wndpossiz.width = rc.right - rc.left;
		wndpossiz.height = rc.bottom - rc.top; }
inline CRect CMSTest::Convert(WNDPOSSIZ const wndpossiz)
	{       return CRect(wndpossiz.left, wndpossiz.top, wndpossiz.left + wndpossiz.width, wndpossiz.top + wndpossiz.height); }

// wRect <==> CRect


/////////////////////////////////////////////////////////////////////////////
// From TESTCTRL.H
//
//---------------------------------------------------------------------------
// Miscelaneous routines
//---------------------------------------------------------------------------

//long WMessage        (HWND hWnd, UINT wMsg)
//long WMessageW       (HWND hWnd, UINT wMsg, WPARAM wp)
//long WMessageL       (HWND hWnd, UINT wMsg, LPARAM lp)
//long WMessageWL      (HWND hWnd, UINT wMsg, WPARAM wp, LPARAM lp)

// BEGIN_HELP_COMMENT
// Function: HWND CMSTest::WGetFocus(void)
// Description: A wrapper for the MS-Test function WGetFocus. See the MS-Test documentation for a description of this function.
// Return: An HWND.
// END_HELP_COMMENT
HWND CMSTest::WGetFocus       (void)
	{       return ::WGetFocus();      }
//void WDisplayInfo    (HWND, UINT)
//void WGetInfo        (HWND, LPINFO)

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WStaticSetClass(LPSTR lpszClassName)
// Description: A wrapper for the MS-Test function WStaticSetClass. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpszClassName A pointer to a string that contains the static window class name.
// END_HELP_COMMENT
// void CMSTest::WStaticSetClass (LPSTR lpszClassName)
//	{ ::WStaticSetClass(lpszClassName); }

//void WResetClasses   (void)

// BEGIN_HELP_COMMENT
// Function: BOOL CMSTest::WIsVisible(HWND hwnd)
// Description: A wrapper for the MS-Test function WIsVisible. See the MS-Test documentation for a description of this function.
// Return: A Boolean value.
// Param: hwnd An HWND that specifies the window.
// END_HELP_COMMENT
BOOL CMSTest::WIsVisible      (HWND hwnd)
	{       return ::WIsVisible(hwnd); }

//long WTextLen        (HWND hWnd)

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WGetText(HWND hwnd, CString& strBuffer)
// Description: A wrapper for the MS-Test function WGetText. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: hwnd An HWND that specifies the window.
// Param: strBuffer A reference to a CString that will contain the text of the specified window.
// END_HELP_COMMENT
void CMSTest::WGetText        (HWND hwnd, CString& strBuffer)
	{   ::WGetText(hwnd, strBuffer.GetBufferSetLength(BUFFER));
		strBuffer.ReleaseBuffer(-1); }

//void WSetText        (HWND hWnd, LPCSTR lpcszText)
//int  WNumAltKeys     (void)
//void WGetAltKeys     (CString& strBuff)
//int  WNumDupAltKeys  (void)
//void WGetDupAltKeys  (CString& strBuff)

//---------------------------------------------------------------------------
// General Window routines
//---------------------------------------------------------------------------

// BEGIN_HELP_COMMENT
// Function: HWND CMSTest::WFndWndWait(LPCSTR lpcszCaption, UINT uFlags, UINT uSeconds)
// Description: A wrapper for the MS-Test function WFndWndWait. See the MS-Test documentation for a description of this function.
// Return: An HWND of the window.
// Param: lpcszCaption A pointer to a string that contains the caption of the window.
// Param: uFlags A bitfield that specifies the type of window.
// Param: uSeconds An integer that specifies the number of seconds to wait for the window.
// END_HELP_COMMENT
HWND CMSTest::WFndWndWait       (LPCSTR lpcszCaption, UINT uFlags, UINT uSeconds)
	{       return ::WFndWnd((LPSTR)lpcszCaption, uFlags, uSeconds); }

// BEGIN_HELP_COMMENT
// Function: HWND CMSTest::WFndWndWaitC(LPCSTR lpcszCaption, LPCSTR lpcszClass, UINT uFlags, UINT uSeconds)
// Description: A wrapper for the MS-Test function WFndWndWaitC. See the MS-Test documentation for a description of this function.
// Return: An HWND of the window.
// Param: lpcszCaption A pointer to a string that contains the caption of the window.
// Param: lpcszClass A pointer to a string that contains the name of the window class of the window.
// Param: uFlags A bitfield that specifies the type of window.
// Param: uSeconds An integer that specifies the number of seconds to wait for the window.
// END_HELP_COMMENT
HWND CMSTest::WFndWndWaitC       (LPCSTR lpcszCaption, LPCSTR lpcszClass, UINT uFlags, UINT uSeconds)
	{       return ::WFndWndC((LPSTR)lpcszCaption, (LPSTR)lpcszClass, uFlags, uSeconds); }

// BEGIN_HELP_COMMENT
// Function: HWND CMSTest::WFndWnd(LPCSTR lpcszCaption, UINT uFlags)
// Description: A wrapper for the MS-Test function WFndWnd. See the MS-Test documentation for a description of this function.
// Return: An HWND of the window.
// Param: lpcszCaption A pointer to a string that contains the caption of the window.
// Param: uFlags A bitfield that specifies the type of window.
// END_HELP_COMMENT
HWND CMSTest::WFndWnd       (LPCSTR lpcszCaption, UINT uFlags)
	{       return ::WFndWnd((LPSTR)lpcszCaption, uFlags, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: HWND CMSTest::WFndWndC(LPCSTR lpcszCaption, LPCSTR lpcszClass, UINT uFlags)
// Description: A wrapper for the MS-Test function WFndWndC. See the MS-Test documentation for a description of this function.
// Return: An HWND of the window.
// Param: lpcszCaption A pointer to a string that contains the caption of the window.
// Param: lpcszClass A pointer to a string that contains the name of the window class of the window.
// Param: uFlags A bitfield that specifies the type of window.
// END_HELP_COMMENT
HWND CMSTest::WFndWndC      (LPCSTR lpcszCaption, LPCSTR lpcszClass, UINT uFlags)
	{       return ::WFndWndC((LPSTR)lpcszCaption, (LPSTR)lpcszClass, uFlags, TIMEOUT); }

//void WMinWnd       (HWND hWnd);
void CMSTest::WMaxWnd(HWND hWnd)
{
	::WMaxWnd(hWnd);
}
//void WResWnd       (HWND hWnd);
//void WSetWndPosSiz (HWND hWnd, int x,  int y, int w, int h);
//void WSetWndPos    (HWND hWnd, int x,  int y);

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WSetWndSiz(HWND hwnd, int w,  int h)
// Description: A wrapper for the MS-Test function WSetWndSiz. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: hwnd The HWND of the window.
// Param: w An integer that contains the width to set.
// Param: h An integer that contains the height to set.
// END_HELP_COMMENT
void CMSTest::WSetWndSiz    (HWND hwnd, int w,  int h)
	{      ::WSetWndSiz(hwnd,w,h); }

//void WAdjWndPosSiz (HWND hWnd, int dx, int dy, int dw, int dh);
//void WAdjWndPos    (HWND hWnd, int dx, int dy);
//void WAdjWndSiz    (HWND hWnd, int dw, int dh);
//void WGetWndPosSiz (HWND hWnd, LPWNDPOSSIZ lpWndPosSiz, BOOL fRelative);
//void WGetWndPos    (HWND hWnd, LPWNDPOS    lpWndPos,    BOOL fRelative);

// BEGIN_HELP_COMMENT
// Function: CSize CMSTest::WGetWndSiz(HWND hwnd)
// Description: A wrapper for the MS-Test function WGetWndSiz. See the MS-Test documentation for a description of this function.
// Return: A CSize object that contains the size of the window.
// Param: hwnd The HWND of the window.
// END_HELP_COMMENT
CSize CMSTest::WGetWndSiz    (HWND hwnd)
	{  //             return ::WGetWndSiz(hwnd, TIMEOUT); }

     ::WGetWndSiz(hwnd, &g_WndSiz);
		return Convert(g_WndSiz); }


// BEGIN_HELP_COMMENT
// Function: void CMSTest::WSetActWnd(HWND hwnd)
// Description: A wrapper for the MS-Test function WSetActWnd. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: hwnd The HWND of the window to make active.
// END_HELP_COMMENT
void CMSTest::WSetActWnd    (HWND hwnd)
	{      ::WSetActWnd(hwnd); }

// BEGIN_HELP_COMMENT
// Function: HWND CMSTest::WGetActWnd(HWND hwnd)
// Description: A wrapper for the MS-Test function WGetActWnd. See the MS-Test documentation for a description of this function.
// Return: The HWND of the active window.
// Param: hwnd The HWND of the window.
// END_HELP_COMMENT
HWND CMSTest::WGetActWnd    (HWND hwnd)
	{       return ::WGetActWnd(hwnd); }

//BOOL WIsMaximized  (HWND hWnd);
//BOOL WIsMinimized  (HWND hWnd);

//---------------------------------------------------------------------------
// Menu routines
//---------------------------------------------------------------------------

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WMenu(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WMenu. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the menu name.
// END_HELP_COMMENT
void CMSTest::WMenu        (LPCSTR lpcszName)
#if CMDBAR
{
	WaitStepInstructions("Exec menu command '%s'", lpcszName);
	HWND hWndActive= ::GetForegroundWindow();
	if(hWndActive)
	{
		ATOM nAtom=GlobalAddAtom(lpcszName);
		::SendMessage(hWndActive, DSM_TESTMENU, cMenuMenu, nAtom);

		// 1 second delay. Extravagant, and we need to work on a better way to do this.
		Sleep(1000);

		GlobalDeleteAtom(nAtom);
	}
}
#else
	{      ::WMenu((LPSTR)lpcszName); }
#endif

//void FAR     WMenuEx            (LPCSTR lpcszName, ...);

// BEGIN_HELP_COMMENT
// Function: BOOL CMSTest::WMenuExists(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WMenuExists. See the MS-Test documentation for a description of this function.
// Return: A Boolean value that indicates whether the menu exists.
// Param: lpcszName A pointer to a string that contains the menu name.
// END_HELP_COMMENT
BOOL CMSTest::WMenuExists        (LPCSTR lpcszName)
#if CMDBAR
{
	HWND hWndActive= ::GetForegroundWindow();
	if(hWndActive)
	{
		ATOM nAtom=GlobalAddAtom(lpcszName);
		int rv=::SendMessage(hWndActive, DSM_TESTMENU, cMenuExists, nAtom);
		GlobalDeleteAtom(nAtom);
		return rv;
	}
	return FALSE;
}
#else
	{      return ::WMenuExists(lpcszName); }
#endif

// BEGIN_HELP_COMMENT
// Function: BOOL CMSTest::WMenuGrayed(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WMenuGrayed. See the MS-Test documentation for a description of this function.
// Return: A Boolean value that indicates whether the menu is grayed.
// Param: lpcszName A pointer to a string that contains the menu name.
// END_HELP_COMMENT
BOOL CMSTest::WMenuGrayed        (LPCSTR lpcszName)
// no cmdbar here, because internally this function does nothing.
	{       return ::WMenuGrayed((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: BOOL CMSTest::WMenuChecked(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WMenuChecked. See the MS-Test documentation for a description of this function.
// Return: A Boolean value that indicates whether the menu is checked.
// Param: lpcszName A pointer to a string that contains the menu name.
// END_HELP_COMMENT
BOOL CMSTest::WMenuChecked       (LPCSTR lpcszName)
#if CMDBAR
{
	HWND hWndActive= ::GetForegroundWindow();
	if(hWndActive)
	{
		ATOM nAtom=GlobalAddAtom(lpcszName);
		int rv=::SendMessage(hWndActive, DSM_TESTMENU, cMenuRealChecked, nAtom);
		GlobalDeleteAtom(nAtom);
		return rv;
	}
	return FALSE;
}
#else
	{       return ::WMenuChecked((LPSTR)lpcszName, TIMEOUT); }
#endif

// BEGIN_HELP_COMMENT
// Function: BOOL CMSTest::WMenuEnabled(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WMenuEnabled. See the MS-Test documentation for a description of this function.
// Return: A Boolean value that indicates whether the menu is enabled.
// Param: lpcszName A pointer to a string that contains the menu name.
// END_HELP_COMMENT
BOOL CMSTest::WMenuEnabled       (LPCSTR lpcszName)
#if CMDBAR
{
	HWND hWndActive= ::GetForegroundWindow();
	if(hWndActive)
	{
		ATOM nAtom=GlobalAddAtom(lpcszName);
		int rv=::SendMessage(hWndActive, DSM_TESTMENU, cMenuEnabled, nAtom);
		GlobalDeleteAtom(nAtom);
		return rv;
	}
	return FALSE;
}
#else
	{       return  ::WMenuEnabled((LPSTR)lpcszName); } 
#endif

// BEGIN_HELP_COMMENT
// Function: int CMSTest::WMenuCount(void)
// Description: A wrapper for the MS-Test function WMenuCount. See the MS-Test documentation for a description of this function.
// Return: An integer that specifies the number of items in the menu.
// END_HELP_COMMENT
int  CMSTest::WMenuCount         (void)
#if CMDBAR
{
	HWND hWndActive= ::GetForegroundWindow();
	if(hWndActive)
	{
		return ::SendMessage(hWndActive, DSM_TESTMENU, cMenuCount, 0);
	}
	return 0;
}
#else
	{       return ::WMenuCount(); }
#endif

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WMenuText(LPCSTR lpcszName, CString& strBuffer)
// Description: A wrapper for the MS-Test function WMenuText. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the menu name.
// Param: strBuffer A CString reference that will contain the name of the menu.
// END_HELP_COMMENT
void CMSTest::WMenuText                 (LPCSTR lpcszName, CString& strBuffer)
#if CMDBAR
{
	HWND hWndActive= ::GetForegroundWindow();
	if(hWndActive)
	{
		ATOM nAtom=GlobalAddAtom(lpcszName);
		ATOM nNewAtom=(ATOM)::SendMessage(hWndActive, DSM_TESTMENU, cMenuText, nAtom);
		GlobalGetAtomName(nNewAtom, strBuffer.GetBufferSetLength(BUFFER), BUFFER); // ugh. We don't know how big strBuffer is.
		strBuffer.ReleaseBuffer(-1) ;
		GlobalDeleteAtom(nAtom);
		GlobalDeleteAtom(nNewAtom);
	}
}
#else
	{ 
	   ::WMenuText((LPSTR)lpcszName, (LPSTR) strBuffer.GetBufferSetLength(BUFFER));
	   strBuffer.ReleaseBuffer(-1) ; }
#endif

//int  WMenuLen           (LPCSTR lpcszName)
//void WMenuFullText      (LPCSTR lpcszName, CString& strBuffer)
//int  WMenuFullLen       (LPCSTR lpcszName)

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WMenuEnd(void)
// Description: A wrapper for the MS-Test function WMenuEnd. See the MS-Test documentation for a description of this function.
// Return: <none>
// END_HELP_COMMENT
void CMSTest::WMenuEnd           (void)
#if CMDBAR
{
	HWND hWndActive= ::GetForegroundWindow();
	if(hWndActive)
	{
		SendMessage(hWndActive, DSM_TESTMENU, cMenuEnd, 0);
	}
}
#else
	{      ::WMenuEnd(); }
#endif

//BOOL WSysMenuExists     (HWND hWnd)
//void WSysMenu           (HWND hWnd)
//int  WMenuNumAltKeys    (void)
//void WMenuGetAltKeys    (CString& strBuff)
//int  WMenuNumDupAltKeys (void)
//void WMenuGetDupAltKeys (CString& strBuff)
//BOOL WMenuSeparator     (int iIndex)

// Obsolete.
//----------
//void WMenuX             (int iIndex)
//BOOL WMenuGrayedX       (int iIndex)
//BOOL WMenuCheckedX      (int iIndex)
//BOOL WMenuEnabledX      (int iIndex)

//---------------------------------------------------------------------------
// Command button routines.
//---------------------------------------------------------------------------

//void WButtonSetClass (LPCSTR lpcszClassName)

// BEGIN_HELP_COMMENT
// Function: BOOL CMSTest::WButtonExists(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WButtonExists. See the MS-Test documentation for a description of this function.
// Return: A Boolean value that indicates whether the button exists.
// Param: lpcszName A pointer to a string that contains the button name.
// END_HELP_COMMENT
BOOL CMSTest::WButtonExists   (LPCSTR lpcszName)
	{       return ::WButtonExists((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: BOOL CMSTest::WButtonEnabled(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WButtonEnabled. See the MS-Test documentation for a description of this function.
// Return: A Boolean value that indicates whether the button is enabled.
// Param: lpcszName A pointer to a string that contains the button name.
// END_HELP_COMMENT
BOOL CMSTest::WButtonEnabled  (LPCSTR lpcszName)
	{       return ::WButtonEnabled((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: BOOL CMSTest::WButtonFocus(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WButtonFocus. See the MS-Test documentation for a description of this function.
// Return: A Boolean value that indicates whether the button has focus.
// Param: lpcszName A pointer to a string that contains the button name.
// END_HELP_COMMENT
BOOL CMSTest::WButtonFocus    (LPCSTR lpcszName)
	{       return ::WButtonFocus((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WButtonClick(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WButtonClick. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the button name.
// END_HELP_COMMENT
void CMSTest::WButtonClick    (LPCSTR lpcszName)
	{       WaitStepInstructions("Click button '%s'", lpcszName);
      ::WButtonClick((LPSTR)lpcszName, TIMEOUT); }

//void WButtonHide     (LPCSTR lpcszName)
//void WButtonShow     (LPCSTR lpcszName)
//void WButtonEnable   (LPCSTR lpcszName)
//void WButtonDisable  (LPCSTR lpcszName)
//BOOL WButtonDefault  (LPCSTR lpcszName)
//int WButtonDefaults (void)

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WButtonSetFocus(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WButtonSetFocus. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the button name.
// END_HELP_COMMENT
void CMSTest::WButtonSetFocus (LPCSTR lpcszName)
	{       WaitStepInstructions("Set focus to button '%s'", lpcszName);
      ::WButtonSetFocus((LPSTR)lpcszName, TIMEOUT); }

//---------------------------------------------------------------------------
// CheckBox routines
//---------------------------------------------------------------------------

//void WCheckSetClass (LPCSTR lpcszClassName)

// BEGIN_HELP_COMMENT
// Function: BOOL CMSTest::WCheckExists(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WCheckExists. See the MS-Test documentation for a description of this function.
// Return: A Boolean value that indicates whether the check box exists.
// Param: lpcszName A pointer to a string that contains the check box name.
// END_HELP_COMMENT
BOOL CMSTest::WCheckExists   (LPCSTR lpcszName)
	{       return ::WCheckExists((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: BOOL CMSTest::WCheckEnabled(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WCheckEnabled. See the MS-Test documentation for a description of this function.
// Return: A Boolean value that indicates whether the check box is enabled.
// Param: lpcszName A pointer to a string that contains the check box name.
// END_HELP_COMMENT
BOOL CMSTest::WCheckEnabled  (LPCSTR lpcszName)
	{       return ::WCheckEnabled((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: BOOL CMSTest::WCheckFocus(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WCheckFocus. See the MS-Test documentation for a description of this function.
// Return: A Boolean value that indicates whether the check box has focus.
// Param: lpcszName A pointer to a string that contains the check box name.
// END_HELP_COMMENT
BOOL CMSTest::WCheckFocus    (LPCSTR lpcszName)
	{       return ::WCheckFocus((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: int CMSTest::WCheckState(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WCheckState. See the MS-Test documentation for a description of this function.
// Return: An integer value that indicates the state of the check box.
// Param: lpcszName A pointer to a string that contains the check box name.
// END_HELP_COMMENT
int  CMSTest::WCheckState    (LPCSTR lpcszName)
	{       return ::WCheckState((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WCheckClick(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WCheckClick. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the check box name.
// END_HELP_COMMENT
void CMSTest::WCheckClick    (LPCSTR lpcszName)
	{       WaitStepInstructions("Click checkbox '%s'", lpcszName);
      ::WCheckClick((LPSTR)lpcszName, TIMEOUT); }

//void WCheckHide     (LPCSTR lpcszName)
//void WCheckShow     (LPCSTR lpcszName)
//void WCheckEnable   (LPCSTR lpcszName)
//void WCheckDisable  (LPCSTR lpcszName)

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WCheckCheck(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WCheckCheck. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the check box name.
// END_HELP_COMMENT
void CMSTest::WCheckCheck    (LPCSTR lpcszName)
	{       WaitStepInstructions("Check checkbox '%s'", lpcszName);
      ::WCheckCheck((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WCheckUnCheck(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WCheckUnCheck. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the check box name.
// END_HELP_COMMENT
void CMSTest::WCheckUnCheck  (LPCSTR lpcszName)
	{       WaitStepInstructions("Uncheck checkbox '%s'", lpcszName);
      ::WCheckUnCheck((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WCheckSetFocus(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WCheckSetFocus. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the check box name.
// END_HELP_COMMENT
void CMSTest::WCheckSetFocus (LPCSTR lpcszName)
	{       WaitStepInstructions("Set focus to checkbox '%s'", lpcszName);
      ::WCheckSetFocus((LPSTR)lpcszName, TIMEOUT); }

//---------------------------------------------------------------------------
// Option Button routines
//---------------------------------------------------------------------------

//void WOptionSetClass (LPCSTR lpcszClassName)

// BEGIN_HELP_COMMENT
// Function: BOOL CMSTest::WOptionExists(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WOptionExists. See the MS-Test documentation for a description of this function.
// Return: A Boolean value that indicates whether the radio button exists.
// Param: lpcszName A pointer to a string that contains the radio button name.
// END_HELP_COMMENT
BOOL CMSTest::WOptionExists   (LPCSTR lpcszName)
	{       return ::WOptionExists((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: BOOL CMSTest::WOptionEnabled(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WOptionEnabled. See the MS-Test documentation for a description of this function.
// Return: A Boolean value that indicates whether the radio button is enabled.
// Param: lpcszName A pointer to a string that contains the radio button name.
// END_HELP_COMMENT
BOOL CMSTest::WOptionEnabled  (LPCSTR lpcszName)
	{       return ::WOptionEnabled((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: BOOL CMSTest::WOptionFocus(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WOptionFocus. See the MS-Test documentation for a description of this function.
// Return: A Boolean value that indicates whether the radio button has focus.
// Param: lpcszName A pointer to a string that contains the radio button name.
// END_HELP_COMMENT
BOOL CMSTest::WOptionFocus    (LPCSTR lpcszName)
	{       return ::WOptionFocus((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: int CMSTest::WOptionState(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WOptionState. See the MS-Test documentation for a description of this function.
// Return: An integer that contains the state of the radio button.
// Param: lpcszName A pointer to a string that contains the radio button name.
// END_HELP_COMMENT
int  CMSTest::WOptionState    (LPCSTR lpcszName)
	{       return ::WOptionState((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WOptionClick(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WOptionClick. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the radio button name.
// END_HELP_COMMENT
void CMSTest::WOptionClick    (LPCSTR lpcszName)
	{       WaitStepInstructions("Click radio button '%s'", lpcszName);
      ::WOptionClick((LPSTR)lpcszName, TIMEOUT); }

//void WOptionHide     (LPCSTR lpcszName)
//void WOptionShow     (LPCSTR lpcszName)
//void WOptionEnable   (LPCSTR lpcszName)
//void WOptionDisable  (LPCSTR lpcszName)

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WOptionSelect(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WOptionSelect. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the radio button name.
// END_HELP_COMMENT
void CMSTest::WOptionSelect   (LPCSTR lpcszName)
	{       WaitStepInstructions("Select radio button '%s'", lpcszName);
      ::WOptionSelect((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WOptionSetFocus(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WOptionSetFocus. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the radio button name.
// END_HELP_COMMENT
void CMSTest::WOptionSetFocus (LPCSTR lpcszName)
	{       WaitStepInstructions("Set focus to radio button '%s'", lpcszName);
      ::WOptionSetFocus((LPSTR)lpcszName, TIMEOUT); }

//---------------------------------------------------------------------------
// Listbox routines
//---------------------------------------------------------------------------

 void CMSTest::WListSetClass (LPCSTR lpszClassName)
	{ ::WListSetClass((LPSTR)lpszClassName); }

// BEGIN_HELP_COMMENT
// Function: BOOL CMSTest::WListExists(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WListExists. See the MS-Test documentation for a description of this function.
// Return: A Boolean value that indicates whether the list box exists.
// Param: lpcszName A pointer to a string that contains the list box name.
// END_HELP_COMMENT
BOOL CMSTest::WListExists       (LPCSTR lpcszName)
	{       return ::WListExists((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: int  CMSTest::WListCount(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WListCount. See the MS-Test documentation for a description of this function.
// Return: An integer that contains the number of items in the list.
// Param: lpcszName A pointer to a string that contains the list box name.
// END_HELP_COMMENT
int  CMSTest::WListCount        (LPCSTR lpcszName)
	{       return ::WListCount((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WListText(LPCSTR lpcszName, CString& strBuffer)
// Description: A wrapper for the MS-Test function WListText. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the list box name.
// Param: strBuffer A CString reference that will contain the text of the list box.
// END_HELP_COMMENT
void CMSTest::WListText         (LPCSTR lpcszName, CString& strBuffer)
	{      ::WListText((LPSTR)lpcszName,  strBuffer.GetBufferSetLength(BUFFER), TIMEOUT);
			strBuffer.ReleaseBuffer(-1) ; }

// BEGIN_HELP_COMMENT
// Function: int  CMSTest::WListLen(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WListLen. See the MS-Test documentation for a description of this function.
// Return: An integer that specifies the length of the list.
// Param: lpcszName A pointer to a string that contains the list box name.
// END_HELP_COMMENT
int  CMSTest::WListLen          (LPCSTR lpcszName)
	{       return ::WListLen((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: int  CMSTest::WListIndex(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WListIndex. See the MS-Test documentation for a description of this function.
// Return: An integer that specifies the index.
// Param: lpcszName A pointer to a string that contains the list box name.
// END_HELP_COMMENT
int  CMSTest::WListIndex        (LPCSTR lpcszName)
	{       return ::WListIndex((LPSTR)lpcszName, TIMEOUT); }

//int  WListTopIndex     (LPCSTR lpcszName)

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WListItemText(LPCSTR lpcszName, int iIndex, CString& strBuffer)
// Description: A wrapper for the MS-Test function WListItemText. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the list box name.
// Param: iIndex An integer that specifies the 1-based index into the list box.
// Param: strBuffer A CString reference that will contain the text of the list box item.
// END_HELP_COMMENT
void CMSTest::WListItemText     (LPCSTR lpcszName, int iIndex, CString& strBuffer)
	{   
     ::WListItemText((LPSTR)lpcszName, iIndex, strBuffer.GetBufferSetLength(BUFFER), TIMEOUT);
		strBuffer.ReleaseBuffer(-1) ; }

// BEGIN_HELP_COMMENT
// Function: int  CMSTest::WListItemLen(LPCSTR lpcszName, int iIndex)
// Description: A wrapper for the MS-Test function WListItemLen. See the MS-Test documentation for a description of this function.
// Return: An integer that contains the length of the list box item.
// Param: lpcszName A pointer to a string that contains the list box name.
// Param: iIndex An integer that specififes the 1-based index into the list box.
// END_HELP_COMMENT
int  CMSTest::WListItemLen      (LPCSTR lpcszName, int iIndex)
	{       return ::WListItemLen((LPSTR)lpcszName, iIndex, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: int CMSTest::WListItemExists(LPCSTR lpcszName, LPCSTR lpcszItem)
// Description: A wrapper for the MS-Test function WListItemExists. See the MS-Test documentation for a description of this function.
// Return: An integer that indicates whether the list box item exists.
// Param: lpcszName A pointer to a string that contains the list box name.
// Param: lpcszItem A pointer to a string that contains the name of the list box item.
// END_HELP_COMMENT
int  CMSTest::WListItemExists   (LPCSTR lpcszName, LPCSTR lpcszItem)
	{ 
		int nitems=WListCount(lpcszName);
#ifdef _DEBUG
		LOG->Comment("Trying CMSTest::List(%s) ItemExists(%s):%d items...",
			lpcszName,lpcszItem,nitems);
#endif
		char strItem[1024]; //should be enough
		int item;
		for(item=1;item<=nitems;item++)
		{			
//			WListItemText(lpcszName, item, strItem); does not work quite, we need shorter timeout
			::WListItemText((LPSTR)lpcszName, item, strItem, 20); //enough timeout
			if(strcmp(lpcszItem,strItem)!=0)
			{
#ifdef _DEBUG
				LOG->Comment("\tItem#%d: (%s), no match...",item,strItem);
#endif
			}
			else
			{
#ifdef _DEBUG
				LOG->Comment("\tItem#%d: (%s), Found!!!",item,strItem);
#endif
				return item;
			}
		}
		return 0;
//	this MSTEST40 function not work here 
//	return ::WListItemExists((LPSTR)lpcszName, (LPSTR)lpcszItem, TIMEOUT); 
	}

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WListItemClk(LPCSTR lpcszName, int iIndex, int nOffset /*=0*/)
// Description: A wrapper for the MS-Test function WListItemClk. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the list box name.
// Param: iIndex An integer that specifies the 1-based index of the list box item.
// Param: nOffset An integer that specifies the offset. (Default value is 0.)
// END_HELP_COMMENT
void CMSTest::WListItemClk (LPCSTR lpcszName, int iIndex, int nOffset /*=0*/)
	{       char acBuf[10];
		wsprintf(acBuf, "@%d", iIndex);
		WaitStepInstructions("Click item #%d of listbox '%s'", iIndex, lpcszName);
		::WListItemClkEx((LPSTR)lpcszName, acBuf, nOffset, TIMEOUT); 
	}

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WListItemClk(LPCSTR lpcszName, LPCSTR szItem, int nOffset /*=0*/)
// Description: A wrapper for the MS-Test function WListItemClk. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the list box name.
// Param: szItem A pointer to a string taht contains the name of the list box item.
// Param: nOffset An integer that specifies the offset. (Default value is 0.)
// END_HELP_COMMENT
void CMSTest::WListItemClk  (LPCSTR lpcszName, LPCSTR szItem, int nOffset /*=0*/)
	{       WaitStepInstructions("Click item '%s' of listbox '%s'", szItem, lpcszName);
//      ::WListItemClkEx((LPSTR)lpcszName, (LPSTR)szItem, nOffset); }
      ::WListItemClkEx((LPSTR)lpcszName, (LPSTR)szItem, nOffset, TIMEOUT); }


// BEGIN_HELP_COMMENT
// Function: void CMSTest::WListItemCtrlClk(LPCSTR lpcszName, int iIndex, int nOffset /*=0*/)
// Description: A wrapper for the MS-Test function WListItemCtrlClk. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the list box name.
// Param: iIndex An integer that specifies the 1-based index of the list box item.
// Param: nOffset An integer that specifies the offset. (Default value is 0.)
// END_HELP_COMMENT
void CMSTest::WListItemCtrlClk  (LPCSTR lpcszName, int iIndex, int nOffset /*=0*/)
	{       char acBuf[10];
		wsprintf(acBuf, "@%d", iIndex);
		WaitStepInstructions("Ctrl-click item #%d of listbox '%s'", iIndex, lpcszName);
      ::WListItemCtrlClkEx((LPSTR)lpcszName, acBuf, nOffset,TIMEOUT); 
	}


// BEGIN_HELP_COMMENT
// Function: void CMSTest::WListItemCtrlClk(LPCSTR lpcszName, LPCSTR szItem, int nOffset /*=0*/)
// Description: A wrapper for the MS-Test function WListItemCtrlClk. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the list box name.
// Param: szItem A pointer to a string taht contains the name of the list box item.
// Param: nOffset An integer that specifies the offset. (Default value is 0.)
// END_HELP_COMMENT
void CMSTest::WListItemCtrlClk  (LPCSTR lpcszName, LPCSTR szItem, int nOffset /*=0*/)
	{       WaitStepInstructions("Ctrl-click item '%s' of listbox '%s'", szItem, lpcszName);
      ::WListItemCtrlClkEx((LPSTR)lpcszName, (LPSTR)szItem, nOffset, TIMEOUT); }


// BEGIN_HELP_COMMENT
// Function: void CMSTest::WListItemShftClk(LPCSTR lpcszName, int iIndex, int nOffset /*=0*/)
// Description: A wrapper for the MS-Test function WListItemShftClk. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the list box name.
// Param: iIndex An integer that specifies the 1-based index of the list box item.
// Param: nOffset An integer that specifies the offset. (Default value is 0.)
// END_HELP_COMMENT
void CMSTest::WListItemShftClk  (LPCSTR lpcszName, int iIndex, int nOffset /*=0*/)
	{       char acBuf[10];
		wsprintf(acBuf, "@%d", iIndex);
		WaitStepInstructions("Shift-click item #%d of listbox '%s'", iIndex, lpcszName);
      ::WListItemShftClkEx((LPSTR)lpcszName, acBuf, nOffset, TIMEOUT);
	}


// BEGIN_HELP_COMMENT
// Function: void CMSTest::WListItemShftClk(LPCSTR lpcszName, LPCSTR szItem, int nOffset /*=0*/)
// Description: A wrapper for the MS-Test function WListItemShftClk. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the list box name.
// Param: szItem A pointer to a string taht contains the name of the list box item.
// Param: nOffset An integer that specifies the offset. (Default value is 0.)
// END_HELP_COMMENT
void CMSTest::WListItemShftClk  (LPCSTR lpcszName, LPCSTR szItem, int nOffset /*=0*/)
	{       WaitStepInstructions("Shift-click item '%s' of listbox '%s'", szItem, lpcszName);
      ::WListItemShftClkEx((LPSTR)lpcszName, (LPSTR)szItem, nOffset, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WListItemDblClk(LPCSTR lpcszName, int iIndex, int nOffset /*=0*/)
// Description: A wrapper for the MS-Test function WListItemDblClk. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the list box name.
// Param: iIndex An integer that specifies the 1-based index of the list box item.
// Param: nOffset An integer that specifies the offset. (Default value is 0.)
// END_HELP_COMMENT
void CMSTest::WListItemDblClk  (LPCSTR lpcszName, int iIndex, int nOffset /*=0*/)
	{       char acBuf[10];
		wsprintf(acBuf, "@%d", iIndex);
		WaitStepInstructions("Double-click item #%d of listbox '%s'", iIndex, lpcszName);
      ::WListItemDblClkEx((LPSTR)lpcszName, acBuf, nOffset, TIMEOUT);
	}
      
// BEGIN_HELP_COMMENT
// Function: void CMSTest::WListItemDblClk(LPCSTR lpcszName, LPCSTR szItem, int nOffset /*=0*/)
// Description: A wrapper for the MS-Test function WListItemDblClk. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the list box name.
// Param: szItem A pointer to a string taht contains the name of the list box item.
// Param: nOffset An integer that specifies the offset. (Default value is 0.)
// END_HELP_COMMENT
void CMSTest::WListItemDblClk  (LPCSTR lpcszName, LPCSTR szItem, int nOffset /*=0*/)
	{       WaitStepInstructions("Double-click item '%s' of listbox '%s'", szItem, lpcszName);
      ::WListItemDblClkEx((LPSTR)lpcszName, (LPSTR)szItem, nOffset, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: int CMSTest::WListSelCount(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WListSelCount. See the MS-Test documentation for a description of this function.
// Return: An integer that contains the number of selected items in the list box.
// Param: lpcszName A pointer to a string that contains the list box name.
// END_HELP_COMMENT
int  CMSTest::WListSelCount     (LPCSTR lpcszName)
	{       return ::WListSelCount((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WListSelItems(LPCSTR lpcszName, LPINT lpIntArray)
// Description: A wrapper for the MS-Test function WListSelItems. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the list box name.
// Param: lpIntArray An array of integers that specifies the items to select in the list box.
// END_HELP_COMMENT
void CMSTest::WListSelItems     (LPCSTR lpcszName, LPINT lpIntArray)
	{      ::WListSelItems((LPSTR)lpcszName, lpIntArray, TIMEOUT); }

//void WListClear        (LPCSTR lpcszName)
//void WListAddItem      (LPCSTR lpcszName, LPCSTR lpcszItem)
//void WListDelItem      (LPCSTR lpcszName, int iIndex)
//void WListDelItem      (LPCSTR lpcszName, LPCSTR lpcszItem)

// BEGIN_HELP_COMMENT
// Function: BOOL CMSTest::WListEnabled(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WListEnabled. See the MS-Test documentation for a description of this function.
// Return: A Boolean value that indicates whether the list box is enabled.
// Param: lpcszName A pointer to a string that contains the list box name.
// END_HELP_COMMENT
BOOL CMSTest::WListEnabled      (LPCSTR lpcszName)
	{       return ::WListEnabled((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WListSetFocus(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WListSetFocus. See the MS-Test documentation for a description of this function.
// Return: <void>
// Param: lpcszName A pointer to a string that contains the list box name.
// END_HELP_COMMENT
void CMSTest::WListSetFocus     (LPCSTR lpcszName)
	{       WaitStepInstructions("Set focus to listbox '%s'", lpcszName);
      ::WListSetFocus((LPSTR)lpcszName, TIMEOUT); }

//---------------------------------------------------------------------------
// ListView routines
//---------------------------------------------------------------------------

// BEGIN_HELP_COMMENT
// Function: int  CMSTest::WViewCount(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WListCount. See the MS-Test documentation for a description of this function.
// Return: An integer that contains the number of items in the list.
// Param: lpcszName A pointer to a string that contains the list box name.
// END_HELP_COMMENT
int  CMSTest::WViewCount        (LPCSTR lpcszName)
	{       return ::WViewCount((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: BOOL CMSTest::WListEnabled(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WViewEnabled. See the MS-Test documentation for a description of this function.
// Return: A Boolean value that indicates whether the listview is enabled.
// Param: lpcszName A pointer to a string that contains the listview name.
// END_HELP_COMMENT
BOOL CMSTest::WViewEnabled      (LPCSTR lpcszName)
	{       return ::WViewEnabled((LPSTR)lpcszName, TIMEOUT); }


// BEGIN_HELP_COMMENT
// Function: void CMSTest::WViewSetFocus(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WViewSetFocus. See the MS-Test documentation for a description of this function.
// Return: <void>
// Param: lpcszName A pointer to a string that contains the listview name.
// END_HELP_COMMENT
void CMSTest::WViewSetFocus     (LPCSTR lpcszName)
	{       WaitStepInstructions("Set focus to listview '%s'", lpcszName);
      ::WViewSetFocus((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WViewSelItem(LPCSTR lpcszName, LPINT lpIntArray)
// Description: A wrapper for the MS-Test function WViewSelItems. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the listview name.
// Param: lpcszItem ListView item name
// END_HELP_COMMENT
int CMSTest::WViewSelItem     (LPCSTR lpcszName, LPCSTR lpcszItem)
	{      return ::WViewSelItem((LPSTR)lpcszName, (LPSTR)lpcszItem, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WViewItemClk(LPCSTR lpcszName, LPCSTR lpcszItem)
// Description: A wrapper for the MS-Test function WViewItemClk. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the listview name.
// Param: lpcszItem ListView item name
// END_HELP_COMMENT
void CMSTest::WViewItemClk (LPCSTR lpcszName, LPCSTR lpcszItem)
	{       
		WaitStepInstructions("Click item '%s' of listview '%s'", lpcszItem, lpcszName);
		::WViewItemClk((LPSTR)lpcszName, (LPSTR)lpcszItem, VK_LBUTTON, TIMEOUT); 
	}

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WViewItemClk(LPCSTR lpcszName, int iIndex)
// Description: A wrapper for the MS-Test function WViewItemClk. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the listview name.
// Param: iIndex An integer that specifies the 1-based index of the listview item.
// END_HELP_COMMENT
void CMSTest::WViewItemClk (LPCSTR lpcszName, int iIndex)
	{       char acBuf[10];
		wsprintf(acBuf, "@%d", iIndex);
		WaitStepInstructions("Click item #%d of listview '%s'", iIndex, lpcszName);
		::WViewItemClk((LPSTR)lpcszName, acBuf, VK_LBUTTON, TIMEOUT); 
	}

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WViewItemExists(LPCSTR lpcszName, LPINT lpIntArray)
// Description: A wrapper for the MS-Test function WViewItemExists. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the listview name.
// Param: lpcszItem ListView item name
// END_HELP_COMMENT
BOOL CMSTest::WViewItemExists	(LPCSTR lpcszName,  LPCSTR lpcszItem)
	{      return (WViewItemIndex(lpcszName, lpcszItem)>0); } //::WViewItemExists does not work here

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WViewItemIndex(LPCSTR lpcszName, LPINT lpIntArray)
// Description: A wrapper for the MS-Test function WViewItemIndex. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the listview name.
// Param: lpcszItem ListView item name
// END_HELP_COMMENT
int  CMSTest::WViewItemIndex	(LPCSTR lpcszName,  LPCSTR lpcszItem)
	{      return ::WViewItemIndex((LPSTR)lpcszName, (LPSTR)lpcszItem, TIMEOUT); }
//---------------------------------------------------------------------------
// Combobox routines
//---------------------------------------------------------------------------

//void WComboSetClass    (LPCSTR lpcszName)
//void WComboSetLBClass  (LPCSTR lpcszName)

// BEGIN_HELP_COMMENT
// Function: BOOL CMSTest::WComboExists(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WComboExists. See the MS-Test documentation for a description of this function.
// Return: A Boolean value that indicates whether the combo box exists.
// Param: lpcszName A pointer to a string that contains the combo box name.
// END_HELP_COMMENT
BOOL CMSTest::WComboExists      (LPCSTR lpcszName)
	{       return ::WComboExists((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: int CMSTest::WComboCount(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WComboCount. See the MS-Test documentation for a description of this function.
// Return: An integer that contains the number of items in the combo box.
// Param: lpcszName A pointer to a string that contains the combo box name.
// END_HELP_COMMENT
int  CMSTest::WComboCount       (LPCSTR lpcszName)
	{       return ::WComboCount((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WComboText(LPCSTR lpcszName, CString& strBuff)
// Description: A wrapper for the MS-Test function WComboText. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the combo box name.
// Param: strBuff A CString reference that will contain the text of the combo box.
// END_HELP_COMMENT
void CMSTest::WComboText        (LPCSTR lpcszName, CString& strBuff)
	{      ::WComboText((LPSTR)lpcszName, strBuff.GetBufferSetLength(BUFFER), TIMEOUT);
		strBuff.ReleaseBuffer(-1); }

// BEGIN_HELP_COMMENT
// Function: int  CMSTest::WComboLen(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WComboLen. See the MS-Test documentation for a description of this function.
// Return: An integer that contains the length of the combo box.
// Param: lpcszName A pointer to a string that contains the combo box name.
// END_HELP_COMMENT
int  CMSTest::WComboLen         (LPCSTR lpcszName)
	{       return ::WComboLen((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: int  CMSTest::WComboIndex(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WComboIndex. See the MS-Test documentation for a description of this function.
// Return: An integer that contains the combo box index.
// Param: lpcszName A pointer to a string that contains the combo box name.
// END_HELP_COMMENT
int  CMSTest::WComboIndex       (LPCSTR lpcszName)
	{       return ::WComboIndex((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WComboSetText (LPCSTR lpcszName, LPCSTR lpcszText)
// Description: A wrapper for the MS-Test function WComboSetText. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the combo box name.
// Param: lpcszText A pointer to a string that contains the text to set in the combo box.
// END_HELP_COMMENT
void CMSTest::WComboSetText (LPCSTR lpcszName, LPCSTR lpcszText)
	{
	WaitStepInstructions("Set text of combobox '%s' to '%s'", lpcszName, lpcszText);
	//::WComboSetFocus((LPSTR)lpcszName, TIMEOUT);
	//DoKeys(lpcszText,TRUE);
	::WComboSetText((LPSTR)lpcszName, (LPSTR)lpcszText, TIMEOUT);
	}

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WComboSelText(LPCSTR lpcszName, CString& strBuff)
// Description: A wrapper for the MS-Test function WComboSelText. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the combo box name.
// Param: strBuff A CString reference that will contain the selected text in the combo box.
// END_HELP_COMMENT
void CMSTest::WComboSelText     (LPCSTR lpcszName, CString& strBuff)
	{ 
		::WComboSelText((LPSTR)lpcszName, strBuff.GetBufferSetLength(BUFFER), TIMEOUT);
		strBuff.ReleaseBuffer(-1); }

// BEGIN_HELP_COMMENT
// Function: int CMSTest::WComboSelLen(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WComboSelLen. See the MS-Test documentation for a description of this function.
// Return: An integer that contains the length of the selected text in the combo box.
// Param: lpcszName A pointer to a string that contains the combo box name.
// END_HELP_COMMENT
int  CMSTest::WComboSelLen      (LPCSTR lpcszName)
	{       return ::WComboSelLen((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WComboItemText(LPCSTR lpcszName, int iIndex, CString& strBuff)
// Description: A wrapper for the MS-Test function WComboItemText. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the combo box name.
// Param: iIndex An integer that specifies the 1-based index of the combo box item.
// Param: strBuff A CString reference that will contain the text of the combo box item.
// END_HELP_COMMENT
void CMSTest::WComboItemText    (LPCSTR lpcszName, int iIndex, CString& strBuff)
	{ ::WComboItemText((LPSTR)lpcszName, iIndex, strBuff.GetBufferSetLength(BUFFER), TIMEOUT);
		strBuff.ReleaseBuffer(-1); }

// BEGIN_HELP_COMMENT
// Function: int CMSTest::WComboItemLen(LPCSTR lpcszName, int iIndex)
// Description: A wrapper for the MS-Test function WComboItemLen. See the MS-Test documentation for a description of this function.
// Return: An integer that contains the length of the combo box item.
// Param: lpcszName A pointer to a string that contains the combo box name.
// Param: iIndex An integer that specifies the 1-based index of the combo box item.
// END_HELP_COMMENT
int  CMSTest::WComboItemLen     (LPCSTR lpcszName, int iIndex)
	{       return ::WComboItemLen((LPSTR)lpcszName, iIndex, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: int CMSTest::WComboItemExists(LPCSTR lpcszName, LPCSTR lpcszItem)
// Description: A wrapper for the MS-Test function WComboItemExists. See the MS-Test documentation for a description of this function.
// Return: An integer that indicates whether the combo box item exists.
// Param: lpcszName A pointer to a string that contains the combo box name.
// Param: lpcszItem A pointer to a string that contains the name of the combo box item.
// END_HELP_COMMENT
int  CMSTest::WComboItemExists  (LPCSTR lpcszName, LPCSTR lpcszItem)
	{
		int nitems=WComboCount(lpcszName);
#ifdef _DEBUG
		LOG->Comment("Trying CMSTest::Combo(%s) ItemExists(%s):%d items...",
			lpcszName,lpcszItem,nitems);
#endif
		char strItem[1024];
		int item;
		for(item=1;item<=nitems;item++)
		{			
//			WComboItemText(lpcszName, item, strItem); does not work quite, we need shorter timeout
			::WComboItemText((LPSTR)lpcszName, item, strItem, 20); //shld be enough
			if(strcmp(lpcszItem,strItem)!=0)
			{
#ifdef _DEBUG
				LOG->Comment("\tItem#%d: (%s), no match...",item,strItem);
#endif
			}
			else
			{
#ifdef _DEBUG
				LOG->Comment("\tItem#%d: (%s), Found!!!",item,strItem);
#endif
				return item;
			}
		}
		return 0;
//	this MSTEST40 function not work here 
//	return ::WComboItemExists((LPSTR)lpcszName, (LPSTR)lpcszItem, TIMEOUT);
	}

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WComboItemClk(LPCSTR lpcszName, int iIndex)
// Description: A wrapper for the MS-Test function WComboItemClk. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the combo box name.
// Param: iIndex An integer that specifies the 1-based index of the combo box item.
// END_HELP_COMMENT
void CMSTest::WComboItemClk(LPCSTR lpcszName, int iIndex)
	{       char acBuf[10];
		wsprintf(acBuf, "@%d", iIndex);
		WaitStepInstructions("Click item #%d of combobox '%s'", iIndex, lpcszName);
      ::WComboItemClk((LPSTR)lpcszName, acBuf, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WComboItemClk(LPCSTR lpcszName, LPCSTR szItem)
// Description: A wrapper for the MS-Test function WComboItemClk. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the combo box name.
// Param: szItem A pointer to a string that contains the name of the combo box item.
// END_HELP_COMMENT
void CMSTest::WComboItemClk(LPCSTR lpcszName, LPCSTR szItem)
	{       WaitStepInstructions("Click item '%s' of combobox '%s'", szItem, lpcszName);
      ::WComboItemClk((LPSTR)lpcszName, (LPSTR)szItem, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WComboItemDblClk(LPCSTR lpcszName, int iIndex)
// Description: A wrapper for the MS-Test function WComboItemDblClk. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the combo box name.
// Param: iIndex An integer that specifies the 1-based index of the combo box item.
// END_HELP_COMMENT
void CMSTest::WComboItemDblClk(LPCSTR lpcszName, int iIndex)
	{       char acBuf[10];
		wsprintf(acBuf, "@%d", iIndex);
		WaitStepInstructions("Double-click item #%d of combobox '%s'", iIndex, lpcszName);
      ::WComboItemDblClk((LPSTR)lpcszName, acBuf, TIMEOUT); }
// BEGIN_HELP_COMMENT
// Function: void CMSTest::WComboItemDblClk(LPCSTR lpcszName, LPCSTR szItem)
// Description: A wrapper for the MS-Test function WComboItemDblClk. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the combo box name.
// Param: szItem A pointer to a string that contains the name of the combo box item.
// END_HELP_COMMENT
void CMSTest::WComboItemDblClk(LPCSTR lpcszName, LPCSTR szItem)
	{       WaitStepInstructions("Double-click item '%s' of combobox '%s'", szItem, lpcszName);
      ::WComboItemDblClk((LPSTR)lpcszName, (LPSTR)szItem, TIMEOUT); }

//void WComboClear       (LPCSTR lpcszName)
//void WComboAddItem     (LPCSTR lpcszName, LPCSTR lpcszText)
//void WComboDelItem     (LPCSTR lpcszName, int iIndex)
//void WComboDelItem     (LPCSTR lpcszName, LPCSTR lpcszItem)

// BEGIN_HELP_COMMENT
// Function: BOOL CMSTest::WComboEnabled(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WComboEnabled. See the MS-Test documentation for a description of this function.
// Return: A Boolean value that indicates whether the combo box is enabled.
// Param: lpcszName A pointer to a string that contains the combo box name.
// END_HELP_COMMENT
BOOL CMSTest::WComboEnabled     (LPCSTR lpcszName)
	{       return ::WComboEnabled((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WComboSetFocus(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WComboSetFocus. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the combo box name.
// END_HELP_COMMENT
void CMSTest::WComboSetFocus    (LPCSTR lpcszName)
	{       WaitStepInstructions("Set focus to combobox '%s'", lpcszName);
      ::WComboSetFocus((LPSTR)lpcszName, TIMEOUT); }

//---------------------------------------------------------------------------
// Editbox routines
//---------------------------------------------------------------------------

//void WEditSetClass (LPCSTR lpcszClassName)

// BEGIN_HELP_COMMENT
// Function: BOOL CMSTest::WEditExists(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WEditExists. See the MS-Test documentation for a description of this function.
// Return: A Boolean value that indicates whether the edit box exists.
// Param: lpcszName A pointer to a string that contains the edit box name.
// END_HELP_COMMENT
BOOL CMSTest::WEditExists   (LPCSTR lpcszName)
	{       return ::WEditExists((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: long CMSTest::WEditLen(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WEditLen. See the MS-Test documentation for a description of this function.
// Return: A long that contains the length of the text in the edit box.
// Param: lpcszName A pointer to a string that contains the edit box name.
// END_HELP_COMMENT
long CMSTest::WEditLen      (LPCSTR lpcszName)
	{       return ::WEditLen((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WEditText(LPCSTR lpcszName, CString& strBuff)
// Description: A wrapper for the MS-Test function WEditText. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the edit box name.
// Param: strBuff A CString reference that will contain the text from the edit box.
// END_HELP_COMMENT
void CMSTest::WEditText     (LPCSTR lpcszName, CString& strBuff)
	{ ::WEditText((LPSTR)lpcszName, strBuff.GetBufferSetLength(BUFFER), TIMEOUT);
		strBuff.ReleaseBuffer(-1); }

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WEditSetText(LPCSTR lpcszName, LPCSTR lpcszText)
// Description: A wrapper for the MS-Test function WEditSetText. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the edit box name.
// Param: lpcszText A pointer to a string that contains the text to set in the edit box.
// END_HELP_COMMENT
void CMSTest::WEditSetText  (LPCSTR lpcszName, LPCSTR lpcszText)
	{       WaitStepInstructions("Set text of edit '%s' to '%s'", lpcszName, lpcszText);
      ::WEditSetText((LPSTR)lpcszName, (LPSTR)lpcszText, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WEditSelText(LPCSTR lpcszName, CString& strBuff)
// Description: A wrapper for the MS-Test function WEditSelText. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the edit box name.
// Param: strBuff A CString reference that will contain the selected text in the edit box.
// END_HELP_COMMENT
void CMSTest::WEditSelText  (LPCSTR lpcszName, CString& strBuff)
	{ 
		::WEditSetText((LPSTR)lpcszName, strBuff.GetBufferSetLength(BUFFER), TIMEOUT);
		strBuff.ReleaseBuffer(-1); }

// BEGIN_HELP_COMMENT
// Function: long CMSTest::WEditSelLen(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WEditSelLen. See the MS-Test documentation for a description of this function.
// Return: A long that contains the length of the selected text in the edit box.
// Param: lpcszName A pointer to a string that contains the edit box name.
// END_HELP_COMMENT
long CMSTest::WEditSelLen   (LPCSTR lpcszName)
	{       return ::WEditSelLen((LPSTR)lpcszName, TIMEOUT); }

//void WEditLineText (LPCSTR lpcszName, long lIndex, CString& strBuff)
//long WEditLineLen  (LPCSTR lpcszName, long lIndex)
//long WEditPos      (LPCSTR lpcszName)
//long WEditLine     (LPCSTR lpcszName)
//long WEditChar     (LPCSTR lpcszName)
//long WEditFirst    (LPCSTR lpcszName)
//long WEditLines    (LPCSTR lpcszName)

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WEditClick(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WEditClick. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the edit box name.
// END_HELP_COMMENT
void CMSTest::WEditClick    (LPCSTR lpcszName)
	{       WaitStepInstructions("Click edit '%s'", lpcszName);
      ::WEditClick((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: BOOL CMSTest::WEditEnabled(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WEditEnabled. See the MS-Test documentation for a description of this function.
// Return: A Boolean value that indicates whether the edit box is enabled.
// Param: lpcszName A pointer to a string that contains the edit box name.
// END_HELP_COMMENT
BOOL CMSTest::WEditEnabled  (LPCSTR lpcszName)
	{       return ::WEditEnabled((LPSTR)lpcszName, TIMEOUT); }

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WEditSetFocus(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WEditSetFocus. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the edit box name.
// END_HELP_COMMENT
void CMSTest::WEditSetFocus (LPCSTR lpcszName)
	{       WaitStepInstructions("Set focus to edit '%s'", lpcszName);
      ::WEditSetFocus((LPSTR)lpcszName, TIMEOUT); }

//---------------------------------------------------------------------------
// Static control routines
//---------------------------------------------------------------------------

// BEGIN_HELP_COMMENT
// Function: BOOL CMSTest::WStaticExists(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WStaticExists. See the MS-Test documentation for a description of this function.
// Return: A Boolean value that indicates whether the static control exists.
// Param: lpcszName A pointer to a string that contains the static control's name.
// END_HELP_COMMENT
BOOL CMSTest::WStaticExists   (LPCSTR lpcszName)
	{       
	WaitStepInstructions("Looking for Static Control '%s'", lpcszName);
    if(::WFndWndC((LPSTR)lpcszName, (LPSTR)"STATIC", FW_PART|FW_ACTIVE, TIMEOUT)!=NULL)
		return TRUE;
	return FALSE;
//WStaticExists is not exported from MSTEST40
//	return ::WStaticExists((LPSTR)lpcszName, TIMEOUT) ;
	}
		
// BEGIN_HELP_COMMENT
// Function: long CMSTest::WStaticLen(LPCSTR lpcszName)
// Description: A wrapper for the MS-Test function WStaticLen. See the MS-Test documentation for a description of this function.
// Return: A long that contains the length of the static control.
// Param: lpcszName A pointer to a string that contains the static control's name.
// END_HELP_COMMENT
//MSTEST40.DLL does not export WStaticLen
//long CMSTest::WStaticLen         (LPCSTR lpcszName)
//	{       return ::WStaticLen         ((LPSTR) lpcszName, TIMEOUT) ;}

// BEGIN_HELP_COMMENT
// Function: void CMSTest::WStaticText(LPCSTR lpcszName, CString& strBuff)
// Description: A wrapper for the MS-Test function WStaticText. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: lpcszName A pointer to a string that contains the static control's name.
// Param: strBuff A CString reference that will contain the text from the static control.
// END_HELP_COMMENT
void CMSTest::WStaticText     (LPCSTR lpcszName, CString& strBuff)
	{
		HWND hwnd=::WFndWndC((LPSTR)lpcszName, (LPSTR)"STATIC", FW_ACTIVE, TIMEOUT);
		if(hwnd!=NULL)
		    WGetText(hwnd, strBuff);
//	    ::WStaticText((LPSTR)lpcszName, strBuff.GetBufferSetLength(BUFFER), TIMEOUT);
//		strBuff.ReleaseBuffer(-1); 
	}

//---------------------------------------------------------------------------
// Error routines
//---------------------------------------------------------------------------

//int  WError     (void)
//void WErrorSet  (int errValue)
//void WErrorText (CString& strBuff)
//int  WErrorLen  (void)
//void WErrorTrap (int iTrapID, int iAction, FARPROC lpfnCallBack)

/////////////////////////////////////////////////////////////////////////////
// From TESTEVNT.H
//

// BEGIN_HELP_COMMENT
// Function: int CMSTest::QueKeys(LPCSTR sz)
// Description: A wrapper for the MS-Test function QueKeys. See the MS-Test documentation for a description of this function.
// Return: An integer value.
// Param: sz A pointer to a string that contains the keys.
// END_HELP_COMMENT
int CMSTest::QueKeys (LPCSTR sz)
	{       return ::QueKeys((LPSTR)sz); }

// BEGIN_HELP_COMMENT
// Function: int CMSTest::QueKeyDn(LPCSTR sz)
// Description: A wrapper for the MS-Test function QueKeyDn. See the MS-Test documentation for a description of this function.
// Return: An integer value.
// Param: sz A pointer to a string that contains the keys.
// END_HELP_COMMENT
int CMSTest::QueKeyDn (LPCSTR sz)
	{       return ::QueKeyDn((LPSTR)sz); }

// BEGIN_HELP_COMMENT
// Function: int CMSTest::QueKeyUp(LPCSTR sz)
// Description: A wrapper for the MS-Test function QueKeyUp. See the MS-Test documentation for a description of this function.
// Return: An integer value.
// Param: sz A pointer to a string that contains the keys.
// END_HELP_COMMENT
int CMSTest::QueKeyUp (LPCSTR sz)
	{       return ::QueKeyUp((LPSTR)sz); }


void ConvertLiteral(LPCSTR sz, CString &str)
{
	str.Empty();
	while( *sz != '\0' )
	{                                               
		if( strchr("+^%(){}~|[]", *sz) == NULL )
		{
			str += *sz++;
			if( IsDBCSLeadByte(*sz) )
				str += *sz++;
		}
		else
		{
			str += "{";             // enclose every control character in {}
			str += *sz++;   // so MS-Test to treats them literally
			str += "}";
		}
	}
}

//#define __SENDINPUT__
#ifdef __SENDINPUT__
#include "sendinpt.cpp"
#endif
// BEGIN_HELP_COMMENT
// Function: int CMSTest::DoKeys(LPCSTR sz, BOOL bLiteral /*=FALSE*/, int nWaitForIdleTime = 5000)
// Description: A wrapper for the MS-Test function DoKeys. See the MS-Test documentation for a description of this function.
// Return: An integer value.
// Param: sz A pointer to a string that contains the keys.
// Param: bLiteral A Boolean value that indicates whether to translate the keys given in sz as DoKeys does (FALSE) or interpret them literally (TRUE).
// Param: nWaitForIdleTime - An amount of time to wait after generating keystrokes for the process to become idle
// END_HELP_COMMENT
int CMSTest::DoKeys (LPCSTR sz, BOOL bLiteral /*=FALSE*/, int nWaitForIdleTime /* = 5000 */)
{
	int ret=0;                        // Return value (whatever ::DoKeys returns.)
	WaitStepInstructions("DoKeys%s:'%s'", (bLiteral?"Lit":""), sz);

#ifdef __SENDINPUT__
	::DoKeyshwnd(NULL, sz, bLiteral);
//	Sleep(500);
#else
	if( !bLiteral )
		ret = ::DoKeys((LPSTR)sz);
	else
	{
		CString str;
		ConvertLiteral(sz, str);
		ret = ::DoKeys((LPSTR)(LPCSTR)str);
	}
#endif
	if (g_hTargetProc)              // This avoids many potential timing problems when using DoKeys to drive an application.
		WaitForInputIdle(g_hTargetProc, nWaitForIdleTime);

	return ret;
}

// BEGIN_HELP_COMMENT
// Function: int CMSTest::DoKeyshWnd(HWND hwnd, LPCSTR sz)
// Description: A wrapper for the MS-Test function DoKeyshWnd. See the MS-Test documentation for a description of this function.
// Return: An integer value.
// Param: hwnd An HWND that specifies the window to send the keys to.
// Param: sz A pointer to a string that contains the keys.
// END_HELP_COMMENT
int CMSTest::DoKeyshWnd (HWND hwnd, LPCSTR sz, BOOL bLiteral /*=FALSE*/, int nWaitForIdleTime /* = 5000 */)
{
	int ret=0;                        // Return value (whatever ::DoKeys returns.)
	WaitStepInstructions("DoKeyWnd%s:'%s' to 0x%X", (bLiteral?"Lit":""), sz, hwnd);

#ifdef __SENDINPUT__
	::DoKeyshwnd(hwnd, sz, bLiteral);
//	Sleep(500);
#else
	if( !bLiteral )
		ret = ::DoKeyshWnd(hwnd, (LPSTR)sz);
	else
	{
		CString str(sz);
		ConvertLiteral(sz, str);
		ret = ::DoKeyshWnd(hwnd, (LPSTR)(LPCSTR)str);
	}
#endif
	if (g_hTargetProc)              // This avoids many potential timing problems when using DoKeys to drive an application.
		WaitForInputIdle(g_hTargetProc, nWaitForIdleTime);

	return ret;
}

// BEGIN_HELP_COMMENT
// Function: void CMSTest::QuePause(DWORD dw)
// Description: A wrapper for the MS-Test function QuePause. See the MS-Test documentation for a description of this function.
// Return: <none>
// Param: dw A DWORD that specifies the number of milliseconds to pause.
// END_HELP_COMMENT
void CMSTest::QuePause (DWORD dw)
	{      ::QuePause(dw); }

// BEGIN_HELP_COMMENT
// Function: int CMSTest::QueSetSpeed(WORD w)
// Description: A wrapper for the MS-Test function QueSetSpeed. See the MS-Test documentation for a description of this function.
// Return: An integer value.
// Param: w A WORD that specifies the queue speed.
// END_HELP_COMMENT
int  CMSTest::QueSetSpeed (WORD w)
	{       return ::QueSetSpeed(w); }

// BEGIN_HELP_COMMENT
// Function: int CMSTest::QueSetFocus(HWND hwnd)
// Description: A wrapper for the MS-Test function QueSetFocus. See the MS-Test documentation for a description of this function.
// Return: An integer value.
// Param: hwnd An HWND that specifies the window to set focus to.
// END_HELP_COMMENT
int  CMSTest::QueSetFocus (HWND hwnd)
	{       return ::QueSetFocus(hwnd); }

// BEGIN_HELP_COMMENT
// Function: int CMSTest::QueSetRelativeWindow(HWND hwnd)
// Description: A wrapper for the MS-Test function QueSetRelativeWindow. See the MS-Test documentation for a description of this function.
// Return: An integer value.
// Param: hwnd An HWND that specifies the relative window.
// END_HELP_COMMENT
int  CMSTest::QueSetRelativeWindow (HWND hwnd)
	{       return ::QueSetRelativeWindow(hwnd); }

// BEGIN_HELP_COMMENT
// Function: int CMSTest::QueMouseMove(POINT pt)
// Description: A wrapper for the MS-Test function QueMouseMove. See the MS-Test documentation for a description of this function.
// Return: An integer value.
// Param: pt A POINT value that specifies the point to move the mouse to.
// END_HELP_COMMENT
int  CMSTest::QueMouseMove (POINT pt)
	{       return ::QueMouseMove((WORD)pt.x, (WORD)pt.y); } 
	//return ::QueMouseMove(pt,0); }     //CHRISKOZ review didn't know what to put here

// BEGIN_HELP_COMMENT
// Function: int CMSTest::QueMouseDn(int n, POINT pt)
// Description: A wrapper for the MS-Test function QueMouseDn. See the MS-Test documentation for a description of this function.
// Return: An integer value.
// Param: n An integer that specifies the button to push.
// Param: pt A POINT value that specifies the point.
// END_HELP_COMMENT
int  CMSTest::QueMouseDn (int n, POINT pt)
{     return ::QueMouseDn(n, (WORD)pt.x, (WORD)pt.y); }  
//	return ::QueMouseDn(n,pt, 0); }  //CHRISKOZ review didn't know what to put here


// BEGIN_HELP_COMMENT
// Function: int CMSTest::QueMouseUp(int n, POINT pt)
// Description: A wrapper for the MS-Test function QueMouseUp. See the MS-Test documentation for a description of this function.
// Return: An integer value.
// Param: n An integer that specifies the button to release.
// Param: pt A POINT value that specifies the point.
// END_HELP_COMMENT
int  CMSTest::QueMouseUp (int n, POINT pt)
{     return ::QueMouseUp(n, (WORD)pt.x, (WORD)pt.y); }  
//		return ::QueMouseUp(n, pt, 0); }  //CHRISKOZ review didn't know what to put here    

// BEGIN_HELP_COMMENT
// Function: int CMSTest::QueMouseClick(int n, POINT pt)
// Description: A wrapper for the MS-Test function QueMouseClick. See the MS-Test documentation for a description of this function.
// Return: An integer value.
// Param: n An integer that specifies the button to click.
// Param: pt A POINT value that specifies the point.
// END_HELP_COMMENT
int  CMSTest::QueMouseClick (int n, POINT pt)
{     return ::QueMouseClick(n, (WORD)pt.x, (WORD)pt.y); }       
//		return ::QueMouseClick(n, pt, 0); }   //CHRISKOZ review didn't know what to put here

// BEGIN_HELP_COMMENT
// Function: int CMSTest::QueMouseDblClk(int n, POINT pt)
// Description: A wrapper for the MS-Test function QueMouseDblClk. See the MS-Test documentation for a description of this function.
// Return: An integer value.
// Param: n An integer that specifies the button to double click.
// Param: pt A POINT value that specifies the point.
// END_HELP_COMMENT
int  CMSTest::QueMouseDblClk (int n, POINT pt)
{     return ::QueMouseDblClk(n, (WORD)pt.x, (WORD)pt.y); }      
//		return ::QueMouseDblClk(n, pt, TIMEOUT); }  

// BEGIN_HELP_COMMENT
// Function: int CMSTest::QueMouseDblDn(int n, POINT pt)
// Description: A wrapper for the MS-Test function QueMouseDblDn. See the MS-Test documentation for a description of this function.
// Return: An integer value.
// Param: n An integer that specifies the button to push.
// Param: pt A POINT value that specifies the point.
// END_HELP_COMMENT
int  CMSTest::QueMouseDblDn (int n, POINT pt)
{     return ::QueMouseDblDn(n, (WORD)pt.x, (WORD)pt.y); }       
//		return ::QueMouseDblDn(n, pt, TIMEOUT); }   

//int  TimeDelay (int)

// BEGIN_HELP_COMMENT
// Function: int CMSTest::QueFlush(BOOL bRestoreKeyState)
// Description: A wrapper for the MS-Test function QueFlush. See the MS-Test documentation for a description of this function.
// Return: An integer value.
// Param: bRestoreKeyState A Boolean value that specifies whether to restore the key state (TRUE) or not.
// END_HELP_COMMENT
int CMSTest::QueFlush (BOOL bRestoreKeyState)
	{ return ::QueFlush(bRestoreKeyState); }   // bRestoreKeyState ignored under NT

//void QueEmpty (void)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\guiv1.cpp ===
/////////////////////////////////////////////////////////////////////////////
// guiv1.cpp
//
// email	date		change
// briancr	12/05/94	created
//
// copyright 1994 Microsoft

// Backward compatibility

// REVIEW(briancr): these objects are declared as globals for backward compatibility

#include "stdafx.h"
#include "guiv1.h"
#include "testxcpt.h"
#include "testutil.h"
#include "guitarg.h"

#define new DEBUG_NEW

// REVIEW(briancr): this is just to make things work. Is there a better way to do this?
// provide for a global log pointer
GUI_DATA CLog *gpLog;
// provide a global cmd line settings object
GUI_DATA CSettings *gpsettingsCmdLine;

//REVIEW(michma): this is a work-around to allow suite dlls to call
// GetUserTargetPlatforms (in shl.dll) while the test lists are being
// processed at load time.  GetUserTargetPlatforms() used to use a
// COConnection object for its work, but now COConnection is initialized
// by an IDE object which doesn't exist while suite dlls are being loaded.

GUI_DATA CString gplatformStr;

// REVIEW(briancr): we currently store the support system's language in this
// global. In the future, after the support system hierarchy is reworked,
// the support system will be able to query the toolset to find out the langauge
// and this global won't be needed anymore
int glang;
// handle to the dll that contains the localized ide strings.
HINSTANCE ghLangDll;

GUI_API int GetLang(void)
{
	return glang;
}

GUI_API void SetLang(int lang)
{
	glang = lang;
}

GUI_API HINSTANCE GetLangDllHandle(void)
{
	return ghLangDll;
}

GUI_API void SetLangDllHandle(HINSTANCE hLangDll)
{
	ghLangDll = hLangDll;
}

GUI_API int GetSysLang(void)
{
	switch (GetSystem()) {
		case SYSTEM_JAPAN: {
			return CAFE_LANG_JAPANESE;
			break;
		}
		default: {
			return CAFE_LANG_ENGLISH;
			break;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// hot key global variables and functions

GUI_DATA HANDLE g_hSingleStep = NULL;
GUI_DATA HANDLE g_hUserAbort = NULL;
GUI_DATA HWND g_hwndHotKey = NULL;
GUI_DATA EHotKey g_hkToDo = HOTKEY_RUN;
GUI_DATA int g_stopStep = -1;

// BEGIN_HELP_COMMENT
// Function: void WaitStepInstructions(LPCSTR szFmt, ...)
// Description: Put a message in the single step window. Wait for the next step command from the user if in single step mode.
// Return: <none>
// Param: szFmt A pointer to a string that contains the format specifiers for the remaining parameters. The format of this string is the same as the format-specifier string passed to printf.
// Param: ... A variable number of arguments that are expanded as specified in the format-specifier string.
// END_HELP_COMMENT
GUI_API void WaitStepInstructions( LPCSTR szFmt, ... )

{
	// this is to help alleviate timing problems.
	Sleep(CMDLINE->GetIntValue("StepSleep", 0));

    static int nStepNum = 0;

    if (!strcmp(szFmt, INITIALIZE_STRING))
        nStepNum = 0;

	if( szFmt != NULL )				// post notice of what next step will do
	{
		char szBuf[256], szFmtCpy[256] ;
		CString szTestNm, stepNum;
		strcpy(szFmtCpy,szFmt) ;
		int i = 0;
		if (!gpLog->GetTestName().IsEmpty())
		{
			i += sprintf(szBuf, "%s", (LPCSTR)gpLog->GetTestName());
			if(g_stopStep>nStepNum)
	        	i += sprintf(&szBuf[i], "(*%d)", g_stopStep); //mark the breakpoint
        	i += sprintf(&szBuf[i], " %d: ", ++nStepNum);
			i += sprintf( &szBuf[i], " F=%d ", gpLog->GetTotalFailCount() + gpLog->GetTestFailCount());
			szTestNm = szBuf ;
		}
		va_list marker;
		va_start( marker, szFmt );
		_vsnprintf( &szBuf[i], 255 - i, szFmt, marker );
	   	va_end( marker );

		SetWindowText(g_hwndHotKey, szBuf);	  
		// Record the key stroke without the test information.
		if (szTestNm.IsEmpty())
			gpLog->RecordTestKeys("%s",szBuf);
		else 
		{
//			stepNum.Format("%d",nStepNum);stepNum += "\t" ;
			stepNum.Format("%-6d",nStepNum); //chriskoz: /t caused paint problem
			CString szlogTxt, szTmp = szBuf ;
			int iKeyLen = szTmp.GetLength() - szTestNm.GetLength() ;
			szlogTxt = stepNum+	szTmp.Right(iKeyLen);
			gpLog->RecordTestKeys("%s",szlogTxt.GetBuffer(szlogTxt.GetLength()));
		} 
	}

	HANDLE ahObjects[2];
	ahObjects[0] = g_hSingleStep;
	ahObjects[1] = g_hUserAbort;
	if( g_hkToDo == HOTKEY_RUN && g_stopStep>nStepNum)
		g_hkToDo = HOTKEY_SINGLE; //force it to be single step when breakpoint set
	if( g_hkToDo == HOTKEY_SINGLE && g_stopStep>nStepNum)
		SetEvent(g_hSingleStep); // do not wait if breakpoint set
	DWORD dwObject = WaitForMultipleObjects(2, ahObjects, FALSE, INFINITE);	// wait for hot key
	if( dwObject - WAIT_OBJECT_0 == 1 )	// index 1 in ahObjects array is UserAbort
		TEST_EXCEPTION(causeGeneric);		// throws exception
	if(g_stopStep-1>nStepNum)
		g_hkToDo = HOTKEY_SINGLE; //set single mode for breakpoint
	if( g_hkToDo == HOTKEY_SINGLE && g_stopStep-1<=nStepNum)	// if we're single stepping
	{	
		ResetEvent(g_hSingleStep);		// reset event so we wait at next step
		SetWindowText(g_hwndHotKey, "Running...");
	}

	if (WaitForInputIdle(g_hTargetProc, 60000) == WAIT_TIMEOUT)
		gpLog->RecordInfo("WaitForInputIdle timed out in WaitStepInstructions()");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\imewrap.h ===
///////////////////////////////////////////////////////////////////////////////
//	IMEWRAP.H
//
//	Created by :			Date :
//		DavidGa					3/1/94
//
//	Description :
//		Declaration of the CIME class
//

#ifndef __IMEWRAP_H__
#define __IMEWRAP_H__

#include <ime32.h>		// IME header

#include "guixprt.h"

// REVIEW(briancr): we should probably change all these IME functions to take
// a parameter that is the hwnd of the window we want to the settings/attributes
// to be for (instead of using ::GetForegroundWindow()).

/////////////////////////////////////////////////////////////////////////////
// Flags, Enums and Symbols

#define IME_MODES_ALPHABET	(IME_MODE_ALPHANUMERIC | IME_MODE_KATAKANA | IME_MODE_HIRAGANA)
#define IME_MODES_NUMBYTES	(IME_MODE_DBCSCHAR | IME_MODE_SBCSCHAR)
#define IME_MODES_ROMAN		(IME_MODE_ROMAN | IME_MODE_NOROMAN)
#define IME_MODES_INPUT		(IME_MODE_CODEINPUT | IME_MODE_NOCODEINPUT)

// used for calling ImmSetConversionStatus in imehook.dll on nt/j.
// see cafe\support\guitools\imehook.cpp (michma - 1/1/97).
#define	IME_MODE_DB_HIRAGANA	0x19
#define IME_MODE_DB_KATAKANA	0x1B
#define	IME_MODE_DB_ALPHA		0x18
#define	IME_MODE_SB_KATAKANA	0x13
#define IME_MODE_SB_ALPHA		0x10

/////////////////////////////////////////////////////////////////////////////
// CIME class

// BEGIN_CLASS_HELP
// ClassName: CIME
// BaseClass: CWnd
// Category: General
// END_CLASS_HELP
class GUI_CLASS CIME : public CWnd
{
public:
	CIME();
	~CIME();
	#ifdef OLD_IME_BEHAVIOR
	BOOL Create(void);
	#endif // OLD_IME_BEHAVIOR

	DECLARE_DYNCREATE(CIME)

// Data
protected:
	HANDLE m_hIME;				// handle to the IME
	CEdit m_editCtl;
	bool IME_UseFlag ;
	HINSTANCE m_hNLSLibrary;	// handle to the library
	WORD (FAR WINAPI *m_lpfnSendIMEMessage)(HWND, LONG);	// handle to the library
	BOOL (FAR WINAPI *m_lpfnEnableIME)(HWND, BOOL);			// WINNLSEnableIME function pointer
	BOOL (FAR WINAPI *m_lpfnGetEnableStatus)(HWND);			// WINNLSGetEnableStatus function pointer

// Enums
public:
	enum EAlphabets { DONTCARE, ALPHA, KATAKANA, HIRAGANA };
	
// Operations
public:
	BOOL Enable(BOOL bEnable = TRUE);
	BOOL IsEnabled(void);
	BOOL Open(BOOL bOpen = TRUE);
	int IsOpen(void);
	void Flush(HWND hwnd);		// REVIEW: what is the HWND for?
	UINT GetMode(void);
	UINT SetMode(UINT flags);
	UINT SetMode(EAlphabets eAlphabet = ALPHA, UINT nBytes = 1, BOOL bRoman = TRUE, BOOL bCodeInput = FALSE);
	BOOL SendVKey(UINT vKey);
	BOOL SetConversionMode(int nMode);
	void IMEInUse(bool useFlag);
	bool IsIMEInUse() { return IME_UseFlag ; } ;

// Helper functions
protected:
	HWND GetDumbWindow(void);
	void SwitchFocus(void);

// Implementation
public:
#ifdef _DEBUG
	virtual	void AssertValid() const;
	virtual	void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CIME)
	#ifdef OLD_IME_BEHAVIOR
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	#endif // OLD_IME_BEHAVIOR
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	// the following members are used in conjunction with imehook.dll.
	// see cafe\support\guitools\imehook.cpp (michma - 1/1/97).

	// we only use imehook.dll on nt/j.
	BOOL m_bRunningOnNTJ;
	// messages that CIME functions pass to imehook.dll.
	UINT m_msgIMESetOpen;
	UINT m_msgIMEGetOpen;
	UINT m_msgIMESetMode;
	UINT m_msgIMEGetMode;

};

// REVIEW(briancr): this object is declared as a global for backward compatibility
// REVIEW(briancr): this is just to make things work. Is there a better way to do this?
extern GUI_DATA CIME IME;

#endif //__IMEWRAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\sendinpt.cpp ===
#ifndef __SENDINPUT__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#endif
//
// Note that the dwFlags field uses the same flags as keybd_event and 
// mouse_event, depending on what type of input this is.
//
typedef struct tagMOUSEINPUT {
    LONG    dx;
    LONG    dy;
    DWORD   mouseData;
    DWORD   dwFlags;
    DWORD   time;
    DWORD   dwExtraInfo;
} MOUSEINPUT, *PMOUSEINPUT, FAR* LPMOUSEINPUT;

typedef struct tagKEYBDINPUT {
    WORD    wVk;
    WORD    wScan;
    DWORD   dwFlags;
    DWORD   time;
    DWORD   dwExtraInfo;
} KEYBDINPUT, *PKEYBDINPUT, FAR* LPKEYBDINPUT;

typedef struct tagHARDWAREINPUT {
    DWORD   uMsg;
    WORD    wParamL;
    WORD    wParamH;
	DWORD	dwExtraInfo;
} HARDWAREINPUT, *PHARDWAREINPUT, FAR* LPHARDWAREINPUT;

#define INPUT_MOUSE     0
#define INPUT_KEYBOARD  1
#define INPUT_HARDWARE  2


typedef struct tagINPUT {
    DWORD   type;

    union
    {
        MOUSEINPUT      mi;
        KEYBDINPUT      ki;
        HARDWAREINPUT   hi;
    };
} INPUT, *PINPUT, FAR* LPINPUT;

UINT
WINAPI
SendInput(
    UINT    cInputs,     // number of input in the array
    LPINPUT pInputs,     // array of inputs
    int     cbSize);     // sizeof(INPUT)

extern "C" typedef
UINT
(WINAPI *PSENDINPUT)(
    UINT    cInputs,     // number of input in the array
    LPINPUT pInputs,     // array of inputs
    int     cbSize);     // sizeof(INPUT)


typedef struct tagmyINPUT {
	    WORD    wVk;
		bool	bUp;
} myINPUT, *PmyINPUT, FAR* LPmyINPUT;

myINPUT   *rgInput;
int inputlength,inputalocated; //actual & allocated length of input stream
unsigned short altkeystate[3]; //stack of VK_CONTROL, VK_SHIFT and VK_MENU keys pressed
short altkeynum; //how many alt-keys deperessed
#define KEYDOWN 0

#ifdef _DEBUG
char szDebugOutput[1024];
#endif
//RETURN: FLASE - out of memory
bool emitscancode(unsigned short scancode, int keyup)
{
	myINPUT *pnext=rgInput+inputlength;
	if(inputlength!=0 && 
		(scancode==VK_CONTROL
		|| scancode==VK_MENU
		|| scancode==VK_SHIFT)
	)
	{//optimize out the collated altkeys (ex: VK_SHIFT-UP and VK_SHIFT-DOWN)
		myINPUT *pprev=pnext-1;
		if(pprev->/*ki.*/wVk==(short)scancode)
		{
			inputlength--; //optimized out!!!
#ifdef _DEBUG
			szDebugOutput[strlen(szDebugOutput)-4]=0; //erase the debug output
#endif
			return TRUE;
		}
	}
	if(inputalocated<=inputlength)
	{ //reallocate memory in 16-character increments
		if((rgInput=(myINPUT*)realloc(rgInput, (inputalocated+=32)*sizeof(myINPUT)))==NULL)
			return FALSE;
		pnext=rgInput+inputlength;
	}
//    pnext->type = INPUT_KEYBOARD;
    pnext->/*ki.dwFlags = keyup*/bUp = (keyup!=0);
//	pnext->ki.dwExtraInfo =  0; // don't use it: MAKELONG(0x9F, 0x14FE);
	pnext->/*ki.*/wVk = scancode;
//	pnext->ki.wScan =  0; // don't use it: 0x1D;
	inputlength++;
#ifdef _DEBUG
	char test[20];
	sprintf(test, "%X%s", scancode, (keyup?"u":" "));
	strcat(szDebugOutput, test);
#endif
	return TRUE;
}

BOOL vk_altkeydepressed(unsigned short scan_code)
{
	int i;
	for(i=0;i<altkeynum;i++)
		if(altkeystate[i]==scan_code)
			return TRUE;
	return FALSE;
}

void emitchar(unsigned short scan_code, int repeats=1);
void emitchar(char inchar, int repeats=1);

void emitchar(unsigned short scan_code, int repeats)
{
	BOOL bUpcase=HIBYTE(scan_code);
	scan_code=LOBYTE(scan_code); //adjust scancode to ignore highbyte

	if(repeats<=0)
		return;

	if(bUpcase && !altkeynum) //altkeynum depressed supersedes the upcase
		emitscancode(VK_SHIFT, KEYDOWN);
	for(int i=0;i<repeats;i++)
	{
		emitscancode(scan_code, KEYDOWN);				
		emitscancode(scan_code, KEYEVENTF_KEYUP);
	}
	if(bUpcase && !altkeynum) //altkeynum depressed supersedes the upcase
		emitscancode(VK_SHIFT, KEYEVENTF_KEYUP);
}

void emitchar(char inchar, int repeats)
{
	unsigned short scan_code=VkKeyScan(inchar);
	emitchar(scan_code, repeats);
}


//spec_expr - function scans the special characters in {}
//PARAM - szKeys: input stream of chars
//PARAM - vk_altkey: state of the keaboard before {}
						//		-1	if '{' scanned
					   //VK_CONTROL	if '^{' scanned
					   //VK_MENU	if '%{' scanned
					   //VK_SHIFT	if '+{' scanned
//RETURN: the input stream position after having scanned the special char
const char *spec_expr(LPCSTR szKeys, unsigned short vk_altkey)
{ //scan the special character
//	_ASSERTE(*szKeys=='{');
	char *pclose_bra=strchr(++szKeys,'}');
	if(pclose_bra==NULL)
	{
		OutputDebugString("Error in expression, no close brace");
	}
	else
	{ //scan the special characters
		if(pclose_bra==szKeys)
		{ //the very next character (most likely "{}}" or "{} n}" sequence)
			pclose_bra++;
			if(*pclose_bra=='}' || (*pclose_bra==' ' && isdigit(pclose_bra[1])))
			{
				pclose_bra=strchr(pclose_bra,'}');
				if(pclose_bra==NULL)
				{ //"{}" or erroneous sentence; skip "{}", don't scan the rest
					szKeys++;
				}
			}
			else
			{ //"{}" sentence; skip "{}", don't scan the rest
				szKeys++;
				pclose_bra=NULL;
			}
		}
		if(pclose_bra!=NULL)
		{ //special characters from szKeys ending before pclose_bra
			unsigned short scan_code;
			if(toupper(*szKeys)=='F' && isdigit(szKeys[1]))
			{
				int fun_num=atoi(szKeys+1);
				scan_code=VK_F1+fun_num-1;
			}
			else if(_strnicmp(szKeys,"NUMPAD",strlen("NUMPAD"))==0)
			{
				if(isdigit(szKeys[strlen("NUMPAD")]))
				{
					int number=atoi(szKeys+strlen("NUMPAD"));
					scan_code=VK_NUMPAD0+number;
				}
				else if(szKeys[strlen("NUMPAD")]=='/')
					scan_code=VK_DIVIDE;
				else if(szKeys[strlen("NUMPAD")]=='*')
					scan_code=VK_MULTIPLY;
				else if(szKeys[strlen("NUMPAD")]=='-')
					scan_code=VK_SUBTRACT;
				else if(szKeys[strlen("NUMPAD")]=='+')
					scan_code=VK_ADD;
				else if(szKeys[strlen("NUMPAD")]=='.')
					scan_code=VK_DECIMAL; //?????
				else 
				{
					OutputDebugString("Error: nonexisting NUMPAD code");
					scan_code=0;
				}
			}
			else if(_strnicmp(szKeys,"LEFT",strlen("LEFT"))==0)
				scan_code=VK_LEFT;
			else if(_strnicmp(szKeys,"RIGHT",strlen("RIGHT"))==0)
				scan_code=VK_RIGHT;
			else if(_strnicmp(szKeys,"UP",strlen("UP"))==0)
				scan_code=VK_UP;
			else if(_strnicmp(szKeys,"DOWN",strlen("DOWN"))==0)
				scan_code=VK_DOWN;
			else if(_strnicmp(szKeys,"HOME",strlen("HOME"))==0)
				scan_code=VK_HOME;
			else if(_strnicmp(szKeys,"END",strlen("END"))==0)
				scan_code=VK_END;

			else if(_strnicmp(szKeys,"PGDN",strlen("PGDN"))==0)
				scan_code=VK_NEXT; //???????
			else if(_strnicmp(szKeys,"PGUP",strlen("PGUP"))==0)
				scan_code=VK_PRIOR;//???????
			else if(_strnicmp(szKeys,"TAB",strlen("TAB"))==0)
				scan_code=VK_TAB;
			else if(_strnicmp(szKeys,"ESC",strlen("ESC"))==0 || 
					_strnicmp(szKeys,"ESCAPE",strlen("ESCAPE"))==0 )
				scan_code=VK_ESCAPE;
			else if(_strnicmp(szKeys,"ENTER",strlen("ENTER"))==0)
				scan_code=VK_RETURN;
			else if(_strnicmp(szKeys,"DEL",strlen("DEL"))==0 || 
					_strnicmp(szKeys,"DELETE",strlen("DELETE"))==0 )
				scan_code=VK_DELETE;
			else if(_strnicmp(szKeys,"INSERT",strlen("INSERT"))==0)
				scan_code=VK_INSERT;
			else if(_strnicmp(szKeys,"BS",strlen("BS"))==0 || 
					_strnicmp(szKeys,"BACKSPACE",strlen("BACKSPACE"))==0 )
				scan_code=VK_BACK;
			else if(_strnicmp(szKeys,"CLEAR",strlen("CLEAR"))==0)
				scan_code=VK_CLEAR;
			else if(_strnicmp(szKeys,"HELP",strlen("HELP"))==0)
				scan_code=VK_HELP;
			else if(_strnicmp(szKeys,"BREAK",strlen("BREAK"))==0)
				scan_code=VK_PAUSE;
			else if(_strnicmp(szKeys,"PRTSC",strlen("PRTSC"))==0)
				scan_code=VK_PRINT;
			else //CAPSLOCK, NUMLOCK, SCROLLLOCK not supported
			{
				scan_code=VkKeyScan(*szKeys);
			}
			char *pspace;
			int repeat=1;
			if((pspace=strchr(szKeys,' '))!=NULL &&
				pspace<pclose_bra)
			{
				if(isdigit(pspace[1]))
					repeat=atoi(pspace+1);
			}
			emitchar(scan_code, repeat);
			szKeys=pclose_bra+1;
		}
	}
	if((short)vk_altkey>0)
	{
		emitscancode(vk_altkey, KEYEVENTF_KEYUP);
		if(altkeynum)
			altkeynum--;
	}
	return szKeys;
} // spec_expr

#define	VK_QUEUESYNC  ((SHORT) -1)	// our user-defined virtual key code for queuesync
HWND g_hwndTarget;int current_char=0;
LRESULT CALLBACK JournalPlaybackProc(int code,WPARAM wParam,LPARAM lParam);
BOOL GetNextChar(SHORT* pVirtKey,/*SHORT *pVirtScan,*/BOOL* pKeyDown)
{
	
	if(current_char>=inputlength)
	{
		current_char=-1; //set to -1 meaning VK_QUEUESYNC was sent
		*pVirtKey = VK_QUEUESYNC;
		*pKeyDown = TRUE;
		return true;
	}
	if(current_char<0)
	{
		current_char=0;
		return false; //don't set anything ele after VK_QUEUESYNC
	}
	*pVirtKey = rgInput[current_char].wVk;
//	*pVirtScan = rgInput[current_char].pVScan;
	*pKeyDown = rgInput[current_char].bUp == 0;
	current_char++;
	return true;
}

void DoKeyshwnd(HWND handle,LPCSTR szKeys, BOOL bLiteral =FALSE);
void DoKeyshwnd(HWND handle,LPCSTR szKeys, BOOL bLiteral /*=FALSE*/)
{
	inputalocated=4*strlen(szKeys); //should be enough for most cases
    if((rgInput=(myINPUT*)malloc(inputalocated*sizeof(myINPUT)))==NULL)
		return;
#ifdef _DEBUG
	szDebugOutput[0]='"';
	strcat(strcpy(szDebugOutput+1, szKeys),"\"");
	if(bLiteral)strcat(szDebugOutput, "-Literal-");
#endif
	inputlength=0; //length of the input table filled

	altkeynum=0; //how many alt-keys deperessed
	while(*szKeys!=0)
	{
		if(bLiteral)
			emitchar(*szKeys++);
		else
		switch(*szKeys)
		{
			unsigned short vk_altkey;
			case')':
				if(altkeynum)
				{
					emitscancode(altkeystate[--altkeynum], KEYEVENTF_KEYUP);
				}
				else
					emitchar(')');
				szKeys++;
				break;
			case '{':
				szKeys=spec_expr(szKeys, -1); //special expression without keystate
				break;
			case '~':
				emitchar((unsigned short)VK_RETURN);
				szKeys++;
				break;
			case '^':
			case '%':
			case '+':
//				unsigned short vk_altkey;
				if(*szKeys=='^')vk_altkey=VK_CONTROL;
				if(*szKeys=='%')vk_altkey=VK_MENU;
				if(*szKeys=='+')vk_altkey=VK_SHIFT;
				if(!vk_altkeydepressed(vk_altkey))
				{
					szKeys++;
					emitscancode(vk_altkey, KEYDOWN);
					altkeystate[altkeynum++]=vk_altkey;
					if(*szKeys=='(' || *szKeys=='{')
					{ //scan the subexpression (altkeystate remain pushed)
						if(*szKeys=='{')
							szKeys=spec_expr(szKeys, vk_altkey);
						else
							szKeys++;
					}
					else if(*szKeys)
					{ //emit key and pop altkeystate
						emitchar(*szKeys++);
						emitscancode(vk_altkey, KEYEVENTF_KEYUP);
						altkeynum--;
					}
				}
				else
				{
					emitchar(*szKeys);
					szKeys++;
				}
				break;
			default: //any character
				emitchar(*szKeys++);
				break;

		} //switch(*szKeys)
	} //while
	if(altkeynum>0)
	{
		OutputDebugString("Error in expression, altkeys not depressed");
		while(altkeynum>0)
			emitscancode(altkeystate[--altkeynum], KEYEVENTF_KEYUP);
	}
//altkeystate should be empty
//send input with allocated & filled rgInput
	if(handle && SetForegroundWindow(handle)==0)
		OutputDebugString("Failure setting the foreground window");
#ifdef _DEBUG
	char number[15];
	sprintf(number, "len:%d\n", inputlength);
	strcat(szDebugOutput, number);
	OutputDebugString(szDebugOutput);
#endif
	HMODULE hUser32=::GetModuleHandle("USER32");
	PSENDINPUT pSendInput = (PSENDINPUT)::GetProcAddress(hUser32, "SendInput");
	if(pSendInput==NULL)
		OutputDebugString("Failure getting SendInput from USER32");
	else
	{
	//	(*pSendInput)(inputlength, rgInput,sizeof(INPUT));
		/*
		for(int nevent=0; nevent<inputlength; nevent++)
		{
			keybd_event((unsigned char)rgInput[nevent].wVk, 0, 
				rgInput[nevent].bUp?KEYEVENTF_KEYUP:0, 0);
		}
		*/
		g_hwndTarget=handle; //TODO: no fucken way to avoid it with WH_JOURNALPLAYBACK, must protect it with a mutex
		current_char=0; //TODO: as above

		int ret;
		HHOOK hJournalPlaybackHook = SetWindowsHookEx(WH_JOURNALPLAYBACK,
		(HOOKPROC)JournalPlaybackProc,GetModuleHandle(NULL), 0);
		ret = (hJournalPlaybackHook!=NULL);
		while(ret>0)
		{
			MSG msg;
			ret = GetMessage(&msg,NULL,0,0);

			if (msg.message == WM_CANCELJOURNAL)
			{
				PostQuitMessage(0);
			}
			else
			{
				TranslateMessage(&msg);
				DefWindowProc(msg.hwnd, msg.message, msg.wParam, msg.lParam);
			}
		}
		if(hJournalPlaybackHook!=NULL)
			UnhookWindowsHookEx(hJournalPlaybackHook);
	}

	free(rgInput);

} //DoKeyshwnd

LRESULT CALLBACK JournalPlaybackProc(int code,WPARAM wParam,LPARAM lParam)
{
	static SHORT	nVirtKey = 0;
	static BOOL		bKeyDown = FALSE;
	PEVENTMSG		pEvent;
	static bool		bDelay = false;

	if (bDelay == false)			// first time
	{
		BYTE			baKeyStates[256];
		if(g_hwndTarget) //todo: maybe avoid setting when it's already set but force setting (even when called with NULL) if it lost focus for whatever reason
			SetForegroundWindow(g_hwndTarget);
		

		GetKeyboardState(baKeyStates);
		baKeyStates[VK_CONTROL] &= 0x7F;
		baKeyStates[VK_MENU] &= 0x7F;
		baKeyStates[VK_SHIFT] &= 0x7F;
		baKeyStates[VK_CAPITAL] &= 0x7E;
		baKeyStates[VK_NUMLOCK] &= 0x7E;
		SetKeyboardState(baKeyStates);
		bDelay = true;
	}

	switch (code)
	{
	case HC_SKIP:
		pEvent = (PEVENTMSG)lParam;
		if (GetNextChar(&nVirtKey,&bKeyDown) == FALSE)
		{
			PostQuitMessage(0);
		}
		break;

	case HC_GETNEXT:
//		if(g_hwndTarget) //todo: maybe avoid setting when it's already set but force setting (even when called with NULL) if it lost focus for whatever reason
//			SetForegroundWindow(g_hwndTarget);
		pEvent = (PEVENTMSG)lParam;
		pEvent->time = GetTickCount();
		if(nVirtKey == VK_QUEUESYNC)
		{
			pEvent->message = WM_QUEUESYNC;
			pEvent->paramL = 0; //(UINT)g_hwndMessagWindow;
			pEvent->paramH = 0;
		}
		else
		{
			pEvent->message = bKeyDown ? WM_KEYDOWN : WM_KEYUP;
			pEvent->paramL = nVirtKey;
			pEvent->paramH = MapVirtualKey(nVirtKey,1);
		}
		break;

	}
	return 0;
}


//this is the test code
#ifndef __SENDINPUT__


BOOL CALLBACK EnumWindowsProc(HWND hwnd,LPARAM lParam)
{
	int		nLen = GetWindowTextLength(hwnd) + 1;
	char*	pszWindowText = new char[nLen];
	if (GetWindowText(hwnd,pszWindowText,nLen))
	{
		if (strstr(pszWindowText,(char*)lParam) != NULL)
		{
			g_hwndTarget = hwnd;
			delete [] pszWindowText;
			return FALSE;
		}
	}
	delete [] pszWindowText;
	return TRUE;
}



int WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow)
{

	EnumWindows((WNDENUMPROC)EnumWindowsProc, (DWORD)"Notepad");
	if (g_hwndTarget != NULL)
	{
		Sleep(1000);
		DoKeyshwnd(g_hwndTarget,"HA");
		Sleep(1000);
		DoKeyshwnd(g_hwndTarget,"%HA");
		Sleep(1000);
		DoKeyshwnd(GetActiveWindow(),"{ENTER}");
		Sleep(1000);
		DoKeyshwnd(NULL, "The test line contains %d{$$$}",TRUE);
		Sleep(1000);
		DoKeyshwnd(NULL,"{ENTER}");
	}

	g_hwndTarget=0;
	EnumWindows((WNDENUMPROC)EnumWindowsProc,(DWORD)"Microsoft Visual C++ - [Text2]");
	if (g_hwndTarget != NULL)
	{
		Sleep(1000);
		DoKeyshwnd(g_hwndTarget,"{ESC}");
		Sleep(1000);
		DoKeyshwnd(NULL,"%Wl");
		Sleep(1000);
		DoKeyshwnd(NULL,"%Fn");
	}

	g_hwndTarget=0;
	EnumWindows((WNDENUMPROC)EnumWindowsProc,(DWORD)"Microsoft Visual C++ [break]");
	if (g_hwndTarget != NULL)
	{
		Sleep(1000);
		DoKeyshwnd(g_hwndTarget, "{F5}", FALSE);
		Sleep(1000);
		DoKeyshwnd(g_hwndTarget, "{F5}", FALSE);
		Sleep(1000);
		DoKeyshwnd(g_hwndTarget, "{F10}", FALSE);
		Sleep(1000);
		DoKeyshwnd(g_hwndTarget, "{F10}", FALSE);
		Sleep(1000);
		DoKeyshwnd(g_hwndTarget, "{F10}", FALSE);
		Sleep(1000);
		DoKeyshwnd(g_hwndTarget, "{F5}", FALSE);
		Sleep(1000);
		DoKeyshwnd(g_hwndTarget, "{F5}", FALSE);
		Sleep(1000);
		DoKeyshwnd(g_hwndTarget, "{F5}", FALSE);
		Sleep(1000);
		DoKeyshwnd(g_hwndTarget, "{F5}", FALSE);
		Sleep(1000);
		DoKeyshwnd(g_hwndTarget, "%DD", FALSE);
	}

	return TRUE;
}
#endif // __SENDINPUT__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\udialog.h ===
///////////////////////////////////////////////////////////////////////////////
//  UDIALOG.H
//
//  Created by :            Date :
//      DavidGa                 9/20/93
//
//  Description :
//      Declaration of the UIDialog class
//

#ifndef __UIDIALOG_H__
#define __UIDIALOG_H__

#include "uwindow.h"

#include "guixprt.h"

///////////////////////////////////////////////////////////////////////////////
// CUniqueID class

// BEGIN_CLASS_HELP
// ClassName: CUniqueDlgCtrl
// BaseClass: None
// Category: General
// END_CLASS_HELP
class GUI_CLASS CUniqueDlgCtrl
{
public:
	inline CUniqueDlgCtrl(void)
		{	m_id = 0; m_type = -1; }
	UINT m_id;
	int m_type;
	inline BOOL IsValid(void) const
		{	return m_id != 0; }
};

///////////////////////////////////////////////////////////////////////////////
// UIDialog class

// BEGIN_CLASS_HELP
// ClassName: UIDialog
// BaseClass: UIWindow
// Category: General
// END_CLASS_HELP
class GUI_CLASS UIDialog : public UIWindow
{
    UIWND_COPY_CTOR( UIDialog, UIWindow);
	UIDialog( LPCSTR szTitle );
	UIDialog( UINT idCtrl, int nType );

// Data
public:
	CString m_strTitle;
	CUniqueDlgCtrl m_UniqueCtrl;

// Utilities
public:
	virtual BOOL Open(void) const;
    virtual BOOL IsValid(void) const;
	virtual BOOL VerifyClass(void) const;
	virtual BOOL VerifyUnique(void) const;
    virtual CString ExpectedTitle(void) const;
    virtual BOOL VerifyTitle(void) const;
	void SetExpectedTitle( LPCSTR sz );
	virtual HWND GetDlgItem(UINT id) const;
	BOOL VerifyDlgItemClass(UINT id, int nClass) const;
	operator HWND ( ) {return  HWnd();} ;

// Standard buttons
    virtual HWND OK(void);
    virtual HWND Cancel(void);
    virtual HWND Close(void);
    virtual HWND Help(void);
};

#endif //__UIDIALOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\testutil.h ===
///////////////////////////////////////////////////////////////////////////////
//  TESTUTIL.H
//
//  Created by :            Date :
//      DavidGa                 8/13/93
//
//  Description :
//      Declaration of global utility functions
//

#ifndef __TESTUTIL_H__
#define __TESTUTIL_H__

#ifndef __STDAFX_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include "guixprt.h"

///////////////////////////////////////////////////////////////////////////////
//  Global Data items and enums

typedef enum {TOGGLE_OFF, TOGGLE_ON} TOGGLE_TYPE;

enum {	GL_NONE = -1,		
		GL_STATIC = 0,
		GL_BUTTON = 1,
		GL_EDIT = 2,
		GL_LISTBOX = 3,
		GL_COMBOBOX = 4,
		GL_LISTVIEW = 5,
		GL_TABVIEW = 6,
		GL_TREEVIEW = 7,
		GL_SCROLLBAR = 8,
		GL_SLIDER = 9,
		GL_SPIN = 10,
		GL_STATUSBAR = 11,
		GL_MSVCSTATIC = 12,
		GL_DIALOG = 13,
		GL_CHECKBOX = 14,
		GL_RADIOBUTTON = 15};

#define WAIT_CONTROL_0 0
#define WAIT_CONTROL_1 (WAIT_CONTROL_0 + 1)
#define WAIT_CONTROL_2 (WAIT_CONTROL_0 + 2)
#define WAIT_CONTROL_3 (WAIT_CONTROL_0 + 3)
#define WAIT_CONTROL_4 (WAIT_CONTROL_0 + 4)
#define WAIT_CONTROL_5 (WAIT_CONTROL_0 + 5)
#define WAIT_CONTROL_6 (WAIT_CONTROL_0 + 6)
#define WAIT_CONTROL_7 (WAIT_CONTROL_0 + 7)
#define WAIT_CONTROL_8 (WAIT_CONTROL_0 + 8)
#define WAIT_CONTROL_9 (WAIT_CONTROL_0 + 9)

///////////////////////////////////////////////////////////////////////////////
//  Global utility functions

GUI_API void EditUndo(int count);
GUI_API void EditRedo(int count);
GUI_API BOOL GetDragFullWindows(BOOL *bResult);

//  Process Control
GUI_API void MilliSleep( DWORD milliseconds );

//  Clipboard
// OBSOLETE(briancr): BTHROW is no longer used
GUI_API BOOL EmptyClip( /*BTHROW bThrowFail = DO_THROW */);
GUI_API BOOL GetClipText( CString& rstrTextOut/*, BTHROW bThrowFail = DO_THROW */);
GUI_API BOOL SetClipText( LPCSTR szTextIn/*, BTHROW bThrowFail = DO_THROW */);
GUI_API void PasteKeys(LPCSTR szPasteText/*, BTHROW bThrowFail = DO_THROW*/);
GUI_API void DoKeysSlow(LPCSTR szKeys, WORD wMilliseconds = 0, BOOL bLiteral = FALSE);
GUI_API CString ExtractHotKey(CString Caption);
//  Mouse Actions
GUI_API void ClickMouse(int nButton,HWND hwnd, int cX,  int cY);
GUI_API void DragMouse(int nButton,HWND hwnd1,int cX1,int cY1, HWND hwnd2,int cX2,int cY2);
GUI_API BOOL ScreenToClient(HWND hwnd, CRect* pRect);
GUI_API BOOL ClientToScreen(HWND hwnd, CRect* pRect);

//  Files and Directories
// return values for CompareFile
enum {  CF_SAME = 0,    // The 2 files are the same
		CF_DUPNAME,     // can't compare a file to itself
		CF_CANTOPEN1,   // can't open source file
		CF_CANTOPEN2,   // can't open target file
		CF_DIFFSIZE,    // files are different sizes
		CF_NOTSAME,     // some byte was different
	 };

GUI_API int CompareFiles(LPCSTR strSource, LPCSTR strTarget, int nStart);   
GUI_API void KillFile(LPCSTR szPathName, LPCSTR szFileName = NULL, BOOL bIgnoreReadOnly = FALSE);
GUI_API BOOL KillAllFiles(LPCSTR szPathName, BOOL bRemoveDir = TRUE);
GUI_API BOOL CopyTree(LPCSTR szFrom, LPCSTR szTo);
GUI_API int FindStrInFile(LPCSTR szFileName, LPCSTR szStr, int nStart = 1);

// Menu Access
GUI_API int DoMenu(LPCSTR szMenu1,        LPCSTR szMenu2,        LPCSTR szMenu3 = NULL,
		   LPCSTR szMenu4 = NULL, LPCSTR szMenu5 = NULL, LPCSTR szMenu6 = NULL,
		   LPCSTR szMenu7 = NULL, LPCSTR szMenu8 = NULL, LPCSTR szMenu9 = NULL);
GUI_API int DoMenu(LPCSTR szMenu);
GUI_API BOOL DoSingleMenu(LPCSTR szMenu);

// Other
GUI_API LPCSTR GetText(HWND hwnd, LPSTR sz, int cMax);
GUI_API CString GetText(HWND hwnd);
GUI_API BOOL IsWindowActive(LPCSTR szWndTitle);
GUI_API BOOL WaitMsgBoxText(LPCSTR szExpect, int nSeconds);
GUI_API int WaitForOriginalWnd(HWND hOrig, int Sec);	
GUI_API int GetDlgControlClass(HWND hWnd) ;
GUI_API void DayRandSeed(void);
GUI_API int DayRand(int nRange);
GUI_API BOOL SetFocusToDlgControl(UINT id, HWND hwnd = NULL);

// window manipulation
GUI_API HWND FindFirstChild(HWND hWnd, int nID);
GUI_API HWND FindChildWindow(HWND hWnd, LPCSTR pCaption, LPCSTR pClassType =NULL);
GUI_API DWORD WaitForSingleControl(const DWORD dwProcessId, const int idControl, const DWORD dwTimeout);
GUI_API DWORD WaitForMultipleControls(const DWORD dwProcessId, const int cControls, const int aControls[], const DWORD dwTimeout);

// Dialog navigation support functions
GUI_API BOOL CALLBACK WGetPageHandle(HWND, LPARAM) ;
GUI_API HWND ControlOnPropPage(int iCtrlId) ;
GUI_API HWND WaitForWndWithCtrl(INT ID, DWORD dwMillSec = 3000) ;
// Localization
GUI_API LPCSTR GetLabel(UINT id, HWND hwnd = NULL, BOOL bOkNoExist = FALSE);

enum { 	SYSTEM_NT_4		= 0x01,
		SYSTEM_NT_5		= 0x02,
		SYSTEM_NT		= 0x83,		// SYSTEM_NT_4 | SYSTEM_NT_5 - probably should also include SYSTEM_NT_51
		SYSTEM_WIN_95	= 0x04,  
		SYSTEM_WIN_98	= 0x08,
		SYSTEM_WIN_MILL = 0x10,
		SYSTEM_WIN		= 0x1C,		// SYSTEM_WIN_95 | SYSTEM_WIN_98 | SYSTEM_WIN_MILL
		SYSTEM_DBCS		= 0x20,
		SYSTEM_JAPAN	= 0x40,
		SYSTEM_NT_51	= 0x80,		//	WHISTLER i.e. NT5.1
	 };

GUI_API DWORD GetSystem(void);

GUI_API int GetPowerOfTwo(int i);
GUI_API void TrimString(CString* pStr);
GUI_API int GetLabelNo(HWND hCtl);

enum {VC_PRO, VC_ENT, VC_LRN};
GUI_API DWORD GetProductType(void);
										
// BEGIN_CLASS_HELP
// ClassName: RandomNumberCheckList
// BaseClass: None
// Category: Global
// END_CLASS_HELP
class GUI_CLASS RandomNumberCheckList
{
public:
	// the default constructor is so the class can be contained.
	// just call the (int) constructor afterward to set iMax.
	RandomNumberCheckList(void);
	RandomNumberCheckList(int iMax);
	void SetMax(int iMax);
	int GetNext(void);
	void UndoLast(void);
private:
	int m_iMax;
	CArray<int, int> m_iaUsed;
};


///////////////////////////////////////////////////////////////////////////////
// COApplication class
//
// BEGIN_CLASS_HELP
// ClassName: COApplication
// BaseClass: None
// Category: Global
// END_CLASS_HELP
class GUI_CLASS COApplication

{
private:
	HWND m_hWnd;
public:
	COApplication(void) {m_hWnd = NULL;}
	virtual BOOL Attach(LPCSTR szAppTitle = NULL, int secWait = 0);
	virtual BOOL Activate(void);
	virtual void SendKeys(LPCSTR szKeys);
};

#endif //__TESTUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\umsgbox.h ===
///////////////////////////////////////////////////////////////////////////////
//   UIMSGBOX.H
//
//  Created by :            Date :
//      DavidGa                 1/12/94
//
//  Description :
//      Declaration of the  UIMessageBox class
//

#ifndef __UIMSGBOX_H__
#define __UIMSGBOX_H__

#include "uwindow.h"

#include "guixprt.h"

#ifndef __UIWINDOW_H__
    #error include 'uwindow.h' before including this file
#endif

#define MSG_DEFAULT UIMessageBox::m_idDefaultButton
#define MSG_OK		UIMessageBox::m_idOKButton
#define MSG_CANCEL	UIMessageBox::m_idCancelButton
#define MSG_ABORT	UIMessageBox::m_idAbortButton
#define MSG_RETRY	UIMessageBox::m_idRetryButton
#define MSG_IGNORE	UIMessageBox::m_idIgnoreButton
#define MSG_YES		UIMessageBox::m_idYesButton
#define MSG_NO		UIMessageBox::m_idNoButton


///////////////////////////////////////////////////////////////////////////////
//   UIMessageBox class

// BEGIN_CLASS_HELP
// ClassName: UIMessageBox
// BaseClass: UIWindow
// Category: General
// END_CLASS_HELP
class GUI_CLASS UIMessageBox : public  UIWindow
{
     UIWND_COPY_CTOR(UIMessageBox,  UIWindow);

// Utilities
public:
	virtual BOOL IsValid(void) const;
	CString GetMessageText(void);

// Standard buttons
public:
	BOOL ButtonClick(int btn = MSG_DEFAULT);
	BOOL ButtonExists(int btn);
	int GetActiveButton(void);

	static int m_idDefaultButton;
	static int m_idOKButton;
	static int m_idCancelButton;
	static int m_idAbortButton;
	static int m_idRetryButton;
	static int m_idIgnoreButton;
	static int m_idYesButton;
	static int m_idNoButton;
};

#endif //__UIMSGBOX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\umsgbox.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UMSGBOX.H
//
//  Created by :            Date :
//      DavidGa                 1/12/94
//
//  Description :
//      Implementation of the UIMessageBox class
//

#include "stdafx.h"

#include "umsgbox.h"
#include "mstwrap.h"
#include "testutil.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

///////////////////////////////////////////////////////////////////////////////
//  UIMessageBox class

int UIMessageBox::m_idDefaultButton = 0;

int UIMessageBox::m_idOKButton = IDOK + 
	(((GetSystem() & SYSTEM_WIN) || (GetSystem() & SYSTEM_NT)) ? 1 : 2);
int UIMessageBox::m_idCancelButton = IDCANCEL + 
	(((GetSystem() & SYSTEM_WIN) || (GetSystem() & SYSTEM_NT)) ? 1 : 2);
int UIMessageBox::m_idAbortButton  = IDABORT + 
	(((GetSystem() & SYSTEM_WIN) || (GetSystem() & SYSTEM_NT)) ? 1 : 2);
int UIMessageBox::m_idRetryButton = IDRETRY + 
	(((GetSystem() & SYSTEM_WIN) || (GetSystem() & SYSTEM_NT)) ? 1 : 2);
int UIMessageBox::m_idIgnoreButton = IDIGNORE + 
	(((GetSystem() & SYSTEM_WIN) || (GetSystem() & SYSTEM_NT)) ? 1 : 2);
int UIMessageBox::m_idYesButton = IDYES + 
	(((GetSystem() & SYSTEM_WIN) || (GetSystem() & SYSTEM_NT)) ? 0 : 2);
int UIMessageBox::m_idNoButton = IDNO + 
	(((GetSystem() & SYSTEM_WIN) || (GetSystem() & SYSTEM_NT)) ? 0 : 2);

// BEGIN_HELP_COMMENT
// Function: BOOL UIMessageBox::IsValid(void) const
// Description: Determine if the message box is valid by checking that the window handle is valid and that the window class is #32770.
// Return: A Boolean value that indicates whether the message box is valid (TRUE) or not.
// END_HELP_COMMENT
BOOL UIMessageBox::IsValid(void) const
{
    if( !UIWindow::IsValid() )
        return FALSE;
    
    char acClass[10];
    GetClassName(HWnd(), acClass, 9);
    return strcmp(acClass, "#32770") == 0;
}

// BEGIN_HELP_COMMENT
// Function: CString UIMessageBox::GetMessageText(void)
// Description: Get the message text from the message box.
// Return: A CString that contains the text of the message in the message box.
// END_HELP_COMMENT
CString UIMessageBox::GetMessageText(void)
{
    HWND hwndChild = GetWindow(HWnd(), GW_CHILD);
    HWND hwndLast = GetWindow(hwndChild, GW_HWNDLAST);
    return ::GetText(hwndLast);
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIMessageBox::ButtonClick(int btn /*=MSG_DEFAULT*/)
// Description: Click the specified button in the message box.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: btn An integer that specifies the ID of the button to click: MSG_DEFAULT, MSG_OK, MSG_CANCEL, MSG_ABORT, MSG_RETRY, MSG_IGNORE, MSG_YES, MSG_NO. (Default value is MSG_DEFAULT.)
// END_HELP_COMMENT
BOOL UIMessageBox::ButtonClick(int btn /*=MSG_DEFAULT*/)
{
    if( btn == MSG_DEFAULT )
        MST.WButtonClick(NULL);
    else if( !ButtonExists(btn) )
        return FALSE;
    else
        MST.WButtonClick(GetLabel(btn));
    return WaitUntilGone(1000);     // every button should make a message box go away
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIMessageBox::ButtonExists(int btn)
// Description: Determine whether the specified button exists on the message box.
// Return: A Boolean value that indicates whether the button exists (TRUE) or not.
// Param: btn An integer that contains the ID of the button.
// END_HELP_COMMENT
BOOL UIMessageBox::ButtonExists(int btn)
{
    return GetDlgItem(HWnd(), btn) != NULL;
}

// BEGIN_HELP_COMMENT
// Function: int UIMessageBox::GetActiveButton(void)
// Description: Get the ID of the active button on the message box.
// Return: An integer that specifies the ID of the active button.
// END_HELP_COMMENT
int UIMessageBox::GetActiveButton(void)
{
    for( int btn = MSG_OK; btn <= MSG_NO; btn++ )
        if( ButtonExists(btn) && MST.WButtonFocus(GetLabel(btn)) )
            return btn;
    return 0;   // huh?
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\udialog.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UDIALOG.H
//
//  Created by :            Date :
//      DavidGa                 9/20/93
//
//  Description :
//      Declaration of the UIDialog class
//

#include "stdafx.h"
#include "testxcpt.h"
#include "udialog.h"
#include "testutil.h"
#include "mstwrap.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

UIDialog::UIDialog( LPCSTR szTitle )
: UIWindow()
{
	SetExpectedTitle(szTitle);
}

UIDialog::UIDialog( UINT idCtrl, int nType )
: UIWindow()
{
	m_UniqueCtrl.m_id = idCtrl;
	m_UniqueCtrl.m_type = nType;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIDialog::Open(void)
// Description: Open the dialog. This member function must be overridden in the derived class.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIDialog::Open(void) const
{
	// override this in the derived class
	ASSERT(0);
	return FALSE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIDialog::IsValid(void) const
// Description: Determine if the dialog is valid by verifying that the dialog is a valid window and by calling VerifyClass and VerifyUnique.
// Return: A Boolean value that indicates whether the dialog is valid (TRUE) or not.
// END_HELP_COMMENT
BOOL UIDialog::IsValid(void) const
{
	if( !UIWindow::IsValid() )
		return FALSE;

	return VerifyClass() && VerifyUnique();
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIDialog::VerifyClass(void) const
// Description: Determine if the window class of the dialog is #32770.
// Return: A Boolean value that indicates whether the window class is #32770 (TRUE) or not.
// END_HELP_COMMENT
BOOL UIDialog::VerifyClass(void) const
{
	char acClass[32];
	GetClassName(HWnd(), acClass, 31);
	return ( lstrcmpi(acClass, "#32770") == 0 );
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIDialog::VerifyUnique(void) const
// Description: Verify that this dialog is unique.
// Return: A Boolean value that indicates whether the dialog is unique (TRUE) or not.
// END_HELP_COMMENT
BOOL UIDialog::VerifyUnique(void) const
{				// if no derived class has overridden this function,
	if( m_UniqueCtrl.IsValid() )	// then either verify unique dialog control
		return VerifyDlgItemClass(m_UniqueCtrl.m_id, m_UniqueCtrl.m_type);
	else
		return VerifyTitle();	// or verify dialog caption
}

// BEGIN_HELP_COMMENT
// Function: LPCSTR UIDialog::ExpectedTitle(void) const
// Description: Get the title of the dialog (as expected by this object--not from the actual dialog).
// Return: A pointer to a string that contains the title of the dialog.
// END_HELP_COMMENT
CString UIDialog::ExpectedTitle(void) const
{
	return m_strTitle.IsEmpty()? "" : m_strTitle;
}

// BEGIN_HELP_COMMENT
// Function: void UIDialog::SetExpectedTitle(LPCSTR szTitle)
// Description: Set the expected title for this dialog.
// Return: <none>
// Param: szTitle A pointer to a string that contains the expected title of this dialog.
// END_HELP_COMMENT
void UIDialog::SetExpectedTitle(LPCSTR szTitle)
{
	if( szTitle == NULL )
		m_strTitle.Empty();
	else
		m_strTitle = szTitle;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIDialog::VerifyTitle(void) const
// Description: Determine if the title of the dialog matches the expected title of the dialog.
// Return: A Boolean value that indicates whether the title of the dialog matches the expected title (TRUE) or not.
// END_HELP_COMMENT
BOOL UIDialog::VerifyTitle(void) const
{
	CString strTitle = ExpectedTitle();   // or against the expected titlebar text
	if (strTitle.IsEmpty())        // if that is also NULL
		return TRUE;        // then no particular title is expected.  REVIEW: does this make sense?

	char acBuf[256];
	GetText(acBuf, 255);
	return lstrcmpi(acBuf, strTitle) == 0;
}

// BEGIN_HELP_COMMENT
// Function: HWND UIDialog::GetDlgItem(UINT id) const
// Description: Get the HWND of an item in the dialog.
// Return: The HWND of the specified item in the dialog.
// Param: id An integer that specifies the ID of the item in the dialog.
// END_HELP_COMMENT
HWND UIDialog::GetDlgItem(UINT id) const
{
	return ::GetDlgItem(HWnd(), id);
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIDialog::VerifyDlgItemClass(UINT id, int nClass) const
// Description: Verify that the class of the specified dialog item matches the given class.
// Return: A Boolean value that indicates whether the class of the specified dialog item matches the given class (TRUE) or not.
// Param: id An integer that specifies the ID of the item in the dialog.
// Param: nClass An integer that specifies the class of the dialog item.
// END_HELP_COMMENT
BOOL UIDialog::VerifyDlgItemClass(UINT id, int nClass) const
{
	return  (GetDlgItem(id) != NULL) &&
			(GetDlgControlClass(GetDlgItem(id)) == nClass);
}

// BEGIN_HELP_COMMENT
// Function: HWND UIDialog::OK(void)
// Description: Click the OK button in the dialog.
// Return: NULL if successful; the HWND of a message or dialog box that has focus otherwise.
// END_HELP_COMMENT
HWND UIDialog::OK(void)
{
	ExpectValid();

//	if( !MST.WButtonExists(UD_BTN_OK) )
//		return FALSE;

	MST.WButtonClick(GetLabel(IDOK));
	if( WaitUntilGone(1000) )
		return NULL;		// NULL means all is well
	else
		return MST.WGetActWnd(0);	// an HWND presumes some alert came up
}

// BEGIN_HELP_COMMENT
// Function: HWND UIDialog::Cancel(void)
// Description: Click the Cancel button in the dialog.
// Return: NULL if successful; the HWND of a message or dialog box that has focus otherwise.
// END_HELP_COMMENT
HWND UIDialog::Cancel(void)
{
	ExpectValid();

//	if( !MST.WButtonExists(UD_BTN_CANCEL) )
//		return FALSE;

	MST.WButtonClick(GetLabel(IDCANCEL));
	if( WaitUntilGone(1000) )
		return NULL;		// NULL means all is well
	else
		return MST.WGetActWnd(0);	// an HWND presumes some alert came up
}

// BEGIN_HELP_COMMENT
// Function: HWND UIDialog::Close(void)
// Description: Click the Close button in the dialog.
// Return: NULL if successful; the HWND of a message or dialog box that has focus otherwise.
// END_HELP_COMMENT
HWND UIDialog::Close(void)
{
	ExpectValid();

	if( MST.WButtonExists("Close") )		// LOCALIZE
		MST.WButtonClick("Close");		// use the close button if there is one
	else if( MST.WButtonExists(GetLabel(IDCANCEL) ))	// use the Cancel button if not 
		MST.WButtonClick(GetLabel(IDCANCEL));
		else
			PostMessage(HWnd(), WM_CLOSE, 0, 0);	// otherwise, close it however we must

	if( WaitUntilGone(3000) )		// REVIEW(davidga) 3000 is too arbitrary
		return NULL;		// NULL means all is well
	else
		return MST.WGetActWnd(0);	// an HWND presumes some alert came up
}

// BEGIN_HELP_COMMENT
// Function: HWND UIDialog::Help(void)
// Description: Click the Help button in the dialog.
// Return: NULL if successful; the HWND of a message or dialog box that has focus otherwise.
// END_HELP_COMMENT
HWND UIDialog::Help(void)
{
	ExpectValid();

	if( !MST.WButtonExists("Help") )
		return NULL;
	MST.WButtonClick ("Help");

	int n = 0;
	while( MST.WGetActWnd(0) == HWnd() )
	{
		if( n++ > 10 )		
			return NULL;	// no new window popped up within 10 seconds
		Sleep(1000);
	}
	return MST.WGetActWnd(0);	// return HWND of Help window
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\uwindow.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	UWINDOW.CPP
//
//	Created by :			Date :
//		DavidGa					9/20/93
//
//	Description :
//		Declaration of the UIWindow class
//

#include "stdafx.h"
#include "uwindow.h"
#include "testutil.h"
#include "mstwrap.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/*	UIWindow
 *		Default parameter allows single function to be both simple constructor
 *		and copy constructor.  I have chosen not to have a constructor that
 *		attaches to the active window.
 */
UIWindow::UIWindow(HWND hwnd)
{
	m_hWnd = hwnd;
	OnUpdate();
}

/*	operator= and Attach
 *		Two ways to attach an HWND to a UIWindow.
 *		operator= returns an HWND, so that ='s may be chained.
 *		Attach returns a BOOL, stating whether the HWND was valid or not.
 */
// BEGIN_HELP_COMMENT
// Function: HWND UIWindow::operator=(HWND hwnd)
// Description: Assign this UIWindow object or HWND to another UIWindow object or HWND.
// Return: HWND that specifies the UIWindow object.
// Param: hwnd The HWND of the object to assign from.
// END_HELP_COMMENT
HWND UIWindow::operator=(HWND hwnd)
{
	m_hWnd = hwnd;
	OnUpdate();
	return m_hWnd;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWindow::Attach(HWND hwnd)
// Description: Attach to the window with the given handle.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: hwnd An HWND that specifies the handle of the window to attach to.
// END_HELP_COMMENT
BOOL UIWindow::Attach(HWND hwnd)
{
	operator=(hwnd);
	return IsValid();
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIWindow::AttachActive(void)
// Description: Attach to the active window.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWindow::AttachActive(void)
{
	return Attach(MST.WGetActWnd(0));
}

/*	Find
 *		Derived classes should override this function, and implement a search
 *		for a window that fits their expectations.
 *		Once found, call Attach with that HWND - do not call the base class.
 *		REVIEW: can the base class be made more useful?
 */
// BEGIN_HELP_COMMENT
// Function: BOOL UIWindow::Find(void)
// Description: Find the window and attach to it. This member function must be overridden by the derived class.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWindow::Find(void)
{
	return Attach(NULL);
}

/*	OnUpdate
 *		Called every time a new hwnd has been attached to the UIWindow.
 *		Override this function in order to keep other member variables in sync.
 *		Do NOT call the base class's OnUpdate, as the only way this function is
 *		called is through a constructor or operator=, both of which use macros 
 *		to make sure that all classes get called.
 */
void UIWindow::OnUpdate(void)
{
}

/*	IsValid
 *		Should cantain any convenient checks that will ensure that m_hWnd
 *		(derived classes must use HWnd() or PWnd()) is really of the type
 *		expected for the particular class.
 *		Always call the base class first, both because anything that fails the
 *		base class test should necessarilybe invalid, and because that will
 *		help avoiding crashes where you assumed things like ::IsWindow(m_hWnd).
 */
// BEGIN_HELP_COMMENT
// Function: BOOL UIWindow::IsValid(void) const
// Description: Determine if the window is valid by verifying the validity of its HWND and that it's visible.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWindow::IsValid(void) const
{
	return ::IsWindow(m_hWnd) && IsVisible();	// REVIEW(davidga): don't test HasFocus()
}

/*	GetText
 *		Get's the title text (using SendMessage(WM_GETTEXT)) of m_hWnd.
 *		The text is placed either in a provided char buffer, or else into
 *		a new CString.
 */
// BEGIN_HELP_COMMENT
// Function: LPCSTR UIWindow::GetText(LPSTR sz, int cMax) const
// Description: Get the window text (by sending a WM_GETTEXT) message to the window. (See CString UIWindow::GetText(void) to get the text without allocating a buffer.)
// Return: A pointer to the beginning of the buffer pointed to by the sz parameter.
// Param: sz A pointer to a string that will contain the text of the window.
// Param: cMax An integer that specifies the size of the sz buffer.
// END_HELP_COMMENT
LPCSTR UIWindow::GetText(LPSTR sz, int cMax) const
{
	return ::GetText(m_hWnd, sz, cMax);
}

// BEGIN_HELP_COMMENT
// Function: CString UIWindow::GetText(void) const
// Description: Get the window text (by sending a WM_GETTEXT) message to the window. (See LPCSTR UIWindow::GetText(LPSTR, int) to get the text in a user allocated buffer.)
// Return: A pointer to the beginning of the buffer pointed to by the sz parameter.
// END_HELP_COMMENT
CString UIWindow::GetText(void) const
{
	return ::GetText(m_hWnd);
}

/*	IsActive
 *		Determines if the m_hWnd is the currently active window.
 *		Override this function for classes representing child windows, and 
 *		other things that will not be returned by WGetActWnd()
 *		(e.g. MDI children).
 */
// BEGIN_HELP_COMMENT
// Function: BOOL UIWindow::IsActive(void)
// Description: Determine if the window is active.
// Return: A Boolean value that indicates whether the window is active (TRUE) or not.
// END_HELP_COMMENT
BOOL UIWindow::IsActive(void)
{
	return HWnd() == WGetActWnd(0);
}

/*	Activate
 *		Activates this HWND.  I don't know if this will work for child windows
 *		as well - I'm not sure what WSetActWnd does.  If there is a problem
 *		with child windows, override this function in the appropriate classes.
 */
// BEGIN_HELP_COMMENT
// Function: BOOL UIWindow::Activate(void)
// Description: Make this window the active window. (See UIWindow::BlockingActivate() to make this window active and wait until it's active.)
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWindow::Activate(void)
{
	MST.WSetActWnd(HWnd());								
	return IsActive();			
}

/*	BlockingActivate
 *		Activates this HWND.  Same as Activate but blocks until window isActive
 */
// BEGIN_HELP_COMMENT
// Function: BOOL UIWindow::BlockingActivate(void)
// Description: Make this window the active window and wait until it is active. (See UIWindow::Activate() to make this window active without waiting.)
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWindow::BlockingActivate(void)
{
	::WSetActWnd(HWnd());								
	while (!IsActive())
		 Sleep(10);
	return IsActive();			
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWindow::HasFocus(void) const
// Description: Determine if this window has focus.
// Return: A Boolean value that indicates whether this window has focus (TRUE) or not.
// END_HELP_COMMENT
BOOL UIWindow::HasFocus(void) const
{
	HWND hwnd = MST.WGetFocus();
	return (hwnd == HWnd()) ||			// is the focus in the hwnd
			(IsChild(HWnd(), hwnd) );	// or at least in one of its children
}

/*	WaitAttachActive
 *		Waits until the window retrieved by AttachActive passes the IsValid test,
 *		or until dwMilliseconds times out.
 *		For UIWindow, this is the same as AttachActive.  But in derived classes, 
 *		with good overrides of IsValid and AttachActive, this can be very useful.
 *		Returns the HWND, to be more useful.
 */
// BEGIN_HELP_COMMENT
// Function: HWND UIWindow::WaitAttachActive(DWORD dwMilliseconds)
// Description: Wait until active window is attached to successfully or the specified time-out is reached.
// Return: An HWND that specifies the window attached to.
// Param: dwMilliseconds A DWORD that specifies the number of milliseconds to wait.
// END_HELP_COMMENT
HWND UIWindow::WaitAttachActive(DWORD dwMilliseconds)
{
	while( !AttachActive() )		// Attach returns IsValid of new HWND
	{
		if( dwMilliseconds == 0 )
		{
//			Detach();		// REVIEW: this makes testing a pain
			return NULL;
		}
		DWORD dwSleep = dwMilliseconds > 100 ? 100 : dwMilliseconds;  //Waynebr reduce 1000 to 100 ms 
		Sleep(dwSleep);
		dwMilliseconds -= dwSleep;
	}
	return HWnd();
}

/*	WaitUntilGone
 *		Checks every second (or until dwMilliSeconds times out) for m_hWnd
 *		to go away, as determined by ::IsWindow().
 */
// BEGIN_HELP_COMMENT
// Function: BOOL UIWindow::WaitUntilGone(DWORD dwMilliseconds)
// Description: Wait until the window is no longer valid or the specified time-out is reached.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: dwMilliseconds A DWORD that specifies the number of milliseconds to wait.
// END_HELP_COMMENT
BOOL UIWindow::WaitUntilGone(DWORD dwMilliseconds)
{
	while( ::IsWindow(HWnd()) )		// As long as m_hWnd is valid, then it's still there
	{
		if( dwMilliseconds == 0 )
			return FALSE;
		DWORD dwSleep = dwMilliseconds > 1000 ? 1000 : dwMilliseconds;
		Sleep(dwSleep);
		dwMilliseconds -= dwSleep;
	}
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: int UIWindow::ResizeWindow(BOOL bIsDocked, WINDOW_SIDE wSide, MOVE_DIRECTION wDirection, int count)
// Description: Resizes window
// Return: int actual position change (in number of arrow hits)
// Param: A Boolean value that specifies if the window is Docked or not. If TRUE it is Docked; FALSE otherwise.
// Param: WINDOW_SIDE wSide Determines which side should be moved (SLeft, STop, SRight, SBottom)
// Param: MOVE_DIRECTION wDirection Determined the direction where to move the side (DLeft, DUp, DRight, DDown)
// Param:  int desired position change (in number of arrow hits)
// Param: BOOL DragFullWindows A Boolean value that specifies if "Show window contents while dagging".
// END_HELP_COMMENT
int UIWindow::ResizeWindow(BOOL bIsDocked, WINDOW_SIDE wSide, MOVE_DIRECTION wDirection, int count, BOOL DragFullWindows)
{

	WNDPOS WinPos;
	int nActualCount;
	POINT old_curpos, new_curpos;
	RECT old_rect, new_rect;
	const int max_int = 65535;
	bool bCheckOldPosition;

	//Activate();

	if(bIsDocked)		// If Docked we emulate right mouse click on the title bar
	{
		::WGetWndPos(m_hWnd, &WinPos, FALSE);
		WinPos.left = (WinPos.left < 0) ? 1 : WinPos.left;
		WinPos.top = (WinPos.top < 0) ? 1 : WinPos.top;
		::QueMouseClick(VK_RBUTTON, WinPos.left + 10, WinPos.top + 5);
		::QueFlush(TRUE);
	}
	else				// If Not Docked we emulate "Alt -" keystroke
	{
		MST.DoKeys("%{-}");
	}

	// Choose size
	MST.DoKeys("{DOWN 2}");
	MST.DoKeys("{ENTER}");

	// Choose the side we are going to move
	switch(wSide)
	{
		case SLeft:
			MST.DoKeys("{Left}");
			break;
		case STop:
			MST.DoKeys("{Up}");
			break;
		case SRight:
			MST.DoKeys("{Right}");
			break;
		case SBottom:
			MST.DoKeys("{Down}");
			break;
	}

	// count < 0 means as much as possible
	if(count < 0)
		count = max_int; // Is it possible to move more than 65535 pixels? dklem

	// Move the side
	for(bCheckOldPosition = TRUE, nActualCount = 0; nActualCount < count; nActualCount++)
	{
		GetCursorPos(&old_curpos);
		GetWindowRect(m_hWnd, &old_rect);		

		switch(wDirection)
		{
		case DLeft:
			MST.DoKeys("{Left}");
			break;
		case DUp:
			MST.DoKeys("{Up}");
			break;
		case DRight:
			MST.DoKeys("{Right}");
			break;
		case DDown:
			MST.DoKeys("{Down}");
			break;
		}
		// Do size change until position is not changed
		GetCursorPos(&new_curpos);
		GetWindowRect(m_hWnd, &new_rect);
		if(	bCheckOldPosition && (
			(DragFullWindows && new_rect.left == old_rect.left && new_rect.top == old_rect.top &&	new_rect.right == old_rect.right && new_rect.bottom == old_rect.bottom)
			||
			(!DragFullWindows && new_curpos.x == old_curpos.x && new_curpos.y == old_curpos.y)
			)
		  )
		{
			count =  nActualCount + 3; // Let's hit arrow a couple of times.  Just in case.
			bCheckOldPosition = FALSE;
		}
	}


	// Fix new position
	MST.DoKeys("{ENTER}");

	if(!bCheckOldPosition)
		nActualCount -= 2;

	// Return actual position change (in arrow hits)
	return (nActualCount < 0) ? -nActualCount: nActualCount;
}


// BEGIN_HELP_COMMENT
// Function: int UIWindow::MoveWindow(BOOL bIsDocked, MOVE_DIRECTION wDirection, int count)
// Description: Moves window
// Return: int actual position change (in number of arrow hits)
// Param: A Boolean value that specifies if the window is Docked or not. If TRUE it is Docked; FALSE otherwise.
// Param: MOVE_DIRECTION wDirection Determined the direction where to move the window (DLeft, DUp, DRight, DDown)
// Param:  int desired posizion change (in number of arrow hits)
// Param: BOOL DragFullWindows A Boolean value that specifies if "Show window contents while dagging".
// END_HELP_COMMENT
int UIWindow::MoveWindow(BOOL bIsDocked, MOVE_DIRECTION wDirection, int count, BOOL DragFullWindows)
{

	WNDPOS WinPos;
	int nActualCount;
	POINT old_curpos, new_curpos;
	RECT old_rect, new_rect;
	const int max_int = 65535;
	bool bCheckOldPosition;

	//Activate();

	if(bIsDocked)		// If Docked we emulate right mouse click on the title bar
	{
		::WGetWndPos(m_hWnd, &WinPos, FALSE);
		WinPos.left = (WinPos.left < 0) ? 1 : WinPos.left;
		WinPos.top = (WinPos.top < 0) ? 1 : WinPos.top;
		::QueMouseClick(VK_RBUTTON, WinPos.left + 10, WinPos.top + 5);
		::QueFlush(TRUE);
	}
	else				// If Not Docked we emulate "Alt -" keystroke
	{
		MST.DoKeys("%{-}");
	}

	// Choose size
	MST.DoKeys("{DOWN}");
	MST.DoKeys("{ENTER}");

	// count < 0 means as much as possible
	if(count < 0)
		count = max_int; // Is it possible to move more than 65535 pixels? dklem

	// Move the side
	for(bCheckOldPosition = TRUE, nActualCount = 0; nActualCount < count; nActualCount++)
	{
		GetCursorPos(&old_curpos);
		GetWindowRect(m_hWnd, &old_rect);		

		switch(wDirection)
		{
		case DLeft:
			MST.DoKeys("{Left}");
			break;
		case DUp:
			MST.DoKeys("{Up}");
			break;
		case DRight:
			MST.DoKeys("{Right}");
			break;
		case DDown:
			MST.DoKeys("{Down}");
			break;
		}
		// Do size change until position is not changed
		GetCursorPos(&new_curpos);
		GetWindowRect(m_hWnd, &new_rect);
		if(	bCheckOldPosition && (
			(DragFullWindows && new_rect.left == old_rect.left && new_rect.top == old_rect.top &&	new_rect.right == old_rect.right && new_rect.bottom == old_rect.bottom)
			||
			(!DragFullWindows && new_curpos.x == old_curpos.x && new_curpos.y == old_curpos.y)
			)
		  )
		{
			count =  nActualCount + 3; // Let's hit arrow a couple of times.  Just in case.
			bCheckOldPosition = FALSE;
		}
	}


	// Fix new position
	MST.DoKeys("{ENTER}");

	if(!bCheckOldPosition)
		nActualCount -= 2;

	// Return actual posizion change (in arrow hits)
	return (nActualCount < 0) ? -nActualCount: nActualCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\uwindow.h ===
///////////////////////////////////////////////////////////////////////////////
//      UIWINDOW.H
//
//      Created by :                    Date :
//              DavidGa                                 9/20/93
//
//      Description :
//              Declaration of the UIWindow class
//
//              The UIWindow is the basis of all utility classes associated with a
//              specific window.  Derive a new class from UIWindow for each new window
//              tpye necessary.
//

#ifndef __UIWINDOW_H__
#define __UIWINDOW_H__

#ifndef __STDAFX_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "guixprt.h"

enum UIWND_SPECIAL { UIWND_NONE, UIWND_SELF, UIWND_ACTIVE };

enum WINDOW_SIDE		{SLeft, STop, SRight, SBottom};
enum MOVE_DIRECTION	{DLeft, DUp, DRight, DDown};


///////////////////////////////////////////////////////////////////////////////
//      UIWindow class

// BEGIN_CLASS_HELP
// ClassName: UIWindow
// BaseClass: None
// Category: General
// END_CLASS_HELP
class GUI_CLASS UIWindow
{
public:
	void SetHWnd(HWND hWnd) { m_hWnd = hWnd; };
	UIWindow(HWND hwnd = NULL);
	HWND operator=(HWND hwnd);
	operator HWND ( ) {return HWnd();} ;
	operator BOOL() {return  m_hWnd == 0;} ;
	BOOL Attach(HWND hwnd);
	virtual inline BOOL AttachActive(void);
	virtual BOOL Find(void);
	inline BOOL Detach(void)
		{       return Attach(NULL); }
protected:
	virtual void OnUpdate(void);

// Data
private:
	HWND m_hWnd;

// Attributes
public:
	virtual BOOL IsValid(void) const;

	inline HWND HWnd(void) const
		{       return m_hWnd; }
	inline CWnd* PWnd(void) const
		{       return CWnd::FromHandle(m_hWnd); }
	inline operator HWND() const
		{       return m_hWnd; }

	inline BOOL operator==(HWND hwnd)
		{       return hwnd == HWnd(); }
	inline BOOL operator!=(HWND hwnd)
		{       return hwnd != HWnd(); }


// Utilities
public:
	LPCSTR GetText(LPSTR sz, int cMax) const;
	CString GetText(void) const;
	virtual BOOL IsActive(void);
	virtual BOOL Activate(void);
	virtual BOOL BlockingActivate(void);
	inline BOOL IsVisible(void) const
		{       return ::IsWindowVisible(HWnd()); }
	BOOL HasFocus(void) const;
	HWND WaitAttachActive(DWORD dwMilliseconds);
	BOOL WaitUntilGone(DWORD dwMilliSeconds);
	int ResizeWindow(BOOL bIsDocked, WINDOW_SIDE wSide, MOVE_DIRECTION wDirection, int count, BOOL DragFullWindows);
	int MoveWindow(BOOL bIsDocked, MOVE_DIRECTION wDirection, int count, BOOL DragFullWindows);

};

#define ExpectValid() EXPECT(IsValid())

/*      UIWND_COPY_CTOR
 *              Macro that makes constructors and operator= effectively virtual.
 *              Both functions operate by calling their base class versions until
 *              UIWindow is reached, which sets m_hWnd to the new value.
 *              On the way back up, each class's OnUpdate is called, so that any other
 *              member variables can be set up.
 */
#define UIWND_COPY_CTOR(this_class, base_class) \
	public: \
	inline this_class(HWND hwnd = NULL) \
		: base_class(hwnd) \
		{       this_class::OnUpdate(); } \
	inline HWND operator=(HWND hwnd) \
		{       base_class::operator=(hwnd); \
			/*this_class::OnUpdate();*/ \
			return hwnd; } \

#endif //__UIWINDOW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\testutil.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  TESTUTIL.CPP
//
//  Created by :            Date :
//      DavidGa                 8/20/93
//
//	Description :
//		Implementation of global utility functions
//

#include "stdafx.h"

#include <stdarg.h>
#include <stdio.h>
#include <fstream.h>
#include <windows.h>					    

#include "testutil.h"
#include "testxcpt.h"
#include "mstwrap.h"
#include "guiv1.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

//
//  Process Control
//

/* MilliSleep
 *  Sleeps for X milliseconds
 */
// BEGIN_HELP_COMMENT
// Function: void MilliSleep( DWORD milliseconds )
// Description: Sleep for the number of milliseconds specified. This function is obsolete; use ::Sleep() instead.
// Return: <none>
// Param: milliseconds A DWORD that specifies the number of milliseconds to sleep.
// END_HELP_COMMENT
GUI_API void MilliSleep( DWORD milliseconds )
{
/*  DWORD dwSleepUntil = GetTickCount() + milliseconds;
    while( GetTickCount() < dwSleepUntil );*/
	::Sleep(milliseconds);
}

// BEGIN_HELP_COMMENT
// Function: CString ExtractHotKey(CString)
// Description: Given a string, extracts the hotkeys and returns them as one string.
// Return: A CString containing the hotkeys.
// END_HELP_COMMENT
GUI_API CString ExtractHotKey(CString Caption)
{
	CString HotKeys;
	for(CString mnem; mnem != Caption; )
	{
	   mnem = Caption.SpanExcluding("&");
	   if (mnem != Caption) // If there was a hotkey in the menu string
	   {
		HotKeys += Caption.Mid(mnem.GetLength()+1,1);
		Caption = Caption.Mid(mnem.GetLength()+1) ; // Start the search past the previous &
	   }
	}
	return HotKeys;
}
//
//  Clipboard
//



// BEGIN_HELP_COMMENT
// Function: BOOL EmptyClip(void) 
// Description: Clear the text on the system clipboard. This functions is obsolete; use COClip::Empty() instead.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
GUI_API BOOL EmptyClip( /*BTHROW bThrowFail /*= DO_THROW*/ ) 
{
	if ( !OpenClipboard( NULL ) ) 
//		EXPECT_EXEC( bThrowFail, "Cannot open clipboard to empty contents" );
		LOG->RecordInfo("Cannot open clipboard to empty contents");
	else if ( !EmptyClipboard() )
	{
		CloseClipboard();
//		EXPECT_EXEC( bThrowFail, "Cannot empty clipboard" );
		LOG->RecordInfo("Cannot empty clipboard");
	}
	else
	{
		CloseClipboard();
		return TRUE;
	}
	return FALSE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL GetClipText( CString& rstrTextOut)
// Description: Get the text from the system clipboard. This functions is obsolete; use COClip::GetText() instead.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: A CString reference that will contain the text from the system clipboard.
// END_HELP_COMMENT
GUI_API BOOL GetClipText( CString& rstrTextOut/*, BTHROW bThrowFail /*= DO_THROW*/ )
{
	int tries = 3;

	while (--tries && !OpenClipboard( NULL )) Sleep(2000);
	if ( !tries )
//		EXPECT_EXEC( bThrowFail, "Cannot open clipboard to get text" );
		LOG->RecordInfo("Cannot open clipboard to get text");
	else
	{
		HANDLE hText = GetClipboardData( CF_TEXT );
		if ( !hText )
		{
			CloseClipboard();
//			EXPECT_EXEC( bThrowFail, "Cannot get handle to clipboard text" );
			LOG->RecordInfo("Cannot get handle to clipboard text");
		}
		else
		{
			LPSTR lpText = (LPSTR)GlobalLock( hText );
			if ( !lpText )
			{
				CloseClipboard();
//				EXPECT_EXEC( bThrowFail, "Cannot lock handle for clipboard text" );
				LOG->RecordInfo("Cannot lock handle for clipboard text");
			}
			else
			{
				rstrTextOut = lpText;
				GlobalUnlock( hText );
				CloseClipboard();
				return TRUE;
			}
		}   
	}
	return FALSE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL SetClipText( LPCSTR szTextIn)
// Description: Set the text in the system clipboard. This functions is obsolete; use COClip::SetText() instead.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: szTextIn A pointer to a string containing the text to put in the clipboard.
// END_HELP_COMMENT
GUI_API BOOL SetClipText( LPCSTR szTextIn/*, BTHROW bThrowFail /*= DO_THROW*/ )
{

// Don't delete the following EmptyClip call.

		if ( !EmptyClip() )
				return FALSE;

// The precedinging EmptyClip call is currently (4-20-94) needed because for some hideous reason CTL3D32.DLL will
// not pick up the true clipboard text if we just set the clipboard without emptying it first.  -CFlaat


    if ( !OpenClipboard( NULL ) )
    {
//        EXPECT_EXEC( bThrowFail, "Could not open clipboard to set text" );
		LOG->RecordInfo("Could not open clipboard to set text");
        return FALSE;
    }

    
    HANDLE hText = GlobalAlloc( GMEM_MOVEABLE | GMEM_DDESHARE, 1+strlen(szTextIn) );


    if ( !hText )
    {
        CloseClipboard();
//        EXPECT_EXEC( bThrowFail, "Could not allocate memory for clipboard text" );
		LOG->RecordInfo("Could not allocate memory for clipboard text");
        return FALSE;
    }
    

    LPSTR lpText = (LPSTR)GlobalLock( hText );

    if ( !lpText )
    {
        CloseClipboard();
        GlobalFree(hText);
//        EXPECT_EXEC( bThrowFail, "Could not lock handle for clipboard text" );
		LOG->RecordInfo("Could not lock handle for clipboard text");
        return FALSE;
    }

    strcpy( lpText, szTextIn);

    GlobalUnlock( hText );
    
    HANDLE hData = SetClipboardData( CF_TEXT, hText );

    CloseClipboard();

    if (!hData)
    {
//        EXPECT_EXEC( bThrowFail, "Could not set clipboard data" );
		LOG->RecordInfo("Could not set clipboard data");
        return FALSE;
    }

 
    return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: void PasteKeys(LPCSTR szPasteText)
// Description: Paste the given string into the control with the focus.
// Param: szPasteText A pointer to a string that contains the text to paste.
// END_HELP_COMMENT
GUI_API void PasteKeys(LPCSTR szPasteText/*, BTHROW bThrowFail /*= DO_THROW*/)
{
  if (SetClipText(szPasteText/*, bThrowFail*/))
    MST.DoKeys("^v");
    else
    {
//      EXPECT_EXEC(bThrowFail, "Can't set clipboard text in PasteKeys!");
	  LOG->RecordInfo("Can't set clipboard text in PasteKeys!");
        Sleep(500); // maybe it was a synchronization problem
        MST.DoKeys(szPasteText);  // try to stuff 'em in anyway
    }
}

/*	DoKeysSlow
 *		Uses QueKeys rather than DoKeys to put a delay between each character.
 *		Used because speed bugs found by autotests aren't realistic.
 */
// BEGIN_HELP_COMMENT
// Function: void DoKeysSlow(LPCSTR szKeys, WORD wMilliseconds = 0, BOOL bLiteral = FALSE)
// Description: Perform DoKeys at a slower rate.
// Param: szKeys Pointer to a null-terminated string containing the DoKeys-formatted keystrokes.
// Param: wMilliseconds The number of milliseconds to wait between keystrokes. (Default value is 0.)
// Param: bLiteral TRUE to interpret the keystrokes literally; FALSE to interpret the keystrokes as DoKeys keystrokes. (Default value is FALSE.)
// END_HELP_COMMENT
GUI_API void DoKeysSlow(LPCSTR szKeys, WORD wMilliseconds /*=0*/, BOOL bLiteral /*=FALSE*/)
{
	if( !bLiteral )
	{
		WaitStepInstructions("Do Keys '%s'", szKeys);
		MST.QueSetSpeed(wMilliseconds);
		MST.QueKeys((LPSTR)szKeys);
		MST.QueFlush();
		MST.QueSetSpeed(0);		// reset to no delay
		return;
	}
	CString str;
	while( *szKeys != '\0' )	// this routine taken from MST.DoKeys.  Maybe we need a helper function.
	{						
		if( strchr("+^%(){}~", *szKeys) == NULL )
		{
			str += *szKeys++;
			if( IsDBCSLeadByte(*szKeys) )
				str += *szKeys++;
		}
		else
		{
			str += "{";			// enclose every control character in {}
			str += *szKeys++;	// so MS-Test to treats them literally
			str += "}";
		}					// NOTE: \x escape codes still work
	}
	WaitStepInstructions("Do Keys '%s'", str);
	MST.QueSetSpeed(wMilliseconds);
	MST.QueKeys(str);
	MST.QueFlush();
	MST.QueSetSpeed(0);
	return;
}


/*  ClickMouse    (Enriquep)
       Takes a set of coordinates and a handle to a Window
       and clicks either of the mouse buttons there       */

//REVIEW: Overload function to take a CPoint 
// BEGIN_HELP_COMMENT
// Function: void ClickMouse(int nButton, HWND hwnd, int cX,  int cY) 
// Description: Click the mouse at the given coordinates (relative to the window specified).
// Return: <none>
// Param: nButton An integer that specifies the button to click: VK_LBUTTON, VK_MBUTTON, VK_RBUTTON.
// Param: hwnd An HWND that specifies the window to click in.
// Param: cX An integer that specifies the x-coordinate of the click.
// Param: cY An integer that specifies the y-coordinate of the click.
// END_HELP_COMMENT
GUI_API void ClickMouse( int nButton, HWND hwnd, int cX,  int cY) 
{
	CPoint ptClick(cX, cY);
	if (hwnd != NULL)
		ClientToScreen(hwnd, &ptClick);

	WaitStepInstructions("Click mouse at %d,%d", ptClick.x, ptClick.y);

	// SPEED 10   *if NT
	MST.QueMouseClick(nButton, ptClick);
	MST.QueFlush(TRUE);   
}



/*  XDragMouse       (Enriquep)
 *      Takes two sets of coordinates (including a handle to a window)
 *      and drags from point1 to point2
 */
// REVIEW: Overload to remove the second CWnd*
// BEGIN_HELP_COMMENT
// Function: void DragMouse(int nButton, HWND hwnd1, int cX1, int cY1, HWND hwnd2, int cX2, int cY2)
// Description: Drag the mouse from the given coordinates to the given coordinates (relative to the window specified).
// Return: <none>
// Param: nButton An integer that specifies the button to click: VK_LBUTTON, VK_MBUTTON, VK_RBUTTON.
// Param: hwnd1 An HWND that specifies the window to start dragging from.
// Param: cX1 An integer that specifies the x-coordinate of the beginning drag position.
// Param: cY1 An integer that specifies the y-coordinate of the beginning drag position.
// Param: hwnd2 An HWND that specifies the window the end dragging in.
// Param: cX2 An integer that specifies the x-coordinate of the ending drag position.
// Param: cY2 An integer that specifies the y-coordinate of the ending drag position.
// END_HELP_COMMENT
GUI_API void DragMouse ( int nButton, HWND hwnd1, int cX1, int cY1, HWND hwnd2, int cX2, int cY2)
{
	// Mouse down at point1    

	CPoint ptFrom(cX1, cY1);
	ASSERT(hwnd1 != NULL);
		ClientToScreen(hwnd1, &ptFrom);

	CPoint ptTo(cX2, cY2);
	ASSERT(hwnd2 != NULL);
		ClientToScreen(hwnd2, &ptTo);

	WaitStepInstructions("Drag mouse from %d,%d to %d,%d", ptFrom.x, ptFrom.y, ptTo.x, ptTo.y);

	MST.QueMouseDn(nButton, ptFrom);
	//  Drag.  Mouse up at X2,Y2 on dialog2 (possibly the same dialog)
	// SPEED 10         if NT
	MST.QueMouseMove(ptTo);
	MST.QueMouseUp(nButton,ptTo);

	QueFlush(TRUE);
}

/*  ScreenToClient and ClientToScreen
 *      are provided because these MFC functions are widely used,
 *      and would be missed if UWindow restricts use of MFC.
 */
// BEGIN_HELP_COMMENT
// Function: BOOL ScreenToClient(HWND hwnd, CRect* pRect)
// Description: Converts the coordinates in the given rectangle from screen coordinates to client coordinates for the specified window.
// Return: A Boolean value that indicates success. TRUE if success; FALSE otherwise.
// Param: hwnd An HWND that specifies the window to convert the screen coordinates to client coordinates.
// Param: pRect A pointer to a CRect that contains the rectangle to convert. The converted coordinates will be stored in this object when the function returns.
// END_HELP_COMMENT
GUI_API BOOL ScreenToClient(HWND hwnd, CRect* pRect)
{
	return ScreenToClient(hwnd, (LPPOINT)pRect) &&      // top-left
			ScreenToClient(hwnd, ((LPPOINT)pRect+1));   // bottom-right
}

// BEGIN_HELP_COMMENT
// Function: BOOL ClientToScreen(HWND hwnd, CRect* pRect)
// Description: Converts the coordinates in the given rectangle from client coordinates for the specified window to screen coordinates.
// Return: A Boolean value that indicates success. TRUE if success; FALSE otherwise.
// Param: hwnd An HWND that specifies the window that contains the client coordinates.
// Param: pRect A pointer to a CRect that contains the rectangle to convert. The converted coordinates will be stored in this object when the function returns.
// END_HELP_COMMENT
GUI_API BOOL ClientToScreen(HWND hwnd, CRect* pRect)
{
	return ClientToScreen(hwnd, (LPPOINT)pRect) &&      // top-left
			ClientToScreen(hwnd, ((LPPOINT)pRect+1));   // bottom-right
}

/*  CompareFiles    (Enriquep)
 *      Compares two files given two path strings
 *      returns CF_SAME (0) if identical, 
 *      or an error code describing the difference
 */
// BEGIN_HELP_COMMENT
// Function: int CompareFiles(LPCSTR strSource, LPCSTR strTarget, int nStart)
// Description: Compare the contents of two files.
// Return: A value that specifies the result of the comparison: CF_SAME, CF_DUPNAME, CF_CANTOPEN1, CF_CANTOPEN2, CF_DIFFSIZE, CF_NOTSAME.
// Param: strSource A pointer to a string that contains the path and filename of the first file to compare.
// Param: strTarget A pointer to a string that contains the path and filename of the second file to compare.
// Param: nStart An integer that contains the offset from the beginning of the files to start the comparison.
// END_HELP_COMMENT
GUI_API int CompareFiles(LPCSTR strSource, LPCSTR strTarget, int nStart)
{
    // Error if the file names are the same
    if ( lstrcmp( strSource, strTarget ) == 0 )
        return CF_DUPNAME;

    // Open both the files
    HFILE hSource, hTarget;
    if ( (hSource = _lopen( strSource, OF_READ )) == -1 )
        return CF_CANTOPEN1;

    if ( (hTarget = _lopen( strTarget, OF_READ )) == -1 )
    {
        _lclose( hSource );
        return CF_CANTOPEN2;
    }

    // Check and see if the files are the same size
    LONG SourceSize = _llseek( hSource, 0L, SEEK_END );
    LONG TargetSize = _llseek( hTarget, 0L, SEEK_END );
    if (SourceSize != TargetSize)
    {
        _lclose( hSource );
        _lclose( hTarget );
        return CF_DIFFSIZE;
    }

    // Reset file pointers and compare byte-by-byte
    // Start comparing at "nStart", used since the header 
    // will be different depending on the device...
    if (nStart < 0)
        nStart = 0;
    _llseek( hSource, (LONG)nStart, SEEK_SET );
    _llseek( hTarget, (LONG)nStart, SEEK_SET );

    char iSource[512], iTarget[512];
    int cbIntSize = 512;
    int cbBytesRead;

    do
    {
        cbBytesRead = _lread(hSource, &iSource, cbIntSize);
        cbBytesRead = _lread(hTarget, &iTarget, cbIntSize);

        if (memcmp(&iSource, &iTarget, cbBytesRead) != 0)
        {
            _lclose( hSource );
            _lclose( hTarget );
            return CF_NOTSAME;
        }
    } while (cbBytesRead > (cbIntSize-1));

    /* Close files */
    _lclose( hSource );
    _lclose( hTarget );


    return CF_SAME;
}

/*	KillFile
 *		Deletes all files that meet the pattern provided.
 *		If any of these files cannot be deleted (e.g. directories and read-only
 *		files), KillFile will abort - so don't KillFile("*.*");
 *		If you really do want to delete read-only files, pass TRUE for the 3rd param.
 */
// BEGIN_HELP_COMMENT
// Function: void KillFile(LPCSTR szPathName, LPCSTR szFileName = NULL, BOOL bIgnoreReadOnly = FALSE)
// Description: Delete all files that match the pattern provided in szFileName.
// Param: szPathName A string containing the path to the files.
// Param: szFileName A string containing the filename to delete (wildcards are supported).
// Param: bIgnoreReadOnly TRUE to ignore the read-only bit; FALSE to honor the read-only bit.
// END_HELP_COMMENT
GUI_API void KillFile(LPCSTR szPathName, LPCSTR szFileName /*=NULL*/, BOOL bIgnoreReadOnly /*=FALSE*/)
{
	WIN32_FIND_DATA ffdImgFile;
	HANDLE hFile;
	CString strPattern, strPath = szPathName;
	if( szFileName != NULL )
	{
		if( (strPath.Right(1) != "\\") && (szFileName[0] != '\\') )
			strPath += "\\";
		strPattern = strPath + szFileName; 
	}
	else
		strPattern = strPath;

	while( (hFile = FindFirstFile(strPattern, &ffdImgFile)) != INVALID_HANDLE_VALUE )
	{
		BOOL bCantDelete;
		CString str = strPath + ffdImgFile.cFileName;
		if( !(bCantDelete = DeleteFile(str)) )
		{
			DWORD dwStyle = GetFileAttributes(str);
			if( dwStyle & FILE_ATTRIBUTE_READONLY )
			{
				if( bIgnoreReadOnly )	// try again if test doesn't care about read-only
				{
					LOG->RecordInfo("Attempting to delete read-only file '%s'", (LPCSTR)str);
					SetFileAttributes(str, dwStyle & ~FILE_ATTRIBUTE_READONLY);
					if( !(bCantDelete = DeleteFile(str)) )
					{
						SetFileAttributes(str, dwStyle);	// might as well revert to previous attributes
						LOG->RecordInfo("Still couldn't delete '%s'.  Aborting KillFile function.", (LPCSTR)str);
					}
				}
				else
					LOG->RecordInfo("Unable to delete '%s'.  File was read-only.  Aborting KillFile function.", (LPCSTR)str);
			}
		}
		FindClose(hFile);
		if( !bCantDelete )	// if DeleteFile failed, don't bother continueing, 
			return;			// because FindFirstFile will grab the same file.
	}
}

/* KillAllFiles
 *  The equivalent of calling KillFile(szPathName, "*.*");
 *  except that *.* doesn't work for KillFile, because "." and ".." get found.
 */

// BEGIN_HELP_COMMENT
// Function: void KillAllFiles(LPCSTR szPathName, BOOL bRemoveDir = TRUE)
// Description: Delete an entire directory, recursively.
// Param: szPathName A pointer to a string that contains the path to the directory to be deleted.
// Param: bRemoveDir TRUE to remove the directory itself; FALSE to keep the directory but delete all the files in it.
// END_HELP_COMMENT
GUI_API BOOL KillAllFiles(LPCSTR szPathName, BOOL bRemoveDir /*=TRUE*/)
{
	CStringArray sa;
	WIN32_FIND_DATA ffdImgFile;

	CString strPattern = szPathName;

	if (strPattern.SpanExcluding(" ").IsEmpty())
		return FALSE;

#ifdef _DEBUG
	if (bRemoveDir && !CMDLINE->IsDefined("no_del_warn"))
	{
		CFileStatus status;
		CFile::GetStatus(szPathName, status);
		CString strMsg = CString("About to delete everything starting at ") + status.m_szFullName;

		HWND hwndTarget = GetForegroundWindow();	// Save active target window.
		SetForegroundWindow(g_hwndHotKey);	
		int choice = MessageBox(g_hwndHotKey, strMsg, "CAFE Warning", MB_YESNO | MB_ICONEXCLAMATION);
		SetForegroundWindow(hwndTarget);			// Restore focus to target.
		
		while(GetForegroundWindow() != hwndTarget)	// Wait for full activation!
			;

		if (choice == IDNO)
			return FALSE;
	}

#endif

	if( strPattern.Right(1) != "\\" )
		strPattern += "\\";
	strPattern += "*.*";

	HANDLE hFile = FindFirstFile(strPattern, &ffdImgFile);
	if( hFile != INVALID_HANDLE_VALUE )
		do
		{
			if( !(ffdImgFile.dwFileAttributes & FILE_ATTRIBUTE_READONLY))
			{
				// Modified to handle handle nested subdirectories (Ivanl)
				if(ffdImgFile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) // if a directory 
				{  CString Name = ffdImgFile.cFileName ;
					if((Name != ".") && (Name != ".."))
					{
				 		CString newPath = szPathName ;
				 		if(newPath.Right(1) != "\\")  //If the pathname didn't have a "\" add one.
				 			newPath += "\\" ;
				 		newPath += ffdImgFile.cFileName ;
						// KillAllFiles recursively
				 		KillAllFiles(newPath);
					}
				}
				if(!(ffdImgFile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) 
					sa.Add(ffdImgFile.cFileName);	// build a list of the rest
			}				// this way I don't disrupt the file finding routines
			
		}
						// by deleting the reference points it is using
		while( FindNextFile(hFile, &ffdImgFile) );
	FindClose(hFile);	

	for( int n = 0; n < sa.GetSize(); n++ )
		KillFile(szPathName, sa.GetAt(n));		// delete all the files we could.

	return bRemoveDir && RemoveDirectory(szPathName);
}

// BEGIN_HELP_COMMENT
// Function: BOOL CopyTree(LPCSTR szFrom, LPCSTR szTo)
// Description: Copy a tree of directories and files from one tree to another.
// Return: FALSE on failure
// Param: szFrom A pointer to a string that contains the path to the source tree (the tree to copy from).
// Param: szTo A pointer to a string that contains the path to the destination tree (the tree to copy to).
// END_HELP_COMMENT
GUI_API BOOL CopyTree(LPCSTR szFrom, LPCSTR szTo)
{
    _TCHAR acFrom[_MAX_PATH];

    lstrcpy(acFrom, szFrom);
    int nFrom = lstrlen(acFrom);
	ASSERT(nFrom);
	_TCHAR* pszFromEnd = &acFrom[nFrom];
	ASSERT(!*pszFromEnd);
	if(_tcsncmp(_tcsdec(acFrom, pszFromEnd), _T("\\"), 1))
	{
		lstrcpy(pszFromEnd, _T("\\"));
		pszFromEnd = _tcsinc(pszFromEnd);
	}
	lstrcat(acFrom, "*.*");

	_TCHAR acTo[_MAX_PATH];
    lstrcpy(acTo, szTo);
    int nTo = lstrlen(acTo);
	ASSERT(nTo);
	_TCHAR* pszToEnd = &acTo[nTo];
	ASSERT(!*pszToEnd);
	if(_tcsncmp(_tcsdec(acTo, pszToEnd), _T("\\"), 1))
	{
		lstrcpy(pszToEnd, _T("\\"));
		pszToEnd = _tcsinc(pszToEnd);
	}

    WIN32_FIND_DATA ffdImgFile;
    HANDLE hFile = FindFirstFile(acFrom, &ffdImgFile);
    if( hFile != INVALID_HANDLE_VALUE )
    {
        do
        {
            lstrcpy(pszFromEnd, ffdImgFile.cFileName);
            lstrcpy(pszToEnd, ffdImgFile.cFileName);
            if( !(ffdImgFile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
            {
				if(!CopyFile(acFrom, acTo, FALSE))      // could add fFailIfExists as optional param
				{
					LOG->RecordInfo("Can't CopyFile() %s to '%s'. Aborting CopyTree function.", (LPCSTR)acFrom, (LPCSTR)acTo);
					return FALSE;
				}
                DWORD dwAttrib = ffdImgFile.dwFileAttributes & ~(FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM);
                if(!SetFileAttributes(acTo, dwAttrib))
				{
					LOG->RecordInfo("Can't SetFileAttributes() on %s'. Aborting CopyTree function.", (LPCSTR)acTo);
					return FALSE;
				}
            }
            else if( (strcmp(ffdImgFile.cFileName, ".") != 0) &&
                    (strcmp(ffdImgFile.cFileName, "..") != 0) )     // ignore . and ..
            {
                if(!CreateDirectory(acTo, NULL))
				{
					LOG->RecordInfo("Can't CreateDirectory() %s'. Aborting CopyTree function.", (LPCSTR)acTo);
					return FALSE;
				}
				if(!CopyTree(acFrom, acTo))     // recursive call for subdirectories
					return FALSE;
            }
        } while( FindNextFile(hFile, &ffdImgFile) );

        EXPECT( GetLastError() == ERROR_NO_MORE_FILES );
    }
	return TRUE;
}

/*	FindStrInFile
 *		Searches a text file for a string
 *		Returns the line# on which it was found (first line is #1)
 *		or returns 0 if string not found
 */
// BEGIN_HELP_COMMENT
// Function: int FindStrInFile(LPCSTR szFileName, LPCSTR szStr, int nStart /*=1*/)
// Description: Search for the specified string in a file.
// Return: An integer that contains the line number in the file that contains the string. 0 if the string was not found.
// Param: szFileName A pointer to a string that contains the path and filename of the file to search.
// Param: szStr A pointer to the string to find.
// Param: nStart An integer that contains the offset from the beginning of the file to start the search.
// END_HELP_COMMENT
GUI_API int FindStrInFile(LPCSTR szFileName, LPCSTR szStr, int nStart /*=1*/)
{
	ifstream f(szFileName, ios::in | ios::nocreate);
	if( !f.is_open() )
	{
		LOG->RecordInfo("FindStrInFile: Can't open %s", szFileName);
		return 0;
	}

	int nLine = 0;
	char acBuf[512];
	while( f.getline(acBuf, 512, '\n') )
	{
		nLine++;
		if( (nLine >= nStart) && (strstr(acBuf, szStr) != NULL) )
			return nLine;	// return on what line we found the string
	}
	return 0;	// string not found (or it was before line nStart)
}
	
	
/*  GetText
 *      GetWindowText should SendMessage(WM_GETTEXT), but doesn't always.
 *      Therefore, here are two versions of a function that will.
 */
// BEGIN_HELP_COMMENT
// Function: LPCSTR GetText(HWND hwnd, LPSTR sz, int cMax)
// Description: Get the text associated with the specified window by sending the WM_GETTEXT message to the window.
// Return: A pointer to the buffer specified by sz that contains the text associated with the window.
// Param: hwnd An HWND of the window to get the text for.
// Param: sz A pointer to a buffer that will contain the text associated with the window.
// Param: cMax An integer that specifies the maximum size of the buffer sz.
// END_HELP_COMMENT
GUI_API LPCSTR GetText(HWND hwnd, LPSTR sz, int cMax)
{
	if( hwnd == NULL )	// REVIEW(davidga): can SendMessage handle NULL hwnd?
		*sz = '\0';
	else		
		::SendMessage(hwnd, WM_GETTEXT, (WPARAM)cMax, (LPARAM)sz);
	return sz;
}

// BEGIN_HELP_COMMENT
// Function: CString GetText(HWND hwnd)
// Description: Get the text associated with the specified window by sending the WM_GETTEXT message to the window.
// Return: A pointer to a buffer that contains the text associated with the window.
// Param: hwnd An HWND of the window to get the text for.
// END_HELP_COMMENT
GUI_API CString GetText(HWND hwnd)
{
	CString str;
	GetText(hwnd, str.GetBufferSetLength(256), 255);    // call first function
	str.ReleaseBuffer(-1);
	return str;
}

/* Do

 *  Calls DoSingleMenu, passing each of the szMenu parameters in turn.
 *  If we fail to execute any of the steps, we escape out of the menu 
 *  structure, and return an index (base 1) to that step.  Thus, returning 
 *  zero is good, while returning non-zero signifies an error.
 */
// BEGIN_HELP_COMMENT
// Function: int DoMenu(LPCSTR szMenu1, LPCSTR szMenu2, LPCSTR szMenu3 /*=NULL*/, LPCSTR szMenu4 /*=NULL*/, LPCSTR szMenu5 /*=NULL*/, LPCSTR szMenu6 /*=NULL*/, LPCSTR szMenu7 /*=NULL*/, LPCSTR szMenu8 /*=NULL*/, LPCSTR szMenu9 /*=NULL*/)
// Description: Open a series of menus. This function is obsolete; use CMSTest::DoMenu() instead.
// Return: An integer that indicates success. 0 if success; a positive value that contains the menu level that failed otherwise.
// Param: szMenu1 A pointer to a string that contains the name of the menu to open.
// Param: szMenu2 A pointer to a string that contains the name of the menu to open.
// Param: szMenu3 A pointer to a string that contains the name of the menu to open. (Default value is NULL.)
// Param: szMenu4 A pointer to a string that contains the name of the menu to open. (Default value is NULL.)
// Param: szMenu5 A pointer to a string that contains the name of the menu to open. (Default value is NULL.)
// Param: szMenu6 A pointer to a string that contains the name of the menu to open. (Default value is NULL.)
// Param: szMenu7 A pointer to a string that contains the name of the menu to open. (Default value is NULL.)
// Param: szMenu8 A pointer to a string that contains the name of the menu to open. (Default value is NULL.)
// Param: szMenu9 A pointer to a string that contains the name of the menu to open. (Default value is NULL.)
// END_HELP_COMMENT
GUI_API int DoMenu( LPCSTR szMenu1, LPCSTR szMenu2, LPCSTR szMenu3, 
			LPCSTR szMenu4, LPCSTR szMenu5, LPCSTR szMenu6,
			LPCSTR szMenu7, LPCSTR szMenu8, LPCSTR szMenu9 )
{
	LPCSTR aMenu[10];       // arbitrary limit of 9 menu levels
	aMenu[0] = szMenu1;     // params 3-9 default to NULL
	aMenu[1] = szMenu2;     // 2 params are required, to differentiate DoMenu's
	aMenu[2] = szMenu3;
	aMenu[3] = szMenu4;
	aMenu[4] = szMenu5;
	aMenu[5] = szMenu6;
	aMenu[6] = szMenu7;
	aMenu[7] = szMenu8;
	aMenu[8] = szMenu9;
	aMenu[9] = NULL;

	int i = 0;
	LPCSTR szMenu;
	while( (szMenu = aMenu[i++]) != NULL )
	{
		if( !DoSingleMenu(szMenu) )
		{
//          WMenuEnd();     // does "% %" to clear any lingering menu state
			return i;       // return which menu level failed
		}
	}
	return 0;
}

/* DoMenu
 *  Variation of the above DoMenu, which receives all of its menu strings
 *  in a \0 delimited list.
 *  Otherwise, the behavior and return value are the same.
 */
// BEGIN_HELP_COMMENT
// Function: int DoMenu(LPCSTR szMenu)
// Description: Open a series of menus in a NULL-separated list. This function is obsolete; use CMSTest::DoMenu() instead.
// Return: An integer that indicates success. 0 if success; a positive value that contains the menu level that failed otherwise.
// Param: szMenu A pointer to a string that contains the names of the menu to open. The list of menus is NULL-separated and NULL-terminated.
// END_HELP_COMMENT
GUI_API int DoMenu(LPCSTR szMenu)
{
    ASSERT( szMenu != NULL );

    int i = 1;
    LPCSTR pchSingle = szMenu;
    while( *pchSingle != '\0' )
    {
        if( !DoSingleMenu(pchSingle) )
        {
            MST.WMenuEnd();     // does "% %" to clear any lingering menu state
            return i;       // return which menu level failed
        }
        pchSingle += strlen(pchSingle) + 1;
        i++;
    }
    return 0;
}

/* DoSingleMenu
 *  Activates a menu in the current popup.
 *  Before the menu is called, we check if it exists, and if it's enabled.
 */
// BEGIN_HELP_COMMENT
// Function: BOOL DoSingleMenu(LPCSTR szMenu)
// Description: Open a menu. This function is obsolete; use CMSTest::DoMenu() instead.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: szMenu A pointer to a string that contains the name of the menu to open.
// END_HELP_COMMENT
GUI_API BOOL DoSingleMenu(LPCSTR szMenu)
{
//LOG->Comment("DoSingleMenu : start %s", szMenu);
    if( !MST.WMenuExists(szMenu) )
    {
        MilliSleep(500);            // sleep 1/2 second
        if( !MST.WMenuExists(szMenu) )  // and try again
        {
            LOG->Comment("'%s' menu doesn't exist", szMenu);
            return FALSE;
        }
    }
//LOG->Comment("DoSingleMenu : WMenuExists %s", szMenu);

    if(!MST.WMenuEnabled(szMenu))
    {
        LOG->Comment("'%s' menu isn't enabled", szMenu);
        return FALSE;
    }
//LOG->Comment("DoSingleMenu : WMenuEnabled %s", szMenu);

    MST.WMenu(szMenu);
//LOG->Comment("DoSingleMenu : WMenu %s", szMenu);

#if 0
	// this is no longer possible for the current command bars code
    if( MST.WMenuExists(szMenu) )   // except for top-level non-popups (and coincidental dups)
    {                           // this is always false if WMenu succeeds
//LOG->Comment("DoSingleMenu : Toplevel failed - sleep .5 sec");
        MilliSleep(500);            // sleep .5 seconds
//LOG->Comment("DoSingleMenu : Toplevel failed - done sleeping");
        if( MST.WMenuExists(szMenu) )   // and if it's still not up
        {
            LOG->Comment("'%s' menu isn't popping up!  Trying one more time.", szMenu);
            MST.WMenu(szMenu);          // try again
                if( MST.WMenuExists(szMenu) )
                {
                    LOG->Comment("Nope, I give up on menu '%s'.", szMenu);
                    return FALSE;   // if it's still not up, fail as disabled
                }
        }
    }   // REVIEW: This presumes that all top level menus are popups
//LOG->Comment("DoSingleMenu : done %s", szMenu);
#endif
    return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL IsWindowActive(LPCSTR szWndTitle)
// Description: Determine if the specified window is the active window.
// Return: A Boolean value that indicates whether the specified window is the active window (TRUE) or not.
// Param: szWndTitle A pointer to a string that contains the title of the window.
// END_HELP_COMMENT
GUI_API BOOL IsWindowActive(LPCSTR szWndTitle)
{
	HWND hwnd = MST.WGetActWnd(0);
	char acBuf[256];
	GetText(hwnd, acBuf, 255);
	if (strcmp(acBuf, szWndTitle) != 0)  
		return FALSE;
	return TRUE;
}

// REVIEW(briancr): this needs to be code reviewed
// BEGIN_HELP_COMMENT
// Function: BOOL WaitMsgBoxText(LPCSTR szExpect, int nSeconds)
// Description: Wait for a specific message to be active.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: szExpect A pointer to a string that contains the partial text expected in the message box.
// Param: nSeconds An integer that specifies the number of seconds to wait for the message box to appear.
// END_HELP_COMMENT
GUI_API BOOL WaitMsgBoxText(LPCSTR szExpect, int nSeconds)
{
	// rumor has it that there's a bug in WFndWndWaitC, 
	// so Brian was just looping using WFndWndC

	// REVIEW (michma): in some cases when no msg box comes up this function is making the
	// originally active window inactive and not re-activating it, causing tests to fail.
	HWND hwndActive = MST.WGetActWnd(0);

	// is there any msg/dlg box at all?
	if( MST.WFndWndWait(NULL, FW_DIALOG | FW_PART | FW_NOCASE | FW_FOCUS, nSeconds) )
	{
		HWND hwndText;
		// REVIEW(michma - 6/3/99): we're seeing this weird problem on w2k where a data breakpoint hit
		// message is coming up but the dlg isn't active. doesn't happen manually, only when Go is done
		// through cafe. this is a work-around so we can find the expected static text.
		// is there a second static text field?
		if( (hwndText = MST.WFndWndC("@2", "Static", GetSystem() & SYSTEM_NT_5 ? FW_DEFAULT : FW_ACTIVE)) != NULL )
		{
			// get the text from the second static text field
			CString strActual = GetText(hwndText);
			// is the expected string part of the actual string?
			if( strActual.Find(szExpect) != -1 )
				return TRUE;
		}
	}

	// no msg box was found, so restore focus to original window with focus (see michma REVIEW above).
	MST.WSetActWnd(hwndActive);
	return FALSE;
}


/*	GetLabelNo
 *		Determines the ord number of a class of a control given its hwnd
 */
GUI_API int GetLabelNo(HWND hCtl)
{ // REVIEW(DavidGa): MSVCStaticWindow - not generic!!
static LPCSTR szDialogControlLabels[] = {
	"Static",
	"Button",
	"Edit",
	"ListBox",
	"ComboBox",
	"SysListView32",
	"TabView32",
	"TreeView32",
	"Scrollbar32",
	"Slider32",
	"Spin32",
	"Statusbar32",
	"MSVCStaticWindow",
	"#32770"
}; //if you add/rearrange strings, make sure the public values
//	enum { GL_NONE, GL_STATIC, ...}
//  correspond correctly to the strings

	char acClass[128];
	GetClassName(hCtl, acClass, 128);
	int nlabels=sizeof(szDialogControlLabels)/sizeof(szDialogControlLabels[0]);
	for(int ilab=0;ilab<nlabels;ilab++)
		if(strstr(szDialogControlLabels[ilab],acClass)!=NULL)
			return ilab;
	LOG->RecordInfo("Unknown control '0x%X' class: (%s)", hCtl, acClass);
	return GL_NONE;
}

/*	GetLabel
 *		If the control is a list box, combo box, or edit field, the caption
 *		is the static control immediately preceding the control.
 *		Only the immediate children of the HWND are searched.  If no HWND
 *		is provided, the active popup window (presumably a dialog) is used.
 *		The bOkNoExist flag states whether to WriteWarning if the control isn't found.
 */

// BEGIN_HELP_COMMENT
// Function: LPCSTR GetLabel(UINT id, HWND hwnd /*=NULL*/, BOOL bOkNoExist /*=FALSE*/)
// Description: Get the caption of a control given its ID. If the control is a list box, combo box, or edit box, the caption is the static control immediately preceeding the control. Only the immediate children of the given window are searched.
// Return: A pointer to a string that contains the caption of the control.
// Param: id An integer that specifies the ID of the control.
// Param: hwnd An HWND that specifies the window that contains the control. NULL means use the currently active window. (Default value is NULL.)
// Param: bOkNoExist A Boolean value that specifies whether to log information if the control is not found (FALSE) or not.
// END_HELP_COMMENT
GUI_API LPCSTR GetLabel(UINT id, HWND hwnd /*=NULL*/, BOOL bOkNoExist /*=FALSE*/)
{
	static CString strLabel;	// contains the label name through end of scope
		// but DONT maintain a pointer here - stick it in a CString of your own!

	//HWND hwndDialog = hwnd == NULL ? WGetActWnd(0) : hwnd;  Changed by (Ivan) to handle AppWiz dlgs
	HWND hwndDialog = hwnd == NULL ? ControlOnPropPage(id) : hwnd;
	HWND hwndControl = GetDlgItem(hwndDialog, id);
	if( !IsWindow(hwndControl) )
	{
		if( !bOkNoExist )
			LOG->RecordInfo("Could not find a control 0x%X in dialog 0x%X ('%s')", id, hwndDialog, (LPCSTR)GetText(hwndDialog));
		return NULL;
	}

	char acClass[128];
	GetClassName(hwndControl, acClass, 128);
	int iClass = GetLabelNo(hwndControl);

	switch( iClass )
	{
		case GL_STATIC:
		case GL_BUTTON:
		case GL_MSVCSTATIC:
			strLabel = GetText(hwndControl);
			return strLabel;
		case GL_LISTVIEW:
			strLabel = GetText(hwndControl);
			return strLabel;
		case GL_EDIT:
		case GL_LISTBOX:
		case GL_COMBOBOX:
		{
			HWND hwndLabel = GetWindow(hwndControl, GW_HWNDPREV);
			if( hwndLabel == NULL )
			{
				LOG->RecordInfo("Found 0x%X (%s), but no label precedes it.", hwndControl, acClass);
				return NULL;
			}

			char acLabelClass[128];
			GetClassName(hwndLabel, acLabelClass, 128);
			int iPrec=GetLabelNo(hwndLabel);
			if( (iPrec == GL_STATIC) ||
				(iPrec == GL_MSVCSTATIC) )
			{
				strLabel = GetText(hwndLabel);
				return strLabel;
			}
			else
			{
				LOG->RecordInfo("Found 0x%X (%s), but the preceding control is a '%s', not a static label.", hwndControl, acClass, acLabelClass);
				return NULL;
			}
		}
		case GL_DIALOG:
		case GL_NONE:
		default:
			LOG->RecordInfo("Found the control 0x%X, but I can't figure out what it is (it says it's a '%s').", hwndControl, acClass);
	}
	return NULL;
}



// BEGIN_HELP_COMMENT
// Function: int GetDlgControlClass(HWND hCtl) 
// Description: Get the window class type of the specified control.
// Return: A value that indicates the window class type of the control: GL_NONE, GL_STATIC, GL_BUTTON, GL_EDIT, GL_LISTBOX, GL_COMBOBOX, GL_DIALOG, GL_CHECKBOX, GL_RADIOBUTTON.
// Param: hCtl An HWND that specifies the control.
// END_HELP_COMMENT
GUI_API int GetDlgControlClass(HWND hCtl) 
{
	// Validate the Window handle.
	if( !IsWindow(hCtl) )
	{
		LOG->RecordInfo("Cannot get control class of invalid HWND 0x%08x", hCtl);
		return GL_NONE;
	}

	int iClass = GetLabelNo(hCtl);
	
	if (iClass == GL_BUTTON) // If button 
		{	DWORD dwStyle = GetWindowLong(hCtl,GWL_STYLE) ;
		
			// Determine what kind of button 
			// If checkbutton
			if((dwStyle & BS_3STATE) || (dwStyle & BS_AUTO3STATE) || (dwStyle & BS_AUTOCHECKBOX) || (dwStyle & BS_CHECKBOX))
			{
				return GL_CHECKBOX ;
			}
			// If Radiobutton
			if ((dwStyle & BS_RADIOBUTTON) || (dwStyle & BS_AUTORADIOBUTTON))
			{
				return GL_RADIOBUTTON ;
			}
			// If any other button
			if ((dwStyle & BS_OWNERDRAW) || (dwStyle & BS_DEFPUSHBUTTON) || (dwStyle & BS_PUSHBUTTON))
			{
			 	return iClass ;
			}
		}

	return iClass ;
}


// Tabbed dialog support functions. 

/* 
 *	ControlOnProjPage(int) determines whether a given control identified by its ID exisists on 
 *	the current page. This works for both property paged and tabbed dialog pages.
 *	(Ivanl)
 */

HWND hActive = NULL  ;
// BEGIN_HELP_COMMENT
// Function: HWND ControlOnPropPage(int iCtrlId)
// Description: Find the parent window of the specified control in the active window.
// Return: An HWND that specifies the parent window of the control.
// Param: iCtrlId An integer that contains the ID of the control.
// END_HELP_COMMENT
GUI_API HWND ControlOnPropPage(int iCtrlId)
{	
	HWND hWnd = WGetActWnd(0) ;

	hActive = NULL ;
	if(!(hActive = GetDlgItem(WGetActWnd(0),iCtrlId))) // If option not on active child
	{
	 	EnumChildWindows(hWnd,WGetPageHandle,(LPARAM) iCtrlId) ;
	}
	else // if the child is on the active window 
	hActive = WGetActWnd(0) ;
 	return (hActive) ; 
 }

 /*
 	WGetPageHandle() is a callback function for ControlOnPropPage(). See ControlOnPropPage above for 
	more info. (Ivanl)
 */
GUI_API BOOL CALLBACK WGetPageHandle(HWND hChWnd,LPARAM iCtrlId)	  // Can this be a private member??
{

	if (GetDlgItem(hChWnd,iCtrlId))
	{	
		hActive = hChWnd ;
		return FALSE ;
   	}
	hActive = NULL ;
	return TRUE ;	

}


/*	DayRandSeed and DayRand
 *		DayRandSeed seeds the random number generator with the date.
 *		This way, the random numbers will be consistent for the duration of a day.
 *		DayRand retrieves a random number within a range.
 *		If no range is desired, just call rand()
 */

UINT nDayRandSeed;

// BEGIN_HELP_COMMENT
// Function: void DayRandSeed(void)
// Description: Seed the random number generator.
// Return: <none>
// END_HELP_COMMENT
GUI_API void DayRandSeed(void)
{
	CTime t = CTime::GetCurrentTime();
	nDayRandSeed = (t.GetDay() * 13) + t.GetMonth();
}

// BEGIN_HELP_COMMENT
// Function: int DayRand(int nRange)
// Description: Get a random number.
// Return: An integer that is a random number in the given range.
// Param: nRange An integer that specifies the upper end of the range (the range will be between 0 and nRange-1).
// END_HELP_COMMENT
GUI_API int DayRand(int nRange)
{
	ASSERT( nRange >= 0 );
	nDayRandSeed = (((0xffffffff - nDayRandSeed) % 9699689) + 30029) * 2309;
	return (int)(nDayRandSeed % nRange);
}

// Waits for a given number of miliseconds, or until the active Hwnd == hOrig.
// Great if an operation brings up several dialogs, and you want to make sure that 
// they are all gone before you perform the next operation. (Ivanl)
GUI_API int WaitForOriginalWnd(HWND hOrig, int Sec)	
{	
	while (Sec)
	{
		HWND hAct = WGetActWnd(0) ;
		if(hAct == hOrig)
			return 1 ;
		Sleep(1000) ;
		Sec-- ;
	}
	return 0 ;
}

/**************************************************************************************************
 *																								  *
 * WaitForWndWithCtrl() Takes a control ID which is expected to exist on the active window, Dialog *
 * together with the time in milliseconds to wait before returning a failure if the control is 	  *
 * not found on the active window.	REVIEW(Ivan) should we accept a handle to any window???		  *
 **************************************************************************************************/
// BEGIN_HELP_COMMENT
// Function: HWND WaitForWndWithCtrl(INT ID, DWORD dwMillSec /* = 3000*/)
// Description: Wait for a window with the specified control to be active.
// Return: A non-NULL handle of the window if successful; NULL otherwise.
// Param: ID An integer that contains the ID of the control.
// Param: dwMillSec A DWORD that contains the number of milliseconds to wait for the window to appear. (Default value is 3000.)
// END_HELP_COMMENT
GUI_API HWND WaitForWndWithCtrl(INT ID, DWORD dwMillSec /* = 3000*/)
{
	HWND hWnd = WGetActWnd(0) ;
	DWORD dwDone = 0 ;
   	while( dwDone <= dwMillSec )
	{ 	// Pardon the PropPage misnomer, the contol may not be a direct child of the active window
		// ControlOnPropPage() allows us to search for the control on the active window children as well.
		if(!ControlOnPropPage(ID))
		{	
			DWORD dwSleep = dwMillSec - dwDone >= 1000 ? 1000 : dwMillSec - dwDone;
			Sleep(dwSleep);			// wait another second (or whatever's left)
			dwDone += dwSleep;		// and try at least one more time
		}							
		else
		{										
			return hWnd ;
		}
		if( dwDone >= dwMillSec )	// no more waiting
			return NULL;			// just say we didn't find it
	}
		return NULL;				// should never get hit	
}

/*	GetSystem
 *		returns DWORD which will indicate the system being run on.
 */
// BEGIN_HELP_COMMENT
// Function: DWORD GetSystem(void)
// Description: Get the operating system currently in use.
// Return: A DWORD bit field that specifies the system currently in use: SYSTEM_NT, SYSTEM_DAYTONA, SYSTEM_CHICAGO, SYSTEM_DBCS, SYSTEM_JAPAN.
// END_HELP_COMMENT
GUI_API DWORD GetSystem(void)
{
	
	DWORD dw = 0;
	OSVERSIONINFO strcVerInfo;

	strcVerInfo.dwOSVersionInfoSize = sizeof(strcVerInfo);

	::GetVersionEx(&strcVerInfo);

	if (strcVerInfo.dwMajorVersion == 4 && strcVerInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
	{
		if (strcVerInfo.dwMinorVersion == 10)  // this might change with Win98 release?
			dw |= SYSTEM_WIN_98;
		else if (strcVerInfo.dwMinorVersion == 90)  // this might change with Win MILL release?
			dw |= SYSTEM_WIN_MILL;

		else if (strcVerInfo.dwMinorVersion == 0)
			dw |= SYSTEM_WIN_95;
	}
	else if (strcVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
	{
		if (strcVerInfo.dwMajorVersion == 5)
		{
			if (strcVerInfo.dwMinorVersion == 1)
				dw |= SYSTEM_NT_51;
			else
				dw |= SYSTEM_NT_5;
		}
		else if (strcVerInfo.dwMajorVersion == 4)
			dw |= SYSTEM_NT_4;
	}
	if (dw == 0x0) // couldn't figure out what we were on
	{
		// OS not supported with this version of Cafe'
		ASSERT(0);
	}

	// REVIEW: there's got to be a better way to get this
	if( IsDBCSLeadByte((BYTE)0x81) )
	{
		dw |= SYSTEM_DBCS;
		if( !IsDBCSLeadByte((BYTE)0xa1) )
			dw |= SYSTEM_JAPAN;
	}

	return dw;
}

// BEGIN_HELP_COMMENT
// Function: int GetPowerOfTwo(int i)
// Description: Returns the power of 2 for the specified number (i).
// Param: int i - The number for which to calculate the power of 2.
// Return: int - The power of two for the specified number (i).
// END_HELP_COMMENT
GUI_API int GetPowerOfTwo(int i)
	
	{
	int power = 0;

	while(i /= 2)
		power++;
		
	return power;
	}

// BEGIN_HELP_COMMENT
// Function: HWND FindFirstChild(HWND hWnd, int nID)
// Description: This function performs a breadth first search of a window for a child window specified by the control ID given.  This function was created because ::GetDlgItem is not recursive, and CWnd::GetDescendantWindow does a breadth then depth first search, resulting in a different window being found than if a total breadth first search was done.
// Return: The HWND of the window found, or NULL if none were found.
// Param: hWnd - Window from which to start the search.
// Param: nID - Control ID of the child window for which to search
// END_HELP_COMMENT
GUI_API HWND FindFirstChild(HWND hWnd, int nID)
{
	HWND hWndChild;
	if ((hWndChild = ::GetDlgItem(hWnd, nID)) != NULL)
	{
		return hWndChild;
	}
	else
	{
		HWND hWndFoundChild;
		// walk each child
		for (hWndChild = ::GetTopWindow(hWnd); hWndChild != NULL; hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT))
		{
			hWndFoundChild = FindFirstChild(hWndChild, nID);
			if (hWndFoundChild != NULL)
				return hWndFoundChild;
		}
		return NULL;    // not found
	}
}

// BEGIN_HELP_COMMENT
// Function: HWND FindChildClass(HWND hWnd, LPCSTR pCaption, LPCSTR pClassType /* ==NULL */)
// Description: This function performs a breadth first search of a window for a child window specified by the caption & class.  This function was created because ::WCustomExists() must receive the exact match for the class it's looking for
// Return: The HWND of the window found, or NULL if none were found. Window found must have Non-null caption.
// Param: hWnd - Window from which to start the search.
// Param: pCaption - the caption of window searched for (exact match is required)
// Param: pClassType - the classtype (ex: "Afx:") of window searched for (must be prefix of the actual class found)
// END_HELP_COMMENT
GUI_API HWND FindChildWindow(HWND hWnd, LPCSTR pCaption, LPCSTR pClassType /*=NULL*/)
{
	char szFound[80];

	if(pCaption==NULL || *pCaption==0)
		return NULL; // no caption to compare with
	HWND childhwnd=::GetWindow(hWnd,GW_CHILD);		
	while(childhwnd!=NULL)
	{
		::GetWindowText(childhwnd, szFound, 80);
		if(strcmp(szFound,pCaption)==0)
		{	
			if(pClassType==NULL || *pClassType==0)
				return childhwnd;
			::GetClassName(childhwnd, szFound, 80);
			if(strstr(szFound,pClassType)==szFound)
				return childhwnd;
		}
		HWND hWndFoundChild = FindChildWindow(childhwnd, pCaption, pClassType);
		if (hWndFoundChild != NULL)
			return hWndFoundChild;
		childhwnd=::GetWindow(childhwnd,GW_HWNDNEXT);
	}
	return NULL;    // not found
}

// BEGIN_HELP_COMMENT
// Function: DWORD WaitForSingleControl(const DWORD dwProcessId, const int idControl, const DWORD dwTimeout)
// Description: Wait for a control to be found in any of the specified process's windows. This function can be used to wait for a window to appear with the specified control. See WaitForMultipleControls(int, int*, DWORD) to wait for one of any number of controls.
// Return: A DWORD that specifies the result: WAIT_CONTROL_0, if successful; WAIT_TIMEOUT otherwise.
// Param: dwProcessId A DWORD that specifies the ID of the process.
// Param: idControl An integer that specifies the control to look for on the active window.
// Param: dwTimeout A DWORD that specifies the number of milliseconds to wait for the control.
// END_HELP_COMMENT
GUI_API DWORD WaitForSingleControl(const DWORD dwProcessId, const int idControl, const DWORD dwTimeout)
{
	const int cnPeriod = 100;
	HWND hwnd;
	DWORD dwWait;
	DWORD dwHwndProcessId;

	// loop until the time specified by dwTimeout has elapsed
	for (dwWait = 0; dwWait <= dwTimeout; dwWait += cnPeriod) {
		// iterate through all top level windows
		for (hwnd = ::GetTopWindow(NULL); hwnd != NULL; hwnd = ::GetNextWindow(hwnd, GW_HWNDNEXT)) {
			// does this window belong to the process specified?
			GetWindowThreadProcessId(hwnd, &dwHwndProcessId);
			if (dwHwndProcessId == dwProcessId) {
				// look for the control
				if (FindFirstChild(hwnd, idControl)) {
					return WAIT_CONTROL_0;
				}
			}
		}

		// wait
		// if a timeout of 0 is specified, don't wait at all
		if (dwTimeout != 0) {
			Sleep(cnPeriod);
		}
	}

	return WAIT_TIMEOUT;
}

// BEGIN_HELP_COMMENT
// Function: DWORD WaitForMultipleControls(const DWORD dwProcessId, const int cControl, const int aControls[], const DWORD dwTimeout)
// Description: Wait for any of the specified controls to be found in any of the specified process's windows. This function can be used to wait for a window to appear with any one of the the specified controls. See WaitForSingleControl(int, DWORD) to wait for a single control.
// Return: A DWORD that specifies the control found: WAIT_CONTROL_0 through WAIT_CONTROL_n, if successful; WAIT_TIMEOUT otherwise. Only WAIT_CONTROL_0 through WAIT_CONTROL_9 are defined; use WAIT_CONTROL_0 + n to test the return value when more than ten controls are being waited on.
// Param: dwProcessId A DWORD that specifies the ID of the process.
// Param: cControl An integer that specifies the number of controls in the aControls array.
// Param: aControls An integer array that contains the controls to look for on the active window.  The controls should be uniquely chosen for specific window detection and ordered such that the controls for the specific windows requiring detection are listed first.  ID's that specify very generic controls, such as MSG_OK and MSG_YES should not be used, or be listed last, so as to not cause specific window to be incorrectly detected as a general dialog.
// Param: dwTimeout A DWORD that specifies the number of milliseconds to wait for the control.
// END_HELP_COMMENT
GUI_API DWORD WaitForMultipleControls(const DWORD dwProcessId, const int cControls, const int aControls[], const DWORD dwTimeout)
{
	const int cnPeriod = 100;
	DWORD dwWait;
	int nControl;

	// there must be at least one control
	ASSERT(cControls > 0);

	// loop until the time specified by dwTimeout has elapsed
	for (dwWait = 0; dwWait <= dwTimeout; dwWait += cnPeriod) {
		// iterate through each control
		for (nControl = 0; nControl < cControls; nControl++) {
			// is the current control visible?
			if (WaitForSingleControl(dwProcessId, aControls[nControl], 0) == WAIT_CONTROL_0) {
				return WAIT_CONTROL_0+nControl;
			}
		}
		// wait
		// if a timeout of 0 is specified, don't wait at all
		if (dwTimeout != 0) {
			Sleep(cnPeriod);
		}
	}

	return WAIT_TIMEOUT;
}
// BEGIN_HELP_COMMENT
// Function: void TrimString(CString* pStr)
// Description:  This function trims leading and trailing spaces from a string.  It assumes that there are no trailing \n's or \r's on the string that should also be ignored.
// Param: pStr - Pointer to the string to be modified.
// END_HELP_COMMENT
void TrimString(CString* pStr)
{
    char* pBuf;

    // Get a pointer to the first non-space.
    pBuf = pStr->GetBuffer(pStr->GetLength());
    for (int nFirst = 0; isspace(pBuf[nFirst]); nFirst++)
        ;

    // Get a pointer to the last non-space, converting spaces to nulls as we go.
    for (int nLast = strlen(pBuf) - 1; isspace(pBuf[nLast]); nLast--)
        ;

    pStr->ReleaseBuffer();

    *pStr = pStr->Mid(nFirst, nLast - nFirst + 1);
}


// BEGIN_HELP_COMMENT
// Function: BOOL SetFocusToDlgControl(UINT id, HWND hwnd /*=NULL*/)
// Description: Set focus to a control given its ID. If the control is a list box, combo box, or edit box, the caption is the static control immediately preceeding the control. Only the immediate children of the given window are searched.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: id An integer that specifies the ID of the control.
// Param: hwnd An HWND that specifies the window (dialog) that contains the control. NULL means use the currently active window. (Default value is NULL.)
// END_HELP_COMMENT
GUI_API BOOL SetFocusToDlgControl(UINT id, HWND hwnd /*=NULL*/)
{
	HWND hwndDialog = hwnd == NULL ? ControlOnPropPage(id) : hwnd;
	HWND hwndControl = GetDlgItem(hwndDialog, id);
	if( !IsWindow(hwndControl) )
	{
		LOG->RecordInfo("Could not find a control 0x%X in dialog 0x%X ('%s')", id, hwndDialog, (LPCSTR)GetText(hwndDialog));
		return FALSE;
	}

	::SetFocus(hwndControl);
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: RandomNumberCheckList::RandomNumberCheckList(void)
// Description: Constructs a RandomNumberCheckList object. This object generates random numbers in a specified range (starting from 0), checking each off as it is generated so only one occurence of each number in the range will be generated for the lifetime of the object.
// Return: none.
// END_HELP_COMMENT
RandomNumberCheckList::RandomNumberCheckList(void)
{
	// seed the random number generator.
	srand(time(NULL));
}


// BEGIN_HELP_COMMENT
// Function: RandomNumberCheckList::RandomNumberCheckList(int iMax)
// Description: Constructs a RandomNumberCheckList object. This object generates random numbers in a specified range (starting from 0), checking each off as it is generated so only one occurence of each number in the range will be generated for the lifetime of the object.
// Return: none.
// Param: iMax An integer specifying the count of numbers the random number generator will have to choose from. The beginning of the range is 0 so, for example, an iMax value of 5 will generate random numbers 0-4.
// END_HELP_COMMENT
RandomNumberCheckList::RandomNumberCheckList(int iMax)
{
	m_iMax = iMax;
	// seed the random number generator.
	srand(time(NULL));
}


// BEGIN_HELP_COMMENT
// Function: void RandomNumberCheckList::SetMax(int iMax)
// Description: Sets the limit on the count of numbers generated by a RandomNumberCheckList object.
// Return: none.
// Param: iMax An integer specifying the count of numbers the random number generator will have to choose from. The beginning of the range is 0 so, for example, an iMax value of 5 will generate random numbers 0-4.
// END_HELP_COMMENT
void RandomNumberCheckList::SetMax(int iMax)
{
	m_iMax = iMax;
}


// BEGIN_HELP_COMMENT
// Function: void RandomNumberCheckList::UndoLast(void)
// Description: Makes the last number selected available for random selection again.
// Return: none.
// END_HELP_COMMENT
void RandomNumberCheckList::UndoLast(void)
{
	// ensure that there is at least one number to undo
	if(m_iaUsed.GetSize() > 0)
		// remove the last number selected.
		m_iaUsed.RemoveAt(m_iaUsed.GetSize() - 1);
}


// BEGIN_HELP_COMMENT
// Function: int RandomNumberCheckList::GetNext(void)
// Description: Gets the next random number from a RandomNumberCheckList object, checking that number on the list so it is not generated again.
// Return: A random number in the range specified when the RandomNumberCheckList object was constructed, unless all the numbers have been previously generated, in which case the return is -1.
// END_HELP_COMMENT
int RandomNumberCheckList::GetNext(void)
{
	// check if we've used up all the numbers.
	if(m_iaUsed.GetSize() == m_iMax)
		// -1 means all the numbers have been used.		
		return -1;	

	// used to store the random number generated.
	int n;
	// used to index the array of used numbers.
	int i;

	// keep generating numbers until an unused one is found.
	while(1)
	
	{
		// generate a number within the range specified. 
		n = rand() % m_iMax;

		// iterate through the list of used numbers.
		for(i = 0; i < m_iaUsed.GetSize(); i++)
		{
			// if n has already been used, we start over.
			if(m_iaUsed[i] == n)
				break;
		}

		// we checked the used list and didn't find it, so n is a new number.
		if(i == m_iaUsed.GetSize())
		{
			// and now it is also a used number.
			m_iaUsed.Add(n);
			return n;
		}
	}
}


// BEGIN_HELP_COMMENT
// Function: BOOL COApplication::Attach(LPCSTR szAppTitle /* NULL */, int secWait /* 0 */)
// Description: Attach to the specified application.
// Return: A BOOL that indicates success. TRUE if successful; FALSE otherwise.
// Param: szAppTitle A pointer to a string that contains the name of application to attach to (the window title). The default value is NULL. If NULL is specified, the function immediately attaches to the active application.
// Param: secWait An integer specifying the number of seconds to wait for the app to become active. The default is 0. If 0 is specified, the function immediately attaches to the active application.
// END_HELP_COMMENT
BOOL COApplication::Attach(LPCSTR szAppTitle /* NULL */, int secWait /* 0 */)

{
	// can't wait negative seconds.
	ASSERT(secWait >= 0);
	
	// either wait for the window with the specified title to appear,
	// or immediately attach to the active window.
	if(szAppTitle)
	{
		if(!(m_hWnd = MST.WFndWndWait(szAppTitle, FW_PART, secWait)))
			LOG->RecordInfo("ERROR in COApplication::Attach - "
							"cannot find app '%s' after %d seconds.",
							szAppTitle, secWait);
	}
	else
		m_hWnd = MST.WGetActWnd(0);

	return m_hWnd != NULL;
}


// BEGIN_HELP_COMMENT
// Function: BOOL COApplication::Activate(void)
// Description: Activate the application. An application must be attached (see Attach function) before it can be activated.
// Return: A BOOL that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL COApplication::Activate(void)
{

	// can't activate a null window handle.
	if(!m_hWnd)
	{
		LOG->RecordInfo("ERROR in COApplication::Activate - "
						"no app is attached to the object.");
		return FALSE;
	}

	WSetActWnd(m_hWnd);
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL COApplication::SendKeys(LPCSTR szKeys)
// Description: Send keystrokes to the application. The application must be active (see Activate function) before keystrokes can be sent to it.
// Return: void.
// Param: szKeys A pointer to a string that contains the keys to send.
// END_HELP_COMMENT
void COApplication::SendKeys(LPCSTR szKeys)
{
	// can't do NULL keys.
	ASSERT(szKeys);
	MST.DoKeys(szKeys);
}


GUI_API DWORD GetProductType(void)

{
	// determine if we are running against pro, enterprise, or learning edition.
	char szSkuValue[4];
	GetEnvironmentVariable("sku", szSkuValue, 4);

	if(((CString)szSkuValue == "p") || ((CString)szSkuValue == "P"))
		return (DWORD)VC_PRO;
	else if(((CString)szSkuValue == "l") || ((CString)szSkuValue == "L"))
		return (DWORD)VC_LRN;
	else
		return (DWORD)VC_ENT;
}

// BEGIN_HELP_COMMENT
// Function: TARGET_API void EditUndo(int count)
// Description: Does Undo (^Z) in active window
// Param: count A number of Undos that will be done 
// Return: void.
// END_HELP_COMMENT
GUI_API void EditUndo(int count)
{
	for(int ii = 0; ii < count; ii++)	
		MST.DoKeys("^z");
}

// BEGIN_HELP_COMMENT
// Function: TARGET_API void EditRedo(int count)
// Description: Does Undo (^Y) in active window
// Param: count A number of Undos that will be done 
// Return: void.
// END_HELP_COMMENT
GUI_API void EditRedo(int count)
{
	for(int ii = 0; ii < count; ii++)	
		MST.DoKeys("^y");
}


// BEGIN_HELP_COMMENT
// Function: TARGET_API BOOL GetDragFullWindows(BOOL *bResult)
// Description: Checks if "Show window contents while dragging" is turned on/off 
// Param: BOOL *bResult TRUE if "Show window contents while dragging" is turned on.  FALSE, otherwise.
// Return: TRUE if successfull.
// END_HELP_COMMENT
GUI_API BOOL GetDragFullWindows(BOOL *bResult)
{
	HKEY hkDragFullWin;
	DWORD cbData = 2;
	unsigned char lpData[2];
	unsigned long Type  = REG_SZ;

	if(ERROR_SUCCESS != RegOpenKey(HKEY_CURRENT_USER, "Control Panel\\Desktop", &hkDragFullWin))
		return FALSE;

	if(ERROR_SUCCESS != RegQueryValueEx(hkDragFullWin, "DragFullWindows", NULL, &Type, lpData, &cbData))
		return FALSE;

	RegCloseKey(hkDragFullWin);

	if(*lpData == '0')
		*bResult = FALSE;
	else 
		*bResult = TRUE;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\filetabl.h ===
///////////////////////////////////////////////////////////////////////
////  FILETABL.H
//
//	Created by :			Date :
//		EnriqueP					3/4/94
//
////  File Table Classes used for table driven test sets.

#ifndef __FILETABL_H__
#define __FILETABL_H__

#include "idexprt.h"

#define   LANG_US  		0x0001
#define   LANG_J		0x0002


///////////////////////////////////////////////////////////////////////
////  CFileTableLine class:  defines a single line of a file table
///////////////////////////////////////////////////////////////////////

class IDE_CLASS CFileTableLine : public CObject
{
// Data members
public:
	CStringArray m_strArray; 
    
// Ctors
public:
	CFileTableLine(void);
	CFileTableLine(LPCSTR szLine);
	~CFileTableLine();

// 	Utilities  
	int LangFromString(CString& str);
	BOOL BoolFromString(CString& str, BOOL bDefault = TRUE);
};


///////////////////////////////////////////////////////////////////////
////  CFileTableLineList class:  defines a linked list of FileTableLine objects
///////////////////////////////////////////////////////////////////////


class IDE_CLASS CFileTableLineList: public CObList
{
public:
	CFileTableLineList();
	~CFileTableLineList();

	CFileTableLine* GetHead(void);
	CFileTableLine* GetTail(void);
	POSITION AddHead(CFileTableLine* pFileTableLine);
	POSITION AddTail(CFileTableLine* pFileTableLine);
	CFileTableLine* GetNext(POSITION& pos);
	CFileTableLine* GetPrev(POSITION& pos);
	CFileTableLine* GetAt(POSITION pos);
	CFileTableLine* RemoveHead(void);
	void RemoveAll(void);
};




///////////////////////////////////////////////////////////////////////
////  CFileTable class:  Stores all relevant info for each file to be used as a test target
///////////////////////////////////////////////////////////////////////

// BEGIN_CLASS_HELP
// ClassName: CFileTable
// BaseClass: None
// Category: Tools
// END_CLASS_HELP
class IDE_CLASS CFileTable 
{
public: 
	CFileTable();
	CFileTable(LPCSTR szName);
	virtual ~CFileTable();
	
// Data
protected:
	CFileTableLineList m_FileTableLineList;	// List that contains lines
	LPCSTR m_szTableName;
public:
	POSITION m_currPos;
// Attributes
public:
	inline int GetNumLines(void) const
	{
		return m_FileTableLineList.GetCount();
	}	
	inline void SetTableName(LPCSTR szTable)
	{
		m_szTableName = szTable;
	}

// Internal Operations
public:
	BOOL AppendLine(LPCSTR szNewLine);
	char* RemoveExtraChars(char* pchLine); 


// Interface
public:
	virtual	void DeleteContents();
	virtual	int LoadTable(LPCSTR szName = NULL);
	virtual CFileTableLine* GetFirstLine(void);
	virtual CFileTableLine* GetNextLine(POSITION& pos);
	virtual POSITION GetFirstLinePos(void); 
	virtual CString CFileTable::GetStrValue(POSITION& pos, int nColumn);
	virtual int GetLastColumnIndex(POSITION& pos);

};

/////////////////////////////////////////////////////////////////////////////


#endif //__FILETABL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\filetabl.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	FILETABL.CPP
//
//	Created by :			Date :
//		EnriqueP					3/4/94
//
//	Description :
//		Implementation of the File Table classes
//

#include "stdafx.h"
#include "filetabl.h"
#include "mstwrap.h"
#include "guiv1.h"
#include "resource.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CFileTableLine  implementation

CFileTableLine::CFileTableLine() 
{
}


CFileTableLine::CFileTableLine(LPCSTR szLine)
{
	while( szLine[0] != '\0' )
	{
		int nSeparator = strcspn(szLine, ",;\t");
		// For each column in table add a string value and grow array as needed.
		m_strArray.Add( CString(szLine, nSeparator) );	
		szLine = szLine + nSeparator + strspn(szLine + nSeparator, ",;\t");
	}
}

CFileTableLine::~CFileTableLine() 
{
	m_strArray.RemoveAll();	
}


int CFileTableLine::LangFromString(CString& str)

{
	str.MakeUpper();

	if(str.Find("Japanese") >= 0)
		return CAFE_LANG_JAPANESE;
	else if(str.Find("German") >= 0)
		return CAFE_LANG_GERMAN;
	else
		return CAFE_LANG_ENGLISH;
}


BOOL CFileTableLine::BoolFromString(CString& str, BOOL bDefault /*=TRUE*/)
{
	str.MakeUpper();
	if( (str == "0") || (str == "FALSE") || (str == "NO") || (str == "F") || (str == "N") )
		return FALSE;
	if( (str == "1") || (str == "TRUE") || (str == "YES") || (str == "T") || (str == "Y") )
		return TRUE;

	LOG->RecordInfo("Could not deduce a boolean value from the string '%s'", (LPCSTR)str);
	return bDefault;
}

/////////////////////////////////////////////////////////////////////////////
// CFileTableLineList implementation
 
CFileTableLineList::CFileTableLineList(void) : CObList()
{
	NULL;
}

CFileTableLineList::~CFileTableLineList()
{
	RemoveAll();
}

CFileTableLine *CFileTableLineList::GetHead(void)
{
	return ((CFileTableLine *)CObList::GetHead());
}

CFileTableLine *CFileTableLineList::GetTail(void)
{
	return ((CFileTableLine *)CObList::GetTail());
}

POSITION CFileTableLineList::AddHead(CFileTableLine *pFileTableLine)
{
	return (CObList::AddHead((CObject *)pFileTableLine));
}

POSITION CFileTableLineList::AddTail(CFileTableLine *pFileTableLine)
{
	return (CObList::AddTail((CObject *)pFileTableLine));
}

CFileTableLine *CFileTableLineList::GetNext(POSITION &pos)
{
	return ((CFileTableLine *)CObList::GetNext(pos));
}

CFileTableLine *CFileTableLineList::GetPrev(POSITION &pos)
{
	return ((CFileTableLine *)CObList::GetPrev(pos));
}

CFileTableLine *CFileTableLineList::GetAt(POSITION pos)
{
	return ((CFileTableLine *)CObList::GetAt(pos));
}

CFileTableLine* CFileTableLineList::RemoveHead(void)
{
	return ((CFileTableLine *)CObList::RemoveHead());
}

void CFileTableLineList::RemoveAll(void)
{
	while( !IsEmpty() )
	{
		CFileTableLine* pftll = RemoveHead();
		delete pftll;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFileTable implementation


CFileTable::CFileTable()
{
	m_szTableName = "files.txt";		 // default name for file table 
}

CFileTable::CFileTable(LPCSTR szName)
{
	m_szTableName = szName;
}

CFileTable::~CFileTable()
{
	DeleteContents();
}


// BEGIN_HELP_COMMENT
// Function: void CFileTable::DeleteContents()
// Description: Removes all entries in the File Table.
// Return: void. 
// Param: none
// END_HELP_COMMENT
void CFileTable::DeleteContents()
{
	m_FileTableLineList.RemoveAll();
}

// BEGIN_HELP_COMMENT
// Function: BOOL CFileTable::LoadTable(LPCSTR szName /*=NULL*/)
// Description: Opens the text file specified by szName and loads its info into the table.
// Return: Returns TRUE if it was successfull loading the table.
// Param: The table's filename to be loaded. It may contain a full path.
// END_HELP_COMMENT
BOOL CFileTable::LoadTable(LPCSTR szName /*=NULL*/)
{
	if( szName != NULL )
		m_szTableName = szName;

	DeleteContents(); // Make sure list is empty
	TRY
	{
		CStdioFile file(m_szTableName, CFile::modeRead | CFile::typeText);
		char acLine[512];
		while( file.ReadString(acLine, 511) != NULL )
			AppendLine(acLine);
	}
	CATCH(CFileException, e)
	{
		AfxMessageBox(IDS_ERROR_CANT_OPEN);
		return FALSE;
	}
	END_CATCH;
	return TRUE;
}

 // CFileTable internal commands

BOOL CFileTable::AppendLine(LPCSTR szNewLine)
{
	char* sz = new char[strlen(szNewLine) + 1];		 
	strcpy(sz, szNewLine);
	char* pchStr = sz;
	pchStr = RemoveExtraChars( pchStr );

	if (pchStr[0] == '\0')
	{
		delete[] sz;
		return FALSE;
	}

	CFileTableLine*  pFileTableLine = new CFileTableLine(pchStr);
	POSITION line = m_FileTableLineList.AddTail( pFileTableLine );	   // Add string to array if is not empty or blank
	delete[] sz;
	return TRUE;
}

char* CFileTable::RemoveExtraChars(char* pchLine) 	  // REVIEW (EnriqueP): Move this code to CFileTableLine::CFileTableLine(pchStr)
{
	int iCRLF = strcspn(pchLine, "\'\r\n");	 // remove trailing comments , CR or LF
	pchLine[iCRLF] = '\0';
	pchLine += strspn(pchLine, "\t ");	// Remove leading spaces or tabs
	return pchLine;
}

// BEGIN_HELP_COMMENT
// Function: CFileTableLine* CFileTable::GetFirstLine()
// Description: Returns a pointer to the first line in the table.
// Return: A CFileTableLine* that can be used to access its member variables or NULL if table is empty.
// Param: None.
// END_HELP_COMMENT
CFileTableLine* CFileTable::GetFirstLine() 
{
	if (m_FileTableLineList.IsEmpty())
	{
		LOG->RecordInfo("The file table is empty");
		return NULL;
	}
	
	return m_FileTableLineList.GetHead();
}


// BEGIN_HELP_COMMENT
// Function: CFileTableLine* CFileTable::GetNextLine(POSITION& pos)
// Description: Retrieves a pointer to the line pointed by pos and advances pos automatically to point to the next line.
// Return: Returns a pointer to a line CFileTableLine*
// Param: pos points to the line that is to be retrieved.
// END_HELP_COMMENT
CFileTableLine* CFileTable::GetNextLine(POSITION& pos) 
{
	return m_FileTableLineList.GetNext(pos);
}

               
// BEGIN_HELP_COMMENT
// Function: POSITION CFileTable::GetFirstLinePos()
// Description: Returns the first POSITION of the first entry on the table. Use this to start a navigating the table.
// Return: Returns a POSITION value to the first entry or NULL if table is empty.
// Param: None.
// END_HELP_COMMENT
POSITION CFileTable::GetFirstLinePos() 
{
	return m_FileTableLineList.GetHeadPosition();
}

// BEGIN_HELP_COMMENT
// Function: CString CFileTable::GetStrValue(POSITION& pos, int column) 
// Description: Returns the first POSITION of the first entry on the table. Use this to start a navigating the table.
// Return: Returns a POSITION value to the first entry or NULL if table is empty.
// Param: None.
// END_HELP_COMMENT
CString CFileTable::GetStrValue(POSITION& pos, int nColumn) 
{
	return m_FileTableLineList.GetAt(pos)->m_strArray[nColumn];
}

// BEGIN_HELP_COMMENT
// Function: int CFileTable::GetLastColumnIndex(POSITION& pos) 
// Description: Returns the first POSITION of the first entry on the table. Use this to start a navigating the table.
// Return: Returns a POSITION value to the first entry or NULL if table is empty.
// Param: None.
// END_HELP_COMMENT
int CFileTable::GetLastColumnIndex(POSITION& pos) 
{
	return m_FileTableLineList.GetAt(pos)->m_strArray.GetUpperBound();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\connec.cpp ===
/*******************************************************************************

Include files

********************************************************************************/

#include "stdafx.h"
#include "connec.h"
#include "resource.h"
#include "..\testutil.h"

#define new DEBUG_NEW

/*******************************************************************************

Global data

********************************************************************************/

CSettings **gConnecSettings;	// connections settings objects for current platform
PLATFORM_TYPE gplatform;		// current platform
HINSTANCE ghinst;				// handle to instance of cafe driver

CString	platform_str[4] = {"Win32", "Win32s", "68k Macintosh", "Power Macintosh"};

CString	connection_str[6][4] = {"Local", "Serial", "", "Network (TCP/IP)",            
								"", "Serial", "", "",                                                  
								"", "Serial", "Network (AppleTalk)", "Network (TCP/IP)",               
								"", "Serial", "Network (AppleTalk)", "Network (TCP/IP)"};
	 
CString baud_rate_str[] = {"300", "600", "1200", "1800", "2400", "4800", "7200",
						   "9600", "14400", "19200", "38400", "57600"};

CString connector_str[] = {"COM1", "COM2", "COM3", "COM4"};  //todo: localize
CString data_bits_str[] = {"5", "6", "7", "8"};                              
CString stop_bits_str[] = {"1", "1.5", "2"};                         
CString parity_str[]    = {"NONE", "ODD", "EVEN"};                           

int connection_to_index[6][4] = {0, 1, -1, 2,
								 -1, 0, -1, -1,
								 -1, 0, 1, 2,
								 -1, 0, 1, 2};

int	index_to_connection[6][4] = {CONNECTION_LOCAL, CONNECTION_SERIAL, CONNECTION_TCP_IP, -1,
								 CONNECTION_SERIAL, -1, -1, -1,
								 CONNECTION_SERIAL, CONNECTION_APPLETALK, CONNECTION_TCP_IP, -1,
								 CONNECTION_SERIAL, CONNECTION_APPLETALK, CONNECTION_TCP_IP, -1}; 


/*******************************************************************************

Entry point to connection settings feature

********************************************************************************/

int CConnections::Connections(HWND hwndOwner, CSettings **pSettings, PLATFORM_TYPE platform)
	{
	gConnecSettings = pSettings;
	gplatform = platform;
	ghinst = (HINSTANCE)GetWindowLong(hwndOwner, GWL_HINSTANCE); 
	return DialogBox(ghinst, MAKEINTRESOURCE(IDD_DIALOG_CONNECTION), hwndOwner, ConnectionDlgProc);
	}


/*******************************************************************************

Text to int conversion routines

********************************************************************************/

CONNECTION_TYPE CConnections::ConnectionTextToInt(CString connection_txt)
	
	{
	connection_txt.MakeLower();

	if(connection_txt == "local")             
		return CONNECTION_LOCAL;
	if(connection_txt == "serial")             
		return CONNECTION_SERIAL;
	if(connection_txt == "tcp_ip")             
		return CONNECTION_TCP_IP;
	if(connection_txt == "appletalk")             
		return CONNECTION_APPLETALK;

	// todo: print error
	return CONNECTION_LOCAL;
	}


CONNECTOR_TYPE CConnections::ConnectorTextToInt(CString connector_txt)
	
	{
	connector_txt.MakeLower();

	if(connector_txt == "com1")             
		return CONNECTOR_COM1;
	if(connector_txt == "com2")             
		return CONNECTOR_COM2;
	if(connector_txt == "com3")             
		return CONNECTOR_COM3;
	if(connector_txt == "com4")             
		return CONNECTOR_COM4;

	// todo: print error
	return CONNECTOR_COM1;
	}


BAUD_RATE_TYPE CConnections::BaudRateTextToInt(CString baud_rate_txt)
	
	{
	if(baud_rate_txt == "300")
		return BAUD_RATE_1200;
	if(baud_rate_txt == "600")
		return BAUD_RATE_1200;
	if(baud_rate_txt == "1200")
		return BAUD_RATE_1200;
	if(baud_rate_txt == "1800")
		return BAUD_RATE_1200;
	if(baud_rate_txt == "2400")
		return BAUD_RATE_2400;
	if(baud_rate_txt == "4800")
		return BAUD_RATE_4800;
	if(baud_rate_txt == "7200")
		return BAUD_RATE_4800;
	if(baud_rate_txt == "9600")
		return BAUD_RATE_9600;
	if(baud_rate_txt == "14400")
		return BAUD_RATE_14400;
	if(baud_rate_txt == "19200")
		return BAUD_RATE_19200;
	if(baud_rate_txt == "38400")
		return BAUD_RATE_38400;
	if(baud_rate_txt == "57600")
		return BAUD_RATE_57600;

	// todo: print error
	return BAUD_RATE_57600;
	}


FLOW_CONTROL_TYPE CConnections::FlowControlTextToInt(CString flow_control_txt)

	{
	flow_control_txt.MakeLower();

	if(flow_control_txt == "hardware")      
		return FLOW_CONTROL_HARDWARE;
	if(flow_control_txt == "xonxoff")       
		return FLOW_CONTROL_XONXOFF;

	// todo: print error
	return FLOW_CONTROL_HARDWARE;
	}


DATA_BITS_TYPE CConnections::DataBitsTextToInt(CString data_bits_txt)

	{
	data_bits_txt.MakeLower();

	if(data_bits_txt == "5")
		return DATA_BITS_5;
	if(data_bits_txt == "6")
		return DATA_BITS_6;
	if(data_bits_txt == "7")
		return DATA_BITS_7;
	if(data_bits_txt == "8")
		return DATA_BITS_8;

	// todo: print error
	return DATA_BITS_8;
	}


STOP_BITS_TYPE CConnections::StopBitsTextToInt(CString stop_bits_txt)

	{
	stop_bits_txt.MakeLower();

	if(stop_bits_txt == "1")
		return STOP_BITS_1;
	if(stop_bits_txt == "1.5")
		return STOP_BITS_1_PT_5;
	if(stop_bits_txt == "2")
		return STOP_BITS_2;

	// todo: print error
	return STOP_BITS_1;
	}


PARITY_TYPE CConnections::ParityTextToInt(CString parity_txt)

	{
	parity_txt.MakeLower();

	if(parity_txt == "none")
		return PARITY_NONE;
	if(parity_txt == "even")
		return PARITY_EVEN;
	if(parity_txt == "odd")
		return PARITY_ODD;

	// todo: print error
	return PARITY_NONE;
	}

/*******************************************************************************

Connection dialog window procedure

********************************************************************************/

BOOL CALLBACK ConnectionDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)

	{
	static HWND hwndListConnection, hwndButtonSettings, hwndEditLocalPath, hwndEditSharePath, hwndStaticSharePath;
	static int current_connection; 

	switch(msg)
		
		{
		case WM_INITDIALOG:
			
			{
			hwndListConnection = GetDlgItem(hwndDlg, IDC_LIST_CONNECTION);
			hwndButtonSettings = GetDlgItem(hwndDlg, IDC_BUTTON_SETTINGS);
			hwndEditLocalPath = GetDlgItem(hwndDlg, IDC_EDIT_LOCAL_PATH);
			hwndEditSharePath = GetDlgItem(hwndDlg, IDC_EDIT_SHARE_PATH);
			hwndStaticSharePath = GetDlgItem(hwndDlg, IDC_STATIC_SHARE_PATH);
			current_connection = gConnecSettings[0]->GetIntValue(settingConnection);

			for(int i = 0; i < 4; i++)
				if(connection_str[GetPowerOfTwo(gplatform)][i] != "")
					SendMessage(hwndListConnection, LB_ADDSTRING, 0, 
								(LPARAM)(LPCTSTR)connection_str[GetPowerOfTwo(gplatform)][i]);
				
			if(current_connection == CONNECTION_LOCAL)
				EnableWindow(hwndButtonSettings, FALSE);
				
			if(gplatform == PLATFORM_WIN32S_X86)
				EnableWindow(hwndListConnection, FALSE);						
					
			SendMessage(hwndListConnection, LB_SETCURSEL, 
						connection_to_index[GetPowerOfTwo(gplatform)][GetPowerOfTwo(current_connection)], 0);

			SetWindowText(hwndEditLocalPath, gConnecSettings[0]->GetTextValue(settingRemoteLocalPath));

			if((gplatform != PLATFORM_MAC_68K) && (gplatform != PLATFORM_MAC_PPC))
				{
				ShowWindow(hwndEditSharePath, SW_SHOW);
				ShowWindow(hwndStaticSharePath, SW_SHOW);
				SetWindowText(hwndEditSharePath, gConnecSettings[0]->GetTextValue(settingRemoteSharePath));
				}
			
			CString title = platform_str[GetPowerOfTwo(gplatform)] + " Connections";
			SetWindowText(hwndDlg, title);
			return TRUE;
			}

		case WM_COMMAND:
			
			switch(LOWORD(wParam))
				
				{
				case IDOK:
					
					char ch_array[256];
					GetWindowText(hwndEditLocalPath, ch_array, 256);
					gConnecSettings[0]->SetTextValue(settingRemoteLocalPath, ch_array);

					if((gplatform != PLATFORM_MAC_68K) && (gplatform != PLATFORM_MAC_PPC))
						{
						GetWindowText(hwndEditSharePath, ch_array, 256);
						gConnecSettings[0]->SetTextValue(settingRemoteSharePath, ch_array);
						}

					gConnecSettings[0]->SetIntValue(settingConnection, current_connection); 
					gConnecSettings[0]->WriteRegistry();
					return SendMessage(hwndDlg, WM_CLOSE, 0, 0);
				
				case IDCANCEL:
					return SendMessage(hwndDlg, WM_CLOSE, 0, 0);
				
				case IDC_BUTTON_SETTINGS:

					switch(current_connection)

						{
						case CONNECTION_TCP_IP:
							return DialogBox(ghinst, MAKEINTRESOURCE(IDD_DIALOG_IP), hwndDlg, IPDlgProc);

						case CONNECTION_APPLETALK:
							return DialogBox(ghinst, MAKEINTRESOURCE(IDD_DIALOG_AT), hwndDlg, ATDlgProc);

						case CONNECTION_SERIAL:

							switch(gplatform)

								{
								case PLATFORM_WIN32_X86:
								case PLATFORM_WIN32S_X86:

									return DialogBox(ghinst, MAKEINTRESOURCE(IDD_DIALOG_WIN32_SERIAL),
													 hwndDlg, Win32SerialDlgProc);

								case PLATFORM_MAC_68K:

									return DialogBox(ghinst, MAKEINTRESOURCE(IDD_DIALOG_68K_SERIAL),
													 hwndDlg, Mac68KSerialDlgProc);
								case PLATFORM_MAC_PPC:

									return DialogBox(ghinst, MAKEINTRESOURCE(IDD_DIALOG_PMAC_SERIAL),
													 hwndDlg, PMacSerialDlgProc);

								default:
									return 0;
								}

						default:
							return 0;
						}

				case IDC_LIST_CONNECTION:
					
					switch(HIWORD(wParam))	
						
						{
						case LBN_SELCHANGE:
																
							current_connection = (CONNECTION_TYPE)index_to_connection[GetPowerOfTwo(gplatform)][SendMessage((HWND)lParam, LB_GETCURSEL, 0, 0)];

							if(current_connection == CONNECTION_LOCAL)
								EnableWindow(hwndButtonSettings, FALSE);						
							else
								EnableWindow(hwndButtonSettings, TRUE);

							return -1;

						default:
							return 0;
						}									
						
				default:
					return 0;
				}

		case WM_CLOSE:
			return EndDialog(hwndDlg, 0);

		default:
			return 0;
		}
	}


/*******************************************************************************

Win32 serial settings dialog window procedure

********************************************************************************/

BOOL CALLBACK Win32SerialDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)

	{
	static HWND hwndComboConnector, hwndComboBaudRate;

	switch(msg)
		
		{
		case WM_INITDIALOG:
			
			{
			hwndComboConnector = GetDlgItem(hwndDlg, IDC_COMBO_WIN32_CONNECTOR);
			hwndComboBaudRate = GetDlgItem(hwndDlg, IDC_COMBO_BAUD_RATE);

			for(int i = 0; i < 4; i++)
				SendMessage(hwndComboConnector, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)connector_str[i]);

			for(i = 0; i < 12; i++)
				SendMessage(hwndComboBaudRate, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)baud_rate_str[i]);

			SendMessage(hwndComboConnector, CB_SETCURSEL, gConnecSettings[2]->GetIntValue(settingConnector), 0);
			SendMessage(hwndComboBaudRate, CB_SETCURSEL, gConnecSettings[2]->GetIntValue(settingBaudRate), 0);

			if(gConnecSettings[2]->GetIntValue(settingFlowControl) == FLOW_CONTROL_HARDWARE)
				CheckRadioButton(hwndDlg, IDC_RADIO_HARDWARE, IDC_RADIO_XONXOFF, IDC_RADIO_HARDWARE);
			else
				CheckRadioButton(hwndDlg, IDC_RADIO_HARDWARE, IDC_RADIO_XONXOFF, IDC_RADIO_XONXOFF);
	
			CString title = platform_str[GetPowerOfTwo(gplatform)] + " Serial Settings";
			SetWindowText(hwndDlg, title);
			return TRUE;
			}

		case WM_COMMAND:
			
			switch(LOWORD(wParam))
				
				{
				case IDOK:

					gConnecSettings[2]->SetIntValue(settingConnector, 
													(CONNECTOR_TYPE)SendMessage(hwndComboConnector, CB_GETCURSEL, 0, 0));

					gConnecSettings[2]->SetIntValue(settingBaudRate, 
													(BAUD_RATE_TYPE)SendMessage(hwndComboBaudRate, CB_GETCURSEL, 0, 0));

					if(SendMessage(GetDlgItem(hwndDlg, IDC_RADIO_HARDWARE), BM_GETCHECK, 0, 0) == 1)
						gConnecSettings[2]->SetIntValue(settingFlowControl, FLOW_CONTROL_HARDWARE);
					else
						gConnecSettings[2]->SetIntValue(settingFlowControl, FLOW_CONTROL_XONXOFF);

					gConnecSettings[2]->WriteRegistry();
					return SendMessage(hwndDlg, WM_CLOSE, 0, 0);
				
				case IDCANCEL:
					return SendMessage(hwndDlg, WM_CLOSE, 0, 0);
				
				default:
					return 0;
				}

		case WM_CLOSE:
			return EndDialog(hwndDlg, 0);

		default:
			return 0;
		}
	}


/*******************************************************************************

PMac serial settings dialog window procedure

********************************************************************************/

BOOL CALLBACK PMacSerialDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)

	{
	static HWND hwndComboConnector;

	switch(msg)
		
		{
		case WM_INITDIALOG:
			
			{
			hwndComboConnector = GetDlgItem(hwndDlg, IDC_COMBO_PMAC_CONNECTOR);

			for(int i = 0; i < 4; i++)
				SendMessage(hwndComboConnector, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)connector_str[i]);

			SendMessage(hwndComboConnector, CB_SETCURSEL, gConnecSettings[2]->GetIntValue(settingConnector), 0);
			return TRUE;
			}

		case WM_COMMAND:
			
			switch(LOWORD(wParam))
				
				{
				case IDOK:
					
					gConnecSettings[2]->SetIntValue(settingConnector, 
													(CONNECTOR_TYPE)SendMessage(hwndComboConnector, CB_GETCURSEL, 0, 0));

					gConnecSettings[2]->WriteRegistry();
					return SendMessage(hwndDlg, WM_CLOSE, 0, 0);
				
				case IDCANCEL:
					return SendMessage(hwndDlg, WM_CLOSE, 0, 0);
				default:
					return 0;
				}

		case WM_CLOSE:
			return EndDialog(hwndDlg, 0);

		default:
			return 0;
		}
	}


/*******************************************************************************

68K serial settings dialog window procedure

********************************************************************************/

BOOL CALLBACK Mac68KSerialDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)

	{
	static HWND hwndComboConnector, hwndComboBaudRate, hwndComboDataBits, hwndComboParity, hwndComboStopBits;

	switch(msg)
		
		{
		case WM_INITDIALOG:
			
			{
			hwndComboConnector = GetDlgItem(hwndDlg, IDC_COMBO_68K_CONNECTOR);
			hwndComboBaudRate = GetDlgItem(hwndDlg, IDC_COMBO_68K_BAUD_RATE);
			hwndComboDataBits = GetDlgItem(hwndDlg, IDC_COMBO_DATA_BITS);
			hwndComboParity = GetDlgItem(hwndDlg, IDC_COMBO_PARITY);
			hwndComboStopBits = GetDlgItem(hwndDlg, IDC_COMBO_STOP_BITS);

			int i;

			for(i = 0; i < 4; i++)
				SendMessage(hwndComboConnector, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)connector_str[i]);
			for(i = 0; i < 12; i++)
				SendMessage(hwndComboBaudRate, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)baud_rate_str[i]);
			for(i = 0; i < 4; i++)
				SendMessage(hwndComboDataBits, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)data_bits_str[i]);
			for(i = 0; i < 3; i++)
				SendMessage(hwndComboParity, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)parity_str[i]);
			for(i = 0; i < 3; i++)
				SendMessage(hwndComboStopBits, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)stop_bits_str[i]);

			SendMessage(hwndComboConnector, CB_SETCURSEL, gConnecSettings[2]->GetIntValue(settingConnector), 0);
			SendMessage(hwndComboBaudRate, CB_SETCURSEL, gConnecSettings[2]->GetIntValue(settingBaudRate), 0);
			SendMessage(hwndComboDataBits, CB_SETCURSEL, gConnecSettings[2]->GetIntValue(settingDataBits), 0);
			SendMessage(hwndComboParity, CB_SETCURSEL, gConnecSettings[2]->GetIntValue(settingParity), 0);
			SendMessage(hwndComboStopBits, CB_SETCURSEL, gConnecSettings[2]->GetIntValue(settingStopBits), 0);
			return TRUE;
			}

		case WM_COMMAND:
			
			switch(LOWORD(wParam))
				
				{
				case IDOK:
					
					gConnecSettings[2]->SetIntValue(settingConnector, 
													(CONNECTOR_TYPE)SendMessage(hwndComboConnector, CB_GETCURSEL, 0, 0));
					gConnecSettings[2]->SetIntValue(settingBaudRate, 
													(BAUD_RATE_TYPE)SendMessage(hwndComboBaudRate, CB_GETCURSEL, 0, 0));
					gConnecSettings[2]->SetIntValue(settingDataBits, 
													(DATA_BITS_TYPE)SendMessage(hwndComboDataBits, CB_GETCURSEL, 0, 0));
					gConnecSettings[2]->SetIntValue(settingParity, 
													(PARITY_TYPE)SendMessage(hwndComboParity, CB_GETCURSEL, 0, 0));
					gConnecSettings[2]->SetIntValue(settingStopBits, 
													(STOP_BITS_TYPE)SendMessage(hwndComboStopBits, CB_GETCURSEL, 0, 0));

					gConnecSettings[2]->WriteRegistry();
					return SendMessage(hwndDlg, WM_CLOSE, 0, 0);
				
				case IDCANCEL:
					return SendMessage(hwndDlg, WM_CLOSE, 0, 0);
				default:
					return 0;
				}

		case WM_CLOSE:
			return EndDialog(hwndDlg, 0);

		default:
			return 0;
		}
	}


/*******************************************************************************

IP settings dialog window procedure

********************************************************************************/

BOOL CALLBACK IPDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)

	{
	static HWND hwndEditName, hwndEditPassword;

	switch(msg)
		{
		case WM_INITDIALOG:
			{
			hwndEditName = GetDlgItem(hwndDlg, IDC_EDIT_IP_NAME);
			hwndEditPassword = GetDlgItem(hwndDlg, IDC_EDIT_IP_PASSWORD);
			SetWindowText(hwndEditName, gConnecSettings[1]->GetTextValue(settingRemoteIPAddress));
			SetWindowText(hwndEditPassword, gConnecSettings[1]->GetTextValue(settingRemoteIPPassword));
			CString title = platform_str[GetPowerOfTwo(gplatform)] + " TCP/IP Settings";
			SetWindowText(hwndDlg, title);
			return TRUE;
			}
		case WM_COMMAND:
			switch(LOWORD(wParam))
				{
				case IDOK:
					char ch_array[256];
					GetWindowText(hwndEditName, ch_array, 256);
					gConnecSettings[1]->SetTextValue(settingRemoteIPAddress, ch_array);
					GetWindowText(hwndEditPassword, ch_array, 256);
					gConnecSettings[1]->SetTextValue(settingRemoteIPPassword, ch_array);
					gConnecSettings[1]->WriteRegistry();
					return SendMessage(hwndDlg, WM_CLOSE, 0, 0);
				case IDCANCEL:
					return SendMessage(hwndDlg, WM_CLOSE, 0, 0);
				default:
					return 0;
				}
		case WM_CLOSE:
			return EndDialog(hwndDlg, 0);
		default:
			return 0;
		}
	}


/*******************************************************************************

AppleTalk settings dialog window procedure

********************************************************************************/

BOOL CALLBACK ATDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
	
	{
	static HWND hwndEditName, hwndEditZone, hwndEditPassword;

	switch(msg)
		{
		case WM_INITDIALOG:
			{
			hwndEditName = GetDlgItem(hwndDlg, IDC_EDIT_AT_NAME);
			hwndEditZone = GetDlgItem(hwndDlg, IDC_EDIT_ZONE);
			hwndEditPassword = GetDlgItem(hwndDlg, IDC_EDIT_AT_PASSWORD);
			SetWindowText(hwndEditName, gConnecSettings[3]->GetTextValue(settingRemoteMachName));
			SetWindowText(hwndEditZone, gConnecSettings[3]->GetTextValue(settingRemoteZone));
			SetWindowText(hwndEditPassword, gConnecSettings[3]->GetTextValue(settingRemoteATPassword));
			CString title = platform_str[GetPowerOfTwo(gplatform)] + " AppleTalk Settings";
			SetWindowText(hwndDlg, title);
			return TRUE;
			}
		case WM_COMMAND:
			switch(LOWORD(wParam))
				{
				case IDOK:
					char ch_array[256];
					GetWindowText(hwndEditName, ch_array, 256);
					gConnecSettings[3]->SetTextValue(settingRemoteMachName, ch_array);
					GetWindowText(hwndEditZone, ch_array, 256);
					gConnecSettings[3]->SetTextValue(settingRemoteZone, ch_array);
					GetWindowText(hwndEditPassword, ch_array, 256);
					gConnecSettings[3]->SetTextValue(settingRemoteATPassword, ch_array);
					gConnecSettings[3]->WriteRegistry();
					return SendMessage(hwndDlg, WM_CLOSE, 0, 0);
				case IDCANCEL:
					return SendMessage(hwndDlg, WM_CLOSE, 0, 0);
				default:
					return 0;
				}
		case WM_CLOSE:
			return EndDialog(hwndDlg, 0);
		default:
			return 0;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\connec.h ===
#ifndef CONNEC_H
#define CONNEC_H

/*******************************************************************************

Include files

********************************************************************************/

#include <afxwin.h>
#include "settings.h"
#include "shl\coconnec.h"
#include "shl\wbutil.h"
#include "shl\uiconset.h"


/*******************************************************************************

Declaration of CConnections class

********************************************************************************/

class CConnections
	
	{		
	public:
		
		// entry point into connection settings feature
		int Connections(HWND hwndOwner, CSettings** pConnecSettings, PLATFORM_TYPE platform);

		// text-to-int conversion routines (called by ide targets during init)
		CONNECTION_TYPE ConnectionTextToInt(CString connection_txt);
		CONNECTOR_TYPE ConnectorTextToInt(CString connector_txt);
		BAUD_RATE_TYPE BaudRateTextToInt(CString baud_rate_txt);
		FLOW_CONTROL_TYPE FlowControlTextToInt(CString flow_control_txt);
		DATA_BITS_TYPE DataBitsTextToInt(CString data_bits_txt);
		STOP_BITS_TYPE StopBitsTextToInt(CString stop_bits_txt);
		PARITY_TYPE ParityTextToInt(CString parity_txt);
	};

// window procedures for settings dlgs
BOOL CALLBACK ConnectionDlgProc(HWND hwndDlg, UINT msg,	WPARAM wParam, LPARAM lParam);
BOOL CALLBACK Win32SerialDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK PMacSerialDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK Mac68KSerialDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK IPDlgProc(HWND hwndDlg, UINT msg,	WPARAM wParam, LPARAM lParam);
BOOL CALLBACK ATDlgProc(HWND hwndDlg, UINT msg,	WPARAM wParam, LPARAM lParam);
		
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\idepage.h ===
/////////////////////////////////////////////////////////////////////////////
// idepage.h
//
// email	date		change
// briancr	11/10/94	created
//
// copyright 1994 Microsoft

// Interface of the CIDEPage class

#include "resource.h"
#include "settings.h"
#include "target.h"
#include "idetarg.h"

/////////////////////////////////////////////////////////////////////////////
// CIDEPage dialog

class CIDEPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CIDEPage)

// Construction
public:
	CIDEPage(CSettings* pSettings = NULL, CIDE* pIDE = NULL);
	~CIDEPage();

// Dialog Data
	//{{AFX_DATA(CIDEPage)
	enum { IDD = IDD_TargetIDE };
	int		m_bClose;
	int		m_bDebugProcess;
	int		m_bIgnoreASSERT;
	int		m_bBreakASSERT;
	int		m_bNewApp;
	int		m_bUseKey;
	int		m_bPersist;
	CString	m_strCmdLine;
	CString	m_strFilename;
	CString	m_strKey;
	CString	m_strWorkDir;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CIDEPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
	virtual BOOL OnSetActive(void);
	virtual void OnOK(void);

// data
protected:
	CSettings* m_pSettings;
	CIDE* m_pIDE;

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CIDEPage)
	afx_msg void OnIDEUseKey();
	afx_msg void OnIDEConnections();
	afx_msg void OnIDEDebugProcess();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		BrianCr				09/06/94
//
//	Description :
//		Precompiled header for all of the core MFC files
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		BrianCr				09/06/94
//
//	Description :
//		source file that includes just the standard includes
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\idepage.cpp ===
/////////////////////////////////////////////////////////////////////////////
// idepage.cpp
//
// email	date		change
// briancr	11/10/94	created
//
// copyright 1994 Microsoft

// Implementation of the CIDEPage class

#include "stdafx.h"
#include "idepage.h"

#define new DEBUG_NEW

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CIDEPage property page

IMPLEMENT_DYNCREATE(CIDEPage, CPropertyPage)

CIDEPage::CIDEPage(CSettings* pSettings /*= NULL*/, CIDE* pIDE /*= NULL*/)
: CPropertyPage(CIDEPage::IDD),
  m_pSettings(pSettings),
  m_pIDE(pIDE)
{
	//{{AFX_DATA_INIT(CIDEPage)
	m_bClose = FALSE;
	m_bDebugProcess = FALSE;
	m_bIgnoreASSERT = FALSE;
	m_bBreakASSERT = FALSE;
	m_bNewApp = FALSE;
	m_bPersist = FALSE;
	m_bUseKey = FALSE;
	m_strCmdLine = _T("");
	m_strFilename = _T("");
	m_strKey = _T("");
	m_strWorkDir = _T("");
	//}}AFX_DATA_INIT
}

CIDEPage::~CIDEPage()
{
}

void CIDEPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CIDEPage)
	DDX_Check(pDX, IDC_IDEClose, m_bClose);
	DDX_Check(pDX, IDC_IDEDebugProcess, m_bDebugProcess);
	DDX_Check(pDX, IDC_IDEIgnoreASSERT, m_bIgnoreASSERT);
	DDX_Check(pDX, IDC_IDEBreakASSERT, m_bBreakASSERT);
	DDX_Check(pDX, IDC_IDENewApp, m_bNewApp);
	DDX_Check(pDX, IDC_IDEPersist, m_bPersist);
	DDX_Check(pDX, IDC_IDEUseKey, m_bUseKey);
	DDX_Text(pDX, IDE_IDECmdLine, m_strCmdLine);
	DDX_Text(pDX, IDE_IDEFilename, m_strFilename);
	DDX_Text(pDX, IDE_IDEKey, m_strKey);
	DDX_Text(pDX, IDE_IDEWorkDir, m_strWorkDir);
	//}}AFX_DATA_MAP

}

BOOL CIDEPage::OnSetActive(void)
{
	// call the base class
	if (!CPropertyPage::OnSetActive()) {
		return FALSE;
	}

	// the settings object must exist
	ASSERT(m_pSettings);

	// fill in the UI from the settings object
	m_bIgnoreASSERT = m_pSettings->GetBooleanValue(settingIgnoreASSERT);
	m_bBreakASSERT = m_pSettings->GetBooleanValue(settingBreakASSERT);
	m_bNewApp = m_pSettings->GetBooleanValue(settingNewApp);
	m_bClose = m_pSettings->GetBooleanValue(settingClose);
	m_bDebugProcess = m_pSettings->GetBooleanValue(settingDebugProcess);
	m_bPersist = m_pSettings->GetBooleanValue(settingPersist);
	m_bUseKey = m_pSettings->GetBooleanValue(settingIDEUseKey);

	// Get the filename based on whether we're gonna run debug or retail.
	if (m_pSettings->GetBooleanValue(settingDebugBuild))
		m_strFilename = m_pSettings->GetTextValue(settingDebugFilename);
	else
		m_strFilename = m_pSettings->GetTextValue(settingFilename);

	m_strCmdLine = m_pSettings->GetTextValue(settingCmdLine);
	m_strWorkDir = m_pSettings->GetTextValue(settingWorkingDir);
	m_strKey = m_pSettings->GetTextValue(settingIDEKey);

	UpdateData(FALSE);

	OnIDEUseKey();
	OnIDEDebugProcess();

	return TRUE;
}

void CIDEPage::OnOK(void)
{
	// call the base class
	CPropertyPage::OnOK();

	// the settings object must exist
	ASSERT(m_pSettings);

	// retrieve the settings from the UI
	UpdateData(TRUE);

	// update the settings object from the UI
	m_pSettings->SetBooleanValue(settingIgnoreASSERT, m_bIgnoreASSERT);
	m_pSettings->SetBooleanValue(settingBreakASSERT, m_bBreakASSERT);
	m_pSettings->SetBooleanValue(settingNewApp, m_bNewApp);
	m_pSettings->SetBooleanValue(settingClose, m_bClose);
	m_pSettings->SetBooleanValue(settingDebugProcess, m_bDebugProcess);
	m_pSettings->SetBooleanValue(settingPersist,m_bPersist);
	m_pSettings->SetBooleanValue(settingIDEUseKey, m_bUseKey);

	if (m_pSettings->GetBooleanValue(settingDebugBuild))
		m_pSettings->SetTextValue(settingDebugFilename, m_strFilename);
	else
		m_pSettings->SetTextValue(settingFilename, m_strFilename);

	m_pSettings->SetTextValue(settingCmdLine, m_strCmdLine);
	m_pSettings->SetTextValue(settingWorkingDir, m_strWorkDir);
	m_pSettings->SetTextValue(settingIDEKey, m_strKey);

	// write settings to the registry
	m_pSettings->WriteRegistry();
}

BEGIN_MESSAGE_MAP(CIDEPage, CPropertyPage)
	//{{AFX_MSG_MAP(CIDEPage)
	ON_BN_CLICKED(IDC_IDEUseKey, OnIDEUseKey)
	ON_BN_CLICKED(IDB_IDEConnections, OnIDEConnections)
	ON_BN_CLICKED(IDC_IDEDebugProcess, OnIDEDebugProcess)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CIDEPage message handlers

void CIDEPage::OnIDEUseKey()
{
	// retrieve the settings from the UI
	UpdateData(TRUE);

	// get pointers to the connector and baud rate drop downs and text
	CWnd* pKeyText = GetDlgItem(IDS_IDEKeyText);
	CWnd* pKeyEdit = GetDlgItem(IDE_IDEKey);

	// enable connector and baud rate based on setting of use com port
	pKeyText->EnableWindow(m_bUseKey);
	pKeyEdit->EnableWindow(m_bUseKey);
}

void CIDEPage::OnIDEConnections()
{
	m_pIDE->SetConnections(m_hWnd);
}

void CIDEPage::OnIDEDebugProcess()
{
	// Set the current state of the member vars to match those of what's being displayed.
	UpdateData(TRUE);

	if (m_bDebugProcess == FALSE)
		GetDlgItem(IDC_IDEClose)->EnableWindow();
	else
	{
		m_bClose = TRUE;
		GetDlgItem(IDC_IDEClose)->EnableWindow(FALSE);
		UpdateData(FALSE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\registry.cpp ===
#ifdef _CONSOLE
	#include <afxwin.h>
	#include <windows.h>
	#include <ostream.h>
	#include "registry.h"
	#define __WB_H__
#endif
#include "stdafx.h"
#include "registry.h"
#include "guiv1.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
static BOOL g_bListOnly = FALSE;

#ifdef _CONSOLE
	static CString strKeyName = cstrKeyRoot;
#else
	#if defined(V4LOW)
		static CString strKeyName = cstrKeyRoot + "Developer Standard";
	#else
		static CString strKeyName = cstrKeyRoot + "DevStudio\\6.0";
	#endif
#endif

CString gstrKeyExt = "_AUTO";
	
inline const CString GetRegistryKeyName( void )
{
	return strKeyName + gstrKeyExt;
}

void ReplaceKey( const CString& strRestoreFile )
{
	DWORD dwDisp;
	HKEY hKeyMain;
	VERIFY( RegCreateKeyEx( HKEY_CURRENT_USER, GetRegistryKeyName(),
		0, "", REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_READ, NULL,
		&hKeyMain, &dwDisp )	== ERROR_SUCCESS );

	SushiRestoreKey( hKeyMain, strRestoreFile );
	RegCloseKey( hKeyMain );
}

void DeleteKey(void)
{
	DWORD dwDisp;
	HKEY hKeyMain;
	TRACE("Deleting key '%s' use caution...\n", GetRegistryKeyName());
	if (RegCreateKeyEx(HKEY_CURRENT_USER, GetRegistryKeyName(),	0, "", REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_READ, NULL, &hKeyMain, &dwDisp ) == ERROR_SUCCESS) {
		DeleteSubKeys(hKeyMain, GetRegistryKeyName());
		RegCloseKey(hKeyMain);
	}
}

void SushiRestoreKey( HKEY hKey, const CString& str )
{
#ifdef _WIN32
	if ( !str.IsEmpty() )
	{
        HANDLE hToken;
        TOKEN_PRIVILEGES tkp;

        OpenProcessToken( GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken );

        // Get the LUID for restore privilege
        LookupPrivilegeValue( NULL, SE_RESTORE_NAME, &tkp.Privileges[0].Luid );

        tkp.PrivilegeCount = 1;  // one privilege to set
        tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

	        // Get restore privilege for this process.
        AdjustTokenPrivileges( hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0 );

	#ifdef _CONSOLE
		if ( IsNTKey( str ) )
		{
			if ( ::GetVersion() & 0x80000000 )	// Win32s or Chicago
				cout << endl << endl << "*** Cannot use an NT binary key on this system!" << endl;
			else
				RegRestoreKey( hKey, str, 0 );
		}
		else
		{
			cout << endl << "Removing subkeys";
	#endif

			DeleteSubKeys( hKey, GetRegistryKeyName() );

	#ifdef _CONSOLE
			cout << endl << "Removing values";
	#endif

			DeleteValues( hKey, GetRegistryKeyName() );

	#ifdef _CONSOLE
		cout << endl << "Restoring key from " << (LPCTSTR)str;
	#endif

			RestoreKey( hKey, str );

	#ifdef _CONSOLE
			cout << endl;
		}
	#endif

		// Reset privilege.
        tkp.Privileges[0].Attributes = SE_PRIVILEGE_USED_FOR_ACCESS;
        AdjustTokenPrivileges( hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0 );
	}
#endif
}

BOOL IsNTKey( const CString& strRestoreFile )
{
	TRY
	{
		CString strBuffer;
		CFile keyFile( strRestoreFile, CFile::modeRead | CFile::shareDenyNone );
		VERIFY( keyFile.Read( strBuffer.GetBufferSetLength( 4 ), 4 ) == 4 );
		strBuffer.ReleaseBuffer( 4 );
		BOOL bNTKey = (strBuffer == "regf");
		keyFile.Close();
		return bNTKey;
	}
	CATCH_ALL( e )
		return FALSE;
	END_CATCH_ALL
}

void DeleteSubKeys( HKEY hKey, const CString& strKeyName )
{
	TRY
	{
		DWORD iSubKey = 0;
		TCHAR szSubKey[MAX_PATH+1];
		CStringArray* pKeyArray = new CStringArray;
		while ( RegEnumKey( hKey, iSubKey++, szSubKey, MAX_PATH ) == ERROR_SUCCESS )
			pKeyArray->Add( szSubKey );

		for ( int iCur = 0, iTop = pKeyArray->GetUpperBound(); iCur <= iTop; iCur++ )
		{
			HKEY hSubKey;
			CString strSubKeyName = strKeyName + '\\' + (*pKeyArray)[iCur];
			LONG lResult = RegOpenKeyEx( HKEY_CURRENT_USER, strSubKeyName, 0, KEY_WRITE | KEY_READ, &hSubKey );
			ASSERT( lResult == ERROR_SUCCESS );
			if ( lResult == ERROR_SUCCESS )
			{
				DeleteSubKeys( hSubKey, strSubKeyName );
				RegCloseKey( hSubKey );
			}
			if ( !g_bListOnly )
				VERIFY( RegDeleteKey( hKey, (*pKeyArray)[iCur] ) == ERROR_SUCCESS );
			#ifdef _CONSOLE
				cout << endl << '\t' << (LPCTSTR)strSubKeyName;
			#endif
		}
		delete pKeyArray;
	}
	CATCH_ALL( e )
		ASSERT( FALSE );	//shdn't get to this statement
	END_CATCH_ALL
}

void DeleteValues( HKEY hKey, const CString& strKeyName )
{
	TRY
	{
		DWORD iValue = 0;
		DWORD cchValue = MAX_PATH;
		TCHAR szValue[MAX_PATH];
		CStringArray* pValueArray = new CStringArray;
		while ( RegEnumValue( hKey, iValue++, szValue, &cchValue, NULL, NULL, NULL, NULL ) == ERROR_SUCCESS )
		{
			pValueArray->Add( szValue );
			cchValue = MAX_PATH;
		}
		for ( int iCur = 0, iTop = pValueArray->GetUpperBound(); iCur <= iTop; iCur++ )
		{
			if ( !g_bListOnly )
				VERIFY( RegDeleteValue( hKey, (LPTSTR)(LPCTSTR)(*pValueArray)[iCur] ) == ERROR_SUCCESS );
			#ifdef _CONSOLE
				cout << endl << '\t' << (LPCTSTR)(*pValueArray)[iCur];
			#endif
		}
		delete pValueArray;
	}
	CATCH_ALL( e )
		ASSERT( FALSE );	//shdn't get to this statement
	END_CATCH_ALL
}

inline HKEY AddSubKey( HKEY hKey, LPCTSTR szName )
{
	DWORD dwDisp;
	HKEY hSubKey = NULL;
	if ( !g_bListOnly )
		VERIFY( RegCreateKeyEx( hKey, szName, 0, "", REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_READ, NULL,
								&hSubKey, &dwDisp )	== ERROR_SUCCESS );
	#ifdef _CONSOLE
		cout << endl << '\t' << szName;
	#endif
	return hSubKey;
}

inline void AddValue( HKEY hKey, LPTSTR szName, DWORD dwType, CONST BYTE* pbData, DWORD cbData )
{
	if ( !g_bListOnly )
		VERIFY( RegSetValueEx( hKey, szName, 0, dwType, pbData, cbData ) == ERROR_SUCCESS );
	#ifdef _CONSOLE
		cout << endl << "\t\t" << szName;
	#endif
}

void RestoreKey( HKEY hKey, const CString& strRestoreFile )
{
	TRY
	{
		CStdioFile file;
		if ( !file.Open( strRestoreFile, CFile::modeRead | CFile::typeText ) )
			return;

		char acOldName[256];
		VERIFY( file.ReadString( acOldName, 255 ) );
		char* pchCol = acOldName;
		do									// find colon
		{
			if ( IsDBCSLeadByte( *pchCol ) )
				pchCol += 2;
			else
				pchCol++;
		}
		while ( *pchCol != ':' );
		while ( isspace( *++pchCol ) );			// find next non-space
		int nCol = pchCol - acOldName;
		acOldName[strlen( acOldName ) - 1] = '\\';	// append backslash, and remove line-feed

		char acClassName[256];
		VERIFY( file.ReadString( acClassName, 255 ) );
		char acLastWrite[256];
		VERIFY( file.ReadString( acLastWrite, 255 ) );		// Last Write Time

		HKEY hSubKey = hKey;

		char acBuf[256];
		while ( file.ReadString( acBuf, 255 ) != NULL )
		{
			ASSERT( acBuf[strlen( acBuf ) - 1] == '\n' );		// if this fails, the line was longer than 255 characters
			acBuf[strlen( acBuf ) - 1] = '\0';				// remove line-feed

			if ( strcmp( acBuf," " ) == 0 )
				continue;	// no sense worrying about blank lines

			if ( (strlen( acBuf ) > strlen( acOldName ) ) &&
				(strncmp( acOldName + nCol, acBuf + nCol, strlen( acOldName + nCol ) ) == 0) )
			{							// this is a sub-key
				VERIFY( file.ReadString( acClassName, 255 ) );
				VERIFY( file.ReadString( acLastWrite, 255 ) );		// Last Write Time
				if ( hSubKey != hKey )
					RegCloseKey( hSubKey );
				hSubKey = AddSubKey( hKey, acBuf + strlen( acOldName ) );	// new key using only relative name of key
			}
			else						// this is a value
			{
				char acValueName[256];
				VERIFY( file.ReadString( acValueName, 255 ) );
				acValueName[strlen( acValueName )-1] = '\0';
				char acValueType[256];
				VERIFY( file.ReadString( acValueType, 255 ) );
				acValueType[strlen( acValueType )-1] = '\0';
				if ( strcmp( acValueType + nCol, "REG_SZ" ) == 0 )
				{
					char acString[2048];
					VERIFY( file.ReadString( acString, 2047 ) );
					ASSERT( strlen( acString ) > (size_t)nCol );				// failure means no string was read
					ASSERT( acString[strlen( acString )-1] == '\n' );	// failure means the string was bigger than our buffer
					acString[strlen( acString )-1] = '\0';
					AddValue( hSubKey, acValueName + nCol, REG_SZ, (CONST BYTE*)acString + nCol, strlen( acString + nCol ) + 1 );
				}
				else if ( strcmp( acValueType + nCol, "REG_MULTI_SZ" ) == 0 )
				{
					CStringArray sa;
					char acString[2048];
					VERIFY( file.ReadString( acString, 2047 ) );
					ASSERT( acString[strlen( acString )-1] == '\n' );	// failure means the string was bigger than our buffer
					acString[strlen( acString )-1] = '\0';
					sa.Add( acString + nCol );

					while ( TRUE )
					{
						VERIFY( file.ReadString( acString, 2047 ) );
						ASSERT( acString[strlen( acString )-1] == '\n' );	// failure means the string was bigger than our buffer
						acString[strlen( acString )-1] = '\0';
						ASSERT( strncmp( acString, "+++++++++ ", 10 ) == 0 );
						if ( acString[10] == '\0' )
							break;		// end of string list
						sa.Add( acString + 10 );	// add string to array
					}

					int nBytes = 1;		// final NULL
					int n;
					for ( n = 0; n < sa.GetSize(); n++ )
						nBytes += sa.GetAt( n ).GetLength() + 1;	// string length including NULL

					char* pchData = new char[nBytes];
					char* pch = pchData;
					for ( n = 0; n < sa.GetSize(); n++ )
					{
						strcpy( pch, sa.GetAt( n ) );
						pch += sa.GetAt( n ).GetLength() + 1;
					}
					*pch = '\0';		// final NULL

					AddValue( hSubKey, acValueName + nCol, REG_MULTI_SZ, (CONST BYTE*)pchData, nBytes );
					delete[] pchData;
				}
				else if ( strcmp( acValueType + nCol, "REG_DWORD" ) == 0 )
				{
					char acString[2048];
					VERIFY( file.ReadString( acString, 2047 ) );
					DWORD dw;
					if ( (acString[nCol] == '0') && (acString[nCol+1] == 'x') )
						sscanf( acString + nCol, "%x", &dw );
					else
						sscanf( acString + nCol, "%d", &dw );
					AddValue( hSubKey, acValueName + nCol, REG_DWORD, (CONST BYTE*)&dw, sizeof(DWORD) );
				}
				else if ( strcmp( acValueType + nCol, "REG_BINARY" ) == 0 )
				{
					char acLine[256];
					VERIFY( file.ReadString( acLine, 255 ) );		// "Data:"
					DWORD dwLine = 0x0;
					int nDataSize = 2048;
					BYTE* pbData = new BYTE[nDataSize];		// initially try this size
					int nBytes = 0;
					BYTE* pb = pbData;

					while ( TRUE )
					{
						VERIFY( file.ReadString( acLine, 255 ) );		// "00000000"
						CString strLine;
						strLine.Format( "%08x", dwLine );
						if ( strncmp( strLine, acLine, 8 ) != 0 )
							break;	// we're done, or something, cause this is not the next line of binary data

						char* pchData = acLine + 11;
						for ( int n = 0; n < 16; n++, pchData += 3, nBytes++, pb++ )
						{
							if ( n == 8 )
								pchData += 2;		// skip " - "
							if ( !isxdigit( *pchData ) )
								break;

							if ( (pchData[0] >= 'a') && (pchData[0] <= 'f') )
								*pb = ((pchData[0]) - 'a') + 10;
							else if ( (pchData[0] >= 'A') && (pchData[0] <= 'F') )
								*pb = ((pchData[0]) - 'A') + 10;
							else if ( isdigit( pchData[0] ) )
								*pb = ((pchData[0]) - '0');
							*pb *= 0x10;
							if ( (pchData[1] >= 'a') && (pchData[1] <= 'f') )
								*pb += ((pchData[1]) - 'a') + 10;
							else if ( (pchData[1] >= 'A') && (pchData[1] <= 'F') )
								*pb += ((pchData[1]) - 'A') + 10;
							else if ( isdigit( pchData[1] ) )
								*pb += ((pchData[1]) - '0');
						}
						if ( n < 16 )
							break;		// end of data

						if ( nBytes > nDataSize )
						{
							ASSERT( FALSE );		// NYI - grow data size
						}

						dwLine += 0x10;			// increment the number expected on the next line
					}

					AddValue( hSubKey, acValueName + nCol, REG_BINARY, pbData, nBytes );
					delete[] pbData;
				}
				else
					ASSERT( FALSE );		// REG_TYPE NYI
			}
		}

		if ( hSubKey != hKey )
			RegCloseKey( hSubKey );
	}
	CATCH_ALL( e )
		ASSERT( FALSE );	//shdn't get to this statement
	END_CATCH_ALL
}

#ifdef _CONSOLE
	void main( int argc, char* argv[] )
	{
		CString strValue;
		CCmdLine cmdline( argc, argv );
		if ( cmdline.GetBooleanSwitch( "?", FALSE ) )
		{
			cout << endl
				<< "Initializes a registry key in HKEY_CURRENT_USER\\Software\\Microsoft." << endl << endl
				<< "SETKEY [/list] [/name=keyname] [/key=keyfile] [/i=keysuffix]" << endl << endl
				<< "  /list\t\tList actions. (Does not modify key)" << endl
				<< "  /name\t\tName of key.  Default is Visual C++ 2.0" << endl
				<< "  /key\t\tName of file.  Default is SUSHI.KEY" << endl
				<< "  /i\t\tSuffix for key.  Default is _AUTO  (Use /i=no to omit suffix)" << endl;
				return;
		}
		cmdline.GetTextSwitch( "NAME", strValue, "Visual C++ 2.0" );
		strKeyName += strValue;
		if ( cmdline.GetBooleanSwitch( "I", TRUE ) )
		{
			cmdline.GetTextSwitch( "I", strValue, "_AUTO" );
			strKeyName += strValue;
		}
		cout << endl << "Initializing HKEY_CURRENT_USER\\" << (LPCTSTR)GetRegistryKeyName();
		g_bListOnly = cmdline.GetBooleanSwitch( "LIST", FALSE );
		cmdline.GetTextSwitch( "KEY", strValue, "SUSHI.KEY" );
		ReplaceKey( strValue );
	}

	/*	CCmdLine Constructor
	 *		Reads command line strings and stores switches (arguments preceded by '-' or '/')
	 *		in a CMapStringToString object for later retrieval.
	 *		Example: sniff.exe -c="-run=false post=true" -run -post:false -logdir=h:\logs
	 *		
	 *		This would map in the following manner:
	 *		
	 *		C 		->		"-run=false post=true"
	 *		RUN		->		""
	 *		POST	->		"false"
	 *		LOGDIR	->		"h:\logs"
	 *		
	 *		Note that the case of switch names is always ignored, but the case of their
	 *		value is preserved.
	 */
	CCmdLine::CCmdLine( int argc, char* argv[] )
	{
		CString strA, strV;

		for ( int iNext = 0; iNext < argc; iNext++ )
		{	
			ParseSwitch( argv[iNext], strA, strV );

			if ( strA.GetLength() )
			{
				strA.MakeUpper();
				m_SwitchMap.SetAt( strA, strV );
			}
		}
	}

	int CCmdLine::ParseSwitch( LPCSTR szCL, CString &strA, CString &strV )
	{
		strA = strV = "";

		if ( !szCL || !szCL[0] )
			return 0;

		int iNext = FindNextSwitch( szCL );
		if ( iNext == -1 )
			return -1;

		CString strCL = szCL + iNext;

		int iAssign = strCL.FindOneOf( ":=" );
		int iDelim = strCL.FindOneOf( " ,\t\"" );

		if ( (iDelim != -1) && (iDelim < iAssign) )
			iAssign = -1;

		if ( iDelim == 0 )	// if delimiter is next
			return 1;

		if ( (iAssign == -1) && (iDelim == -1) )	// if last parameter & no assignment
		{
			strA = strCL;
			return strCL.GetLength();	// point at '\0';
		}

		if ( iAssign == -1 )	// but iDelim > -1
		{
			strA = strCL.Left( iDelim );	// leave off delimiter
			return 1 + strA.GetLength();	// point past delimiter
		}

		if ( iDelim == -1 )	// if last parameter & uses assignment
		{
			strA = strCL.Left( iAssign );
			strV = strCL.Mid( 1 + iAssign );
			return strCL.GetLength();	// point at '\0';
		}

		// otherwise both are > -1

		if ( strCL[iDelim] == '"' )	// uh oh, they're using quotes
		{
			strA = strCL.Left( iAssign );
			if ( iDelim != 1 + iAssign )	// the user messed up, but try to cope
			{
				strV = strCL.Mid( 1 + iAssign, iDelim - iAssign - 1 );
				return -1;	// they improperly used quotes
			}
			strV = strCL.Mid( 2 + iAssign );	// the quoted text
			int iEndQuote = strV.Find( '"' );
			if ( iEndQuote != -1 )
			{
				strV = strV.Left( iEndQuote );
				return iEndQuote + 3 + iAssign;	// point past 2nd quote
			}
			else
				return -1;	// they didn't give a second quote
		}
		else		// no quotes, just x=y or x:y
		{
			strA = strCL.Left( iAssign );
			strV = strCL.Mid( 1 + iAssign, iDelim - iAssign - 1 );
			return 1 + iDelim;	// point past delimiter
		}
	}

	int CCmdLine::FindNextSwitch( LPCSTR szCL )
	{
		CString strCL = szCL;
		int i = strCL.FindOneOf( "-/" );
		if ( i == -1 )
			return -1;
		CString strX = strCL.Mid( i+1 );
		if ( strX.FindOneOf( " \t-/" ) == 0 )
			return FindNextSwitch( 2+i+szCL );
		return i+1;
	}


	/*	GetTextSwitch
	 *		This function returns the given value of a command-line switch.
	 *		Example: sniff.exe -c=" -run:0 -X:1 " -run:yes -post:"false" -logdir=h:\logs
	 *		
	 *		GetTextSwitch("c", strV): strV == " -run:0 -X:1 "
	 *		GetTextSwitch("run", strV): strV == "yes"
	 *		GetTextSwitch("RUN", strV): strV == "yes"
	 *		GetTextSwitch("LogDir", strV): strV == "h:\logs"
	 */
	BOOL CCmdLine::GetTextSwitch( LPCSTR szArg, CString &strR, LPCSTR szDefault /*=""*/ )
	{
		if ( (!szArg) || (!szArg[0]) )
		{
			strR = szDefault;
			return FALSE;
		}

		CString strArg = szArg;
		strArg.MakeUpper();

		if ( m_SwitchMap.Lookup( strArg, strR) )
			return TRUE;
		else
		{
			strR = szDefault;
			return FALSE;
		}

	}

	int CCmdLine::GetIntSwitch( LPCSTR szSwitch, int nDefault /*=0*/ )
	{
		CString strV;
	
		if ( GetTextSwitch( szSwitch, strV ) )
			return atoi( strV );
	
		return nDefault;
	}

	#define MAX_FALSE_STR 3
	LPCSTR aszFalseStr[1+MAX_FALSE_STR] = {"0","NO","FALSE","OFF"};
	#define MAX_TRUE_STR 3
	LPCSTR aszTrueStr[1+MAX_TRUE_STR] = {"1","YES","TRUE","ON"};

	/*	ParseBoolean
	 *		Used internally by GetBooleanSwitch.  Interprets text as a Boolean value.
	 */
	BOOL CCmdLine::ParseBoolean( LPCSTR szV, BOOL bDefault /*=FALSE*/ )
	{
		if ( (!szV) || (!szV[0]) )
			return TRUE;

		int i;

		CString strV( szV );
		strV.MakeUpper();

		for ( i = 0; i <= MAX_FALSE_STR; i++ )
		{
			if ( strV == aszFalseStr[i] )
				return FALSE;
		}

		for ( i = 0; i <= MAX_TRUE_STR; i++ )
		{
			if ( strV == aszTrueStr[i] )
				return TRUE;
		}

		return bDefault;
	}

	/*	GetBooleanSwitch
	 *		This function returns a Boolean interpretation of a command-line switch.
	 *		FALSE, NO, OFF, and 0 are interpreted as FALSE.
	 *		TRUE, YES, ON, 1, and no value are interpreted as TRUE.
	 *		Example: sniff.exe -debug=0 -run -post:"false" -logdir=h:\logs
	 *		
	 *		GetBooleanSwitch("debug") == FALSE
	 *		GetBooleanSwitch("run") == TRUE
	 *		GetBooleanSwitch("RUN") == TRUE
	 *		GetBooleanSwitch("Post") == FALSE
	 */
	BOOL CCmdLine::GetBooleanSwitch( LPCSTR szArg, BOOL bDefault /* = FALSE */ )
	{
		CString strV, strArg( szArg );
	
		if ( GetTextSwitch( strArg, strV ) )
		{
			return ParseBoolean( strV, bDefault );
		}

		if ( GetTextSwitch( "no"+strArg, strV ) )
		{
			return !ParseBoolean( strV, bDefault );
		}
	
		return bDefault;
	}
#endif	//_CONSOLE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\idetarg.cpp ===
/////////////////////////////////////////////////////////////////////////////
// idetarg.cpp
//
// email	date		change
// briancr	11/04/94	created
//
// copyright 1994 Microsoft

// Implementation of the CTarget class

#include "stdafx.h"
#include "afxdllx.h"
#include "testxcpt.h"
#include "settings.h"
#include "idepage.h"
#include "registry.h"
#include "target.h"
#include "idetarg.h"
#include "mstwrap.h"
#include "guiv1.h"
#include "..\testutil.h"
#include "shl\uwbframe.h"
#include "dbg\codebug.h"
#include "shl\uioptdlg.h"
#include "shl\wbutil.h"
#include "shl\uiconset.h"
#include "shl\uitipdlg.h"
#include "prj\coprject.h"
#include "applog.h"
#include "toolset.h"
#include "evnthdlr.h"
#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CIDE

// register the HeapUse message
UINT CIDE::m_msgHeapUse = RegisterWindowMessage("HeapUse");

CIDE::CIDE()
: m_dwLaunchTime(0),
  m_pConnectionInfo(NULL),
  CGUITarget(GetLocString(IDSS_WORKBENCH_TITLEBAR))
{
	// filename of the heap use log file
	const char * const pfnHeapUse = "heapuse.log";

	// get the current directory
	::GetCurrentDirectory(MAX_PATH, m_strHeapUseFilename.GetBuffer(MAX_PATH));
	m_strHeapUseFilename.ReleaseBuffer();
	m_strHeapUseFilename = m_strHeapUseFilename + '\\' + pfnHeapUse;

	APPLOG("Deleting the heap use log file (%s).", (LPCSTR)m_strHeapUseFilename);

	// delete the heap use file
	::DeleteFile(m_strHeapUseFilename);

	// if we're running on nt/j, we need to initialize imehook.dll.
	// see cafe\support\guitools\imehook.cpp (michma - 1/1/97).
	if(m_bRunningOnNTJ = (GetSystem() & SYSTEM_NT) && (GetSystem() & SYSTEM_JAPAN))
		{
		// load imehook.dll into cafe's address space.
		if(m_hIMEHookDll = LoadLibrary("imehook.dll"))
			{
			// load the address of HookIDE().
			if(m_lpfnHookIDE = (void (FAR WINAPI *)(HWND))GetProcAddress(m_hIMEHookDll, "HookIDE"))
				{
				// load the address of UnhookIDE().
				if(!(m_lpfnUnhookIDE = (void (FAR WINAPI *)(HWND))GetProcAddress(m_hIMEHookDll, "UnhookIDE")))
					{
					APPLOG("WARNING: error %d getting proc address of UnhookIDE()."
						   "CAFE will not be able to access the IME\n", GetLastError());
					}
				}
			else
				{
				APPLOG("WARNING: error %d getting proc address of HookIDE()."
					   "CAFE will not be able to access the IME\n", GetLastError());
				}	
			}
		else
			APPLOG("WARNING: error %d loading imehook.dll. "
				   "CAFE will not be able to access the IME\n", GetLastError());
		}
}

CIDE::~CIDE()
{
	// destroy the connection info object
	delete m_pConnectionInfo;

	// if the IDE is still around, exit it
	if (IsLaunched() && m_psettingsTarget->GetBooleanValue(settingClose))
	{

		// if we are persisting the target between subsuites, we only want to exit the target after the last subsuite.
		if(!gbPersistTarget || gbLastSubSuite)
		{
			Exit();

			// if we were running on NT/J, we need to unload imehook.dll.
			// see cafe\support\guitools\imehook.cpp (michma - 1/1/97).
			if(m_bRunningOnNTJ && m_hIMEHookDll)
				FreeLibrary(m_hIMEHookDll);
		}
	}
}

BOOL CIDE::Launch(void)
{
	DWORD dwStartTime;
	DWORD dwEndTime;

	BOOL bLaunch;

	// tell the registry module which key to use
	gstrKeyExt = GetKeyExt();
	
	// slow links (win9x specific problem) must be turned on in the devstudio key before the ide launches. 
	// currently it requires that we launch without -i too.
	if(CMDLINE->GetBooleanValue("slowlinks", FALSE))
	
	{
		HKEY hKey;

		// open the key we need to modify.
		if(RegOpenKeyEx(HKEY_CURRENT_USER,"Software\\Microsoft\\DevStudio\\6.0\\Build System",
						0, KEY_SET_VALUE, &hKey) == ERROR_SUCCESS) 
		{
			// turn slow links on.
			DWORD dwSetting = 2;
			
			// write the value to the registry
			if(RegSetValueEx(hKey, "Slow Links for Win95", 0, REG_DWORD, 
							 (const unsigned char *) &dwSetting, sizeof(DWORD)) != ERROR_SUCCESS)
				APPLOG("WARNING: got error %d setting slow links reg key value.\n", GetLastError());

		// close the registry
		RegCloseKey(hKey);
		}
		
		else
			APPLOG("WARNING: got error %d opening build system reg key for slow links.\n", GetLastError());
	}
	
	else
	
	{
		/*
		emmang@xbox - don't delete VC keys for xbox testing

		// delete whatever alternate key is to be used
		DeleteKey();

		// do we restore the key?
		if (m_psettingsTarget->GetBooleanValue(settingIDEUseKey)) {
			// restore the key to the registry
			ReplaceKey(m_psettingsTarget->GetTextValue(settingIDEKey));
		}
		*/
	}

    WaitStepInstructions("Launching %s", (LPCSTR)(GetPath() + GetFileName()));

	// store the tick count before launching
	dwStartTime = ::GetTickCount();

	//prepare the titles of dialogs to be handled automatically by event thread
//set from here because GetLocString() cannot be reached from TARGET.DLL or GUI.DLL
	m_AssertionMsgText=GetLocString(IDSS_ASSERTION_FAILED);
	m_AssertionMsgTitle=GetLocString(IDSS_ASSERTION_FROM_DEBUGLIB);
//	currently, "Find Symbols" & "Find Source" dialogs are added to the list of automatically handled
	SetHandleMsgTitle(GetLocString(IDSS_FS_TITLE));
	SetHandleMsgTitle(GetLocString(IDSS_FIND_SYMBOLS_DLG_TITLE));
	SetHandleMsgs(TRUE);

	// call the base class to launch
	bLaunch = CGUITarget::Launch();

	// store the tick count after launching
	dwEndTime = ::GetTickCount();

	// compute the launch time
	// note that this includes the time it takes for the IDE's window to actually be visible
	m_dwLaunchTime = dwEndTime - dwStartTime;

	// was the launch successful?


	MST.DoKeys("{ESC}") ; // HACK HACK HACK REMOVE ..
	if (bLaunch) {
	
		// is the Info Title Not Found dialog staring us in the face?
		UIDialog nd(GetLocString(IDSS_INFOTITLE_NOT_FOUND));
		if (nd.WaitAttachActive(1000))
		{
			// Cancel out of it
			nd.Cancel();
		}
		Sleep(2000) ; // HACK HACK HACK REMOVE
		MST.DoKeys("{ESC}");

		// is the tip of the day dialog showing?
		UITipDialog dlgTip;
		if (dlgTip.WaitAttachActive(500)) {
			// close it
			dlgTip.Close();
		}

		WaitForInputIdle(g_hTargetProc, 5000);		// Make sure the IDE gets the focus
		
		// REVIEW(briancr): This is for backward compatibility. We really should change this.
		// (JimGries) This comment refers to the removal or hiding of the UIWBFrame class within
		//            the CIDE class or whatever.
		// set up UIWB so it's valid
		UIWB.Attach(m_hWnd);
		//REVIEW(chriskoz): above is absolutely correct. I should also consider hooking the events (like Active Accessibility, ASSERTIONs) earlier in the Launch cycle but this is not in CAFE
		UIWB.m_pEventHandler = new CEventHandler;
		UIWB.m_pEventHandler->Connect(m_psettingsTarget->GetBooleanValue(settingDebugBuild)); //connect the AplicationEvents & Debugger Events & pass the pointer to target which would implement the Debugger Events thread
		UIWB.m_pTarget = this; //to know the target
		// Set the keymapping to VC2.0 by default. 
		// Much of CAFE support layer was written during the v2 time frame, and we requires these key mappings.

		// we must attach cafe's and the ide's thread inputs in order for cafe to call WGetFocus on the ide.
		// we are asssuming that the ide is in the foreground.
		HWND hWndFore = GetForegroundWindow();
		DWORD dwThreadFore = GetWindowThreadProcessId(hWndFore, NULL);
		AttachThreadInput(GetCurrentThreadId(), dwThreadFore, TRUE);

		UIOptionsTabDlg CompDlg ;
		CompDlg.ShowTabsTab() ;	
		MST.WComboItemClk(GetLabel(VCPP32_IDC_LANGUAGES), 2) ;
		MST.WOptionSelect(GetLabel(VCPP32_IDC_SMART_AUTOINDENT)) ;
		CompDlg.ChangeCompatility(EMULATE_VC2) ;

		// if we are running on nt/j, we need to hook the ide to access its ime.
		// see cafe\support\guitools\imehook.cpp (michma - 1/1/97).
		if(m_bRunningOnNTJ && m_lpfnHookIDE)
			// call HookIDE() in imehook.dll, passing the ide's main window handle.
			(*(m_lpfnHookIDE))(m_hWnd);
			 
		return TRUE;
	}

	return FALSE;
}

BOOL CIDE::Exit(void)
{
    WaitStepInstructions("Shutting down %s...", (LPCSTR)GetFileName());

	// if debugging, stop debugging
	//REVIEW(chriskoz): removed the COdebug::StopDebugging(). It should not be there. No idea why it got here?
	UINT state = UIWB.GetIDEState();
	if((state & ST_DEBUGRUN) || (state & ST_DEBUGBREAK))
		UIWB.StopDebugging(ASSUME_NORMAL_TERMINATION);
	// close all open windows
	UIWB.CloseAllWindows();		// closes any open source files

	// if we were running on nt/j, we need to unhook the ide.
	// see cafe\support\guitools\imehook.cpp (michma - 1/1/97).
	if(m_bRunningOnNTJ && m_lpfnUnhookIDE)
		// call UnhookIDE() in imehook.dll, passing the ide's main window handle.
		(*(m_lpfnUnhookIDE))(m_hWnd);

	UIWB.m_pEventHandler->Disconnect(); //to disconnect the pointer to Debugger in Target Class
	delete UIWB.m_pEventHandler;
	UIWB.m_pEventHandler=NULL;
	UIWB.m_pTarget = NULL; //REVIEW(chriskoz): should we wait until the process is shut down?

	// call the base class
	if(CGUITarget::Exit())
	
	{
		// check to see if the slow links switch was set (see Launch for explanation).
		if(CMDLINE->GetBooleanValue("slowlinks", FALSE))
		
		{
			HKEY hKey;

			// open the key we need to modify.
			if(RegOpenKeyEx(HKEY_CURRENT_USER,"Software\\Microsoft\\DevStudio\\6.0\\Build System",
							0, KEY_SET_VALUE, &hKey) == ERROR_SUCCESS) 
			{
				// turn off slow links.
				DWORD dwSetting = 0;
				
				// write the value to the registry
				if(RegSetValueEx(hKey, "Slow Links for Win95", 0, REG_DWORD, 
								 (const unsigned char *) &dwSetting, sizeof(DWORD)) != ERROR_SUCCESS)
					APPLOG("WARNING: got error %d setting slow links reg key value.\n", GetLastError());

			// close the registry
			RegCloseKey(hKey);
			}
			
			else
				APPLOG("WARNING: got error %d opening build system reg key for slow links.\n", GetLastError());
		}

		return TRUE;
	}

	return FALSE;
}


BOOL CIDE::IsActive(void)
{
 //	Sleep(10000);
	if( UIWB.IsAlert() )
	{
		LOG->RecordCriticalError("XSAFETY: Unexpected Workbench Alert");
		TEST_EXCEPTION(causeTargetGone);     // REVIEW: Should there be an exception cause for this case
		return FALSE;
	}

	if( !UIWB.IsActive() )
	{
		HWND hwnd = MST.WGetActWnd(0);
		char acBuf[256];
		GetText(hwnd, acBuf, 255);
		LOG->RecordCriticalError("XSAFETY: %x (%s) active when expecting %x (%s)", hwnd, acBuf, (HWND)UIWB, "target app" /*WORKBENCH_EXENAME*/);
		TEST_EXCEPTION(causeTargetGone);
		return FALSE;
	}
	return TRUE;
}

BOOL CIDE::Initialize(CToolset::BUILD_TYPE nBuildType, CString strKey)
{
	// instantiate the settings object for this target
	strKey += "\\"+strIDETargetKey;
	m_psettingsTarget = new CSettings(strKey);

	// instantiate the property page for this target
	m_ppageTarget = new CIDEPage(m_psettingsTarget, this);

	// initialize settings
	BOOL bResult = InitializeSettings();

	if (bResult == FALSE)
		LOG->RecordFailure("CIDE::Initialize: Couldn't initialize the settings for the CIDE object");
	else  // Now initialize the filename and path member variables.
	{
		// Set the filename and path to this target based on the the Path environment variable.
		if (nBuildType == CToolset::Debug)	// If cafe is set to run debug version of target...
		{
			m_strFileName = m_psettingsTarget->GetTextValue(settingDebugFilename);
			m_psettingsTarget->SetBooleanValue(settingDebugBuild, TRUE);	// Required for IDE property page.
		}
		else								// Let's run retail...
		{
			m_strFileName = m_psettingsTarget->GetTextValue(settingFilename);
			m_psettingsTarget->SetBooleanValue(settingDebugBuild, FALSE);	// Required for IDE property page.
		}

		m_strFileName += ".exe";

		// Find the file on the path sent by CAFE.
		CString strPath;
		CString strEnvPath;
		m_mapEnv.Lookup("PATH", strEnvPath);

		LPTSTR lpszJunk;
		if (::SearchPath(strEnvPath, m_strFileName, NULL, 1023, strPath.GetBuffer(1023), &lpszJunk) == 0)
		{
			APPLOG("CTarget::GetFullCmdLine: unable to find the target (%s) on the path (%s)\n", (LPCTSTR)m_strFileName, (LPCTSTR)strEnvPath);
			bResult = FALSE;
		}
		else
		{
			strPath.ReleaseBuffer();

			// set the path and filename to target
			char acDrive[_MAX_DRIVE];
			char acDir[_MAX_DIR];
			char acFileName[_MAX_FNAME];
			char acExt[_MAX_EXT];
			_splitpath(strPath, acDrive, acDir, acFileName, acExt);

			m_strPath = CString(acDrive) + acDir;
		}
	}

	return bResult;
}

BOOL CIDE::ApplySettings(CSettings* pSettings)
{
	// call the base class
	CGUITarget::ApplySettings(pSettings);

	// apply command line overrides:
	// ASSERTIONs/Exceptions handling
	m_psettingsTarget->SetBooleanValue(settingIgnoreASSERT, pSettings->GetBooleanValue(settingIgnoreASSERT, m_psettingsTarget->GetBooleanValue(settingIgnoreASSERT)));
	m_psettingsTarget->SetBooleanValue(settingBreakASSERT, pSettings->GetBooleanValue(settingBreakASSERT, m_psettingsTarget->GetBooleanValue(settingBreakASSERT)));
	// persist IDE between subsuites
	m_psettingsTarget->SetBooleanValue(settingPersist, pSettings->GetBooleanValue(settingPersist, m_psettingsTarget->GetBooleanValue(settingPersist)));
	//command line
	m_psettingsTarget->SetTextValue(settingCmdLine, pSettings->GetTextValue(settingCmdLine, m_psettingsTarget->GetTextValue(settingCmdLine)));

	// key extension
	if (!pSettings->GetBooleanValue(settingIDEKeyExt, TRUE)) {
		DeleteKeyExt();
	}
	// use key
	m_psettingsTarget->SetBooleanValue(settingIDEUseKey, pSettings->GetBooleanValue(settingIDEKey, m_psettingsTarget->GetBooleanValue(settingIDEUseKey)));
	// key
	m_psettingsTarget->SetTextValue(settingIDEKey, pSettings->GetTextValue(settingIDEKey, m_psettingsTarget->GetTextValue(settingIDEKey)));

	return TRUE;
}


BOOL CIDE::InitializeSettings(void)
{
	CString strDrive;
	CString strDir;

	BOOL bResult = TRUE;

	// call the base class
	bResult &= CGUITarget::InitializeSettings();

	// initialize IDE default settings
	m_psettingsTarget->SetBooleanValue(settingPersist, FALSE);
	// filename
	//xbox - we dont have access to debug builds of msdev
	//xbox   m_psettingsTarget->SetTextValue(settingDebugFilename, "msdevd");
	m_psettingsTarget->SetTextValue(settingDebugFilename, "msdev");
	m_psettingsTarget->SetTextValue(settingFilename, "msdev");

	// window class
	m_psettingsTarget->SetTextValue(settingWndClass, "Afx:");
	// cmd line
	//xbox - dont use the _auto registry key
	//xbox   m_psettingsTarget->SetTextValue(settingCmdLine, "-y0 -i_auto -noidelog -nocmdlog");
	m_psettingsTarget->SetTextValue(settingCmdLine, "-y0 -noidelog -nocmdlog");
	// don't use a key by default
	m_psettingsTarget->SetBooleanValue(settingIDEUseKey, FALSE);
	// key
	m_psettingsTarget->SetTextValue(settingIDEKey, "msdev.key");

	// REVIEW(briancr): don't forget remote settings
	// actually, remote settings probably go in the derived class(es)
	// remote settings...

	// load settings from the registry
	bResult &= m_psettingsTarget->ReadRegistry();
	// write the settings back out to initialize registry
	bResult &= m_psettingsTarget->WriteRegistry();

	// REVIEW(briancr): this sucks. When we go to the new method of using member vars, this problem will be more easily dealt with
	// prepend path to start up location in front of key name (only if there isn't one already)
	_splitpath(m_psettingsTarget->GetTextValue(settingIDEKey), NULL, strDir.GetBuffer(_MAX_DIR), NULL, NULL);
	strDir.ReleaseBuffer();
	if (strDir.IsEmpty()) {
		_splitpath(AfxGetApp()->m_pszHelpFilePath, strDrive.GetBuffer(_MAX_DRIVE), strDir.GetBuffer(_MAX_DIR), NULL, NULL);
		strDrive.ReleaseBuffer();
		strDir.ReleaseBuffer();

		m_psettingsTarget->SetTextValue(settingIDEKey, strDrive + strDir + m_psettingsTarget->GetTextValue(settingIDEKey));
	}

	return bResult;
}

COConnection* CIDE::GetConnectionInfo(void)
{
	// the connection info object should be initialized by now
	ASSERT(m_pConnectionInfo);

	return m_pConnectionInfo;
}

BOOL CIDE::RecordHeapUse(void)
{
	const ccBuf = 256;
	char acBuf[ccBuf];
	CStdioFile fileHeapUse;
	UINT nOpenFlags;
	CFileStatus status;
	BOOL bResult = FALSE;

	// get the atom that contains the heap use information from the IDE
	ATOM atomHeapUse = (ATOM)::SendMessage(m_hWnd, m_msgHeapUse, 0, 0L);

	// get the string out of the atom
	if (::GlobalGetAtomName(atomHeapUse, acBuf, ccBuf) != 0) {
		// define open mode for the file
		nOpenFlags = CFile::modeWrite | CFile::modeNoInherit | CFile::typeText | CFile::shareDenyWrite;
		// if the file doesn't exist, create it (MFC doesn't do this for us)
		if (!CFile::GetStatus(m_strHeapUseFilename, status)) {
			nOpenFlags |= CFile::modeCreate;
		}

		// open the file
		if (fileHeapUse.Open(m_strHeapUseFilename, nOpenFlags)) {
			APPLOG("Recording IDE heap use: %s", acBuf);
			// move the file pointer to the end of the file
			fileHeapUse.SeekToEnd();
			// write out the heap use information
			fileHeapUse.WriteString(acBuf);
			// close the file
			fileHeapUse.Close();
			bResult = TRUE;
		}
		else {
			APPLOG("Unable to record IDE heap use: %s", acBuf);
		}
	}

	// delete the atom
	::GlobalDeleteAtom(atomHeapUse);

	return bResult;
}

CString CIDE::GetKeyExt(void)
{
	CString strKeyExt;
	
	CString strCmdLine = m_psettingsTarget->GetTextValue(settingCmdLine);
	strCmdLine.MakeLower();
	int nBeginExt = strCmdLine.Find("-i");
	if (nBeginExt < 0) {
		nBeginExt = strCmdLine.Find("/i");
	}
	// found the beginning
	if (nBeginExt >= 0) {
		// skip -i
		nBeginExt += 2;
		int nEndExt = (strCmdLine.Mid(nBeginExt)).Find(' ') + nBeginExt;
		if (nEndExt < nBeginExt) {
			nEndExt = strCmdLine.GetLength();
		}
		strKeyExt = strCmdLine.Mid(nBeginExt, nEndExt-nBeginExt);
	}
	return strKeyExt;
}

void CIDE::DeleteKeyExt(void)
{
	CString strCmdLine = m_psettingsTarget->GetTextValue(settingCmdLine);
	strCmdLine.MakeLower();
	int nBeginExt = strCmdLine.Find("-i");
	if (nBeginExt < 0) {
		nBeginExt = strCmdLine.Find("/i");
	}
	// found the beginning
	if (nBeginExt >= 0) {
		int nEndExt = (strCmdLine.Mid(nBeginExt)).Find(' ') + nBeginExt;
		if (nEndExt < nBeginExt) {
			nEndExt = strCmdLine.GetLength();
		}
		strCmdLine = strCmdLine.Left(nBeginExt) + strCmdLine.Mid(nEndExt);
	}
	m_psettingsTarget->SetTextValue(settingCmdLine, strCmdLine);
}


CX86IDE::CX86IDE()
: m_psettingsTCPIP(NULL),
  m_psettingsSerial(NULL)
{
}

CX86IDE::~CX86IDE()
{
	delete m_psettingsTCPIP;
	delete m_psettingsSerial;
}


BOOL CX86IDE::Initialize(CToolset::BUILD_TYPE nBuildType, CString strKey)
	
	{
	m_psettingsTCPIP = new CSettings(strKey + "\\" + strIDETargetKey + "\\tcp/ip");
	m_psettingsSerial = new CSettings(strKey + "\\" + strIDETargetKey + "\\serial");
	
	// base class will call initialize settings
	return CIDE::Initialize(nBuildType, strKey);
	}


BOOL CX86IDE::ApplySettings(CSettings* pSettings)
	
	{
	// apply command line overrides for current connection
	if(pSettings->IsDefined(settingConnection))
		m_psettingsTarget->SetIntValue(settingConnection, m_connec.ConnectionTextToInt(pSettings->GetTextValue(settingConnection)));
	if(pSettings->IsDefined(settingRemoteLocalPath))
		m_psettingsTarget->SetTextValue(settingRemoteLocalPath, pSettings->GetTextValue(settingRemoteLocalPath));
	if(pSettings->IsDefined(settingRemoteSharePath))
		m_psettingsTarget->SetTextValue(settingRemoteSharePath, pSettings->GetTextValue(settingRemoteSharePath));

	// call the base class
	CIDE::ApplySettings(pSettings);

	// apply command line overrides for tcp/ip connection
	if(pSettings->IsDefined(settingRemoteIPAddress))
		m_psettingsTCPIP->SetTextValue(settingRemoteIPAddress, pSettings->GetTextValue(settingRemoteIPAddress));
	if(pSettings->IsDefined(settingRemoteIPPassword))
		m_psettingsTCPIP->SetTextValue(settingRemoteIPPassword, pSettings->GetTextValue(settingRemoteIPPassword));

	// apply command line overrides for serial connection
	if(pSettings->IsDefined(settingConnector))
		m_psettingsSerial->SetIntValue(settingConnector, m_connec.ConnectorTextToInt(pSettings->GetTextValue(settingConnector)));
	if(pSettings->IsDefined(settingBaudRate))
		m_psettingsSerial->SetIntValue(settingBaudRate, m_connec.BaudRateTextToInt(pSettings->GetTextValue(settingBaudRate)));
	if(pSettings->IsDefined(settingFlowControl))
		m_psettingsSerial->SetIntValue(settingFlowControl, m_connec.FlowControlTextToInt(pSettings->GetTextValue(settingFlowControl)));
	
	CSettings *psettings[3] = {m_psettingsTarget};

	switch(m_psettingsTarget->GetIntValue(settingConnection))
		{
		case CONNECTION_TCP_IP:
			psettings[1] = m_psettingsTCPIP;
			break;
		case CONNECTION_SERIAL:
			psettings[2] = m_psettingsSerial;
		}

	delete m_pConnectionInfo;
	m_pConnectionInfo = new COConnection(PLATFORM_WIN32_X86, psettings);
	gpConnec = m_pConnectionInfo;

	return TRUE;
	}


BOOL CX86IDE::InitializeSettings(void)
	
	{
	BOOL bResult = TRUE;
	m_psettingsTarget->SetIntValue(settingConnection, CONNECTION_LOCAL);
	m_psettingsTarget->SetTextValue(settingRemoteLocalPath, "");
	m_psettingsTarget->SetTextValue(settingRemoteSharePath, "");

	// call the base class
	bResult &= CIDE::InitializeSettings();

	// initialize tcp/ip default settings
	m_psettingsTCPIP->SetTextValue(settingRemoteIPAddress, "");
	m_psettingsTCPIP->SetTextValue(settingRemoteIPPassword, "");

	// initialize serial default settings
	m_psettingsSerial->SetIntValue(settingConnector, CONNECTOR_COM1);
	m_psettingsSerial->SetIntValue(settingBaudRate, BAUD_RATE_57600);
	m_psettingsSerial->SetIntValue(settingFlowControl, FLOW_CONTROL_HARDWARE);

	// load settings from the registry
	bResult &= m_psettingsTCPIP->ReadRegistry();
	bResult &= m_psettingsSerial->ReadRegistry();

	// write the settings back out to initialize registry
	bResult &= m_psettingsTCPIP->WriteRegistry();
	bResult &= m_psettingsSerial->WriteRegistry();
	
	return bResult;
	}


BOOL CX86IDE::SetConnections(HWND hwndDlg)
	{
	CSettings *psettings[3] = {m_psettingsTarget, m_psettingsTCPIP, m_psettingsSerial};
	m_connec.Connections(hwndDlg, psettings, PLATFORM_WIN32_X86);
	return TRUE;
	}


CWin32sIDE::CWin32sIDE()
: m_psettingsSerial(NULL)
{
}

CWin32sIDE::~CWin32sIDE()
{
	delete m_psettingsSerial;
}


BOOL CWin32sIDE::Initialize(CToolset::BUILD_TYPE nBuildType, CString strKey)
	
	{
	m_psettingsSerial = new CSettings(strKey + "\\" + strIDETargetKey + "\\serial");
	
	// base class will call initialize settings
	return CIDE::Initialize(nBuildType, strKey);
	}


BOOL CWin32sIDE::ApplySettings(CSettings* pSettings)
	
	{
	// apply command line overrides for current connection
	if(pSettings->IsDefined(settingConnection))
		m_psettingsTarget->SetIntValue(settingConnection, m_connec.ConnectionTextToInt(pSettings->GetTextValue(settingConnection)));
	if(pSettings->IsDefined(settingRemoteLocalPath))
		m_psettingsTarget->SetTextValue(settingRemoteLocalPath, pSettings->GetTextValue(settingRemoteLocalPath));
	if(pSettings->IsDefined(settingRemoteSharePath))
		m_psettingsTarget->SetTextValue(settingRemoteSharePath, pSettings->GetTextValue(settingRemoteSharePath));

	// call the base class
	CIDE::ApplySettings(pSettings);

	// apply command line overrides for serial connection
	if(pSettings->IsDefined(settingConnector))
		m_psettingsSerial->SetIntValue(settingConnector, m_connec.ConnectorTextToInt(pSettings->GetTextValue(settingConnector)));
	if(pSettings->IsDefined(settingBaudRate))
		m_psettingsSerial->SetIntValue(settingBaudRate, m_connec.BaudRateTextToInt(pSettings->GetTextValue(settingBaudRate)));
	if(pSettings->IsDefined(settingFlowControl))
		m_psettingsSerial->SetIntValue(settingFlowControl, m_connec.FlowControlTextToInt(pSettings->GetTextValue(settingFlowControl)));
	
	// win32s doesn't support tcp/ip, so psettings[1] is NULL, but we never use it.
	CSettings *psettings[3] = {m_psettingsTarget};
	psettings[2] = m_psettingsSerial;
	delete m_pConnectionInfo;
	m_pConnectionInfo = new COConnection(PLATFORM_WIN32S_X86, psettings);
	gpConnec = m_pConnectionInfo;
	return TRUE;
	}


BOOL CWin32sIDE::InitializeSettings(void)
	
	{
	BOOL bResult = TRUE;
	m_psettingsTarget->SetIntValue(settingConnection, CONNECTION_SERIAL);
	m_psettingsTarget->SetTextValue(settingRemoteLocalPath, "");
	m_psettingsTarget->SetTextValue(settingRemoteSharePath, "");

	// call the base class
	bResult &= CIDE::InitializeSettings();

	// initialize serial default settings
	m_psettingsSerial->SetIntValue(settingConnector, CONNECTOR_COM1);
	m_psettingsSerial->SetIntValue(settingBaudRate, BAUD_RATE_57600);
	m_psettingsSerial->SetIntValue(settingFlowControl, FLOW_CONTROL_HARDWARE);

	// load settings from the registry
	bResult &= m_psettingsSerial->ReadRegistry();

	// write the settings back out to initialize registry
	bResult &= m_psettingsSerial->WriteRegistry();
	
	return bResult;
	}


BOOL CWin32sIDE::SetConnections(HWND hwndDlg)
	{
	// win32s doesn't support tcp/ip, so psettings[1] is NULL, but we never use it.
	CSettings *psettings[3] = {m_psettingsTarget, NULL, m_psettingsSerial};
	m_connec.Connections(hwndDlg, psettings, PLATFORM_WIN32S_X86);
	return TRUE;
	}


C68KIDE::C68KIDE()
: m_psettingsTCPIP(NULL),
  m_psettingsSerial(NULL),
  m_psettingsAT(NULL)
{
}

C68KIDE::~C68KIDE()
{
	delete m_psettingsTCPIP;
	delete m_psettingsSerial;
	delete m_psettingsAT;
}


BOOL C68KIDE::Initialize(CToolset::BUILD_TYPE nBuildType, CString strKey)
	
	{
	m_psettingsTCPIP = new CSettings(strKey + "\\" + strIDETargetKey + "\\tcp/ip");
	m_psettingsSerial = new CSettings(strKey + "\\" + strIDETargetKey + "\\serial");
	m_psettingsAT = new CSettings(strKey + "\\" + strIDETargetKey + "\\appletalk");
	
	// base class will call initialize settings
	return CIDE::Initialize(nBuildType, strKey);
	}


BOOL C68KIDE::ApplySettings(CSettings* pSettings)
	
	{
	// apply command line overrides for current connection
	if(pSettings->IsDefined(settingConnection))
		m_psettingsTarget->SetIntValue(settingConnection, m_connec.ConnectionTextToInt(pSettings->GetTextValue(settingConnection)));
	if(pSettings->IsDefined(settingRemoteLocalPath))
		m_psettingsTarget->SetTextValue(settingRemoteLocalPath, pSettings->GetTextValue(settingRemoteLocalPath));

	// call the base class
	CIDE::ApplySettings(pSettings);

	// apply command line overrides for tcp/ip connection
	if(pSettings->IsDefined(settingRemoteIPAddress))
		m_psettingsTCPIP->SetTextValue(settingRemoteIPAddress, pSettings->GetTextValue(settingRemoteIPAddress));
	if(pSettings->IsDefined(settingRemoteIPPassword))
		m_psettingsTCPIP->SetTextValue(settingRemoteIPPassword, pSettings->GetTextValue(settingRemoteIPPassword));

	// apply command line overrides for serial connection
	if(pSettings->IsDefined(settingConnector))
		m_psettingsSerial->SetIntValue(settingConnector, m_connec.ConnectorTextToInt(pSettings->GetTextValue(settingConnector)));
	if(pSettings->IsDefined(settingBaudRate))
		m_psettingsSerial->SetIntValue(settingBaudRate, m_connec.BaudRateTextToInt(pSettings->GetTextValue(settingBaudRate)));
	if(pSettings->IsDefined(settingDataBits))
		m_psettingsSerial->SetIntValue(settingDataBits, m_connec.DataBitsTextToInt(pSettings->GetTextValue(settingDataBits)));
	if(pSettings->IsDefined(settingParity))
		m_psettingsSerial->SetIntValue(settingParity, m_connec.ParityTextToInt(pSettings->GetTextValue(settingParity)));
	if(pSettings->IsDefined(settingStopBits))
		m_psettingsSerial->SetIntValue(settingStopBits, m_connec.StopBitsTextToInt(pSettings->GetTextValue(settingStopBits)));
	
	// apply command line overrides for appletalk connection
	if(pSettings->IsDefined(settingRemoteMachName))
		m_psettingsAT->SetTextValue(settingRemoteMachName, pSettings->GetTextValue(settingRemoteMachName));
	if(pSettings->IsDefined(settingRemoteZone))
		m_psettingsAT->SetTextValue(settingRemoteZone, pSettings->GetTextValue(settingRemoteZone));
	if(pSettings->IsDefined(settingRemoteATPassword))
		m_psettingsAT->SetTextValue(settingRemoteATPassword, pSettings->GetTextValue(settingRemoteATPassword));

	CSettings *psettings[4] = {m_psettingsTarget};

	switch(m_psettingsTarget->GetIntValue(settingConnection))
		{
		case CONNECTION_TCP_IP:
			psettings[1] = m_psettingsTCPIP;
			break;
		case CONNECTION_SERIAL:
			psettings[2] = m_psettingsSerial;
			break;
		case CONNECTION_APPLETALK:
			psettings[3] = m_psettingsAT;
		}

	delete m_pConnectionInfo;
	m_pConnectionInfo = new COConnection(PLATFORM_MAC_68K, psettings);
	gpConnec = m_pConnectionInfo;

	return TRUE;
	}


BOOL C68KIDE::InitializeSettings(void)

	{
	BOOL bResult = TRUE;
	m_psettingsTarget->SetIntValue(settingConnection, CONNECTION_TCP_IP);
	m_psettingsTarget->SetTextValue(settingRemoteLocalPath, "");

	// call the base class
	bResult &= CIDE::InitializeSettings();

	// cmd line
	m_psettingsTarget->SetTextValue(settingCmdLine, "-y0 -noidelog -nocmdlog");

	// initialize tcp/ip default settings
	m_psettingsTCPIP->SetTextValue(settingRemoteIPAddress, "");
	m_psettingsTCPIP->SetTextValue(settingRemoteIPPassword, "");

	// initialize serial default settings
	m_psettingsSerial->SetIntValue(settingConnector, CONNECTOR_COM1);
	m_psettingsSerial->SetIntValue(settingBaudRate, BAUD_RATE_57600);
	m_psettingsSerial->SetIntValue(settingDataBits, DATA_BITS_8);
	m_psettingsSerial->SetIntValue(settingParity, PARITY_NONE);
	m_psettingsSerial->SetIntValue(settingStopBits, STOP_BITS_1);

	// initialize appletalk default settings
	m_psettingsAT->SetTextValue(settingRemoteMachName, "");
	m_psettingsAT->SetTextValue(settingRemoteZone, "");
	m_psettingsAT->SetTextValue(settingRemoteATPassword, "");

	// load settings from the registry
	bResult &= m_psettingsTCPIP->ReadRegistry();
	bResult &= m_psettingsSerial->ReadRegistry();
	bResult &= m_psettingsAT->ReadRegistry();

	// write the settings back out to initialize registry
	bResult &= m_psettingsTCPIP->WriteRegistry();
	bResult &= m_psettingsSerial->WriteRegistry();
	bResult &= m_psettingsAT->WriteRegistry();

	return bResult;
	}


BOOL C68KIDE::SetConnections(HWND hwndDlg)
	{
	CSettings *psettings[4] = {m_psettingsTarget, m_psettingsTCPIP, m_psettingsSerial, m_psettingsAT};
	m_connec.Connections(hwndDlg, psettings, PLATFORM_MAC_68K);
	return TRUE;
	}


CPMacIDE::CPMacIDE()
: m_psettingsTCPIP(NULL),
  m_psettingsSerial(NULL),
  m_psettingsAT(NULL)
{
}

CPMacIDE::~CPMacIDE()
{
	delete m_psettingsTCPIP;
	delete m_psettingsSerial;
	delete m_psettingsAT;
}


BOOL CPMacIDE::Initialize(CToolset::BUILD_TYPE nBuildType, CString strKey)
	
	{
	m_psettingsTCPIP = new CSettings(strKey + "\\" + strIDETargetKey + "\\tcp/ip");
	m_psettingsSerial = new CSettings(strKey + "\\" + strIDETargetKey + "\\serial");
	m_psettingsAT = new CSettings(strKey + "\\" + strIDETargetKey + "\\appletalk");

	// base class will call initialize settings
	return CIDE::Initialize(nBuildType, strKey);
	}


BOOL CPMacIDE::ApplySettings(CSettings* pSettings)
	
	{
	// apply command line overrides for current connection
	if(pSettings->IsDefined(settingConnection))
		m_psettingsTarget->SetIntValue(settingConnection, m_connec.ConnectionTextToInt(pSettings->GetTextValue(settingConnection)));
	if(pSettings->IsDefined(settingRemoteLocalPath))
		m_psettingsTarget->SetTextValue(settingRemoteLocalPath, pSettings->GetTextValue(settingRemoteLocalPath));

	// call the base class
	CIDE::ApplySettings(pSettings);

	// apply command line overrides for tcp/ip connection
	if(pSettings->IsDefined(settingRemoteIPAddress))
		m_psettingsTCPIP->SetTextValue(settingRemoteIPAddress, pSettings->GetTextValue(settingRemoteIPAddress));
	if(pSettings->IsDefined(settingRemoteIPPassword))
		m_psettingsTCPIP->SetTextValue(settingRemoteIPPassword, pSettings->GetTextValue(settingRemoteIPPassword));

	// apply command line overrides for serial connection
	if(pSettings->IsDefined(settingConnector))
		m_psettingsSerial->SetIntValue(settingConnector, m_connec.ConnectorTextToInt(pSettings->GetTextValue(settingConnector)));
	
	// apply command line overrides for appletalk connection
	if(pSettings->IsDefined(settingRemoteMachName))
		m_psettingsAT->SetTextValue(settingRemoteMachName, pSettings->GetTextValue(settingRemoteMachName));
	if(pSettings->IsDefined(settingRemoteZone))
		m_psettingsAT->SetTextValue(settingRemoteZone, pSettings->GetTextValue(settingRemoteZone));
	if(pSettings->IsDefined(settingRemoteATPassword))
		m_psettingsAT->SetTextValue(settingRemoteATPassword, pSettings->GetTextValue(settingRemoteATPassword));

	CSettings *psettings[4] = {m_psettingsTarget};

	switch(m_psettingsTarget->GetIntValue(settingConnection))
		{
		case CONNECTION_TCP_IP:
			psettings[1] = m_psettingsTCPIP;
			break;
		case CONNECTION_SERIAL:
			psettings[2] = m_psettingsSerial;
			break;
		case CONNECTION_APPLETALK:
			psettings[3] = m_psettingsAT;
		}

	delete m_pConnectionInfo;
	m_pConnectionInfo = new COConnection(PLATFORM_MAC_PPC, psettings);
	gpConnec = m_pConnectionInfo;

	return TRUE;
	}


BOOL CPMacIDE::InitializeSettings(void)

	{
	BOOL bResult = TRUE;
	m_psettingsTarget->SetIntValue(settingConnection, CONNECTION_TCP_IP);
	m_psettingsTarget->SetTextValue(settingRemoteLocalPath, "");

	// call the base class
	bResult &= CIDE::InitializeSettings();

	// cmd line
	m_psettingsTarget->SetTextValue(settingCmdLine, "-y0 -noidelog -nocmdlog");

	// initialize tcp/ip default settings
	m_psettingsTCPIP->SetTextValue(settingRemoteIPAddress, "");
	m_psettingsTCPIP->SetTextValue(settingRemoteIPPassword, "");

	// initialize serial default settings
	m_psettingsSerial->SetIntValue(settingConnector, CONNECTOR_COM1);

	// initialize appletalk default settings
	m_psettingsAT->SetTextValue(settingRemoteMachName, "");
	m_psettingsAT->SetTextValue(settingRemoteZone, "");
	m_psettingsAT->SetTextValue(settingRemoteATPassword, "");

	// load settings from the registry
	bResult &= m_psettingsTCPIP->ReadRegistry();
	bResult &= m_psettingsSerial->ReadRegistry();
	bResult &= m_psettingsAT->ReadRegistry();

	// write the settings back out to initialize registry
	bResult &= m_psettingsTCPIP->WriteRegistry();
	bResult &= m_psettingsSerial->WriteRegistry();
	bResult &= m_psettingsAT->WriteRegistry();

	return bResult;
	}


BOOL CPMacIDE::SetConnections(HWND hwndDlg)
	{
	CSettings *psettings[4] = {m_psettingsTarget, m_psettingsTCPIP, m_psettingsSerial, m_psettingsAT};
	m_connec.Connections(hwndDlg, psettings, PLATFORM_MAC_PPC);
	return TRUE;
	}


CMIPSIDE::CMIPSIDE()
{
}

CMIPSIDE::~CMIPSIDE()
{
}

CAlphaIDE::CAlphaIDE()
{
}

CAlphaIDE::~CAlphaIDE()
{
}

CPowerPCIDE::CPowerPCIDE()
{
}

CPowerPCIDE::~CPowerPCIDE()
{
}

///////////////////////////////////////////////////////////////////////////////
//	DLL support

static AFX_EXTENSION_MODULE extensionDLL = { NULL, NULL };

extern "C" __declspec(dllexport) int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("IDE DLL Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(extensionDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(extensionDLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("IDE DLL Terminating!\n");
		// Terminate the library before destructors are called
		AfxTermExtensionModule(extensionDLL);
	}
	return 1;   // ok

	UNREFERENCED_PARAMETER(lpReserved);
}

BOOL CIDE::SetEnvironmentVar(LPCSTR pszEnvVar, LPCSTR pszValue)
{
	CString strEnvVar = pszEnvVar;

	// upper case the variable name
	strEnvVar.MakeUpper();
	m_mapEnv.SetAt(strEnvVar, pszValue);
	return TRUE;
}

BOOL CIDE::GetEnvironmentVar(LPCSTR pszEnvVar, CString &strValue)
{
	return 	m_mapEnv.Lookup(pszEnvVar, strValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ide.rc
//
#define IDS_ERROR_CANT_OPEN             1
#define IDD_TargetIDE                   101
#define IDD_DIALOG_68K_SERIAL           102
#define IDD_DIALOG_AT                   107
#define IDD_DIALOG_CONNECTION           108
#define IDD_DIALOG_IP                   109
#define IDD_DIALOG_PMAC_SERIAL          110
#define IDD_DIALOG_WIN32_SERIAL         111
#define IDC_IDENewApp                   1000
#define IDC_COMBO_68K_CONNECTOR         1000
#define IDE_IDEFilename                 1001
#define IDC_COMBO_68K_BAUD_RATE         1001
#define IDC_COMBO_DATA_BITS             1002
#define IDC_IDEPersist                  1002
#define IDC_IDEClose                    1003
#define IDC_BUTTON_SETTINGS             1003
#define IDC_COMBO_PARITY                1003
#define IDC_IDEDebugProcess             1004
#define IDC_LIST_CONNECTION             1004
#define IDC_COMBO_STOP_BITS             1004
#define IDE_IDECmdLine                  1005
#define IDC_STATIC_AT_PASSWORD          1005
#define IDE_IDEWorkDir                  1006
#define IDC_STATIC_WIN32_BAUD_RATE      1006
#define IDE_IDEKey                      1007
#define IDC_EDIT_AT_NAME                1007
#define IDC_STATIC_68K_CONNECTOR        1007
#define IDC_EDIT_ZONE                   1008
#define IDC_STATIC_68K_BAUD_RATE        1008
#define IDC_IDEIgnoreASSERT             1008
#define IDC_EDIT_AT_PASSWORD            1009
#define IDC_STATIC_DATA_BITS            1009
#define IDC_IDEBreakASSERT              1009
#define IDC_IDEUseKey                   1010
#define IDC_EDIT_IP_NAME                1010
#define IDC_STATIC_PARITY               1010
#define IDS_IDEKeyText                  1011
#define IDC_EDIT_IP_PASSWORD            1011
#define IDC_STATIC_STOP_BITS            1011
#define IDC_EDIT_LOCAL_PATH             1012
#define IDB_IDEConnections              1013
#define IDC_EDIT_SHARE_PATH             1013
#define IDC_STATIC_LOCAL_PATH           1014
#define IDC_STATIC_SHARE_PATH           1015
#define IDC_COMBO_WIN32_CONNECTOR       1017
#define IDC_COMBO_BAUD_RATE             1018
#define IDC_COMBO_WIN32_BAUD_RATE       1018
#define IDC_RADIO_HARDWARE              1021
#define IDC_RADIO_XONXOFF               1022
#define IDC_COMBO_MAC_CONNECTOR         1024
#define IDC_COMBO_PMAC_CONNECTOR        1024
#define IDC_STATIC_CONNECTION           -1
#define IDC_STATIC_ZONE                 -1
#define IDC_STATIC_PASSWORD             -1
#define IDC_STATIC_BAUD_RATE            -1
#define IDC_STATIC_FLOW_CONTROL         -1
#define IDC_STATIC_MAC_CONNECTOR        -1
#define IDC_STATIC_AT_NAME              -1
#define IDC_STATIC_IP_NAME              -1
#define IDC_STATIC_WIN32_CONNECTOR      -1
#define IDC_STATIC_PMAC_CONNECTOR       -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1016
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\registry.h ===
#ifndef __REGISTRY_H__
#define __REGISTRY_H__

#ifndef __AFXWIN_H__
	#error include 'afxwin.h' before including this file
#endif

#ifdef _CONSOLE
	class CCmdLine
	{
	public:
		CCmdLine( int argc, char* argv[] );
		BOOL GetTextSwitch( LPCSTR szSwitch, CString& strValue, LPCSTR szDefault = "" );
		int GetIntSwitch( LPCSTR szSwitch, int nDefault = 0 );
		BOOL GetBooleanSwitch( LPCSTR szSwitch, BOOL bDefault = FALSE );
	protected:
		int FindNextSwitch( LPCSTR szCL );
		int ParseSwitch( LPCSTR szCL, CString &strA, CString &strV );
		BOOL ParseBoolean( LPCSTR szText, BOOL bDefault );
	private:
		CMapStringToString m_SwitchMap;
	};
#endif

void ReplaceKey( const CString& strRestoreFile );
void DeleteKey(void);
inline const CString GetRegistryKeyName( void );
void SushiRestoreKey( HKEY hKey, const CString& strRestoreFile );
BOOL IsNTKey( const CString& strRestoreFile );
void DeleteSubKeys( HKEY hKey, const CString& strKeyName );
void DeleteValues( HKEY hKey, const CString& strKeyName );
inline HKEY AddSubKey( HKEY hKey, LPCTSTR szName );
inline void AddValue( HKEY hKey, LPTSTR szName, DWORD dwType, CONST BYTE* pbData, DWORD cbData );
void RestoreKey( HKEY hKey, const CString& strRestoreFile );

// specify the extension to the key
extern CString gstrKeyExt;

#endif //__REGISTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\coauto.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  COAUTO.CPP
//
//  Created by:            Date:
//      MichMa                  9/16/98
//
//  Description:
//      Implementation of the COAuto class
//

#include "stdafx.h"
#include "coauto.h"
#include "guiv1.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

#pragma warning (disable : 4069)


// BEGIN_HELP_COMMENT
// Function: BOOL COAuto::VerifyAutoInfo(CAuto Auto)
// Description: Verify that an expression of the specified name, value, type, and state exists in the debugger's auto list.
// Return: A Boolean value that specifies whether the verification was sucessful (TRUE) or not (FALSE).
// Param: Auto A CAuto object containing the name, value, type, and state of the expression to verify.
// END_HELP_COMMENT
BOOL COAuto::VerifyAutoInfo(CAuto Auto)

{
	const char* const THIS_FUNCTION = "COAuto::VerifyAutoInfo";

	// activate the variables window.
	// TODO(michma): UIVariables::Activate isn't returning TRUE even though the window gets activated.
	/*if(!m_uivar.Activate())
	{
		LOG->RecordInfo("ERROR in %s: can't activate variables window.", THIS_FUNCTION);
		return FALSE;
	}
	*/
	m_uivar.Activate();

	// select the auto.
	if(!m_uivar.SelectAuto(Auto.m_strName))
	{
		LOG->RecordInfo("ERROR in %s: can't select auto \"%s\".", THIS_FUNCTION, Auto.m_strName);
		return FALSE;
	}
	
	// stores the auto's actual and expected information.
	EXPR_INFO ActualAutoInfo, ExpectedAutoInfo;
	m_coee.FillExprInfo(ExpectedAutoInfo, Auto.m_ExprState, Auto.m_strType, Auto.m_strName, Auto.m_strValue);

	// get the fields of the auto from the variables window.
	if(m_uivar.GetAllFields(&ActualAutoInfo, ROW_CURRENT) != ERROR_SUCCESS)
	{
		LOG->RecordInfo("ERROR in %s: couldn't get fields of auto \"%s\".", THIS_FUNCTION, Auto.m_strName);
		return FALSE;
	}

	// return focus back to source (if it's there).
	MST.DoKeys("{ESC}");
	// compare the actual auto info with the expected auto info.
	return m_coee.CompareExprInfo(&ActualAutoInfo, &ExpectedAutoInfo);
}


// BEGIN_HELP_COMMENT
// Function: BOOL COAuto::VerifyAutoInfo(LPCSTR szName, LPCSTR szValue,  LPCSTR szType, EXPR_STATE ExprState)
// Description: Verify that an expression of the specified name, value, type, and state exists debugger's auto list.
// Return: A Boolean value that specifies whether the verification was sucessful (TRUE) or not (FALSE).
// Param: szName - A string specifying the name of the expression.
// Param: szValue - A string specifying the value of the expression.
// Param: szType - A string specifying the type of the expression.
// Param: ExprState - An EXPR_STATE value specifying the expansion state of the expression (NOT_EXPANABLE, COLLAPSED, EXPANDED).
// END_HELP_COMMENT
BOOL COAuto::VerifyAutoInfo(LPCSTR szName, LPCSTR szValue,  LPCSTR szType, EXPR_STATE ExprState)
{
	CAuto Auto;
	Auto.m_ExprState = ExprState;
	Auto.m_strType = szType;
	Auto.m_strName = szName;
	Auto.m_strValue = szValue;
	return VerifyAutoInfo(Auto);
}


// BEGIN_HELP_COMMENT
// Function: BOOL COAuto::AutoDoesNotExist(LPCSTR szName)
// Description: Verify that an expression of the specified name does not exist in the debugger's auto list.
// Return: A Boolean value that specifies whether the verification was sucessful (TRUE) or not (FALSE).
// Param: szName A pointer to a string that contains the name of the expression to check for.
// END_HELP_COMMENT
BOOL COAuto::AutoDoesNotExist(LPCSTR szName)

{
	const char* const THIS_FUNCTION = "COAuto::AutoDoesNotExist";

	// activate the variables window.
	// TODO(michma): UIVariables::Activate isn't returning TRUE even though the window gets activated.
	/*if(!m_uivar.Activate())
	{
		LOG->RecordInfo("ERROR in %s: can't activate variables window.", THIS_FUNCTION);
		return FALSE;
	}
	*/
	m_uivar.Activate();
	
	BOOL bResult = m_uivar.SelectAuto(szName);
	// return focus back to source (if it's there).
	MST.DoKeys("{ESC}");
	return !bResult;
}


// BEGIN_HELP_COMMENT
// Function: BOOL COAuto::AutoCountIs(int intAutoCount)
// Description: Verify that the debugger has an accurate count of the expressions in its auto list.
// Return: A Boolean value that specifies whether the verification was sucessful (TRUE) or not (FALSE).
// Param: intAutoCount An integer specifying the expected count of items in the auto list.
// END_HELP_COMMENT
BOOL COAuto::AutoCountIs(int intAutoCount)

{
	const char* const THIS_FUNCTION = "COAuto::AutoCountIs";

	// activate the variables window.
	// TODO(michma): UIVariables::Activate isn't returning TRUE even though the window gets activated.
	/*if(!m_uivar.Activate())
	{
		LOG->RecordInfo("ERROR in %s: can't activate variables window.", THIS_FUNCTION);
		return FALSE;
	}
	*/
	m_uivar.Activate();

	int intActualAutoCount = m_uivar.GetAutoCount();
	LOG->RecordInfo("%s: actual auto count is %d.", THIS_FUNCTION, intActualAutoCount);
	// return focus back to source (if it's there).
	MST.DoKeys("{ESC}");
	return intActualAutoCount == intAutoCount;
}


// BEGIN_HELP_COMMENT
// Function: BOOL COAuto::SetAutoValue(LPCSTR szName, LPCSTR szValue)
// Description: Sets a value for the specified variable in the debugger's auto list.
// Return: A Boolean value that specifies whether the verification was sucessful (TRUE) or not (FALSE).
// Param: szName A string specifying the name of the auto variable for which to assign a value.
// Param: szValue A string specifying the value to be assigned to the auto variable.
// END_HELP_COMMENT
BOOL COAuto::SetAutoValue(LPCSTR szName, LPCSTR szValue)

{
	const char* const THIS_FUNCTION = "COAuto::SetAutoValue";

	// activate the variables window.
	// TODO(michma): UIVariables::Activate isn't returning TRUE even though the window gets activated.
	/*if(!m_uivar.Activate())
	{
		LOG->RecordInfo("ERROR in %s: can't activate variables window.", THIS_FUNCTION);
		return FALSE;
	}
	*/
	m_uivar.Activate();

	// select the auto to change.
	if(!m_uivar.SelectAuto(szName))
	{
		LOG->RecordInfo("ERROR in %s: can't select auto \"%s\".", THIS_FUNCTION, szName);
		return FALSE;
	}

	// Change the auto value
	if(ERROR_SUCCESS != m_uivar.SetValue(szValue, ROW_CURRENT))
	{
		LOG->RecordInfo("ERROR in %s: can't set the value of auto \"%s\".", THIS_FUNCTION, szName);
		return FALSE;
	}
	
	// return focus back to source (if it's there).
	MST.DoKeys("{ESC}");
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL COAuto::VerifyReturnValue(LPCSTR szName, LPCSTR szValue,  LPCSTR szType, EXPR_STATE ExprState)
// Description: Verify that a return value of the specified function name, value, type, and state exists debugger's auto list.
// Return: A Boolean value that specifies whether the verification was sucessful (TRUE) or not (FALSE).
// Param: szName - A string specifying the name of the function that returned.
// Param: szValue - A string specifying the value of the return.
// Param: szType - A string specifying the type of the return value.
// Param: ExprState - An EXPR_STATE value specifying the expansion state of the return value (NOT_EXPANABLE, COLLAPSED, EXPANDED).
// END_HELP_COMMENT
BOOL COAuto::VerifyReturnValue(LPCSTR szName, LPCSTR szValue,  LPCSTR szType, EXPR_STATE ExprState)
{
	CAuto Auto;
	Auto.m_ExprState = ExprState;
	Auto.m_strType = szType;
	Auto.m_strName = (CString)szName + " " + GetLocString(IDSS_RETURNED);
	Auto.m_strValue = szValue;
	return VerifyAutoInfo(Auto);
}

#pragma warning (default : 4069)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\cobp.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  COBP.CPP
//
//  Created by :            Date :
//      MichMa                  1/13/94
//
//  Description :
//      Implementation of the COBreakpoints class
//
		   
#include "stdafx.h"
#include "cobp.h"
#include "codebug.h"
#include "..\shl\uwbframe.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


// BEGIN_HELP_COMMENT
// Function: bp* COBreakpoints::SetBreakpoint(int line, LPCSTR source, int passcount /* 0 */)
// Description: Set a breakpoint on the given line in the specified source file with the given pass count.
// Return: A pointer to a bp object that is used as a handle to the breakpoint. Store this pointer to reference the breakpoint later.
// Param: line An integer that contains the line to set the breakpoint on.
// Param: source A pointer to a string that contains the name of the source file to set the breakpoint in. NULL means use the current file.
// Param: passcount An integer that contains the number of times to pass this breakpoint before breaking. (Default value is 0.)
// END_HELP_COMMENT
bp *COBreakpoints::SetBreakpoint(int line, LPCSTR source, int passcount /* 0 */)
	{
	char string[12];
	CString cstr;
	if (source)
		cstr = cstr + "{," + source + ",}";
	cstr = cstr + "." + _itoa(line, string, 10);
	return SetBreakpoint(cstr, passcount);
	}


// BEGIN_HELP_COMMENT
// Function: bp* COBreakpoints::SetBreakpoint(LPCSTR function, LPCSTR source, int passcount /* 0 */)
// Description: Set a breakpoint on the given function in the specified source file with the given pass count.
// Return: A pointer to a bp object that is used as a handle to the breakpoint. Store this pointer to reference the breakpoint later.
// Param: function A pointer to a string that contains the name of the function to set the breakpoint on.
// Param: source A pointer to a string that contains the name of the source file to set the breakpoint in. NULL means use the current file.
// Param: passcount An integer that contains the number of times to pass this breakpoint before breaking. (Default value is 0.)
// END_HELP_COMMENT
bp *COBreakpoints::SetBreakpoint(LPCSTR function, LPCSTR source, int passcount /* 0 */)
	{
	CString cstr;
	if (source)
		cstr = cstr + "{," + source + ",}";
	cstr = cstr + function;
	return SetBreakpoint(cstr, passcount);
	}


// BEGIN_HELP_COMMENT
// Function: bp* COBreakpoints::SetBreakpoint(int line, LPCSTR expression, int option, int length, int passcount /* 0 */)
// Description: Set an expression breakpoint on the given line with the given pass count.
// Return: A pointer to a bp object that is used as a handle to the breakpoint. Store this pointer to reference the breakpoint later.
// Param: line An integer that contains the line to set the breakpoint on.
// Param: expression A pointer to a string that contains the expression to use in the breakpoint. Expression is specified by the following form: {function name, source filename, EXE filename} expression.
// Param: option A value that specifies the type of expression breakpoint to set: COBP_TYPE_IF_EXP_TRUE, COBP_TYPE_IF_EXP_CHANGED.
// Param: length An integer that contains the number of elements to watch.
// Param: passcount An integer that contains the number of times to pass this breakpoint before breaking. (Default value is 0.)
// END_HELP_COMMENT
bp *COBreakpoints::SetBreakpoint(int line, LPCSTR expression, int option, int length, int passcount /* 0 */)
	{
	char string[12];
	CString cstr;
	cstr = cstr + "." + _itoa(line, string, 10);
	return SetBreakOnExpr(cstr, expression, option, length, passcount);
	}


// BEGIN_HELP_COMMENT
// Function: bp* COBreakpoints::SetBreakpoint(int line, LPCSTR source, LPCSTR expression, int option, int length, int passcount /* 0 */)
// Description: Set an expression breakpoint on the given line in the specified source file with the given pass count.
// Return: A pointer to a bp object that is used as a handle to the breakpoint. Store this pointer to reference the breakpoint later.
// Param: line An integer that contains the line to set the breakpoint on.
// Param: source A pointer to a string that contains the name of the source file to set the breakpoint in. NULL means use the current file.
// Param: expression A pointer to a string that contains the expression to use in the breakpoint. Expression is specified by the following form: {function name, source filename, EXE filename} expression.
// Param: option A value that specifies the type of expression breakpoint to set: COBP_TYPE_IF_EXP_TRUE, COBP_TYPE_IF_EXP_CHANGED.
// Param: length An integer that contains the number of elements to watch.
// Param: passcount An integer that contains the number of times to pass this breakpoint before breaking. (Default value is 0.)
// END_HELP_COMMENT
bp *COBreakpoints::SetBreakpoint(int line, LPCSTR source, LPCSTR expression, int option, int length, int passcount /* 0 */)
	{
	char string[12];								
	CString cstr;
	if (source)
		cstr = cstr + "{," + source + ",}";
	cstr = cstr + _itoa(line, string, 10);
	return SetBreakOnExpr(cstr, expression, option, length, passcount);
	}


// BEGIN_HELP_COMMENT
// Function: bp* COBreakpoints::SetBreakpoint(LPCSTR function, LPCSTR expression, int option, int length, int passcount /* 0 */)
// Description: Set an expression breakpoint on the given function with the given pass count.
// Return: A pointer to a bp object that is used as a handle to the breakpoint. Store this pointer to reference the breakpoint later.
// Param: function A pointer to a string that contains the name of the function to set the breakpoint on.
// Param: expression A pointer to a string that contains the expression to use in the breakpoint. Expression is specified by the following form: {function name, source filename, EXE filename} expression.
// Param: option A value that specifies the type of expression breakpoint to set: COBP_TYPE_IF_EXP_TRUE, COBP_TYPE_IF_EXP_CHANGED.
// Param: length An integer that contains the number of elements to watch.
// Param: passcount An integer that contains the number of times to pass this breakpoint before breaking. (Default value is 0.)
// END_HELP_COMMENT
bp *COBreakpoints::SetBreakpoint(LPCSTR function, LPCSTR expression, int option, int length, int passcount /* 0 */)
	{
	return SetBreakOnExpr(function, expression, option, length, passcount);
	}


// BEGIN_HELP_COMMENT
// Function: bp* COBreakpoints::SetBreakpoint(LPCSTR function, LPCSTR source, LPCSTR expression, int option, int length, int passcount /* 0 */)
// Description: Set an expression breakpoint on the given function in the specified source file with the given pass count.
// Return: A pointer to a bp object that is used as a handle to the breakpoint. Store this pointer to reference the breakpoint later.
// Param: function A pointer to a string that contains the name of the function to set the breakpoint on.
// Param: source A pointer to a string that contains the name of the source file to set the breakpoint in. NULL means use the current file.
// Param: expression A pointer to a string that contains the expression to use in the breakpoint. Expression is specified by the following form: {function name, source filename, EXE filename} expression.
// Param: option A value that specifies the type of expression breakpoint to set: COBP_TYPE_IF_EXP_TRUE, COBP_TYPE_IF_EXP_CHANGED.
// Param: length An integer that contains the number of elements to watch.
// Param: passcount An integer that contains the number of times to pass this breakpoint before breaking. (Default value is 0.)
// END_HELP_COMMENT
bp *COBreakpoints::SetBreakpoint(LPCSTR function, LPCSTR source, LPCSTR expression, int option, int length, int passcount /* 0 */)
	{
	CString cstr;
	if (source)
		cstr = cstr + "{," + source + ",}";
	cstr = cstr + function;
	return SetBreakOnExpr(cstr, expression, option, length, passcount);
	}


// BEGIN_HELP_COMMENT
// Function: bp* COBreakpoints::SetBreakpoint(LPCSTR expression, int option, int length, int passcount /* 0 */)
// Description: Set an expression breakpoint with the given pass count.
// Return: A pointer to a bp object that is used as a handle to the breakpoint. Store this pointer to reference the breakpoint later.
// Param: expression A pointer to a string that contains the expression to use in the breakpoint. Expression is specified by the following form: {function name, source filename, EXE filename} expression.
// Param: option A value that specifies the type of expression breakpoint to set: COBP_TYPE_IF_EXP_TRUE, COBP_TYPE_IF_EXP_CHANGED.
// Param: length An integer that contains the number of elements to watch.
// Param: passcount An integer that contains the number of times to pass this breakpoint before breaking. (Default value is 0.)
// END_HELP_COMMENT
bp *COBreakpoints::SetBreakpoint(LPCSTR expression, int option, int length, int passcount /* 0 */)
	{
	return SetBreakOnExpr(expression, option, length, passcount);
	}

// BEGIN_HELP_COMMENT
// Function: bp* COBreakpoints::SetBreakpoint(LPCSTR location /* NULL */, int passcount /* 0 */)
// Description: Set breakpoint at the given location with the given pass count.
// Return: A pointer to a bp object that is used as a handle to the breakpoint. Store this pointer to reference the breakpoint later.
// Param: location A pointer to a string that specifies the location of the breakpoint. Location is specified by the following form: {function name, source file name, EXE filename} .line. NULL means set the breakpoint at the current source location. (Default value is NULL.)
// Param: passcount An integer that contains the number of times to pass this breakpoint before breaking. (Default value is 0.)
// END_HELP_COMMENT
bp *COBreakpoints::SetBreakpoint(LPCSTR location /* NULL */, int passcount /* 0 */)
	{
	char string[12];
	CString cstr;
//	int line;

	if (!location)										 // F9 if line=0
	{
		if (!UIWB.ToggleBreakpoint()) return NULL;  // REVIEW what if we toggle off
		return (AddBPToList());
	}
//	below doesn't work msvc won't let it add the bp!
//	if (!location)                                       //use current line if line=0
//		line = UIWB.GetEditorCurPos(GECP_LINE);
//		cstr = "." + _itoa(line, string, 10);

// REVIEW(briancr): this is obsolete code
//	if(!(uibp = UIWB.Breakpoints())) return NULL;			
	if (!uibp.Activate()) {
		return NULL;
	}

//  below doesn't work default location somehow cleared!!!!
//	if (!locaion)                                       //use defaults if line=0
//		return AddBPandClose();
	cstr = location;
//	if(!uibp.SetType(UIBP_TYPE_LOC)) return FailAndClose();
	if(!uibp.SetLocation(cstr)) return FailAndClose();
	if(passcount) {	
		if(!uibp.SetPassCount(_itoa(passcount, string, 10))) return FailAndClose();
	}
	return AddBPandClose();
	}


// BEGIN_HELP_COMMENT
// Function: bp* COBreakpoints::SetAmbiguousBreakpoint(LPCSTR location, int ambiguity)
// Description: Set breakpoint at the given ambiguous location, resolving the ambiguity as specified.
// Return: A pointer to a bp object that is used as a handle to the breakpoint. Store this pointer to reference the breakpoint later.
// Param: location A pointer to a string that specifies the location of the breakpoint (ex. a function, or a context string).
// Param: ambiguity An integer that specifies which function to select from the ambiguity list
// END_HELP_COMMENT
bp *COBreakpoints::SetAmbiguousBreakpoint(LPCSTR location, int ambiguity)

{
	if (!uibp.Activate())
		return NULL;

	uibp.SetLocation(location); 
	MST.WButtonClick(GetLabel(UIBP_OK_BTN));

	// wait for the ra dlg to be displayed
	if(!MST.WFndWndWait(GetLocString(IDSS_RESOLVE_AMBIGUITY_TITLE), FW_DEFAULT, 5))
	{
		LOG->RecordInfo("ERROR: Resolve Ambiguity dlg not found");
		return FailAndClose();
	}

	// make sure the dlg has enough entries in it.
	if(MST.WListCount("") < ambiguity)
	{
		LOG->RecordInfo("ERROR: Number of entries in RA dlg is less than %d", ambiguity);
		return FailAndClose();
	}
	
	// choose the source line entry from the list box in the rsla dlg
	for(int i = 1; i < ambiguity; i++)
		MST.DoKeys("{DOWN}");
	
	// ok the dlg
	MST.DoKeys("{ENTER}");
	
	// wait for the ra dlg to be displayed
	if(!MST.WFndWndWait(GetLocString(IDSS_RESOLVE_AMBIGUITY_TITLE), FW_DEFAULT | FW_NOEXIST, 5))
	{
		LOG->RecordInfo("ERROR: Resolve Ambiguity dlg still active");
		return FailAndClose();
	}

	return AddBPToList();
}


// BEGIN_HELP_COMMENT
// Function: bp* COBreakpoints::SetBreakOnExpr(LPCSTR location, LPCSTR expression, int expr_type, int length /* 1 */, int passcount /* 0 */)
// Description: Set an expression breakpoint at the given location with the given pass count.
// Return: A pointer to a bp object that is used as a handle to the breakpoint. Store this pointer to reference the breakpoint later.
// Param: location A pointer to a string that specifies the location of the breakpoint. Location is specified by the following form: {function name, source filename, EXE filename} .line.
// Param: expression A pointer to a string that contains the expression to use in the breakpoint. Expression is specified by the following form: {function name, source filename, EXE filename} expression.
// Param: expr_type A value that specifies the type of expression breakpoint to set: COBP_TYPE_IF_EXP_TRUE, COBP_TYPE_IF_EXP_CHANGED.
// Param: length An integer that contains the number of elements to watch. (Default value is 1.)
// Param: passcount An integer that contains the number of times to pass this breakpoint before breaking. (Default value is 0.)
// END_HELP_COMMENT
bp *COBreakpoints::SetBreakOnExpr(LPCSTR location, LPCSTR expression, int expr_type, int length /* 1 */, int passcount /* 0 */)
	{
	char string[12];						   	
// REVIEW(briancr): this is obsolete code
//	if(!(uibp = UIWB.Breakpoints())) return NULL;
	if (!uibp.Activate()) {
		return NULL;
	}

	if(!uibp.SetLocation(location)) return FailAndClose();	
	if(passcount) {	
		if(!uibp.SetPassCount(_itoa(passcount, string, 10))) return FailAndClose();
	}
	switch(expr_type)
		{
		case COBP_TYPE_IF_EXP_TRUE:
			{
			if(!uibp.SetLocationExpression(expression, UIBP_TYPE_IF_EXP_TRUE)) return FailAndClose();
			break;
			}
		case COBP_TYPE_IF_EXP_CHANGED:
			{
			if(!uibp.SetLocationExpression(expression, UIBP_TYPE_IF_EXP_CHANGED)) return FailAndClose();
			if(!uibp.SetLocationExprLength(_itoa(length, string, 10))) return FailAndClose();
			}
		}

	return AddBPandClose();
	}
	
	
// BEGIN_HELP_COMMENT
// Function: bp* COBreakpoints::SetBreakOnMsg(LPCSTR location, LPCSTR message)
// Description: Set a message breakpoint at the given location with the given pass count.
// Return: A pointer to a bp object that is used as a handle to the breakpoint. Store this pointer to reference the breakpoint later.
// Param: location A pointer to a string that specifies the location of the breakpoint. Location is specified by the following form: {function name, source filename, EXE filename} .line.
// Param: message A pointer to a string that contains the name of the message to break on.
// END_HELP_COMMENT
bp *COBreakpoints::SetBreakOnMsg(LPCSTR location, LPCSTR message)
	{
//	char string[12];						   	
// REVIEW(briancr): this is obsolete code
//	if(!(uibp = UIWB.Breakpoints())) return NULL;
	if (!uibp.Activate()) {
		return NULL;
	}
///	if(!uibp.SetType(UIBP_TYPE_WNDPROC_IF_MSG_RECVD)) return FailAndClose();
	if(!uibp.SetWndProc(location)) return FailAndClose();	
	if(!uibp.SetMessage(message, 0)) return FailAndClose();
//	if(!uibp.SetPassCount(_itoa(passcount, string, 10))) return FailAndClose();
	return AddBPandClose();
	}
	

// BEGIN_HELP_COMMENT
// Function: bp* COBreakpoints::SetBreakOnExpr(LPCSTR expression, int expr_type, int length /* 1 */, int passcount /* 0 */)
// Description: Set an expression breakpoint with the given pass count.
// Return: A pointer to a bp object that is used as a handle to the breakpoint. Store this pointer to reference the breakpoint later.
// Param: expression A pointer to a string that contains the expression to use in the breakpoint. Expression is specified by the following form: {function name, source filename, EXE filename} expression.
// Param: expr_type A value that specifies the type of expression breakpoint to set: COBP_TYPE_IF_EXP_TRUE, COBP_TYPE_IF_EXP_CHANGED.
// Param: length An integer that contains the number of elements to watch. (Default value is 1.)
// Param: passcount An integer that contains the number of times to pass this breakpoint before breaking. (Default value is 0.)
// END_HELP_COMMENT
bp *COBreakpoints::SetBreakOnExpr(LPCSTR expression, int expr_type, int length /* 1 */, int passcount /* 0 */)
	{
	char string[12];
// REVIEW(briancr): this is obsolete code
//	if(!(uibp = UIWB.Breakpoints())) return NULL;
	if (!uibp.Activate()) {
		return NULL;
	}

	switch(expr_type)
		{
		case COBP_TYPE_IF_EXP_TRUE:
			{
			if(!uibp.SetDataExpression(expression, UIBP_TYPE_IF_EXP_TRUE)) return FailAndClose();
			break;
			}
		case COBP_TYPE_IF_EXP_CHANGED:
			{
			if(!uibp.SetDataExpression(expression, UIBP_TYPE_IF_EXP_CHANGED)) return FailAndClose();
			if(!uibp.SetExprLength(_itoa(length, string, 10))) return FailAndClose();
			}
		}

	return AddBPandClose();
	}



// BEGIN_HELP_COMMENT
// Function: BOOL COBreakpoints::EnableBreakpoint(bp* pbp)
// Description: Enable the breakpoint specified by the bp object given.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: pbp A pointer to a bp object that specifies the breakpoint to enable.
// END_HELP_COMMENT
BOOL COBreakpoints::EnableBreakpoint(bp *pbp)
	{
	BOOL success=TRUE;
	int bpindex = FindBPIndex(bp_list.Find(pbp));
	ASSERT(bpindex != -1);
// REVIEW(briancr): this is obsolete code
//	if(!(uibp = UIWB.Breakpoints())) return FALSE;
	if (!uibp.Activate()) {
		return FALSE;
	}
	success = uibp.Enable(bpindex);//can't return here without closing dialog!
	success = (uibp.Close() == NULL) && success;
	return (success);  		
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COBreakpoints::EnableAllBreakpoints(void)
// Description: Enable all breakpoints.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL COBreakpoints::EnableAllBreakpoints(void)
	{
	BOOL success=TRUE;
// REVIEW(briancr): this is obsolete code
//	if(!(uibp = UIWB.Breakpoints())) return FALSE;
	if (!uibp.Activate()) {
		return FALSE;
	}
	
	int index=0;
	for (POSITION bp_pos = bp_list.GetHeadPosition(); ((bp_pos != NULL) && (success));)
	{
		bp_list.GetNext(bp_pos);
		success=uibp.Enable(index++);//can't return here without closing dialog!
	}
	if (bp_pos!=NULL) return success=FALSE;	
	
	success = (uibp.Close() == NULL) && success;
	return (success);  		
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COBreakpoints::DisableBreakpoint(bp* pbp)
// Description: Disable the breakpoint specified by the bp object given.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: pbp A pointer to a bp object that specifies the breakpoint to disable.
// END_HELP_COMMENT
BOOL COBreakpoints::DisableBreakpoint(bp *pbp)
	{
	BOOL success=TRUE;
	int bpindex = FindBPIndex(bp_list.Find(pbp));
	ASSERT(bpindex != -1);
// REVIEW(briancr): this is obsolete code
//	if(!(uibp = UIWB.Breakpoints())) return FALSE;
	if (!uibp.Activate()) {
		return FALSE;
	}
	success = uibp.Disable(bpindex);//can't return here without closing dialog!
	success = (uibp.Close() == NULL) && success;
	return (success);  		
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COBreakpoints::DisableAllBreakpoints(void)
// Description: Disable all breakpoints.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL COBreakpoints::DisableAllBreakpoints(void)
	{
	BOOL success=TRUE;
// REVIEW(briancr): this is obsolete code
//	if(!(uibp = UIWB.Breakpoints())) return FALSE;
	if (!uibp.Activate()) {
		return FALSE;
	}
	
//	int index=1;
	int index=0;
	for (POSITION bp_pos= bp_list.GetHeadPosition(); (bp_pos != NULL) && (success);)
	{
		bp_list.GetNext(bp_pos);
		success=uibp.Disable(index++);//can't return here without closing dialog!
	}
	if (bp_pos!=NULL) return success=FALSE;	
	
	success = (uibp.Close() == NULL) && success;
	return (success);  		
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COBreakpoints::RemoveBreakpoint(bp* pbp)
// Description: Remove the breakpoint specified by the bp object given.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: pbp A pointer to a bp object that specifies the breakpoint to remove.
// END_HELP_COMMENT
BOOL COBreakpoints::RemoveBreakpoint(bp *pbp)
	{
	BOOL success=TRUE;
	int bpindex = FindBPIndex(bp_list.Find(pbp));
	ASSERT(bpindex != -1);
// REVIEW(briancr): this is obsolete code
//	if(!(uibp = UIWB.Breakpoints())) return FALSE;
	if (!uibp.Activate()) {
		return FALSE;
	}
	success = uibp.Remove(bpindex);//can't return here without closing dialog!
	success = (uibp.Close() == NULL) && success;
	if(!success)  return FALSE;
	
	delete bp_list.GetAt(bp_list.Find(pbp));
	bp_list.RemoveAt(bp_list.Find(pbp));
	
	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COBreakpoints::ClearAllBreakpoints(void)
// Description: Remove all breakpoints.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL COBreakpoints::ClearAllBreakpoints(void)
	{
	BOOL success=TRUE;
// REVIEW(briancr): this is obsolete code
//	if(!(uibp = UIWB.Breakpoints())) return FALSE;
	if (!uibp.Activate()) {
		return FALSE;
	}
	success = uibp.ClearAll();	//can't return here without closing dialog!
	success = (uibp.Close() == NULL) && success;
	if(!success)  return FALSE;  		

	while(! bp_list.IsEmpty())
		delete bp_list.RemoveTail();

	return TRUE;
	}

// BEGIN_HELP_COMMENT
// Function: BOOL VerifyBreakpointHit(void)
// Description: Verify that a breakpoint was hit. This function is NYI.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL VerifyBreakpointHit(void)
	{
	//todo chech for bp dialog/message
	return TRUE;
	}

bp *COBreakpoints::FailAndClose(void) //close dialog then fail Set Bp operation
	{
	uibp.Close();
	return NULL;
	};

bp *COBreakpoints::AddBPandClose(void)
	{
	BOOL success = TRUE;
///	success = uibp.Add();  //can't return here without closing dialog!
	success = (uibp.Close() == NULL) && success;
	if(!success)  return FALSE;  		
	return AddBPToList();
	};

bp *COBreakpoints::AddBPToList(void)
	{
	bp *pbp = new bp;
	bp_list.AddTail( pbp );
	return pbp;
	}

int COBreakpoints::FindBPIndex(POSITION pos)
	{
	int index=0;	 //YS: changed to 0 to keep consistent 0-based indexing
	for (POSITION bp_pos = bp_list.GetHeadPosition(); ((bp_pos != NULL) && (bp_pos!=pos));)
	{
		bp_list.GetNext(bp_pos);
		index++;
	}
	if ((pos==NULL) || (bp_pos==NULL)) return -1;	
	return index;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COBreakpoints::EditCode(bp *pbp, LPCSTR szFileDir /* NULL */)
// Description: Displays the source file (and cursor) where the specified bp is located,  
// Param: pbp A pointer to a bp object that specifies the breakpoint in question.
// Param: szFileDir An optional string specifying the file path if it needs to be supplied for the debugger to find the file.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL COBreakpoints::EditCode(bp *pbp, LPCSTR szFileDir /* NULL */)

{
	// figure out which position in the bp list this bp should be at.
	int bpindex = FindBPIndex(bp_list.Find(pbp));
	
	// make sure we got a valid position.
	if(bpindex < 0)
	{
		LOG->RecordInfo("ERROR in COBreakpoints::EditCode() - can't find bp in list");
		return FALSE;
	}

	// active the bp dlg.
	if(!uibp.Activate())
	{
		LOG->RecordInfo("ERROR in COBreakpoints::EditCode() - can't activate bp dlg");
		return FALSE;
	}

	// select the specified bp.
	if(!uibp.SetCurrentBreakpoint(bpindex))
	{
		LOG->RecordInfo("ERROR in COBreakpoints::EditCode() - can't select bp %d", bpindex);
		return FALSE;
	}

	// if a file path was specified, we are expecting the find source dlg & want to handle it
	if(szFileDir)
		UIWB.m_pTarget->SetHandleMsgs(FALSE);
	// select the edit code option in the bp dlg.
	if(!uibp.EditCode())
	{
		LOG->RecordInfo("ERROR in COBreakpoints::EditCode() - can't edit code from bp dlg");
		UIWB.m_pTarget->SetHandleMsgs(TRUE);
		return FALSE;
	}
	
	// wait around 10 seconds max for the bp dlg to go away.
	int iSleep = 0;
	while(uibp.IsActive())
	{
		Sleep(1000);
		if(++iSleep == 10)
		{
			LOG->RecordInfo("ERROR in COBreakpoints::EditCode() - bp dlg still active after 10 seconds");
			UIWB.m_pTarget->SetHandleMsgs(TRUE);
			return FALSE;
		}
	}

	// if a file path was specified, we are expecting the find source dlg.
	if(szFileDir)
	
	{
		// set up the object for the Find Source dlg.
		UIDialog dlgFindSource(GetLocString(IDSS_FS_TITLE));

		// wait up to 3 seconds for Find Source dlg to come up.
		if(dlgFindSource.WaitAttachActive(3000))
		{
			// verify that it is the Find Source dlg.
			if(dlgFindSource.VerifyTitle() )
			{
				// enter the specified directory and close the dlg.
				MST.DoKeys(szFileDir);
				dlgFindSource.OK();
			}
			else
			{
				LOG->RecordInfo("ERROR in COBreakpoints::EditCode() - dlg other than Find Source came up");
				UIWB.m_pTarget->SetHandleMsgs(TRUE);
				return FALSE;
			}
		}
		else
		{
			LOG->RecordInfo("ERROR in COBreakpoints::EditCode() - no dlg came up (expected Find Source)");
			UIWB.m_pTarget->SetHandleMsgs(TRUE);
			return FALSE;
		}
	}
	UIWB.m_pTarget->SetHandleMsgs(TRUE);
	return TRUE;  		
}


// BEGIN_HELP_COMMENT
// Function: BOOL COBreakpoints::RemainingPassCountIs(bp *pbp, int iPassCount)
// Description: Compares teh passcount of a specified bp with a specified value.  
// Param: pbp A pointer to a bp object that specifies the breakpoint in question.
// Param: iPassCount An integer specifying the expected pass count.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL COBreakpoints::RemainingPassCountIs(bp *pbp, int iPassCount)

{
	// figure out which position in the bp list this bp should be at.
	int bpindex = FindBPIndex(bp_list.Find(pbp));
	
	// make sure we got a valid position.
	if(bpindex < 0)
	{
		LOG->RecordInfo("ERROR in COBreakpoints::RemainingPassCountIs() - can't find bp in list");
		return FALSE;
	}

	// active the bp dlg.
	if(!uibp.Activate())
	{
		LOG->RecordInfo("ERROR in COBreakpoints::RemainingPassCountIs() - can't activate bp dlg");
		return FALSE;
	}

	// get the bp string.
	CString strBp;
	MST.WListItemText("@1", bpindex + 1, strBp);
	
	// close the bp dlg.
	if(uibp.Close())
	{
		LOG->RecordInfo("ERROR in COBreakpoints::RemainingPassCountIs() - bp dlg still active after 10 seconds");
		return FALSE;
	}

	// see if the passcount is as expected.
	char szPassCount[12];
	if(strBp.Find((CString)_itoa(iPassCount, szPassCount, 10) + " remaining") == -1)
	{
		LOG->RecordInfo("ERROR in COBreakpoints::RemainingPassCountIs() - "
						"couldn't find \"%s remaining\" in \"%s\"", szPassCount, strBp);
		return FALSE;
	}

	return TRUE;  		
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\coauto.h ===
///////////////////////////////////////////////////////////////////////////////
//  COAUTO.H
//
//  Created by:            Date:
//      MichMa                  9/16/98
//
//  Description:
//      Declaration of the COAuto class
//

#ifndef __COAUTO_H__
#define __COAUTO_H__

#include "dbgxprt.h"
#include "uivar.h"
#include "coee.h"

#pragma warning (disable : 4069)


///////////////////////////////////////////////////////////////////////////////
//  CAuto class

// BEGIN_CLASS_HELP
// ClassName: CAuto
// BaseClass: none
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS CAuto

{
public:

	CString m_strType;
	CString m_strName;
	CString m_strValue;
	EXPR_STATE m_ExprState;
	CAuto(void){}

	const CAuto& operator=(const CAuto &AutoSrc)
	{
		m_strType = AutoSrc.m_strType;
		m_strName = AutoSrc.m_strName;
		m_strValue = AutoSrc.m_strValue;
		m_ExprState = AutoSrc.m_ExprState;
		return *this;	
	}

	CAuto(CAuto &AutoSrc)
	{
		m_strType = AutoSrc.m_strType;
		m_strName = AutoSrc.m_strName;
		m_strValue = AutoSrc.m_strValue;
		m_ExprState = AutoSrc.m_ExprState;
	}
};


///////////////////////////////////////////////////////////////////////////////
//  COAuto class

// BEGIN_CLASS_HELP
// ClassName: COAuto
// BaseClass: none
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS COAuto

{
	// Data
	private:
		UIVariables m_uivar;
		COExpEval m_coee;

	// Utilities
	public:
		BOOL VerifyAutoInfo(CAuto Auto);
		BOOL VerifyAutoInfo(LPCSTR szName, LPCSTR szValue,  LPCSTR szType, EXPR_STATE ExprState);
		BOOL AutoDoesNotExist(LPCSTR szName);
		BOOL AutoCountIs(int intAutoCount);
		BOOL SetAutoValue(LPCSTR szName, LPCSTR szValue);
		BOOL VerifyReturnValue(LPCSTR szName, LPCSTR szValue,  LPCSTR szType, EXPR_STATE ExprState);
};

#endif // __COAUTO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\cobp.h ===
///////////////////////////////////////////////////////////////////////////////
//  COBP.H
//
//  Created by :            Date :
//      MichMa                  1/13/94
//
//  Description :
//      Declaration of the COBreakpoints class
//
	 
#ifndef __COBP_H__
#define __COBP_H__

#include "uibp.h"

#include "dbgxprt.h"

///////////////////////////////////////////////////////////////////////////////
//  COBreakpoints symbols

enum {COBP_TYPE_IF_EXP_TRUE, COBP_TYPE_IF_EXP_CHANGED};

///////////////////////////////////////////////////////////////////////////////
//  bp (supporting) struct

struct bp
	{
	CString name;
	};

///////////////////////////////////////////////////////////////////////////////
//  COBreakpoints class

// BEGIN_CLASS_HELP
// ClassName: COBreakpoints
// BaseClass: none
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS COBreakpoints

	{
	// Data
	private:
		CPtrList bp_list;
		UIBreakpoints uibp;

	// Utilities
	public:

		// obsolete api's kept for backward compatability
		bp *SetBreakpoint(int line, LPCSTR source=NULL, int passcount = 0);
		bp *SetBreakpoint(int line, LPCSTR expression, int option, int length,  int passcount = 0);
		bp *SetBreakpoint(int line, LPCSTR source, LPCSTR expression, int option, int length, int passcount = 0);

		bp *SetBreakpoint(LPCSTR function, LPCSTR source, int passcount = 0);
		bp *SetBreakpoint(LPCSTR function, LPCSTR expression, int option, int length, int passcount = 0);
		bp *SetBreakpoint(LPCSTR function, LPCSTR source, LPCSTR expression, int option, int length, int passcount = 0);

		bp *SetBreakpoint(LPCSTR expression, int option, int length, int passcount = 0);


		// suggested api's
		bp *SetBreakpoint(LPCSTR location = NULL, int passcount = 0);
		bp *SetAmbiguousBreakpoint(LPCSTR function, int ambiguity);
		bp *SetBreakOnMsg(LPCSTR location, LPCSTR message);
		bp *SetBreakOnExpr(LPCSTR location, LPCSTR expression, int expr_type, int length = 1, int passcount = 0);
		bp *SetBreakOnExpr(LPCSTR expression, int expr_type, int length = 1, int passcount = 0);

		// other api's
		BOOL EnableBreakpoint(bp *pbp);
		BOOL EnableAllBreakpoints(void);
		BOOL DisableBreakpoint(bp *pbp);
		BOOL DisableAllBreakpoints(void);
		BOOL RemoveBreakpoint(bp *pbp);
		BOOL ClearAllBreakpoints(void);

		BOOL VerifyBreakpointHit(void);
		BOOL EditCode(bp *pbp, LPCSTR szFileDir = NULL);
		BOOL RemainingPassCountIs(bp *pbp, int iPassCount);

	private:
		bp *AddBPandClose(void);
		bp *FailAndClose(void);
		int FindBPIndex(POSITION pos);
		bp *AddBPToList(void);
	};

#endif // __COBP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\cobrowse.h ===
///////////////////////////////////////////////////////////////////////////////
//  COBROWSE.H
//
//  Created by :            Date :
//      WayneBr                 1/21/94
//
//  Description :
//      Declaration of the COBrowse class
//

#ifndef __COBROWSE_H__
#define __COBROWSE_H__

#include "uibrowse.h"

#include "dbgxprt.h"

///////////////////////////////////////////////////////////////////////////////
//  COBrowse class

// Special values for ambiguity index. Normal values for index are >= 0.
int const NoAmbiguity = -1;


typedef enum {LOC_DEF, LOC_REF} BROWSER_LOC_TYPE;
typedef enum {SYM_VAR, SYM_PARAM} BROWSER_SYM_TYPE;

// abbreviations to make casting shorter.
#define SDR SYM_DEFS_REFS
#define BL BROWSER_LOCATION
#define CI COMMENT_INFO

class COMMENT_INFO
	{
	public:
		CString file;
		CArray<int, int> lines;
	};

class BROWSER_LOCATION
	{
	public:
		// contructor
		BROWSER_LOCATION(){commented = FALSE;}
		// data
		CString name;
		CString file;
		int	line;
		BOOL commented;
		CPtrArray comments;
		CArray<int, int> dependents;
	};

class SYM_DEFS_REFS
	{
	public:
		// constructor
		SYM_DEFS_REFS(){commented = FALSE;}
		// data
		CString sym_name;
		CString sym_type;
		BOOL commented;
		// [0] is defs and [1] is refs
		CPtrArray locs[2];
	};


// BEGIN_CLASS_HELP
// ClassName: COBrowse
// BaseClass: none
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS COBrowse
{
public:

	// Navigation operations
	BOOL GotoNthDefinition(int index, LPCSTR name,int ambiguity = NoAmbiguity ); // Global context, NULL name use cursor loc
	BOOL GotoNthReference(int index, LPCSTR name,int ambiguity = NoAmbiguity );  // Global context, NULL name use cursor loc
	BOOL NextDefinition(void);
	BOOL PrevDefinition(void);
	BOOL NextReference(void);
	BOOL PrevReference(void);
	BOOL PopContext(void);

	// Batch query operations.
	BOOL GetMatches( CStringArray& matches, CString name, QueryType type, int filter = NONE );
	BOOL GetDefinitions( CStringArray& defs, CString name, QueryType type, int filter = NONE, int ambiguity = NoAmbiguity );
	BOOL GetReferences( CStringArray& refs, CString name, QueryType type, int filter = NONE, int ambiguity = NoAmbiguity );
	BOOL GetMembers( CStringArray& members, CString name, QueryType type, int filter = NONE, int ambiguity = NoAmbiguity );

	BOOL VerifyMultDefRefMatches(CPtrArray& expected, LPCSTR query_name = "");

	// get first level of descendents or ancestors in tree.
	BOOL GetFirstLevelBranches( CStringArray& branches, CString name, QueryType type, int filter = NONE, int ambiguity = NoAmbiguity  );

	// Utilities
	BOOL VerifyNavigation(LPCSTR file_line);
	BOOL GetLocations(CStringArray& defs, CStringArray& refs);
	CString BuildSymbolMatchStr(SDR *sdr);
	
private:
	UIBrowse m_uibrowse;
};

#endif // __CBROWSE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\cocp.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  COCP.CPP
//
//  Created by :            Date :
//      WayneBr             1/14/94
//
//  Description :
//      Implementation of the COCoProcessor class
//

#include "stdafx.h"
#include "cocp.h"
#include "testxcpt.h"
#include "..\sym\qcqp.h"
#include "guiv1.h"
#include "..\shl\uwbframe.h"
#include "uidebug.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


// BEGIN_HELP_COMMENT
// Function: CString COCoProcessor::GetCPRegister(int reg)
// Description: Get the value of one of the coprocessor's registers.
// Return: A CString that contains the value of the specified coprocessor's register.
// Param: reg An integer that specifies the 1-based index into the set of coprocessor registers.
// END_HELP_COMMENT
CString  COCoProcessor::GetCPRegister(int reg)
	{
	EXPECT(uicp = UIDebug::ShowDockWindow(IDW_CPU_WIN));
	CString temp  = uicp.GetCPRegister(reg);
	EXPECT(uicp.Close());
	return  temp;
	};

// BEGIN_HELP_COMMENT
// Function: BOOL COCoProcessor::CPRegisterValueIs(int reg, LPCSTR value)
// Description: Determine whether the given coprocessor register matches the given value.
// Return: A Boolean value that indicates whether the coprocessor's register matches the given value (TRUE) or not.
// Param: reg An integer that specifies the 1-based index into the set of coprocessor registers.
// Param: value A pointer to a string that contains the expected value of the specified register.
// END_HELP_COMMENT
BOOL  COCoProcessor::CPRegisterValueIs(int reg, LPCSTR value)
	{
	EXPECT(uicp = UIDebug::ShowDockWindow(IDW_CPU_WIN));
	CString temp  = uicp.GetCPRegister(reg);
	if (temp!=value)
	{
		// log warning
		LOG->RecordInfo( (LPCSTR) "Register Values is %d, expected %d",temp, value);
	}
	EXPECT(uicp.Close());
	return  temp==value;
	};

// BEGIN_HELP_COMMENT
// Function: BOOL COCoProcessor::SetCPRegister(int reg, LPCSTR value)
// Description: Set the value of one of the coprocessor's registers.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: reg An integer that specifies the 1-based index into the set of coprocessor registers.
// Param: value A pointer to a string that contains the value to set the specified register to.
// END_HELP_COMMENT
BOOL COCoProcessor::SetCPRegister(int reg, LPCSTR value)
	{
	EXPECT(uicp = UIDebug::ShowDockWindow(IDW_CPU_WIN));
	EXPECT(uicp.SetCPRegister(reg, value ));
	return uicp.Close();
	};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\cobrowse.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  COBROWSE.CPP
//
//  Created by :            Date :
//      WayneBr                 1/21/94
//
//  Description :
//      Implementation of the COBrowse class
//

#include "stdafx.h"
#include "cobrowse.h"
#include "testxcpt.h"
#include "guiv1.h"
#include "..\shl\uwbframe.h"
#include "..\eds\ueditor.h"
#include "Strings.h"
#include "..\shl\wbutil.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


// indexed by BROWSER_LOC_TYPE for use in log (see VerifyMultDefRefMatch).
CString blt_str[2] = {"def", "ref"};


// BEGIN_HELP_COMMENT
// Function: BOOL COBrowse::GotoNthDefinition(int index, LPCSTR name, int ambiguity /*= NoAmbiguity*/)
// Description: Go to the n-th definition of the given symbol.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: index An integer that specifies the n-th definition to go to.
// Param: name A pointer to a string that contains the name of the symbol to go to.
// Param: ambiguity An integer that specifies the index of the symbol in the list of ambiguous symbols, if applicable. If ambiguity is not expected, set this value to NoAmbiguity. (Default value is NoAmbiguity.)
// END_HELP_COMMENT
BOOL COBrowse::GotoNthDefinition(int index, LPCSTR name,int ambiguity ) {
    if (name) UIWB.SetToolbarCombo(name);
	//We don't need assertion here since the function always return true
    //EXPECT(m_uibrowse.FirstDefinition());
	m_uibrowse.FirstDefinition();

	// check for ambiguity resolution dialog
	UIAmbiguiousSymbolDialog dlg;
	if( dlg.AttachActive() )
	{
		if( ambiguity == NoAmbiguity ) {
			LOG->RecordInfo( "COBrowse::GotoNthDefinition - Ambiguity not expected" );
			dlg.Cancel();
			return FALSE;
		}
		else {
			if( !dlg.SelectAmbiguity( ambiguity ) ) {
				LOG->RecordInfo( "COBrowse::GotoNthDefinition - Could not select ambiguity item %d", ambiguity );
				dlg.Cancel();
				return FALSE;
			}
		}
	}
	else
	{
		// No ambiguity resolution dialog, make sure it wasn't expected.
		if( ambiguity >= 0 ) {
			LOG->RecordInfo( "COBrowse::GotoNthDefinition - Expected ambiguity resolution dialog" );
			return FALSE;
		}
	}
    for (int count=2; count<index; count++) m_uibrowse.NextDefinition();
    return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL COBrowse::GotoNthReference(int index, LPCSTR name, int ambiguity /*= NoAmbiguity*/)
// Description: Go to the n-th reference of the given symbol.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: index An integer that specifies the n-th reference to go to.
// Param: name A pointer to a string that contains the name of the symbol to go to.
// Param: ambiguity An integer that specifies the index of the symbol in the list of ambiguous symbols, if applicable. If ambiguity is not expected, set this value to NoAmbiguity. (Default value is NoAmbiguity.)
// END_HELP_COMMENT
BOOL COBrowse::GotoNthReference(int index, LPCSTR name, int ambiguity) {
    if (name) UIWB.SetToolbarCombo(name);
    EXPECT(m_uibrowse.FirstReference());

	// check for ambiguity resolution dialog
	UIAmbiguiousSymbolDialog dlg;
	if( dlg.AttachActive() )
	{
		if( ambiguity == NoAmbiguity ) {
			LOG->RecordInfo( "COBrowse::GotoNthReference - Ambiguity not expected" );
			dlg.Cancel();
			return FALSE;
		}
		else {
			if( !dlg.SelectAmbiguity( ambiguity ) ) {
				LOG->RecordInfo( "COBrowse::GotoNthReference - Could not select ambiguity item %d", ambiguity );
				dlg.Cancel();
				return FALSE;
			}
		}
	}
	else
	{
		// No ambiguity resolution dialog, make sure it wasn't expected.
		if( ambiguity >= 0 ) {
			LOG->RecordInfo( "COBrowse::GotoNthReference - Expected ambiguity resolution dialog" );
			return FALSE;
		}
	}
    for (int count=2; count<index; count++) m_uibrowse.NextReference();
    return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL COBrowse::NextDefinition(void)
// Description: Go to the next definition of the currently selected symbol.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL COBrowse::NextDefinition(void) {
    return m_uibrowse.NextDefinition();
}

// BEGIN_HELP_COMMENT
// Function: BOOL COBrowse::PrevDefinition(void)
// Description: Go to the previous definition of the currently selected symbol.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL COBrowse::PrevDefinition(void) {
    return m_uibrowse.PrevDefinition();
}


// BEGIN_HELP_COMMENT
// Function: BOOL COBrowse::NextReference(void)
// Description: Go to the next reference of the currently selected symbol.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL COBrowse::NextReference(void) {
    return m_uibrowse.NextReference();
}

// BEGIN_HELP_COMMENT
// Function: BOOL COBrowse::PrevReference(void)
// Description: Go to the previous reference of the currently selected symbol.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL COBrowse::PrevReference(void) {
    return m_uibrowse.PrevReference();
}

// BEGIN_HELP_COMMENT
// Function: BOOL COBrowse::PopContext(void)
// Description: Pop context to the previous cursor location/context.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL COBrowse::PopContext(void) {
    if (!m_uibrowse.PopContext())
    {
        // log warning
        LOG->RecordInfo( (LPCSTR) "Can't pop context");
        return FALSE;
    }
    return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL COBrowse::GetMatches( CStringArray& matches, CString name, QueryType type, int filter /*= NONE*/)
// Description: Get the list of symbols that match the name specified when the specified query is performed.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: matches A CStringArray reference that will contain the list of symbols that match the symbols specified by name.
// Param: name A CString that contains the name of the symbol.
// Param: type A QueryType value that specifies the type of query to perform: DefRef, FileOutline, BaseClass, DerivedClass, CallGraph, CallerGraph.
// Param: filter A bit field that specifies the type of filter to apply to the query: NONE, CLASSES, FUNCTIONS, DATA, MACROS, TYPES. (Default value is NONE.)
// END_HELP_COMMENT
BOOL COBrowse::GetMatches( CStringArray& matches, CString name, QueryType type, int filter ) {

	matches.RemoveAll();

	if( m_uibrowse.Query( type, name, filter ) ) {
		EXPECT( m_uibrowse.IsActive() );
		if( m_uibrowse.GetMatches( matches ) ) {
			// remove filname which is listed with matches from file outline.
			if( type == FileOutline ) {
				EXPECT( matches.GetSize() > 0 );
				matches.RemoveAt( 0 );
			}

			m_uibrowse.CloseBrowser();
			return TRUE;
		}
		else {
			m_uibrowse.CloseBrowser();
			return FALSE;
		}
	}
	else if( m_uibrowse.GetStatus() == UIBrowse::AmbiguityDialog ) {

		CStringArray amb;
		EXPECT( m_uibrowse.GetAmbiguities( amb ) );

		// Cancel dialog
		m_uibrowse.CancelAmbiguity();
		int nAmb = amb.GetSize();

		for( int i=0; i < nAmb; i++ ) {
			CStringArray tmp;
			EXPECT( !m_uibrowse.Query( type, name, filter ) );
			EXPECT( m_uibrowse.GetStatus() == UIBrowse::AmbiguityDialog );
			EXPECT( m_uibrowse.SelectAmbiguity( i ) );
			EXPECT( m_uibrowse.GetMatches( tmp ) );
			matches.InsertAt( matches.GetSize(), &tmp );
			m_uibrowse.CloseBrowser();
		}
		return TRUE;
	}
	else {
		LOG->RecordInfo( "COBrowse::GetMatches - Query failed" );
		return FALSE;
	}
}

// BEGIN_HELP_COMMENT
// Function: BOOL COBrowse::GetDefinitions( CStringArray& definitions, CString name, QueryType type, int filter /*= NONE*/, int ambiguity /*= NoAmbiguity*/)
// Description: Get the list of definitions for a given symbol when a specified query is performed.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: definitions A CStringArray reference that will contain the list of definitions for the given symbol.
// Param: name A CString that contains the name of the symbol.
// Param: type A QueryType value that specifies the type of query to perform: DefRef, FileOutline, BaseClass, DerivedClass, CallGraph, CallerGraph.
// Param: filter A bit field that specifies the type of filter to apply to the query: NONE, CLASSES, FUNCTIONS, DATA, MACROS, TYPES. (Default value is NONE.)
// Param: ambiguity An integer that specifies the index of the symbol in the list of ambiguous symbols, if applicable. If ambiguity is not expected, set this value to NoAmbiguity. (Default value is NoAmbiguity.)
// END_HELP_COMMENT
BOOL COBrowse::GetDefinitions( CStringArray& definitions, CString name, QueryType type, int filter, int ambiguity ) {

	definitions.RemoveAll();

	if( !m_uibrowse.Query( type, name, filter ) ) {
		if( m_uibrowse.GetStatus() == UIBrowse::AmbiguityDialog ) {

			if( ambiguity == NoAmbiguity ) {
				// Cancel dialog
				m_uibrowse.CancelAmbiguity();
				LOG->RecordInfo( "COBrowse::GetDefintions - Ambiguity not expected" );
				return FALSE;
			}
			else {
				// select ambiguity
				if( !m_uibrowse.SelectAmbiguity( ambiguity ) ) {
					m_uibrowse.CancelAmbiguity();
					LOG->RecordInfo( "COBrowse::GetDefintions - SelectAmbiguity failed" );
					return FALSE;
				}
			}
		}
		else {
			LOG->RecordInfo( "COBrowse::GetDefintions - Query failed" );
			return FALSE;
		}
	}

	// don't care about refs, but must pass dummy param.
	CStringArray references;
	return GetLocations(definitions, references);
}


// BEGIN_HELP_COMMENT
// Function: BOOL COBrowse::GetReferences( CStringArray& references, CString name, QueryType type, int filter /*= NONE*/, int ambiguity /*= NoAmbiguity*/)
// Description: Get the list of references for a given symbol when a specified query is performed.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: references A CStringArray reference that will contain the list of references for the given symbol.
// Param: name A CString that contains the name of the symbol.
// Param: type A QueryType value that specifies the type of query to perform: DefRef, FileOutline, BaseClass, DerivedClass, CallGraph, CallerGraph.
// Param: filter A bit field that specifies the type of filter to apply to the query: NONE, CLASSES, FUNCTIONS, DATA, MACROS, TYPES. (Default value is NONE.)
// Param: ambiguity An integer that specifies the index of the symbol in the list of ambiguous symbols, if applicable. If ambiguity is not expected, set this value to NoAmbiguity. (Default value is NoAmbiguity.)
// END_HELP_COMMENT
BOOL COBrowse::GetReferences( CStringArray& references, CString name, QueryType type, int filter, int ambiguity ) {

	references.RemoveAll();

	if( !m_uibrowse.Query( type, name, filter ) ) {
		if( m_uibrowse.GetStatus() == UIBrowse::AmbiguityDialog ) {

			if( ambiguity == NoAmbiguity ) {
				// Cancel dialog
				m_uibrowse.CancelAmbiguity();
				LOG->RecordInfo( "COBrowse::GetReferences - Ambiguity not expected" );
				return FALSE;
			}
			else {
				// select ambiguity
				if( !m_uibrowse.SelectAmbiguity( ambiguity ) ) {
					m_uibrowse.CancelAmbiguity();
					LOG->RecordInfo( "COBrowse::GetReferences - SelectAmbiguity failed" );
					return FALSE;
				}
			}
		}
		else {
			LOG->RecordInfo( "COBrowse::GetReferences - Query failed" );
			return FALSE;
		}
	}

	// don't care about defs, but must pass dummy param.
	CStringArray definitions;
	return GetLocations(definitions, references);
}


// BEGIN_HELP_COMMENT
// Function: BOOL COBrowse::GetLocations(CStringArray& defs, CStringArray& refs)
// Description: Get the current list of definitnios and references and put them in separate lists.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: defs A CStringArray reference that will contain the list of current definitions. may be NULL if refs isn't.
// Param: refs A CStringArray reference that will contain the list of current references. may be NULL if defs isn't.
// END_HELP_COMMENT
BOOL COBrowse::GetLocations(CStringArray& defs, CStringArray& refs)

	{
	EXPECT(m_uibrowse.IsActive());
	CString defStr = GetLocString(IDSS_BRS_DEFINITIONS);
	CString refStr = GetLocString(IDSS_BRS_REFERENCES);
	CStringArray locs;

	if(m_uibrowse.GetLocations(locs))

		{
		EXPECT(locs[0] == defStr);
		int i = 1;
	
		while((i < locs.GetSize()) && (locs[i] != refStr))
			{
			defs.Add(locs[i]);
			i++;
			}

		EXPECT(locs[i] == refStr);
		i++;

		while(i < locs.GetSize())
			{
			refs.Add(locs[i]);
			i++;
			}

		return TRUE;
		}

	LOG->RecordInfo("COBrowse::GetLocations - couldn't get locations" );
	return FALSE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COBrowse::GetMembers( CStringArray& members, CString name, QueryType type, int filter /*= NONE*/, int ambiguity /*= NoAmbiguity*/)
// Description: Get the list of members for a given symbol when a specified query is performed.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: members A CStringArray reference that will contain the list of members for the given symbol.
// Param: name A CString that contains the name of the symbol.
// Param: type A QueryType value that specifies the type of query to perform: DefRef, FileOutline, BaseClass, DerivedClass, CallGraph, CallerGraph.
// Param: filter A bit field that specifies the type of filter to apply to the query: NONE, CLASSES, FUNCTIONS, DATA, MACROS, TYPES. (Default value is NONE.)
// Param: ambiguity An integer that specifies the index of the symbol in the list of ambiguous symbols, if applicable. If ambiguity is not expected, set this value to NoAmbiguity. (Default value is NoAmbiguity.)
// END_HELP_COMMENT
BOOL COBrowse::GetMembers( CStringArray& members, CString name, QueryType type, int filter, int ambiguity ) {
	members.RemoveAll();

	if( !m_uibrowse.Query( type, name, filter ) ) {
		if( m_uibrowse.GetStatus() == UIBrowse::AmbiguityDialog ) {

			if( ambiguity == NoAmbiguity ) {
				// Cancel dialog
				m_uibrowse.CancelAmbiguity();
				LOG->RecordInfo( "COBrowse::GetMembers - Ambiguity not expected" );
				return FALSE;
			}
			else {
				// select ambiguity
				if( !m_uibrowse.SelectAmbiguity( ambiguity ) ) {
					m_uibrowse.CancelAmbiguity();
					LOG->RecordInfo( "COBrowse::GetMembers - SelectAmbiguity failed" );
					return FALSE;
				}
			}
		}
		else {
			LOG->RecordInfo( "COBrowse::GetMembers - Query failed" );
			return FALSE;
		}
	}

	EXPECT( m_uibrowse.IsActive() );
	if( m_uibrowse.GetMembers( members ) ) {
		m_uibrowse.CloseBrowser();

		// Filter for public|protected|filter
		int index = 0;
		while( index < members.GetSize() ) {
			if( members[index] == "Public:" ) {
				members.RemoveAt( index );
			}
			else if( members[index] == "Protected:" ) {
				members.RemoveAt( index );
			}
			else if( members[index] == "Private:" ) {
				members.RemoveAt( index );
			}
			else {
				index++;
			}
		}
		return TRUE;
	}
	else {
		m_uibrowse.CloseBrowser();
		return FALSE;
	}
}


// BEGIN_HELP_COMMENT
// Function: BOOL COBrowse::GetFirstLevelBranches( CStringArray& branches, CString name, QueryType type, int filter /*= NONE*/, int ambiguity /*= NoAmbiguity*/)
// Description: Get the list of first level branches for a given symbol when a specified query is performed.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: branches A CStringArray reference that will contain the list of first level branches for the given symbol.
// Param: name A CString that contains the name of the symbol.
// Param: type A QueryType value that specifies the type of query to perform: DefRef, FileOutline, BaseClass, DerivedClass, CallGraph, CallerGraph.
// Param: filter A bit field that specifies the type of filter to apply to the query: NONE, CLASSES, FUNCTIONS, DATA, MACROS, TYPES. (Default value is NONE.)
// Param: ambiguity An integer that specifies the index of the symbol in the list of ambiguous symbols, if applicable. If ambiguity is not expected, set this value to NoAmbiguity. (Default value is NoAmbiguity.)
// END_HELP_COMMENT
BOOL COBrowse::GetFirstLevelBranches( CStringArray& branches, CString name, QueryType type, int filter, int ambiguity ) {
	branches.RemoveAll();

	if( !m_uibrowse.Query( type, name, filter ) ) {
		if( m_uibrowse.GetStatus() == UIBrowse::AmbiguityDialog ) {

			if( ambiguity == NoAmbiguity ) {
				// Cancel dialog
				m_uibrowse.CancelAmbiguity();
				LOG->RecordInfo( "COBrowse::GetFirstLevelBranches - Ambiguity not expected" );
				return FALSE;
			}
			else {
				// select ambiguity
				if( !m_uibrowse.SelectAmbiguity( ambiguity ) ) {
					m_uibrowse.CancelAmbiguity();
					LOG->RecordInfo( "COBrowse::GetFirstLevelBranches - SelectAmbiguity failed" );
					return FALSE;
				}
			}
		}
		else {
			LOG->RecordInfo( "COBrowse::GetFirstLevelBranches - Query failed" );
			return FALSE;
		}
	}

	EXPECT( m_uibrowse.IsActive() );
	if( m_uibrowse.GetFirstLevelBranches( branches ) ) {
		m_uibrowse.CloseBrowser();
		return TRUE;
	}
	else {
		m_uibrowse.CloseBrowser();
		return FALSE;
	}
}


// Verifies line in file in source window
// uses notation returned from GetNthDefinition/reference
// ie "f:\cafe\cafe\wb\cobrowse.h(33)"
// BEGIN_HELP_COMMENT
// Function: BOOL COBrowse::VerifyNavigation(LPCSTR file_line)
// Description: Verify browser navigation navigated to the correct file and line number.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: file_line A pointer to a string that contains the file and line number to verify. The form of the string is: filename(line); example: f:\cafe\cafe\wb\cobrowse.h(33).
// END_HELP_COMMENT
BOOL COBrowse::VerifyNavigation(LPCSTR file_line) {
    char file[255];
    int line;
    BOOL success= TRUE;
    EXPECT(m_uibrowse.CrackFileLine(file_line, (char *) &file, &line));

	//
	//		Verify filename.
	//    
	CString strCurFile( ((UIEditor)UIWB.GetActiveEditor()).GetTitle() );
	CString strFile( file );

	//
	//	Case-insensitive compare works since all supportted systems are case-insensitive.
	//	May need to test file system for case-sensitivity someday.
	success = strFile.CompareNoCase( strCurFile ) == 0;

	//
	//		Verify file line.
	//    
    success = success && ( UIWB.GetEditorCurPos(GECP_LINE) == line );
    
    return success;
}


// BEGIN_HELP_COMMENT
// Function: BOOL COBrowse::VerifyMultDefRefMatches(SYM_DEFS_REFS *expected, LPCSTR name)
// Description: Do def/ref query on name and verify all matches are listed along with correct defs/refs for each.  order is not verified.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expected An array of SYM_DEFS_REFS objects containing all matches, defs, and refs expected in browser window.
// Param: name An LPCSTR that contains the name of the symbol to query (default is "").
// END_HELP_COMMENT

BOOL COBrowse::VerifyMultDefRefMatches(CPtrArray& expected, LPCSTR query_name /* "" */)
	
	{
	CStringArray locs[2];
	CString cstr, sym_match;
	char str[8];
	int isym, iloc_act, iloc_exp, blt, count;
	BOOL result = TRUE;

	// do the query.
	if(!m_uibrowse.Query(DefRef, query_name))
		
		{
		LOG->RecordInfo("COBrowse::VerifyMultDefRefMatches - "
						"query on symbol \"%s\" failed", query_name);
		
		return FALSE;
		}

	// perform for each SYM_DEFS_REFS object.
	for(isym = 0; isym < expected.GetSize(); isym++)

		{
		sym_match = BuildSymbolMatchStr((SDR *)expected[isym]);

		// if symbol is commented, we expect not to find it in browser wnd.
		if(((SDR *)expected[isym])->commented)
			
			{
			if(m_uibrowse.FindMatch(sym_match) > -1)
				
				{
				LOG->RecordInfo("COBrowse::VerifyMultDefRefMatches - "
								"commented symbol \"%s\" found", sym_match);
			
				result = FALSE;
				continue;
				}
			}

		// symbol isn't commented so verify it's defs/refs.
		else 
		
			{
			if(!m_uibrowse.SelectMatch(sym_match))
				
				{
				LOG->RecordInfo("COBrowse::VerifyMultDefRefMatches - "
								"couldn't select symbol \"%s\"", sym_match);

				result = FALSE;
				continue;
				}
		
			// empty def and ref arrays that will recieve defs and refs in browser wnd.
			locs[LOC_DEF].RemoveAll();
			locs[LOC_REF].RemoveAll();

			// get the defs and refs for the currently selected symbol.
			if(!GetLocations(locs[LOC_DEF], locs[LOC_REF]))			
				
				{
				LOG->RecordInfo("COBrowse::VerifyMultDefRefMatches - "
								"couldn't get defs/refs for symbol \"%s\"", sym_match);

				result = FALSE;
				continue;
				}

			// verify that defs/refs match expected.
			for(blt = 0; blt < 2; blt++)
				
				{
				count = 0;

				// get the count of uncommented defs/refs.
				for(iloc_exp = 0; iloc_exp < ((SDR *)expected[isym])->locs[blt].GetSize(); iloc_exp++)
					{
					if(!(((BL *)(((SDR *)expected[isym])->locs[blt][iloc_exp]))->commented))
						count++;
					}
				
				// compare it to actual count.
				if(count != locs[blt].GetSize())
					
					{
					LOG->RecordInfo("COBrowse::VerifyMultDefRefMatches - "
									"%s count for symbol \"%s\" is %d instead of expected %d",
									blt_str[blt], sym_match, 
									locs[blt].GetSize(), count);

					result = FALSE;
					continue;
					}

				// start with the first def/ref element.
				iloc_exp = 0;

				// peform for each def/ref displayed in browser window.
				for(iloc_act = 0; iloc_act < locs[blt].GetSize(); iloc_act++)
					
					{
					// advance to next expected uncommented def/ref.
					while(((BL *)(((SDR *)expected[isym])->locs[blt][iloc_exp]))->commented)
						iloc_exp++;
						
					// TODO (michma): enable full string comparison.
					// build ref/def string as displayed in browser wnd.
					cstr = ((BL *)(((SDR *)expected[isym])->locs[blt][iloc_exp]))->file + "(" +
						   _itoa(((BL *)(((SDR *)expected[isym])->locs[blt][iloc_exp]))->line, str, 10) + ")";

					// search for the def/ref string in the actual string.
					if(locs[blt][iloc_act].Find(cstr) < 0)

						{
						LOG->RecordInfo("COBrowse::VerifyMultDefRefMatches - "
										"mismatch for \"%s\" of symbol \"%s\": "
										"could not find expected \"%s\" in \"%s\"",
										((BL *)(((SDR *)expected[isym])->locs[blt][iloc_exp]))->name, 
										sym_match, cstr, locs[blt][iloc_act]);
						
						result = FALSE;
						continue;
						}

					// advance to next def/ref element.
					iloc_exp++;
					}
				}
			}
		}

	if(!m_uibrowse.CloseBrowser())
		{
		LOG->RecordInfo("COBrowse::VerifyMultDefRefMatches - failed to close browser");
		return FALSE;
		}

	return result;
	}


CString COBrowse::BuildSymbolMatchStr(SDR *sdr)

	{
	CString sym_type_str;

	if(sdr->sym_type == "var")
		sym_type_str = " (variable)";
	else if(sdr->sym_type == "param")
		sym_type_str = " (parameter";
	else if(sdr->sym_type == "struct")
		sym_type_str = " (struct_name)";
	else if(sdr->sym_type == "union")
		sym_type_str = " (union_name)";
	else if(sdr->sym_type == "enum")
		sym_type_str = " (enum_name)";
	else if(sdr->sym_type == "enum_mem")
		sym_type_str = " (enum_mem)";
	else if(sdr->sym_type == "typedef")
		sym_type_str = " (typedef)";
	else if(sdr->sym_type == "const")
		sym_type_str = " (constant)";
	else if(sdr->sym_type == "macro")
		sym_type_str = " (macro)";
	else if(sdr->sym_type != "")
		sym_type_str = "(" + sdr->sym_type + ")";

	return sdr->sym_name + sym_type_str;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\cocp.h ===
///////////////////////////////////////////////////////////////////////////////
//  COCP.H
//
//  Created by :            Date :
//      WayneBr             1/14/94
//
//  Description :
//      Declaration of the COCoProcessor class
//

#ifndef __COCP_H__
#define __COCP_H__

#include "uicp.h"

#include "dbgxprt.h"

///////////////////////////////////////////////////////////////////////////////
//  COCoProcessor class

// BEGIN_CLASS_HELP
// ClassName: COCoProcessor
// BaseClass: none
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS COCoProcessor

	{

	// Data
	private:
		UICoProcessor uicp;

	// Utilities
	public:
		CString GetCPRegister(int reg);
		BOOL SetCPRegister(int reg, LPCSTR value);
		BOOL CPRegisterValueIs(int reg, LPCSTR value);
	};


#endif // __COCP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\codam.h ===
///////////////////////////////////////////////////////////////////////////////
//  CODAM.H
//
//  Created by :            Date :
//      WayneBr             1/14/94
//
//  Description :
//      Declaration of the CODAM class
//

#ifndef __CODAM_H__
#define __CODAM_H__

#include "dbgxprt.h"
#include "uidam.h"


///////////////////////////////////////////////////////////////////////////////
//  CODAM class

// BEGIN_CLASS_HELP
// ClassName: CODAM
// BaseClass: none
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS CODAM

	{

	// Data
	private:
		UIDAM uidam;

	// Utilities
	public:

		BOOL GotoSymbol(LPCSTR symbol, BOOL bCloseAfter = TRUE);
		BOOL GotoAddress(int address, BOOL bCloseAfter = TRUE);
		CString GetInstruction(void);
		BOOL InstructionIs(LPCSTR inst);
		BOOL Enable(void);
		BOOL Disable(void);
		BOOL ToggleSourceDisplay(BOOL bToggle);
		CString GetLines(int startline = 0, int count = 1);
		BOOL InstructionContains(int offset = 1, CString ExpectedInst = "",BOOL bLocateCaretAtLeftTop = FALSE);
		BOOL SwitchBetweenASMAndSRC(BOOL bUsingContextMenu = FALSE);
		BOOL IsActive(void);
		BOOL VerifyCurrentInstruction(LPCSTR szInstruction);
	};

#endif // __CODAM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\codebug.cpp ===
//////////////////////////////////////////////////////////////////////////////
//  CODEBUG.CPP
//
//  Created by :            Date :
//      MichMa                  1/14/93
//
//  Description :
//      Implementation of the CODebug class
//
		
#include "stdafx.h"
#include "codebug.h"
#include "mstwrap.h"
#include "..\..\udialog.h"
#include "..\sym\qcqp.h"
#include "guiv1.h"
#include "..\shl\uwbframe.h"
#include "..\shl\wbutil.h"
#include "..\src\cosource.h"
#include "coee.h"
#include "parse.h"
#include "uidebug.h"
#include "uiattach.h"
#include "uidam.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// stores all localizable string id's for msgs used by CancelMsg() and HandleMsg()
int msg_array[] = 
{
	IDSS_REMOTE_EXE_NAME_REQUIRED,
	IDSS_REMOTE_LOCAL_EXE_MISMATCH,
	IDSS_EC_DELAYED_DUE_TO_CTOR_DTOR,
	IDSS_EC_ONLY_ASM_AVAILABLE,
	IDSS_EXCEPTION_DIVIDE_BY_ZERO,
	IDSS_EC_POINT_OF_EXECUTION_MOVED,
	IDSS_EC_LOCAL_VAR_REMOVED
};


CODebug::CODebug() {
	mMode = SRC;       //default to source mode.
	m_pOwnedStack = NULL;
};

// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::Exec(BOOL (UIWBFrame::*stepfcn)(int), int count /*= 1*/, LPCSTR symbol /*= NULL*/, LPCSTR line /*= NULL*/, LPCSTR function /*= NULL*/, int WAIT /*= WAIT_FOR_BREAK*/, int ModeVerify /*= TRUE*/)
// Description: Execute a debugging operation and verify success.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: stepfcn A pointer to a function in UIWBFrame that takes an int. This parameter specifies the debugging operation to perform: 	Go, Restart, StopDebugging, Break, StepInto, StepOver, StepOut, StepToCursor, ToggleBreakpoint.
// Param: count An integer that contains the number of times to perform this debugging operation. (Default value is 1.)
// Param: symbol A pointer to a string that contains the symbol to expect at the current line when the debugging operation is complete. NULL means don't verify based on symbol name. (Default value is NULL.)
// Param: line A pointer to a string that contains the text of the line to expect at the current line when the debugging operation is complete. NULL means don't verify based on line text. (Default value is NULL.)
// Param: function A pointer to a string that contains the function name to expect when the debugging operation is complete. NULL means don't verify based on function name. (Default value is NULL.)
// Param: WAIT A value that specifies how to wait for the debugging operation to complete: NOWAIT, WAIT_FOR_RUN, WAIT_FOR_BREAK, WAIT_FOR_TERMINATION, ASSUME_NORMAL_TERMINATION, WAIT_FOR_EXCEPTION, WAIT_FOR_CODED_BREAK. (Default value is WAIT_FOR_BREAK.)
// Param: ModeVerify A Boolean value that is unused. This parameter is NYI. (Default value is TRUE.)
// END_HELP_COMMENT
BOOL CODebug::Exec(BOOL (UIWBFrame::*stepfcn)(int), int count, LPCSTR symbol, LPCSTR line, LPCSTR function, int WAIT, int ModeVerify)
	{	
	BOOL success = TRUE;
	if (!MyIsActive()) return FALSE;

	DirtyStack();

	if((WAIT == NOWAIT) && (line || function || symbol || (count > 1)))
		{
		WAIT = WAIT_FOR_BREAK;
		LOG->RecordInfo("WARNING: exec with verification attempted without\n"
						"waiting for break. your wait param was overridden\n"
						"to prevent timing problems on fast machines.");
		}

	Sleep(200);

	for(int i = 0; i < count; i++)
		{
		if (! (UIWB.*stepfcn)(WAIT) ) return FALSE;
		};
	if ((line) && (!VerifyCurrentLine(line)))
		success = FALSE;
	
	if ((function) && (!cos.VerifyCurrentFunction(function)))
		success = FALSE;

	if ((symbol) && (!VerifyAtSymbol(symbol)))
		success = FALSE;

	return success;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::ExecUntilLine(BOOL (UIWBFrame::*stepfcn)(int), LPCSTR line, LPCSTR function /*= NULL*/, int WAIT /*= WAIT_FOR_BREAK*/)
// Description: Execute a debugging operation until the specified line is hit.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: stepfcn A pointer to a function in UIWBFrame that takes an int. This parameter specifies the debugging operation to perform: 	Go, Restart, StopDebugging, Break, StepInto, StepOver, StepOut, StepToCursor, ToggleBreakpoint.
// Param: line A pointer to a string that contains the text of the line to be found that will end the debugging operation.
// Param: function A pointer to a string that contains the function name that contains the line to wait for. This parameter augments line. NULL means only look for the given line. (Default value is NULL.)
// Param: WAIT A value that specifies how to wait for the debugging operation to complete: NOWAIT, WAIT_FOR_RUN, WAIT_FOR_BREAK, WAIT_FOR_TERMINATION, ASSUME_NORMAL_TERMINATION, WAIT_FOR_EXCEPTION, WAIT_FOR_CODED_BREAK. (Default value is WAIT_FOR_BREAK.)
// END_HELP_COMMENT
BOOL CODebug::ExecUntilLine(BOOL (UIWBFrame::*stepfcn)(int), LPCSTR line, LPCSTR function, int WAIT)	// REVIEW set limit?
	{									
	BOOL success = TRUE;
	if (!MyIsActive()) return FALSE;
	DirtyStack();
	if (!ValidateSteppingMode(GetSteppingMode())) return FALSE;

	if(WAIT == NOWAIT)
		{
		WAIT = WAIT_FOR_BREAK;
		LOG->RecordInfo("WARNING: exec until operation attempted without\n"
						"waiting for break. your wait param was overridden\n"
						"to prevent timing problems on fast machines.");
		}

	while(!(CurrentLineIs(line) && (cos.CurrentFunctionIs(function) || !function)))
		{
		if (! (UIWB.*stepfcn)(WAIT) ) return FALSE;
		}
	return success;
	}
			

// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::ExecUntilFunc(BOOL (UIWBFrame::*stepfcn)(int), LPCSTR function, int WAIT /*= WAIT_FOR_BREAK*/)
// Description: Execute a debugging operation until the specified function is entered.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: stepfcn A pointer to a function in UIWBFrame that takes an int. This parameter specifies the debugging operation to perform: 	Go, Restart, StopDebugging, Break, StepInto, StepOver, StepOut, StepToCursor, ToggleBreakpoint.
// Param: function A pointer to a string that contains the function name to be found that will end the debugging operation.
// Param: WAIT A value that specifies how to wait for the debugging operation to complete: NOWAIT, WAIT_FOR_RUN, WAIT_FOR_BREAK, WAIT_FOR_TERMINATION, ASSUME_NORMAL_TERMINATION, WAIT_FOR_EXCEPTION, WAIT_FOR_CODED_BREAK. (Default value is WAIT_FOR_BREAK.)
// END_HELP_COMMENT
BOOL CODebug::ExecUntilFunc(BOOL (UIWBFrame::*stepfcn)(int), LPCSTR function, int WAIT)	//REVIEW: set limit?
	{									
	BOOL success = TRUE;
	if (!MyIsActive()) return FALSE;
	DirtyStack();
	if (!ValidateSteppingMode(GetSteppingMode())) return FALSE;
	CString curfunc = cos.GetFunction();

	// exec operations without waiting for break causes timing problems
	if(WAIT == NOWAIT)
		{
		WAIT = WAIT_FOR_BREAK;
		LOG->RecordInfo("WARNING: exec until operation attempted without\n"
						"waiting for break. your wait param was overridden\n"
						"to prevent timing problems on fast machines.");
		}

	while(!(cos.CurrentFunctionIs(function) || (!function && !cos.CurrentFunctionIs(curfunc))))
		{
		if (! (UIWB.*stepfcn)(WAIT) ) return FALSE;
		}
	
	return success;
	}

// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::ExecUntilSymbol(BOOL (UIWBFrame::*stepfcn)(int), LPCSTR symbol, int WAIT)
// Description: Execute a debugging operation until the specified symbol is found at the current line.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: stepfcn A pointer to a function in UIWBFrame that takes an int. This parameter specifies the debugging operation to perform: 	Go, Restart, StopDebugging, Break, StepInto, StepOver, StepOut, StepToCursor, ToggleBreakpoint.
// Param: symbol A pointer to a string that contains the symbol name to be found that will end the debugging operation.
// Param: WAIT A value that specifies how to wait for the debugging operation to complete: NOWAIT, WAIT_FOR_RUN, WAIT_FOR_BREAK, WAIT_FOR_TERMINATION, ASSUME_NORMAL_TERMINATION, WAIT_FOR_EXCEPTION, WAIT_FOR_CODED_BREAK. (Default value is WAIT_FOR_BREAK.)
// END_HELP_COMMENT
BOOL CODebug::ExecUntilSymbol(BOOL (UIWBFrame::*stepfcn)(int), LPCSTR symbol, int WAIT)
	{									
	BOOL success = TRUE;
	if (!MyIsActive()) return FALSE;
	DirtyStack();
	if (!ValidateSteppingMode(GetSteppingMode())) return FALSE;

	// multiple exec operations without waiting for break causes timing problems
	// exec operations without waiting for break causes timing problems
	if(WAIT == NOWAIT)
		{
		WAIT = WAIT_FOR_BREAK;
		LOG->RecordInfo("WARNING: exec until operation attempted without\n"
						"waiting for break. your wait param was overridden\n"
						"to prevent timing problems on fast machines.");
		}

	while(!(AtSymbol(symbol)))
		{
		if (! (UIWB.*stepfcn)(WAIT) ) return FALSE;
		}
	return success;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::Go(LPCSTR symbol, LPCSTR line /*= NULL*/, LPCSTR function /*= NULL*/, int WAIT /*= WAIT_FOR_BREAK*/)
// Description: Perform the Go debugging operation and verify the correct line/function is entered when the operation is complete.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: symbol A pointer to a string that contains the symbol to expect at the current line when the Go operation is complete.
// Param: line A pointer to a string that contains the text of the line to expect at the current line when the Go operation is complete. NULL means don't verify based on line text. (Default value is NULL.)
// Param: function A pointer to a string that contains the function name to expect when the Go operation is complete. NULL means don't verify based on function name. (Default value is NULL.)
// Param: WAIT A value that specifies how to wait for the debugging operation to complete: NOWAIT, WAIT_FOR_RUN, WAIT_FOR_BREAK, WAIT_FOR_TERMINATION, ASSUME_NORMAL_TERMINATION, WAIT_FOR_EXCEPTION, WAIT_FOR_CODED_BREAK. (Default value is WAIT_FOR_BREAK.)
// END_HELP_COMMENT
BOOL CODebug::Go(LPCSTR symbol, LPCSTR line /* 0 */, LPCSTR function /* NULL */, int WAIT)
	{
		return Exec(&UIWBFrame::Go, 1, symbol , line, function, WAIT, FALSE);
	};


// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::Restart(LPCSTR path /*= NULL*/)
// Description: Perform the Restart debugging operation.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: path A pointer to a string that contains the path to the source files. (Default value is NULL.)
// END_HELP_COMMENT
BOOL CODebug::Restart(LPCSTR path /* NULL */)
{
	DirtyStack();
	// if a file path was specified, we are expecting the find source dlg & want to handle it
	if(path)
		UIWB.m_pTarget->SetHandleMsgs(FALSE);

	if (!UIWB.Restart(WAIT_FOR_BREAK)) 
	{
		UIWB.m_pTarget->SetHandleMsgs(TRUE);
		return FALSE;
	}
	if(path)
	{
		UIDialog fs(GetLocString(IDSS_FS_TITLE));	// "Find Source" dialog
		if( fs.WaitAttachActive(5000) )			// REVIEW: is 5 seconds enough?
		{
			if (path)
			{
				MST.DoKeys(path,TRUE);
				fs.OK();
				fs.WaitUntilGone(1000);
			}
			UIWB.m_pTarget->SetHandleMsgs(TRUE);
			return TRUE;
		}
	}
	// no find source dialog  (but if we specified path, then FAIL)
	UIWB.m_pTarget->SetHandleMsgs(TRUE);
	return (path==NULL);
}


// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::StopDebugging(int WAIT /*= ASSUME_NORMAL_TERMINATION*/)
// Description: Perform the Stop Debugging debugging operation.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: WAIT A value that specifies how to wait for the debugging operation to complete: NOWAIT, WAIT_FOR_RUN, WAIT_FOR_BREAK, WAIT_FOR_TERMINATION, ASSUME_NORMAL_TERMINATION, WAIT_FOR_EXCEPTION, WAIT_FOR_CODED_BREAK. (Default value is ASSUME_NORMAL_TERMINATION.)
// END_HELP_COMMENT
BOOL CODebug::StopDebugging(int WAIT)		
{
	if (!MyIsActive()) return FALSE;
	Sleep(1000);
	UINT state = UIWB.GetIDEState();
	if((state & ST_DEBUGRUN) || (state & ST_DEBUGBREAK))
	{
		return (UIWB.StopDebugging(WAIT));
	}
	else
	{
		LOG->RecordInfo( (LPCSTR) "Called Stop debugging when not currently debugging");
		return (UIWB.StopDebugging(WAIT));
	}
}


// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::Break()
// Description: Perform the Break debugging operation.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL CODebug::Break()
{
	return (UIWB.Break(WAIT_FOR_BREAK));
}


// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::StepInto(int count /* 1 */, LPCSTR symbol /* NULL */, LPCSTR line /* NULL */, LPCSTR function /* NULL */, int WAIT)
// Description: Perform the Step Into debugging operation and verify the correct line/function/symbol is entered when the operation is complete.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: count An integer that contains the number of times to perform this debugging operation. (Default value is 1.)
// Param: symbol A pointer to a string that contains the symbol to expect at the current line when the Step Into operation is complete. NULL means don't verify based on symbol name. (Default value is NULL.)
// Param: line A pointer to a string that contains the text of the line to expect at the current line when the Step Into operation is complete. NULL means don't verify based on line text. (Default value is NULL.)
// Param: function A pointer to a string that contains the function name to expect when the Step Into operation is complete. NULL means don't verify based on function name. (Default value is NULL.)
// Param: WAIT A value that specifies how to wait for the debugging operation to complete: NOWAIT, WAIT_FOR_RUN, WAIT_FOR_BREAK, WAIT_FOR_TERMINATION, ASSUME_NORMAL_TERMINATION, WAIT_FOR_EXCEPTION, WAIT_FOR_CODED_BREAK. (Default value is WAIT_FOR_BREAK.)
// END_HELP_COMMENT
BOOL CODebug::StepInto(int count /* 1 */, LPCSTR symbol /* NULL */, LPCSTR line /* NULL */, LPCSTR function /* NULL */, int WAIT)
	{
		return Exec(&UIWBFrame::StepInto, count, symbol , line, function, WAIT);
	};

// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::StepIntoUntilLine(LPCSTR line, LPCSTR function /* NULL */, int WAIT /*= WAIT_FOR_BREAK*/)
// Description: Perform the Step Into debugging operation until the specified line/function is entered.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: line A pointer to a string that contains the text of the line to step into until reached.
// Param: function A pointer to a string that contains the function name that contains the line to wait for. This parameter augments line. NULL means only look for the given line. (Default value is NULL.)
// Param: WAIT A value that specifies how to wait for the debugging operation to complete: NOWAIT, WAIT_FOR_RUN, WAIT_FOR_BREAK, WAIT_FOR_TERMINATION, ASSUME_NORMAL_TERMINATION, WAIT_FOR_EXCEPTION, WAIT_FOR_CODED_BREAK. (Default value is WAIT_FOR_BREAK.)
// END_HELP_COMMENT
BOOL CODebug::StepIntoUntilLine(LPCSTR line, LPCSTR function /* NULL */, int WAIT)
	{
		return ExecUntilLine(&UIWBFrame::StepInto, line, function, WAIT);
	};

// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::StepIntoUntilFunc(LPCSTR function /* NULL */, int WAIT /*= WAIT_FOR_BREAK*/)
// Description: Perform the Step Into debugging operation until the specified function is entered.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: function A pointer to a string that contains the function name to be found that will end the step into operation.
// Param: WAIT A value that specifies how to wait for the debugging operation to complete: NOWAIT, WAIT_FOR_RUN, WAIT_FOR_BREAK, WAIT_FOR_TERMINATION, ASSUME_NORMAL_TERMINATION, WAIT_FOR_EXCEPTION, WAIT_FOR_CODED_BREAK. (Default value is WAIT_FOR_BREAK.)
// END_HELP_COMMENT
BOOL CODebug::StepIntoUntilFunc(LPCSTR function /* NULL */, int WAIT)
	{
		return ExecUntilFunc(&UIWBFrame::StepInto, function, WAIT);
	};

// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::StepIntoUntilSymbol(LPCSTR symbol, int WAIT /*= WAIT_FOR_BREAK*/)
// Description: Perform the Step Into debugging operation until the specified symbol is reached.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: symbol A pointer to a string that contains the symbol name to be found that will end the step into operation.
// Param: WAIT A value that specifies how to wait for the debugging operation to complete: NOWAIT, WAIT_FOR_RUN, WAIT_FOR_BREAK, WAIT_FOR_TERMINATION, ASSUME_NORMAL_TERMINATION, WAIT_FOR_EXCEPTION, WAIT_FOR_CODED_BREAK. (Default value is WAIT_FOR_BREAK.)
// END_HELP_COMMENT
BOOL CODebug::StepIntoUntilSymbol(LPCSTR symbol, int WAIT)
	{
		return ExecUntilSymbol(&UIWBFrame::StepInto, symbol, WAIT);
	};


// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::StepOver(int count /* 1 */, LPCSTR symbol /* NULL */, LPCSTR line /* NULL */, LPCSTR function /* NULL */, int WAIT)
// Description: Perform the Step Over debugging operation and verify the correct line/function/symbol is entered when the operation is complete.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: count An integer that contains the number of times to perform this debugging operation. (Default value is 1.)
// Param: symbol A pointer to a string that contains the symbol to expect at the current line when the Step Over operation is complete. NULL means don't verify based on symbol name. (Default value is NULL.)
// Param: line A pointer to a string that contains the text of the line to expect at the current line when the Step Over operation is complete. NULL means don't verify based on line text. (Default value is NULL.)
// Param: function A pointer to a string that contains the function name to expect when the Step Over operation is complete. NULL means don't verify based on function name. (Default value is NULL.)
// Param: WAIT A value that specifies how to wait for the debugging operation to complete: NOWAIT, WAIT_FOR_RUN, WAIT_FOR_BREAK, WAIT_FOR_TERMINATION, ASSUME_NORMAL_TERMINATION, WAIT_FOR_EXCEPTION, WAIT_FOR_CODED_BREAK. (Default value is WAIT_FOR_BREAK.)
// END_HELP_COMMENT
BOOL CODebug::StepOver(int count /* 1 */, LPCSTR symbol /* NULL */, LPCSTR line /* NULL */, LPCSTR function /* NULL */, int WAIT)
	{
		return Exec(&UIWBFrame::StepOver, count, symbol , line, function, WAIT);
	};

// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::StepOverUntilLine(LPCSTR line, LPCSTR function /* NULL */, int WAIT)
// Description: Perform the Step Over debugging operation until the specified line/function is entered.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: line A pointer to a string that contains the text of the line to be found that will end the step over operation.
// Param: function A pointer to a string that contains the function name that contains the line to wait for. This parameter augments line. NULL means only look for the given line. (Default value is NULL.)
// Param: WAIT A value that specifies how to wait for the debugging operation to complete: NOWAIT, WAIT_FOR_RUN, WAIT_FOR_BREAK, WAIT_FOR_TERMINATION, ASSUME_NORMAL_TERMINATION, WAIT_FOR_EXCEPTION, WAIT_FOR_CODED_BREAK. (Default value is WAIT_FOR_BREAK.)
// END_HELP_COMMENT
BOOL CODebug::StepOverUntilLine(LPCSTR line, LPCSTR function /* NULL */, int WAIT)
	{
		return ExecUntilLine(&UIWBFrame::StepOver, line, function, WAIT);
	};

// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::StepOverUntilFunc(LPCSTR function /* NULL */, int WAIT)
// Description: Perform the Step Over debugging operation until the specified function is entered.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: function A pointer to a string that contains the function name to be found that will end the step over operation.
// Param: WAIT A value that specifies how to wait for the debugging operation to complete: NOWAIT, WAIT_FOR_RUN, WAIT_FOR_BREAK, WAIT_FOR_TERMINATION, ASSUME_NORMAL_TERMINATION, WAIT_FOR_EXCEPTION, WAIT_FOR_CODED_BREAK. (Default value is WAIT_FOR_BREAK.)
// END_HELP_COMMENT
BOOL CODebug::StepOverUntilFunc(LPCSTR function /* NULL */, int WAIT)
	{
		return ExecUntilFunc(&UIWBFrame::StepOver, function, WAIT);
	};

// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::StepOverUntilSymbol(LPCSTR symbol, int WAIT)
// Description: Perform the Step Over debugging operation until the specified symbol is reached.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: symbol A pointer to a string that contains the symbol name to be found that will end the step over operation.
// Param: WAIT A value that specifies how to wait for the debugging operation to complete: NOWAIT, WAIT_FOR_RUN, WAIT_FOR_BREAK, WAIT_FOR_TERMINATION, ASSUME_NORMAL_TERMINATION, WAIT_FOR_EXCEPTION, WAIT_FOR_CODED_BREAK. (Default value is WAIT_FOR_BREAK.)
// END_HELP_COMMENT
BOOL CODebug::StepOverUntilSymbol(LPCSTR symbol, int WAIT)
	{
		return ExecUntilSymbol(&UIWBFrame::StepOver, symbol, WAIT);
	};


// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::StepOut(int count /* 1 */, LPCSTR symbol /* NULL */, LPCSTR line /* NULL */, LPCSTR function /* NULL */, int WAIT)
// Description: Perform the Step Out debugging operation and verify the correct line/function/symbol is entered when the operation is complete.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: count An integer that contains the number of times to perform this debugging operation. (Default value is 1.)
// Param: symbol A pointer to a string that contains the symbol to expect at the current line when the Step Out operation is complete. NULL means don't verify based on symbol name. (Default value is NULL.)
// Param: line A pointer to a string that contains the text of the line to expect at the current line when the Step Out operation is complete. NULL means don't verify based on line text. (Default value is NULL.)
// Param: function A pointer to a string that contains the function name to expect when the Step Out operation is complete. NULL means don't verify based on function name. (Default value is NULL.)
// Param: WAIT A value that specifies how to wait for the debugging operation to complete: NOWAIT, WAIT_FOR_RUN, WAIT_FOR_BREAK, WAIT_FOR_TERMINATION, ASSUME_NORMAL_TERMINATION, WAIT_FOR_EXCEPTION, WAIT_FOR_CODED_BREAK. (Default value is WAIT_FOR_BREAK.)
// END_HELP_COMMENT
BOOL CODebug::StepOut(int count /* 1 */, LPCSTR symbol /* NULL */, LPCSTR line /* NULL */, LPCSTR function /* NULL */, int WAIT)
	{
		return Exec(&UIWBFrame::StepOut, count, symbol , line, function, WAIT);
	};

// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::StepOutUntilLine(LPCSTR line, LPCSTR function /* NULL */, int WAIT)
// Description: Perform the Step Out debugging operation until the specified line/function is entered.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: line A pointer to a string that contains the text of the line to be found that will end the step out operation.
// Param: function A pointer to a string that contains the function name that contains the line to wait for. This parameter augments line. NULL means only look for the given line. (Default value is NULL.)
// Param: WAIT A value that specifies how to wait for the debugging operation to complete: NOWAIT, WAIT_FOR_RUN, WAIT_FOR_BREAK, WAIT_FOR_TERMINATION, ASSUME_NORMAL_TERMINATION, WAIT_FOR_EXCEPTION, WAIT_FOR_CODED_BREAK. (Default value is WAIT_FOR_BREAK.)
// END_HELP_COMMENT
BOOL CODebug::StepOutUntilLine(LPCSTR line, LPCSTR function /* NULL */, int WAIT)	//REVIEW: set limit?
	{
		return ExecUntilLine(&UIWBFrame::StepOut, line, function, WAIT);
	};

// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::StepOutUntilFunc(LPCSTR function /* NULL */, int WAIT)
// Description: Perform the Step Out debugging operation until the specified function is entered.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: function A pointer to a string that contains the function name to be found that will end the step out operation.
// Param: WAIT A value that specifies how to wait for the debugging operation to complete: NOWAIT, WAIT_FOR_RUN, WAIT_FOR_BREAK, WAIT_FOR_TERMINATION, ASSUME_NORMAL_TERMINATION, WAIT_FOR_EXCEPTION, WAIT_FOR_CODED_BREAK. (Default value is WAIT_FOR_BREAK.)
// END_HELP_COMMENT
BOOL CODebug::StepOutUntilFunc(LPCSTR function /* NULL */, int WAIT)
	{
		return ExecUntilFunc(&UIWBFrame::StepOut, function, WAIT);
	};

// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::StepOutUntilSymbol(LPCSTR symbol, int WAIT)
// Description: Perform the Step Out debugging operation until the specified symbol is reached.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: symbol A pointer to a string that contains the symbol name to be found that will end the step out operation.
// Param: WAIT A value that specifies how to wait for the debugging operation to complete: NOWAIT, WAIT_FOR_RUN, WAIT_FOR_BREAK, WAIT_FOR_TERMINATION, ASSUME_NORMAL_TERMINATION, WAIT_FOR_EXCEPTION, WAIT_FOR_CODED_BREAK. (Default value is WAIT_FOR_BREAK.)
// END_HELP_COMMENT
BOOL CODebug::StepOutUntilSymbol(LPCSTR symbol, int WAIT)
	{
		return ExecUntilSymbol(&UIWBFrame::StepOut, symbol, WAIT);
	};


// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::StepToCursor(int linepos /* 0 */, LPCSTR symbol /* NULL */, LPCSTR line /* NULL */, LPCSTR function /* NULL */, int WAIT /*WAIT_FOR_BREAK*/)
// Description: Perform the Step To Cursor debugging operation and verify the correct line/function/symbol is entered when the operation is complete.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: linepos An integer that contains the line to position the cursor on before performing the Step To Cursor operation. 0 means use the current line. (Default is 0.)
// Param: symbol A pointer to a string that contains the symbol to expect at the current line when the Step To Cursor operation is complete. NULL means don't verify based on symbol name. (Default value is NULL.)
// Param: line A pointer to a string that contains the text of the line to expect at the current line when the Step To Cursor operation is complete. NULL means don't verify based on line text. (Default value is NULL.)
// Param: function A pointer to a string that contains the function name to expect when the Step To Cursor operation is complete. NULL means don't verify based on function name. (Default value is NULL.)
// Param: WAIT A value that specifies how to wait for the debugging operation to complete: NOWAIT, WAIT_FOR_RUN, WAIT_FOR_BREAK, WAIT_FOR_TERMINATION, ASSUME_NORMAL_TERMINATION, WAIT_FOR_EXCEPTION, WAIT_FOR_CODED_BREAK. (Default value is WAIT_FOR_BREAK.)
// END_HELP_COMMENT
BOOL CODebug::StepToCursor(int linepos /* 0 */, LPCSTR symbol /* NULL */, LPCSTR line /* NULL */, LPCSTR function /* NULL */, int WAIT /*WAIT_FOR_BREAK*/)
	{
		COSource src;

	if(linepos)
	{
// REVIEW(briancr): this is obsolete code
//		if (!UIWB.GoToLine(linepos)) return FALSE;
		if (!src.GoToLine(linepos)) {
			return FALSE;
		}
	};
	return Exec(&UIWBFrame::StepToCursor, 1, symbol , line, function, WAIT, FALSE);
	};

// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::AttachToProcess(LPCSTR szProcessName, int WAIT /*WAIT_FOR_RUN*/, BOOL bSysProcess /*FALSE*/)
// Description: Attaches the debugger to a specified process via the Attach To Process dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: szProcessName A pointer to a string specifying the name of the process to attach to (without the .EXE extension).
// Param: WAIT A value that specifies how to wait for the debugging operation to complete: NOWAIT, WAIT_FOR_RUN, WAIT_FOR_BREAK, WAIT_FOR_TERMINATION, ASSUME_NORMAL_TERMINATION, WAIT_FOR_EXCEPTION, WAIT_FOR_CODED_BREAK. (Default value is WAIT_FOR_RUN.)
// Param: bSysProcess A Boolean that indicates if szProcessName is system process. If true, Show System Processes checkbox is set in the Attach To Process dialog
// END_HELP_COMMENT

BOOL CODebug::AttachToProcess(LPCSTR szProcessName, int WAIT /*WAIT_FOR_RUN*/, BOOL bSysProcess /*FALSE*/)

{
	char szThisFunc[] = "CODebug::AttachToProcess";
	UIAttachToProcessDlg uiattach;

	// activate the Attach To Process dlg.
	if(!uiattach.Activate())
	{
		LOG->RecordInfo("ERROR in %s: couldn't activate Attach To Process dlg.", szThisFunc);
		return FALSE;
	}

	// toggle display of the system processes appropriately.
	if(!uiattach.ShowSystemProcesses(bSysProcess))
	{
		LOG->RecordInfo("ERROR in %s: couldn't toggle display of system processes.", szThisFunc);
		uiattach.Cancel();
		return FALSE;
	}
	
	// select the process.
	if(!uiattach.SelectProcess(szProcessName))
	{
		LOG->RecordInfo("ERROR in %s: couldn't select the '%s' process.", szThisFunc, szProcessName);
		uiattach.Cancel();
		return FALSE;
	}

	// ok the Attach To Process dlg.
	if(uiattach.OK() != NULL)
	{
		LOG->RecordInfo("ERROR in %s: couldn't OK Attach To Process dlg.", szThisFunc);
		return FALSE;
	}

	return Wait(WAIT);
}


// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::SetNextStatement(int line /* 0 */)
// Description: Set the next statement (IP) to the given line.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: line An integer that contains the line to set the next statement to. 0 means use the current line. (Default value is 0.)
// END_HELP_COMMENT
BOOL CODebug::SetNextStatement(int line /* 0 */)		// REVIEW: check for non-zero line number?
	{
		COSource src;

	if(line>0)
	{
// REVIEW(briancr): this is obsolete code
//		if (!UIWB.GoToLine(line)) return FALSE;
		if (!src.GoToLine(line)) {
			return FALSE;
		}
	};
	DirtyStack();
	return UIWB.SetNextStatement();
	}


// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::SetNextStatement(LPCSTR line)
// Description: Set the next statement (IP) to the given line.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: line A pointer to a string that contains the line to set the next statement to. NULL means use the current line. (Default value is NULL.)
// END_HELP_COMMENT
BOOL CODebug::SetNextStatement(LPCSTR line)		//TODO: use UIFind class
{
	COSource src;

	if(line) 	// if line is NULL  use current line
	{
		if (*line == '@')  // handle "@23" for line number 23
// REVIEW(briancr): this is obsolete code
//			if (!UIWB.GoToLine( atoi((line+1)) )) return FALSE;
			if (!src.GoToLine(atoi(line+1))) {
				return FALSE;
			}
		else
// REVIEW(briancr): this is obsolete code
//			if (!UIWB.GoToLine(line)) return FALSE;
			if (!src.GoToLine(line)) {
				return FALSE;
			}
	};
	DirtyStack();
	return (UIWB.SetNextStatement());
};


// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::ShowNextStatement(void)
// Description: Go to the next statement to be executed by the debugger.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL CODebug::ShowNextStatement(void) 
{
	WaitStepInstructions("Sending keys '%({NUMPAD*})'");
	keybd_event(VK_MENU, 0,0,0);
	keybd_event(VK_MULTIPLY, 0,0,0);
	keybd_event(VK_MULTIPLY, 0,KEYEVENTF_KEYUP,0);
	keybd_event(VK_MENU, 0,KEYEVENTF_KEYUP,0);
	// give the ide a half-second to update the cursor. if we return too soon then menu items might be grayed when we expect them to be enabled.
	Sleep(500);
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: DebugState CODebug::GetDebugState(void)
// Description: Get the state of the debugger.
// Return: A DebugState value that indicates the state of the debugger: ST_NODEBUG, ST_DEBUGBREAK, ST_DEBUGRUN.
// END_HELP_COMMENT
DebugState CODebug::GetDebugState(void) {
    MyIsActive();
    UINT state = UIWB.GetIDEState();
    if (state & ST_NODEBUG)
        return NotDebugging;
    if (state & ST_DEBUGBREAK)
        return Debug_Break;
    if (state & ST_DEBUGRUN)
        return Debug_Run;
    // defualt
    return NotDebugging;
};

// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::Wait(int option, BOOL bLeaveFindSource /* FALSE */)
// Description: Wait for the current debugging operation to complete.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: option A value that specifies how to wait for the debugging operation to complete: NOWAIT, WAIT_FOR_RUN, WAIT_FOR_BREAK, WAIT_FOR_TERMINATION, ASSUME_NORMAL_TERMINATION, WAIT_FOR_EXCEPTION, WAIT_FOR_CODED_BREAK. (Default value is WAIT_FOR_BREAK.)
// Param: BOOL bLeaveFindSource A Boolean value indicated whether or not to leave the Find Source dlg up at the break.
// END_HELP_COMMENT
BOOL CODebug::Wait(int option, BOOL bLeaveFindSource /* FALSE */)
	{
	return UIWB.Wait(option, TRUE, bLeaveFindSource);
	}


// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::CurrentLineIs(LPCSTR line)		
// Description: Determine whether the current line in the debugger matches the line given.
// Return: A Boolean value that indicates whether the current line in the debugger matches the given line (TRUE) or not.
// Param: line A pointer to a string that contains either part of the text of the line expected or the line number specified by @line.
// END_HELP_COMMENT
BOOL CODebug::CurrentLineIs(LPCSTR line)		
{
	if (*line == '@') // handle "@23" for line number 23
		return ( UIWB.GetEditorCurPos(GECP_LINE) == atoi((line+1)) );
	else
		return ( UIWB.VerifySubstringAtLine(line) );
}


// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::VerifyCurrentLine(LPCSTR line)
// Description: Determine whether the current line in the debugger matches the line given.
// Return: A Boolean value that indicates whether the current line in the debugger matches the given line (TRUE) or not.
// Param: line A pointer to a string that contains either part of the text of the line expected or the line number specified by @line.
// END_HELP_COMMENT
BOOL CODebug::VerifyCurrentLine(LPCSTR line)
{
	if (*line == '@') // handle "@23" for line number 23
	{
		int actual_pos, expected_pos;
		actual_pos= UIWB.GetEditorCurPos(GECP_LINE);
		expected_pos= atoi((line+1));
		if (expected_pos==actual_pos)
			return TRUE;
		else
		{
			LOG->RecordInfo( (LPCSTR) "Current line is %d : expected %d", actual_pos, expected_pos);
			return FALSE;
		}
		
	}
	else
	{
		if ( UIWB.VerifySubstringAtLine(line) )
			return TRUE;
		else
		{
			LOG->RecordInfo( (LPCSTR) "Current line does not contain '%s'", line);
			return FALSE;
		}
	};
};


// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::AtSymbol(LPCSTR symbol)
// Description: Determine whether the current debugging location (IP) is at the given symbol.
// Return: A Boolean value that indicates whether the current debugging location (IP) is at the given symbol (TRUE) or not.
// Param: symbol A pointer to a string that contains the symbol.
// END_HELP_COMMENT
BOOL CODebug::AtSymbol(LPCSTR symbol)
{
	COExpEval coee;
	CString InstructionPtr;

#if defined( _M_MRX000 )
	InstructionPtr = "FIR";    	// MIPS specific

	//
	//	Variance is allowed for matching breakpoint at function for MIPS
	//	since it must set the breakpoint after the prolog.  Note that it
	//	possible for the prolog to be much greater but hopefully unlikely.
	//
	const CString AllowedVariance( "40" );	//	Arbitrary value for variance offset (bytes)

	CString expr = InstructionPtr + " >= " + symbol + " && " +
		InstructionPtr  + " - " + AllowedVariance + " <= " + symbol;
#elif defined(_M_ALPHA)
	InstructionPtr = "FIR";    	// ALPHA specific

	//
	//	Variance is allowed for matching breakpoint at function for ALPHA
	//	since it must set the breakpoint after the prolog.  Note that it
	//	possible for the prolog to be much greater but hopefully unlikely.
	//
	const CString AllowedVariance( "80" );	//	Arbitrary value for variance offset (bytes)

	CString expr = InstructionPtr + " >= " + symbol + " && " +
		InstructionPtr  + " - " + AllowedVariance + " <= " + symbol;
#else
	
	if((GetUserTargetPlatforms() == PLATFORM_MAC_68K) ||
	   (GetUserTargetPlatforms() == PLATFORM_MAC_PPC) ||
	   (GetUserTargetPlatforms() == PLATFORM_WIN32_PPC))
		InstructionPtr = "PC";
	else if((GetUserTargetPlatforms() == PLATFORM_WIN32_ALPHA))
		InstructionPtr = "PC";    	
	else if((GetUserTargetPlatforms() == PLATFORM_WIN32_X86) ||
			(GetUserTargetPlatforms() == PLATFORM_WIN32S_X86))
		InstructionPtr = "EIP";
	else
		{
		ASSERT(0);
		return FALSE;
		}		    	

	CString expr = InstructionPtr + " == " + symbol;
#endif
	return (coee.ExpressionValueIs(expr,TRUE));
};


// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::VerifyAtSymbol(LPCSTR symbol)
// Description: Determine whether the current debugging location (IP) is at the given symbol.
// Return: A Boolean value that indicates whether the current debugging location (IP) is at the given symbol (TRUE) or not.
// Param: symbol A pointer to a string that contains the symbol.
// END_HELP_COMMENT
BOOL CODebug::VerifyAtSymbol(LPCSTR symbol)
{
	if  (AtSymbol(symbol))
		return TRUE;
	else
	{
		LOG->RecordInfo( (LPCSTR) "Instruction Pointer not at Symbol '%s'", symbol);
		return FALSE;
	}
};


// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::VerifyTermination(int exitcode)
// Description: Determine whether the debuggee terminated with the specified exit code. (See VerifyTermination(void) to verify termination regardless of exit code.) This function is NYI.
// Return: A Boolean value that indicates whether the debuggee terminated with the specified exit code (TRUE) or not.
// Param: exitcode An integer that specifies the expected exit code.
// END_HELP_COMMENT
BOOL CODebug::VerifyTermination(int exitcode)
{
    // todo  check for specific termination code
    //       log warning only if code doesn't match
    return TRUE;
};


// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::VerifyTermination(void)
// Description: Determine whether the debuggee terminated. (See VerifyTermination(int) to verify termination with a specific exit code.) This function is NYI.
// Return: A Boolean value that indicates whether the debuggee terminated (TRUE) or not.
// END_HELP_COMMENT
BOOL CODebug::VerifyTermination(void)          //any exitcode
{
    // todo check for ANY termination
    //        don't log warning
    return TRUE;
};


// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::SetSteppingMode(StepMode mode)
// Description: Set the stepping mode in the debugger.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: mode A StepMode value that indicates the stepping mode: SRC, ASM.
// END_HELP_COMMENT
BOOL CODebug::SetSteppingMode(StepMode mode)
{
	BOOL success=TRUE;
	mMode = mode;

	if (GetDebugState() == NotDebugging)
		return success;  // bail-out but succeed if not debugging
	
	if (mode == SRC)	
	{
		UIDAM uidam;

		// find out what more we're in
		// emmang@xbox.com
		CString cstrCaption = "[";
		cstrCaption += GetLocString(IDSS_ASM_WND_TITLE) + "]";
		CString cstrFound;

		MST.WGetText(WGetActWnd(0), cstrFound);

		// if we're in asm mode, switch to source using hotkey. else just show the next statement in source mode.
		//if(uidam.AttachActive())
		if (cstrFound.Find(cstrCaption) != -1)
		{
			LOG->RecordInfo("SetSteppingMode(%d) : uidam.AttachActive() == TRUE, calling uidam.SwitchBetweenASMAndSrc()", mode);
			uidam.SwitchBetweenASMAndSRC(FALSE);
		}
		else
			ShowNextStatement();

		mMode = mode;
	}
	else if (mode == ASM)
	{
		UIDebug::ShowDockWindow(IDW_DISASSY_WIN); // focus to dam
		mMode = mode;
	}
	else
	{
		LOG->RecordInfo( (LPCSTR) "Stepping Mode, %d is not valid", mode);
		success=FALSE;
	};
	return success;
};

// BEGIN_HELP_COMMENT
// Function: StepMode CODebug::GetSteppingMode(void)
// Description: Get the current stepping mode in the debugger.
// Return: A StepMode value that indicates the current stepping mode: SRC, ASM.
// END_HELP_COMMENT
StepMode CODebug::GetSteppingMode(void)
{
	return mMode;
};

// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::ValidateSteppingMode(StepMode mode)
// Description: Determine whether the current stepping mode matches the given stepping mode.
// Return: A Boolean value that indicates whether the current stepping mode matches the given stepping mode (TRUE) or not.
// Param: mode A StepMode value that contains the expected stepping mode: SRC, ASM.
// END_HELP_COMMENT
BOOL CODebug::ValidateSteppingMode(StepMode mode)
{
	// todo be smarter here and check before re-setting each time
	return SetSteppingMode(mode);
};

// code reminant from old cafe sniff tests
// although not portable  may be very useful
// todo: review the implementation.

// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::DoDebuggeeKeys(CString str)
// Description: Perform the given keystrokes in the debuggee. This code is not portable and should be used with extreme caution.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: str A CString that contains the title, class, and keystrokes to send to the debuggee. The form is: Title#Class#Keys.
// END_HELP_COMMENT
BOOL CODebug::DoDebuggeeKeys(CString str)
{
	// Title#Class#Keys

	CString strTitle, strClass, strKeys;
	CTokenList listToken;

	// parse the parameters
	Parse(str, "#", listToken);
	strTitle = listToken.GetTokenString(0);
	strClass = listToken.GetTokenString(1);
	strKeys = listToken.GetTokenString(2);

	// give the debuggee focus
	if (MST.WFndWndC(strTitle, strClass, FW_NOCASE | FW_PART | FW_FOCUS) != NULL) {
		MST.DoKeys(strKeys);
		LOG->RecordInfo("Keystrokes '"+str+"' sent to debuggee");
		return (TRUE);
	}
	else {
		LOG->RecordInfo("Keystrokes '"+str+"' not sent to debuggee");
		return (FALSE);
	}
}


// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::DoDebuggeeCmd(CString str)
// Description: Perform the given command in the debuggee. This code is not portable and should be used with extreme caution.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: str A CString that contains the title, class, and command to send to the debuggee. The form is: Title#Class#Command.
// END_HELP_COMMENT
BOOL CODebug::DoDebuggeeCmd(CString str)
{
	// Title#Class#Command

	CString strTitle, strClass, strCmd;
	CTokenList listToken;
	HWND hwnd;

	// parse out the parameters
	Parse(str, "#", listToken);
	strTitle = listToken.GetTokenString(0);
	strClass = listToken.GetTokenString(1);
	strCmd = listToken.GetTokenString(2);

	// give the debuggee focus
	if ((hwnd = MST.WFndWndC(strTitle, strClass, FW_NOCASE | FW_PART | FW_FOCUS)) != NULL) {
		PostMessage(hwnd, WM_COMMAND, (WPARAM)atoi(strCmd), 0L);

	// wait for the IDE to enter break mode or display a msg box
/*	for (BOOL bDone = FALSE; !bDone; ) {
		MST.WFndWnd(GetLocString(IDSS_WORKBENCH_TITLEBAR), FW_PART | FW_NOCASE | FW_FOCUS);
		if (MST.WFndWndC(GetLocString(IDSS_WORKBENCH_TITLEBAR), "#32770", FW_PART | FW_NOCASE) != NULL) {
			bDone = TRUE;
		}
		UIWB.Activate();
		if (UIWB.GetIDEState() & ST_DEBUGBREAK) {
			bDone = TRUE;
		}
	} */
		Sleep(20000);
		LOG->RecordInfo("Command "+str+" sent to debuggee");
		return (TRUE);
	}
	else {
		LOG->RecordInfo("Command "+str+" not sent to debuggee");
		return (FALSE);
	}
}


BOOL CODebug::MyIsActive()
{
	if (!UIWB.IsActive())
	{
		UIWB.BlockingActivate();
	};
	return TRUE;
}

BOOL CODebug::SetOwnedStack( COStack* pStack ) {

	// Unlink previous owned stack
	if( m_pOwnedStack != NULL ) {
		ASSERT( m_pOwnedStack->m_pOwner == this );
		m_pOwnedStack->m_pOwner = NULL;
	}

	// Link new stack
	if( pStack != NULL ) {
		ASSERT( pStack->m_pOwner == NULL );

		pStack->m_pOwner = this;
	}

	m_pOwnedStack = pStack;
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::VerifyNotification(LPCSTR notification, int startLine /* 1 */, int numberOfLines /* 1 */)
// Description: Verifies any debugger output (substring).
// Return: TRUE if the notification substring is found at line, FALSE - if not
// Param: notification A pointer to a string that contains the substring to look for in the debugger output.
// Param: nOccurence An integer that specifies the 1-based number of occurence of the Substring in the Output window. (Default value is 1.)
// Old: Param: startLine An integer that specifies the 1-based line number in the Output window to start looking for the specified substring. (Default value is 1.)
// Param: numberOfLines An integer that specifies the number of lines to search (from startLine) for the substring. (Default value is 1.)
// Param: nCase A boolean: TRUE specifies case insensitive search. (Default value is FALSE.)
// END_HELP_COMMENT
BOOL CODebug::VerifyNotification(LPCSTR notification, int nOccurence /* 1 */, int numberOfLines /* 1 */, BOOL nCase /* FALSE */)
{
	UIDebug::ShowDockWindow(IDW_OUTPUT_WIN); // focus to Output wnd
	// REVIEW(michma - 6/4/99):
	// this timing problem is showing up on w2k. apparently the ^home isn't making it to the output window
	// because it doesn't have focus yet.
	Sleep(500);
	MST.DoKeys("^{home}");
	int counter = 0;

	for( int i = 0; i < numberOfLines; i++)
	{
		if( UIWB.VerifySubstringAtLine(notification, nCase) )
		{
			if( ++counter == nOccurence )
				return TRUE;
		}
		MST.DoKeys("{down}");
	}
	
	if( counter )
	{
		LOG->RecordInfo( (LPCSTR) "Only %d notification occurences were found", counter);
	}
	else
	{
		LOG->RecordInfo( (LPCSTR) "Notification was not found");
	}

	return FALSE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::HandleMsg(MSG_TYPE msg, LPCSTR pdata /* NULL */, int wait_time /* 60 */)
// Description: Waits for a specific msg box to be displayed, supplies the data requested, and continues
// Return: TRUE if the correct msg box comes up, the data is supplied, and the msg box is dismissed.  FALSE if any of those operations fail.
// Param: msg: a symbol representing the particular msg box to be handled.  current legal values are MSG_REMOTE_EXE_NAME_REQUIRED and MSG_REMOTE_LOCAL_EXE_MISMATCH
// Param: pdata: a pointer to the data that needs to be supplied to handle the message. the type of data depends on the msg being handled.  currently only MSG_REMOTE_EXE_NAME_REQUIRED uses data, and that is a string pointing to the remote path of the target.  the default data pointer is NULL.
// Param: wait_time: time in seconds to wait for msg box to be displayed. default is 60 seconds.
// END_HELP_COMMENT

BOOL CODebug::HandleMsg(MSG_TYPE msg, LPCSTR pdata /* NULL */, int wait_time /* 60 */)

{
	if(!WaitMsgDisplayed(msg, wait_time)) return FALSE;
	BOOL fDataSupplied = FALSE;
	CString str;

	switch(msg)
		
	{
		case MSG_REMOTE_EXE_NAME_REQUIRED:
		
		{
			MST.WEditSetText("@1", pdata);
			MST.WEditText("@1", str);
			
			if(!(str == CString(pdata)))
			{
				LOG->RecordInfo("ERROR in CODebug::HandleMsg(): "
								"data \"%s\" not supplied to msg box", (LPCSTR)pdata);
				return FALSE;
			}

			break;
		}

		default:
			break;
	}

	MST.DoKeys("{ENTER}");
	return WaitMsgDismissed(msg);
}
	

// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::CancelMsg(MSG_TYPE msg, int wait_time /* 60 */)
// Description: Waits for a specific msg box to be displayed and cancels it
// Return: TRUE if the correct msg box comes up and is canceled.  FALSE if either of those operations fail.
// Param: msg: a symbol representing the particular msg box to be handled.  current legal values are MSG_REMOTE_EXE_NAME_REQUIRED and MSG_REMOTE_LOCAL_EXE_MISMATCH
// Param: wait_time: time in seconds to wait for msg box to be displayed. default is 60 seconds.
// END_HELP_COMMENT

BOOL CODebug::CancelMsg(MSG_TYPE msg, int wait_time /* 60 */)
	{
	if(!WaitMsgDisplayed(msg, wait_time)) return FALSE;
	MST.DoKeys("{ESC}");
	return WaitMsgDismissed(msg);
	}


BOOL CODebug::WaitMsgDisplayed(MSG_TYPE msg, int wait_time)
	
	{
	if(!MST.WFndWndWaitC(GetLocString(msg_array[msg]), "Static", FW_PART, wait_time))
		
		{
		LOG->RecordInfo("ERROR in CODebug::WaitMsgDisplayed(): msg box containing \"%s\" not "
						"displayed after %d seconds", (LPCSTR)GetLocString(msg_array[msg]), wait_time);

		return FALSE;
		}

	return TRUE;
	}


BOOL CODebug::WaitMsgDismissed(MSG_TYPE msg)

	{
	int i = 0;
	
	while(MST.WFndWndWaitC(GetLocString(msg_array[msg]), "Static", FW_PART,1))
		
		{

		if(++i > 5)
			{
			LOG->RecordInfo("ERROR in CODebug::WaitMsgDismissed(): msg box containing \"%s\""
							"could not be dismissed", (LPCSTR)GetLocString(msg_array[msg]));

			return FALSE;
			}
		}

	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: int CODebug::ToggleReturnValue(TOGGLE_TYPE t)
// Description: Toggles the return values feature on and off.
// Return: Currently always returns TRUE.
// Param: t: a TOGGLE_TYPE value specifying to turn return values on (TOGGLE_ON) or off (TOGGLE_OFF).
// END_HELP_COMMENT

/* TODO (michma): add error checking. */
BOOL CODebug::ToggleReturnValue(TOGGLE_TYPE t)
	
	{
	UIOptionsTabDlg uiopt;
	uiopt.Display();
	uiopt.ShowPage(TAB_DEBUG, 6);
	
	if(t == TOGGLE_ON)
		MST.WCheckCheck(GetLocString(IDSS_OPT_DEBUG_RETURN_VALUE));
	else
 		MST.WCheckUnCheck(GetLocString(IDSS_OPT_DEBUG_RETURN_VALUE));

	uiopt.OK();
	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::ToggleEditAndContinue(TOGGLE_TYPE t)
// Description: Toggles EditAndContinue check box
// Return: 
// Param: t: Toggle type: TOGGLE_ON if box is to be checked; TOGGLE_OFF if box is to be unchecked  
// END_HELP_COMMENT

/* TODO (michma): add error checking. */
BOOL CODebug::ToggleEditAndContinue(TOGGLE_TYPE t)
	
	{
	UIOptionsTabDlg uiopt;
	uiopt.Display();
	uiopt.ShowPage(TAB_DEBUG, 6);
	
	if(t == TOGGLE_ON)
		MST.WCheckCheck(GetLocString(IDSS_OPT_DEBUG_EDIT_AND_CONTINUE));
	else
 		MST.WCheckUnCheck(GetLocString(IDSS_OPT_DEBUG_EDIT_AND_CONTINUE));

	uiopt.OK();
	return TRUE;
	}


// TODO(michma): RSLA dlg needs its own support layer class
// BEGIN_HELP_COMMENT
// Function: int CODebug::ResolveSourceLineAmbiguity(int iEntry)
// Description: waits for a "resolve source line ambiguity" message from the debugger, and resolves it.
// Return: BOOL returns TRUE if successful, FALSE if not.
// Param: iEntry: an int indicated which entry in the ambiguity list to select
// END_HELP_COMMENT
BOOL CODebug::ResolveSourceLineAmbiguity(int iEntry)
{
	
	// wait for the rsla dlg to be displayed
	if(!MST.WFndWndWait(GetLocString(IDSS_RSLA_DLG_TITLE), FW_DEFAULT, 5))
	{
		LOG->RecordInfo("ERROR: Resolve Source Line Ambiguity dlg not found");
		return FALSE;
	}

	// make sure the dlg has enough entries in it.
	if(MST.WListCount("") < iEntry)
	{
		LOG->RecordInfo("ERROR: Number of entries in RSLA dlg is less than %d", iEntry);
		return FALSE;
	}
	
	// choose the source line entry from the list box in the rsla dlg
	for(int i = 1; i < iEntry; i++)
		MST.DoKeys("{DOWN}");
	
	// ok the dlg
	MST.DoKeys("{ENTER}");

	// wait for the rsla dlg to be disappear
	if(!MST.WFndWndWait(GetLocString(IDSS_RSLA_DLG_TITLE), FW_DEFAULT | FW_NOEXIST, 5))
	{
		LOG->RecordInfo("ERROR: Resolve Source Line Ambiguity dlg still active");
		return FALSE;
	}
	
	return TRUE;
}


// TODO(michma): RA dlg has a class of its own in uibrowse.*.
// BEGIN_HELP_COMMENT
// Function: int CODebug::ResolveAmbiguity(int iEntry)
// Description: waits for a "resolve ambiguity" message from the debugger, and resolves it.
// Return: BOOL returns TRUE if successful, FALSE if not.
// Param: iEntry: an int indicated which entry in the ambiguity list to select
// END_HELP_COMMENT
BOOL CODebug::ResolveAmbiguity(int iEntry)
{
	
	// wait for the ra dlg to be displayed
	if(!MST.WFndWndWait(GetLocString(IDSS_RESOLVE_AMBIGUITY_TITLE), FW_DEFAULT, 5))
	{
		LOG->RecordInfo("ERROR: Resolve Ambiguity dlg not found");
		return FALSE;
	}

	// make sure the dlg has enough entries in it.
	if(MST.WListCount("") < iEntry)
	{
		LOG->RecordInfo("ERROR: Number of entries in RA dlg is less than %d", iEntry);
		return FALSE;
	}
	
	// choose the source line entry from the list box in the rsla dlg
	for(int i = 1; i < iEntry; i++)
		MST.DoKeys("{DOWN}");
	
	// ok the dlg
	MST.DoKeys("{ENTER}");

	// wait for the ra dlg to be disappear
	if(!MST.WFndWndWait(GetLocString(IDSS_RESOLVE_AMBIGUITY_TITLE), FW_DEFAULT | FW_NOEXIST, 5))
	{
		LOG->RecordInfo("ERROR: Resolve Ambiguity dlg still active");
		return FALSE;
	}
	
	return TRUE;
}

// TODO(michma): RA dlg has a class of its own in uibrowse.*.
// BEGIN_HELP_COMMENT
// Function: int CODebug::ResolveAmbiguity(LPCSTR szEntry)
// Description: waits for a "resolve ambiguity" message from the debugger, and resolves it.
// Return: BOOL returns TRUE if successful, FALSE if not.
// Param: szEntry: a string (partial allowed) indicating which entry in the ambiguity list to select.
// END_HELP_COMMENT
BOOL CODebug::ResolveAmbiguity(LPCSTR szEntry)
{
	
	// wait for the ra dlg to be displayed
	if(!MST.WFndWndWait(GetLocString(IDSS_RESOLVE_AMBIGUITY_TITLE), FW_DEFAULT, 5))
	{
		LOG->RecordInfo("ERROR: Resolve Ambiguity dlg not found");
		return FALSE;
	}

	CString strEntry;
	
	// iterate through each entry in the list box.
	for(int iEntry = 1; iEntry <= MST.WListCount(""); iEntry++)
	{
		// get the text for the entry.
		MST.WListItemText("", iEntry, strEntry);

		// see if it contains the specified text.
		if(strEntry.Find(szEntry) != -1)
			break;
	}

	// if we found a match, select it.
	if(iEntry <= MST.WListCount(""))
		MST.WListItemClk("", strEntry);
	
	// ok the dlg
	MST.DoKeys("{ENTER}");

	// wait for the ra dlg to be disappear
	if(!MST.WFndWndWait(GetLocString(IDSS_RESOLVE_AMBIGUITY_TITLE), FW_DEFAULT | FW_NOEXIST, 5))
	{
		LOG->RecordInfo("ERROR: Resolve Ambiguity dlg still active");
		return FALSE;
	}
	
	return TRUE;
}

// TODO(michma): RA dlg has a class of its own in uibrowse.*.
// BEGIN_HELP_COMMENT
// Function: int CODebug::ResolveSourceAmbiguity(LPCSTR szEntry)
// Description: waits for a "resolve source ambiguity" message from the debugger, and resolves it.
// Return: BOOL returns TRUE if successful, FALSE if not.
// Param: szEntry: a string (partial allowed) indicating which entry in the ambiguity list to select.
// END_HELP_COMMENT
BOOL CODebug::ResolveSourceLineAmbiguity(LPCSTR szEntry)
{
	
	// wait for the ra dlg to be displayed
	if(!MST.WFndWndWait(GetLocString(IDSS_RESOLVE_SOURCE_AMBIGUITY_TITLE), FW_DEFAULT, 5))
	{
		LOG->RecordInfo("ERROR: Resolve Ambiguity dlg not found");
		return FALSE;
	}

	CString strEntry;
	
	// iterate through each entry in the list box.
	for(int iEntry = 1; iEntry <= MST.WListCount(""); iEntry++)
	{
		// get the text for the entry.
		MST.WListItemText("", iEntry, strEntry);

		// see if it contains the specified text.
		if(strEntry.Find(szEntry) != -1)
			break;
	}

	// if we found a match, select it.
	if(iEntry <= MST.WListCount(""))
		MST.WListItemClk("", strEntry);
	
	// ok the dlg
	MST.DoKeys("{ENTER}");

	// wait for the ra dlg to be disappear
	if(!MST.WFndWndWait(GetLocString(IDSS_RESOLVE_SOURCE_AMBIGUITY_TITLE), FW_DEFAULT | FW_NOEXIST, 5))
	{
		LOG->RecordInfo("ERROR: Resolve Source Ambiguity dlg still active");
		return FALSE;
	}
	
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::SupplySourceLocation(LPCSTR path)
// Description: Supplys a source location to the debugger (assuming it is asking for one).
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: path A pointer to a string that contains the path to the source file.
// END_HELP_COMMENT
BOOL CODebug::SupplySourceLocation(LPCSTR path)

{
	//REVIEW(chriskoz) is handled by default by CTarget, 
	//so you must call UIWB.m_pTarget->SetHandleMsgs(FALSE) to handle it manually in this function
	//then call UIWB.m_pTarget->SetHandleMsgs(TRUE) to restore the automatic handling
	// set up the object for the Find Source dlg.
	UIDialog dlgFindSource(GetLocString(IDSS_FS_TITLE));

	// wait up to 3 seconds for Find Source dlg to come up.
	if(dlgFindSource.WaitAttachActive(3000))
	{
		// verify that it is the Find Source dlg.
		if(dlgFindSource.VerifyTitle() )
		{
			// enter the specified directory and close the dlg.
			MST.DoKeys(path);
			dlgFindSource.OK();
		}
		else
		{
			LOG->RecordInfo("ERROR in CODebug::SupplySourceLocation() - dlg other than Find Source came up");
			return FALSE;
		}
	}
	else
	{
		LOG->RecordInfo("ERROR in CODebug::SupplySourceLocation() - no dlg came up (expected Find Source)");
		return FALSE;
	}

	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: int CODebug::SetDebugOutputPane( int pane)
// Description: Set the current pane of the Output window to Debug.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: pane A value that specifies the pane to activate: IDSS_PANE_DEBUG_OUTPUT.
// END_HELP_COMMENT
int CODebug::SetDebugOutputPane(int pane)
{
	UIDebug::ShowDockWindow(IDW_OUTPUT_WIN); // focus to Output wnd

	char pane_str[128];
	strncpy(pane_str, GetLocString(pane), 128);
	

	// cycle through panes until we find the pane
	for(int i = 0; i < TOTAL_OUTPUT_PANES; i++)
		{
//		if(GetName(1) == this_str)
		Sleep(500);
//		::WCustomSetClass("Afx:400000:0"); //obsolete
//		if(::WCustomExists(pane_str,0)!=0) //obsolete
//		if(::WFndWndC(pane_str,"Afx:400000:0",FW_ACTIVE,0)!=NULL)
		if(::WFndWndC(pane_str,NULL,FW_ACTIVE,0)!=NULL) //we don't want to rely on th above class name
			break;
		MST.DoKeys("^({PGDN})");
		}
	
/*		if(MST.FindWndWait(pane_str,1)
			break;
		else
			MST.DoKeys("^({PGDN})");
*/ //there is no way to use FindWndWait
	if(i == TOTAL_OUTPUT_PANES)
		{
		LOG->RecordInfo("ERROR in CODebug::SetDebugOutputPane(): "
						"can't find %s pane", pane_str);

		return ERROR_ERROR;
		}	
	return ERROR_SUCCESS;
}


// BEGIN_HELP_COMMENT
// Function: int CODebug::StepIntoSpecific(int iWait /* WAIT_FOR_BREAK */)
// Description: Executes a Step Into <func> operation. The cursor is expected to be on a function call.
// Return: A BOOL that indicates success. TRUE if successful; FALSE otherwise.
// Param: pane A value that specifies the pane to activate: IDSS_PANE_DEBUG_OUTPUT.
// END_HELP_COMMENT
BOOL CODebug::StepIntoSpecific(int iWait /* WAIT_FOR_BREAK */)
{
	MST.DoKeys(GetLocString(IDSS_STEP_INTO_SPECIFIC_ACCEL));
	return Wait(iWait);
}

// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::ToggleHexDisplay(BOOL bEnable)
// Description: Toggles Hexadecimal display mode
// Param: bEnable If the parameter is TRUE, the Hexadecimal display mode is on. If FALSE - off.
// Return: A Boolean value that indicates whether the toggle operatin was sucessfull (TRUE) or not.
// END_HELP_COMMENT
BOOL CODebug::ToggleHexDisplay(BOOL bEnable)
{

	UIOptionsTabDlg OptionsTabDlg;
	return OptionsTabDlg.ToggleHexDisplay(bEnable);
}

// BEGIN_HELP_COMMENT
// Function: BOOL CODebug::ToggleSourceAnnotation(BOOL bEnable)
// Description: Toggles Source Annotation
// Param: bEnable If the parameter is TRUE, the Hexadecimal display mode is on. If FALSE - off.
// Return: A Boolean value that indicates whether the toggle operatin was sucessfull (TRUE) or not.
// END_HELP_COMMENT
BOOL CODebug::ToggleSourceAnnotation(BOOL bEnable)
{

	UIOptionsTabDlg OptionsTabDlg;
	return OptionsTabDlg.ToggleSourceAnnotation(bEnable);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\coexcpt.h ===
///////////////////////////////////////////////////////////////////////////////
//  COEXCPT.H
//
//  Created by :            Date :
//      WayneBr             1/14/94
//
//  Description :
//      Declaration of the COExceptions class
//

#ifndef __COEXCPT_H__
#define __COEXCPT_H__

#include "uiexcpt.h"

#include "dbgxprt.h"

///////////////////////////////////////////////////////////////////////////////
//  COExceptions class

// BEGIN_CLASS_HELP
// ClassName: COExceptions
// BaseClass: none
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS COExceptions

	{

	// Data
	private:
		UIExceptions uiexcpt;

	// Utilities
	public:
		BOOL VerifyExceptionHit(void);
		BOOL VerifyExceptionHit(int code);
		BOOL SetException(int code, int option);
		CString  GetException(int code);
		BOOL RestoreDefualts(void);

	};

#endif // __COEXCPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\coee.h ===
///////////////////////////////////////////////////////////////////////////////
//  COEE.H
//
//  Created by :            Date :
//      MichMa                  1/13/94
//
//  Description :
//      Declaration of the COExpEval class
//

#ifndef __COEE_H__
#define __COEE_H__

#include "uiqw.h"
#include "uiwatch.h"
#include "uieewnd.h"

#include "dbgxprt.h"

#pragma warning (disable : 4069)


typedef enum{EE_VALUES_ONLY, EE_ALL_INFO} EE_TYPE;


///////////////////////////////////////////////////////////////////////////////
//  COExpEval class

// BEGIN_CLASS_HELP
// ClassName: COExpEval
// BaseClass: none
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS COExpEval

	{
	// Data
	private:
		UIQuickWatch m_uiqw;
		UIWatch	m_uiwatch;
		EE_TYPE m_eetype;
		BOOL m_bEEIsEnabled;

	// Utilities
	public:

		BOOL Enable(EE_TYPE eetype = EE_VALUES_ONLY);
		BOOL Disable();

		BOOL GetExpressionValue(LPCSTR expression, char *value);
		BOOL GetExpressionValue(LPCSTR expression, unsigned char *value);
		BOOL GetExpressionValue(LPCSTR expression, short int *value);
		BOOL GetExpressionValue(LPCSTR expression, unsigned short int *value);
		BOOL GetExpressionValue(LPCSTR expression, int *value);
		BOOL GetExpressionValue(LPCSTR expression, unsigned int *value);
		BOOL GetExpressionValue(LPCSTR expression, long int *value);
		BOOL GetExpressionValue(LPCSTR expression, unsigned long int *value);
		BOOL GetExpressionValue(LPCSTR expression, float *value);
		BOOL GetExpressionValue(LPCSTR expression, double *value);
		BOOL GetExpressionValue(LPCSTR expression, long double *value);
		BOOL GetExpressionValue(LPCSTR expression, CString &value);

		BOOL SetExpressionValue(LPCSTR expression, char value);
		BOOL SetExpressionValue(LPCSTR expression, unsigned char value);
		BOOL SetExpressionValue(LPCSTR expression, short int value);
		BOOL SetExpressionValue(LPCSTR expression, unsigned short int value);
		BOOL SetExpressionValue(LPCSTR expression, int value);
		BOOL SetExpressionValue(LPCSTR expression, unsigned int value);
		BOOL SetExpressionValue(LPCSTR expression, long int value);
		BOOL SetExpressionValue(LPCSTR expression, unsigned long int value);
		BOOL SetExpressionValue(LPCSTR expression, float value);
		BOOL SetExpressionValue(LPCSTR expression, double value);
		BOOL SetExpressionValue(LPCSTR expression, long double value);
		BOOL SetExpressionValue(LPCSTR expression, __int64 value);
		BOOL SetExpressionValue(LPCSTR expression, unsigned __int64 value);
		BOOL SetExpressionValue(LPCSTR expression, LPCSTR value);
		
		BOOL ExpressionValueIs(LPCSTR expression, char value);
		BOOL ExpressionValueIs(LPCSTR expression, unsigned char value);
		BOOL ExpressionValueIs(LPCSTR expression, short int value);
		BOOL ExpressionValueIs(LPCSTR expression, unsigned short int value);
		BOOL ExpressionValueIs(LPCSTR expression, int value);
		BOOL ExpressionValueIs(LPCSTR expression, unsigned int value);
		BOOL ExpressionValueIs(LPCSTR expression, long int value);
		BOOL ExpressionValueIs(LPCSTR expression, unsigned long int value);
		BOOL ExpressionValueIs(LPCSTR expression, float value);
		BOOL ExpressionValueIs(LPCSTR expression, double value);
		BOOL ExpressionValueIs(LPCSTR expression, long double value);
		BOOL ExpressionValueIs(LPCSTR expression, LPCSTR value);
		BOOL ExpressionValueSubstringIs(LPCSTR expression, LPCSTR value);

		BOOL ExpressionValueIsTrue(LPCSTR expression);
		BOOL ExpressionValueIsFalse(LPCSTR expression);
		BOOL ExpressionErrorIs(LPCSTR expression, LPCSTR value);

		BOOL ValueIsAddress(LPCSTR szValue);
		void FillExprInfo(EXPR_INFO &ExprInfo, EXPR_STATE ExprState, LPCSTR szType, LPCSTR szName, LPCSTR szValue);
		BOOL CompareExprInfo(EXPR_INFO *ExprInfo1, EXPR_INFO *ExprInfo2, int iCount = 1);
		BOOL VerifyExprInfo(EXPR_INFO expr_info);

	private:
		CString ExtractExpressionValue(LPCSTR expression,BOOL bErrorExpected=FALSE);
	};

#endif // __COEE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\codam.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  CODAM.CPP
//
//  Created by :            Date :
//      WayneBr                 1/14/94
//
//  Description :
//      Implementation of the CODAM class
//

#include "stdafx.h"
#include "codam.h"
#include "uidebug.h"

#include "..\SYM\cmdids.h"
#include "..\SHL\uwbframe.h"
#include "..\..\coclip.h"
#include <testxcpt.h>
#include <guiv1.h>
#include <mstwrap.h>
#include "..\SHL\uioptdlg.h"
#include "codebug.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// none of these close the DAM window 				

// BEGIN_HELP_COMMENT
// Function: int CODAM::GotoSymbol(LPCSTR symbol)
// Description: Navigate to a specified symbol in the disassembly code.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: symbol A pointer to a string that contains the symbol to navigate to.
// Param: bCloseAfter A Boolean value that indicates if dialog should be closed after the command was implemented (TRUE).
// END_HELP_COMMENT
BOOL  CODAM::GotoSymbol(LPCSTR symbol, BOOL bCloseAfter /* TRUE */)

{
	const char* const THIS_FUNCTION = "CODAM::GotoSymbol()";

	if(!uidam.Activate())
	{
		LOG->RecordInfo("ERROR in %s: could not activate the asm window.", THIS_FUNCTION);
		return FALSE;
	}

	return uidam.GotoSymbol(symbol, bCloseAfter);
}


// BEGIN_HELP_COMMENT
// Function: int CODAM::GotoAddress(int address)
// Description: Navigate to an address in the disassembly code.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: address An integer that contains the address to navigate to.
// Param: bCloseAfter A Boolean value that indicates if dialog should be closed after the command was implemented (TRUE).
// END_HELP_COMMENT
BOOL  CODAM::GotoAddress(int address, BOOL bCloseAfter /* TRUE */)

{
	const char* const THIS_FUNCTION = "CODAM::GotoAddress()";

	if(!uidam.Activate())
	{
		LOG->RecordInfo("ERROR in %s: could not activate the asm window.", THIS_FUNCTION);
		return FALSE;
	}

	return uidam.GotoAddress(address, bCloseAfter);
}


// BEGIN_HELP_COMMENT
// Function: BOOL CODAM::InstructionIs(LPCSTR inst)
// Description: Determine whether the instruction at the current location in the diassasembly code matches the given instruction.
// Return: A Boolean value that indicates whether the instruction at the current location in the disassembly code matches the given instruction (TRUE) or not.
// Param: inst A pointer to a string that contains the instruction to compare to.
// END_HELP_COMMENT
BOOL  CODAM::InstructionIs(LPCSTR inst)
	
{
	const char* const THIS_FUNCTION = "CODAM::InstructionIs()";

	if(!uidam.Activate())
	{
		LOG->RecordInfo("ERROR in %s: could not activate the asm window.", THIS_FUNCTION);
		return FALSE;
	}

	CString temp = uidam.GetInstruction();

	if(temp.Find(inst) == -1)
		LOG->RecordInfo("ERROR in %s: Instruction is %s, expected %s", THIS_FUNCTION, temp, inst);

	return (temp.Find(inst) != -1);
}


// BEGIN_HELP_COMMENT
// Function: CString CODAM::GetInstruction()
// Description: Get the instruction at the current location in the disassembly code.
// Return: A CString that contains the instruction.
// END_HELP_COMMENT
CString CODAM::GetInstruction()

{
	const char* const THIS_FUNCTION = "CODAM::GetInstruction()";

	if(!uidam.Activate())
	{
		LOG->RecordInfo("ERROR in %s: could not activate the asm window.", THIS_FUNCTION);
		return (CString)"";
	}

	return uidam.GetInstruction();
}


// BEGIN_HELP_COMMENT
// Function: BOOL CODAM::Enable()
// Description: Enable access to disassembly in the debugger.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL CODAM::Enable()
{
	return uidam.Activate();
}


// BEGIN_HELP_COMMENT
// Function: BOOL CODAM::Disable()
// Description: Disable access to disassembly in the debugger.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL CODAM::Disable()

{
	const char* const THIS_FUNCTION = "CODAM::Disable()";

	if(!uidam.ChooseContextMenuItem(CLOSE_HIDE))
	{
		LOG->RecordInfo("ERROR in %s: could not select CLOSE/HIDE menu item in asm context menu.", THIS_FUNCTION);
		return FALSE;
	}

	if(uidam.IsActive())
	{
		LOG->RecordInfo("ERROR in %s: asm window is still active after trying to close it.", THIS_FUNCTION);
		return FALSE;
	}

	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: CString CODAM::GetLines(int startline /* 0 */, int count /* 1 */)
// Description: Returns one or more lines in the disassembly listing.
// Return: none
// Param: startline An integer that contains offset of the starting line of the block to get (ex: 0 represents the current line, 1 the line below, -1 the line above, etc.).
// Param: count An integer that contains the number of lines to get.
// END_HELP_COMMENT
CString CODAM::GetLines(int startline /* 0 */, int count /* 1 */)

{
	int i;

	// 0 represents the current line.
	if(startline > 0)
	{
		for(i = 0; i < startline; i++)
			MST.DoKeys("{DOWN}");
	}
	else if(startline < 0)
	{
		for(i = 0; i > startline; i--)
			MST.DoKeys("{UP}");
	}
	
	// select the line(s).
	for(i = 0; i < count; i++)
		MST.DoKeys("+({DOWN})");

	// copy the lines to the clipboard and return them.
	UIWB.DoCommand(ID_EDIT_COPY, DC_ACCEL);
	COClipboard clip;
	return clip.GetText();
}


// BEGIN_HELP_COMMENT
// Function: BOOL CODAM::ToggleSourceDisplay(BOOL bToggle)
// Description: Toggles the source display feature of the asm window on and off.
// Return: TRUE is successful, FALSE if not.
// Param: bToggle: a BOOL value specifying to turn source display on (TRUE) or off (FALSE).
// END_HELP_COMMENT
BOOL CODAM::ToggleSourceDisplay(BOOL bToggle)

{
	const char* const THIS_FUNC = "CODebug::GoToDisassembly()";
	BOOL bReturn = TRUE;
	UIOptionsTabDlg uiopt;

	// bring up the options dlg.
	if(uiopt.Display())
	
	{
		// select the debug page.
		if(uiopt.ShowPage(TAB_DEBUG, 6))
		
		{
			// set the source display checkbox accordingly.
			if(bToggle)
				MST.WCheckCheck("@13");
			else
 				MST.WCheckUnCheck("@13");

			// check that the source display checkbox was checked\unchecked properly.
			BOOL bCheckState = MST.WCheckState("@13");

			if((bCheckState  && !bToggle) || (!bCheckState  && bToggle))
			{
				LOG->RecordInfo("ERROR in %s: source display checkbox state is %d instead of expected %d.", 
					THIS_FUNC, bCheckState, bToggle);
				bReturn = FALSE;
			}
		
		}
		
		else
		{
			LOG->RecordInfo("ERROR in %s: could not select the debug page of the options dlg.", THIS_FUNC);
			bReturn = FALSE;
		}

		// close the options dlg.
		if(uiopt.OK())
		{
			LOG->RecordInfo("ERROR in %s: could not close the options dlg.", THIS_FUNC);
			bReturn = FALSE;
		}
	}
		
	else
	{
		LOG->RecordInfo("ERROR in %s: could not bring up the options dlg.", THIS_FUNC);
		bReturn = FALSE;
	}
	
	return bReturn;
}


// BEGIN_HELP_COMMENT
// Function: BOOL CODAM::InstructionContains(int offset, CString inst)
// Description: Determine whether the instruction at the location set by offset in the diassasembly code contains the given instruction.
// Return: A Boolean value that indicates whether the instruction at the current location in the disassembly code matches the given instruction (TRUE) or not.
// Param: offset An integer that contains the offset (in lines) from the current cursor position to start retrieving instructions from. This value is negative to move up in the window (down in memory). (Default value is 0.)
// Param: inst A string that contains the instruction to compare to.
// Param: bLocateCaretAtLeftTop A Boolean value that indicates if the caret should be moved to the left top corner of the DAM window before offset
// END_HELP_COMMENT
BOOL CODAM::InstructionContains(int offset, CString ExpectedInst, BOOL bLocateCaretAtLeftTop)
{
	CString csDamInstruction = uidam.GetInstruction(offset, 1, bLocateCaretAtLeftTop);

	// Remove Tabs and spaces. 
	ExpectedInst.TrimRight("\t ");
	ExpectedInst.TrimLeft("\t ");

	if(-1 == csDamInstruction.Find(ExpectedInst))
	{
		LOG->RecordSuccess("Expected Instruction %s", ExpectedInst);
		LOG->RecordSuccess("Actual   Instruction %s", csDamInstruction);
		LOG->RecordSuccess("Offset               %d", offset);
		return FALSE;
	}

	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL CODAM::SwitchBetweenASMAndSRC(BOOL bUsingContextMenu)
// Description: Switches from Source window to DAM and back
// Return: A Boolean value which is currenly always TRUE
// Param: bUsingContextMenu A Boolean value that indicates if the context menu should be used to switch.  If FALSE, hot key is used.
// END_HELP_COMMENT
BOOL CODAM::SwitchBetweenASMAndSRC(BOOL bUsingContextMenu)
{
 return uidam.SwitchBetweenASMAndSRC(bUsingContextMenu);
}


// BEGIN_HELP_COMMENT
// Function: BOOL CODAM::IsActive(void)
// Description: Determine if the disassembly window is active.
// Return: A Boolean value that indicates whether the disassembly window is active (TRUE) or not.
// END_HELP_COMMENT
BOOL CODAM::IsActive(void)
{
	return uidam.IsActive();
}


// BEGIN_HELP_COMMENT
// Function: BOOL CODAM::VerifyCurrentInstruction(LPCSTR szInstruction)
// Description: Determine whether the instruction at the current location in the diassasembly code matches the given instruction.
// Description: The given instruction should be in the form "<instruction> <operands>", with one space between the instruction and operands.
// Return: A Boolean value that indicates whether the instruction at the current location in the disassembly code matches the given instruction (TRUE) or not.
// Param: szInstruction - A pointer to a string that contains the instruction to compare to.
// END_HELP_COMMENT
BOOL  CODAM::VerifyCurrentInstruction(LPCSTR szInstruction)
	
{
	const char* const THIS_FUNCTION = "CODAM::VerifyCurrentInstruction()";

	// activate the disassembly window.
	if(!uidam.Activate())
	{
		LOG->RecordInfo("ERROR in %s: could not activate the disassembly window.", THIS_FUNCTION);
		return FALSE;
	}

	// see if the expected instruction has an operand.
	CString cstrExpected = szInstruction;
	int intSpace = cstrExpected.Find(" ");

	// if the instruction has an operand, then we need to insert the correct amount of spaces between them so it matches what the debugger will display.
	if(intSpace != -1)
	
	{
		// the instruction is everything before the space.
		CString cstrInstruction = cstrExpected.Left(intSpace);
		// the operand is everything after the space.
		CString cstrOperand = cstrExpected.Mid(intSpace + 1);

		// the length from the start of the instruction to the start of the operand is always 12 characters.
		// in between the end of the instruction and the start of the operand is a variable number of spaces.
		cstrExpected = cstrInstruction;
		int intNumSpaces = 12 - cstrInstruction.GetLength();
		
		// add the appropriate number of spaces.
		for(int i = 0; i < intNumSpaces; i++)
			cstrExpected = cstrExpected + " ";
		
		// append the operand.
		cstrExpected = cstrExpected + cstrOperand;
	}

	// get the actual instruction from the disassembly window.
	CString cstrActual = uidam.GetInstruction();

	// check if the expected instruction can be found in the actual instruction.
	if(cstrActual.Find(cstrExpected) == -1)
	{
		LOG->RecordInfo("ERROR in %s: Cannot find expected instruction \"%s\" in actual instruction \"%s\"", THIS_FUNCTION, cstrExpected, cstrActual);
		return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\coee.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  COEE.CPP
//
//  Created by :            Date :
//      MichMa                  1/13/94
//
//  Description :
//      Implementation of the COExpEval class
//

#include "stdafx.h"
#include "coee.h"
#include "guiv1.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

#pragma warning (disable : 4069)


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::Enable(EE_TYPE eetype /* EE_VALUES_ONLY */)
// Description: Enable the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL COExpEval::Enable(EE_TYPE eetype /* EE_VALUES_ONLY */)

{
	// if we're only checking values, then we can use the quickwatch dlg. otherwise we need the watch window.
	if(eetype == EE_VALUES_ONLY)
	{
		if (!m_uiqw.Activate())
			return FALSE;
	}
	else
		// TODO(michma - 2/7/98): need to check return value when we get Activate working for watch window.
		m_uiwatch.Activate();

	// store the current EE_TYPE for later.
	m_eetype = eetype;
	m_bEEIsEnabled = TRUE;
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::Disable()
// Description: Disable the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL COExpEval::Disable()

{
	// if we're using the quickwatch dlg to evaluate expressions, then we want to close it when finished.
	// if we're using the watch window, we want to leave it open.
	if(m_eetype == EE_VALUES_ONLY)
	{
		if(m_uiqw.Close() != NULL) 
			return FALSE;
	}
	else
		MST.DoKeys("{ESC}");

	m_bEEIsEnabled = FALSE;
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::GetExpressionValue(LPCSTR expression, char *value)
// Description: Get the result (one charachter) of the given expression of type char from the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value A pointer to a char that will contain the result of the expression evaluation.
// END_HELP_COMMENT
BOOL COExpEval::GetExpressionValue(LPCSTR expression, char *value)
	
	{
	CString cstr = ExtractExpressionValue(expression);

	if(cstr == "")
		return FALSE;

	*value = (char)strtol(cstr, NULL, 0);
	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::GetExpressionValue(LPCSTR expression, unsigned char *value)
// Description: Get the result (one character) of the given expression of type unsigned char from the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value A pointer to an unsigned char that will contain the result of the expression evaluation.
// END_HELP_COMMENT
BOOL COExpEval::GetExpressionValue(LPCSTR expression, unsigned char *value)
	
	{
	CString cstr = ExtractExpressionValue(expression);

	if(cstr == "")
		return FALSE;

	*value = (unsigned char)strtoul(cstr, NULL, 0);
	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::GetExpressionValue(LPCSTR expression, short int *value)
// Description: Get the result of the given expression from the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value A pointer to a short integer that will contain the result of the expression evaluation.
// END_HELP_COMMENT
BOOL COExpEval::GetExpressionValue(LPCSTR expression, short int *value)

	{
	CString cstr = ExtractExpressionValue(expression);
	
	if(cstr == "")
		return FALSE;

	*value = (short int)strtol(cstr, NULL, 0);
	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::GetExpressionValue(LPCSTR expression, unsigned short int *value)
// Description: Get the result of the given expression from the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value A pointer to an unsigned short integer that will contain the result of the expression evaluation.
// END_HELP_COMMENT
BOOL COExpEval::GetExpressionValue(LPCSTR expression, unsigned short int *value)

	{
	CString cstr = ExtractExpressionValue(expression);
	
	if(cstr == "")
		return FALSE;

	*value = (unsigned short int)strtoul(cstr, NULL, 0);
	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::GetExpressionValue(LPCSTR expression, int *value)
// Description: Get the result of the given expression from the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value A pointer to an integer that will contain the result of the expression evaluation.
// END_HELP_COMMENT
BOOL COExpEval::GetExpressionValue(LPCSTR expression, int *value)
	
	{
	CString cstr = ExtractExpressionValue(expression);
	
	if(cstr == "")
		return FALSE;

	*value = (int)strtol(cstr, NULL, 0);
	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::GetExpressionValue(LPCSTR expression, unsigned int *value)
// Description: Get the result of the given expression from the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value A pointer to an unsigned integer that will contain the result of the expression evaluation.
// END_HELP_COMMENT
BOOL COExpEval::GetExpressionValue(LPCSTR expression, unsigned int *value)
	
	{
	CString cstr = ExtractExpressionValue(expression);
	
	if(cstr == "")
		return FALSE;

	*value = (unsigned int)strtoul(cstr, NULL, 0);
	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::GetExpressionValue(LPCSTR expression, long int *value)
// Description: Get the result of the given expression from the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value A pointer to a long that will contain the result of the expression evaluation.
// END_HELP_COMMENT
BOOL COExpEval::GetExpressionValue(LPCSTR expression, long int *value)
	
	{
	CString cstr = ExtractExpressionValue(expression);
	
	if(cstr == "")
		return FALSE;

	*value = strtol(cstr, NULL, 0);
	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::GetExpressionValue(LPCSTR expression, unsigned long int *value)
// Description: Get the result of the given expression from the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value A pointer to an unsigned long that will contain the result of the expression evaluation.
// END_HELP_COMMENT
BOOL COExpEval::GetExpressionValue(LPCSTR expression, unsigned long int *value)
	
	{
	CString cstr = ExtractExpressionValue(expression);
	
	if(cstr == "")
		return FALSE;

	*value = strtoul(cstr, NULL, 0);
	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::GetExpressionValue(LPCSTR expression, float *value)
// Description: Get the result of the given expression from the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value A pointer to a float that will contain the result of the expression evaluation.
// END_HELP_COMMENT
BOOL COExpEval::GetExpressionValue(LPCSTR expression, float *value)
	
	{
	CString cstr = ExtractExpressionValue(expression);
	
	if(cstr == "")
		return FALSE;

	*value = (float)atof(cstr);
	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::GetExpressionValue(LPCSTR expression, double *value)
// Description: Get the result of the given expression from the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value A pointer to a double that will contain the result of the expression evaluation.
// END_HELP_COMMENT
BOOL COExpEval::GetExpressionValue(LPCSTR expression, double *value)
	
	{
	CString cstr = ExtractExpressionValue(expression);
	
	if(cstr == "")
		return FALSE;

	*value = (double)atof(cstr);
	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::GetExpressionValue(LPCSTR expression, long double *value)
// Description: Get the result of the given expression from the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value A pointer to a long double that will contain the result of the expression evaluation.
// END_HELP_COMMENT
BOOL COExpEval::GetExpressionValue(LPCSTR expression, long double *value)
	
	{
	CString cstr = ExtractExpressionValue(expression);
	
	if(cstr == "")
		return FALSE;

	*value = atof(cstr);
	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::GetExpressionValue(LPCSTR expression, short int *value)
// Description: Get the result of the string expression from the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value A string that will contain the result of the expression evaluation. It will contain the exprassion as it's displayed in the debugger including the quotes and/or braces (ex. {"string"})
// END_HELP_COMMENT
BOOL COExpEval::GetExpressionValue(LPCSTR expression, CString &value)

	{
	CString cstr = ExtractExpressionValue(expression);
	
	value = cstr;

	if(cstr == "")
		return FALSE;

	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: CString COExpEval::ExtractExpressionValue(LPCSTR expression, BOOL bErrorExpected /* FALSE */)
// Description: Get the result of the given expression from the expression evaluator.
// Return: A CString that contains the result of the expression evaluation.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: bErrorExpected A Boolean value that indicates whether to expect an error (TRUE) during evaluation or not.
// END_HELP_COMMENT
CString COExpEval::ExtractExpressionValue(LPCSTR expression, BOOL bErrorExpected /* FALSE */)
	
	{
	int EEisActive = m_uiqw.IsActive();

	if(!EEisActive)
		if(!Enable()) return CString("");

	if(!m_uiqw.SetExpression(expression)) return CString("");
	if(!m_uiqw.Recalc()) return CString("");
	CString value = m_uiqw.GetCurrentValue();
	if(value == "") return value;

	if(!EEisActive)
		if(!Disable()) return CString("");

	if(value.Find("Error") == -1 || (bErrorExpected))
		{
		LOG->RecordInfo("EE - extracted value = %s", value);
		return value;
		}

	
	LOG->RecordInfo("EE ERROR - %s\n", value);
	return CString("");

	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::SetExpressionValue(LPCSTR expression, char value)
// Description: Set an expression's value in the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to set.
// Param: value A char that contains the value to set the expression to.
// END_HELP_COMMENT
BOOL COExpEval::SetExpressionValue(LPCSTR expression, char value)
	{
	CString cstr = value;
	return SetExpressionValue(expression, cstr);
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::SetExpressionValue(LPCSTR expression, unsigned char value)
// Description: Set an expression's value in the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to set.
// Param: value An unsigned char that contains the value to set the expression to.
// END_HELP_COMMENT
BOOL COExpEval::SetExpressionValue(LPCSTR expression, unsigned char value)
	{
	CString cstr = value;
	return SetExpressionValue(expression, cstr);
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::SetExpressionValue(LPCSTR expression, short int value)
// Description: Set an expression's value in the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to set.
// Param: value A short that contains the value to set the expression to.
// END_HELP_COMMENT
BOOL COExpEval::SetExpressionValue(LPCSTR expression, short int value)
	{
	char string[256];
	return SetExpressionValue(expression, _itoa(value, string, 10));
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::SetExpressionValue(LPCSTR expression, unsigned short int value)
// Description: Set an expression's value in the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to set.
// Param: value An unsigned short that contains the value to set the expression to.
// END_HELP_COMMENT
BOOL COExpEval::SetExpressionValue(LPCSTR expression, unsigned short int value)
	{
	char string[256];
	return SetExpressionValue(expression, _itoa((signed int)value, string, 10));
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::SetExpressionValue(LPCSTR expression, int value)
// Description: Set an expression's value in the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to set.
// Param: value An integer that contains the value to set the expression to.
// END_HELP_COMMENT
BOOL COExpEval::SetExpressionValue(LPCSTR expression, int value)
	{
	char string[256];
	return SetExpressionValue(expression, _itoa(value, string, 10));
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::SetExpressionValue(LPCSTR expression, unsigned int value)
// Description: Set an expression's value in the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to set.
// Param: value An unsigned integer that contains the value to set the expression to.
// END_HELP_COMMENT
BOOL COExpEval::SetExpressionValue(LPCSTR expression, unsigned int value)
	{
	char string[256];
	return SetExpressionValue(expression, _itoa((signed)value, string, 10));
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::SetExpressionValue(LPCSTR expression, long int value)
// Description: Set an expression's value in the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to set.
// Param: value A long that contains the value to set the expression to.
// END_HELP_COMMENT
BOOL COExpEval::SetExpressionValue(LPCSTR expression, long int value)
	{
	char string[256];
	return SetExpressionValue(expression, _ltoa(value, string, 10));
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::SetExpressionValue(LPCSTR expression, unsigned long int value)
// Description: Set an expression's value in the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to set.
// Param: value An unsigned long that contains the value to set the expression to.
// END_HELP_COMMENT
BOOL COExpEval::SetExpressionValue(LPCSTR expression, unsigned long int value)
	{
	char string[256];
	return SetExpressionValue(expression, _ltoa((signed)value, string, 10));
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::SetExpressionValue(LPCSTR expression, float value)
// Description: Set an expression's value in the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to set.
// Param: value A float that contains the value to set the expression to.
// END_HELP_COMMENT
BOOL COExpEval::SetExpressionValue(LPCSTR expression, float value)
	{
	char string[256];
	return SetExpressionValue(expression, _gcvt(value, 6, string));
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::SetExpressionValue(LPCSTR expression, double value)
// Description: Set an expression's value in the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to set.
// Param: value A double that contains the value to set the expression to.
// END_HELP_COMMENT
BOOL COExpEval::SetExpressionValue(LPCSTR expression, double value)
	{
	char string[256];
	return SetExpressionValue(expression, _gcvt(value, 14, string));	
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::SetExpressionValue(LPCSTR expression, long double value)
// Description: Set an expression's value in the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to set.
// Param: value A long double that contains the value to set the expression to.
// END_HELP_COMMENT
BOOL COExpEval::SetExpressionValue(LPCSTR expression, long double value)
	{
	char string[256];
	return SetExpressionValue(expression, _gcvt(value, 14 , string));
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::SetExpressionValue(LPCSTR expression, __int64 value)
// Description: Set an expression's value in the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to set.
// Param: value An __int64 that contains the value to set the expression to.
// END_HELP_COMMENT
BOOL COExpEval::SetExpressionValue(LPCSTR expression, __int64 value)
	{
	char string[256];
	return SetExpressionValue(expression, _i64toa(value, string, 10));
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::SetExpressionValue(LPCSTR expression, unsigned __int64 value)
// Description: Set an expression's value in the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to set.
// Param: value An __int64 that contains the value to set the expression to.
// END_HELP_COMMENT
BOOL COExpEval::SetExpressionValue(LPCSTR expression, unsigned __int64 value)
	{
	char string[256];
	return SetExpressionValue(expression, _i64toa(value, string, 10));
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::SetExpressionValue(LPCSTR expression, LPCSTR value)
// Description: Set an expression's value in the expression evaluator.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to set.
// Param: value A pointer to a string that contains the value to set the expression to.
// END_HELP_COMMENT
BOOL COExpEval::SetExpressionValue(LPCSTR expression, LPCSTR value)
	
	{
	int EEisActive = m_uiqw.IsActive();

	if(!EEisActive)
		if(!Enable()) return FALSE;

	if(!m_uiqw.SetExpression(expression)) return FALSE;
	if(!m_uiqw.Recalc()) return FALSE;
	if(!m_uiqw.SetNewValue(value)) return FALSE;

	if(!EEisActive)
		if(!Disable()) return FALSE;
	
	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::ExpressionValueIs(LPCSTR expression, char value)
// Description: Determine whether the expression evaluates to the given value in the expression evaluator.
// Return: A Boolean value that indicates whether the given expression evaluates to the specified value (TRUE) or not.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value A char that contains the expected result of the expression evaluation.
// END_HELP_COMMENT
BOOL COExpEval::ExpressionValueIs(LPCSTR expression, char value)
	{
	char eevalue;
	if (!GetExpressionValue(expression, &eevalue)) return FALSE;
	return value == eevalue;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::ExpressionValueIs(LPCSTR expression, unsigned char value)
// Description: Determine whether the expression evaluates to the given value in the expression evaluator.
// Return: A Boolean value that indicates whether the given expression evaluates to the specified value (TRUE) or not.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value An unsigned char that contains the expected result of the expression evaluation.
// END_HELP_COMMENT
BOOL COExpEval::ExpressionValueIs(LPCSTR expression, unsigned char value)
	{
	unsigned char eevalue;
	if (!GetExpressionValue(expression, &eevalue)) return FALSE;
	return value == eevalue;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::ExpressionValueIs(LPCSTR expression, short int value)
// Description: Determine whether the expression evaluates to the given value in the expression evaluator.
// Return: A Boolean value that indicates whether the given expression evaluates to the specified value (TRUE) or not.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value A short that contains the expected result of the expression evaluation.
// END_HELP_COMMENT
BOOL COExpEval::ExpressionValueIs(LPCSTR expression, short int value)
	{
	short int eevalue;
	if (!GetExpressionValue(expression, &eevalue)) return FALSE;
	return value == eevalue;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::ExpressionValueIs(LPCSTR expression, unsigned short int value)
// Description: Determine whether the expression evaluates to the given value in the expression evaluator.
// Return: A Boolean value that indicates whether the given expression evaluates to the specified value (TRUE) or not.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value An unsigned short that contains the expected result of the expression evaluation.
// END_HELP_COMMENT
BOOL COExpEval::ExpressionValueIs(LPCSTR expression, unsigned short int value)
	{
	unsigned short int eevalue;
	if (!GetExpressionValue(expression, &eevalue)) return FALSE;
	return value == eevalue;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::ExpressionValueIs(LPCSTR expression, int value)
// Description: Determine whether the expression evaluates to the given value in the expression evaluator.
// Return: A Boolean value that indicates whether the given expression evaluates to the specified value (TRUE) or not.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value An integer that contains the expected result of the expression evaluation.
// END_HELP_COMMENT
BOOL COExpEval::ExpressionValueIs(LPCSTR expression, int value)
	{
	int eevalue;
	if (!GetExpressionValue(expression, &eevalue)) return FALSE;
	return value == eevalue;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::ExpressionValueIs(LPCSTR expression, unsigned int value)
// Description: Determine whether the expression evaluates to the given value in the expression evaluator.
// Return: A Boolean value that indicates whether the given expression evaluates to the specified value (TRUE) or not.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value An unsigned integer that contains the expected result of the expression evaluation.
// END_HELP_COMMENT
BOOL COExpEval::ExpressionValueIs(LPCSTR expression, unsigned int value)
	{
	unsigned int eevalue;
	if (!GetExpressionValue(expression, &eevalue)) return FALSE;
	return value == eevalue;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::ExpressionValueIs(LPCSTR expression, long int value)
// Description: Determine whether the expression evaluates to the given value in the expression evaluator.
// Return: A Boolean value that indicates whether the given expression evaluates to the specified value (TRUE) or not.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value A long that contains the expected result of the expression evaluation.
// END_HELP_COMMENT
BOOL COExpEval::ExpressionValueIs(LPCSTR expression, long int value)
	{
	long int eevalue;
	if (!GetExpressionValue(expression, &eevalue)) return FALSE;
	return value == eevalue;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::ExpressionValueIs(LPCSTR expression, unsigned long int value)
// Description: Determine whether the expression evaluates to the given value in the expression evaluator.
// Return: A Boolean value that indicates whether the given expression evaluates to the specified value (TRUE) or not.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value An unsigned long that contains the expected result of the expression evaluation.
// END_HELP_COMMENT
BOOL COExpEval::ExpressionValueIs(LPCSTR expression, unsigned long int value)
	{
	unsigned long int eevalue;
	if (!GetExpressionValue(expression, &eevalue)) return FALSE;
	return value == eevalue;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::ExpressionValueIs(LPCSTR expression, float value)
// Description: Determine whether the expression evaluates to the given value in the expression evaluator.
// Return: A Boolean value that indicates whether the given expression evaluates to the specified value (TRUE) or not.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value A float that contains the expected result of the expression evaluation.
// END_HELP_COMMENT
BOOL COExpEval::ExpressionValueIs(LPCSTR expression, float value)
	{
	float eevalue;
	if (!GetExpressionValue(expression, &eevalue)) return FALSE;

	char str1[128], str2[128];

	// Since comparing floats doesn't give correct results if one of them is a result of atof
	// we compare strings

	memset(str1, 0, sizeof(str1));
	memset(str2, 0, sizeof(str2));

	sprintf(str1, "%.5e", eevalue);
	sprintf(str2, "%.5e", value);
	return !strcmp(str1,str2);

//	return value == eevalue;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::ExpressionValueIs(LPCSTR expression, double value)
// Description: Determine whether the expression evaluates to the given value in the expression evaluator.
// Return: A Boolean value that indicates whether the given expression evaluates to the specified value (TRUE) or not.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value A double that contains the expected result of the expression evaluation.
// END_HELP_COMMENT
BOOL COExpEval::ExpressionValueIs(LPCSTR expression, double value)
	{
	double eevalue;
	if (!GetExpressionValue(expression, &eevalue)) return FALSE;
	return value == eevalue;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::ExpressionValueIs(LPCSTR expression, long double value)
// Description: Determine whether the expression evaluates to the given value in the expression evaluator.
// Return: A Boolean value that indicates whether the given expression evaluates to the specified value (TRUE) or not.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value A long double that contains the expected result of the expression evaluation.
// END_HELP_COMMENT
BOOL COExpEval::ExpressionValueIs(LPCSTR expression, long double value)
	{
	long double eevalue;
	if (!GetExpressionValue(expression, &eevalue)) return FALSE;
	return value == eevalue;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::ExpressionValueIs(LPCSTR expression, LPCSTR value)
// Description: Determine whether the expression evaluates to the given value in the expression evaluator.
// Return: A Boolean value that indicates whether the given expression evaluates to the specified value (TRUE) or not.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value A pointer to a string that contains the expected result of the expression evaluation.
// END_HELP_COMMENT
BOOL COExpEval::ExpressionValueIs(LPCSTR expression, LPCSTR value)

	{
	// evaluate the expression.
	CString eevalue = ExtractExpressionValue(expression);
	CString expected_value = value;

	// is an address (unknown value) expected at the beginning of the value?
	if(expected_value.Mid(0, 7) == "ADDRESS")
		
		{
		// verify that the first 10 characters of the extracted value are a non-zero address.
		if (!((eevalue.Mid(0, 2) == "0x") && 
		      (eevalue.Mid(2).SpanIncluding("0123456789abcdef").GetLength() == 8) &&
		      (eevalue.Mid(0, 10) != "0x00000000")))
			return FALSE;

		// is extra data besides the address expected?
		if(expected_value.Mid(0, 8) == "ADDRESS ")
		
			{
			// make sure actual string is long enough so we avoid CString assert.
			if(eevalue.GetLength() > 10)
				// verify extra data is correct.
				return eevalue.Mid(10) == expected_value.Mid(7);
			else
				// actual string wasn't long enough to contain extra data.
				return FALSE;
			}

		return TRUE;
		}
	
	return eevalue == expected_value;
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::ExpressionValueSubstringIs(LPCSTR expression, LPCSTR value)
// Description: Determine whether the expression evaluates to the string which contains the given value in the expression evaluator.
// Return: A Boolean value that indicates whether the given expression evaluates to the string which contains the specified value (TRUE) or not.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value A pointer to a string that contains the expected substring of the result of the expression evaluation.
// END_HELP_COMMENT
BOOL COExpEval::ExpressionValueSubstringIs(LPCSTR expression, LPCSTR value)

	{
	// evaluate the expression.
	CString eevalue = ExtractExpressionValue(expression);
	CString expected_value = value;

	// is an address (unknown value) expected at the beginning of the value?
	if(expected_value.Mid(0, 7) == "ADDRESS")
		
		{
		// verify that the first 10 characters of the extracted value are a non-zero address.
		if (!((eevalue.Mid(0, 2) == "0x") && 
		      (eevalue.Mid(2).SpanIncluding("0123456789abcdef").GetLength() == 8) &&
		      (eevalue.Mid(0, 10) != "0x00000000")))
			return FALSE;

		// is extra data besides the address expected?
		if(expected_value.Mid(0, 8) == "ADDRESS ")
		
			{
			// make sure actual string is long enough so we avoid CString assert.
			if(eevalue.GetLength() > 10)
				// verify extra data is correct.
				return (eevalue.Mid(10).Find(expected_value.Mid(7)) != -1);
			else
				// actual string wasn't long enough to contain extra data.
				return FALSE;
			}

		return TRUE;
		}
	
	return (eevalue.Find(expected_value) != -1);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::ExpressionValueIsTrue(LPCSTR expression)
// Description: Determine whether the given expression evaluates to TRUE in the expression evaluator.
// Return: A Boolean value that indicates whether the given expression evaluates to TRUE (TRUE) or not.
// Param: expression A pointer to a string that contains the expression to evaluate.
// END_HELP_COMMENT
BOOL COExpEval::ExpressionValueIsTrue(LPCSTR expression)
	{
	char eevalue;
	if (!GetExpressionValue(expression, &eevalue)) return FALSE;
	return eevalue == 1;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::ExpressionValueIsFalse(LPCSTR expression)
// Description: Determine whether the given expression evaluates to FALSE in the expression evaluator.
// Return: A Boolean value that indicates whether the given expression evaluates to FALSE (TRUE) or not.
// Param: expression A pointer to a string that contains the expression to evaluate.
// END_HELP_COMMENT
BOOL COExpEval::ExpressionValueIsFalse(LPCSTR expression)
	{
	char eevalue;
	if (!GetExpressionValue(expression, &eevalue)) return FALSE;
	return eevalue == 0;
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::ExpressionErrorIs(LPCSTR expression, LPCSTR value)
// Description: Determine whether the given expression evaluates to the specified error value in the expression evaluator.
// Return: A Boolean value that indicates whether the given expression evaluates to the given error value (TRUE) or not.
// Param: expression A pointer to a string that contains the expression to evaluate.
// Param: value A pointer to a string that contains the error expected.
// END_HELP_COMMENT
BOOL COExpEval::ExpressionErrorIs(LPCSTR expression, LPCSTR value)
	{
	CString eevalue = ExtractExpressionValue(expression,TRUE);
	return eevalue == value;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::ValueIsAddress(LPCSTR szValue)
// Description: Reports whether or not a specified value represents an address.
// Return: TRUE if the value is an address, FALSE if not.
// Param: szValue A pointer to a string that contains the value to check.
// END_HELP_COMMENT
BOOL COExpEval::ValueIsAddress(LPCSTR szValue)
{
	CString strValue = szValue;
	return (strValue.Mid(0, 2) == "0x") && 
		   (strValue.Mid(2).SpanIncluding("0123456789abcdef").GetLength() == 8);
}


// BEGIN_HELP_COMMENT
// Function: void COExpEval::FillExprInfo(EXPR_INFO &ExprInfo, EXPR_STATE ExprState, LPCSTR szType, LPCSTR szName, LPCSTR szValue)
// Description: Fills a given EXPR_INFO structure with the supplied state, type, name, and value of an expression.
// Return: none.
// Param: ExprInfo A reference to an EXPR_INFO object that will be filled with the other parameters.
// Param: ExprState An EXPR_STATE enum value specifying the state of the expression (NOT_EXPANDABLE, EXPANDED, COLLAPSED).
// Param: szType A pointer to a string that contains the type of the expression.
// Param: szName A pointer to a string that contains the name of the expression.
// Param: szValue A pointer to a string that contains the value of the expression.
// END_HELP_COMMENT
void COExpEval::FillExprInfo(EXPR_INFO &ExprInfo, EXPR_STATE ExprState, LPCSTR szType, LPCSTR szName, LPCSTR szValue)
{
	ExprInfo.state = ExprState;
	ExprInfo.type = szType;
	ExprInfo.name = szName;
	ExprInfo.value = szValue;
}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::CompareExprInfo(EXPR_INFO *ExprInfo1, EXPR_INFO *ExprInfo2, int iCount /* 1 */)
// Description: Compares two arrays of EXPR_INFO structures.
// Return: A boolean value indicating whether or not the EXPR_INFO arrays match, element for element.
// Param: ExprInfo1 An EXPR_STATE array that is expected to match ExprInfo2 element for element.
// Param: ExprInfo2 An EXPR_STATE array that is expected to match ExprInfo1 element for element.
// Param: iCount An integer specifying how many elements to compare.
// END_HELP_COMMENT
BOOL COExpEval::CompareExprInfo(EXPR_INFO *ExprInfo1, EXPR_INFO *ExprInfo2, int iCount /* 1 */)
	
{
	// loop through all the elements to compare.
	for(int i = 0; i < iCount; i++)

	{
		// compare the states.
		if(ExprInfo1[i].state != ExprInfo2[i].state)
		{
			LOG->RecordInfo("ERROR in COExpEval::ExprInfoIs(): state is %d instead of %d", 
							ExprInfo1[i].state, ExprInfo2[i].state);
			return FALSE;
		}

		// compare the types.
		if(ExprInfo1[i].type != ExprInfo2[i].type)
		{
			LOG->RecordInfo("ERROR in COExpEval::ExprInfoIs(): type is \"%s\" instead of \"%s\"", 
							ExprInfo1[i].type, ExprInfo2[i].type);
			return FALSE;
		}

		// compare the names.
		if(ExprInfo1[i].name != ExprInfo2[i].name)
		{
			LOG->RecordInfo("ERROR in COExpEval::ExprInfoIs(): name is \"%s\" instead of \"%s\"", 
							ExprInfo1[i].name, ExprInfo2[i].name);
			return FALSE;
		}

		// make sure an unknown value isn't being compared.
		// "UNKNOWN" values must always be passed in the ExprInfo2 array.
		if(ExprInfo2[i].value.Mid(0, 7) != "UNKNOWN") 

		{
			BOOL bValueComparePassed;

			// check if an address is being copmared.
			// "ADDRESS" values must always be passed in the ExprInfo2 array.
			if(ExprInfo2[i].value.Mid(0, 7) == "ADDRESS")
				
			{
				// verify that the value is an address.
				bValueComparePassed = ValueIsAddress(ExprInfo1[i].value);

				// is extra data besides address expected? (ex. peek at string)
				if(ExprInfo2[i].value != "ADDRESS")
				
				{
					// user must supply extra data to avoid CString assert.
					EXPECT(ExprInfo2[i].value.GetLength() > 8);

					// make sure actual string is long enough so we avoid CString assert.
					if(ExprInfo1[i].value.GetLength() > 10)
					{
						// verify extra data is correct.
						if(ExprInfo1[i].value.Mid(10) ==  (" " + ExprInfo2[i].value.Mid(8)))
							bValueComparePassed = TRUE;	
					}
					else
						// actual string wasn't long enough to contain extra data.
						bValueComparePassed = FALSE;
				}	// extra data besides address expected?
			}	// address being compared?

			// straight value comparison (no address).
			else	
				bValueComparePassed = ExprInfo1[i].value == ExprInfo2[i].value;

			// check the value comparison.
			if(!bValueComparePassed)
			{
				LOG->RecordInfo("ERROR in COExpEval::ExprInfoIs(): value is \"%s\" instead of \"%s\"", 
								ExprInfo1[i].value, ExprInfo2[i].value);
				return FALSE;
			}
		
		}	// unknown value being compared?
	
	}	// loop through all the elements to compare.

	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL COExpEval::VerifyExprInfo(EXPR_INFO expr_info)
// Description: Verify the name, value, type, and state of an expression.
// Return: A Boolean value that specifies whether the verification was sucessful (TRUE) or not (FALSE).
// Param: expr_info A EXPR_INFO object containing the name, value, type, and state of the expression to verify.
// END_HELP_COMMENT
BOOL COExpEval::VerifyExprInfo(EXPR_INFO expr_info)

{
	char szThisFunc[] = "COExpEval::VerifyExprInfo";

	// enable the watch window if it hasn't been already.
	if(!m_bEEIsEnabled)
		// TODO(michma - 2/7/98): check for a return value when we get Activate working for the watch window.
		m_uiwatch.Activate();

	// add a watch on the expression.
	if(m_uiwatch.SetName(expr_info.name, ROW_LAST) != ERROR_SUCCESS)
	{
		LOG->RecordInfo("ERROR in %s: can't add watch on expression \"%s\".", szThisFunc, expr_info.name);
		return FALSE;
	}
	
	// stores the expression's actual information.
	EXPR_INFO expr_info_actual;

	// get the fields of the expression from the watch window.
	if(m_uiwatch.GetAllFields(&expr_info_actual, ROW_PREVIOUS) != ERROR_SUCCESS)
	{
		LOG->RecordInfo("ERROR in %s: couldn't get fields of expression \"%s\".", szThisFunc, expr_info.name);
		return FALSE;
	}

	// delete the watch so as not to clutter up the watch window.
	if(m_uiwatch.Delete(ROW_PREVIOUS) != ERROR_SUCCESS)
	{
		LOG->RecordInfo("ERROR in %s: couldn't delete expression \"%s\" from watch window.", szThisFunc, expr_info.name);
		return FALSE;
	}

	// compare the actual expression info with the expected expression info.
	return CompareExprInfo(&expr_info_actual, &expr_info);
}


#pragma warning (default : 4069)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\coexcpt.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  COEXCPT.CPP
//
//  Created by :            Date :
//      WayneBr                 1/14/94
//
//  Description :
//      Implementation of the COExceptions class
//

#include "stdafx.h"
#include "coexcpt.h"
#include "testxcpt.h"
#include "guiv1.h"
#include "..\shl\uwbframe.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: BOOL COExceptions::VerifyExceptionHit(void)
// Description: Determine whether an exception was hit. (See VerifyExceptionHit(int) to verify a specific exception.)
// Return: A Boolean value that indicates whether an exception was hit (TRUE) or not.
// END_HELP_COMMENT
BOOL COExceptions::VerifyExceptionHit(void)
	{
	// todo check to see if any exception was hit (message box).
	if (FALSE)
	{
		LOG->RecordInfo( (LPCSTR) "No Exceptions trapped");
	}
	return TRUE;
	};

// BEGIN_HELP_COMMENT
// Function: BOOL COExceptions::VerifyExceptionHit(int code)
// Description: Determine whether a specific exception was hit. (See VerifyException(void) to verify any exception.)
// Return: A Boolean value that indicates whether the specified exception was hit (TRUE) or not.
// Param: code An integer that contains the exception code expected.
// END_HELP_COMMENT
BOOL COExceptions::VerifyExceptionHit(int code)
	{
	// todo check to see if the specified exception was hit (message box).
	BOOL temp = FALSE;  //call white box verify here?
	if (FALSE)
	{
		LOG->RecordInfo( (LPCSTR) "Exception %d was not trapped", code );
	}
	return TRUE;
	};

// BEGIN_HELP_COMMENT
// Function: BOOL COExceptions::SetException(int code, int option)
// Description: Set or change an exception.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: code An integer that contains the exception code.
// Param: option A value that specifies the type of action to take when the exception is caught: STOP_ALWAYS, IF_NOT_HANDLED.
// END_HELP_COMMENT
BOOL COExceptions::SetException(int code, int option)
	{
	EXPECT(uiexcpt.Activate());
	EXPECT(uiexcpt.SetException(code, option));
	EXPECT(uiexcpt.Close());
	// verify really set, log warning return FALSE if not
	return TRUE;
	};

// BEGIN_HELP_COMMENT
// Function: CString  COExceptions::GetException(int code)
// Description: Get a string that describes the exception.
// Return: A CString that contains a string describing the exception specified.
// Param: code An integer that contains the exception code.
// END_HELP_COMMENT
CString  COExceptions::GetException(int code)
	{
	EXPECT(uiexcpt.Activate());
	CString temp = uiexcpt.GetException(code);
	EXPECT(uiexcpt.Close());
	return  temp;
	};

// BEGIN_HELP_COMMENT
// Function: BOOL COExceptions::RestoreDefualts(void)
// Description: Restore all default exceptions.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL COExceptions::RestoreDefualts(void)
	{
	EXPECT(uiexcpt.Activate());
	EXPECT(uiexcpt.RestoreDefualts());
	EXPECT(uiexcpt.Close());
	// verify really done, log warning return FALSE if not
	return TRUE;
	};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\colocals.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  COLOCALS.CPP
//
//  Created by:            Date:
//      MichMa                  10/26/97
//
//  Description:
//      Implementation of the COLocals class
//

#include "stdafx.h"
#include "colocals.h"
#include "guiv1.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

#pragma warning (disable : 4069)


// BEGIN_HELP_COMMENT
// Function: BOOL COLocals::VerifyLocalInfo(CLocal Local)
// Description: Verify that a local of the specified name, value, type, and state exists in the current frame of the app being debugged.
// Return: A Boolean value that specifies whether the verification was sucessful (TRUE) or not (FALSE).
// Param: Local A CLocal object containing the name, value, type, and state of the local to verify.
// END_HELP_COMMENT
BOOL COLocals::VerifyLocalInfo(CLocal Local)

{
	// activate the variables window.
	// TODO(michma): UIVariables::Activate isn't returning TRUE even though the window gets activated.
	/*if(!uivar.Activate())
	{
		LOG->RecordInfo("ERROR in COLocals::VerifyLocalInfo(): can't activate variables window.", Local.m_strName);
		return FALSE;
	}
	*/
	uivar.Activate();

	// select the local.
	if(!uivar.SelectLocal(Local.m_strName))
	{
		LOG->RecordInfo("ERROR in COLocals::VerifyLocalInfo(): can't select local \"%s\".", Local.m_strName);
		return FALSE;
	}
	
	// stores the local's actual and expected information.
	EXPR_INFO ActualLocalInfo, ExpectedLocalInfo;
	coee.FillExprInfo(ExpectedLocalInfo, Local.m_ExprState, Local.m_strType, Local.m_strName, Local.m_strValue);

	// get the fields of the local from the variables window.
	if(uivar.GetAllFields(&ActualLocalInfo, ROW_CURRENT) != ERROR_SUCCESS)
	{
		LOG->RecordInfo("ERROR in COLocals::VerifyLocalInfo(): couldn't get fields of local.");
		return FALSE;
	}

	// return focus back to source (if it's there).
	MST.DoKeys("{ESC}");
	// compare the actual local info with the expected local info.
	return coee.CompareExprInfo(&ActualLocalInfo, &ExpectedLocalInfo);
}


// BEGIN_HELP_COMMENT
// Function: BOOL COLocals::VerifyLocalInfo(LPCSTR szName, LPCSTR szValue,  LPCSTR szType, EXPR_STATE ExprState)
// Description: Verify that a local of the specified name, value, type, and state exists in the current frame of the app being debugged.
// Return: A Boolean value that specifies whether the verification was sucessful (TRUE) or not (FALSE).
// Param: szName - A string specifying the name of the local.
// Param: szValue - A string specifying the value of the local.
// Param: szType - A string specifying the type of the local.
// Param: ExprState - An EXPR_STATE value specifying the expansion state of the local (NOT_EXPANABLE, COLLAPSED, EXPANDED).
// END_HELP_COMMENT
BOOL COLocals::VerifyLocalInfo(LPCSTR szName, LPCSTR szValue,  LPCSTR szType, EXPR_STATE ExprState)
{
	CLocal Local;
	Local.m_ExprState = ExprState;
	Local.m_strType = szType;
	Local.m_strName = szName;
	Local.m_strValue = szValue;
	return VerifyLocalInfo(Local);
}


// BEGIN_HELP_COMMENT
// Function: BOOL COLocals::LocalDoesNotExist(LPCSTR szLocal)
// Description: Verify that a local of the specified name does not exist.
// Return: A Boolean value that specifies whether the verification was sucessful (TRUE) or not (FALSE).
// Param: szLocal A pointer to a string that contains the local to check for.
// END_HELP_COMMENT
BOOL COLocals::LocalDoesNotExist(LPCSTR szLocal)

{
	// activate the variables window.
	// TODO(michma): UIVariables::Activate isn't returning TRUE even though the window gets activated.
	/*if(!uivar.Activate())
	{
		LOG->RecordInfo("ERROR in COLocals::VerifyLocalInfo(): can't activate variables window.", Local.m_strName);
		return FALSE;
	}
	*/
	uivar.Activate();
	
	BOOL bResult = uivar.SelectLocal(szLocal);
	// return focus back to source (if it's there).
	MST.DoKeys("{ESC}");
	return !bResult;
}


// BEGIN_HELP_COMMENT
// Function: BOOL COLocals::LocalsCountIs(int intLocalsCount)
// Description: Verify that the debugger has an accurate count of the locals in the current function.
// Return: A Boolean value that specifies whether the verification was sucessful (TRUE) or not (FALSE).
// Param: intLocalCount An integer specifying the expected count of locals.
// END_HELP_COMMENT
BOOL COLocals::LocalsCountIs(int intLocalsCount)

{
	// activate the variables window.
	// TODO(michma): UIVariables::Activate isn't returning TRUE even though the window gets activated.
	/*if(!uivar.Activate())
	{
		LOG->RecordInfo("ERROR in COLocals::VerifyLocalInfo(): can't activate variables window.", Local.m_strName);
		return FALSE;
	}
	*/
	uivar.Activate();

	int intActualLocalsCount = uivar.GetLocalsCount();
	// return focus back to source (if it's there).
	MST.DoKeys("{ESC}");
	return intActualLocalsCount == intLocalsCount;
}

// BEGIN_HELP_COMMENT
// Function: BOOL COLocals::SetLocalValue(LPCSTR szLocal, LPCSTR szValue)
// Description: Sets a value for the local variable.
// Return: A Boolean value that specifies whether the verification was sucessful (TRUE) or not (FALSE).
// Param: szLocal A string specifying the name of the local value expression for which to assign a value
// Param: szValue A string specifying the value to be assigned to the local variable
// END_HELP_COMMENT
BOOL COLocals::SetLocalValue(LPCSTR szLocal, LPCSTR szValue)

{
	const char* const THIS_FUNCTION = "COLocals::SetLocalValue";

	// activate the variables window.
	// TODO(michma): UIVariables::Activate isn't returning TRUE even though the window gets activated.
	/*if(!uivar.Activate())
	{
		LOG->RecordInfo("ERROR in %s: can't activate variables window.", THIS_FUNCTION);
		return FALSE;
	}
	*/
	uivar.Activate();

	// select the local to change.
	if(!uivar.SelectLocal(szLocal))
	{
		LOG->RecordInfo("ERROR in %s: can't select local \"%s\".", THIS_FUNCTION, szLocal);
		return FALSE;
	}

	// Change the local value
	if(ERROR_SUCCESS != uivar.SetValue(szValue, ROW_CURRENT))
	{
		LOG->RecordInfo("ERROR in %s: can't set the value of local \"%s\".", THIS_FUNCTION, szLocal);
		return FALSE;
	}
	
	// return focus back to source (if it's there).
	MST.DoKeys("{ESC}");
	return TRUE;
}

#pragma warning (default : 4069)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\codebug.h ===
///////////////////////////////////////////////////////////////////////////////
//  CODEBUG.H
//
//  Created by :            Date :
//      MichMa                  1/13/94
//
//  Description :
//      Declaration of the CODebug class
//
   
#ifndef __CODEBUG_H__
#define __CODEBUG_H__

#include "costack.h"
#include "..\shl\uwbframe.h"
#include "..\..\testutil.h"

#include "dbgxprt.h"

enum StepMode { SRC, ASM };
enum DebugState { NotDebugging, Debug_Run, Debug_Break };

// msg types user can pass to CancelMsg() and HandleMsg().  these also act as indexes into
// an array of localized string id's (see msg_array in codebug.cpp)

typedef enum {
	MSG_REMOTE_LOCAL_EXE_MISMATCH,
	MSG_REMOTE_EXE_NAME_REQUIRED,
	MSG_EC_DELAYED_DUE_TO_CTOR_DTOR,
	MSG_EC_ONLY_ASM_AVAILABLE, 
	MSG_EXCEPTION_DIVIDE_BY_ZERO,
	MSG_EC_POINT_OF_EXECUTION_MOVED,
	MSG_EC_LOCAL_VAR_REMOVED
} MSG_TYPE;

#define TOTAL_OUTPUT_PANES 4

///////////////////////////////////////////////////////////////////////////////
//  CODebug class

// BEGIN_CLASS_HELP
// ClassName: CODebug
// BaseClass: none
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS CODebug

    {
    // Data
    private:
        COStack cos;
        StepMode mMode;
		COStack* m_pOwnedStack;

    // internal functions
    private:
        BOOL Exec(BOOL (UIWBFrame::*stepfcn)(int), int count = 1, LPCSTR symbol = NULL, LPCSTR line = NULL, LPCSTR function = NULL, int WAIT=WAIT_FOR_BREAK, int ModeVerify=TRUE);
        BOOL ExecUntilLine(BOOL   (UIWBFrame::*stepfcn)(int), LPCSTR line, LPCSTR function = NULL, int WAIT=WAIT_FOR_BREAK);
        BOOL ExecUntilFunc(BOOL   (UIWBFrame::*stepfcn)(int), LPCSTR function = NULL, int WAIT=WAIT_FOR_BREAK);
        BOOL ExecUntilSymbol(BOOL (UIWBFrame::*stepfcn)(int), LPCSTR symbol, int WAIT=WAIT_FOR_BREAK);
        BOOL MyIsActive();
		// REVIEW (michma): these should probably be in shl
		BOOL WaitMsgDisplayed(MSG_TYPE msg, int wait_time);
		BOOL WaitMsgDismissed(MSG_TYPE msg);


    // Utilities
    public:
        CODebug();
        BOOL Go(LPCSTR symbol = NULL, LPCSTR line = NULL, LPCSTR function = NULL, int WAIT=WAIT_FOR_BREAK);

        BOOL Restart(LPCSTR path = NULL);
        BOOL StopDebugging(int WAIT=ASSUME_NORMAL_TERMINATION);
        BOOL Break(void);

        BOOL SetSteppingMode(StepMode mode);
        StepMode GetSteppingMode(void);
        BOOL ValidateSteppingMode(StepMode mode);

        BOOL StepInto(int count = 1, LPCSTR symbol = NULL, LPCSTR line = NULL, LPCSTR function = NULL, int WAIT=WAIT_FOR_BREAK);
        BOOL StepIntoUntilLine(LPCSTR line, LPCSTR function = NULL, int WAIT=WAIT_FOR_BREAK);
        BOOL StepIntoUntilFunc(LPCSTR function = NULL, int WAIT=WAIT_FOR_BREAK);
        BOOL StepIntoUntilSymbol(LPCSTR symbol, int WAIT=WAIT_FOR_BREAK);

		BOOL StepIntoSpecific(int iWait = WAIT_FOR_BREAK);

        BOOL StepOver(int count = 1, LPCSTR symbol = NULL, LPCSTR line = NULL, LPCSTR function = NULL, int WAIT=WAIT_FOR_BREAK);
        BOOL StepOverUntilLine(LPCSTR line, LPCSTR function = NULL, int WAIT=WAIT_FOR_BREAK);
        BOOL StepOverUntilFunc(LPCSTR function = NULL, int WAIT=WAIT_FOR_BREAK);
        BOOL StepOverUntilSymbol(LPCSTR symbol, int WAIT=WAIT_FOR_BREAK);

        BOOL StepOut(int count = 1, LPCSTR symbol = NULL, LPCSTR line = NULL, LPCSTR function = NULL, int WAIT=WAIT_FOR_BREAK);
        BOOL StepOutUntilLine(LPCSTR line, LPCSTR function = NULL, int WAIT=WAIT_FOR_BREAK);
        BOOL StepOutUntilFunc(LPCSTR function = NULL, int WAIT=WAIT_FOR_BREAK);
        BOOL StepOutUntilSymbol(LPCSTR symbol, int WAIT=WAIT_FOR_BREAK);

        BOOL StepToCursor(int linepos = 0, LPCSTR symbol = NULL, LPCSTR line = NULL, LPCSTR function = NULL, int WAIT=WAIT_FOR_BREAK);
		BOOL AttachToProcess(LPCSTR szProcessName, int WAIT = WAIT_FOR_RUN, BOOL bSysProcess = FALSE);

        BOOL SetNextStatement(int line = 0);
        BOOL SetNextStatement(LPCSTR line);
        BOOL ShowNextStatement(void);

        BOOL Wait(int option, BOOL bLeaveFindSource = FALSE);
        DebugState GetDebugState(void);
		BOOL ToggleHexDisplay(BOOL bEnable);
		BOOL ToggleSourceAnnotation(BOOL bEnable);

        // check but no logging
        BOOL CurrentLineIs(LPCSTR line);
        BOOL AtSymbol(LPCSTR symbol);

        // check, log standard warning if fails
        BOOL VerifyCurrentLine(LPCSTR line);
        BOOL VerifyAtSymbol(LPCSTR symbol);
        BOOL VerifyTermination(int exitcode);  // log warning if code is wrong.
		BOOL VerifyTermination(void);          // any exitcode
		
		BOOL VerifyNotification(LPCSTR notification, int nOccurence = 1, int numberOfLines = 1, BOOL nCase = FALSE);      
		int SetDebugOutputPane(int pane);

		BOOL SetOwnedStack( COStack* );
		void DirtyStack() { if( m_pOwnedStack != NULL ) m_pOwnedStack->SetDirty( TRUE ); }

		// REVIEW (michma): these should probably be in shl
		BOOL HandleMsg(MSG_TYPE msg, LPCSTR pdata = NULL, int wait_time = 60);
		BOOL CancelMsg(MSG_TYPE msg, int wait_time = 60);
	
        // NOT PORTABLE AVOID USING THESE
        BOOL DoDebuggeeKeys(CString str);
        BOOL DoDebuggeeCmd(CString str);

		BOOL ToggleReturnValue(TOGGLE_TYPE t);
		BOOL ToggleEditAndContinue(TOGGLE_TYPE t);
        BOOL ResolveSourceLineAmbiguity(int iEntry);
		BOOL ResolveAmbiguity(int iEntry);
		BOOL ResolveAmbiguity(LPCSTR szEntry);
		BOOL ResolveSourceLineAmbiguity(LPCSTR szEntry);
		BOOL SupplySourceLocation(LPCSTR path);

};

#endif // __CDEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\comem.h ===
///////////////////////////////////////////////////////////////////////////////
//  COMEM.H
//
//  Created by :            Date :
//      MichMa                  1/13/94
//
//  Description :
//      Declaration of the COMemory class
//

#ifndef __COMEM_H__
#define __COMEM_H__

#include "dbgxprt.h"
#include "uimem.h"
#include "..\SHL\uwbframe.h"


#pragma warning (disable : 4069)

#define ERROR_ERROR -1

///////////////////////////////////////////////////////////////////////////////
//  COMemory class

// BEGIN_CLASS_HELP
// ClassName: COMemory
// BaseClass: none
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS COMemory

	{
	// Data
	private:
		UIMemory uimem;

	// Utilities
	public:

        BOOL Enable(void);
        BOOL Disable(void);

        BOOL GetMemoryData(int address, char *data, MEM_FORMAT format = MEM_FORMAT_ASCII, int count = 1);
        BOOL GetMemoryData(int address, unsigned char *data, MEM_FORMAT format = MEM_FORMAT_ASCII, int count = 1);
        BOOL GetMemoryData(int address, short int *data, MEM_FORMAT format = MEM_FORMAT_SHORT, int count = 1);
        BOOL GetMemoryData(int address, unsigned short int *data, MEM_FORMAT format = MEM_FORMAT_SHORT_UNSIGNED, int count = 1);
        BOOL GetMemoryData(int address, int *data, MEM_FORMAT format = MEM_FORMAT_LONG, int count = 1);
        BOOL GetMemoryData(int address, unsigned int *data, MEM_FORMAT format = MEM_FORMAT_LONG_UNSIGNED, int count = 1);
        BOOL GetMemoryData(int address, long int *data, MEM_FORMAT format = MEM_FORMAT_LONG, int count = 1);
        BOOL GetMemoryData(int address, unsigned long int *data, MEM_FORMAT format = MEM_FORMAT_LONG_UNSIGNED, int count = 1);
        BOOL GetMemoryData(int address, float *data, MEM_FORMAT format = MEM_FORMAT_REAL, int count = 1);
        BOOL GetMemoryData(int address, double *data, MEM_FORMAT format = MEM_FORMAT_REAL_LONG, int count = 1);
        BOOL GetMemoryData(int address, long double *data, MEM_FORMAT format = MEM_FORMAT_REAL_LONG, int count = 1);
		BOOL GetMemoryData(int address, __int64 *data, MEM_FORMAT format = MEM_FORMAT_INT64, int count = 1);
		BOOL GetMemoryData(int address, unsigned __int64 *data, MEM_FORMAT format = MEM_FORMAT_INT64_UNSIGNED, int count = 1);

		BOOL GetMemoryData(LPCSTR symbol, char *data, MEM_FORMAT format = MEM_FORMAT_ASCII, int count = 1);
		BOOL GetMemoryData(LPCSTR symbol, unsigned char *data, MEM_FORMAT format = MEM_FORMAT_ASCII, int count = 1);
		BOOL GetMemoryData(LPCSTR symbol, short int *data, MEM_FORMAT format = MEM_FORMAT_SHORT, int count = 1);
		BOOL GetMemoryData(LPCSTR symbol, unsigned short int *data, MEM_FORMAT format = MEM_FORMAT_SHORT_UNSIGNED, int count = 1);
        BOOL GetMemoryData(LPCSTR symbol, int *data, MEM_FORMAT format = MEM_FORMAT_LONG, int count = 1);
		BOOL GetMemoryData(LPCSTR symbol, unsigned int *data, MEM_FORMAT format = MEM_FORMAT_LONG_UNSIGNED, int count = 1);
		BOOL GetMemoryData(LPCSTR symbol, long int *data, MEM_FORMAT format = MEM_FORMAT_LONG, int count = 1);
		BOOL GetMemoryData(LPCSTR symbol, unsigned long int *data, MEM_FORMAT format = MEM_FORMAT_LONG_UNSIGNED, int count = 1);
		BOOL GetMemoryData(LPCSTR symbol, float *data, MEM_FORMAT format = MEM_FORMAT_REAL, int count = 1);
		BOOL GetMemoryData(LPCSTR symbol, double *data, MEM_FORMAT format = MEM_FORMAT_REAL_LONG, int count = 1);
		BOOL GetMemoryData(LPCSTR symbol, long double *data, MEM_FORMAT format = MEM_FORMAT_REAL_LONG, int count = 1);
		BOOL GetMemoryData(LPCSTR symbol, __int64 *data, MEM_FORMAT format = MEM_FORMAT_INT64, int count = 1);
		BOOL GetMemoryData(LPCSTR symbol, unsigned __int64 *data, MEM_FORMAT format = MEM_FORMAT_INT64_UNSIGNED, int count = 1);

        BOOL SetMemoryData(int address, char *data, MEM_FORMAT format = MEM_FORMAT_ASCII, int count = 1);
        BOOL SetMemoryData(int address, short int *data, MEM_FORMAT format = MEM_FORMAT_SHORT, int count = 1);
        BOOL SetMemoryData(int address, unsigned short int *data, MEM_FORMAT format = MEM_FORMAT_SHORT_UNSIGNED, int count = 1);
        BOOL SetMemoryData(int address, int *data, MEM_FORMAT format = MEM_FORMAT_LONG, int count = 1);
        BOOL SetMemoryData(int address, unsigned int *data, MEM_FORMAT format = MEM_FORMAT_LONG_UNSIGNED, int count = 1);
        BOOL SetMemoryData(int address, long int *data, MEM_FORMAT format = MEM_FORMAT_LONG, int count = 1);
        BOOL SetMemoryData(int address, unsigned long int *data, MEM_FORMAT format = MEM_FORMAT_LONG_UNSIGNED, int count = 1);
        BOOL SetMemoryData(int address, float *data, MEM_FORMAT format = MEM_FORMAT_REAL, int count = 1);
        BOOL SetMemoryData(int address, double *data, MEM_FORMAT format = MEM_FORMAT_REAL_LONG, int count = 1);
        BOOL SetMemoryData(int address, long double *data, MEM_FORMAT format = MEM_FORMAT_REAL_LONG, int count = 1);
        BOOL SetMemoryData(int address, __int64 *data, MEM_FORMAT format = MEM_FORMAT_INT64, int count = 1);
        BOOL SetMemoryData(int address, unsigned __int64 *data, MEM_FORMAT format = MEM_FORMAT_INT64_UNSIGNED, int count = 1);

        BOOL SetMemoryData(int address, char data, MEM_FORMAT format = MEM_FORMAT_ASCII);
        BOOL SetMemoryData(int address, unsigned char data, MEM_FORMAT format = MEM_FORMAT_ASCII);
        BOOL SetMemoryData(int address, short int data, MEM_FORMAT format = MEM_FORMAT_SHORT);
        BOOL SetMemoryData(int address, unsigned short int data, MEM_FORMAT format = MEM_FORMAT_SHORT_UNSIGNED);
        BOOL SetMemoryData(int address, int data, MEM_FORMAT format = MEM_FORMAT_LONG);
        BOOL SetMemoryData(int address, unsigned int data, MEM_FORMAT format = MEM_FORMAT_LONG_UNSIGNED);
        BOOL SetMemoryData(int address, long int data, MEM_FORMAT format = MEM_FORMAT_LONG);
        BOOL SetMemoryData(int address, unsigned long int data, MEM_FORMAT format = MEM_FORMAT_LONG_UNSIGNED);
        BOOL SetMemoryData(int address, float data, MEM_FORMAT format = MEM_FORMAT_REAL);
        BOOL SetMemoryData(int address, double data, MEM_FORMAT format = MEM_FORMAT_REAL_LONG);
        BOOL SetMemoryData(int address, long double data, MEM_FORMAT format = MEM_FORMAT_REAL_LONG);
        BOOL SetMemoryData(int address, __int64 data, MEM_FORMAT format = MEM_FORMAT_INT64);
		BOOL SetMemoryData(int address, unsigned __int64 data, MEM_FORMAT format = MEM_FORMAT_INT64_UNSIGNED);

		BOOL SetMemoryData(LPCSTR symbol, char *data, MEM_FORMAT format = MEM_FORMAT_ASCII, int count = 1);
		BOOL SetMemoryData(LPCSTR symbol, short int *data, MEM_FORMAT format = MEM_FORMAT_SHORT, int count = 1);
		BOOL SetMemoryData(LPCSTR symbol, unsigned short int *data, MEM_FORMAT format = MEM_FORMAT_SHORT_UNSIGNED, int count = 1);
        BOOL SetMemoryData(LPCSTR symbol, int *data, MEM_FORMAT format = MEM_FORMAT_LONG, int count = 1);
		BOOL SetMemoryData(LPCSTR symbol, unsigned int *data, MEM_FORMAT format = MEM_FORMAT_LONG_UNSIGNED, int count = 1);
		BOOL SetMemoryData(LPCSTR symbol, long int *data, MEM_FORMAT format = MEM_FORMAT_LONG, int count = 1);
		BOOL SetMemoryData(LPCSTR symbol, unsigned long int *data, MEM_FORMAT format = MEM_FORMAT_LONG_UNSIGNED, int count = 1);
		BOOL SetMemoryData(LPCSTR symbol, float *data, MEM_FORMAT format = MEM_FORMAT_REAL, int count = 1);
		BOOL SetMemoryData(LPCSTR symbol, double *data, MEM_FORMAT format = MEM_FORMAT_REAL_LONG, int count = 1);
		BOOL SetMemoryData(LPCSTR symbol, long double *data, MEM_FORMAT format = MEM_FORMAT_REAL_LONG, int count = 1);
		BOOL SetMemoryData(LPCSTR symbol, __int64 *data, MEM_FORMAT format = MEM_FORMAT_INT64, int count = 1);
		BOOL SetMemoryData(LPCSTR symbol, unsigned __int64 *data, MEM_FORMAT format = MEM_FORMAT_INT64_UNSIGNED, int count = 1);

        BOOL SetMemoryData(LPCSTR symbol, char data, MEM_FORMAT format = MEM_FORMAT_ASCII);		
		BOOL SetMemoryData(LPCSTR symbol, unsigned char data, MEM_FORMAT format = MEM_FORMAT_ASCII);
		BOOL SetMemoryData(LPCSTR symbol, short int data, MEM_FORMAT format = MEM_FORMAT_SHORT);		
		BOOL SetMemoryData(LPCSTR symbol, unsigned short int data, MEM_FORMAT format = MEM_FORMAT_SHORT_UNSIGNED);
		BOOL SetMemoryData(LPCSTR symbol, int data, MEM_FORMAT format = MEM_FORMAT_LONG);
		BOOL SetMemoryData(LPCSTR symbol, unsigned int data, MEM_FORMAT format = MEM_FORMAT_LONG_UNSIGNED);
		BOOL SetMemoryData(LPCSTR symbol, long int data, MEM_FORMAT format = MEM_FORMAT_LONG);
		BOOL SetMemoryData(LPCSTR symbol, unsigned long int data, MEM_FORMAT format = MEM_FORMAT_LONG_UNSIGNED);
		BOOL SetMemoryData(LPCSTR symbol, float data, MEM_FORMAT format = MEM_FORMAT_REAL);
		BOOL SetMemoryData(LPCSTR symbol, double data, MEM_FORMAT format = MEM_FORMAT_REAL_LONG);
		BOOL SetMemoryData(LPCSTR symbol, long double data, MEM_FORMAT format = MEM_FORMAT_REAL_LONG);
		BOOL SetMemoryData(LPCSTR symbol, __int64 data, MEM_FORMAT format = MEM_FORMAT_INT64);
		BOOL SetMemoryData(LPCSTR symbol, unsigned __int64 data, MEM_FORMAT format = MEM_FORMAT_INT64_UNSIGNED);

        BOOL MemoryDataIs(int address, char *data, MEM_FORMAT format = MEM_FORMAT_ASCII, int count = 1);
        BOOL MemoryDataIs(int address, unsigned char *data, MEM_FORMAT format = MEM_FORMAT_ASCII, int count = 1);
        BOOL MemoryDataIs(int address, short int *data, MEM_FORMAT format = MEM_FORMAT_SHORT, int count = 1);
        BOOL MemoryDataIs(int address, unsigned short int *data, MEM_FORMAT format = MEM_FORMAT_SHORT_UNSIGNED, int count = 1);
        BOOL MemoryDataIs(int address, int *data, MEM_FORMAT format = MEM_FORMAT_LONG, int count = 1);
        BOOL MemoryDataIs(int address, unsigned int *data, MEM_FORMAT format = MEM_FORMAT_LONG_UNSIGNED, int count = 1);
        BOOL MemoryDataIs(int address, long int *data, MEM_FORMAT format = MEM_FORMAT_LONG, int count = 1);
        BOOL MemoryDataIs(int address, unsigned long int *data, MEM_FORMAT format = MEM_FORMAT_LONG_UNSIGNED, int count = 1);
        BOOL MemoryDataIs(int address, float *data, MEM_FORMAT format = MEM_FORMAT_REAL, int count = 1);
        BOOL MemoryDataIs(int address, double *data, MEM_FORMAT format = MEM_FORMAT_REAL_LONG, int count = 1);
        BOOL MemoryDataIs(int address, long double *data, MEM_FORMAT format = MEM_FORMAT_REAL_LONG, int count = 1);
        BOOL MemoryDataIs(int address, __int64 *data, MEM_FORMAT format = MEM_FORMAT_INT64, int count = 1);
        BOOL MemoryDataIs(int address, unsigned __int64 *data, MEM_FORMAT format = MEM_FORMAT_INT64_UNSIGNED, int count = 1);

		BOOL MemoryDataIs(LPCSTR symbol, char *data, MEM_FORMAT format = MEM_FORMAT_ASCII, int count = 1);
		BOOL MemoryDataIs(LPCSTR symbol, unsigned char *data, MEM_FORMAT format = MEM_FORMAT_ASCII, int count = 1);
		BOOL MemoryDataIs(LPCSTR symbol, short int *data, MEM_FORMAT format = MEM_FORMAT_SHORT, int count = 1);
		BOOL MemoryDataIs(LPCSTR symbol, unsigned short int *data, MEM_FORMAT format = MEM_FORMAT_SHORT_UNSIGNED, int count = 1);
        BOOL MemoryDataIs(LPCSTR symbol, int *data, MEM_FORMAT format = MEM_FORMAT_LONG, int count = 1);
		BOOL MemoryDataIs(LPCSTR symbol, unsigned int *data, MEM_FORMAT format = MEM_FORMAT_LONG_UNSIGNED, int count = 1);
		BOOL MemoryDataIs(LPCSTR symbol, long int *data, MEM_FORMAT format = MEM_FORMAT_LONG, int count = 1);
		BOOL MemoryDataIs(LPCSTR symbol, unsigned long int *data, MEM_FORMAT format = MEM_FORMAT_LONG_UNSIGNED, int count = 1);
		BOOL MemoryDataIs(LPCSTR symbol, float *data, MEM_FORMAT format = MEM_FORMAT_REAL, int count = 1);
		BOOL MemoryDataIs(LPCSTR symbol, double *data, MEM_FORMAT format = MEM_FORMAT_REAL_LONG, int count = 1);
		BOOL MemoryDataIs(LPCSTR symbol, long double *data, MEM_FORMAT format = MEM_FORMAT_REAL_LONG, int count = 1);
        BOOL MemoryDataIs(LPCSTR symbol, __int64 *data, MEM_FORMAT format = MEM_FORMAT_INT64, int count = 1);
        BOOL MemoryDataIs(LPCSTR symbol, unsigned __int64 *data, MEM_FORMAT format = MEM_FORMAT_INT64_UNSIGNED, int count = 1);

        BOOL MemoryDataIs(int address, char data, MEM_FORMAT format = MEM_FORMAT_ASCII);
        BOOL MemoryDataIs(int address, unsigned char data, MEM_FORMAT format = MEM_FORMAT_ASCII);
        BOOL MemoryDataIs(int address, short int data, MEM_FORMAT format = MEM_FORMAT_SHORT);
        BOOL MemoryDataIs(int address, unsigned short int data, MEM_FORMAT format = MEM_FORMAT_SHORT_UNSIGNED);
        BOOL MemoryDataIs(int address, int data, MEM_FORMAT format = MEM_FORMAT_LONG);
        BOOL MemoryDataIs(int address, unsigned int data, MEM_FORMAT format = MEM_FORMAT_LONG_UNSIGNED);
        BOOL MemoryDataIs(int address, long int data, MEM_FORMAT format = MEM_FORMAT_LONG);
        BOOL MemoryDataIs(int address, unsigned long int data, MEM_FORMAT format = MEM_FORMAT_LONG_UNSIGNED);
        BOOL MemoryDataIs(int address, float data, MEM_FORMAT format = MEM_FORMAT_REAL);
        BOOL MemoryDataIs(int address, double data, MEM_FORMAT format = MEM_FORMAT_REAL_LONG);
        BOOL MemoryDataIs(int address, long double data, MEM_FORMAT format = MEM_FORMAT_REAL_LONG);
        BOOL MemoryDataIs(int address, __int64 data, MEM_FORMAT format = MEM_FORMAT_INT64);
        BOOL MemoryDataIs(int address, unsigned __int64 data, MEM_FORMAT format = MEM_FORMAT_INT64_UNSIGNED);

        BOOL MemoryDataIs(LPCSTR symbol, char data, MEM_FORMAT format = MEM_FORMAT_ASCII);
        BOOL MemoryDataIs(LPCSTR symbol, unsigned char data, MEM_FORMAT format = MEM_FORMAT_ASCII);
        BOOL MemoryDataIs(LPCSTR symbol, short int data, MEM_FORMAT format = MEM_FORMAT_SHORT);
        BOOL MemoryDataIs(LPCSTR symbol, unsigned short int data, MEM_FORMAT format = MEM_FORMAT_SHORT_UNSIGNED);
        BOOL MemoryDataIs(LPCSTR symbol, int data, MEM_FORMAT format = MEM_FORMAT_LONG);
        BOOL MemoryDataIs(LPCSTR symbol, unsigned int data, MEM_FORMAT format = MEM_FORMAT_LONG_UNSIGNED);
        BOOL MemoryDataIs(LPCSTR symbol, long int data, MEM_FORMAT format = MEM_FORMAT_LONG );
        BOOL MemoryDataIs(LPCSTR symbol, unsigned long int data, MEM_FORMAT format = MEM_FORMAT_LONG_UNSIGNED);
        BOOL MemoryDataIs(LPCSTR symbol, float data, MEM_FORMAT format = MEM_FORMAT_REAL);
        BOOL MemoryDataIs(LPCSTR symbol, double data, MEM_FORMAT format = MEM_FORMAT_REAL_LONG);
        BOOL MemoryDataIs(LPCSTR symbol, long double data, MEM_FORMAT format = MEM_FORMAT_REAL_LONG);
        BOOL MemoryDataIs(LPCSTR symbol, __int64 data, MEM_FORMAT format = MEM_FORMAT_INT64);
        BOOL MemoryDataIs(LPCSTR symbol, unsigned __int64 data, MEM_FORMAT format = MEM_FORMAT_INT64_UNSIGNED);

		BOOL SetMemoryFormat(MEM_FORMAT format);
		CString GetColumns(void);
		BOOL SetColumns(CString Columns);
		CString COMemory::GetAddress(CString symbol);
		BOOL CycleMemoryFormat(int count);

		CString ExtractMemoryData(MEM_FORMAT format, int address, int count);
		CString ExtractMemoryData(MEM_FORMAT format, LPCSTR symbol, int count);
		BOOL SetMemoryBytes(int address, LPCSTR bytes, MEM_FORMAT format = MEM_FORMAT_BYTE);
		BOOL SetMemoryBytes(LPCSTR symbol, LPCSTR bytes, MEM_FORMAT format = MEM_FORMAT_BYTE);
	};

#pragma warning (default : 4069)

#endif // __COMEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\comem.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  COMEM.CPP
//
//  Created by :            Date :
//      MichMa                  1/13/94
//
//  Description :
//      Implementation of the COMemory class
//

#include "stdafx.h"
#include "comem.h"
#include "uidebug.h"
#include "..\SRC\cosource.h"
#include "..\SYM\qcqp.h"
#include "..\SHL\uwbframe.h"
#include <testxcpt.h>
#include <guiv1.h>

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

#pragma warning (disable : 4069)

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::Enable(void)
// Description: Enable memory access in the debugger.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL COMemory::Enable(void)
	{
	uimem = UIDebug::ShowDockWindow(IDW_MEMORY_WIN);
	return uimem.IsValid();
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::Disable(void)
// Description: Disable memory access in the debugger.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL COMemory::Disable(void)
	{
	uimem.Close();
	return TRUE;
	}

////////////////////////////////////////////////////////////////////////////////////////////////////////
// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(int address, char *data, MEM_FORMAT format, int count /* 1 */)
// Description: Get data from memory at the specified address.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: address An integer that contains the address in memory to retrieve data from.
// Param: data A pointer to a char buffer that will contain the data retrieved.
// Param: count An integer that contains the number of elements of data to retrieve from memory. (Default value is 1.)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(int address, char *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return GetMemoryData(symbol, data, format, count);

	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(int address, unsigned char *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(int address, unsigned char *data, MEM_FORMAT format, int count)
	{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return GetMemoryData(symbol, data, format, count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(int address, short int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(int address, short int *data, MEM_FORMAT format, int count)
	{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return GetMemoryData(symbol, data, format, count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(int address, unsigned short int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(int address, unsigned short int *data, MEM_FORMAT format, int count)
	{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return GetMemoryData(symbol, data, format, count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(int address, int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(int address, int *data, MEM_FORMAT format, int count)
	{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return GetMemoryData(symbol, data, format, count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(int address, unsigned int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(int address, unsigned int *data, MEM_FORMAT format, int count)
	{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return GetMemoryData(symbol, data, format, count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(int address, long int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(int address, long int *data, MEM_FORMAT format, int count)
	{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return GetMemoryData(symbol, data, format, count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(int address, unsigned long int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(int address, unsigned long int *data, MEM_FORMAT format, int count)
	{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return GetMemoryData(symbol, data, format, count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(int address, float *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(int address, float *data, MEM_FORMAT format, int count)
	{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return GetMemoryData(symbol, data, format, count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(int address, double *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(int address, double *data, MEM_FORMAT format, int count)
	{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return GetMemoryData(symbol, data, format, count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(int address, long double *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(int address, long double *data, MEM_FORMAT format, int count)
	{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return GetMemoryData(symbol, data, format, count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(int address, __int64 *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(int address, __int64 *data, MEM_FORMAT format, int count)
	{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return GetMemoryData(symbol, data, format, count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(int address, unsigned __int64 *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(int address, unsigned __int64 *data, MEM_FORMAT format, int count)
	{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return GetMemoryData(symbol, data, format, count);
	}

////////////////////////////////////////////////////////////////////////////////////////////////////////
// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(LPCSTR symbol, char *data, MEM_FORMAT format,  int count /* 1 */)
// Description: Get data from memory for the specified symbol.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: symbol A string that contains the symbol in memory to retrieve data from.
// Param: data A pointer to a buffer that will contain the data retrieved.
// Param: count An integer that contains the number of elements of data to retrieve from memory. (Default value is 1.)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(LPCSTR symbol, char *data, MEM_FORMAT format, int count /* 1 */)
	{
	CString cstr = ExtractMemoryData(format, symbol, count);

	if(cstr == "")
		return FALSE;

	// In order to prevent GetAt(i) from failing we need to limit count
	if(count > cstr.GetLength())
		count = cstr.GetLength();

	for(int i = 0; i < count; i++)
		data[i] = cstr.GetAt(i);

	return TRUE;
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(LPCSTR symbol, unsigned char *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(LPCSTR symbol, unsigned char *data, MEM_FORMAT format, int count /* 1 */)
	{
	CString cstr = ExtractMemoryData(format, symbol, count);

	if(cstr == "")
		return FALSE;

	// In order to prevent GetAt(i) from failing we need to limit count
	if(count > cstr.GetLength())
		count = cstr.GetLength();
	for(int i = 0; i < count; i++)
		data[i] = cstr.GetAt(i);

	return TRUE;
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(LPCSTR symbol, short int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(LPCSTR symbol, short int *data, MEM_FORMAT format, int count /* 1 */)
	{
	CString cstr = ExtractMemoryData(format, symbol, count);

	if(cstr == "")
		return FALSE;

	for(int i = 0; i < count; i++)
		data[i] = atoi(cstr.Mid(uimem.GetFormatWidth() * i, uimem.GetFormatWidth()));

	return TRUE;
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(LPCSTR symbol, unsigned short int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(LPCSTR symbol, unsigned short int *data, MEM_FORMAT format, int count /* 1 */)
	{
	CString cstr = ExtractMemoryData(format, symbol, count);

	if(cstr == "")
		return FALSE;

	for(int i = 0; i < count; i++)
		data[i] = atoi(cstr.Mid(uimem.GetFormatWidth() * i, uimem.GetFormatWidth()));

	return TRUE;
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(LPCSTR symbol, int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(LPCSTR symbol, int *data, MEM_FORMAT format, int count /* 1 */)
	{
	CString cstr = ExtractMemoryData(format, symbol, count);

	if(cstr == "")
		return FALSE;

	for(int i = 0; i < count; i++)
		data[i] = atoi(cstr.Mid(uimem.GetFormatWidth() * i, uimem.GetFormatWidth()));

	return TRUE;
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(LPCSTR symbol, unsigned int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(LPCSTR symbol, unsigned int *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	CString cstr = ExtractMemoryData(format, symbol, count);

	if(cstr == "")
		return FALSE;

	for(int i = 0; i < count; i++)
		data[i] = (unsigned)atoi(cstr.Mid(uimem.GetFormatWidth() * i, uimem.GetFormatWidth()));

	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(LPCSTR symbol, long int *data, MEM_FORMAT format, int count)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(LPCSTR symbol, long int *data, MEM_FORMAT format, int count)
	{
	CString cstr = ExtractMemoryData(format, symbol, count);

	if(cstr == "")
		return FALSE;

	for(int i = 0; i < count; i++)
		data[i] = atol(cstr.Mid(uimem.GetFormatWidth() * i, uimem.GetFormatWidth()));

	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(LPCSTR symbol, unsigned long int *data, MEM_FORMAT format, int count)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(LPCSTR symbol, unsigned long int *data, MEM_FORMAT format, int count)
	{
	CString cstr = ExtractMemoryData(format, symbol, count);

	if(cstr == "")
		return FALSE;

	for(int i = 0; i < count; i++)
		data[i] = (unsigned)atol(cstr.Mid(uimem.GetFormatWidth() * i, uimem.GetFormatWidth()));

	return TRUE;
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(LPCSTR symbol, float *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(LPCSTR symbol, float *data, MEM_FORMAT format, int count /* 1 */)
	{
	CString cstr = ExtractMemoryData(format, symbol, count);

	if(cstr == "")
		return FALSE;

	for(int i = 0; i < count; i++)
		data[i] = (float)atof(cstr.Mid(uimem.GetFormatWidth() * i, uimem.GetFormatWidth()));

	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(LPCSTR symbol, double *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(LPCSTR symbol, double *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	CString cstr = ExtractMemoryData(format, symbol, count);

	if(cstr == "")
		return FALSE;

	for(int i = 0; i < count; i++)
		data[i] = atof(cstr.Mid(uimem.GetFormatWidth() * i, uimem.GetFormatWidth()));

	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(LPCSTR symbol, long double *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(LPCSTR symbol, long double *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	CString cstr = ExtractMemoryData(format, symbol, count);

	if(cstr == "")
		return FALSE;

	for(int i = 0; i < count; i++)
		data[i] = (long double)atof(cstr.Mid(uimem.GetFormatWidth() * i, uimem.GetFormatWidth()));

	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(LPCSTR symbol, __int64 *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(LPCSTR symbol, __int64 *data, MEM_FORMAT format, int count)
	{
	CString cstr = ExtractMemoryData(format, symbol, count);

	if(cstr == "")
		return FALSE;

	for(int i = 0; i < count; i++)
		data[i] = (__int64)_atoi64(cstr.Mid(uimem.GetFormatWidth() * i, uimem.GetFormatWidth()));

	return TRUE;
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::GetMemoryData(LPCSTR symbol, unsigned __int64 *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::GetMemoryData(LPCSTR symbol, unsigned __int64 *data, MEM_FORMAT format, int count)
	{
	CString cstr = ExtractMemoryData(format, symbol, count);

	if(cstr == "")
		return FALSE;

	for(int i = 0; i < count; i++)
		data[i] = (unsigned __int64)_atoi64(cstr.Mid(uimem.GetFormatWidth() * i, uimem.GetFormatWidth()));

	return TRUE;
	}

// TODO (michma): needs error logging.
CString COMemory::ExtractMemoryData(MEM_FORMAT format, int address, int count)	
	
	{ 

	char string[128];
	return ExtractMemoryData(format, _itoa(address, string, 10), count);

	}


// TODO (michma): needs error logging.
CString COMemory::ExtractMemoryData(MEM_FORMAT format, LPCSTR symbol, int count)	
	
	{ 
	
	if(!SetMemoryFormat(format)) return CString("");
	int MemIsActive = uimem.IsActive();

	if(!MemIsActive)
		if(!Enable()) return CString("");

	if (uimem.GoToAddress(symbol) != ERROR_SUCCESS)
		return CString("");

	CString data = uimem.GetCurrentData(count);
	
	if(!MemIsActive)
		if(!Disable()) return CString("");

	LOG->RecordInfo("Memory - extracted data = %s\n", data);
	return data;
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////
// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(int address, char *data, MEM_FORMAT format /* Corresponding Format */, int count /* 1 */)
// Description: Set data at a specified memory location.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: address An integer that contains the address in memory to start setting data.
// Param: data A pointer to a buffer that contains the data to set.
// Param: format A MEM_FORMAT variable that will be used to set the memory format before setting data
// Param: count An integer that contains the number of elements of data to set in memory. (Default value is 1.)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(int address, char *data, MEM_FORMAT format, int count /* 1 */)	//TODO: use big-endian for
	{																						// mac products.
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return SetMemoryData(symbol, data, format, count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(int address, short int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(int address, short int *data, MEM_FORMAT format, int count /* 1 */)
	{																						// mac products.
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return SetMemoryData(symbol, data, format, count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(int address, unsigned short int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(int address, unsigned short int *data, MEM_FORMAT format, int count /* 1 */)
	{																						// mac products.
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return SetMemoryData(symbol, data, format, count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(int address, int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(int address, int *data, MEM_FORMAT format, int count /* 1 */)
	{																						// mac products.
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return SetMemoryData(symbol, data, format, count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(int address, unsigned int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(int address, unsigned int *data, MEM_FORMAT format, int count /* 1 */)
	{																						// mac products.
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return SetMemoryData(symbol, data, format, count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(int address, long int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(int address, long int *data, MEM_FORMAT format, int count /* 1 */)
	{																						// mac products.
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return SetMemoryData(symbol, data, format, count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(int address, unsigned long int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(int address, unsigned long int *data, MEM_FORMAT format, int count /* 1 */)
	{																						// mac products.
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return SetMemoryData(symbol, data, format, count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(int address, float *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(int address, float *data, MEM_FORMAT format, int count /* 1 */)
	{																						// mac products.
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return SetMemoryData(symbol, data, format, count);
	}

// BEGIN_HELP_COMMENT
// Function:  BOOL COMemory::SetMemoryData(int address, double *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(int address, double *data, MEM_FORMAT format, int count /* 1 */)
	{																						// mac products.
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return SetMemoryData(symbol, data, format, count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(int address, long double *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(int address, long double *data, MEM_FORMAT format, int count /* 1 */)
	{																						// mac products.
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return SetMemoryData(symbol, data, format, count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(int address, __int64 *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(int address, __int64 *data, MEM_FORMAT format, int count /* 1 */)
	{																						// mac products.
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return SetMemoryData(symbol, data, format, count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(int address, unsigned __int64 *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(int address, unsigned __int64 *data, MEM_FORMAT format, int count /* 1 */)
	{																						// mac products.
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return SetMemoryData(symbol, data, format, count);
	}

////////////////////////////////////////////////////////////////////////////////////////////////////////
// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(int address, char data, MEM_FORMAT format /* Corresponding Format */)
// Description: Set data at a specified memory location.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: address An integer that contains the address in memory to start setting data.
// Param: data A variable that contains the data to set.
// Param: format A MEM_FORMAT variable that will be used to set the memory format before setting data
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(int address, char data, MEM_FORMAT format)
	{
		//	modified by dverma Apr 2000 - must use string instead of &data
		char str[8];
		sprintf(str, "%c", data);

		return SetMemoryData(address, str, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(int address, unsigned char data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(int address, unsigned char data, MEM_FORMAT format)
	{
		//	modified by dverma Apr 2000 - must use string instead of &data
		char str[8];
		sprintf(str, "%c", data);
	
		return SetMemoryData(address, str, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(int address, short int data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(int address, short int data, MEM_FORMAT format)
	{
	return SetMemoryData(address, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(int address, unsigned short int data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(int address, unsigned short int data, MEM_FORMAT format)
	{
	return SetMemoryData(address, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(int address, int data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(int address, int data, MEM_FORMAT format)
	{
	return SetMemoryData(address, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(int address, unsigned int data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(int address, unsigned int data, MEM_FORMAT format)
	{
	return SetMemoryData(address, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(int address, long int data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(int address, long int data, MEM_FORMAT format)
	{
	return SetMemoryData(address, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(int address, unsigned long int data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(int address, unsigned long int data, MEM_FORMAT format)
	{
	return SetMemoryData(address, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(int address, float data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(int address, float data, MEM_FORMAT format)
	{
	return SetMemoryData(address, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(int address, double data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(int address, double data, MEM_FORMAT format)
	{
	return SetMemoryData(address, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(int address, long double data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(int address, long double data, MEM_FORMAT format)
	{
	return SetMemoryData(address, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(int address, __int64 data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(int address, __int64 data, MEM_FORMAT format)
	{
	return SetMemoryData(address, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(int address, unsigned __int64 data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(int address, unsigned __int64 data, MEM_FORMAT format)
	{
	return SetMemoryData(address, &data, format);
	}

////////////////////////////////////////////////////////////////////////////////////////////////////////
// BEGIN_HELP_COMMENT
// Function: int COMemory::SetMemoryData(LPCSTR symbol, char *data, MEM_FORMAT format /* Corresponding Format */, int count /* 1 */)
// Description: Set data at a specified memory location.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: symbol A pointer to a string that specifies a symbol where memory is to be set. The address of the symbol is used to as the address where memory changes will occur.
// Param: data A pointer to a buffer that contains the data to set.
// Param: format A MEM_FORMAT variable that will be used to set the memory format before setting data
// Param: count An integer that contains the number of elements of data to set in memory. (Default value is 1.)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(LPCSTR symbol, char *data, MEM_FORMAT format, int count /* 1 */)	//TODO: use big-endian for
																			// mac products.
	{
		return SetMemoryBytes(symbol, data, format);
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(LPCSTR symbol, short int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(LPCSTR symbol, short int *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	
	const int short nSymbolsInShort = 5;  // We asume that short int contains sign + 5 digits + '\0'
	char sOneShort[nSymbolsInShort];

	char *bytes = new char[count * (nSymbolsInShort + 2)];
	*bytes = '\0';

	for(int i = 0; i < count; i++)
	{
		if(data[i] > 0)
			strcat(bytes, " ");
		else
			strcat(bytes, "-");

		// Convert short to the string
		_itoa(abs(data[i]), sOneShort, 10);

		// Calculate length and add spaces
		for(short j = 0; j < nSymbolsInShort - (short) strlen(sOneShort); j++)
			strcat(bytes, " ");

		strcat(bytes, sOneShort);

	}
				
	return SetMemoryBytes(symbol, bytes, format);
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(LPCSTR symbol, unsigned short int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(LPCSTR symbol, unsigned short int *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	const int short nSymbolsInShort = 5;  // We asume that unsigned short int contains 5 digits + '\0'
	char sOneShort[nSymbolsInShort];

	char *bytes = new char[count * (nSymbolsInShort + 2)];
	*bytes = '\0';

	for(int i = 0; i < count; i++)
	{
		// Convert short to the string
		_itoa(data[i], sOneShort, 10);

		// Calculate length and add spaces
		for(short j = 0; j < nSymbolsInShort - (short) strlen(sOneShort); j++)
			strcat(bytes, " ");

		strcat(bytes, sOneShort);

	}
				
	return SetMemoryBytes(symbol, bytes, format);

	}


// BEGIN_HELP_COMMENT
// Function: int COMemory::SetMemoryData(LPCSTR symbol, int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(LPCSTR symbol, int *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	const int short nSymbolsInInt = 10;  // We asume that int contains sign + 10 digits + '\0'
	char sOneInteger[nSymbolsInInt];

	char *bytes = new char[count * (nSymbolsInInt + 2)];
	*bytes = '\0';

	for(int i = 0; i < count; i++)
	{
		if(data[i] > 0)
			strcat(bytes, " ");
		else
			strcat(bytes, "-");

		// Convert short to the string
		_itoa(abs(data[i]), sOneInteger, 10);

		// Calculate length and add spaces
		for(short j = 0; j < nSymbolsInInt - (short) strlen(sOneInteger); j++)
			strcat(bytes, " ");

		strcat(bytes, sOneInteger);

	}
				
	return SetMemoryBytes(symbol, bytes, format);	
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(LPCSTR symbol, unsigned int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(LPCSTR symbol, unsigned int *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	const int short nSymbolsInInt = 10;  // We asume that unsigned int contains 10 digits + '\0'
	char sOneInteger[nSymbolsInInt];

	char *bytes = new char[count * (nSymbolsInInt + 2)];
	*bytes = '\0';

	for(int i = 0; i < count; i++)
	{
		// Convert short to the string
		_itoa(data[i], sOneInteger, 10);

		// Calculate length and add spaces
		for(short j = 0; j < nSymbolsInInt - (short) strlen(sOneInteger); j++)
			strcat(bytes, " ");

		strcat(bytes, sOneInteger);

	}
				
	return SetMemoryBytes(symbol, bytes, format);	
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(LPCSTR symbol, long int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(LPCSTR symbol, long int *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	const int short nSymbolsInLongInt = 10;  // We asume that long int contains sign + 10 digits + '\0'
	char sOneLongInteger[nSymbolsInLongInt];

	char *bytes = new char[count * (nSymbolsInLongInt + 2)];
	*bytes = '\0';

	for(int i = 0; i < count; i++)
	{
		if(data[i] > 0)
			strcat(bytes, " ");
		else
			strcat(bytes, "-");

		// Convert short to the string
		_itoa(abs(data[i]), sOneLongInteger, 10);

		// Calculate length and add spaces
		for(short j = 0; j < nSymbolsInLongInt - (short) strlen(sOneLongInteger); j++)
			strcat(bytes, " ");

		strcat(bytes, sOneLongInteger);

	}
				
	return SetMemoryBytes(symbol, bytes, format);	
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(LPCSTR symbol, unsigned long int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(LPCSTR symbol, unsigned long int *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	const int short nSymbolsInLongInt = 10;  // We asume that unsigned long int contains 10 digits + '\0'
	char sOneLongInteger[nSymbolsInLongInt];

	char *bytes = new char[count * (nSymbolsInLongInt + 2)];
	*bytes = '\0';

	for(int i = 0; i < count; i++)
	{
		// Convert short to the string
		_itoa(data[i], sOneLongInteger, 10);

		// Calculate length and add spaces
		for(short j = 0; j < nSymbolsInLongInt - (short) strlen(sOneLongInteger); j++)
			strcat(bytes, " ");

		strcat(bytes, sOneLongInteger);

	}
				
	return SetMemoryBytes(symbol, bytes, format);	
	}

// TODO: (dklem 08/12/98) Change the code for the next three functions when #4727 gets fixed.
//	Note: the code for these functions (for the float, double and long double) is NYI because memory window behavior when 
//	changing (typing) these types is not finally defined yet.

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(LPCSTR symbol, float *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(LPCSTR symbol, float *data, MEM_FORMAT format, int count /* 1 */)
	{
	const int short nSymbolsInReal = 18;  // We asume that real contains 14 digits + 4 '{'s + '\0'
	char sOneReal[nSymbolsInReal];
	char *ptr;

	char *bytes = new char[count * (nSymbolsInReal + 2)];
	*bytes = '\0';

	for(int i = 0; i < count; i++)
	{
		// We should add a sign first
		if(data[i] > 0)
			strcat(bytes, "{+}");

		// Convert real to the string
		sprintf(sOneReal, "%.5E", data[i]);

		// we should put {} around + at the 11th position
		if(ptr = strchr(sOneReal,'+'))
		{
			memcpy(ptr + 3, ptr + 1, 3);
			strncpy(ptr, "{+}", 3);
			*(ptr + 6) = '\0';
		}

		strcat(bytes, sOneReal);
	}
				
	return SetMemoryBytes(symbol, bytes, format);	
	
	}	

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(LPCSTR symbol, double *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(LPCSTR symbol, double *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	const int short nSymbolsInDouble = 27;  // We asume that double contains 23 digits + 4 '{'s + '\0'
	char sOneDouble[nSymbolsInDouble];
	char *ptr;

	char *bytes = new char[count * (nSymbolsInDouble + 2)];
	*bytes = '\0';

	for(int i = 0; i < count; i++)
	{
		// We should add a sign first
		if(data[i] > 0)
			strcat(bytes, "{+}");

		// Convert double to the string
		sprintf(sOneDouble, "%.15E",  data[i]);

		// we should put {} around + at the 11th position
		if(ptr = strchr(sOneDouble,'+'))
		{
			memcpy(ptr + 3, ptr + 1, 3);
			strncpy(ptr, "{+}", 3);
			*(ptr + 6) = '\0';
		}

		strcat(bytes, sOneDouble);
	}
				
	return SetMemoryBytes(symbol, bytes, format);	
}


// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(LPCSTR symbol, long double *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(LPCSTR symbol, long double *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	const int short nSymbolsInLongDouble = 27;  // We asume that long double contains 23 digits + 4 '{'s + '\0'
	char sOneLongDouble[nSymbolsInLongDouble];
	char *ptr;

	char *bytes = new char[count * (nSymbolsInLongDouble + 2)];
	*bytes = '\0';

	for(int i = 0; i < count; i++)
	{
		// We should add a sign first
		if(data[i] > 0)
			strcat(bytes, "{+}");

		// Convert long double to the string
		sprintf(sOneLongDouble, "%.14E", (double) data[i]);

		// we should put {} around + at the 11th position
		if(ptr = strchr(sOneLongDouble,'+'))
		{
			memcpy(ptr + 3, ptr + 1, 3);
			strncpy(ptr, "{+}", 3);
			*(ptr + 6) = '\0';
		}

		strcat(bytes, sOneLongDouble);
	}
				
	return SetMemoryBytes(symbol, bytes, format);	

	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(LPCSTR symbol, __int64 *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(LPCSTR symbol, __int64 *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	const int short nSymbolsInInt64 = 19;  // We asume that __int64 contains sign + 19 digits + '\0'
	char sOneInteger64[nSymbolsInInt64];

	char *bytes = new char[count * (nSymbolsInInt64 + 2)];
	*bytes = '\0';

	for(int i = 0; i < count; i++)
	{
		if(data[i] > 0)
			strcat(bytes, " ");
		else 
		{
			strcat(bytes, "-");
			// Since there is no abs for __int64, we do abs here manually
			data[i] -= (2*data[i]);
		}
		
		// Convert short to the string
		_i64toa(data[i], sOneInteger64, 10);

		// Calculate length and add spaces
		for(short j = 0; j < nSymbolsInInt64 - (short) strlen(sOneInteger64); j++)
			strcat(bytes, " ");

		strcat(bytes, sOneInteger64);

	}
				
	return SetMemoryBytes(symbol, bytes, format);	
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(LPCSTR symbol, unsigned __int64 *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(LPCSTR symbol, unsigned __int64 *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	const int short nSymbolsInInt64 = 19;  // We asume that unsigned __int64 contains 19 digits + '\0'
	char sOneInteger64[nSymbolsInInt64];

	char *bytes = new char[count * (nSymbolsInInt64 + 2)];
	*bytes = '\0';

	for(int i = 0; i < count; i++)
	{
		// Convert short to the string
		_ui64toa(data[i], sOneInteger64, 10);

		// Calculate length and add spaces
		for(short j = 0; j < nSymbolsInInt64 - (short) strlen(sOneInteger64); j++)
			strcat(bytes, " ");

		strcat(bytes, sOneInteger64);

	}
				
	return SetMemoryBytes(symbol, bytes, format);	
	}


////////////////////////////////////////////////////////////////////////////////////////////////////////
// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(LPCSTR symbol, char data, MEM_FORMAT format /* Corresponding Format */)
// Description: Set data at a specified memory location.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: symbol A pointer to a string that specifies a symbol where memory is to be set. The address of the symbol is used to as the address where memory changes will occur.
// Param: data A char that contains the data to set.
// Param: format A MEM_FORMAT variable that will be used to set the memory format before setting data
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(LPCSTR symbol, char data, MEM_FORMAT format)
	{
		//	modified by dverma Apr 2000 - must use string instead of &data
		char str[8];
		sprintf(str, "%c", data);

		return SetMemoryData(symbol, str, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(LPCSTR symbol, unsigned char data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(LPCSTR symbol, unsigned char data, MEM_FORMAT format)
	{
		//	modified by dverma Apr 2000 - must use string instead of &data
		char str[8];
		sprintf(str, "%c", data);

		return SetMemoryData(symbol, str, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(LPCSTR symbol, short int data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(LPCSTR symbol, short int data, MEM_FORMAT format)
	{
	return SetMemoryData(symbol, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(LPCSTR symbol, int data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(LPCSTR symbol, int data, MEM_FORMAT format)
	{
	return SetMemoryData(symbol, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(LPCSTR symbol, unsigned short int data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(LPCSTR symbol, unsigned short int data, MEM_FORMAT format)
	{
	return SetMemoryData(symbol, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(LPCSTR symbol, unsigned int data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(LPCSTR symbol, unsigned int data, MEM_FORMAT format)
	{
	return SetMemoryData(symbol, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(LPCSTR symbol, long int data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(LPCSTR symbol, long int data, MEM_FORMAT format)
	{
	return SetMemoryData(symbol, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(LPCSTR symbol, unsigned long int data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(LPCSTR symbol, unsigned long int data, MEM_FORMAT format)
	{
	return SetMemoryData(symbol, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(LPCSTR symbol, float data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(LPCSTR symbol, float data, MEM_FORMAT format)
	{
	return SetMemoryData(symbol, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(LPCSTR symbol, double data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(LPCSTR symbol, double data, MEM_FORMAT format)
	{
	return SetMemoryData(symbol, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(LPCSTR symbol, long double data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(LPCSTR symbol, long double data, MEM_FORMAT format)
	{
	return SetMemoryData(symbol, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(LPCSTR symbol, __int64 data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(LPCSTR symbol, __int64 data, MEM_FORMAT format)
	{
	return SetMemoryData(symbol, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryData(LPCSTR symbol, unsigned __int64 data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::SetMemoryData(LPCSTR symbol, unsigned __int64 data, MEM_FORMAT format)
	{
	return SetMemoryData(symbol, &data, format);
	}


BOOL COMemory::SetMemoryBytes(int address, LPCSTR bytes, MEM_FORMAT format)
	{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return SetMemoryBytes(symbol, bytes, format);
	}


// TODO (michma): needs error logging.
BOOL COMemory::SetMemoryBytes(LPCSTR symbol, LPCSTR bytes, MEM_FORMAT format)

	{
	if(!SetMemoryFormat(format)) return FALSE;
	int MemIsActive = uimem.IsActive();

	if(!MemIsActive)
		if(!Enable()) return FALSE;

	if(uimem.GoToAddress(symbol) != ERROR_SUCCESS) return FALSE;
	if(!uimem.SetCurrentData(bytes)) return FALSE;
	
	if(!MemIsActive)
		if(!Disable()) return FALSE;

	return TRUE;
	}


////////////////////////////////////////////////////////////////////////////////////////////////////////
// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, char *data, MEM_FORMAT format, int count /* 1 */)
// Description: Determine if the data at the specified address is the same as the data given.
// Return: A Boolean value that indicates whether the data at the specified address is the same as the data given (TRUE) or not.
// Param: address An integer that contains the address in memory to compare with.
// Param: data A pointer to a buffer that contains the data to compare against.
// Param: count An integer that contains the number of elements of data to compare. (Default value is 1.)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, char *data, MEM_FORMAT format, int count /* 1 */)
{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return MemoryDataIs(symbol, data, format, count);
}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(int address, unsigned char *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, unsigned char *data, MEM_FORMAT format, int count /* 1 */)
{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return MemoryDataIs(symbol, data, format, count);
}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(int address, short int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, short int *data, MEM_FORMAT format, int count /* 1 */)
{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return MemoryDataIs(symbol, data, format, count);
}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(int address, unsigned short int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, unsigned short int *data, MEM_FORMAT format, int count /* 1 */)
{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return MemoryDataIs(symbol, data, format, count);
}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(int address, int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, int *data, MEM_FORMAT format, int count /* 1 */)
{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return MemoryDataIs(symbol, data, format, count);
}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(int address, unsigned int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, unsigned int *data, MEM_FORMAT format, int count /* 1 */)
{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return MemoryDataIs(symbol, data, format, count);
}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(int address, long int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, long int *data, MEM_FORMAT format, int count /* 1 */)
{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return MemoryDataIs(symbol, data, format, count);
}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(int address, unsigned long int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, unsigned long int *data, MEM_FORMAT format, int count /* 1 */)
{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return MemoryDataIs(symbol, data, format, count);
}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(int address, float *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, float *data, MEM_FORMAT format, int count /* 1 */)
{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return MemoryDataIs(symbol, data, format, count);
}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(int address, double *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, double *data, MEM_FORMAT format, int count /* 1 */)
{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return MemoryDataIs(symbol, data, format, count);
}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(int address, long double *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, long double *data, MEM_FORMAT format, int count /* 1 */)
{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return MemoryDataIs(symbol, data, format, count);
}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(int address, __int64 *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, __int64 *data, MEM_FORMAT format, int count /* 1 */)
{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return MemoryDataIs(symbol, data, format, count);
}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(int address, unsigned __int64 *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, unsigned __int64 *data, MEM_FORMAT format, int count /* 1 */)
{
	char symbol[16];
	sprintf(symbol, "%08x", address);
	return MemoryDataIs(symbol, data, format, count);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, char *data, MEM_FORMAT format, int count /* 1 */)
// Description: Determine if the data at the specified address is the same as the data given.
// Return: A Boolean value that indicates whether the data at the specified address is the same as the data given (TRUE) or not.
// Param: symbol A pointer that contains the symbol in memory to compare with.
// Param: data A pointer to a buffer that contains the data to compare against.
// Param: count An integer that contains the number of elements of data to compare. (Default value is 1.)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, char *data, MEM_FORMAT format, int count /* 1 */)
	{
	char *memdata = new char[count];
	EXPECT(GetMemoryData(symbol, memdata, format, count));

	// If length of data is less than count we need to limit count
	if(count > (int) strlen(data))
		count = (int) strlen(data);

//	for (int i = 0; i < count; i++)
//		if(data[i] != memdata[i])
//			break;
	BOOL bRes = (0 == _strnicmp(data, memdata, count));

	delete[] memdata;
//	return (i == count);
	return bRes;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, unsigned char *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, unsigned char *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	unsigned char *memdata = new unsigned char[count];
	EXPECT(GetMemoryData(symbol, memdata, format, count));

	// If length of data is less than count we need to limit count
	if(count > (int) strlen((char*) data))
		count = (int) strlen((char*) data);

	for (int i = 0; i < count; i++)
		if(data[i] != memdata[i])
			break;

	delete[] memdata;
	return (i == count);
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, short int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, short int *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	short int *memdata = new short int[count];
	EXPECT(GetMemoryData(symbol, memdata, format, count));

	for (int i = 0; i < count; i++)
		if(data[i] != memdata[i])
			break;

	delete[] memdata;
	return (i == count);
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, unsigned short int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, unsigned short int *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	unsigned short int *memdata = new unsigned short int[count];
	EXPECT(GetMemoryData(symbol, memdata, format, count));

	for (int i = 0; i < count; i++)
		if(data[i] != memdata[i])
			break;

	delete[] memdata;
	return (i == count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, int *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	int *memdata = new int[count];
	EXPECT(GetMemoryData(symbol, memdata, format, count));

	for (int i = 0; i < count; i++)
		if(data[i] != memdata[i])
			break;

	delete[] memdata;
	return (i == count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, unsigned int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, unsigned int *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	unsigned int *memdata = new unsigned int[count];
	EXPECT(GetMemoryData(symbol, memdata, format, count));

	for (int i = 0; i < count; i++)
		if(data[i] != memdata[i])
			break;

	delete[] memdata;
	return (i == count);
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, long int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, long int *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	long int *memdata = new long int[count];
	EXPECT(GetMemoryData(symbol, memdata, format, count));

	for (int i = 0; i < count; i++)
		if(data[i] != memdata[i])
			break;

	delete[] memdata;
	return (i == count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, unsigned long int *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, unsigned long int *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	unsigned long int *memdata = new unsigned long int[count];
	EXPECT(GetMemoryData(symbol, memdata, format, count));

	for (int i = 0; i < count; i++)
		if(data[i] != memdata[i])
			break;

	delete[] memdata;
	return (i == count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, float *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, float *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	float *memdata = new float[count];
	EXPECT(GetMemoryData(symbol, memdata, format, count));

	char str1[128], str2[128];

	// Since comparing floats doesn't give correct results if one of them is a result of atof
	// we compare strings

	for (int i = 0; i < count; i++)
	{
		memset(str1, 0, sizeof(str1));
		memset(str2, 0, sizeof(str2));

		sprintf(str1, "%.5e", data[i]);
		sprintf(str2, "%.5e", memdata[i]);
		if(strcmp(str1,str2))
			break;
	}

	delete[] memdata;
	return (i == count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, double *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, double *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	double *memdata = new double[count];
	EXPECT(GetMemoryData(symbol, memdata, format, count));

	char str1[128], str2[128];

	// Since comparing doubles doesn't give correct results if one of them is a result of atof
	// we compare strings

	for (int i = 0; i < count; i++)
	{
		memset(str1, 0, sizeof(str1));
		memset(str2, 0, sizeof(str2));

		sprintf(str1, "%.14e", data[i]);
		sprintf(str2, "%.14e", memdata[i]);
		if(strcmp(str1,str2))
			break;
	}

	delete[] memdata;
	return (i == count);
	}


// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, long double *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, long double *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	long double *memdata = new long double[count];
	EXPECT(GetMemoryData(symbol, memdata, format, count));

	char str1[128], str2[128];

	// Since comparing long doubles doesn't give correct results if one of them is a result of atof
	// we compare strings

	for (int i = 0; i < count; i++)
	{
		memset(str1, 0, sizeof(str1));
		memset(str2, 0, sizeof(str2));

		sprintf(str1, "%.14e", data[i]);
		sprintf(str2, "%.14e", memdata[i]);
		if(strcmp(str1,str2))
			break;
	}

	delete[] memdata;
	return (i == count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, __int64 *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, __int64 *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	__int64 *memdata = new __int64[count];
	EXPECT(GetMemoryData(symbol, memdata, format, count));

	for (int i = 0; i < count; i++)
		if(data[i] != memdata[i])
			break;

	delete[] memdata;
	return (i == count);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, unsigned __int64 *data, MEM_FORMAT format, int count /* 1 */)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, unsigned __int64 *data, MEM_FORMAT format, int count /* 1 */)
	
	{
	unsigned __int64 *memdata = new unsigned __int64[count];
	EXPECT(GetMemoryData(symbol, memdata, format, count));

	for (int i = 0; i < count; i++)
		if(data[i] != memdata[i])
			break;

	delete[] memdata;
	return (i == count);
	}

////////////////////////////////////////////////////////////////////////////////////////////////////////
// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(int address, char data, MEM_FORMAT format)
// Description: Determine if the data at the specified address is the same as the data given.
// Return: A Boolean value that indicates whether the data at the specified address is the same as the data given (TRUE) or not.
// Param: address An integer that contains the address in memory to compare with.
// Param: data A char that contains the data to compare against.
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, char data, MEM_FORMAT format)
	{
	return MemoryDataIs(address, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(int address, unsigned char data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, unsigned char data, MEM_FORMAT format)
	{
	return MemoryDataIs(address, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(int address, short int data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, short int data, MEM_FORMAT format)
	{
	return MemoryDataIs(address, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(int address, unsigned short int data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, unsigned short int data, MEM_FORMAT format)
	{
	return MemoryDataIs(address, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(int address, int data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, int data, MEM_FORMAT format)
	{
	return MemoryDataIs(address, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(int address, unsigned int data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, unsigned int data, MEM_FORMAT format)
	{
	return MemoryDataIs(address, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(int address, long int data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, long int data, MEM_FORMAT format)
	{
	return MemoryDataIs(address, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(int address, unsigned long int data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, unsigned long int data, MEM_FORMAT format)
	{
	return MemoryDataIs(address, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(int address, float data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, float data, MEM_FORMAT format)
	{
	return MemoryDataIs(address, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(int address, double data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, double data, MEM_FORMAT format)
	{
	return MemoryDataIs(address, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(int address, long double data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, long double data, MEM_FORMAT format)
	{
	return MemoryDataIs(address, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(int address, __int64 data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, __int64 data, MEM_FORMAT format)
	{
	return MemoryDataIs(address, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(int address, unsigned __int64 data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(int address, unsigned __int64 data, MEM_FORMAT format)
	{
	return MemoryDataIs(address, &data, format);
	}

////////////////////////////////////////////////////////////////////////////////////////////////////////
// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, char data, MEM_FORMAT format)
// Description: Determine if the data at the specified address is the same as the data given.
// Return: A Boolean value that indicates whether the data at the specified address is the same as the data given (TRUE) or not.
// Param: symbol A pointer that contains the symbol in memory to compare with.
// Param: data A char that contains the data to compare against.
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, char data, MEM_FORMAT format)
	{
	return MemoryDataIs(symbol, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, unsigned char data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, unsigned char data, MEM_FORMAT format)
	{
	return MemoryDataIs(symbol, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, short int data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, short int data, MEM_FORMAT format)
	{
	return MemoryDataIs(symbol, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, unsigned short int data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, unsigned short int data, MEM_FORMAT format)
	{
	return MemoryDataIs(symbol, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, int data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, int data, MEM_FORMAT format)
	{
	return MemoryDataIs(symbol, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, unsigned int data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, unsigned int data, MEM_FORMAT format)
	{
	return MemoryDataIs(symbol, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, long int data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, long int data, MEM_FORMAT format)
	{
	return MemoryDataIs(symbol, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, unsigned long int data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, unsigned long int data, MEM_FORMAT format)
	{
	return MemoryDataIs(symbol, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, float data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, float data, MEM_FORMAT format)
	{
	return MemoryDataIs(symbol, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, double data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, double data, MEM_FORMAT format)
	{
	return MemoryDataIs(symbol, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, long double data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, long double data, MEM_FORMAT format)
	{
	return MemoryDataIs(symbol, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, __int64 data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, __int64 data, MEM_FORMAT format)
	{
	return MemoryDataIs(symbol, &data, format);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::MemoryDataIs(LPCSTR symbol, unsigned __int64 data, MEM_FORMAT format)
// END_HELP_COMMENT
BOOL COMemory::MemoryDataIs(LPCSTR symbol, unsigned __int64 data, MEM_FORMAT format)
	{
	return MemoryDataIs(symbol, &data, format);
	}

////////////////////////////////////////////////////////////////////////////////////////////////////////
// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetMemoryFormat(MEM_FORMAT format)	
// Description: Set the format of the memory window. 
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: format A MEM_FORMAT value specifying the format of the memory window: MEM_FORMAT_ASCII, MEM_FORMAT_WCHAR, 
//	MEM_FORMAT_BYTE, MEM_FORMAT_SHORT, MEM_FORMAT_SHORT_HEX, MEM_FORMAT_SHORT_UNSIGNED, MEM_FORMAT_LONG, MEM_FORMAT_LONG_HEX, 
//	MEM_FORMAT_LONG_UNSIGNED, MEM_FORMAT_REAL, MEM_FORMAT_REAL_LONG, MEM_FORMAT_INT64, MEM_FORMAT_INT64_HEX, MEM_FORMAT_INT64_UNSIGNED
// END_HELP_COMMENT

BOOL COMemory::SetMemoryFormat(MEM_FORMAT format)	
{

	//Activate memory window
	if (TRUE != uimem.Activate())
	{
		LOG->RecordInfo("ERROR. Can Not Activate Memory Window");
		return FALSE;
	}

	//Set format
	//uimem.SetMemoryFormat(format);
	if(!UIWB.SetMemoryFormat(format))
		return FALSE;
	else
	{
		uimem.m_MemoryFormat = format;
		return TRUE;
	}
}


// BEGIN_HELP_COMMENT
// Function: CString COMemory::GetColumns(void)
// Description: Gets number of columns in memory window
// Param: No Params
// Return: CString Number of columns
// END_HELP_COMMENT
CString COMemory::GetColumns(void)
{	
	//Activate memory window
	if (TRUE != uimem.Activate())
	{
		LOG->RecordInfo("ERROR. Can Not Activate Memory Window");
		return "";
	}

	return uimem.GetColumns();
}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::SetColumns(CString Columns)
// Description: Sets number of columns in memory window
// Param: Columns A number of columns or "<Auto>"
// Return: A Boolean value that indicates whether the set column operatin was sucessfull (TRUE) or not.
// END_HELP_COMMENT
BOOL COMemory::SetColumns(CString Columns)
{
	//Activate memory window
	if (TRUE != uimem.Activate())
	{
		LOG->RecordInfo("ERROR. Can Not Activate Memory Window");
		return FALSE;
	}

	return uimem.SetColumns(Columns);
}


// BEGIN_HELP_COMMENT
// Function: CString COMemory::GetAddress(CString symbol)
// Description: Returns the adddress of a symbol
// Param: symbol A symbol whoes address should be returned
// Return: CString The address of the symbol
// END_HELP_COMMENT
CString COMemory::GetAddress(CString symbol)
{
	//Activate memory window
	if (TRUE != uimem.Activate())
	{
		LOG->RecordInfo("ERROR. Can Not Activate Memory Window");
		return CString("");
	}
	if(ERROR_SUCCESS != uimem.GoToAddress(symbol))
	{
		LOG->RecordInfo("ERROR. Can Not Go To Address");
		return CString("");
	}

	return uimem.GetCurrentAddress();
}

// BEGIN_HELP_COMMENT
// Function: BOOL COMemory::CycleMemoryFormat(int count)
// Description: Cycles though memory formats
// Param: count A number of "Next Format" changes that will be done 
// Return: A Boolean value that indicates whether the cycle operatin was sucessfull (TRUE) or not..
// END_HELP_COMMENT

BOOL COMemory::CycleMemoryFormat(int count)
{
	return uimem.CycleMemoryFormat(count);
}


#pragma warning (default : 4069)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\colocals.h ===
///////////////////////////////////////////////////////////////////////////////
//  COLOCALS.H
//
//  Created by:            Date:
//      MichMa                  10/26/97
//
//  Description:
//      Declaration of the COLocals class
//

#ifndef __COLOCALS_H__
#define __COLOCALS_H__

#include "uivar.h"
#include "coee.h"
#include "dbgxprt.h"

#pragma warning (disable : 4069)


///////////////////////////////////////////////////////////////////////////////
//  CLocal class

// BEGIN_CLASS_HELP
// ClassName: CLocal
// BaseClass: none
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS CLocal

{
public:

	CString m_strType;
	CString m_strName;
	CString m_strValue;
	EXPR_STATE m_ExprState;
	CLocal(void){}

	const CLocal& operator=(const CLocal &LocalSrc)
	{
		m_strType = LocalSrc.m_strType;
		m_strName = LocalSrc.m_strName;
		m_strValue = LocalSrc.m_strValue;
		m_ExprState = LocalSrc.m_ExprState;
		return *this;	
	}

	CLocal(CLocal &LocalSrc)
	{
		m_strType = LocalSrc.m_strType;
		m_strName = LocalSrc.m_strName;
		m_strValue = LocalSrc.m_strValue;
		m_ExprState = LocalSrc.m_ExprState;
	}
};


///////////////////////////////////////////////////////////////////////////////
//  COLocals class

// BEGIN_CLASS_HELP
// ClassName: COLocals
// BaseClass: none
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS COLocals

{
	// Data
	private:
		UIVariables uivar;
		COExpEval coee;

	// Utilities
	public:
		BOOL VerifyLocalInfo(CLocal Local);
		BOOL VerifyLocalInfo(LPCSTR szName, LPCSTR szValue,  LPCSTR szType, EXPR_STATE ExprState);
		BOOL LocalDoesNotExist(LPCSTR szLocal);
		BOOL LocalsCountIs(int intLocalCount);
		BOOL SetLocalValue(LPCSTR szLocal, LPCSTR szValue);
};

#endif // __COLOCALS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\coreg.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  COREG.CPP
//
//  Created by :            Date :
//      WayneBr                 1/14/94
//
//  Description :
//      Implementation of the CORegisters class
//

#include "stdafx.h"
#include "coreg.h"
#include "testxcpt.h"
#include "..\sym\qcqp.h"
#include "guiv1.h"
#include "..\shl\uwbframe.h"
#include "uidebug.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


// BEGIN_HELP_COMMENT
// Function: int CORegisters::GetRegister(int reg)
// Description: Get the value of one of the registers.
// Return: An integer that contains the value of the specified register.
// Param: reg An integer that specifies the 1-based index into the set of registers.
// END_HELP_COMMENT
int  CORegisters::GetRegister(int reg)
	{
	EXPECT(uireg = UIDebug::ShowDockWindow(IDW_CPU_WIN));
	int temp  = uireg.GetRegister(reg);
	EXPECT(uireg.Close());
	return  temp;
	};

// BEGIN_HELP_COMMENT
// Function: BOOL CORegisters::RegisterValueIs(int reg, int value)
// Description: Determine whether the given register's value matches the given value.
// Return: A Boolean that indicates whether the given register's value matches the given value (TRUE) or not.
// Param: reg An integer that specifies the 1-based index into the set of registers.
// Param: value An integer that contains the expected register value.
// END_HELP_COMMENT
BOOL  CORegisters::RegisterValueIs(int reg, int value)
	{
	EXPECT(uireg = UIDebug::ShowDockWindow(IDW_CPU_WIN));
	int temp  = uireg.GetRegister(reg);
	if (temp!=value)
	{
		// log warning
		LOG->RecordInfo( (LPCSTR) "Register Values is %d, expected %d",temp, value);
	}
	EXPECT(uireg.Close());
	return  temp==value;
	};


// BEGIN_HELP_COMMENT
// Function: BOOL CORegisters::SetRegister(int reg, LPCSTR value)
// Description: Set the value of the specified register.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: reg An integer that specifies the 1-based index into the set of registers.
// Param: value A pointer to a string that contains the value to set the specified register to.
// END_HELP_COMMENT
BOOL CORegisters::SetRegister(int reg, LPCSTR value)
	{
	EXPECT(uireg = UIDebug::ShowDockWindow(IDW_CPU_WIN));
	EXPECT(uireg.SetRegister(reg, value ));
	return uireg.Close();
	};


// BEGIN_HELP_COMMENT
// Function: BOOL CORegisters::Enable()
// Description: Enable access to registers in the debugger.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL CORegisters::Enable()
{
	return uireg.Activate();
}


// BEGIN_HELP_COMMENT
// Function: BOOL CORegisters::Disable()
// Description: Disable access to registers in the debugger.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL CORegisters::Disable()
{
	// TODO(michma)
	// return FALSE;
	return uireg.Close();
}

// BEGIN_HELP_COMMENT
// Function: CString CORegisters::GetRegister(CString csRegister, int *pnValue)
// Description: Get the value of one of the registers.
// Return: A CString that contains the value of the specified register.
// Param : CString csRegister a string that specifies the register
// Param int* pnValue A pointer to integer that contains the value of the specified register.
// END_HELP_COMMENT
CString CORegisters::GetRegister(CString csRegister, int *pnValue)
{
	return uireg.GetRegister(csRegister, pnValue);
}

// BEGIN_HELP_COMMENT
// Function: BOOL CORegisters::SetRegister(CString csRegister, CString szValue, int nValue, BOOL bValueIsCString = TRUE)
// Description: Set the value of the specified register.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param : CString csRegister CString that specifies the register to be set
// Param : CString szValue A CString that contains the value to set the specified register to
// Param : int nValue An int that contains the value to set the specified register to
// Param : bValueIsCString A BOOL that indicats if value is represented in the form of CString (TRUE) or int
// END_HELP_COMMENT
BOOL CORegisters::SetRegister(CString csRegister, CString szValue, int nValue, BOOL bValueIsCString /* TRUE */)
{
	return uireg.SetRegister(csRegister, szValue, nValue, bValueIsCString);
}

// BEGIN_HELP_COMMENT
// Function: BOOL CORegisters::RegisterValueIs(CString csRegister, CString szValue, int nValue, BOOL bValueIsCString = TRUE)
// Description: Determine whether the given register's value matches the given value.
// Return: A Boolean that indicates whether the given register's value matches the given value (TRUE) or not.
// Param : CString csRegister CString that specifies the register to be set
// Param : CString szValue A CString that contains the expected register value
// Param : int nValue An int that contains the expected register value
// Param : bValueIsCString A BOOL that indicats if value is represented in the form of CString (TRUE) or int
// END_HELP_COMMENT
BOOL CORegisters::RegisterValueIs(CString csRegister, CString szValue, int nValue, BOOL bValueIsCString /* TRUE */)
{
	CString csActualValue;
	int nActualValue;
	BOOL bRetValue;

	UIDebug::ShowDockWindow(IDW_CPU_WIN);
	csActualValue = uireg.GetRegister(csRegister, &nActualValue);

	if(csActualValue.IsEmpty())
		return FALSE;


	if(bValueIsCString)
		bRetValue = (szValue == csActualValue);

	else
		bRetValue = (nValue == nActualValue);

	if(!bRetValue)
	{
		if(bValueIsCString)
			LOG->RecordInfo((LPCSTR) "Actual Register (%s) value (%s) doesn't match the given value (%s)", 
						LPCTSTR(csRegister), LPCTSTR(csActualValue), LPCTSTR(szValue ));
		else
			LOG->RecordInfo((LPCSTR) "Actual Register (%s) value doesn't match the given value ", LPCTSTR(csRegister));
	}

	return bRetValue;
}


// BEGIN_HELP_COMMENT
//	added by dverma 3/21/2000
// Function: BOOL CORegisters::RegisterDisplayed(CString csRegister)
// Description: Checks whether the given register is displayed in the registers window
// Return: A Boolean that indicates whether the given register was displayed or not
// Param : CString that specifies the register to checked
// END_HELP_COMMENT
BOOL CORegisters::RegisterDisplayed(CString csRegister)
{
	return uireg.RegisterDisplayed(csRegister);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\coreg.h ===
///////////////////////////////////////////////////////////////////////////////
//  COREG.H
//
//  Created by :            Date :
//      WayneBr             1/14/94
//
//  Description :
//      Declaration of the CORegisters class
//

#ifndef __COREG_H__
#define __COREG_H__

#include "uireg.h"

#include "dbgxprt.h"

///////////////////////////////////////////////////////////////////////////////
//  CORegisters class

// BEGIN_CLASS_HELP
// ClassName: CORegisters
// BaseClass: none
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS CORegisters

	{

	// Data
	private:
		UIRegisters uireg;

	// Utilities
	public:
		int  GetRegister(int reg);
		BOOL SetRegister(int reg, LPCSTR value);
		BOOL RegisterValueIs(int reg, int value);
		BOOL Enable(void);
		BOOL Disable(void);

		CString GetRegister(CString csRegister, int *pnValue);
		BOOL SetRegister(CString csRegister, CString szValue, int nValue, BOOL bValueIsCString = TRUE);
		BOOL RegisterValueIs(CString csRegister, CString szValue, int nValue, BOOL bValueIsCString = TRUE);

		//	added by dverma 3/21/2000
		BOOL RegisterDisplayed(CString csRegister);
	};

#endif // __COREG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\costack.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  COSTACK.CPP
//
//  Created by :            Date :
//      WayneBr                 1/14/94
//
//  Description :
//      Implementation of the COStack class
//

#include "stdafx.h"
#include "costack.h"
#include "testxcpt.h"
#include "mstwrap.h"
#include "..\sym\qcqp.h"
#include "guiv1.h"
#include "..\shl\uwbframe.h"
#include "codebug.h"
#include "uidebug.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

COStack::COStack( CODebug* owner ) {
	m_pOwner = NULL;
	if( owner ) {
		// Setup cooperation with owning CODebug instance.
		owner->SetOwnedStack( this );
	}
}


// BEGIN_HELP_COMMENT
// Function: BOOL COStack::RunToFrame(CString strFrame, int ambiguity /* 0 */)
// Description: Run to the given call stack frame.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: strFrame A CString that contains the name of the call stack frame to run to.
// Param: ambiguity An integer that contains the 1-based index of the list of entries to resolve an ambiguity. (Default value is -1.)
// END_HELP_COMMENT
BOOL COStack::RunToFrame(CString strFrame, int ambiguity /* 0 */)
{
	return RunToFrame(Index(strFrame), ambiguity);
}


// BEGIN_HELP_COMMENT
// Function: int COStack::Index( CString str )
// Description: Get the index of the given call stack frame in the current call stack.
// Return: An integer that contains the index of the given call stack frame.
// Param: str A CString that contains the name of the call stack frame.
// END_HELP_COMMENT
int COStack::Index( CString str ) {
	CString strStack = GetAllFunctions();
	FrameList list;
	list.CreateFromText( strStack );
	return list.Index( str );
}


// BEGIN_HELP_COMMENT
// Function: BOOL COStack::CurrentFunctionIs(LPCSTR str)
// Description: Determine if the current function matches the given function.
// Return: A Boolean value that indicates whether the current function matches the given function (TRUE) or not.
// Param: str A pointer to a string that contains the name of the expected function.
// END_HELP_COMMENT
BOOL COStack::CurrentFunctionIs(LPCSTR str) {
		return FunctionIs( str, 0 );
}

// BEGIN_HELP_COMMENT
// Function: BOOL COStack::VerifyCurrentFunction(LPCSTR str)
// Description: Determine if the current function matches the given function.
// Return: A Boolean value that indicates whether the current function matches the given function (TRUE) or not.
// Param: str A pointer to a string that contains the name of the expected function.
// END_HELP_COMMENT
BOOL COStack::VerifyCurrentFunction(LPCSTR str) {
		return FunctionIs( str, 0 );
}

// BEGIN_HELP_COMMENT
// Function: CString COStack::GetFunction(int level /* 0 */, BOOL bNameOnly /* FALSE */)
// Description: Get the call stack description string at the given call stack level (index).
// Return: A CString that contains the call stack description string from the given call stack level.
// Param: level An integer that contains the 0-based index into the call stack. (Default value is 0.)
// Param: bNameOnly A boolean specifying whether or not to return the name of the function only (rather than the whole line)..
// END_HELP_COMMENT
CString COStack::GetFunction(int level /* 0 */, BOOL bNameOnly /* FALSE */)	{
	HWND hFocus = ::WGetFocus();

	CString current;

#if defined(V4LOW)	// V4Low (or standard) does not have a call-stack window.
	EXPECT(uivar = UIDebug::ShowDockWindow(IDW_LOCALS_WIN));
	current = uivar.GetFunction(level);
#else
	EXPECT(uistack = UIDebug::ShowDockWindow(IDW_CALLS_WIN));
	// if callstack line in question displays same string
	// over 500 ms, we'll assume it is done painting.
	// we'll only wait 5 seconds though.
	CString last = uistack.GetFunction(level);

	for(int i = 0; i < 10; i++)
		
		{
		Sleep(500);
		current = uistack.GetFunction(level);

		if((current == last) && (current != ""))
			break;
		
		last = current;
		}

	// REVIEW (michma): we don't want the stack to be closed so it is visible during the sniff (more
	// coverage). however, what we probably should do later is close it	only if it wasn't open previously.
	// the memory and ee component classes already support such behavior.
	//EXPECT(uistack.Close());	
#endif

	if( hFocus ) {
		::QueSetFocus( hFocus );
		::QueFlush( FALSE );
	}
	else {
		LOG->RecordInfo( "COStack::GetFunction(): focus was NULL" );
	}

	// check if we are returning the function name only.
	if(bNameOnly)
	{
		// find the opening parentheses marking the end of the function name.
		int iParen = current.Find("(");
		// function name must be at least 1 character long.
		if(iParen > 0)
			// parse the function name.
			current = current.Left(current.GetLength() - iParen);
	}

	return current;
}

// BEGIN_HELP_COMMENT
// Function: CString COStack::GetAllFunctions(void)
// Description: Get all the call stack frame descriptions for all frames on the call stack.
// Return: A CString that contains a newline-delimited list of call stack frames.
// END_HELP_COMMENT
CString COStack::GetAllFunctions(void) {
	if( IsDirty() ) {
		HWND hFocus = ::WGetFocus();

		#if defined(V4LOW)
			EXPECT(uivar = UIDebug::ShowDockWindow(IDW_LOCALS_WIN));
			m_LastStack = uivar.GetAllFunctions();
		#else
			EXPECT(uistack = UIDebug::ShowDockWindow(IDW_CALLS_WIN));
			m_LastStack = uistack.GetAllFunctions();
			// REVIEW (michma): we don't want the stack to be closed so it is visible during the sniff (more
			// coverage). however, what we probably should do later is close it	only if it wasn't open previously.
			// the memory and ee component classes already support such behavior.
			// EXPECT(uistack.Close());
		#endif

		if( hFocus ) {
			::QueSetFocus( hFocus );
			::QueFlush( FALSE );
		}
		else {
			LOG->RecordInfo( "COStack::GetAllFunctions(): focus was NULL" );
		}
		SetDirty( FALSE );
	}

	return  m_LastStack;
}

// BEGIN_HELP_COMMENT
// Function: int COStack::NavigateStack( CString str )
// Description: Navigate to the given call stack frame & checks the line number navigated to.
// Return: 0 if not successful; -1 if no source avail; line no otherwise.
// Param: str A CString that contains the name of the call stack frame to navigate to.
// END_HELP_COMMENT
int COStack::NavigateStack( CString str ) {
	return NavigateStack( Index( str ) );
}


// BEGIN_HELP_COMMENT
// Function: int COStack::NavigateStack(int level /* 0 */)
// Description: Navigate to the given call stack frame & checks the line number navigated to.
// Return: 0 if not successful; -1 if no source avail; line no otherwise.
// Param: level An integer that contains the 0-based index into the call stack. This parameter specifies which call stack to navigate to. (Default value is 0.)
// END_HELP_COMMENT
int COStack::NavigateStack(int level /* 0 */) {
#if defined(V4LOW)
	EXPECT(uivar = UIDebug::ShowDockWindow(IDW_LOCALS_WIN));
	uivar.NavigateStack(level);
	return TRUE;	// Assume success!
#else
	EXPECT(uistack = UIDebug::ShowDockWindow(IDW_CALLS_WIN));
	return uistack.NavigateStack(level);
	// REVIEW (michma): we don't want the stack to be closed so it is visible during the sniff (more
	// coverage). however, what we probably should do later is close it	only if it wasn't open previously.
	// the memory and ee component classes already support such behavior.
	//uistack.Close();
#endif
}


// BEGIN_HELP_COMMENT
// Function: BOOL COStack::RunToFrame(int level, int ambiguity /* 0 */)
// Description: Run to the given call stack frame.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: level An integer that contains the 0-based index into the call stack. This parameter specifies which call stack to run to.
// Param: ambiguity An integer that contains the 1-based index of the list of entries to resolve an ambiguity. (Default value is -1.)
// END_HELP_COMMENT
BOOL COStack::RunToFrame(int level, int ambiguity /* 0 */) 

{
	EXPECT(uistack = UIDebug::ShowDockWindow(IDW_CALLS_WIN));
	uistack.GoToFrame(level);
//REVIEW(chriskoz) this is the F7 command from uistack context, cannot be executed from UIWB context (dbg.StepToCursor)
	MST.DoKeyshWnd(uistack, "{F7}" /*KEY_STEPTOCURSOR*/);

	CODebug dbg;
	if(ambiguity > 0)
		dbg.ResolveSourceLineAmbiguity(ambiguity);
	dbg.Wait(WAIT_FOR_BREAK);
	
	// return focus from stack window.
	MST.DoKeys("{ESC}");
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL COStack::FunctionIs(LPCSTR str, int level /* 0 */)
// Description: Determine if the name of the function at the specified call stack level matches the given function name.
// Return: A Boolean value that indicates whether the function name at the specified call stack level matches the given function name.
// Param: str A pointer to a string that specifies the expected name of the function.
// Param: level An integer that contains the 0-based index into the call stack. (Default value is 0.)
// END_HELP_COMMENT
BOOL COStack::FunctionIs(LPCSTR str, int level /* 0 */) {
	
	
	CString temp = GetFunction(level);

	if (  ((CString)temp).Find((CString)str) != (-1)  )
		return TRUE;
	else
	{
		// log warning
		LOG->RecordInfo( (LPCSTR) "Current Function is %s, expected %s",temp.GetBuffer(temp.GetLength()), str);
		return FALSE;
	}
}

// BEGIN_HELP_COMMENT
// Function: BOOL COStack::Compare( char const * const * stk, FrameList::Filter filter, int top, int bottom )
// Description: Compare a portion of the call stack to a given portion of the call stack.
// Return: A Boolean value that indicates whether the specified portion of the call stack matches the given call stack (TRUE) or not.
// Param: stk A pointer to a portion of the call stack. This is commonly a pointer to part of the buffer retrieved by GetAllFunctions(void).
// Param: filter A value that specifies the type of filtering to do when comparing call stacks: FrameList::NoFilter, FrameList::NoAbsoluteAddresses. (Default value is FrameList::NoFilter.)
// Param: top An integer that specifies the 0-based index into the call stack to start comparison. (Default value is 0.)
// Param: bottom An integer that specifies the 0-based index into the call stack to end comparison. -1 means the bottom of the stack. (Default value is -1.)
// END_HELP_COMMENT
BOOL COStack::Compare( char const * const * stk, FrameList::Filter filter, int top, int bottom ) {
	CString strStack = GetAllFunctions();
	FrameList list;
	list.CreateFromText( strStack );
	return list.Compare( stk, filter, top, bottom );
}

//
// class FrameList
//
FrameList::FrameList() {
}

FrameList::FrameList(char const* const* ppchar)   {
	while( *ppchar ) {
		m_StringArray.Add( *ppchar );
		ppchar++;
	}
}

BOOL FrameList::CreateFromText( CString str ) {
	const CString CrLf( "\r\n" );
	const int cCrLf = CrLf.GetLength();

	// Clear string array
	m_StringArray.RemoveAll();

	while( str.GetLength() ) {
		CString frame;

		int count = str.Find( CrLf );

		if( -1 != count ) {
			frame = str.Left( count );
			str = str.Mid( count + cCrLf );
		}
		else {
			frame = str;
			str = "";
		}
		m_StringArray.Add( frame );
	}

	return TRUE;
}

int FrameList::Index( CString frame0 ) const {
	int index = 0;

	for( index = 0; index < m_StringArray.GetSize(); index++) {
		Frame frame1( m_StringArray[index] );

		if( frame1.Test( frame0 ) )
			return index;
	}
	LOG->RecordInfo( "FrameList::Index - '%s' not found", (LPCTSTR)frame0 );
	return -1;
}

BOOL FrameList::Compare( char const * const * stk, Filter filter, int top, int bottom ) const {
	BOOL bResult = TRUE;

	// Do general integrity check for warnings.  Ignore return code
	GeneralIntegrity();

	//
	//	Do a frame by frame compare
	//
	if( bottom == -1 ) {
		bottom = m_StringArray.GetUpperBound();
	}

	// Check limits.
	bResult = top >= 0 && bottom >= top && bottom <= m_StringArray.GetUpperBound();
	if( !bResult ) {
		// Write warnings.
		LOG->RecordInfo( "FrameList::Compare - Invalid param: top=%d, bottom=%d, UpperBound=%d",
			top, bottom, m_StringArray.GetUpperBound() );

	}

	// Setting bSkip to TRUE when '*' is encountered in stk allows skipping
	// frames until next match is found.  Useful for skipping system dependent frames
	// when using system callbacks
	BOOL bSkip = FALSE;
	for( int index = top; bResult && index <= bottom; index++ ) {
		Frame frame( m_StringArray[index] );

		// Special "*" in stk.
		if( CString( *stk ) == CString( "*" ) ) {
			stk++;
			ASSERT( *stk );
			ASSERT( **stk );
			ASSERT( CString( *stk ) != CString( "*" ) );
			bSkip = TRUE;
		}

		// Apply filter.
		if( filter == NoAbsoluteAddresses ) {
			CString tmp;
			if( frame.GetAbsoluteAddress( tmp ) )
				continue;
		}

		if( *stk ) {
			bResult = frame.Test( *stk );

			if( bResult ) {
				bSkip = FALSE;
				stk++;
			}
			else if ( !bSkip ) {
				LOG->RecordInfo( "FrameList::Compare - Mismatch on Frame[%d] - Expected '%s', Got '%s'",
					index, *stk, (LPCTSTR)frame );
				stk++;
			}
			else {
				// Continue loop
				bResult = TRUE;
			}

		}
		else {
			bResult = FALSE;
			LOG->RecordInfo( "FrameList::Compare - %d is not enough baseline frames",
				index-top );
		}
	}

	// Make sure that we used the entire baseline.
	if( *stk ) {
		bResult = FALSE;
		LOG->RecordInfo( "FrameList::Compare - Never checked %s in baseline", *stk );
	}

	// Consistency check.  This should only happen if *stk != NULL
	if( bSkip ) {
		bResult = FALSE;
		LOG->RecordInfo( "FrameList::Compare - Never reset 'bSkip'" );
	}
	return bResult;
}

BOOL FrameList::GeneralIntegrity() const {
	BOOL bResult = TRUE;

	// Checks
	// 	consecutive duplicate frames
	//	blank frame
	//	
	CString lastFrame;
	for( int index = 0; bResult && index <= m_StringArray.GetUpperBound(); index++ ) {
		Frame frame( m_StringArray[index] );

		if( lastFrame == m_StringArray[index] ) {
			LOG->RecordInfo( "FrameList::GeneralIntegrity - '%s' duplicated", (LPCTSTR)lastFrame );
			bResult = FALSE;
		}

		CString tmp;
		// Absolute address should always be include with image name.
		if( frame.GetImageName( tmp ) ) {
			if( !frame.GetAbsoluteAddress( tmp ) ) {
				LOG->RecordInfo( "FrameList::GeneralIntegrity - '%s' image name without absolute address", 
					(LPCTSTR)m_StringArray[index] );
				bResult = FALSE;
			}
		}

		// Frame without absolute address should contain function name
		if( !frame.GetAbsoluteAddress( tmp ) ) {
			if( !frame.GetFunctionName( tmp ) ) {
				LOG->RecordInfo( "FrameList::GeneralIntegrity - '%s' No function or absolute address", 
					(LPCTSTR)m_StringArray[index] );
				bResult = FALSE;
			}
		}

		lastFrame = m_StringArray[index];
	}

	return bResult;
}

//
// class Frame
//
BOOL Frame::GetAbsoluteAddress( CString& str ) const {
	//
	// Assume that absolute address has the form XXXXXXXX().
	//
	CString frame = m_strFrame;

	BOOL found = FALSE;
	str.Empty();
	int index = frame.Find( "(" );

	found = -1 != index;
	if( found ) {
		frame = frame.Left( index );
		frame.MakeReverse();
		frame = frame.SpanExcluding( " " );
		frame.MakeReverse();

		// Must have exactly 8.  I don't want to mismatch on short names like abc();
		if( frame.GetLength() != 8 ) {
			found = FALSE;
		}
		else {
			// Allow only lower case hexadecimal.
			str = frame.SpanIncluding( "0123456789abcdef" );
			if( str != frame ) {
				str.Empty();
				found = FALSE;
			}
		}
	}

	return found;
}

BOOL Frame::GetFunctionName( CString& str ) const {
	//
	// Assume that function name and absolute address or image name are mutally exclusive.
	// Assume that the function name if it exists starts at beginning of string
	//
	CString frame = m_strFrame;
	CString tmp;

	BOOL found = FALSE;
	str.Empty();
	if( !GetAbsoluteAddress( tmp ) ) {
		if( GetImageName( tmp ) )
		{
			frame = frame.Mid( tmp.GetLength() + 1); //skip image name + '!'
			frame.TrimLeft(); //get rid of leading spaces
		}
		int index = frame.Find( "(" );

		if( -1 == index )
			index = frame.Find( " " );

		if( -1 != index )
			frame = frame.Left( index );

		if( !frame.IsEmpty() ) {

			// Make sure first character of function is not a digit
			TCHAR ch = frame[0];

			if( IsCharAlphaNumeric( ch ) && !IsCharAlpha( ch ) ) {
				found = FALSE;
			}
			else {
				str = frame;
				found = TRUE;
			}
		}
	}
	return found;
}

BOOL Frame::GetImageName( CString& str ) const {
	//
	// Assume that image name if it exists is at the beginning of the line, is appended with '!'
	// and has no spaces.
	//
	CString frame = m_strFrame;

	BOOL found = FALSE;
	str.Empty();
	int index = frame.Find( "!" );
	found = -1 != index;
	if( found ) {
		frame = frame.Left( index );
		if( frame.IsEmpty() || frame.Find( ' ' ) != -1 ) {
			found = FALSE;
		}
		else {
			str = frame;
		}
	}

	return found;
}

BOOL Frame::GetLineNumber( CString& str ) const {
	CString frame = m_strFrame;

	BOOL found = FALSE;
	str.Empty();
	const CString prefix( "line " );
	int index = frame.Find( prefix );
	if( -1 != index ) {
		frame = frame.Mid( index + prefix.GetLength() ).SpanIncluding( "1234567890" );
		if( !frame.IsEmpty() ) {
			str = frame;
			found = TRUE;
		}
	}
	return found;
}

BOOL Frame::GetByteOffset( CString& str ) const {
	CString frame = m_strFrame;

	BOOL found = FALSE;
	str.Empty();
	const CString postfix( " byte" );
	int index = frame.Find( postfix );
	if( -1 != index ) {
		frame = frame.Left( index );
		frame.MakeReverse();
		frame = frame.SpanIncluding( "1234567890" );
		frame.MakeReverse();
		if( !frame.IsEmpty() ) {
			str = frame;
			found = TRUE;
		}
	}
	return found;
}

BOOL Frame::GetParameters( CString& str ) const {
	BOOL found = FALSE;
	str.Empty();
	int first = m_strFrame.Find( '(' );
	int last = m_strFrame.ReverseFind( ')' );
	if( first != -1 && last > first ) {
		found = TRUE;
		// Include stuff between but excluding parens
		str = m_strFrame.Mid( first+1, last - first - 1 );
	}
	return found;
}

BOOL Frame::GetParameterType( CString& str, int index ) const
{
	BOOL found = FALSE;
	int space_pos = GetParam(str, index);
	if( -1 != space_pos )
	{
		str = str.Left( space_pos );
		found = TRUE;
	} //else NOTE: space_pos can be -1 & str not empty if not Type & Value are present
	return found;
}

BOOL Frame::GetParameterValue( CString& str, int index ) const 
{
	BOOL found = FALSE;
	int space_pos = GetParam(str, index);
	if( -1 != space_pos )
	{
		str = str.Mid( space_pos+1 );
		found = TRUE;
	} //else NOTE: space_pos can be -1 & str not empty if not Type & Value are present
	return found;
}


//Finds the space before the ADDRESS
//RETURN: -1 if not found or ADDRESS is the leftmost substring of params
int FindAddress(const CString& param)
{
	int start,ndigit;
	if((start=param.Find(" 0x")) >=0) //ADDRESS must be prefixed by space
	{
		for(ndigit=0;ndigit<8;ndigit++)
		{
			if (!isxdigit(param[start+3+ndigit]))
			{
				start = -1; //this is not the address
				break;
			}
		}
	} //else NOTE: returns -1 when ADDRESS is the leftmost substr, which is expected
	return start;
}  //FindAddress


// Gets the given parameter and returns the position of the space 
// separating its type & its value in m_strFrame.
// Function assumes both type and value are present in m_strFrame
// Param: index - the 0-indexed parameter number
//RETURN: str - retrieved parameter string
//RETURN: the position of the space separating type & value (-1 if not found)
int Frame::GetParam( CString& str, int index ) const 
{
	int space_pos=-1;
	str.Empty();
	CString params;
	if( GetParameters( params ) ) 
	{

		// Only handle very simple types without spaces.

		// Get start of nth parameter.
		int count = index;
		int start = 0;
		while( count ) {
			start = params.Find( ',' );
			if( -1 == start ) {
				break;
			}
			else {
				params = params.Mid( start + 1 );
				count--;
			}
		}

		if( -1 != start ) 
		{
			int last = params.Find( ',' );
			if( -1 != last ) {
				params = params.Left( last );
			}
			
			// Get rid of tabs & remove leading & trailing white chars
			params.Replace('\t',' ');
			params.TrimLeft();
			params.TrimRight();

			if( (space_pos=FindAddress(params)) <0)
				space_pos = params.ReverseFind( ' ' );
			str = params;
		}
	}
	return space_pos;
} //GetParam



BOOL Frame::Test( CString str ) const {
	//
	// Only test elements that exist in str
	//
	BOOL result = TRUE;
	Frame testFrame( str );
	CString str0, str1;

	if( result && testFrame.GetAbsoluteAddress( str0 ) ) {
		result = GetAbsoluteAddress( str1 ) && str0 == str1;
	}

	if( result && testFrame.GetImageName( str0 ) ) {
		result = GetImageName( str1 ) && str0 == str1;
	}

	if( result && testFrame.GetFunctionName( str0 ) ) {
		result = GetFunctionName( str1 ) && str0 == str1;
	}

	if( result && testFrame.GetLineNumber( str0 ) ) {
		result = GetLineNumber( str1 ) && str0 == str1;
	}

	if( result && testFrame.GetByteOffset( str0 ) ) {
		result = GetByteOffset( str1 ) && str0 == str1;
	}

	if( result && testFrame.GetParameters( str0 ) ) {

		// Parameters must agree in number and type.  Value check is optional.
		result = GetParameters( str1 );
		int i = 0;
		while( result && testFrame.GetParameterType( str0, i ) ) {
			result = GetParameterType( str1, i ) && str0 == str1;

			// Optional value check
			if( result && testFrame.GetParameterValue( str0, i ) ) {
				result = GetParameterValue( str1, i );
				// Compare on if not special case for '%' which doesn't check actual value
				if( result && str0[0] != '%' ) {
					result = str0 == str1;
				}
			}
			i++;
		}

		// Make sure that Frame doesn't have more parameters than testFrame.
		result = result && !GetParameterType( str1, i );
	}

#if 0
	// This might be printed in a special mode.
	if( !result ) {
		LOG->RecordInfo( "Frame::Test - Expected '%s', Got '%s'", (LPCTSTR)str0, (LPCTSTR)str1 );
	}
#endif

	return result;
}

BOOL COStack::IsDirty() const {

	// Always dirty if no CODebug owner
	BOOL dirty = TRUE;

	if( m_pOwner ) {
		dirty = m_bDirty;
	}
	return dirty;
}


// BEGIN_HELP_COMMENT
// Function: BOOL COStack::ToggleBreakpoint(int level /* 0 */)
// Description: Run to the given call stack frame.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: level An integer that contains the 0-based index into the call stack. This parameter specifies which frame to toggle the breakpoint on.
// END_HELP_COMMENT
BOOL COStack::ToggleBreakpoint(int level /* 0 */) 
{
	EXPECT(uistack = UIDebug::ShowDockWindow(IDW_CALLS_WIN));
	uistack.GoToFrame(level);
	MST.DoKeyshWnd(uistack, KEY_TOGGLE_BREAKPOINT);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\cothread.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  COTHREAD.CPP
//
//  Created by :            Date :
//      WayneBr                 1/14/94
//
//  Description :
//      Implementation of the COThreads class
//

#include "stdafx.h"
#include "cothread.h"
#include "testxcpt.h"
#include "guiv1.h"
#include "..\shl\uwbframe.h"
#include "..\shl\uioutput.h"
#include "mstwrap.h"
#include "..\..\testutil.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: BOOL COThreads::FreezeThread(int thread)
// Description: Suspend the specified thread.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: thread An unsigned long that contains the thread ID of the thread to suspend.
// END_HELP_COMMENT
BOOL COThreads::FreezeThread(DWORD thread)
	{
	EXPECT(uithread.Activate());
	EXPECT(uithread.FreezeThread(thread));
	EXPECT(uithread.OK());
	// verify really done, log warning return FALSE if not
	return TRUE;
	};

// BEGIN_HELP_COMMENT
// Function: BOOL COThreads::ThawThread(int thread)			
// Description: Resume the specified thread.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: thread An unsigned long that contains the thread ID of the thread to resume.
// END_HELP_COMMENT
BOOL COThreads::ThawThread(DWORD thread)			
	{
	EXPECT(uithread.Activate());
	EXPECT(uithread.ThawThread(thread));
	EXPECT(uithread.OK());
	// verify really done, log warning return FALSE if not
	return TRUE;
	};


// BEGIN_HELP_COMMENT
// Function: BOOL COThreads::SetCurrentThread(int thread)
// Description: Set the specified thread to be the current thread.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: thread An unsigned long that contains the thread ID of the thread to activate.
// END_HELP_COMMENT
BOOL COThreads::SetCurrentThread(DWORD thread)

{
	const char* const THIS_FUNCTION = "COThreads::SetCurrentThread()";

	if(!uithread.Activate())
	{
		LOG->RecordInfo("ERROR in %s: could not open Threads dialog.", THIS_FUNCTION);
		return FALSE;
	}
	
	if(!uithread.SetCurrentThread(thread))
	{
		LOG->RecordInfo("ERROR in %s: could not give focus to thread %d.", THIS_FUNCTION, thread);
		uithread.Cancel();
		return FALSE;
	}

	if(uithread.OK())
	{
		LOG->RecordInfo("ERROR in %s: could not OK Threads dialog.", THIS_FUNCTION);
		return FALSE;
	}

	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: INT COThreads::GetCurrentThread(void)
// Description: Get the thread ID of the currently active thread.
// Return: An unsigned long that specifies the currently active thread.
// END_HELP_COMMENT
DWORD  COThreads::GetCurrentThread(void)
	{
	EXPECT(uithread.Activate());
	DWORD temp = uithread.GetCurrentThread();
	EXPECT(uithread.OK());
	return temp;
	};

// BEGIN_HELP_COMMENT
// Function: BOOL COThreads::CurrentThreadIs(int thread)
// Description: Determine if the current thread ID matches the given thread ID.
// Return: A Boolean value that indicates whether the current thread ID matches the given thread ID.
// Param: thread An unsigned long that contains the thread ID of the thread.
// END_HELP_COMMENT
BOOL COThreads::CurrentThreadIs(DWORD thread)
	{
	EXPECT(uithread.Activate());
	DWORD temp = uithread.GetCurrentThread();
	if (temp!=thread)
	{
		// log warning
		LOG->RecordInfo( (LPCSTR) "The Current Thread is %ul, expected %ul", temp, thread);
	}
	EXPECT(uithread.OK());
	return thread==temp;
	};


// BEGIN_HELP_COMMENT
// Function: BOOL COThreads::VerifyThreadInfo(int intThread, CThreadInfo& ThreadInfo)
// Description: Determines if the debugger knows the correct information about a thread.
// Return: A boolean value that indicates success or failure. TRUE if successful, FALSE if not.
// Param: ThreadInfo - A CThreadInfo reference that contains the expected information about the thread.
// END_HELP_COMMENT
BOOL COThreads::VerifyThreadInfo(CThreadInfo& ThreadInfo)

{
	char szThisFunc[] = "COThreads::VerifyThreadInfo";

	// activate the threads dlg.
	if(!uithread.Activate())
	{
		LOG->RecordInfo("ERROR in %s: couldn't activate threads dlg.", szThisFunc);
		return FALSE;
	}

	CThreadInfo ThreadInfoActual;
	// set the ID field so UIThreads::GetThreadInfo() knows which thread to get info for.
	ThreadInfoActual.strID = ThreadInfo.strID;

	// get the info for the thread from the threads dlg.
	if(!uithread.GetThreadInfo(ThreadInfoActual))
	{
		LOG->RecordInfo("ERROR in %s: couldn't get info for thread ID '%s'.", szThisFunc, ThreadInfo.strID);
		uithread.Cancel();
		return FALSE;
	}

	// verify each piece of thread info.
	if(ThreadInfoActual.bHasFocus != ThreadInfo.bHasFocus)
	{
		LOG->RecordInfo("ERROR in %s: expected focus for thread ID '%s' didn't match actual focus.",
						szThisFunc, ThreadInfo.strID);
		uithread.Cancel();
		return FALSE;
	}

	if(ThreadInfoActual.intSuspend != ThreadInfo.intSuspend)
	{
		LOG->RecordInfo("ERROR in %s: expected suspend count for thread ID '%s' was %d. Actual suspend count was %d.",
						szThisFunc, ThreadInfo.strID, ThreadInfo.intSuspend, ThreadInfoActual.intSuspend);
		uithread.Cancel();
		return FALSE;
	}

	if(ThreadInfoActual.intPriority != ThreadInfo.intPriority)
	{
		LOG->RecordInfo("ERROR in %s: expected priority for thread ID '%s' was %d. Actual priority was %d.",
						szThisFunc, ThreadInfo.strID, ThreadInfo.intPriority, ThreadInfoActual.intPriority);
		uithread.Cancel();
		return FALSE;
	}

	if(ThreadInfoActual.strLocation != ThreadInfo.strLocation)
	{
		LOG->RecordInfo("ERROR in %s: expected location for thread ID '%s' was '%s'. Actual location was '%s'.", 
						szThisFunc, ThreadInfo.strID, ThreadInfo.strLocation, ThreadInfoActual.strLocation);
		uithread.Cancel();
		return FALSE;
	}

	// close the threads dlg without risking any changes (cancel it).
	if(uithread.Cancel() != NULL)
	{
		LOG->RecordInfo("ERROR in %s: couldn't close threads dlg.", szThisFunc);
		return FALSE;
	}

	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL COThreads::SetThreadFocus(LPCSTR szThreadID)
// Description: Sets debugger focus to a specified thread.
// Return: A boolean value that indicates success or failure. TRUE if successful, FALSE if not.
// Param: szThreadID - A string specifying the ID of the thread to set focus to.
// END_HELP_COMMENT
BOOL COThreads::SetThreadFocus(LPCSTR szThreadID)

{
	char szThisFunc[] = "COThreads::SetThreadFocus";

	// activate the threads dlg.
	if(!uithread.Activate())
	{
		LOG->RecordInfo("ERROR in %s: couldn't activate threads dlg.", szThisFunc);
		return FALSE;
	}

	// set the thread focus.
	if(!uithread.SetThreadFocus(szThreadID))
	{
		LOG->RecordInfo("ERROR in %s: couldn't set focus on thread with ID '%s'.", szThisFunc, szThreadID);
		uithread.Cancel();
		return FALSE;
	}

	// ok the the threads dlg.
	if(uithread.OK() != NULL)
	{
		LOG->RecordInfo("ERROR in %s: couldn't OK threads dlg.", szThisFunc);
		return FALSE;
	}

	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL COThreads::VerifyThreadExitCode(LPCSTR szThreadID, int intExitCode)
// Description: Verifies that the exit code of the specified thread is as expected.
// Return: A boolean value that indicates success or failure. TRUE if successful, FALSE if not.
// Param: szThreadID - A string specifying the thread ID of the thread in question.
// Param: intExitCode - An integer specifying the expected exit code.
// END_HELP_COMMENT
BOOL COThreads::VerifyThreadExitCode(LPCSTR szThreadID, int intExitCode)

{
	char szThisFunc[] = "COThreads::VerifyThreadExitCode";
	
	if((CString)szThreadID == "")
	{
		LOG->RecordInfo("ERROR in %s: expected thread ID is blank.", szThisFunc);
		return FALSE;
	}

	UIOutput uioutput;

	// TODO(michma - 2/8/98): UIOutput::Activate() works but does not return TRUE.
	// activate the output window.
	/*
	if(!uioutput.Activate())
	{
		LOG->RecordInfo("ERROR in %s: couldn't activate output window.", szThisFunc);
		return FALSE;
	}
	*/
	uioutput.Activate();

	// select all the contents of the output window.
	UIWB.DoCommand(ID_EDIT_SELECT_ALL, DC_MNEMONIC);
	// copy it to the clipboard and load it into a string.
	MST.DoKeys("^(c)");
	CString strClip;
	GetClipText(strClip);
	// convert the exit code to the proper string formats.
	char szExitCode[12];
	sprintf(szExitCode, "%d", intExitCode);
	// convert the string id to the proper string format (uppercase and with leading 0's truncated).
	CString strThreadID = szThreadID;
	strThreadID.MakeUpper();
	int iNonZero = strThreadID.FindOneOf("123456789ABCDEF");
	strThreadID = strThreadID.Mid(iNonZero);
	// create the string that we are searching for in the output window.
	CString strThreadExitCode = strThreadID + " " + GetLocString(IDSS_THREAD_EXIT_CODE) + " " + szExitCode;
	
	// verify that the output window contains the correct thread exit code string.
	if(strClip.Find(strThreadExitCode) == -1)
	{
		LOG->RecordInfo("ERROR in %s: could not find '%s' in '%s'.", szThisFunc, strThreadExitCode, strClip);
		return FALSE;
	}

	return TRUE; 
}


// BEGIN_HELP_COMMENT
// Function: BOOL COThreads::SuspendThread(LPCSTR szThreadID)
// Description: Suspends a thread.
// Return: A boolean value that indicates success or failure. TRUE if successful, FALSE if not.
// Param: szThreadID - A string specifying the ID of the thread to suspend.
// END_HELP_COMMENT
BOOL COThreads::SuspendThread(LPCSTR szThreadID)

{
	char szThisFunc[] = "COThreads::SuspendThread";

	// activate the threads dlg.
	if(!uithread.Activate())
	{
		LOG->RecordInfo("ERROR in %s: couldn't activate threads dlg.", szThisFunc);
		return FALSE;
	}

	// suspend the thread.
	if(!uithread.SuspendThread(szThreadID))
	{
		LOG->RecordInfo("ERROR in %s: couldn't suspend thread with ID '%s'.", szThisFunc, szThreadID);
		uithread.Cancel();
		return FALSE;
	}

	// ok the the threads dlg.
	if(uithread.OK() != NULL)
	{
		LOG->RecordInfo("ERROR in %s: couldn't OK threads dlg.", szThisFunc);
		return FALSE;
	}

	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL COThreads::ResumeThread(LPCSTR szThreadID)
// Description: Resumes a thread.
// Return: A boolean value that indicates success or failure. TRUE if successful, FALSE if not.
// Param: szThreadID - A string specifying the ID of the thread to resume.
// END_HELP_COMMENT
BOOL COThreads::ResumeThread(LPCSTR szThreadID)

{
	char szThisFunc[] = "COThreads::ResumeThread";

	// activate the threads dlg.
	if(!uithread.Activate())
	{
		LOG->RecordInfo("ERROR in %s: couldn't activate threads dlg.", szThisFunc);
		return FALSE;
	}

	// resume the thread.
	if(!uithread.ResumeThread(szThreadID))
	{
		LOG->RecordInfo("ERROR in %s: couldn't resume thread with ID '%s'.", szThisFunc, szThreadID);
		uithread.Cancel();
		return FALSE;
	}

	// ok the the threads dlg.
	if(uithread.OK() != NULL)
	{
		LOG->RecordInfo("ERROR in %s: couldn't OK threads dlg.", szThisFunc);
		return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\costack.h ===
///////////////////////////////////////////////////////////////////////////////
//  COStack.H
//
//  Created by :            Date :
//      WayneBr             1/14/94
//
//  Description :
//      Declaration of the COStack class
//

#ifndef __COSTACK_H__
#define __COSTACK_H__

#include "uistack.h"
#include "uivar.h"

#include "dbgxprt.h"

///////////////////////////////////////////////////////////////////////////////
//  COStack class

//
// class Frame - utility class for operating on frame from callstack window
//
// BEGIN_CLASS_HELP
// ClassName: Frame
// BaseClass: none
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS Frame {
public:
	Frame(){}
	Frame( LPCTSTR frame ) { m_strFrame = frame; };
	operator LPCTSTR () const { return LPCTSTR( m_strFrame ); };

	//	Functions for extracting parts of Frame strings.
	BOOL GetAbsoluteAddress( CString& str ) const;
	BOOL GetFunctionName( CString& str ) const;
	BOOL GetImageName( CString& str ) const;
	BOOL GetLineNumber( CString& str ) const;
	BOOL GetByteOffset( CString& str ) const;
	BOOL GetParameters( CString& str ) const;
	BOOL GetParameterType( CString& str, int index = 0 ) const;
	BOOL GetParameterValue( CString& str, int index = 0 ) const;

	BOOL Test( CString str ) const;

private:
	CString m_strFrame;
	int GetParam( CString& str, int index) const;
};


//
// class FrameList
//
// BEGIN_CLASS_HELP
// ClassName: FrameList
// BaseClass: none
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS FrameList {
public:
	// CreateFromText from clipboard.
	BOOL CreateFromText( CString str );
	FrameList();
	FrameList(char const* const* ppchar);

	// General utilities
	int Index( CString str ) const;
	CString operator[] ( int index ) const { return m_StringArray[index]; }
	int GetSize() const { return m_StringArray.GetSize(); }

	enum Filter {
		NoFilter = 0,
		NoAbsoluteAddresses,
	};

	// Testing operations
	BOOL Compare( char const * const * stk, Filter filter, int top, int bottom ) const;

	// General common sense checks on callstack
	BOOL GeneralIntegrity() const;

private:
	CStringArray m_StringArray;
};


//
//	class COStack.
//
class CODebug; // Forward declaration

// BEGIN_CLASS_HELP
// ClassName: COStack
// BaseClass: none
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS COStack {
	friend CODebug;

// Data
private:
    UIStack uistack;
	UIVariables uivar;
	CODebug* m_pOwner;
	BOOL m_bDirty;
	CString m_LastStack;

// Call Stack Utilities
public:
	COStack( CODebug* owner = NULL );
    BOOL CurrentFunctionIs(LPCSTR str);
    BOOL VerifyCurrentFunction(LPCSTR str);  // logs warning if not =
    CString GetFunction(int level = 0, BOOL bNameOnly = FALSE);
    CString GetAllFunctions(void);
    int  NavigateStack(int level = 0);
    int  NavigateStack( CString str );
	BOOL RunToFrame(CString str,  int ambiguity = 0);
	BOOL RunToFrame(int level, int ambiguity = 0); 
	BOOL FunctionIs(LPCSTR str, int level = 0 );
	BOOL ToggleBreakpoint(int level = 0);

    int Index( CString str );
	BOOL Compare( char const * const * stk, FrameList::Filter filter = FrameList::NoFilter, int top = 0, int bottom = -1 );

	void SetDirty( BOOL dirty ) { m_bDirty = dirty; }
	BOOL IsDirty() const;

protected:
};


#endif // __COSTACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		BrianCr				09/06/94
//
//	Description :
//		source file that includes just the standard includes
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		BrianCr				09/06/94
//
//	Description :
//		Precompiled header for all of the core MFC files
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\cowatch.h ===
///////////////////////////////////////////////////////////////////////////////
//  COWATCH.H
//
//  Created by:            Date:
//      MichMa                  6/11/98
//
//  Description:
//      Declaration of the COWatch class
//

#ifndef __COWATCH_H__
#define __COWATCH_H__

#include "dbgxprt.h"
#include "uiwatch.h"
#include "coee.h"

#pragma warning (disable : 4069)


///////////////////////////////////////////////////////////////////////////////
//  CWatch class

// BEGIN_CLASS_HELP
// ClassName: CWatch
// BaseClass: none
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS CWatch

{
public:

	CString m_strType;
	CString m_strName;
	CString m_strValue;
	EXPR_STATE m_ExprState;
	CWatch(void){}

	const CWatch& operator=(const CWatch &WatchSrc)
	{
		m_strType = WatchSrc.m_strType;
		m_strName = WatchSrc.m_strName;
		m_strValue = WatchSrc.m_strValue;
		m_ExprState = WatchSrc.m_ExprState;
		return *this;	
	}

	CWatch(CWatch &WatchSrc)
	{
		m_strType = WatchSrc.m_strType;
		m_strName = WatchSrc.m_strName;
		m_strValue = WatchSrc.m_strValue;
		m_ExprState = WatchSrc.m_ExprState;
	}
};


///////////////////////////////////////////////////////////////////////////////
//  COWatch class

// BEGIN_CLASS_HELP
// ClassName: COWatch
// BaseClass: none
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS COWatch

{
	// Data
	private:
		UIWatch uiwatch;
		COExpEval coee;

	// Utilities
	public:
		BOOL AddWatch(LPCSTR szWatch);
		BOOL RemoveWatch(LPCSTR szWatch);
		BOOL ExpandWatch(LPCSTR szWatch);
		BOOL CollapseWatch(LPCSTR szWatch);
		BOOL VerifyWatchInfo(CWatch Watch);
		BOOL VerifyWatchInfo(LPCSTR szName, LPCSTR szValue,  LPCSTR szType, EXPR_STATE ExprState);
		BOOL WatchDoesNotExist(LPCSTR szWatch);
		BOOL WatchCountIs(int intWatchCount);
		BOOL SetWatchValue(LPCSTR szWatch, LPCSTR szValue);
};

#endif // __COWATCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\cothread.h ===
///////////////////////////////////////////////////////////////////////////////
//  COTHREAD.H
//
//  Created by :            Date :
//      WayneBr             1/14/94
//
//  Description :
//      Declaration of the COThreads class
//

#ifndef __COTHREAD_H__
#define __COTHREAD_H__

#include "uithread.h"

#include "dbgxprt.h"

///////////////////////////////////////////////////////////////////////////////
//  COThreads class

// BEGIN_CLASS_HELP
// ClassName: COThreads
// BaseClass: none
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS COThreads

	{
	// Data
	private:
		UIThreads uithread;

	// Utilities
	public:
		BOOL FreezeThread(DWORD thread);
		BOOL ThawThread(DWORD thread);			
		BOOL SetCurrentThread(DWORD thread);
		DWORD  GetCurrentThread(void);
		BOOL CurrentThreadIs(DWORD thread);
		BOOL VerifyThreadInfo(CThreadInfo& ThreadInfo);
		BOOL SetThreadFocus(LPCSTR szThreadID);
		BOOL VerifyThreadExitCode(LPCSTR szThreadID, int intExitCode);
		BOOL SuspendThread(LPCSTR szThreadID);
		BOOL ResumeThread(LPCSTR szThreadID);
	};

#endif // __COTHREAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\dbgxprt.h ===
///////////////////////////////////////////////////////////////////////////////
//	dbgxprt.h (debugger export)
//
//	Created by :			Date :
//		BrianCr				01/03/95
//
//	Description :
//		Debugger DLL defines
//

#ifndef __DBGXPRT_H__
#define __DBGXPRT_H__

#ifdef EXPORT_DEBUGGER
	#define DBG_CLASS AFX_EXT_CLASS
	#define DBG_API   AFX_EXT_API
	#define DBG_DATA  AFX_EXT_DATA
#else
	#define DBG_CLASS __declspec(dllimport)
	#define DBG_API   __declspec(dllimport)
	#define DBG_DATA  __declspec(dllimport)

	#ifdef _DEBUG 
		#pragma comment(lib, "dbgd.lib")
	#else
		#pragma comment(lib, "dbg.lib")
	#endif
#endif

#endif // __GUIXPRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\cowatch.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  COWATCH.CPP
//
//  Created by:            Date:
//      MichMa                  6/11/98
//
//  Description:
//      Implementation of the COWatch class
//

#include "stdafx.h"
#include "cowatch.h"
#include "guiv1.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

#pragma warning (disable : 4069)


// BEGIN_HELP_COMMENT
// Function: BOOL COWatch::VerifyWatchInfo(CWatch Watch)
// Description: Verify that a watch of the specified name, value, type, and state exists in the debugger.
// Return: A Boolean value that specifies whether the verification was sucessful (TRUE) or not (FALSE).
// Param: Watch A CWatch object containing the name, value, type, and state of the watch to verify.
// END_HELP_COMMENT
BOOL COWatch::VerifyWatchInfo(CWatch Watch)

{
	const char* const THIS_FUNCTION = "COWatch::VerifyWatchInfo()";

	// activate the watch window.
	// TODO(michma): UIWatch::Activate isn't returning TRUE even though the window gets activated.
	/*if(!uiwatch.Activate())
	{
		LOG->RecordInfo("ERROR in %s: can't activate watch window.", THIS_FUNCTION);
		return FALSE;
	}
	*/
	uiwatch.Activate();

	// select the watch.
	if(!uiwatch.SelectWatch(Watch.m_strName))
	{
		LOG->RecordInfo("ERROR in %s: can't select watch \"%s\".", THIS_FUNCTION, Watch.m_strName);
		return FALSE;
	}
	
	// stores the watch's actual and expected information.
	EXPR_INFO ActualWatchInfo, ExpectedWatchInfo;
	coee.FillExprInfo(ExpectedWatchInfo, Watch.m_ExprState, Watch.m_strType, Watch.m_strName, Watch.m_strValue);

	// get the fields of the watch from the watch window.
	if(uiwatch.GetAllFields(&ActualWatchInfo, ROW_CURRENT) != ERROR_SUCCESS)
	{
		LOG->RecordInfo("ERROR in %s: couldn't get fields of watch \"%s\".", THIS_FUNCTION, Watch.m_strName);
		return FALSE;
	}

	// return focus back to source (if it's there).
	MST.DoKeys("{ESC}");
	// compare the actual watch info with the expected watch info.
	return coee.CompareExprInfo(&ActualWatchInfo, &ExpectedWatchInfo);
}


// BEGIN_HELP_COMMENT
// Function: BOOL COWatch::VerifyWatchInfo(LPCSTR szName, LPCSTR szValue,  LPCSTR szType, EXPR_STATE ExprState)
// Description: Verify that a watch of the specified name, value, type, and state exists in the debugger.
// Return: A Boolean value that specifies whether the verification was sucessful (TRUE) or not (FALSE).
// Param: szName - A string specifying the name of the watch.
// Param: szValue - A string specifying the value of the watch.
// Param: szType - A string specifying the type of the watch.
// Param: ExprState - An EXPR_STATE value specifying the expansion state of the watch (NOT_EXPANABLE, COLLAPSED, EXPANDED).
// END_HELP_COMMENT
BOOL COWatch::VerifyWatchInfo(LPCSTR szName, LPCSTR szValue,  LPCSTR szType, EXPR_STATE ExprState)
{
	CWatch Watch;
	Watch.m_ExprState = ExprState;
	Watch.m_strType = szType;
	Watch.m_strName = szName;
	Watch.m_strValue = szValue;
	return VerifyWatchInfo(Watch);
}


// BEGIN_HELP_COMMENT
// Function: BOOL COWatch::WatchDoesNotExist(LPCSTR szWatch)
// Description: Verify that a watch of the specified name does not exist.
// Return: A Boolean value that specifies whether the verification was sucessful (TRUE) or not (FALSE).
// Param: szWatch A pointer to a string that contains the watch to check for.
// END_HELP_COMMENT
BOOL COWatch::WatchDoesNotExist(LPCSTR szWatch)

{
	const char* const THIS_FUNCTION = "COWatch::WatchDoesNotExist";

	// activate the watch window.
	// TODO(michma): UIWatch::Activate isn't returning TRUE even though the window gets activated.
	/*if(!uiwatch.Activate())
	{
		LOG->RecordInfo("ERROR in %s: can't activate watch window.", THIS_FUNCTION);
		return FALSE;
	}
	*/
	uiwatch.Activate();
	
	BOOL bResult = uiwatch.SelectWatch(szWatch);
	// return focus back to source (if it's there).
	MST.DoKeys("{ESC}");
	return !bResult;
}


// BEGIN_HELP_COMMENT
// Function: BOOL COWatch::WatchCountIs(int intWatchCount)
// Description: Verify that the debugger has an accurate count of the watches.
// Return: A Boolean value that specifies whether the verification was sucessful (TRUE) or not (FALSE).
// Param: intWatchCount An integer specifying the expected count of watches.
// END_HELP_COMMENT
BOOL COWatch::WatchCountIs(int intWatchCount)

{
	const char* const THIS_FUNCTION = "COWatch::WatchCountIs()";

	// activate the watch window.
	// TODO(michma): UIWatch::Activate isn't returning TRUE even though the window gets activated.
	/*if(!uiwatch.Activate())
	{
		LOG->RecordInfo("ERROR in %s: can't activate watch window.", THIS_FUNCTION);
		return FALSE;
	}
	*/
	uiwatch.Activate();

	int intActualWatchCount = uiwatch.GetWatchCount();
	// return focus back to source (if it's there).
	MST.DoKeys("{ESC}");
	return intActualWatchCount == intWatchCount;
}


// BEGIN_HELP_COMMENT
// Function: BOOL COWatch::AddWatch(LPCSTR szWatch)
// Description: Adds a watch on an expression to the debugger.
// Return: A Boolean value that specifies whether the operation was sucessful (TRUE) or not (FALSE).
// Param: szWatch A string specifying the name of the expression for which to add a watch.
// END_HELP_COMMENT
BOOL COWatch::AddWatch(LPCSTR szWatch)

{
	const char* const THIS_FUNCTION = "COWatch::AddWatch()";

	// activate the watch window.
	// TODO(michma): UIWatch::Activate isn't returning TRUE even though the window gets activated.
	/*if(!uiwatch.Activate())
	{
		LOG->RecordInfo("ERROR in %s: can't activate watch window.", THIS_FUNCTION);
		return FALSE;
	}
	*/
	uiwatch.Activate();

	// add the watch by setting the name of the last (empty) row in the watch window.
	if(uiwatch.SetName(szWatch, ROW_LAST) != ERROR_SUCCESS)
	{
		LOG->RecordInfo("ERROR in %s: can't set name \"%s\" in watch window.", THIS_FUNCTION);
		return FALSE;
	}

	// return focus back to source (if it's there).
	MST.DoKeys("{ESC}");
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL COWatch::RemoveWatch(LPCSTR szWatch)
// Description: Removes a watch on an expression from the debugger.
// Return: A Boolean value that specifies whether the operation was sucessful (TRUE) or not (FALSE).
// Param: szWatch A string specifying the name of the expression for which to remove a watch.
// END_HELP_COMMENT
BOOL COWatch::RemoveWatch(LPCSTR szWatch)
{
	const char* const THIS_FUNCTION = "COWatch::RemoveWatch()";

	// activate the watch window.
	// TODO(michma): UIWatch::Activate isn't returning TRUE even though the window gets activated.
	/*if(!uiwatch.Activate())
	{
		LOG->RecordInfo("ERROR in %s: can't activate watch window.", THIS_FUNCTION);
		return FALSE;
	}
	*/
	uiwatch.Activate();

	// select the watch to delete.
	if(!uiwatch.SelectWatch(szWatch))
	{
		LOG->RecordInfo("ERROR in %s: can't select watch \"%s\" in watch window.", THIS_FUNCTION, szWatch);
		return FALSE;
	}

	// delete the watch.
	if(uiwatch.Delete() != ERROR_SUCCESS)
	{
		LOG->RecordInfo("ERROR in %s: can't delete watch \"%s\" in watch window.", THIS_FUNCTION, szWatch);
		return FALSE;
	}

	// return focus back to source (if it's there).
	MST.DoKeys("{ESC}");
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL COWatch::SetWatchValue(LPCSTR szWatch, LPCSTR szValue)
// Description: Sets the value of a watch expression.
// Return: A Boolean value that specifies whether the operation was sucessful (TRUE) or not (FALSE).
// Param: szWatch A string specifying the name of the watch expression for which to assign a value.
// Param: szValue A string specifying the value to be assigned to the watch expression.
// END_HELP_COMMENT
BOOL COWatch::SetWatchValue(LPCSTR szWatch, LPCSTR szValue)
{
	const char* const THIS_FUNCTION = "COWatch::SetWatchValue()";

	// activate the watch window.
	// TODO(michma): UIWatch::Activate isn't returning TRUE even though the window gets activated.
	/*if(!uiwatch.Activate())
	{
		LOG->RecordInfo("ERROR in %s: can't activate watch window.", THIS_FUNCTION);
		return FALSE;
	}
	*/
	uiwatch.Activate();

	// select the watch to change.
	if(!uiwatch.SelectWatch(szWatch))
	{
		LOG->RecordInfo("ERROR in %s: can't select watch \"%s\" in watch window.", THIS_FUNCTION, szWatch);
		return FALSE;
	}

	// change the watch value.
	if(uiwatch.SetValue(szValue, ROW_CURRENT, NAME_IS_EDITABLE) != ERROR_SUCCESS)
	{
		LOG->RecordInfo("ERROR in %s: can't change value in watch window \"%s\" in watch window.", THIS_FUNCTION, szWatch);
		return FALSE;
	}

	// return focus back to source (if it's there).
	MST.DoKeys("{ESC}");
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL COWatch::ExpandWatch(LPCSTR szWatch)
// Description: Expands a watch on an expression in the debugger.
// Return: A Boolean value that specifies whether the operation was sucessful (TRUE) or not (FALSE).
// Param: szWatch A string specifying the name of the expression for which to expand a watch.
// END_HELP_COMMENT
BOOL COWatch::ExpandWatch(LPCSTR szWatch)

{
	const char* const THIS_FUNCTION = "COWatch::ExpandWatch()";

	// activate the watch window.
	// TODO(michma): UIWatch::Activate isn't returning TRUE even though the window gets activated.
	/*if(!uiwatch.Activate())
	{
		LOG->RecordInfo("ERROR in %s: can't activate watch window.", THIS_FUNCTION);
		return FALSE;
	}
	*/
	uiwatch.Activate();

	// select the watch to expand.
	if(!uiwatch.SelectWatch(szWatch))
	{
		LOG->RecordInfo("ERROR in %s: can't select watch \"%s\" in watch window.", THIS_FUNCTION, szWatch);
		return FALSE;
	}

	// expand the watch.
	if(uiwatch.Expand() != ERROR_SUCCESS)
	{
		LOG->RecordInfo("ERROR in %s: can't expand watch \"%s\" in watch window.", THIS_FUNCTION, szWatch);
		return FALSE;
	}

	// return focus back to source (if it's there).
	MST.DoKeys("{ESC}");
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL COWatch::CollapseWatch(LPCSTR szWatch)
// Description: Collapses a watch on an expression in the debugger.
// Return: A Boolean value that specifies whether the operation was sucessful (TRUE) or not (FALSE).
// Param: szWatch A string specifying the name of the expression for which to collapse a watch.
// END_HELP_COMMENT
BOOL COWatch::CollapseWatch(LPCSTR szWatch)

{
	const char* const THIS_FUNCTION = "COWatch::CollapseWatch()";

	// activate the watch window.
	// TODO(michma): UIWatch::Activate isn't returning TRUE even though the window gets activated.
	/*if(!uiwatch.Activate())
	{
		LOG->RecordInfo("ERROR in %s: can't activate watch window.", THIS_FUNCTION);
		return FALSE;
	}
	*/
	uiwatch.Activate();

	// select the watch to expand.
	if(!uiwatch.SelectWatch(szWatch))
	{
		LOG->RecordInfo("ERROR in %s: can't select watch \"%s\" in watch window.", THIS_FUNCTION, szWatch);
		return FALSE;
	}

	// collapse the watch.
	if(uiwatch.Collapse() != ERROR_SUCCESS)
	{
		LOG->RecordInfo("ERROR in %s: can't expand watch \"%s\" in watch window.", THIS_FUNCTION, szWatch);
		return FALSE;
	}

	// return focus back to source (if it's there).
	MST.DoKeys("{ESC}");
	return TRUE;
}


#pragma warning (default : 4069)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\dbg.cpp ===
/////////////////////////////////////////////////////////////////////////////
// dbg.cpp
//
// email	date		change
// briancr	01/11/95	created
//
// copyright 1994 Microsoft

#include "stdafx.h"
#include "afxdllx.h"

#define new DEBUG_NEW

///////////////////////////////////////////////////////////////////////////////
//	DLL support

static AFX_EXTENSION_MODULE extensionDLL = { NULL, NULL };

extern "C" __declspec(dllexport) int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("Debugger DLL Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(extensionDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(extensionDLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("Debugger DLL Terminating!\n");
		// Terminate the library before destructors are called
		AfxTermExtensionModule(extensionDLL);
	}
	return 1;   // ok

	UNREFERENCED_PARAMETER(lpReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\parse.h ===
///////////////////////////////////////////////////////////////////////////////
//	PARSE.H
//
//	Created by :			Date :
//		BrianCr				09/24/93
//
//	Description :
//		Declaration of the token classes and parse function
//
//

#ifndef __PARSE_H__
#define __PARSE_H__

#include "dbgxprt.h"

// parsing support

// BEGIN_CLASS_HELP
// ClassName: CToken
// BaseClass: CObject
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS CToken: public CObject {
public:
	CToken(void);
	CToken(CString, CString);
	~CToken();

	CToken &operator=(CToken &);

	CString GetToken(void);
	CString GetLeadingSeps(void);

	void SetToken(CString);
	void SetLeadingSeps(CString);

private:
	CString m_strToken;
	CString m_strLeadingSeps;
};


// BEGIN_CLASS_HELP
// ClassName: CTokenList
// BaseClass: CObList
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS CTokenList: public CObList {
public:
	CTokenList();
	~CTokenList();

	//CToken *&GetHead(void);
	CToken *GetHead(void);

	//CToken *&GetTail(void);
	CToken *GetTail(void);

	POSITION AddHead(CToken *);
	// void AddHead(CTokenList *);

	POSITION AddTail(CToken *);
	// void AddTail(CTokenList *);

//	CToken *&GetNext(POSITION &);
	CToken *GetNext(POSITION &);

//	CToken *&GetPrev(POSITION &);
	CToken *GetPrev(POSITION &);

	//CToken *&GetAt(POSITION);
	CToken *GetAt(POSITION);

	CString GetTokenString(int);

	void RemoveAll(void);
};


void Parse(CString, CString, CTokenList &);

#endif // __PARSE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\parse.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	PARSE.CPP
//
//	Created by :			Date :
//		BrianCr				09/24/93
//
//	Description :
//		Implementation of the token classes and parse function
//
//

#include "stdafx.h"
#include "parse.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// CToken implementation
CToken::CToken(void)
: m_strToken(""), m_strLeadingSeps("")
{
	NULL;
}

CToken::CToken(CString strToken, CString strLeadingSeps)
: m_strToken(strToken), m_strLeadingSeps(strLeadingSeps)
{
	NULL;
}

CToken::~CToken()
{
	NULL;
}

CToken &CToken::operator=(CToken &token)
{
	m_strToken = token.m_strToken;
	m_strLeadingSeps = token.m_strLeadingSeps;

	return (*this);
}

CString CToken::GetToken(void)
{
	return (m_strToken);
}

CString CToken::GetLeadingSeps(void)
{
	return (m_strLeadingSeps);
}

void CToken::SetToken(CString strToken)
{
	m_strToken = strToken;
}

void CToken::SetLeadingSeps(CString strLeadingSeps)
{
	m_strLeadingSeps = strLeadingSeps;
}


// CTokenList implementation
CTokenList::CTokenList(void)
: CObList()
{
	NULL;
}

CTokenList::~CTokenList()
{
	RemoveAll();
}

/*CToken *&CTokenList::GetHead(void)
{
	return ((CToken *&)CObList::GetHead());
} */

CToken *CTokenList::GetHead(void)
{
	return ((CToken *)CObList::GetHead());
}

/*CToken *&CTokenList::GetTail(void)
{
	return ((CToken *)CObList::GetTail());
} */

CToken *CTokenList::GetTail(void)
{
	return ((CToken *)CObList::GetTail());
}

POSITION CTokenList::AddHead(CToken *pToken)
{
	return (CObList::AddHead((CObject *)pToken));
}

POSITION CTokenList::AddTail(CToken *pToken)
{
	return (CObList::AddTail((CObject *)pToken));
}

/*CToken *&CTokenList::GetNext(POSITION &pos)
{
	return ((CToken *&)CObList::GetNext(pos));
} */

CToken *CTokenList::GetNext(POSITION &pos)
{
	return ((CToken *)CObList::GetNext(pos));
}

/*CToken *&CTokenList::GetPrev(POSITION &pos)
{
	return ((CToken *&)CObList::GetPrev(pos));
} */

CToken *CTokenList::GetPrev(POSITION &pos)
{
	return ((CToken *)CObList::GetPrev(pos));
}

/*CToken *&CTokenList::GetAt(POSITION pos)
{
	return ((CToken *&)CObList::GetAt(pos));
} */

CToken *CTokenList::GetAt(POSITION pos)
{
	return ((CToken *)CObList::GetAt(pos));
}

CString CTokenList::GetTokenString(int nIndex)
{
	return ((GetAt(FindIndex(nIndex)))->GetToken());
}

void CTokenList::RemoveAll(void)
{
	POSITION pos, nextpos;

	for (nextpos = pos = GetHeadPosition(); pos != NULL; pos = nextpos) {
		delete GetNext(nextpos);
		RemoveAt(pos);
	}
}


void Parse(CString strParse, CString strSeps, CTokenList &listToken)
{
	CToken *pToken;
	CString strToken, strLeadingSeps;
	int i, nBeginToken, nEndToken;
	BOOL bDone;

	// if the string to parse is empty, we're done
	if (strParse.IsEmpty())
		return;
	// otherwise, get the first token and call this recursively
	else {
		// strip off preceeding separators into strLeadingSeps
		for (i = 0, bDone = FALSE; !bDone; ) {
			if (i >= strParse.GetLength()) {
				bDone = TRUE;
			}
			else {
				if (strSeps.FindOneOf(CString(strParse[i], 1)) != -1) {
					strLeadingSeps += strParse[i++];
				}
				else {
					bDone = TRUE;
				}
			}
		}
		// strip off token into strToken
		nBeginToken = i;
		// if nBeginToken is past the end of the string, there's no token
		if (nBeginToken <= strParse.GetLength()) {
		// end of string is not a separator; if no separator is found, the
			// end of the token is the end of the string
			if ((nEndToken = (strParse.Mid(nBeginToken)).FindOneOf(strSeps)) == -1) {
				nEndToken = strParse.GetLength();
			}
			// convert relative (to nBeginToken) position to absolute position
			else {
				nEndToken += nBeginToken;
			}
			// extract the token
			strToken = strParse.Mid(nBeginToken, nEndToken - nBeginToken);
		}
		// create a new CToken
		pToken = new CToken(strToken, strLeadingSeps);
		// add this token to the end of the token list
		listToken.AddTail(pToken);
		// call Parse minus the stripped token
		Parse(strParse.Mid(nEndToken), strSeps, listToken);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uiattach.h ===
///////////////////////////////////////////////////////////////////////////////
//  UIATTACH.H
//
//  Created by:		MichMa		
//	Date:			2/18/98
//  Description:	Declaration of the UIAttachToProcessDlg class
//

#ifndef __UIATTACH_H__
#define __UIATTACH_H__

#include "..\..\udialog.h"
#include "..\shl\wbutil.h"
#include "dbgxprt.h"

#ifndef __UIDIALOG_H__
   #error include 'udialog.h' before including this file
#endif


///////////////////////////////////////////////////////////////////////////////
//  UIAttachToProcessDlg class

// BEGIN_CLASS_HELP
// ClassName: UIAttachToProcessDlg
// BaseClass: UIDialog
// Category: Debug
// END_CLASS_HELP

class DBG_CLASS UIAttachToProcessDlg : public UIDialog

{
// base class overrides
public:	
	UIWND_COPY_CTOR(UIAttachToProcessDlg, UIDialog);
	virtual CString ExpectedTitle (void) const{return GetLocString(IDSS_ATTACH_TO_PROCESS_DLG_TITLE);}
	virtual BOOL Activate(void);
	virtual HWND OK(void);

// Utilities
public:
	BOOL ShowSystemProcesses(BOOL bShowSystemProcesses);
	BOOL SelectProcess(LPCSTR szProcessName);
};

#endif // __UIATTACH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uibp.h ===
///////////////////////////////////////////////////////////////////////////////
//  UIBP.H
//
//  Created by :            Date :
//      MichMa              1/14/94
//
//  Description :
//      Declaration of the UIBreakpoints class
//

#ifndef __UIBP_H__
#define __UIBP_H__

#include "..\..\udialog.h"
#include "..\shl\wbutil.h"

#include "dbgxprt.h"

#ifndef __UIDIALOG_H__
   #error include 'udialog.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//  UIBreakpoints symbols

enum {  UIBP_TYPE_LOC=1,
		UIBP_TYPE_LOC_IF_EXP_TRUE,
		UIBP_TYPE_LOC_IF_EXP_CHANGED,
		UIBP_TYPE_IF_EXP_TRUE,
		UIBP_TYPE_IF_EXP_CHANGED,
		UIBP_TYPE_WNDPROC_IF_MSG_RECVD };

enum {  BK_MESSAGE=1, BK_CLASS };

/// Control IDs for the new Breakpoints dialog
enum {                                  // From \olympus\ide\src\rsc\resource.h
		UIBP_LOCATION_EDIT = 24134,     // IDC_LOCATION
//		UIBP_LOCATION_TEXT = 24143,     // IDC_BPTAB_GEN1
//		UIBP_EXPRESSION_EDIT = 24135,   // IDC_EXPRESSION
		UIBP_LOCATION_EXPRESSION = 25449,   // Not in rsc\resource.h
		UIBP_DATA_EXPRESSION = 25453,   // Not in rsc\resource.h
//		UIBP_IS_TRUE_BUTTON = 24141,    // IDC_TRUE
//		UIBP_CHANGES_BUTTON = 24142,    // IDC_CHANGES
		UIBP_WINDPROC_COMBO = 24138,    // IDC_WNDPROC
		UIBP_WINDPROC_EDIT = 1001,      // Not in rsc\resource.h
		UIBP_MESSAGE_COMBO = 24137,     // IDC_MESSAGE
		UIBP_MESSAGE_EDIT = 1001,       // Not in rsc\resource.h
//		UIBP_PASSCOUNT_EDIT = 24139,    // IDC_SKIP
//		UIBP_LENGTH_EDIT = 24136,       // IDC_LENGTH
		UIBP_SKIP_COUNT = 25450,		// Not in rsc\resource.h
		UIBP_NUMBER_OF_ELEMENTS = 25460,    // Not in rsc\resource.h
		UIBP_BREAKPOINTS_LIST = 2000,   // Not in rsc\resource.h
		UIBP_OK_BTN = 1,                // Standard ctrl-ID
		UIBP_CANCEL_BTN = 2,            // Standard ctrl-ID
		UIBP_HELP_BTN = 57669,          // Standard ctrl-ID
		UIBP_EDITCODE_BTN = 2001,       // Not in rsc\resource.h
		UIBP_REMOVE_BTN = 2002,         // Not in rsc\resource.h
		UIBP_CONDITION_BTN = 25452,     // Not in rsc\resource.h
	  };


///////////////////////////////////////////////////////////////////////////////
//  UIBreakpointCondition class

// BEGIN_CLASS_HELP
// ClassName: UIBreakpointCondition
// BaseClass: UIDialog
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS UIBreakpointCondition : public UIDialog

	{
// base class overrides
public:
	UIWND_COPY_CTOR (UIBreakpointCondition, UIDialog) ;
	virtual CString ExpectedTitle (void) const{return GetLocString(IDSS_BP_CONDITION_TITLE);}
	virtual BOOL Activate(void);

	// Utilities
	public:

		BOOL SetExpression(LPCSTR expression, int expr_type);
		BOOL SetLength(LPCSTR length);
		BOOL SetPassCount(LPCSTR passcount);
//		BOOL ExpressionTypeIs(int expr_type);

	// Standard buttons
//		virtual HWND Close(void);
	};

///////////////////////////////////////////////////////////////////////////////
//  UIBreakpoints class

// BEGIN_CLASS_HELP
// ClassName: UIBreakpoints
// BaseClass: UIDialog
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS UIBreakpoints : public UIDialog

	{
// base class overrides
public:
	UIWND_COPY_CTOR (UIBreakpoints, UIDialog) ;
	virtual CString ExpectedTitle (void) const{return GetLocString(IDSS_BP_TITLE);}
	virtual BOOL Activate(void);

	// Utilities
	public:

//		BOOL SetType(int type);
		BOOL SetLocation(LPCSTR location);
//		BOOL SetExpression(LPCSTR expression, int expr_type, BOOL fForceType = TRUE);
		BOOL SetLocationExpression(LPCSTR expression, int expr_type);
		BOOL SetDataExpression(LPCSTR expression, int expr_type);
		BOOL SetExprLength(LPCSTR length);
		BOOL SetLocationExprLength(LPCSTR length);
		BOOL SetPassCount(LPCSTR passcount);
		BOOL SetCurrentBreakpoint(int bp = 0);
		BOOL SetWndProc(LPCSTR location);
		BOOL SetMessage(LPCSTR message, int type);
		
//		BOOL Add();
		BOOL Remove(int bp = 0);
		BOOL Enable(int bp = 0);
		BOOL Disable(int bp = 0);
		BOOL ClearAll();

		int GetCount(void);
		CString GetBreakpointStr(int bp = 0);

		BOOL BreakpointIsSet(LPCSTR expr, LPCSTR source = NULL);
		BOOL BreakpointIsEnabled(LPCSTR expr, LPCSTR source = NULL);

		BOOL EditCode(void);

	// Standard buttons
		virtual HWND Close(void);

	private:
		UIBreakpointCondition uibpcond;
	};


#endif //__UIBP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uibp.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UIBP.CPP
//
//  Created by :            Date :
//      MichMa              01/14/94
//
//  Description :
//      Implementation of the UIBreakpoints class
//

#include "stdafx.h"
#include "uibp.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\cmdids.h"
#include "guiv1.h"
#include "..\shl\uitabdlg.h"
#include "..\shl\uwbframe.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


// BEGIN_HELP_COMMENT
// Function: BOOL UIBreakpoints::Activate(void)
// Description: Open the Breakpoints dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIBreakpoints::Activate(void)
{
	UIWB.DoCommand(IDM_RUN_SETBREAK, DC_MNEMONIC);  
//	UIWB.DoCommand(IDM_RUN_SETBREAK, DC_ACCEL);    // Temporary for new BP dialog

	Attach(MST.WFndWndWait(GetLocString(IDSS_BP_TITLE), FW_DEFAULT, 10));   // give it 10 seconds to come up.
	return (this != NULL);
}

///BOOL UIBreakpoints::SetType(int type)
///	{
///	if(!(IsActive() && MST.WComboEnabled(GetLabel(VCPP32_ID_SETBREAK_ACTION)))) return FALSE;
///	MST.WComboItemClk(GetLabel(VCPP32_ID_SETBREAK_ACTION), type);
///	return TRUE;
///	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIBreakpoints::SetLocation(LPCSTR location)
// Description: Set the location for the breakpoint in the Breakpoints dialog. The Breakpoints dialog must be active when this function is called.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: location A pointer to a string that specifies the location for the breakpoint. The location string is in the form: {function, source filename, EXE filename} .line.
// END_HELP_COMMENT
BOOL UIBreakpoints::SetLocation(LPCSTR location)
	{
	if(!(IsActive()) ) return FALSE;
	UITabbedDialog uitd;
	uitd.AttachActive();
	if( uitd.SetOption(UIBP_LOCATION_EDIT, UIBP_LOCATION_EDIT, location) != ERROR_SUCCESS ) return FALSE;

//	if( !MST.WEditEnabled(GetLabel(UIBP_LOCATION_EDIT, uitd.GetCurrentPage())) ) return FALSE;
//	MST.WEditSetText(GetLabel(UIBP_LOCATION_EDIT, uitd.GetCurrentPage()), location);
	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIBreakpoints::SetLocationExpression(LPCSTR expression, int expr_type, BOOL fForceType /* TRUE */)
// Description: Set the expression to break on for a location breakpoint in the Breakpoints dialog. The Breakpoints dialog must be active when this function is called.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to break on. The expression string is in the form: {function, source filename, EXE filename} expression.
// Param: expr_type A value that specifies the type of expression. This parameter is NYI.
// END_HELP_COMMENT
BOOL UIBreakpoints::SetLocationExpression(LPCSTR expression, int expr_type)
	{
	if(!(IsActive()) ) return FALSE;
	UITabbedDialog uitd;
	uitd.AttachActive();
	uitd.ShowPage(UIBP_LOCATION_EDIT,8);

	uibpcond.Activate();
	if(!uibpcond.SetExpression(expression, expr_type)) return FALSE;

	return TRUE;
	}

// BEGIN_HELP_COMMENT
// Function: BOOL UIBreakpoints::SetDataExpression(LPCSTR expression, int expr_type)
// Description: Set the expression to break on for a data breakpoint in the Breakpoints dialog. The Breakpoints dialog must be active when this function is called.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to break on. The expression string is in the form: {function, source filename, EXE filename} expression.
// Param: expr_type A value that specifies the type of expression. This parameter is NYI.
// END_HELP_COMMENT
BOOL UIBreakpoints::SetDataExpression(LPCSTR expression, int expr_type)
	{
	if(!(IsActive()) ) return FALSE;
	UITabbedDialog uitd;
	uitd.AttachActive();
	uitd.ShowPage(UIBP_DATA_EXPRESSION,8);
	// REVIEW (michma): the control-id is correct but GetLabel
	// claims that no label definition precedes the control definition.
	//if(!MST.WEditEnabled(GetLabel(UIBP_DATA_EXPRESSION)) ) return FALSE;
	if(!MST.WEditEnabled("@1")) return FALSE;
	MST.WEditSetText("@1", expression);

	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIBreakpoints::SetExprLength(LPCSTR length)
// Description: Set the size of the data to watch for an expression in the Breakpoints dialog. The Breakpoints dialog must be active when this function is called.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: length A pointer to a string that contains the size of the data to watch.
// END_HELP_COMMENT
BOOL UIBreakpoints::SetExprLength(LPCSTR length)
	{
	if(!(IsActive()) ) return FALSE;
	UITabbedDialog uitd;
	uitd.AttachActive();
	uitd.ShowPage(UIBP_NUMBER_OF_ELEMENTS,8);
	MST.WEditSetText("@2", length);

	return TRUE;
	}

// BEGIN_HELP_COMMENT
// Function: BOOL UIBreakpoints::SetLocationExprLength(LPCSTR length)
// Description: Set the size of the data to watch for an expression in the Breakpoints dialog. The Breakpoints dialog must be active when this function is called.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: length A pointer to a string that contains the size of the data to watch.
// END_HELP_COMMENT
BOOL UIBreakpoints::SetLocationExprLength(LPCSTR length)
	{
	if(!(IsActive()) ) return FALSE;
	UITabbedDialog uitd;
	uitd.AttachActive();
	uitd.ShowPage(UIBP_LOCATION_EDIT,8);
	uibpcond.Activate();
	if(!uibpcond.SetLength(length)) return FALSE;

	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIBreakpoints::SetPassCount(LPCSTR passcount)
// Description: Set the pass count for a breakpoint in the Breakpoints dialog. The Breakpoints dialog must be active when this function is called.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: passcount A pointer to a string that contains the pass count.
// END_HELP_COMMENT
BOOL UIBreakpoints::SetPassCount(LPCSTR passcount)
	{
	if(!(IsActive()) ) return FALSE;
	UITabbedDialog uitd;
	uitd.AttachActive();
	uitd.ShowPage(UIBP_LOCATION_EDIT,8);
	uibpcond.Activate();
	if(!uibpcond.SetPassCount(passcount)) return FALSE;

	return TRUE;
	/* Passcounts removed from Version 2.0, will be in version 3.0
	if(!(IsActive() && MST.WEditEnabled(GetLabel(VCPP32_ID_SETBREAK_PASSCNT)))) return FALSE;
	MST.WEditSetText(GetLabel(VCPP32_ID_SETBREAK_PASSCNT), passcount);
	return TRUE;
	*/
	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIBreakpoints::SetWndProc(LPCSTR location)
// Description: Set the window procedure for a message breakpoint in the Breakpoints dialog. The Breakpoints dialog must be active when this function is called.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: location A pointer to a string that contains the window procedure.
// END_HELP_COMMENT
BOOL UIBreakpoints::SetWndProc(LPCSTR location)
	{
	if(!(IsActive()) ) return FALSE;
	UITabbedDialog uitd;
	uitd.AttachActive();
	uitd.ShowPage(UIBP_WINDPROC_COMBO,8);
	MST.WComboSetText("@1", location);
	return TRUE;
	}
	
	
// BEGIN_HELP_COMMENT
// Function: BOOL UIBreakpoints::SetMessage(LPCSTR message, int type)
// Description: Set the message to break when received in the Breakpoints dialog. The Breakpoints dialog must be active when this function is called.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: message A pointer to a string that contains the name of the message.
// Param: type A value that specifies the type of message. This parameter is NYI.
// END_HELP_COMMENT
BOOL UIBreakpoints::SetMessage(LPCSTR message, int type)
	{
	if(!(IsActive()) ) return FALSE;
	UITabbedDialog uitd;
	uitd.AttachActive();
	uitd.ShowPage(UIBP_MESSAGE_COMBO,8);
	MST.WComboSetText("@2", message);
	return TRUE;
	}	


// BEGIN_HELP_COMMENT
// Function: BOOL UIBreakpoints::SetCurrentBreakpoint(int bp /* 0 */)
// Description: Select the breakpoint specified in the list of breakpoints in the Breakpoints dialog. The Breakpoints dialog must be active when this function is called.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: bp An integer that specifies the 0-based index into the list of breakpoints. (Default value is 0.)
// END_HELP_COMMENT
BOOL UIBreakpoints::SetCurrentBreakpoint(int bp /* 0 */)
	{
	if(!(IsActive() && MST.WListEnabled(GetLabel(UIBP_BREAKPOINTS_LIST)))) return FALSE;
	MST.WListItemClk(GetLabel(UIBP_BREAKPOINTS_LIST), bp + 1);
	return TRUE;
	}


///BOOL UIBreakpoints::Add()
///	{
///	if(!(IsActive() && MST.WButtonEnabled(GetLabel(VCPP32_ID_SETBREAK_ADD)))) return FALSE;
///	int count = GetCount();
///	MST.WButtonClick(GetLabel(VCPP32_ID_SETBREAK_ADD));
///	return GetCount() == (count + 1);
///	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIBreakpoints::Remove(int bp /* 0 */)	
// Description: Remove the specified breakpoint from the list of breakpoints in the Breakpoints dialog. The Breakpoints dialog must be active when this function is called.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: bp An integer that specifies the 0-based index into the list of breakpoints for the breakpoint to remove. (Default value is 0.)
// END_HELP_COMMENT
BOOL UIBreakpoints::Remove(int bp /* 0 */)	
	{
	if (!SetCurrentBreakpoint(bp))
		return FALSE;
	if(!(IsActive() && MST.WButtonEnabled(GetLabel(UIBP_REMOVE_BTN)))) return FALSE;
	int count = GetCount();
	MST.WButtonClick(GetLabel(UIBP_REMOVE_BTN));
	return GetCount() == (count - 1);
	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIBreakpoints::Enable(int bp /* 0 */)
// Description: Enable the specified breakpoint in the list of breakpoints in the Breakpoints dialog. The Breakpoints dialog must be active when this function is called.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: bp An integer that specifies the 0-based index into the list of breakpoints for the breakpoint to remove. (Default value is 0.)
// END_HELP_COMMENT
BOOL UIBreakpoints::Enable(int bp /* 0 */)
	{
	if (!SetCurrentBreakpoint(bp))
		return FALSE;
	if( !IsActive() ) return FALSE;

	CListBox clist;
	if( !clist.Attach( MST.WGetFocus() ) ) return FALSE;
	DWORD checkbox = clist.GetItemData(bp);
   	if( !clist.Detach() ) return FALSE;
	if( checkbox == 0 )
		MST.DoKeys(" ");

	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIBreakpoints::Disable(int bp /* 0 */)
// Description: Disable the specified breakpoint in the list of breakpoints in the Breakpoints dialog. The Breakpoints dialog must be active when this function is called.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: bp An integer that specifies the 0-based index into the list of breakpoints for the breakpoint to remove. (Default value is 0.)
// END_HELP_COMMENT
BOOL UIBreakpoints::Disable(int bp /* 0 */)
	{
	if (!SetCurrentBreakpoint(bp))
		return FALSE;

	CListBox clist;
	DWORD checkbox;
	if( !clist.Attach( MST.WGetFocus() ) ) return FALSE;
	checkbox = clist.GetItemData(bp);
	if( !clist.Detach() ) return FALSE;
	if( checkbox != 0 )
		MST.DoKeys(" ");

	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIBreakpoints::ClearAll()
// Description: Remove all breakpoints from the list of breakpoints in the Breakpoints dialog. The Breakpoints dialog must be active when this function is called.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIBreakpoints::ClearAll()
{
	if(!(IsActive() && MST.WListEnabled(GetLabel(UIBP_BREAKPOINTS_LIST)))) return FALSE;
//	MST.DoKeys("^{Home}^+{End}");
//	MST.DoKeys("^{End}");
//	MST.DoKeys("^+{Home}");
//	if( !MST.WButtonEnabled(GetLabel(UIBP_REMOVE_BTN)) ) return FALSE;
//	MST.WButtonClick(GetLabel(UIBP_REMOVE_BTN));

	// Review: YS: When multiple selection is avalable we'll do SelectAll() & Remove()
	int count = GetCount();
	if( count > 1 ) 	  // New BP dialog: the "new breakpoint" line gets count bigger by 1
		for( int i = 0; i < count - 1; i++ )
		{
			if( !(SetCurrentBreakpoint() && MST.WButtonEnabled(GetLabel(UIBP_REMOVE_BTN))) ) return FALSE;
			MST.WButtonClick(GetLabel(UIBP_REMOVE_BTN));
		}
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIBreakpoints::BreakpointIsSet(LPCSTR expr, LPCSTR source /* NULL */)
// Description: Determine if the breakpoint specified is set in the Breakpoints dialog. The Breakpoints dialog must be active when this function is called.
// Return: A Boolean value that indicates whether the breakpoint is set (TRUE) or not.
// Param: expr A pointer to a string that contains all or part of the expected expression for the breakpoint.
// Param: source A pointer to a string that contains all or part of the expected source filename for the breakpoint. NULL means use expression only. (Default value is NULL.)
// END_HELP_COMMENT
BOOL UIBreakpoints::BreakpointIsSet(LPCSTR expr, LPCSTR source /* NULL */)
	
{
	if(!(IsActive() && MST.WListEnabled(GetLabel(UIBP_BREAKPOINTS_LIST)))) return FALSE;
	int count = GetCount();
	CString cstr;

	for (int i = 0; i < count - 1; i++)
	{
		cstr = GetBreakpointStr(i);

   		if((cstr.Find(expr) != -1) && ((!source) || (cstr.Find(source) != -1)))
			break;
	}
	
	return (i < count - 1);
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIBreakpoints::BreakpointIsEnabled(LPCSTR expr, LPCSTR source /* NULL */)
// Description: Determine if the specified breakpoint is enabled in the Breakpoints dialog. The Breakpoints dialog must be active when this function is called.
// Return: A Boolean value that indicates whether the breakpoint is enabled (TRUE) or not.
// Param: expr A pointer to a string that contains all or part of the expected expression for the breakpoint.
// Param: source A pointer to a string that contains all or part of the expected source filename for the breakpoint. NULL means use expression only. (Default value is NULL.)
// END_HELP_COMMENT
BOOL UIBreakpoints::BreakpointIsEnabled(LPCSTR expr, LPCSTR source /* NULL */)
{
	if(!(IsActive() && MST.WListEnabled(GetLabel(UIBP_BREAKPOINTS_LIST)))) return FALSE;
	int count = GetCount();
	CString cstr;

	CListBox clist;
	if( !clist.Attach( MST.WGetFocus() ) ) return FALSE;

	DWORD checkbox; 
	for (int i = 0; i < count - 1; i++)
 	{
		cstr = GetBreakpointStr(i);
		checkbox = clist.GetItemData(i);
   		if( (cstr.Find(expr) != -1) && ((!source) || (cstr.Find(source) != -1)) && (checkbox != 0) )
			break;
	}

	if( !clist.Detach() ) return FALSE;
	return (i < count - 1);
}


// BEGIN_HELP_COMMENT
// Function: int UIBreakpoints::GetCount(void)
// Description: Get the number of breakpoints set in the Breakpoints dialog. The Breakpoints dialog must be active when this function is called.
// Return: An integer that specifies the number of breakpoints set.
// END_HELP_COMMENT
int UIBreakpoints::GetCount(void)
	{
	if(!(IsActive() && MST.WListExists(GetLabel(UIBP_BREAKPOINTS_LIST)))) return FALSE;
	return MST.WListCount(GetLabel(UIBP_BREAKPOINTS_LIST));
	}


// BEGIN_HELP_COMMENT
// Function: CString UIBreakpoints::GetBreakpointStr(int bp /* 0 */)
// Description: Get a string that describes the specified breakpoint from the Breakpoints dialog. The Breakpoints dialog must be active when this function is called.
// Return: A CString that contains a string describing the specified breakpoint.
// Param: bp An integer that specifies the 0-based index into the list of breakpoints. (Default value is 0.)
// END_HELP_COMMENT
CString UIBreakpoints::GetBreakpointStr(int bp /* 0 */)
	
	{
//	if(!(IsActive() && MST.WListEnabled(GetLabel(UIBP_BREAKPOINTS_LIST)))) return FALSE;
///	//if(!(IsActive() && MST.WListExists(GetLabel(VCPP32_ID_SETBREAK_BREAKPOINT)))) return FALSE;
///					//REVIEW: why does above line cause CString::CString ambigious overloaded function call?
	CString cstr;

	MST.WListItemText(GetLabel(UIBP_BREAKPOINTS_LIST), bp+1, cstr);

	return cstr;
	}

// BEGIN_HELP_COMMENT
// Function: HWND UIBreakpoints::Close(void)
// Description: Close the Breakpoints dialog.
// Return: NULL if successful; the HWND of any remaining dialog or message box otherwise.
// END_HELP_COMMENT
HWND UIBreakpoints::Close(void)
{
//	ExpectValid();
 	
	if( GetLabel(UIBP_OK_BTN,NULL,TRUE) )    // Suppress warning if no button
		MST.WButtonClick(GetLabel(UIBP_OK_BTN));		// use the close button if there is one
	else
	{
	    LOG->RecordInfo( "Did not find Breakpoints Close button" );
		PostMessage(HWnd(), WM_CLOSE, 0, 0);	// otherwise, close it however we must
	}
	if( WaitUntilGone(3000) )		// REVIEW(davidga) 3000 is too arbitrary
		return NULL;		// NULL means all is well
	else
		return MST.WGetActWnd(0);	// an HWND presumes some alert came up
}


//      Implementation of the UIBreakpointCondition class
//

// BEGIN_HELP_COMMENT
// Function: BOOL UIBreakpointCondition::Activate(void)
// Description: Open the Breakpoint Condition dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIBreakpointCondition::Activate(void)
{
	MST.WButtonClick(GetLabel(25452)); // Condition button.
	Attach(MST.WFndWndWait(GetLocString(IDSS_BP_CONDITION_TITLE), FW_ALL|FW_FOCUS|FW_NOCASE|FW_FULL, 10));   // give it 10 seconds to come up.
	return (this != NULL);
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIBreakpointCondition::SetExpression(LPCSTR expression, int expr_type)
// Description: Set the expression in the Breakpoint Condition dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: expression A pointer to a string that contains the expression to set.
// Param: expr_type A value that indicates the type of expression. This parameter is NYI.
// END_HELP_COMMENT
BOOL UIBreakpointCondition::SetExpression(LPCSTR expression, int expr_type)
{
	if( !(IsActive() && MST.WEditEnabled(GetLabel(UIBP_LOCATION_EXPRESSION))) ) return FALSE;
	MST.WEditSetText("@1", expression);
	MST.WButtonClick(GetLabel(UIBP_OK_BTN));
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIBreakpointCondition::SetPassCount(LPCSTR passcount)
// Description: Set the pass count in the Breakpoint Condition dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: passcount A pointer to a string that contains the pass count.
// END_HELP_COMMENT
BOOL UIBreakpointCondition::SetPassCount(LPCSTR passcount)
{
	if( !(IsActive() && MST.WEditEnabled(GetLabel(UIBP_SKIP_COUNT))) ) return FALSE;
	MST.WEditSetText("@3", passcount);
//	if( !SetWindowText(GetDlgItem(UIBP_SKIP_COUNT), passcount) ) return FALSE;
	MST.WButtonClick(GetLabel(UIBP_OK_BTN));
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIBreakpointCondition::SetLength(LPCSTR passcount)
// Description: Set the Number of elements in the Breakpoint Condition dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: length - A pointer to a string that contains the length.
// END_HELP_COMMENT
BOOL UIBreakpointCondition::SetLength(LPCSTR length)
{
	if( !(IsActive() && MST.WEditEnabled(GetLabel(UIBP_LOCATION_EXPRESSION))) ) return FALSE;
//	if( !(IsActive() && MST.WEditEnabled(GetLabel(UIBP_NUMBER_OF_ELEMENTS))) ) return FALSE;
	MST.WEditSetText("@2", length);
	MST.WButtonClick(GetLabel(UIBP_OK_BTN));
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIBreakpoints::EditCode(void)
// Description: Selects the Edit Code button in the breakpoints dlg.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIBreakpoints::EditCode(void)

{
	// make sure the bp dlg is active.
	if(!IsActive())
	{
		LOG->RecordInfo("ERROR in UIBreakpoints::EditCode() - bp dlg not active");
		return FALSE;
	}
	
	// make sure the Edit Code button is enabled.
	if(!MST.WButtonEnabled(GetLocString(IDSS_BP_EDIT_CODE_BUTTON)))
	{
		LOG->RecordInfo("ERROR in UIBreakpoints::EditCode() - \"%s\" button not enabled", 
						GetLocString(IDSS_BP_EDIT_CODE_BUTTON));
		return FALSE;
	}
	
	// hit the Edit Code button.
	MST.WButtonClick(GetLocString(IDSS_BP_EDIT_CODE_BUTTON));
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uiattach.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UIATTACH.CPP
//
//  Created by:		MichMa		
//	Date:			2/18/98
//  Description:	Implementation of the UIAttachToProcessDlg class
//

#include "stdafx.h"
#include "uiattach.h"
#include "..\shl\uwbframe.h"
#include "mstwrap.h"
#include "guiv1.h"
#include "guitarg.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


// BEGIN_HELP_COMMENT
// Function: BOOL UIAttachToProcessDlg::Activate(void)
// Description: Open the Attach To Process dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIAttachToProcessDlg::Activate(void)

{
	UIWB.DoCommand(IDM_BUILD_DEBUG_ATTACH, DC_MNEMONIC);

	if(WaitAttachActive(5000))
		return TRUE;
	
	return FALSE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIAttachToProcessDlg::ShowSystemProcesses(BOOL bShowSystemProcesses)
// Description: Toggles display of system processes in the Attach To Process dlg.
// Return: A boolean value that indicates success or failure. TRUE if successful, FALSE if not.
// Param: bShowSystemProcesses - A boolean value specifying whether or not to show system processes.
// END_HELP_COMMENT
BOOL UIAttachToProcessDlg::ShowSystemProcesses(BOOL bShowSystemProcesses)

{
	char szThisFunc[] = "UIAttachToProcessDlg::ShowSystemProcesses";

	// verify attach to process dlg is up.
	if(!IsActive())
	{
		LOG->RecordInfo("ERROR in %s: 'Attach To Process' dlg isn't active.", szThisFunc);
		return FALSE;
	}

	// check if the Show System Processes checkbox is enabled.
	if(!MST.WCheckEnabled("@1"))
	{
		LOG->RecordInfo("ERROR in %s: 'Show System Processes' checkbox isn't enabled.", szThisFunc);
		return FALSE;
	}
	
	// toggle the Show System Processes checkbox appropriately.
	if(bShowSystemProcesses)
		MST.WCheckCheck("@1");
	else
		MST.WCheckUnCheck("@1");

	// wait for the dialog to update its list with the system processes.
	WaitForInputIdle(g_hTargetProc, 10000);
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIAttachToProcessDlg::SelectProcess(LPCSTR szProcessName)
// Description: Selects a process in the Attach To Process dlg.
// Return: A boolean value that indicates success or failure. TRUE if successful, FALSE if not.
// Param: szProcessName - A string specifying the name of the process to select.
// END_HELP_COMMENT
BOOL UIAttachToProcessDlg::SelectProcess(LPCSTR szProcessName)

{
	char szThisFunc[] = "UIAttachToProcessDlg::SelectProcess";

	// verify attach to process dlg is up.
	if(!IsActive())
	{
		LOG->RecordInfo("ERROR in %s: 'Attach To Process' dlg isn't active.", szThisFunc);
		return FALSE;
	}

	// check if the specified process exists in the process list.
	if(!MST.WViewItemExists("@1", szProcessName))
	{
		LOG->RecordInfo("ERROR in %s: couldn't find process '%s'.", szThisFunc, szProcessName);
		return FALSE;
	}

	MST.WViewItemClk("@1", szProcessName);
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIAttachToProcessDlg::OK(void)
// Description: OK's the Attach To Process dlg.
// Return: NULL if successful, otherwise the handle of the window that was active after the OK was attempted on the Attach To Process dlg.
// END_HELP_COMMENT
HWND UIAttachToProcessDlg::OK(void)

{
	// TODO(michma): for some reason the debugger gets hung when attaching if we close the dialog via ms-test's 
	// WButtonClick like UIDialog::OK() does. so we are working around this by sending the keys more directly.
	WaitStepInstructions("Sending RETURN key");
	keybd_event(VK_RETURN, 0,0,0);
	keybd_event(VK_RETURN, 0,KEYEVENTF_KEYUP,0);

	if(WaitUntilGone(1000))
		return NULL;		
	else
		return MST.WGetActWnd(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uicp.h ===
///////////////////////////////////////////////////////////////////////////////
//  UICP.H
//
//  Created by :            Date :
//      WayneBr             1/14/94
//
//  Description :
//      Declaration of the UICoProcessor class
//

#ifndef __UICP_H__
#define __UICP_H__

#include "..\shl\udockwnd.h"

#include "dbgxprt.h"

#ifndef __UIDOCKWND_H__
	#error include 'udockwnd.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//  UICoProcessor symbols

// enums must start at 1

// Intel Specific
//enum {ST0=1, ST1, ST2, ST3, ST4, ST5, ST6, ST7, CTRL, STAT, TAGS, IP, CS, DO, DS};
enum {rST0=1, rST1, rST2, rST3, rST4, rST5, rST6, rST7, rCTRL, rSTAT, rTAGS, rIP, rCS, rDO, rDS};
//const MaxReg=14;
#define MaxReg 14
#define REG_OFFSET 24


///////////////////////////////////////////////////////////////////////////////
//  UICoProcessor class

// BEGIN_CLASS_HELP
// ClassName: UICoProcessor
// BaseClass: UIDockWindow
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS UICoProcessor : public UIDockWindow
	{

	UIWND_COPY_CTOR(UICoProcessor, UIDockWindow);

	virtual BOOL AttachActive(void);
	virtual BOOL Find(void);

	// Initialization
	public:

	// Data
	private:
		int m_option;

	// UIWindow overrides
	public:
		virtual BOOL IsValid(void) const;
		virtual BOOL IsActive(void);	// derived classes must provide their own Activate (usually a DoCommand)


	// Utilities
	public:
		CString GetCPRegister(int reg);
		BOOL SetCPRegister(int reg, LPCSTR value);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uibrowse.h ===
///////////////////////////////////////////////////////////////////////////////
//  UIBROWSE.H
//
//  Created by :            Date :
//      WayneBr             1/21/94
//
//  Description :
//      Declaration of the UIBrowse class
//

#ifndef __UIBROWSE_H__
#define __UIBROWSE_H__

#include "..\..\udialog.h"
#include "..\..\testutil.h"

#include "dbgxprt.h"

///////////////////////////////////////////////////////////////////////////////
//  UIBrowse symbols

//filters for FILTER BIT MASK
#define NONE 0
enum bmfFilterType {CLASSES=1,FUNCTIONS=2,DATA=4,MACROS=8,TYPES=16};
enum attributeFilterType {AllFNCs=1,Virtual, Static,NonVirtual, NonStatic,NSNV,NoFCNs, AllData=16,StaticData=32,NonStaticData=48,NoData=64};

// Query types
enum QueryType {DefRef=1, FileOutline, BaseClass, DerivedClass, CallGraph, CallerGraph};

// Pane types
enum PaneType {SYMBOL_PANE=1, MEMBER_PANE, DEFREF_PANE};

///////////////////////////////////////////////////////////////////////////////
//  UIBrowse class : public UIWindow

// BEGIN_CLASS_HELP
// ClassName: UIBrowse
// BaseClass: UIWindow
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS UIBrowse : public UIWindow {
public:
	UIWND_COPY_CTOR(UIBrowse, UIWindow);

	virtual BOOL Find(void);

	// Query status
	enum QueryStatus {
		NotActive = 0,
		AmbiguityDialog,
		FileNotFound,
		SymbolNotFound,
		Active,
	};

private:
	// Data
	PaneType m_pane;
	HWND m_hWndPushPin;
	QueryType m_type;
	QueryStatus m_status;
	int m_filters;
	CString m_name;


// UIWindow overrides
public:
	virtual BOOL IsValid(void) const;
	virtual BOOL IsActive(void);    // derived classes must provide their own Activate (usually a DoCommand)


// Utilities
public:
	// Note: There may be a not found or resolve ambiguity dialog if Query returns FALSE
	BOOL Query(QueryType query, LPCSTR name=NULL, int filters=NONE, int case_sensitive = TRUE);
	BOOL SetFilters(QueryType type, int filters);          // set filters based on current type
	int  GetFilters(QueryType type);                       // get filters based on current type

	QueryStatus GetStatus() const { return m_status; }

	BOOL GetMatches( CStringArray& matches );
	BOOL SelectMatch( CString name );
	BOOL SelectMatch( int index );
	int FindMatch(CString name);

	// only applies to class queries ( usually located in upper-right pane )
	BOOL GetMembers( CStringArray& members );
	BOOL SelectMember( CString member );
	BOOL SelectMember( int index );

	// definitions for current match ( usually located in right or lower-right pane )
	BOOL GetLocations( CStringArray& locations );
	BOOL SelectDefinition( CString definition );
	BOOL SelectDefinition( int index );

	// references for current match ( usually located directly below definitions in same pane )
	BOOL SelectReference( CString reference );
	BOOL SelectReference( int index );

	// get first level of descendents or ancestors in tree.
	BOOL GetFirstLevelBranches( CStringArray& branches );

	BOOL PopContext(void);

	BOOL FirstDefinition(void);
	BOOL NextDefinition(void);
	BOOL PrevDefinition(void);

	BOOL FirstReference(void);
	BOOL NextReference(void);
	BOOL PrevReference(void);


	BOOL GotoPane(PaneType pane, QueryType type);
	BOOL GotoDefinitionsHeading(void);
	BOOL GotoReferencesHeading(void);
	BOOL SelectNthItem(QueryType type, int item);
	BOOL Navigate(void);
	BOOL ExpandCurrentItem(void);
	CString GetCurrentItem(void);

	BOOL CrackFileLine(LPCSTR file_line,CHAR *file,int *line);
	void ButtonDown(const char * button);
	void ButtonUp(const char * button);
	BOOL IsButtonDown(const char * button);
	BOOL CloseBrowser(void);

	// interface for ambigious dialog ( only valid when m_status == AmbiguityDialog )
	BOOL GetAmbiguities( CStringArray& ambiguities );
	BOOL GetCurrentAmbiguity( CString& symbol );
	BOOL SelectAmbiguity( CString symbol );
	BOOL SelectAmbiguity( int index );  // only needed if 
	BOOL CancelAmbiguity();

	BOOL ToggleCaseSensitivity(TOGGLE_TYPE t);

protected:
	virtual void OnUpdate(void);
};

// class UIAmbiguiousSymbolDialog 

// BEGIN_CLASS_HELP
// ClassName: UIAmbiguiousSymbolDialog
// BaseClass: UIDialog
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS UIAmbiguiousSymbolDialog : public UIDialog {
public:
    virtual HWND Cancel(void);

	UIAmbiguiousSymbolDialog();
	UIAmbiguiousSymbolDialog(HWND hwnd) : UIDialog(hwnd) {
		UIAmbiguiousSymbolDialog::OnUpdate();
	}
	HWND operator=(HWND hwnd) {
		UIDialog::operator=(hwnd);
		/*UIAmbiguiousSymbolDialog::OnUpdate();*/ 
		return hwnd;
	}

	BOOL GetAmbiguities( CStringArray& ambiguities );
	BOOL GetCurrentAmbiguity( CString& symbol );
	BOOL SelectAmbiguity( CString symbol );
	BOOL SelectAmbiguity( int index );  // only needed if 
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uibrowse.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UIBROWSE.CPP
//
//  Created by :            Date :
//      WayneBr                 1/21/94
//
//  Description :
//      Implementation of the UIBrowse class
//

#include "stdafx.h"
#include "uibrowse.h"
#include "testxcpt.h"
#include "..\..\testutil.h"
#include "mstwrap.h"
#include "..\sym\cmdids.h"
#include "..\sym\vcpp32.h"
#include "guiv1.h"
#include "..\shl\uwbframe.h"
#include "..\shl\wbutil.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

static const LPCTSTR szPushPinName = "PUSHPIN";
/*
static const LPCTSTR szClassesFilterName = "&Classes";
static const LPCTSTR szFunctionsFilterName = "F&unctions";
static const LPCTSTR szDataFilterName = "D&ata";
static const LPCTSTR szMacrosFilterName = "&Macros";
static const LPCTSTR szTypesFilterName = "T&ypes";

// REVIEW (michma): need to use accelerators to get at filter buttons instead of clicking
// because we can't guarantee that the buttons will be completely visible and
// ms-test may not be able to click buttons that aren't completely visible.  it
// seems to try to click in the center of the button.
static const LPCTSTR szClassesFilterAccel = "%c";
static const LPCTSTR szFunctionsFilterAccel = "%u";
static const LPCTSTR szDataFilterAccel = "%a";
static const LPCTSTR szMacrosFilterAccel = "%m";
static const LPCTSTR szTypesFilterAccel = "%y";
*/

// Utility for filling CStringArray from clipboard.
// BEGIN_HELP_COMMENT
// Function: BOOL FillStringArrayFromClipBrd( CStringArray& lines )
// Description: Fill the given CStringArray with lines from the clipboard.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: lines A reference to a CStringArray that will contain the lines of text from the clipboard.
// END_HELP_COMMENT
static BOOL FillStringArrayFromClipBrd( CStringArray& lines ) {

	const CString CrLf( "\r\n" );
	const int cCrLf = CrLf.GetLength();

	lines.RemoveAll();

	CString strClip;

	if( GetClipText(strClip) && !strClip.IsEmpty() ) {
		while( strClip.GetLength() ) {
			CString line;

			int count = strClip.Find( CrLf );

			if( -1 != count ) {
				line = strClip.Left( count );
				strClip = strClip.Mid( count + cCrLf );
			}
			else {
				line = strClip;
				strClip = "";
			}
			lines.Add( line );
		}
	}

	return !!lines.GetSize();
}

void UIBrowse::OnUpdate(void) {
	if( HWnd() ) {
		// Look for "PUSHPIN" Button in browser window
		HWND hWndPushButton = CMSTest::WFndWndC( szPushPinName, "Button", FW_DEFAULT );
		if( hWndPushButton ) {
			if( IsChild( HWnd(), hWndPushButton ) ) {
				m_hWndPushPin = hWndPushButton;
				return;
			}
		}
	}
	m_hWndPushPin = NULL;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::IsValid(void) const
// Description: Determine if the browser window is valid by verifying the push pin control exists.
// Return: A Boolean value that indicates whether the browser window is valid. TRUE if it's valid; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIBrowse::IsValid(void) const {
	if( UIWindow::IsValid() ) {
#if 0
		// Test for unique "PUSHPIN" Button in browser window
		HWND hWndPushButton = CMSTest::WFndWndC( szPushPinName, "Button", FW_DEFAULT );
		if( hWndPushButton ) {
			return IsChild( HWnd(), hWndPushButton );
		}
#else
		if( m_hWndPushPin )
			return TRUE;
#endif
		LOG->RecordInfo( "UIBrowse::IsValid - Couldn't find 'PUSHPIN'" );
	}

	return FALSE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::Find(void)
// Description: Find the browser window and attach to it.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIBrowse::Find(void) {

	// Find unique "PUSHPIN" Button in browser window
	HWND hWndPushButton = CMSTest::WFndWndC( szPushPinName, "Button", FW_DEFAULT );
	if( hWndPushButton ) {
		return Attach( GetParent(GetParent(hWndPushButton)) );
	}
	return FALSE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::IsActive(void)
// Description: Determine if the browser window is active.
// Return: A Boolean value that indicates whether the browser is active. TRUE if it's active; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIBrowse::IsActive(void) {
    HWND hwnd = MST.WGetFocus();
    return (hwnd == HWnd()) || IsChild(HWnd(), hwnd);
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::Query(QueryType query, LPCSTR name /*NULL*/, int filters /*NONE*/)
// Description: Perform a query via the Browse dialog that results in the browser window being active.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: query A QueryType value that indicates the type of query to perform: DefRef, FileOutline, BaseClass, DerivedClass, CallGraph, CallerGraph.
// Param: name A pointer to a string that contains the name of the symbol to query on. (Default value is NULL.)
// Param: filter A bit field that specifies the type of filter to apply to the query: NONE, CLASSES, FUNCTIONS, DATA, MACROS, TYPES. (Default value is NONE.)
// END_HELP_COMMENT
BOOL UIBrowse::Query(QueryType query, LPCSTR name /*NULL*/, int filters /*NONE*/, int case_sensitive /* TRUE */) {

	// Most recent information
	m_type = query;
	m_filters = filters;
	m_name = name;

	EXPECT( UIWB.DoCommand( IDM_BROWSE_QUERY, DC_MNEMONIC ) );

	// look for error dialog
	UIDialog dlg( GetLocString(IDSS_WORKBENCH_TITLEBAR) );
	if( dlg.AttachActive() )
	{
		LOG->RecordInfo( "UIBrowse::Query - Browse operation resulted in error, e.g., File not found, etc." );
		dlg.Cancel();

		// assume file not found
		m_status = FileNotFound;
		return FALSE;
	}

    // wait for query dlg
	HWND hWndBrowseDialog;
	
	if((hWndBrowseDialog = MST.WFndWndWait(GetLocString(IDSS_TB_BROWSE), FW_NOCASE | FW_DIALOG | FW_FOCUS, 3)) == NULL)
		{
		LOG->RecordInfo( "UIBrowse::Query - query dlg did not appear within 3 seconds" );
		return FALSE;
		}

	UIWindow uiBrowseDialog;
	uiBrowseDialog.Attach( hWndBrowseDialog );

    // Enter Name (use defualt of NULL)
    if (name)
    {
        EXPECT(MST.WEditEnabled(GetLabel(VCPP32_IDC_QY_NAME)));
        MST.WEditSetText(GetLabel(VCPP32_IDC_QY_NAME), name);

    }
	else {
		LOG->RecordInfo( "UIBrowse::Query - search name is blank" );
		m_status = SymbolNotFound;
		return FALSE;
	}

    //Query
    // assumes querytypes  maps exactly to listbox !!!
    EXPECT(MST.WListEnabled(GetLabel(VCPP32_IDC_QUERY)));
    MST.WListItemClk(GetLabel(VCPP32_IDC_QUERY), (int) query);

	// set case-sensitivty.
	if(case_sensitive)
		ToggleCaseSensitivity(TOGGLE_ON);
	else
		ToggleCaseSensitivity(TOGGLE_OFF);

    //OK
    EXPECT(MST.WButtonEnabled(GetLabel(IDOK)));
    MST.WButtonClick(GetLabel(IDOK));

	// Test that browse dialog is gone
	EXPECT( uiBrowseDialog.WaitUntilGone(5000) );

	// Check for ambiguity dialog
	UIAmbiguiousSymbolDialog dlgAmb;
	if( dlgAmb.AttachActive() )
	{
		m_status = AmbiguityDialog;
		return FALSE;
	}

	// Check for not found
	if( dlg.AttachActive() )
	{
		LOG->RecordInfo( "UIBrowse::Query - Browse query resulted in error, e.g., Symbol not found, etc." );
		dlg.Cancel();

		// assume symbol not found
		m_status = SymbolNotFound;
		return FALSE;
	}

    // Wait for browse window
    // review really define UIBROWSE_CLASS
    //        #define UIBROWSE_CLASS ""
    //        m_hwndbrowser=MST.WFndWndWaitC(NULL, UIBROWSE_CLASS, FW_FOCUS, 3);
	WaitAttachActive(1000);
	EXPECT( IsValid() );
	m_status = Active;

	// assume unpinned state.
	MST.WCheckCheck( szPushPinName );

    // Set Filters
    SetFilters(query, filters);

    // set pane data
    m_pane=SYMBOL_PANE;         // assumes symbol pane is always the default focus.

    return TRUE;
}

//static void SetFilterButton(UIBrowse* pBrowse, LPCTSTR szButtonAccel, BOOL fButtonDown) 
static void SetFilterButton(UIBrowse* pBrowse, UINT nButtonID, BOOL fButtonDown) 
{
	CStringArray matches;

	CString szButtonAccel = "%";
	szButtonAccel += ExtractHotKey(GetLabel(nButtonID));

	// get the count of matches before the filter button is toggled.
	EXPECT(pBrowse->GetMatches(matches));
	int match_count_before_toggle = matches.GetSize();

	// toggle the filter button.
	MST.DoKeys(szButtonAccel);
	// wait for the browser window to be updated.
	Sleep(1000);

	// get the count of matches after the filter button is toggled.
	EXPECT(pBrowse->GetMatches(matches));
	int match_count_after_toggle = matches.GetSize();

	// if the match count before and after are equal, we can leave the filter button as is.
	// otherwise, the following table illustrates how the second expression works:
	
	// AFTER < BEFORE ?		BUTTON DOWN ?		ACTION ON BUTTON
	// TRUE					TRUE				toggle back
	// TRUE					FALSE				leave as is
	// FALSE				TRUE				leave as is
	// FALSE				FALSE				toggle back

	if((match_count_before_toggle != match_count_after_toggle) &&
	   ((match_count_after_toggle < match_count_before_toggle) == fButtonDown))
		{
		// toggle the filter button again.
		MST.DoKeys(szButtonAccel);
		// wait for the browser window to be updated.
		Sleep(1000);
		}

	return;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::SetFilters(QueryType type, int filters)
// Description: Set the filters for the given query
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: type A QueryType value that indicates the type of query to set the filters for: DefRef, FileOutline, BaseClass, DerivedClass, CallGraph, CallerGraph.
// Param: filters A bit field that specifies the type of filter to set: NONE, CLASSES, FUNCTIONS, DATA, MACROS, TYPES. (Default value is NONE.)
// END_HELP_COMMENT
BOOL UIBrowse::SetFilters(QueryType type, int filters) {  		// set filters based on current type

	if( m_status != Active ) {
		LOG->RecordInfo( "UIBrowse::SetFilters -  m_status != Active" );
		return FALSE;
	}

    EXPECT( Activate() );

    int filt = 0;   // used for temp.
    switch (type)
    {
        case FileOutline:
			if( filters == NONE )
				filters = CLASSES|FUNCTIONS|DATA|MACROS|TYPES;
			// new implementation

			SetFilterButton (this, IDM_CTL_BROWSE_TYPE, filters / TYPES);
//			SetFilterButton (this, szTypesFilterAccel, filters / TYPES);
			filt = filters % TYPES;

            SetFilterButton (this, IDM_CTL_BROWSE_MACRO, filt / MACROS);
//            SetFilterButton (this, szMacrosFilterAccel, filt / MACROS);
            filt = filt    % MACROS;

            SetFilterButton (this, IDM_CTL_BROWSE_DATA, filt / DATA);
//            SetFilterButton (this, szDataFilterAccel, filt / DATA);
            filt = filt    % DATA;

            SetFilterButton (this, IDM_CTL_BROWSE_FUNCS, filt / FUNCTIONS);
//            SetFilterButton (this, szFunctionsFilterAccel, filt / FUNCTIONS);
            filt = filt   % FUNCTIONS;

            SetFilterButton (this, IDM_CTL_BROWSE_CLASS, filt / CLASSES);
//            SetFilterButton (this, szClassesFilterAccel, filt / CLASSES);

			m_filters = filters;
            return TRUE;
            break;

        case BaseClass:
        case DerivedClass:
			if( filters == NONE )
				filters = AllFNCs|AllData;

			int i;
			CString szButtonAccel = "%";
			szButtonAccel += ExtractHotKey(GetLabel(IDM_CTL_BROWSE_DATAMEM));
			
			szButtonAccel += "{DOWN}{HOME}";

			MST.DoKeys( szButtonAccel.GetBuffer(szButtonAccel.GetLength()));
			for( i = 1; i < filters%AllData; i++ )
				MST.DoKeys( "{DOWN}" );

			szButtonAccel = "{TAB}+{TAB}%";
			szButtonAccel += ExtractHotKey(GetLabel(IDM_CTL_BROWSE_FUNCMEM));

			szButtonAccel += "{DOWN}{HOME}";

			MST.DoKeys(szButtonAccel.GetBuffer(szButtonAccel.GetLength()));
			for( i = 1; i < filters/AllData; i++ )
				MST.DoKeys( "{DOWN}" );

			// restore cursor in original pane
			MST.DoKeys( "{TAB}+{TAB}" );

			m_filters = filters;
            return TRUE;
            break;
    }
    return FALSE;
};


// BEGIN_HELP_COMMENT
// Function: int  UIBrowse::GetFilters(QueryType type)
// Description: Get the filters for the current query (of the type given).
// Return: A bit field that specifies the type of filter: NONE, CLASSES, FUNCTIONS, DATA, MACROS, TYPES.
// Param: type A QueryType value that indicates the type of query: DefRef, FileOutline, BaseClass, DerivedClass, CallGraph, CallerGraph.
// END_HELP_COMMENT
int  UIBrowse::GetFilters(QueryType type) {         		// get filters based on current type
	if( m_status != Active ) {
		LOG->RecordInfo( "UIBrowse::SetFilters -  m_status != Active" );
		return FALSE;
	}

	
    EXPECT( Activate() );

    switch (type)
    {
        case FileOutline:
            return ( (CLASSES   * IsButtonDown(GetLabel(IDM_CTL_BROWSE_CLASS)))  +  \
                     (FUNCTIONS * IsButtonDown(GetLabel(IDM_CTL_BROWSE_FUNCMEM)))+  \
                     (DATA      * IsButtonDown(GetLabel(IDM_CTL_BROWSE_DATAMEM)))     +  \
                     (MACROS    * IsButtonDown(GetLabel(IDM_CTL_BROWSE_MACRO)))   +  \
                     (TYPES     * IsButtonDown(GetLabel(IDM_CTL_BROWSE_TYPE)))      );
            break;
        case BaseClass:
        case DerivedClass:
            // {AllFNCs=1,Virtual, Static,NonVirtual, NonStatic,NSNV,NoFCNs, AllData=101,StaticData,NonStaticData,NoData};
            // assume enum exactly matches combo boxes !!!!!
            return ( MST.WComboIndex(GetLabel(VCPP32_IDC_COMBO_FUNS)) + (100*MST.WComboIndex(GetLabel(VCPP32_IDC_COMBO_DATA))));
            // attributeFilterType{NONE=0, Static = 1, NonStatic = 2, Virtual = 4, NonVirtual = 8 };
            return TRUE;
            break;
    }
    return 0;
};

// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::PopContext(void)
// Description: Perform the Pop Context browser operation.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIBrowse::PopContext(void) {
    CString Keys = "^{NUMPAD*}";
    MST.DoKeys(Keys);
    return TRUE;
};


// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::FirstDefinition(void)
// Description: Perform the Go To Definition browser operation.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIBrowse::FirstDefinition(void) {
    CString Keys = "{F11}";
    MST.DoKeys(Keys);
    return TRUE;
};

// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::NextDefinition(void)
// Description: Perform the Go To Next Definition browser operation.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIBrowse::NextDefinition(void) {
    CString Keys = "^{NUMPAD+}";
    MST.DoKeys(Keys);
    return TRUE;
};

// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::PrevDefinition(void)
// Description: Perform the Go To Previous Definition browser operation.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIBrowse::PrevDefinition(void) {
    CString Keys = "^{NUMPAD-}";
    MST.DoKeys(Keys);
    return TRUE;
};

// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::FirstReference(void)
// Description: Perform the Go To Reference browser operation.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIBrowse::FirstReference(void) {
    CString Keys = "+{F11}";
    MST.DoKeys(Keys);
    return TRUE;
};

// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::NextReference(void)
// Description: Perform the Go To Next Reference browser operation.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIBrowse::NextReference(void) {
    CString Keys = "^{NUMPAD+}";
    MST.DoKeys(Keys);
    return TRUE;
};

// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::PrevReference(void)
// Description: Perform the Go To Previous Reference browser operation.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIBrowse::PrevReference(void) {
    CString Keys = "^{NUMPAD-}";
    MST.DoKeys(Keys);
    return TRUE;
};

// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::GotoPane(PaneType pane, QueryType type)
// Description: Set focus to the specified pane in the browser window.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: pane A PaneType value that specifies which pane to set focus to: SYMBOL_PANE, MEMBER_PANE, DEFREF_PANE.
// Param: type A QueryType value that indicates the type of query: DefRef, FileOutline, BaseClass, DerivedClass, CallGraph, CallerGraph.
// END_HELP_COMMENT
BOOL UIBrowse::GotoPane(PaneType pane, QueryType type) {
    Activate();
    if ((type == BaseClass) || (type == DerivedClass))  // three panes
    {
        char buffer[10];
        CString count;
        //assumes panes SYMBOL_PANE MEMBER_PANE DEFREF_PANE numbered 1-3 respctively
        if (pane >= m_pane)
            count=itoa((pane-m_pane), buffer, 10);
        else
            count=itoa(((pane+3)-m_pane), buffer, 10);
        CString Keys = "{TAB "+count+"}";
        MST.DoKeys(Keys);
    }
    else                                                // two panes
    {
      if (m_pane != pane ) MST.DoKeys("{TAB}");
    }
  return TRUE;
};

// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::GotoDefinitionsHeading(void)
// Description: Go to the definitions heading in definitions/references pane in the browser window.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIBrowse::GotoDefinitionsHeading(void) {
    Activate();
    CString Heading=GetLocString(IDSS_BRS_DEFINITIONS);
    CString Keys = "{ENTER}";
    MST.DoKeys(Keys);
    while (GetCurrentItem()!=Heading)
          SelectNthItem(DefRef,1);
    return (GetCurrentItem()==Heading);
};

// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::GotoReferencesHeading(void)
// Description: Go to the references heading in the definitions/references pane in the browser window.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIBrowse::GotoReferencesHeading(void) {
    Activate();
    CString Heading=GetLocString(IDSS_BRS_REFERENCES);
    CString Keys = "{ENTER}";
    MST.DoKeys(Keys);
    while (GetCurrentItem()!=Heading)
          SelectNthItem(DefRef,1);
    return (GetCurrentItem()==Heading);
};

// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::ExpandCurrentItem(void)
// Description: Expand the selected item in the browser window.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIBrowse::ExpandCurrentItem(void) {
    CString Keys = "{ENTER}";
    MST.DoKeys(Keys);
    return TRUE;
};

// BEGIN_HELP_COMMENT
// Function: CString UIBrowse::GetCurrentItem(void)
// Description: Get a string that describes the currently selected item in the browser window. This function is NYI.
// Return: A CString that contains the description of the currently selected item.
// END_HELP_COMMENT
CString UIBrowse::GetCurrentItem(void) {
    Activate();
    //todo call something to get the current item !!!!!!!!!
    return "";
};

// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::Navigate(void)
// Description: Navigate from the currently selected item in the browser window to its location in the source code.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIBrowse::Navigate(void) {
    CString Keys = "{ENTER}";
    MST.DoKeys(Keys);
    return TRUE;
};

// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::SelectNthItem(QueryType type, int item)
// Description: Select the n-th item in the current pane in the browser window. Expandable nodes will be expanded by this function.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: type A QueryType value that indicates the type of query: DefRef, FileOutline, BaseClass, DerivedClass, CallGraph, CallerGraph.
// Param: item An integer that contains the 0-based index of the item to select.
// END_HELP_COMMENT
BOOL UIBrowse::SelectNthItem(QueryType type, int item) {
    Activate();
    for (int temp = 0 ; temp < item; temp++)
    {
         // only symbol pand expandable, also defref, fileoutline not expandable (goto's instaed!)
         if ((m_pane==SYMBOL_PANE) && !((type==DefRef) || (type==FileOutline)))
               ExpandCurrentItem();              //expand as we go
         CString Keys = "{DOWN}";                //move down one
         MST.DoKeys(Keys);
    }
    return TRUE;
};


// Cracks notation returned from GetNthDefinition/reference
// ie "f:\cafe\cafe\wb\cobrowse.h(33)"
// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::CrackFileLine(LPCSTR file_line,CHAR *file,int *line)
// Description: Parse the notation returned from GetNthDefinition/Reference (i.e. f:\cafe\cafe\wb\cobrowse.h(33)).
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: file_line A pointer to a string that contains the file+line string to crack.
// Param: file A pointer to a character buffer that will contain the file part of the file_line string.
// Param: line A pointer to an integer buffer that will contain the line part of the file_line string.
// END_HELP_COMMENT
BOOL UIBrowse::CrackFileLine(LPCSTR file_line,CHAR *file,int *line) {
    CString fileline=file_line;
    int start_num = fileline.ReverseFind('(');
    int end_num =   fileline.ReverseFind(')');
    
    EXPECT( start_num != -1 );
    EXPECT( end_num != -1 );

    //
    //  Number starts after '('
    //
    start_num++;
    
    EXPECT( end_num > start_num );
    
    CString szline= fileline.Mid(start_num, end_num - start_num );
    CString strfile=fileline.Left(fileline.ReverseFind('('));

    *line=atoi(szline);
    strcpy(file, strfile.GetBuffer(strfile.GetLength()));
    return TRUE;
};

// BEGIN_HELP_COMMENT
// Function: void UIBrowse::ButtonDown(const char *button)
// Description: Set the specified button to its down state.
// Return: none
// Param: button A pointer to a string that contains the name of the button.
// END_HELP_COMMENT
void UIBrowse::ButtonDown(const char *button) {
    if (!IsButtonDown(button))
        MST.WButtonClick(button);
};

// BEGIN_HELP_COMMENT
// Function: void UIBrowse::ButtonUp(const char *button)
// Description: Set the specified button to its up state.
// Return: none
// Param: button A pointer to a string that contains the name of the button.
// END_HELP_COMMENT
void UIBrowse::ButtonUp(const char *button) {
    if (IsButtonDown(button))
        MST.WButtonClick(button);
};

// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::IsButtonDown(const char *button)
// Description: Determine if the specified button is in its down state.
// Return: A Boolean value that indicates whether the button is in its down state (TRUE) or not.
// Param: button A pointer to a string that contains the name of the button.
// END_HELP_COMMENT
BOOL UIBrowse::IsButtonDown(const char *button) {

    EXPECT(MST.WButtonEnabled(button));
    //todo determine if down
    return MST.WOptionState(szPushPinName) == 1;
};

// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::CloseBrowser(void)
// Description: Close the browser window.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIBrowse::CloseBrowser(void) {
	Activate();
	// assume that button is down.
	MST.WCheckClick( szPushPinName );
	MST.DoKeys("{ESC}");
	if( !WaitUntilGone( 1000 ) ) {
		// try again
		Activate();
		MST.WButtonClick( szPushPinName );
		MST.DoKeys("{ESC}");
	}
    return TRUE;
};

// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::GetMatches( CStringArray& matches )
// Description: Get the list of symbols that match the symbol name specified in the last query from the symbols pane (the left pane) in the browser window.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: matches A CStringArray reference that will contain the list of symbols.
// END_HELP_COMMENT
BOOL UIBrowse::GetMatches( CStringArray& matches ) {
	// Assume that left pane has focus.  True if window just opened.

	matches.RemoveAll();

	if( m_status != Active ) {
		LOG->RecordInfo( "UIBrowse::GetMatches -  m_status != Active" );
		return FALSE;
	}
	EXPECT( Activate() );

	if( m_type == FileOutline || m_type == DefRef ) {
		MST.DoKeys("+(^c)");
	}
	else {
		// Only select top item for all other queries.
		MST.DoKeys("^{HOME}");
		MST.DoKeys("^c");
	}

	return FillStringArrayFromClipBrd( matches );
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::SelectMatch( CString name )
// Description: Select the specified match by name in the symbols pane (the left pane) in the browser window. (See SelectMatch(int) to select a symbol by index.)
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: name A CString that contains the name of the match to select.
// END_HELP_COMMENT
BOOL UIBrowse::SelectMatch(CString name)

	{
	CString dokeys;
	char str[8];

	int i = FindMatch(name);

	if(i > -1)
		{
		dokeys = (CString)"{HOME}{DOWN " + _itoa(i, str, 10) + "}";
		MST.DoKeys(dokeys);
		return TRUE;
		}

	LOG->RecordInfo( "UIBrowse::SelectMatch - could not find %s", name);
	return FALSE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::SelectMatch( int index )
// Description: Select the specified match by index in the symbols pane (the left pane) in the browser window. (See SelectMatch(CString) to select a symbol by name.) This function is NYI.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: index An integer that contains the 1-based index into the list of symbols.
// END_HELP_COMMENT
BOOL UIBrowse::SelectMatch( int index ) {
	LOG->RecordInfo( "UIBrowse::SelectMatch - Not Implemented" );
	return FALSE;
}


// BEGIN_HELP_COMMENT
// Function: int FindMatch(CStringArray& matches, CString name)
// Description: returns the index of the specified match in the list of matches in the symbol pane of the browser wnd.
// Return: the zero-based index of the match if successful, -1 if not successful.
// Param: name A CString that contains the name of the match to search for.
// END_HELP_COMMENT
int UIBrowse::FindMatch(CString name)

	{
	CStringArray matches;

	if(!GetMatches(matches))
		{
		LOG->RecordInfo( "UIBrowse::FindMatch - could not get matches");
		return FALSE;
		}

	for(int i = matches.GetSize() - 1; i > -1; i--)
		{
		if(matches[i] == name)
			break;
		}

	return i;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::GetMembers( CStringArray& members )
// Description: Get the list of members for the last query performed in the browser window.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: members A CStringArray reference that will contain the list of members.
// END_HELP_COMMENT
BOOL UIBrowse::GetMembers( CStringArray& members ) {

	// Assume that left pane has focus.  True if window just opened.
	members.RemoveAll();

	if( m_status != Active ) {
		LOG->RecordInfo( "UIBrowse::GetMembers -  m_status != Active" );
		return FALSE;
	}
	EXPECT( Activate() );

	if( m_type == BaseClass || m_type == DerivedClass ) {
		MST.DoKeys("{TAB}");
		MST.DoKeys("+(^c)");
		return FillStringArrayFromClipBrd( members );
	}
	else {
		LOG->RecordInfo( "UIBrowse::GetMembers - Query is not class tree" );
		return FALSE;
	}
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::SelectMember( CString member )
// Description: Select the specified member by name in the member pane (the upper right pane) in the browser window. (See SelectMember(int) to select a member by index.) This function is NYI.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: member A CString that contains the name of the member to select.
// END_HELP_COMMENT
BOOL UIBrowse::SelectMember( CString member ) {
	LOG->RecordInfo( "UIBrowse::SelectMember - Not Implemented" );
	return FALSE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::SelectMember( int index )
// Description: Select the specified member by index in the member pane (the upper right pane) in the browser window. (See SelectMember(CString) to select a member by name.) This function is NYI.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: index An integer that contains the 1-based index of the member to select.
// END_HELP_COMMENT
BOOL UIBrowse::SelectMember( int index ) {
	LOG->RecordInfo( "UIBrowse::SelectMember - Not Implemented" );
	return FALSE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::GetLocations( CStringArray& locations )
// Description: Get the list of definitions and references for the selected symbol in last query performed in the browser window.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: locations A CStringArray reference that will contain the list of defs/refs.
// END_HELP_COMMENT
BOOL UIBrowse::GetLocations( CStringArray& locations ) {

	// Assume that left pane has focus. True if window just opened.
	locations.RemoveAll();

	if( m_status != Active ) {
		LOG->RecordInfo( "UIBrowse::GetLocations -  m_status != Active" );
		return FALSE;
	}
	EXPECT( Activate() );

	if( m_type == BaseClass || m_type == DerivedClass ) {
		MST.DoKeys("{TAB 2}");
		MST.DoKeys("+(^c)");
	}
	else {
		MST.DoKeys("{TAB}");
		MST.DoKeys("+(^c)");
	}

	MST.DoKeys("{TAB}");
	return FillStringArrayFromClipBrd( locations );
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::GetFirstLevelBranches( CStringArray& branches )
// Description: Get the list of first level branches for the last query performed in the browser window.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: branches A CStringArray reference that will contain the list of first level branches.
// END_HELP_COMMENT
BOOL UIBrowse::GetFirstLevelBranches( CStringArray& branches ) {

	// Assume that left pane has focus. True if window just opened.
	branches.RemoveAll();

	if( m_status != Active ) {
		LOG->RecordInfo( "UIBrowse::GetFirstLevelBranches -  m_status != Active" );
		return FALSE;
	}
	EXPECT( Activate() );

	if( m_type == FileOutline || m_type == DefRef ) {
		LOG->RecordInfo( "UIBrowse::GetFirstLevelBranches -  Not for file outline or def & ref queries" );
		return FALSE;
	}
	else {
		// toggle top item and get branches, if none, toggle again and get branches
		//		This makes sure that only one level of branches appear
		MST.DoKeys("^{HOME}{ENTER}");
		MST.DoKeys("+(^c)");
		if( FillStringArrayFromClipBrd( branches ) ) {
			if( branches.GetSize() == 1 ) {
				// toggle
				MST.DoKeys("{ENTER}");
				MST.DoKeys("+(^c)");
				// worked once, expect it to work again
				EXPECT( FillStringArrayFromClipBrd( branches ) );
			}
			if( branches.GetSize() > 0 ) {
				// remove parent, then tabs in front of children
				branches.RemoveAt( 0 );
				for( int index=0; index < branches.GetSize(); index++ ) {
					EXPECT( branches[index][0] == '\t' );
					branches[index] = branches[index].Mid( 1 );
				}
				return TRUE;
			}
		}
		return FALSE;
	}

	return FillStringArrayFromClipBrd( branches );
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::SelectDefinition( CString definition )
// Description: Select the specified definition by name in the definitions/references pane (the lower right pane) in the browser window. (See SelectDefinition(int) to select a definition by index.) This function is NYI.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: definition A CString that contains the name of the definition to select.
// END_HELP_COMMENT
BOOL UIBrowse::SelectDefinition( CString definition ) {
	LOG->RecordInfo( "UIBrowse::SelectDefinition - Not Implemented" );
	return FALSE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::SelectDefinition( int index )
// Description: Select the specified definition by index in the definitions/references pane (the lower right pane) in the browser window. (See SelectDefinition(CString) to select a definition by name.) This function is NYI.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: index An integer that contains the 1-based index of the definition to select.
// END_HELP_COMMENT
BOOL UIBrowse::SelectDefinition( int index ) {
	LOG->RecordInfo( "UIBrowse::SelectDefinition - Not Implemented" );
	return FALSE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::SelectReference( CString reference )
// Description: Select the specified reference by name in the definitions/references pane (the lower right pane) in the browser window. (See SelectReference(int) to select a reference by index.) This function is NYI.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: reference A CString that contains the name of the reference to select.
// END_HELP_COMMENT
BOOL UIBrowse::SelectReference( CString reference ) {
	LOG->RecordInfo( "UIBrowse::SelectReference - Not Implemented" );
	return FALSE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::SelectReference( int index )
// Description: Select the specified reference by index in the definitions/references pane (the lower right pane) in the browser window. (See SelectReference(CString) to select a reference by name.) This function is NYI.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: index An integer that contains the 1-based index of the reference to select.
// END_HELP_COMMENT
BOOL UIBrowse::SelectReference( int index ) {
	LOG->RecordInfo( "UIBrowse::SelectReference - Not Implemented" );
	return FALSE;
}


//
// UIBrowse interface to ambiguity dialog
//
// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::GetAmbiguities( CStringArray& ambiguities )
// Description: Get the list of ambiguities from the Resolve Ambiguities dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: ambiguities A reference to a CStringArray that will contain the list of ambiguities.
// END_HELP_COMMENT
BOOL UIBrowse::GetAmbiguities( CStringArray& ambiguities ) {
	if( m_status != AmbiguityDialog ) {
		LOG->RecordInfo( "UIBrowse::GetAmbiguities -  m_status != AmbiguityDialog" );
		return FALSE;
	}

	UIAmbiguiousSymbolDialog dlgAmb;
	EXPECT( dlgAmb.AttachActive() );
	return dlgAmb.GetAmbiguities( ambiguities );
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::GetCurrentAmbiguity( CString& symbol )
// Description: Get the currently selected ambiguity from the Resolve Ambiguities dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: symbol A reference to a CString that will contain the name of the currently selected ambiguity.
// END_HELP_COMMENT
BOOL UIBrowse::GetCurrentAmbiguity( CString& symbol ) {
	if( m_status != AmbiguityDialog ) {
		LOG->RecordInfo( "UIBrowse::GetCurrentAmbiguity -  m_status != AmbiguityDialog" );
		return FALSE;
	}

	UIAmbiguiousSymbolDialog dlgAmb;
	EXPECT( dlgAmb.AttachActive() );
	return dlgAmb.GetCurrentAmbiguity( symbol );
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::SelectAmbiguity( CString symbol )
// Description: Select the specified ambiguity by name in the Resolve Ambiguities dialog. (See SelectAmbiguity(int) to select an ambiguity by index.)
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: symbol A CString that contains the name of the ambiguity to select.
// END_HELP_COMMENT
BOOL UIBrowse::SelectAmbiguity( CString symbol ) {
	if( m_status != AmbiguityDialog ) {
		LOG->RecordInfo( "UIBrowse::SelectAmbiguity -  m_status != AmbiguityDialog" );
		m_status = NotActive;
		return FALSE;
	}

	UIAmbiguiousSymbolDialog dlgAmb;
	EXPECT( dlgAmb.AttachActive() );

	if( dlgAmb.SelectAmbiguity( symbol ) ) {
		AttachActive();
		m_status = Active;
		return TRUE;
	}
	else {
		dlgAmb.Cancel();
		m_status = NotActive;
		return FALSE;
	}
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::SelectAmbiguity( int index )
// Description: Select the specified ambiguity by index in the Resolve Ambiguities dialog. (See SelectAmbiguity(CString) to select an ambiguity by name.)
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: index An integer that contains the 1-based index of the ambiguity to select.
// END_HELP_COMMENT
BOOL UIBrowse::SelectAmbiguity( int index ) {
	if( m_status != AmbiguityDialog ) {
		LOG->RecordInfo( "UIBrowse::SelectAmbiguity -  m_status != AmbiguityDialog" );
		return FALSE;
	}

	UIAmbiguiousSymbolDialog dlgAmb;
	EXPECT( dlgAmb.AttachActive() );

	if( dlgAmb.SelectAmbiguity( index ) ) {
		AttachActive();
		m_status = Active;
		return TRUE;
	}
	else {
		dlgAmb.Cancel();
		m_status = NotActive;
		return FALSE;
	}
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIBrowse::CancelAmbiguity()
// Description: Cancel the query by cancelling the Resolve Ambiguities dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIBrowse::CancelAmbiguity() {
	if( m_status != AmbiguityDialog ) {
		LOG->RecordInfo( "UIBrowse::CancelAmbiguity -  m_status != AmbiguityDialog" );
		return FALSE;
	}

	UIAmbiguiousSymbolDialog dlgAmb;
	EXPECT( dlgAmb.AttachActive() );

	return dlgAmb.Cancel() == NULL;
}

UIAmbiguiousSymbolDialog::UIAmbiguiousSymbolDialog() : 
	UIDialog( GetLocString( IDSS_RESOLVE_AMBIGUITY_TITLE ) ) {
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIAmbiguiousSymbolDialog::GetAmbiguities( CStringArray& ambiguities )
// Description: Get the list of ambiguities from the Resolve Ambiguities dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: ambiguities A reference to a CStringArray that will contain the list of ambiguities.
// END_HELP_COMMENT
BOOL UIAmbiguiousSymbolDialog::GetAmbiguities( CStringArray& ambiguities ) {

	// Clear CStringArray
	ambiguities.RemoveAll();

	EXPECT( IsValid() );

	// Make sure dialog exists and symbol listbox has focus.
	int cListCount = MST.WListCount( GetLabel( VCPP32_ID_AMB_LIST ) );

	if( cListCount < 0 ) { // Should check for -1 but any negative number is bad
		LOG->RecordInfo( "UIAmbiguiousSymbolDialog::GetAmbiguities - Couldn't find listbox" );
		return FALSE;
	}
	else if( cListCount < 2 ) {
		LOG->RecordInfo( "UIAmbiguiousSymbolDialog::GetAmbiguities - Count == %d doesn't make sense", cListCount );
	}

	for ( int i = 0; i < cListCount; i++ ) {
		CString item;
		CMSTest::WListItemText( GetLabel( VCPP32_ID_AMB_LIST ), i+1, item );
		ambiguities.Add( item );
	}

	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIAmbiguiousSymbolDialog::GetCurrentAmbiguity( CString& symbol )
// Description: Get the currently selected ambiguity from the Resolve Ambiguities dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: symbol A reference to a CString that will contain the name of the currently selected ambiguity.
// END_HELP_COMMENT
BOOL UIAmbiguiousSymbolDialog::GetCurrentAmbiguity( CString& symbol ) {
	EXPECT( IsValid() );
	CMSTest::WListText( GetLabel( VCPP32_ID_AMB_LIST ), symbol );
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIAmbiguiousSymbolDialog::SelectAmbiguity( CString symbol )
// Description: Select the specified ambiguity by name in the Resolve Ambiguities dialog. (See SelectAmbiguity(int) to select an ambiguity by index.)
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: symbol A CString that contains the name of the ambiguity to select.
// END_HELP_COMMENT
BOOL UIAmbiguiousSymbolDialog::SelectAmbiguity( CString symbol ) {
	EXPECT( IsValid() );
	CMSTest::WListItemDblClk( GetLabel( VCPP32_ID_AMB_LIST ), symbol );
	return WaitUntilGone( 3000 );
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIAmbiguiousSymbolDialog::SelectAmbiguity( int index )
// Description: Select the specified ambiguity by index in the Resolve Ambiguities dialog. (See SelectAmbiguity(CString) to select an ambiguity by name.)
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: index An integer that contains the 1-based index of the ambiguity to select.
// END_HELP_COMMENT
BOOL UIAmbiguiousSymbolDialog::SelectAmbiguity( int index ) {
	EXPECT( IsValid() );
	CMSTest::WListItemDblClk( GetLabel( VCPP32_ID_AMB_LIST ), index+1 );
	return WaitUntilGone( 3000 );
}



// BEGIN_HELP_COMMENT
// Function: HWND UIAmbiguiousSymbolDialog::Cancel(void)
// Description: Close the Resolve Ambiguities dialog by clicking the Cancel button.
// Return: NULL if successful; the HWND of any remaining messsage or dialog box otherwise.
// END_HELP_COMMENT
HWND UIAmbiguiousSymbolDialog::Cancel(void)
{
	ExpectValid();

	MST.WButtonClick(GetLabel(VCPP32_ID_AMB_CANCEL));
	if( WaitUntilGone(1000) )
		return NULL;		// NULL means all is well
	else
		return MST.WGetActWnd(0);	// an HWND presumes some alert came up
}


// BEGIN_HELP_COMMENT
// Function: BOOL ToggleCaseSensitivity(TOGGLE_TYPE t)
// Description: Toggle the case-sensitivity of browser queries.
// Param: t an enum type with value TOGGLE_OFF or TOGGLE_ON.
// Return: TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIBrowse::ToggleCaseSensitivity(TOGGLE_TYPE t)
	
	{
	if(t)
		MST.WCheckCheck("@1");
	else
		MST.WCheckUnCheck("@1");

	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uicp.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UICP.CPP
//
//  Created by :            Date :
//      WayneBr             1/14/94
//
//  Description :
//      Implementation of the UICoProcessor class
//

#include "stdafx.h"
#include "uicp.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\shl\uwbframe.h"
#include "..\sym\reg.h"
#include "..\sym\qcqp.h"


#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


// BEGIN_HELP_COMMENT
// Function: CString UICoProcessor::GetCPRegister(int reg)
// Description: Get the value of one of the coprocessor's registers.
// Return: A CString that contains the value of the specified coprocessor's register.
// Param: reg An integer that specifies the 1-based index into the set of coprocessor registers.
// END_HELP_COMMENT
CString  UICoProcessor::GetCPRegister(int reg)
	{
	ASSERT(reg <= MaxReg);
	char buffer[10];
	CString count=itoa(reg+REG_OFFSET,buffer,10);
	CString Keys = "^{HOME}{TAB "+count+"}+{END}^(c)";
	MST.DoKeys(Keys);
	CString cstr;
	GetClipText(cstr);
	return cstr;
	};

// BEGIN_HELP_COMMENT
// Function: BOOL UICoProcessor::SetCPRegister(int reg, LPCSTR value)
// Description: Set the value of one of the coprocessor's registers.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: reg An integer that specifies the 1-based index into the set of coprocessor registers.
// Param: value A pointer to a string that contains the value to set the specified register to.
// END_HELP_COMMENT
BOOL UICoProcessor::SetCPRegister(int reg, LPCSTR value)
	{
	ASSERT(reg <= MaxReg);
	char buffer[10];
	CString count=itoa(reg+REG_OFFSET,buffer,10);
	CString Keys = "^{HOME}{TAB "+count+"}";
	MST.DoKeys(Keys);
	// call func that excapes the dokeys controls chars use TRUE flag
	MST.DoKeys(value,TRUE);
	return TRUE;
	};

// BEGIN_HELP_COMMENT
// Function: BOOL UICoProcessor::IsValid(void) const
// Description: Determine if the register's window is valid by checking that the HWND is valid and is a toolbar HWND.
// Return: A Boolean value that indicates whether the register's window is valid. TRUE if it's valid; FALSE otherwise.
// END_HELP_COMMENT
BOOL UICoProcessor::IsValid(void) const
	{
	int pkgId ;
	switch(GetID())
	{
	case 0:
		pkgId = 0 ;
		break ;
	case IDDW_PROJECT:
		pkgId = PACKAGE_VPROJ ;
		break;
	case IDW_LOCALS_WIN: 
		pkgId = PACKAGE_VCPP ;
		break ;
	default:
		break;
	}
	return UIWindow::IsValid() && (HWnd() == UIWB.GetToolbar(GetID(),pkgId));
	}

// BEGIN_HELP_COMMENT
// Function: BOOL UICoProcessor::AttachActive(void)
// Description: Attach to the registers window if it's the active window.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UICoProcessor::AttachActive(void)
	{
	int pkgId ;
	switch(GetID())
	{
	case 0:
		pkgId = 0 ;
		break ;
	case IDDW_PROJECT:
		pkgId = PACKAGE_VPROJ ;
		break;
	case IDW_LOCALS_WIN: 
		pkgId = PACKAGE_VCPP ;
		break ;
	default:
		break;
	}

	HWND hwndFocus = MST.WGetFocus();
	HWND hwndDock = UIWB.GetToolbar(GetID(),pkgId);
	if( (hwndFocus == hwndDock) || (::IsChild(hwndDock, hwndFocus)) )
		return Attach(hwndDock);
	else
		return Attach(hwndFocus);		// will return FALSE, but the HWnd() will still point to something.
	}

// BEGIN_HELP_COMMENT
// Function: BOOL UICoProcessor::Find(void)
// Description: Find the registers window and attach to it
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UICoProcessor::Find(void)
	{
	int pkgId ;
	if (! GetID())
		 pkgId = 0 ;
	else
		pkgId = PACKAGE_VPROJ ;

	return Attach(UIWB.GetToolbar(GetID(),pkgId));
	}

// BEGIN_HELP_COMMENT
// Function: BOOL UICoProcessor::IsActive(void)
// Description: Determine if the registers window is active.
// Return: A Boolean value that indicates whether the register's window is active (TRUE) or not.
// END_HELP_COMMENT
BOOL UICoProcessor::IsActive(void)
	{
	HWND hwnd = MST.WGetFocus();
	return (hwnd == HWnd()) || IsChild(HWnd(), hwnd);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uidam.cpp ===
//////////////////////////// ///////////////////////////////////////////////////
//  UIDAM.CPP
//
//  Created by :            Date :
//      WayneBr                 1/14/94
//
//  Description :
//      Implementation of the UIDAM class
//

#include "stdafx.h"
#include "uidam.h"

#include "..\SYM\cmdids.h"
#include "..\SYM\reg.h"
#include "..\..\testutil.h"
#include "..\SHL\uwbframe.h"
#include "..\SRC\cosource.h"

#include "guitarg.h"

#include <mstwrap.h>

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: BOOL UIDAM::GotoSymbol(LPCSTR symbol)
// Description: Go to the specified symbol in the disassembly window.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: symbol A pointer to a string that contains the name of the symbol to go to.
// Param: bCloseAfter A Boolean value that indicates if dialog should be closed after the command was implemented (TRUE).
// END_HELP_COMMENT
BOOL UIDAM::GotoSymbol(LPCSTR symbol, BOOL bCloseAfter /* TRUE */)
	{
		COSource src;

// REVIEW(briancr): this is obsolete code	
//	return UIWB.GoToLine(symbol);
		return src.GoToLine(symbol, bCloseAfter);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL UIDAM::GotoAddress(int address)
// Description: Go to the specified address in the disassembly window.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: address An integer that contains the address to go to.
// Param: bCloseAfter A Boolean value that indicates if dialog should be closed after the command was implemented (TRUE).
// END_HELP_COMMENT
BOOL UIDAM::GotoAddress(int address, BOOL bCloseAfter /* TRUE */)
	{
		COSource src;

// REVIEW(briancr): this is obsolete code
//	return UIWB.GoToLine(address);
		return src.GoToLine(address, bCloseAfter);
	}

// BEGIN_HELP_COMMENT
// Function: CString UIDAM::GetInstruction(int offset /* 0 */, int range /* 1 */)
// Description: Get the instruction(s) at the current location in the diassembly window.
// Return: A CString that contains the instructions in the range specified.
// Param: offset An integer that contains the offset (in lines) from the current cursor position to start retrieving instructions from. This value is negative to move up in the window (down in memory). (Default value is 0.)
// Param: range An integer that contains the number of instructions to retrieve (also in lines). (Default value is 1.)
// Param: bLocateCaretAtLeftTop A Boolean value that indicates if the caret should be moved to the left top corner of the DAM window before offset
// END_HELP_COMMENT
CString UIDAM::GetInstruction(int offset /* 0 */, int range /* 1 */, BOOL bLocateCaretAtLeftTop)
	{
	int i;

	::WaitForInputIdle(g_hTargetProc,5000);

	if(bLocateCaretAtLeftTop)
		MST.DoKeys("^{HOME}");

	if( offset < 0 )
		for( i = offset; i < 0; i++ )
			MST.DoKeys( "{UP}" );
	else
		for( i = 0; i < offset; i++ )
			MST.DoKeys( "{DOWN}" );

	MST.DoKeys("{HOME}+({END})");

	ASSERT( range>0 );
	for( i=0; i < range-1; i++ )
		MST.DoKeys("+{DOWN}" );
	MST.DoKeys("^(c)");

	CString cstr;
	GetClipText(cstr);
	
	// We should return to the original position, otherwise next call of this function will give incorrect result
	for( i=0; i < range-1; i++ )
		MST.DoKeys("{UP}" );

	if( offset < 0 )
		for( i = offset; i < 0; i++ )
			MST.DoKeys( "{DOWN}" );
	else
		for( i = 0; i < offset; i++ )
			MST.DoKeys( "{UP}" );


	return cstr;
	}

// BEGIN_HELP_COMMENT
// Function: BOOL UIDAM::IsValid(void) const
// Description: Determine if the disassembly window is a valid window.
// Return: A Boolean that indicates whether the diassembly window is valid (TRUE) or not.
// END_HELP_COMMENT
BOOL UIDAM::IsValid(void) const
	{
	return UIWindow::IsValid();
	}

// BEGIN_HELP_COMMENT
// Function: BOOL UIDAM::AttachActive(void)
// Description: Attach to the disassembly window if it's the active window.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIDAM::AttachActive(void)
	{
	HWND hwnd;

    if(hwnd = MST.WFndWndWait(GetLocString(IDSS_ASM_WND_TITLE), FW_FULL, 2))
		return Attach(hwnd);
	else
		return Attach(FindFirstChild(UIWB.HWnd(), IDW_DISASSY_WIN));
	}

// BEGIN_HELP_COMMENT
// Function: BOOL UIDAM::Find(void)
// Description: Find the disassembly window and attach to it
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIDAM::Find(void)
	{
	int pkgId ;
	switch(GetID())
	{
	case 0:
		pkgId = 0 ;
		break ;
	case IDDW_PROJECT:
		pkgId = PACKAGE_VPROJ ;
		break;
	case IDW_LOCALS_WIN: 
		pkgId = PACKAGE_VCPP ;
		break ;
	default:
		break;
	}
	return Attach(UIWB.GetToolbar(GetID(),pkgId));
	}

// BEGIN_HELP_COMMENT
// Function: BOOL UIDAM::IsActive(void)
// Description: Determine if the disassembly window is active.
// Return: A Boolean value that indicates whether the disassembly window is active (TRUE) or not.
// END_HELP_COMMENT
BOOL UIDAM::IsActive(void)
	{
	HWND hwnd = MST.WGetFocus();
	return (hwnd == HWnd()) || IsChild(HWnd(), hwnd);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL UIDAM::Activate(void)
// Description: Bring up the disassembly window.
// Return: A Boolean value that indicates whether the disassembly window is active (TRUE) or not.
// END_HELP_COMMENT
BOOL UIDAM::Activate(void)
{
	UIWB.DoCommand(IDM_VIEW_ASM, DC_MNEMONIC);

//REVIEW(chriskoz) Find symbols dialog handling moved to CTarget
	::Sleep(1000); //we must wait at least 1 second because IDE does idle before openning the dialog
	::WaitForInputIdle(g_hTargetProc,5000);	//works if openning the Find Symbol dlg last a little bit

	return AttachActive();
}


//////////////////////////////////////////////////////////////////////////////////////////

// BEGIN_HELP_COMMENT
// Function: BOOL UIDAM::SwitchBetweenASMAndSRC(BOOL bUsingContextMenu)
// Description: Switches from Source window to DAM and back
// Return: A Boolean value which is currenly always TRUE
// Param: bUsingContextMenu A Boolean value that indicates if the context menu should be used to switch.  If FALSE, hot key is used.
// END_HELP_COMMENT
BOOL UIDAM::SwitchBetweenASMAndSRC(BOOL bUsingContextMenu)
{

	if(!bUsingContextMenu)
	{
		MST.DoKeys("^({F7})");
		return TRUE;
	}
	else
	{
	// Bring up the popup context menu
	MST.DoKeys("+({F10})");
	//Go to the menu item
	if(IsActive())
		MST.DoKeys("{DOWN 1}");
	else
		MST.DoKeys("{DOWN 11}");

	// Toggle it
	MST.DoKeys("{ENTER}");

		return TRUE;
	}
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIDAM::EnableDockingView(BOOL bEnable)
// Description: Enables or disables the Docking View for DAM window
// Param: bEnable If the parameter is TRUE, Docking View will be enabled. If FALSE - disabled.
// Return: A Boolean value that indicates whether the toggle operatin was sucessfull (TRUE) or not.
// END_HELP_COMMENT

BOOL UIDAM::EnableDockingView(BOOL bEnable)
{
	Activate();

	if(!IsActive())
		{
		LOG->RecordInfo("ERROR in UIDAM::EnableDockingView(): DAM window not active");
		return FALSE;
		}

	if((IsDockingViewEnabled() && bEnable) || (!IsDockingViewEnabled() && !bEnable))
		return TRUE;

	// Bring up the popup context menu
	MST.DoKeys("+({F10})");

	//Go to the "Docking view" menu item
	MST.DoKeys("{DOWN 9}");

	// Toggle it
	MST.DoKeys("{ENTER}");

	// Check that the edit control exists
	if((IsDockingViewEnabled() && bEnable) || (!IsDockingViewEnabled() && !bEnable))
		return TRUE;
	else 
		return FALSE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIDAM::IsDockingViewEnabled(BOOL bEnable)
// Description: Check if Docking View is enabled for DAM window
// Param: No Params
// Return: A Boolean value that indicates whether Docking View is enabled (TRUE) or not.
// END_HELP_COMMENT

BOOL UIDAM::IsDockingViewEnabled(void)
{
	UIWBFrame uiwbframe;
	BOOL bResult, bInitiallyMaximized;
	CString csTitle;

	Activate();

	if(!IsActive())
		{
		LOG->RecordInfo("ERROR in UIDAM::IsDockingViewEnabled(): Disassembly window not active");
		return FALSE;
		}

	HWND hwnd = HWnd();

	// Compiler gives the error that WIsMaximized is not a member of MSTest, so we use standard Windows function
	//if(MST.WIsMaximized(hwnd))
	if(IsZoomed(hwnd))
		bInitiallyMaximized = TRUE;
	else 
	{
		bInitiallyMaximized = FALSE;
		// MSTest.WMaxWnd doesn't work here for some reason, so we use standard Windows function
		// MST.WMaxWnd(hwnd);
		ShowWindow(hwnd, SW_MAXIMIZE);
	}

	MST.WGetText(uiwbframe.HWnd(), csTitle);
	if(-1 == csTitle.Find("["+ GetLocString(IDSS_ASM_WND_TITLE)+"]"))
		bResult = TRUE;
	else
		bResult = FALSE;


	if(!bInitiallyMaximized)
		// Compiler gives the error that WResWnd is not a member of MSTest, so we use standard Windows function
		//MST.WResWnd(hwnd);
		ShowWindow(hwnd, SW_RESTORE);

	return bResult;

}

// BEGIN_HELP_COMMENT
// Function: BOOL UIDAM::ChooseContextMenuItem(DAM_MENU_ITEM DamMenuItem)
// Description: Choses (toggles) one of the following DAM context menu items
// Param: DamMenuItem One of the following menu items to be chosen (toggled)
// GO_TO_SOURCE, SHOW_NEX_STATEMENT, INSERT_REMOVE_BREAK_POINT, TOGGLE_BREAKPOINT, RUN_TO_CURSOR,
// SET_NEXT_STATEMENT, SOURCE_ANNOTATION, CODE_BYTES, DOCKING_VIEW, CLOSE_HIDE
// Return: A Boolean value that indicates whether the toggle operatin was sucessfull (TRUE) or not.
// END_HELP_COMMENT

BOOL UIDAM::ChooseContextMenuItem(DAM_MENU_ITEM DamMenuItem)
{
	Activate();

	if(!IsActive())
		{
		LOG->RecordInfo("UIDAM::ChooseContextMenuItem(): Disassembly window not active");
		return FALSE;
		}

	// Bring up the popup context menu
	MST.DoKeys("+({F10})");
	//Go to the desired menu item

	switch(DamMenuItem) 
	{
		case GO_TO_SOURCE:
		MST.DoKeys("{DOWN 1}");
		break;

		case SHOW_NEX_STATEMENT:
		MST.DoKeys("{DOWN 2}");
		break;

		case INSERT_REMOVE_BREAK_POINT:
		MST.DoKeys("{DOWN 3}");
		break;

		case TOGGLE_BREAKPOINT:
		MST.DoKeys("{DOWN 4}");
		break;

		case RUN_TO_CURSOR:
		MST.DoKeys("{DOWN 5}");
		break;

		case SET_NEXT_STATEMENT:
		MST.DoKeys("{DOWN 6}");
		break;

		case SOURCE_ANNOTATION:
		MST.DoKeys("{DOWN 7}");
		break;

		case CODE_BYTES:
		MST.DoKeys("{DOWN 8}");
		break;

		case DOCKING_VIEW:
		MST.DoKeys("{DOWN 9}");
		break;

		case CLOSE_HIDE:
		MST.DoKeys("{DOWN 10}");
		break;

	}

	// Toggle it
	MST.DoKeys("{ENTER}");

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uidam.h ===
///////////////////////////////////////////////////////////////////////////////
//  UIDAM.H
//
//  Created by :            Date :
//      WayneBr             1/14/94
//
//  Description :
//      Declaration of the UIDAM class
//

#ifndef __UIDAM_H__
#define __UIDAM_H__

#include "dbgxprt.h"

#include "..\SYM\qcqp.h"
#include "..\SHL\udockwnd.h"

#ifndef __UIDOCKWND_H__
	#error include 'udockwnd.h' before including this file
#endif

enum DAM_MENU_ITEM{
	GO_TO_SOURCE,	
	SHOW_NEX_STATEMENT,
	INSERT_REMOVE_BREAK_POINT,
	TOGGLE_BREAKPOINT,
	RUN_TO_CURSOR,
	SET_NEXT_STATEMENT,
	SOURCE_ANNOTATION,
	CODE_BYTES,
	DOCKING_VIEW,
	CLOSE_HIDE
} ;


///////////////////////////////////////////////////////////////////////////////
//  UIDAM class

// BEGIN_CLASS_HELP
// ClassName: UIDAM
// BaseClass: UIDockWindow
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS UIDAM : public UIDockWindow
	{
	UIWND_COPY_CTOR(UIDAM, UIDockWindow);

	virtual BOOL Activate(void);
	virtual UINT GetID(void) const
		{	return IDW_DISASSY_WIN; }

	virtual BOOL AttachActive(void);
	virtual BOOL Find(void);

	// Initialization
	public:

	// Data
	private:
		int m_option;

	// UIWindow overrides
	public:
		virtual BOOL IsValid(void) const;
		virtual BOOL IsActive(void);	// derived classes must provide their own Activate (usually a DoCommand)


	// Utilities
	public:
		BOOL GotoSymbol(LPCSTR symbol, BOOL bCloseAfter = TRUE);
		BOOL GotoAddress(int address, BOOL bCloseAfter = TRUE);
		CString GetInstruction(int offset=0,int range=1, BOOL bLocateCaretAtLeftTop = FALSE);
		BOOL SwitchBetweenASMAndSRC(BOOL bUsingContextMenu = FALSE);
		BOOL EnableDockingView(BOOL bEnable);
		BOOL IsDockingViewEnabled(void);
		BOOL ChooseContextMenuItem(DAM_MENU_ITEM DamMenuItem);

		
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uidebug.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UIDEBUG.CPP
//
//  Created by :            Date :
//      BrianCr             01/17/95
//
//  Description :
//      Implementation of the UIDebug class
//

#include "stdafx.h"
#include "uidebug.h"
#include "mstwrap.h"
#include "..\sym\qcqp.h"
#include "..\shl\uioutput.h"
#include "uiwatch.h"
#include "uireg.h"
#include "uilocals.h"
#include "uistack.h"
#include "uimem.h"
#include "uidam.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: BOOL UIDebug::ShowDockWindow(UINT id, BOOL bShow /*=TRUE*/)
// Description: Open the docking window with the given id.
// Return: The HWND of the opened window. NULL if the function fails.
// Param: id The id of the docking window to open (IDW_OUTPUT_WIN, IDW_WATCH_WIN, IDW_LOCALS_WIN, IDW_CPU_WIN, IDW_MEMORY_WIN, IDW_CALLS_WIN, IDW_DISASSY_WIN).
// Param: bShow TRUE to show the window; FALSE to hide it (default is TRUE).
// END_HELP_COMMENT
HWND UIDebug::ShowDockWindow(UINT id, BOOL bShow /*=TRUE*/)
{
	UIDockWindow* pudw;
	switch( id )
	{
		case IDW_OUTPUT_WIN:
			pudw = new UIOutput;
			break;
		case IDW_WATCH_WIN:
			pudw = new UIWatch;
			break;
		case IDW_LOCALS_WIN:
			pudw = new UILocals;
			break;
		case IDW_CPU_WIN:
			pudw = new UIRegisters;
			break;
		case IDW_MEMORY_WIN:
			pudw = new UIMemory;
			break;
		case IDW_CALLS_WIN:
			pudw = new UIStack;
			break;
		case IDW_DISASSY_WIN:
			pudw = new UIDAM;
			break;
		default:
			ASSERT(FALSE);		// never heard of that ID
			return NULL;
	}
	BOOL b = pudw->Activate();
	delete pudw;
	if( !b )					// attempt to show failed - who knows why
		return NULL;
	if( bShow )					// window was activated and has the focus
		return MST.WGetFocus();
	MST.DoKeys("+{escape}");		// shift escape hides the active docking-window/toolbar
	return NULL;				// should we return newly active window?
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uidebug.h ===
///////////////////////////////////////////////////////////////////////////////
//  UIDEBUG.H
//
//  Created by :            Date :
//      BrianCr             1/17/95
//  Description :
//      Declaration of the UIDebug class
//

#ifndef __UIDEBUG_H__
#define __UIDEBUG_H__

#include "dbgxprt.h"

///////////////////////////////////////////////////////////////////////////////
//  UIDebug class

// BEGIN_CLASS_HELP
// ClassName: UIDebug
// BaseClass: None
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS UIDebug
{
public:
	// this function is static to make porting easier: UIWB.ShowDockWindow becomes UIDebug::ShowDockWindow
	static HWND UIDebug::ShowDockWindow(UINT id, BOOL bShow = TRUE);
};

#endif //__UIDEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uieewnd.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UIEEWND.CPP
//
//  Created by :            Date :
//      MichMa              	10/20/94
//
//  Description :
//      Implementation of the UIEEWindow class
//

#include "stdafx.h"
#include "uieewnd.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


// BEGIN_HELP_COMMENT
// Function: int UIEEWindow::GetState(int row /* ROW_CURRENT */)
// Description: Get the state of the expression at the specified row in the expression evaluator window.
// Return: A bit field that specifies the state of the expression: NOT_EXPANDABLE, EXPANDED, COLLAPSED.
// Param: row An integer that specifies the 1-based row of the EE window. Use ROW_CURRENT to specify the current row; ROW_BOTTOM to specify the last row; and ROW_ALL to specify all rows. (Default value is ROW_CURRENT.)
// END_HELP_COMMENT
int UIEEWindow::GetState(int row /* ROW_CURRENT */)
	{
	EXPR_INFO expr_info;
	GetAllFields(&expr_info, row, 1, METHOD_WND_SEL);
	return expr_info.state;
	}


// BEGIN_HELP_COMMENT
// Function: CString UIEEWindow::GetType(int row /* ROW_CURRENT */)
// Description: Get the type of the expression at the specified row in the expression evaluator window.
// Return: A CString that contains a description of the type of the expression.
// Param: row An integer that specifies the 1-based row of the EE window. Use ROW_CURRENT to specify the current row; ROW_BOTTOM to specify the last row; and ROW_ALL to specify all rows. (Default value is ROW_CURRENT.)
// END_HELP_COMMENT
CString UIEEWindow::GetType(int row /* ROW_CURRENT */)
	{
	EXPR_INFO expr_info;
	GetAllFields(&expr_info, row, 1, METHOD_PROP_PAGE);
	return expr_info.type;
	}

/*
// BEGIN_HELP_COMMENT
// Function: CString UIEEWindow::GetName(int row / ROW_CURRENT /)
// Description: Get the name of the expression at the specified row in the expression evaluator window.
// Return: A CString that contains the name of the expression.
// Param: row An integer that specifies the 1-based row of the EE window. Use ROW_CURRENT to specify the current row; ROW_BOTTOM to specify the last row; and ROW_ALL to specify all rows. (Default value is ROW_CURRENT.)
// END_HELP_COMMENT
CString UIEEWindow::GetName(int row / ROW_CURRENT /)
	{
	EXPR_INFO expr_info;
	GetAllFields(&expr_info, row, 1, METHOD_WND_SEL);
	return expr_info.name;
	}
*/
// BEGIN_HELP_COMMENT
// Function: CString UIEEWindow::GetName(int row /* ROW_CURRENT */, EE_METHOD_TYPE method /* METHOD_WND_SEL */)
// Description: Get the name of the expression at the specified row in the expression evaluator window.
// Return: A CString that contains the name of the expression.
// Param: row An integer that specifies the 1-based row of the EE window. Use ROW_CURRENT to specify the current row; ROW_BOTTOM to specify the last row; and ROW_ALL to specify all rows. (Default value is ROW_CURRENT.)
// Param: method An EE_METHOD_TYPE value that specifies the method to use when retrieving the data (METHOD_WND_SEL or METHOD_PROP_PAGE).
// END_HELP_COMMENT
CString UIEEWindow::GetName(int row /* ROW_CURRENT */, EE_METHOD_TYPE method /* METHOD_WND_SEL */)
	{
	EXPR_INFO expr_info;
	GetAllFields(&expr_info, row, 1, method);
	return expr_info.name;
	}


// BEGIN_HELP_COMMENT
// Function: CString UIEEWindow::GetValue(int row /* ROW_CURRENT */)
// Description: Get the value of the expression at the specified row in the expression evaluator window.
// Return: A CString that contains the value of the expression.
// Param: row An integer that specifies the 1-based row of the EE window. Use ROW_CURRENT to specify the current row; ROW_BOTTOM to specify the last row; and ROW_ALL to specify all rows. (Default value is ROW_CURRENT.)
// END_HELP_COMMENT
CString UIEEWindow::GetValue(int row /* ROW_CURRENT */)
	{
	EXPR_INFO expr_info;
	GetAllFields(&expr_info, row, 1, METHOD_WND_SEL);
	return expr_info.value;
	}


// BEGIN_HELP_COMMENT
// Function: int UIEEWindow::SelectRows(int start_row /* ROW_CURRENT */, int total_rows /*= 1*/)
// Description: Select the specified rows in the EE window.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: start_row An integer that specifies the 1-based row of the EE window. Use ROW_CURRENT to specify the current row; ROW_BOTTOM to specify the last row; and ROW_ALL to specify all rows. (Default value is ROW_CURRENT.)
// Param: total_rows An integer that specifies the number of rows to select. (Default value is 1.)
// END_HELP_COMMENT
int UIEEWindow::SelectRows(int start_row /* ROW_CURRENT */, 
						   int total_rows /* 1 */)
	
	{
	switch(start_row)

		{
		case ROW_CURRENT:
			break;
		case ROW_LAST:
			MST.DoKeys("{END}");
			break;
		case ROW_NEXT:
			MST.DoKeys("{DOWN}");
			break;
		case ROW_PREVIOUS:
			MST.DoKeys("{UP}");
			break;
		default:
			
			if(start_row < 1) 
				{					
				LOG->RecordInfo("ERROR in UIEEWindow::SelectRows(): start row < 1");
				return ERROR_ERROR;
				}

			MST.DoKeys("{HOME}");

			for(int i = 1; i < start_row; i++)
				MST.DoKeys("{DOWN}");
		}

	if(total_rows == ROW_ALL)
		 MST.DoKeys("+({END})");
	else
		
		{
		if(total_rows < 1) 
			{					
			LOG->RecordInfo("ERROR in UIEEWindow::SelectRows(): total rows < 1");
			return ERROR_ERROR;
			}
		
		for(int i = 1; i < total_rows; i++)
			MST.DoKeys("+({DOWN})");
		}	

	return ERROR_SUCCESS;
	}
			

// BEGIN_HELP_COMMENT
// Function: int UIEEWindow::Expand(int row /* ROW_CURRENT */)
// Description: Expand the specified row in the EE window.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: row An integer that specifies the 1-based row of the EE window. Use ROW_CURRENT to specify the current row; ROW_BOTTOM to specify the last row; and ROW_ALL to specify all rows. (Default value is ROW_CURRENT.)
// END_HELP_COMMENT
int UIEEWindow::Expand(int row /* ROW_CURRENT */)
	{
	SelectRows(row);
	MST.DoKeys("{+}");
	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int UIEEWindow::Collapse(int row /* ROW_CURRENT */)
// Description: Collapse the specified row in the EE window.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: row An integer that specifies the 1-based row of the EE window. Use ROW_CURRENT to specify the current row; ROW_BOTTOM to specify the last row; and ROW_ALL to specify all rows. (Default value is ROW_CURRENT.)
// END_HELP_COMMENT
int UIEEWindow::Collapse(int row /* ROW_CURRENT */)
	{
	SelectRows(row);
	MST.DoKeys("{-}");
	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int UIEEWindow::GetAllFields(EXPR_INFO* expr_info, int start_row /*= ROW_CURRENT*/, int total_rows /*= 1*/)
// Description: Get information about the expression(s) in the given range of expressions in the expression evaluator window.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: expr_info A pointer to an EXPR_INFO object that will contain the information about the expression(s).
// Param: start_row An integer that specifies the 1-based row of the EE window. Use ROW_CURRENT to specify the current row; ROW_BOTTOM to specify the last row; and ROW_ALL to specify all rows. (Default value is ROW_CURRENT.)
// Param: total_rows An integer that specifies the number of rows to retrieve. (Default value is 1.)
// END_HELP_COMMENT

int UIEEWindow::GetAllFields(EXPR_INFO* expr_info, 
							 int start_row /* ROW_CURRENT */, int total_rows /* 1 */,
							 EE_METHOD_TYPE method /* METHOD_PROP_PAGE */)
	
	{
	int i, cr, tab1, tab2;
	CString expr_str, static_text;		

	// need to select and extract rows directly FROM ee window so we can examine the 
	// expansion state of each row (not available in the properties page).
	if(SelectRows(start_row, total_rows) != ERROR_SUCCESS)
		{					
		LOG->RecordInfo("ERROR in UIEEWindow::GetAllFields(): failed to select rows");
		return ERROR_ERROR;
		}	
	
	// set clipboard to a known state.  this helps us avoid problems when the pane is empty.
	SetClipText("");
	MST.DoKeys("^c");
	GetClipText(expr_str);

	// check if the pane is empty.
	if(expr_str == "")
		{
		expr_info[0].state = NOT_EXPANDABLE;
		expr_info[0].type = "";
		expr_info[0].name = "";
		expr_info[0].value = "";
		return ERROR_SUCCESS;
		}

	// if the user wants to examine all rows, the number of carriage-returns in the extracted
	// string will tell us how many rows there are.
	if(total_rows == ROW_ALL)
		
		{
		CString temp_str = expr_str;	
		cr =  temp_str.Find("\x0D");
		i  = 0;

		while(cr != -1)
			{
			i++;
			temp_str = temp_str.Mid(cr + 2);
			cr = temp_str.Find("\x0D");
			}
		
		total_rows = i;
		}

	// start with the first row. only necessary to do this if we are using the properties
	// page to get the infor for each row.  if the method is METHOD_WND_SEL, we already have
	// the entire contents of the window in expr_info.
	if(method == METHOD_PROP_PAGE)
	{
		// we already selected the start row once to get the state information.
		// if the start row is supposed to be the previous or next row, then selecting it again
		// will actually put us on the wrong row. so in that case we actually want to stay where we are.
		if((start_row != ROW_PREVIOUS) && (start_row != ROW_NEXT))
		{
			if(SelectRows(start_row) != ERROR_SUCCESS)
			{					
				LOG->RecordInfo("ERROR in UIEEWindow::GetAllFields(): failed to select start row");
				return ERROR_ERROR;
			}
		}
	}

	for(i = 0; i < total_rows; i++)

		{
		// set expansion state.
		switch(expr_str[0])
			{
			case '+':
				expr_info[i].state = COLLAPSED;
				break;
			case '-':
				expr_info[i].state = EXPANDED;
				break;
			case '\t': 
				expr_info[i].state = NOT_EXPANDABLE;
				break;
			
			default:
				LOG->RecordInfo("ERROR in UIEEWindow::GetAllFields(): "
								"could not extract state from ee string");

				return ERROR_ERROR;
			}

		// find the end of the current row.
		cr = expr_str.Find("\x0D");

		// since the qw dialog doesn't support the properties page, we need to be able
		// to use the old window selection method in that case.
		switch(method)
			
			{
			// quickwatch functions should not use this method (the default).
			case METHOD_PROP_PAGE:
				
				// bring up properties page (wait for General Tab to appear).
				MST.DoKeys("%({ENTER})");
#ifdef _M_ALPHA
                Sleep(500);  // Slow down a bit so that we can detect the tab.
#endif

				if(!MST.WFndWndWaitC(GetLocString(IDSS_VAR_PROP_TYPE), "Static", FW_PART, 5)) 

					{					
					LOG->RecordInfo("ERROR in UIEEWindow::GetAllFields(): "
									"properties page did not appear within 5 seconds");

					return ERROR_ERROR;
					}
											
				// set type.
				MST.WStaticText("@2", static_text);
				expr_info[i].type = static_text;
				// prop page displays it with a space appended that we need to truncate.
				expr_info[i].type = expr_info[i].type.Left(expr_info[i].type.GetLength() - 1);
				
				// set name and value.
				MST.WStaticText("@4", static_text);
				expr_info[i].name = static_text;
				MST.WStaticText("@6", static_text);
				expr_info[i].value = static_text;

				// close properties page (wait for General Tab to disappear).
				MST.DoKeys("{ESC}");
				while(MST.WFndWndWaitC(GetLocString(IDSS_VAR_PROP_TYPE), "Static", FW_PART,1)); 

				// advance selection to next row if there is a next row.
				if((total_rows - i) > 1)
					MST.DoKeys("{DOWN}");

				break;
		
			case METHOD_WND_SEL:

				// tabs separate state, name, and value fields.
				// carriage-return/linefeed sequence terminates each row.
				tab1 = expr_str.Find("\t");
				tab2 = expr_str.Mid(tab1 + 1).Find("\t") + tab1 + 1;

				// set type (only available in properties page), name, and value.
				expr_info[i].type = "";
				expr_info[i].name  = expr_str.Mid(tab1 + 1, tab2 - tab1 - 1);
				expr_info[i].value = expr_str.Mid(tab2 + 1, cr - tab2 - 1);
				break;

			default:
				// programming error.
				LOG->RecordInfo("ERROR in UIEEWindow::GetAllFields(): invalid method");
				return ERROR_ERROR;
		}

		// advance expression string to next row.  even if method is METHOD_PROP_PAGE,
		// this string is still used to get the expansion state.
		expr_str = expr_str.Mid(cr + 2);
		} 

	return ERROR_SUCCESS;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uieewnd.h ===
///////////////////////////////////////////////////////////////////////////////
//  UIEEWND.H
//
//  Created by :            Date :
//      MichMa              	10/20/94
//
//  Description :
//		Declaration of the UIEEWindow class
//

#ifndef __UIEEWND_H__
#define __UIEEWND_H__

#include "..\shl\udockwnd.h"
#include "dbgxprt.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\cmdids.h"
#include "..\shl\uwbframe.h"
#include "..\sym\qcqp.h"
#include "..\shl\wbutil.h"
#include "Strings.h"
#include "testxcpt.h"
#include "guiv1.h"

#ifndef __UIDOCKWND_H__
	#error include 'udockwnd.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//  UIEEWindow class

#define ERROR_ERROR -1

#define ROW_CURRENT		0
#define ROW_LAST		-1
#define ROW_ALL			-2
#define ROW_NEXT		-3
#define ROW_PREVIOUS	-4

typedef enum {NOT_EXPANDABLE, EXPANDED, COLLAPSED} EXPR_STATE;
typedef enum {METHOD_WND_SEL, METHOD_PROP_PAGE} EE_METHOD_TYPE;

class DBG_CLASS EXPR_INFO
	{
	public:
		int		state;
		CString	type;
		CString	name;
		CString	value;
	};

// BEGIN_CLASS_HELP
// ClassName: UIEEWindow
// BaseClass: UIDockWindow
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS UIEEWindow : public UIDockWindow
	
	{
	UIWND_COPY_CTOR(UIEEWindow, UIDockWindow);

	// subclasses must override these functions
	virtual UINT GetID(void) {return 0;}

	// Public utilities
	public:

		// subclasses must override these function
		virtual BOOL Activate(void) {return FALSE;}
		virtual int SetPane(int pane){return ERROR_ERROR;}
		virtual int SetValue(void) {return 0;}

		int SelectRows(int start_row = ROW_CURRENT, int total_rows = 1);
		int GetState(int row = ROW_CURRENT);

		CString GetType(int row = ROW_CURRENT);
		//CString GetName(int row = ROW_CURRENT);
		CString GetName(int row = ROW_CURRENT, EE_METHOD_TYPE method = METHOD_WND_SEL);
		CString GetValue(int row = ROW_CURRENT);
		
		int GetAllFields(EXPR_INFO* expr_info, int start_row = ROW_CURRENT,
						 int total_rows = 1, EE_METHOD_TYPE method = METHOD_PROP_PAGE);

		int Expand(int row = ROW_CURRENT);
		int Collapse(int row = ROW_CURRENT);
	};

#endif //__UIEEWND_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uiexcpt.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UIEXCPT.CPP
//
//  Created by :            Date :
//      WayneBr                 1/14/94
//
//  Description :
//      Implementation of the UIExceptions class
//

#include "stdafx.h"
#include "uiexcpt.h"
#include "testxcpt.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\cmdids.h"
#include "..\sym\vcpp32.h"
#include "..\shl\uwbframe.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: BOOL UIExceptions::Activate(void)
// Description: Open the Exceptions dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIExceptions::Activate(void)
{
	UIWB.DoCommand(IDM_RUN_EXCEPTIONS, DC_MNEMONIC);
	if (WaitAttachActive(5000)) {
		return TRUE;
	}
	return FALSE;
}

// BEGIN_HELP_COMMENT
// Function: CString UIExceptions::ExcptToString(int excpt)
// Description: Convert an exception ID value to a string. For example, the exception value 0xc0000005 is converted to the string c0000005.
// Return: A CString that contains the exception value converted to a string.
// Param: excpt An integer that contains the exception value.
// END_HELP_COMMENT
CString UIExceptions::ExcptToString(int excpt)
{
	CString sExcpt;
	sprintf(sExcpt.GetBuffer(255), "%.8x", excpt);
	return sExcpt;
};

// BEGIN_HELP_COMMENT
// Function: BOOL UIExceptions::SetNumber(int code)
// Description: Set the exception number in the Exceptions dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: code An integer that contains the exception ID to set.
// END_HELP_COMMENT
BOOL UIExceptions::SetNumber(int code)
{
	EXPECT(IsActive() && MST.WEditEnabled(GetLabel(VCPP32_DLG_EXCEP_NUMBER)));
	MST.WEditSetText(GetLabel(VCPP32_DLG_EXCEP_NUMBER), ExcptToString(code));
	return TRUE;
};

// BEGIN_HELP_COMMENT
// Function: BOOL UIExceptions::SetName(LPCSTR name)
// Description: Set the exception name in the Exceptions dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: name A pointer to a string that contains the name of the exception.
// END_HELP_COMMENT
BOOL UIExceptions::SetName(LPCSTR name)
{
	EXPECT(IsActive() && MST.WEditEnabled(GetLabel(VCPP32_DLG_EXCEP_NAME)));
	MST.WEditSetText(GetLabel(VCPP32_DLG_EXCEP_NAME), name);
	return TRUE;
};

// BEGIN_HELP_COMMENT
// Function: BOOL UIExceptions::SetOption(int option)
// Description: Set the exception action in the Exceptions dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: option A value that specifies the action to take when the exception is detected: STOP_ALWAYS, IF_NOT_HANDLED.
// END_HELP_COMMENT
BOOL UIExceptions::SetOption(int option)
{
	if (option==STOP_ALWAYS)
	{
		MST.WOptionSelect(GetLabel(VCPP32_DLG_EXCEP_1STCHANCE));
	};
	if (option==IF_NOT_HANDLED )
	{
		MST.WOptionSelect(GetLabel(VCPP32_DLG_EXCEP_2NDCHANCE));
	};
	return TRUE;
};

// BEGIN_HELP_COMMENT
// Function: BOOL UIExceptions::AddException(void)
// Description: Click the Add button in the Exceptions dialog to add a new exception.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIExceptions::AddException(void)
{
	if (IsActive() && MST.WButtonEnabled(GetLabel(VCPP32_DLG_EXCEP_ADD)))
	{
		MST.WButtonClick(GetLabel(VCPP32_DLG_EXCEP_ADD));
		return TRUE;
	}
	else
	{
		return FALSE;
	};
};

// BEGIN_HELP_COMMENT
// Function: BOOL UIExceptions::ChangeException(void)
// Description: Click the Change button in the Exceptions dialog to change the exception information.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIExceptions::ChangeException(void)
{
	if (IsActive() && MST.WButtonEnabled(GetLabel(VCPP32_DLG_EXCEP_CHANGE)))
	{
		MST.WButtonClick(GetLabel(VCPP32_DLG_EXCEP_CHANGE));
		return TRUE;
	}
	else
	{
		return FALSE;
	};
};


// BEGIN_HELP_COMMENT
// Function: BOOL UIExceptions::RestoreDefualts(void)
// Description: Click the Reset button in the Exceptions dialog to restore the default exceptions.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIExceptions::RestoreDefualts(void)
{
	EXPECT(IsActive() && MST.WButtonEnabled(GetLabel(VCPP32_DLG_EXCEP_DEFAULT)));
	MST.WButtonClick(GetLabel(VCPP32_DLG_EXCEP_DEFAULT));
	return TRUE;
};


// BEGIN_HELP_COMMENT
// Function: BOOL UIExceptions::SetException(int code, int option)
// Description: Add or change an exception in the Exceptions dialog. The exception is added, if it doesn't exist; changed if it does exist.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: code An integer that specifies the exception ID to add or change.
// Param: option A value that specifies the action to take when the exception is detected: STOP_ALWAYS, IF_NOT_HANDLED.
// END_HELP_COMMENT
BOOL UIExceptions::SetException(int code, int option)
{
	EXPECT(SetNumber(code));
	EXPECT(SetName(GetLocString(IDSS_EXCPT_EXCEPT_NAME)));	// "testing change"
	EXPECT(SetOption(option));
	if (!AddException()) ChangeException();
	return TRUE;
};

// BEGIN_HELP_COMMENT
// Function: BOOL UIExceptions::DeleteException(int code)
// Description: Delete an exception from the Exceptions dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: code An integer that specifies the exception ID to delete.
// END_HELP_COMMENT
BOOL UIExceptions::DeleteException(int code)
{
	CString sListItem;
	CString sExcpt = ExcptToString(code);
	EXPECT(IsActive() && MST.WListEnabled(GetLabel(VCPP32_DLG_EXCEP_LIST)));
	int limit = MST.WListCount(GetLabel(VCPP32_DLG_EXCEP_LIST));
	for (int x=1; x< limit; x++)
	{
		MST.WListItemText(GetLabel(VCPP32_DLG_EXCEP_LIST), x, sListItem);
		if (sListItem.Find(sExcpt) != -1 ) { break; };   // is excpt in list item?
	};
	if ( x > limit )  return FALSE;      //excpt not found
	MST.WListItemClk(GetLabel(VCPP32_DLG_EXCEP_LIST), x);
	EXPECT(IsActive() && MST.WButtonEnabled(GetLabel(VCPP32_DLG_EXCEP_DELETE)));
	MST.WButtonClick(GetLabel(VCPP32_DLG_EXCEP_DELETE));
	return TRUE;
};

// BEGIN_HELP_COMMENT
// Function: CString UIExceptions::GetException(int code)
// Description: Get the description for the specified exception from the Exceptions dialog.
// Return: A CString that contains the description of the specified exception.
// Param: code An integer that specifies the exception ID.
// END_HELP_COMMENT
CString  UIExceptions::GetException(int code)
{
	CString sListItem;
	CString sExcpt = ExcptToString(code);
	EXPECT(IsActive() && MST.WListEnabled(GetLabel(VCPP32_DLG_EXCEP_LIST)));
	int limit = MST.WListCount(GetLabel(VCPP32_DLG_EXCEP_LIST));
	for (int x=1; x< limit; x++)
	{
		MST.WListItemText(GetLabel(VCPP32_DLG_EXCEP_LIST), x, sListItem);
		if (sListItem.Find(sExcpt) != -1 ) { break; };   // is excpt in list item?
	};
	return sListItem;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uiexcpt.h ===
///////////////////////////////////////////////////////////////////////////////
//  UIEXCPT.H
//
//  Created by :            Date :
//      WayneBr             1/14/94
//
//  Description :
//      Declaration of the UIExceptions class
//

#ifndef __UIEXCPT_H__
#define __UIEXCPT_H__

#include "..\..\udialog.h"
#include "..\shl\wbutil.h"

#include "dbgxprt.h"

#ifndef __UIDIALOG_H__
   #error include 'udialog.h' before including this file
#endif


///////////////////////////////////////////////////////////////////////////////
//  UIExceptions symbols

/*
//#define  UIEXCPT_TITLE 			"Exceptions"
//#define  UIEXCPT_EB_NUMBER	"&Exception Number:"
#define  UIEXCPT_EB_NAME			"&Name:"
//#define  UIEXCPT_RB_ALWAYS			"&Stop Always"
//#define  UIEXCPT_RB_PASS_ONCE			"Stop if &Not Handled"
//#define  UIEXCPT_LB_LIST			"Exception &List:"
#define  UIEXCPT_BTN_HELP			"&Help"
//#define  UIEXCPT_BTN_DEFAULT		"&Defaul&t"
//#define  UIEXCPT_BTN_ADD		"&Add"
//#define  UIEXCPT_BTN_CHANGE		"&Change"
//#define  UIEXCPT_BTN_DELETE		"&Delete"
*/

// Intel Specific?
enum {STOP_ALWAYS, IF_NOT_HANDLED };
const MaxOption=2;



///////////////////////////////////////////////////////////////////////////////
//  UIExceptions class

// BEGIN_CLASS_HELP
// ClassName: UIExceptions
// BaseClass: UIDialog
// Category: Debug
// END_CLASS_HELP
class AFX_EXT_CLASS UIExceptions : public UIDialog

	{

// base class overrides
public:
	UIWND_COPY_CTOR (UIExceptions, UIDialog) ;
	virtual CString ExpectedTitle (void) const{return GetLocString(IDSS_EXCPT_TITLE);}
	virtual BOOL Activate(void);

	// Internal Utilities
	private:
	CString ExcptToString(int thread);

	// Utilities
	public:
		BOOL SetException(int code, int option);
		BOOL SetNumber(int code);
		BOOL SetName(LPCSTR name);
		BOOL SetOption(int option);
		BOOL AddException(void);
		BOOL ChangeException(void);
		BOOL DeleteException(int code);
		CString  GetException(int code);
		BOOL RestoreDefualts(void);

	};

#endif // __UIEXCPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uilocals.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UILOCALS.CPP
//
//  Created by :            Date :
//      MichMa              	1/17/94
//
//  Description :
//      Implementation of the UILocals class
//

#include "stdafx.h"
#include "uilocals.h"
#include "..\sym\cmdids.h"
#include "..\shl\uwbframe.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
   

// BEGIN_HELP_COMMENT
// Function: BOOL UILocals::Activate(void)
// Description: Bring up the locals window.
// Return: A Boolean value that indicates whether the register's window is active (TRUE) or not.
// END_HELP_COMMENT
BOOL UILocals::Activate(void)
{
	UIWB.DoCommand(IDM_VIEW_VARS, DC_MNEMONIC);
	return AttachActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uilocals.h ===
///////////////////////////////////////////////////////////////////////////////
//  UILOCALS.H
//
//  Created by :            Date :
//      MichMa              	1/17/94
//
//  Description :
//      Declaration of the UILocals class
//

#ifndef __UILOCALS_H__
#define __UILOCALS_H__

#include "..\sym\qcqp.h"
#include "..\shl\udockwnd.h"

#include "dbgxprt.h"

#ifndef __UIDOCKWND_H__
   #error include 'udockwnd.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//  UILocals class

// BEGIN_CLASS_HELP
// ClassName: UILocals
// BaseClass: UIDockWindow
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS UILocals : public UIDockWindow
   {
	UIWND_COPY_CTOR(UILocals, UIDockWindow);

	virtual BOOL Activate(void);
	virtual UINT GetID(void) const
		{	return IDW_LOCALS_WIN; }
   };

#endif //__UILOCALS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uimem.h ===
///////////////////////////////////////////////////////////////////////////////
//	UIMEM.H
//
//	Created by :			Date :
//		MichMa					1/14/94
//
//	Description :
//		Declaration of the UIMemory class
//

#ifndef __UIMEM_H__
#define __UIMEM_H__

#include "dbgxprt.h"
#include "..\SYM\qcqp.h"
#include "..\SHL\udockwnd.h"

#include "..\SHL\uwbframe.h"

#ifndef __UIDOCKWND_H__
	#error include 'udockwnd.h' before including this file
#endif

// memory format options
/*
typedef enum {	MEM_FORMAT_ASCII = 0,
				MEM_FORMAT_WCHAR,
				MEM_FORMAT_BYTE,
				MEM_FORMAT_SHORT,
				MEM_FORMAT_SHORT_HEX,
				MEM_FORMAT_SHORT_UNSIGNED,
				MEM_FORMAT_LONG,
				MEM_FORMAT_LONG_HEX,
				MEM_FORMAT_LONG_UNSIGNED,
				MEM_FORMAT_REAL,
				MEM_FORMAT_REAL_LONG,
				MEM_FORMAT_INT64,
				MEM_FORMAT_INT64_HEX,
				MEM_FORMAT_INT64_UNSIGNED
			} MEM_FORMAT;
			


*/
///////////////////////////////////////////////////////////////////////////////
//	UIMemory class

// BEGIN_CLASS_HELP
// ClassName: UIMemory
// BaseClass: UIDockWindow
// Category: Debug
// END_CLASS_HELP

#define ERROR_ERROR -1

class DBG_CLASS UIMemory : public UIDockWindow
	
	{
	UIWND_COPY_CTOR(UIMemory, UIDockWindow);

	//Data
	// stores format currently used by Memory window. 
	// used by UIMemory and COMemory utility classes.
	// use UIMemory::SetMemoryFormat() to set it, and
	// UIMemory::GetMemoryFormat() to get it.
	MEM_FORMAT	m_MemoryFormat;

	virtual BOOL Activate(void);
	virtual UINT GetID(void) const
		{	return IDW_MEMORY_WIN; }

	virtual BOOL AttachActive(void);
	virtual BOOL Find(void);

	// UIWindow overrides
	public:
		virtual BOOL IsValid(void) const;
		virtual BOOL IsActive(void);	// derived classes must provide their own Activate (usually a DoCommand)

	// Utilities
	public:
		
		CString GetCurrentAddress(void);
		CString GetCurrentData(int count = 1, int start = 0);
		CString GetCurrentChars(int count = 1, int start = 0);
		CString GetColumns(void);
		CString GetCurrentSymbol(void);
		
		BOOL SetCurrentData(LPCSTR data, int start = 0);
		BOOL SetCurrentChars(LPCSTR chars, int start = 0);
		BOOL SetCurrentChars(char chr, int start = 0);
		BOOL SetMemoryFormat(MEM_FORMAT format);
		BOOL EnableToolBar(BOOL bEnable);
		BOOL ToogleReEvaluation(void);
		BOOL SetColumns(CString Columns);
		BOOL CycleMemoryFormat(int count);
		BOOL EnableDockingView(BOOL bEnable);
		BOOL IsDockingViewEnabled(void);
		BOOL ToggleDockingView(void);

		int GoToAddress(LPCSTR symbol);
		int GetFormatWidth(int format = 0);
		int GetMemoryWidth(void);

		MEM_FORMAT GetMemoryFormat(void);

	};

#endif //__UIMEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uiqw.h ===
///////////////////////////////////////////////////////////////////////////////
//  UIQW.H
//
//  Created by :            Date :
//      MichMa              1/14/94
//
//  Description :
//  	Declaration of the UIQuickWatch class
//

#ifndef __UIQW_H__
#define __UIQW_H__

#include "..\..\udialog.h"
#include "..\shl\wbutil.h"

#include "dbgxprt.h"

#ifndef __UIDIALOG_H__
	#error include 'udialog.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//  UIQuickWatch class

// BEGIN_CLASS_HELP
// ClassName: UIQuickWatch
// BaseClass: UIDialog
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS UIQuickWatch : public UIDialog

	{
// base class overrides
public:
	UIWND_COPY_CTOR(UIQuickWatch, UIDialog);
	CString ExpectedTitle(void) const {return GetLocString(IDSS_QW_TITLE);}
	virtual BOOL Activate(void);

	// Utilities
	public:
		
		CString GetExpression(void);
		CString GetNewValue(void);
		CString GetCurrentValue(void);

		BOOL SetExpression(LPCSTR expression);
		BOOL SetNewValue(LPCSTR value); 
		
		BOOL Recalc(void);
		BOOL AddWatch(void);

	// Standard buttons
    	virtual HWND Close(void);
	};

#endif //__UIQW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uiqw.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UIQW.CPP
//
//  Created by :            Date :
//      MichMa              1/14/94
//
//  Description :
//      Implementation of the UIQuickWatch class
//

#include "stdafx.h"
#include "uiqw.h"
#include "uieewnd.h"
#include "testxcpt.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\cmdids.h"
#include "..\sym\vcpp32.h"
#include "..\shl\uwbframe.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

UIEEWindow UIEE;

// BEGIN_HELP_COMMENT
// Function: BOOL UIQuickWatch::Activate(void)
// Description: Open the QuickWatch dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIQuickWatch::Activate(void)
{
	 UIWB.DoCommand(IDM_RUN_QUICKWATCH, DC_MNEMONIC);
	if (WaitAttachActive(5000)) {
		return TRUE;
	}
	return FALSE;
}

// BEGIN_HELP_COMMENT
// Function: CString UIQuickWatch::GetCurrentValue(void) 
// Description: Returns the value of the current expression in the QuickWatch dialog.
// Return: A CString that contains the current value.
// END_HELP_COMMENT
CString UIQuickWatch::GetCurrentValue(void) 
{
	//MST.DoKeys("%V");	 // TODO: Hack should be replaced with GetLabel or something better
	CString strCurrentValue = "%";
	MST.DoKeys(strCurrentValue += ExtractHotKey(GetLabel(VCPP32_ID_QUICKW_TXT_MEMBERS)));
 	
	return UIEE.GetValue();
}		 

// BEGIN_HELP_COMMENT
// Function: CString UIQuickWatch::GetExpression(void) 
// Description: Returns the current expression
// Return: A CString that contains the current expression.
// END_HELP_COMMENT
CString UIQuickWatch::GetExpression(void) 
	{
	if(!(IsActive() && MST.WComboEnabled(GetLabel(VCPP32_ID_QUICKW_EXPRESSION)))) return CString("");
	CString value;
	MST.WComboText(GetLabel(VCPP32_ID_QUICKW_EXPRESSION), value);
	return value;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIQuickWatch::SetExpression(LPCSTR exp)
// Description: Sets a new expression for the Quickwatch dialog. NOTE: does not do a "recalc."
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: exp A pointer to a string that contains the expression to enter in the QuickWatch dialog.
// END_HELP_COMMENT
BOOL UIQuickWatch::SetExpression(LPCSTR exp)
	{
	if(!(IsActive() && MST.WComboEnabled(GetLabel(VCPP32_ID_QUICKW_EXPRESSION)))) return FALSE;
	MST.WComboSetText(GetLabel(VCPP32_ID_QUICKW_EXPRESSION), exp);
	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIQuickWatch::SetNewValue(LPCSTR value) 
// Description: Modifies the value for the current expression.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: value A pointer to a string that contains the new value to enter in the QuickWatch dialog.
// END_HELP_COMMENT
BOOL UIQuickWatch::SetNewValue(LPCSTR value) 
	{
//	MST.DoKeys("%V");	 // Hack should be replaced with GetLabel or something better
	CString strCurrentValue = "%";
	MST.DoKeys(strCurrentValue += ExtractHotKey(GetLabel(VCPP32_ID_QUICKW_TXT_MEMBERS)));
	MST.DoKeys("{TAB}");
	
	char tmpstr[4];
	char *ptr;
	// Put the + sign in {} for expressions like "123.e+022" in order to prevent "+" treated as Shift
	if(NULL != (ptr = strstr(value, "+")))
	{
		strcpy(tmpstr, ptr + 1);
		strcpy(ptr, "{+}");
		strcat((char*) value, tmpstr);
	}

	MST.DoKeys(value);
					  
	// commit edit
	MST.DoKeys("{ENTER}");
	return TRUE;
	}

      
// BEGIN_HELP_COMMENT
// Function: BOOL UIQuickWatch::Recalc(void)
// Description: Recalcs the expression in the expression field.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIQuickWatch::Recalc(void)
	{
	if(!(IsActive() && MST.WButtonEnabled(GetLabel(VCPP32_ID_QUICKW_NEWEXPR)))) return FALSE;
	MST.WButtonClick(GetLabel(VCPP32_ID_QUICKW_NEWEXPR));
	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIQuickWatch::AddWatch(void)
// Description: Adds the current expression in the Quick Watch Dialog to the Watch window.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIQuickWatch::AddWatch(void)
	{
	if(!(IsActive() && MST.WButtonEnabled(GetLabel(VCPP32_ID_QUICKW_ADD)))) return FALSE;
	MST.WButtonClick(GetLabel(VCPP32_ID_QUICKW_ADD));
	return TRUE;
	}

// BEGIN_HELP_COMMENT
// Function: HWND UIQuickWatch::Close(void)
// Description: Close the QuickWatch Dailog
// Return: HWND: NULL means all went well, otherwise return HWND of active window (alert)
// END_HELP_COMMENT
HWND UIQuickWatch::Close(void)
{
	if(!IsActive())
		return MST.WGetActWnd(0);	// an HWND presumes some alert came up
	
	if(MST.WFndWndWaitC(GetLocString(IDS_CLOSE), "Button", FW_PART, 1))        // WinslowF - Need this for Chicago
		MST.WButtonClick(GetLabel(IDCANCEL));	
	else	
		MST.WButtonClick(GetLabel(IDCANCEL));		// WinslowF - backward compatibility; use the close button if there is one

	if( WaitUntilGone(3000) )		// REVIEW(davidga) 3000 is too arbitrary
		return NULL;		// NULL means all is well
	else
		return MST.WGetActWnd(0);	// an HWND presumes some alert came up
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uimem.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	UIMEM.CPP
//
//	Created by :			Date :
//		MichMa					1/14/94
//
//	Description :
//		Implementation of the UIMemory class
//

#include "stdafx.h"
#include "uimem.h"
#include "..\SYM\cmdids.h"
#include "..\SYM\reg.h"
#include "..\..\testutil.h"
#include "..\SHL\uwbframe.h"
#include "..\SHL\wbutil.h"
#include "..\SHL\uioptdlg.h"
#include <guiv1.h>
#include <mstwrap.h>

#include "..\..\udialog.h"
extern TARGET_DATA HANDLE g_hTargetProc;

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

int FormatWidth[14] = {1, 1, 3, 8, 6, 7, 13, 10, 12, 15, 24, 22, 18, 22};


// BEGIN_HELP_COMMENT
// Function: BOOL UIMemory::AttachActive(void)
// Description: Attach to the locals window if it's the active window.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIMemory::AttachActive(void)
	{
	HWND hwnd;

    if(hwnd = MST.WFndWndWait(GetLocString(IDSS_MEM_WND_TITLE), FW_FULL, 2))
		return Attach(hwnd);
	else
		return Attach(FindFirstChild(UIWB.HWnd(), IDW_MEMORY_WIN));
	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIMemory::Find(void)
// Description: Find the locals window and attach to it
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIMemory::Find(void)
	{
	int pkgId ;
	switch(GetID())
	{
	case 0:
		pkgId = 0 ;
		break ;
	case IDDW_PROJECT:
		pkgId = PACKAGE_VPROJ ;
		break;
	case IDW_LOCALS_WIN: 
		pkgId = PACKAGE_VCPP ;
		break ;
	default:
		break;
	}
	return Attach(UIWB.GetToolbar(GetID(),pkgId));
	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIMemory::IsValid(void) const
// Description: Determine if the locals window is a valid window.
// Return: A Boolean that indicates whether the locals window is valid (TRUE) or not.
// END_HELP_COMMENT
BOOL UIMemory::IsValid(void) const
	{
	return UIWindow::IsValid();
	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIMemory::IsActive(void)
// Description: Determine if the locals window is active.
// Return: A Boolean value that indicates whether the locals window is active (TRUE) or not.
// END_HELP_COMMENT
BOOL UIMemory::IsActive(void)
	{
	HWND hwnd = MST.WGetFocus();
	return (hwnd == HWnd()) || IsChild(HWnd(), hwnd);
	}


// BEGIN_HELP_COMMENT
// Function: CString UIMemory::GetCurrentAddress(void)
// Description: Get the starting address of the first caret line in the memory window.
// Return: A CString that contains the address.
// END_HELP_COMMENT
CString UIMemory::GetCurrentAddress(void)
	{
	Activate();

	if(!IsActive()) return CString("");

	MST.DoKeys("{Enter}");					// Jump to memory window from the Address edit box.  If we already there, this command does nothing
	// In 60 ^{HOME} causes a jump to 00000000
	//MST.DoKeys("^{HOME}");					// Go to the first caret line in the memory window

	MST.DoKeys("{HOME}+({RIGHT 8})^(c)");	// set cursor at beginning of line and
	CString address;						// copy first 8 characters to clipboard
	GetClipText(address);
	return address;
	}


// BEGIN_HELP_COMMENT
// Function: CString UIMemory::GetCurrentData(int count /* 1 */, int start /* 0 */)
// Description: Get data from the current caret line in the memory window.
// Return: A CString that contains the data.
// Param: count An integer that contains the number of data elements to include when getting the data. (Default value is 1.)
// Param: start An integer that contains the number of data elements to skip from the beginning of the line. (Default value is 0.)
// END_HELP_COMMENT
CString UIMemory::GetCurrentData(int count /* 1 */, int start /* 0 */)

	{												 //TODO: handle getting chars from multiple lines
	if(!IsActive())
		{
		LOG->RecordInfo("ERROR in UIMemory::GetCurrentData(): Memory window not active");
		return CString("");
		}

	MST.DoKeys("{HOME}");		// set cursor at beginning of line
	int i;
	
	for(i = -1; i < start; i++)		// set cursor at beginning of start value
		MST.DoKeys("{TAB}");
			
	for(i = 0; i < ((FormatWidth[GetMemoryFormat()]) * count); i++)	// select count worth
		MST.DoKeys("+({RIGHT})");												// of chars for the			
							 													// current format width
	MST.DoKeys("^(c)");		// copy selection to clipboard
	CString data;		
	GetClipText(data);
	return data;
	}


// BEGIN_HELP_COMMENT
// Function: CString UIMemory::GetCurrentChars(int count /* 1 */, int start /* 0 */)
// Description: Get character data from the current caret line in the memory window.
// Return: A CString that contains the characters.
// Param: count An integer that contains the number of characters to include when getting the data. (Default value is 1.)
// Param: start An integer that contains the number of Characters to skip from the beginning of the line. (Default value is 0.)
// END_HELP_COMMENT
CString UIMemory::GetCurrentChars(int count /* 1 */, int start /* 0 */)
	
	{														//TODO: handle getting chars from multiple lines
	if(!IsActive()) return CString("");
	MST.DoKeys("{HOME}");		// set cursor at beginning of line
	int i;

	for(i = -1; i < (GetMemoryWidth() + start); i++)		// set cursor at start char
		MST.DoKeys("{TAB}");

	for(i = 0; i < count; i++)
		MST.DoKeys("+({RIGHT})");		// select count worth of chars			

	MST.DoKeys("^(c)");		// copy selection to clipboard
	CString chars;
	GetClipText(chars);
	return chars;
	}

	
// BEGIN_HELP_COMMENT
// Function: BOOL UIMemory::SetCurrentData(LPCSTR data, int start /* 0 */)
// Description: Set data in the current caret line in the memory window.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: data A pointer to a string that contains the data to enter into the memory window.
// Param: start An integer that contains the number of data elements to skip from the beginning of the line before entering the data. (Default value is 0.)
// END_HELP_COMMENT
BOOL UIMemory::SetCurrentData(LPCSTR data, int start /* 0 */)		// TODO: handle data overlapping to next line
	
	{
	int i;

	if(!IsActive()) return FALSE;
	MST.DoKeys("{HOME}");		// set cursor at beginning of line
										
	for(i = -1; i < start; i++)		// set cursor at beginning of start value
		MST.DoKeys("{TAB}");

	// Put 0s to fit format
	while(data[i] == ' ')
		memset((void*)&data[i++], (int) '0',  1);
	
	MST.DoKeys(data);		// type new data (must be legal for current format)						


	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIMemory::SetCurrentChars(LPCSTR chars, int start /* 0 */)
// Description: Set character data in the current caret line in the memory window. (See also SetCurrentChars(char, int).)
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: chars A pointer to a string that contains the characters to enter into the memory window.
// Param: start An integer that contains the number of characters to skip from the beginning of the line before entering the data. (Default value is 0.)
// END_HELP_COMMENT
BOOL UIMemory::SetCurrentChars(LPCSTR chars, int start /* 0 */)		// TODO: handle chars overlapping to next line
	
	{
	if(!IsActive()) return FALSE;
	MST.DoKeys("{HOME}");		// set cursor at beginning of line
										
	for(int i = -1; i < (GetMemoryWidth() + start); i++)		// set cursor at start char
		MST.DoKeys("{TAB}");

	MST.DoKeys(chars);		// type new chars (must be legal for current format)						
	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIMemory::SetCurrentChars(char chr, int start /* 0 */)
// Description: Set character data in the current caret line in the memory window. (See also SetCurrentChars(LPCSTR, int).)
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: chr A char that contains the character to enter into the memory window.
// Param: start An integer that contains the number of characters to skip from the beginning of the line before entering the data. (Default value is 0.)
// END_HELP_COMMENT
BOOL UIMemory::SetCurrentChars(char chr, int start /* 0 */)
	
	{
	if(!IsActive()) return FALSE;
	MST.DoKeys("{HOME}");		// set cursor at beginning of line
										
	for(int i = -1; i < (GetMemoryWidth() + start); i++)		// set cursor at start char
		MST.DoKeys("{TAB}");

	CString cstr = chr;
	MST.DoKeys(cstr);		// type new char (must be legal for current format)						
	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: int UIMemory::GetFormatWidth(int format /* 0 */)
// Description: Get the width of a single data element in the specified memory window format.
// Return: An integer that contains the width of a single data element in the specified memory window format.
// Param: format A value that specifies the memory window format to get the width for: MEM_FORMAT_ASCII, MEM_FORMAT_WCHAR, MEM_FORMAT_BYTE, MEM_FORMAT_SHORT, MEM_FORMAT_SHORT_HEX, MEM_FORMAT_SHORT_UNSIGNED, MEM_FORMAT_LONG, MEM_FORMAT_LONG_HEX, MEM_FORMAT_LONG_UNSIGNED, MEM_FORMAT_REAL, MEM_FORMAT_REAL_LONG. 0 means get the width for the current format. (Default value is 0.)
// END_HELP_COMMENT
int UIMemory::GetFormatWidth(int format /* 0 */)
	{
	if(format)
		return FormatWidth[format];
	else
		return FormatWidth[GetMemoryFormat()];
	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIMemory::Activate(void)
// Description: Bring up the memory window.
// Return: A Boolean value that indicates whether the memory window is active (TRUE) or not.
// END_HELP_COMMENT
BOOL UIMemory::Activate(void)
	{
	UIWB.DoCommand(IDM_VIEW_MEM, DC_MNEMONIC);
	return AttachActive();
	}


// BEGIN_HELP_COMMENT
// Function: int UIMemory::GoToAddress(LPCSTR symbol)
// Description: Go to the specified address or symbol in the memory window.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: symbol A pointer to a string that contains the address or symbol to go to in the memory window.
// END_HELP_COMMENT
int UIMemory::GoToAddress(LPCSTR symbol)
	
	{
	// Activate();  TODO: (dklem 11/25/98) remove this string if all snaps and sniffs pass

	if(!IsActive())
		{
		LOG->RecordInfo("ERROR in UIMemory::GoToAddress(): Memory window not active");
		return ERROR_ERROR;
		}

	CString cstr;
	if(MST.WEditExists(GetLocString(IDSS_MEMORY_ADDRESS_EDIT)))
	{
		MST.WEditSetFocus(GetLocString(IDSS_MEMORY_ADDRESS_EDIT));
		MST.WEditSetText("", symbol);
		MST.WEditText(GetLocString(IDSS_MEMORY_ADDRESS_EDIT), cstr);
		if(cstr != symbol)
		
			{
			LOG->RecordInfo("ERROR in UIMemory::GoToAddress(): Address field could not be set -"
						"expected text = %s, actual text = %s\n", symbol, cstr);
		
			return ERROR_ERROR;
			}

	}
	else
	{
		// Preserve the focus
		//Save Focus
		HWND hwndSaveFocus = UIWB.HWnd();
		//Set Focus to the Memory window
		UIWB.SetHWnd(MST.WGetFocus());
		::WaitForInputIdle(g_hTargetProc, 10000);
		UIWB.DoCommand(IDM_GOTO_LINE, DC_MNEMONIC);
		// Wait for the dialog
		UIDialog gd(GetLocString(IDSS_GOTO_TITLE));
		if( !gd.WaitAttachActive(10000) )
		{
			LOG->RecordInfo("Could not open the Goto dialog");
			return FALSE;
		}
		// Set desired address
		MST.WEditSetText("@1", symbol);
		// Restore Focus
		UIWB.SetHWnd(hwndSaveFocus);
	}
	
	// michma - 9/21/99: we're seeing timing problems where it appears that the ENTER key isn't taking affect, and
	// the cursor is left in the address field instead of being put into the data field. these sleeps might help.
	LOG->RecordInfo("doing 1000 ms sleep around {ENTER} to avoid timing problem.");
	Sleep(1000);
	MST.DoKeys("{ENTER}");
	Sleep(1000);

	// We need to close the GoTo dialog.  If it is not opened one extra ECS wouldn't hurt.  Would it ? dklem 11/11/98
	// Yes it hurts, so we need to find out if the GoTo dialog exists
	HWND hWndGoTo = MST.WFndWndWait("Go To", FW_NOCASE | FW_PART | FW_FOCUS, 1);  // Let's wait 1 second
	if(hWndGoTo)
	{
		// Hit Enter one more time if the address is invalid
		HWND hWndInvalidAddress = MST.WFndWndWait("Microsoft Visual C++", FW_NOCASE | FW_PART | FW_FOCUS, 1);  // Let's wait 1 second
		if(hWndInvalidAddress)
			MST.DoKeys("{ENTER}");

		// Close the dialog
		SetActiveWindow(hWndGoTo);
		MST.DoKeys("{ESC}");
	}
		
	UIWB.DoCommand(IDM_VIEW_MEM, DC_ACCEL);
	// Since the address of the symbol is always located in the left upper corner, we want to put hte cursor to this corner
	// For 60 this will set address to 0000000
	// MST.DoKeys("^{HOME}");
	return ERROR_SUCCESS;
	}

// BEGIN_HELP_COMMENT
// Function: void UIMemory::SetMemoryFormat(MEM_FORMAT format)	
// Description: Set the format of the memory window. 
// Return: No
// Param: format A MEM_FORMAT value specifying the format of the memory window: MEM_FORMAT_ASCII, MEM_FORMAT_WCHAR, 
//	MEM_FORMAT_BYTE, MEM_FORMAT_SHORT, MEM_FORMAT_SHORT_HEX, MEM_FORMAT_SHORT_UNSIGNED, MEM_FORMAT_LONG, MEM_FORMAT_LONG_HEX, 
//	MEM_FORMAT_LONG_UNSIGNED, MEM_FORMAT_REAL, MEM_FORMAT_REAL_LONG, MEM_FORMAT_INT64, MEM_FORMAT_INT64_HEX, MEM_FORMAT_INT64_UNSIGNED
// END_HELP_COMMENT
BOOL UIMemory::SetMemoryFormat(MEM_FORMAT format)	
	{

	// Bring up the popup context menu
	MST.DoKeys("+({F10})");
	//Go to the "More Formats" menu item
	MST.DoKeys("{DOWN 4}");

	// Choose More Formats
	MST.DoKeys("{RIGHT}");

	// Do one more Right to highLight the first item in the Submenu
	MST.DoKeys("{RIGHT}");

	// Go to the desirable Memory Format
	switch(format)
	{
	case MEM_FORMAT_ASCII:
		{
		//MST.DoKeys("{DOWN 0}");
		break;
		}
	case MEM_FORMAT_WCHAR:
		{
		MST.DoKeys("{DOWN 1}");
		break;
		}
	case MEM_FORMAT_BYTE:
		{
		MST.DoKeys("{DOWN 2}");
		break;
		}
	case MEM_FORMAT_SHORT:
		{
		MST.DoKeys("{DOWN 3}");
		break;
		}
	case MEM_FORMAT_SHORT_HEX:
		{
		MST.DoKeys("{DOWN 4}");
		break;
		}
	case MEM_FORMAT_SHORT_UNSIGNED:
		{
		MST.DoKeys("{DOWN 5}");
		break;
		}
	case MEM_FORMAT_LONG:
		{
		MST.DoKeys("{DOWN 6}");
		break;
		}
	case MEM_FORMAT_LONG_HEX:
		{
		MST.DoKeys("{DOWN 7}");
		break;
		}
	case MEM_FORMAT_LONG_UNSIGNED:
		{
		MST.DoKeys("{DOWN 8}");
		break;
		}
	case MEM_FORMAT_REAL:
		{
		MST.DoKeys("{DOWN 9}");
		break;
		}
	case MEM_FORMAT_REAL_LONG:
		{
		MST.DoKeys("{DOWN 10}");
		break;
		}
	case MEM_FORMAT_INT64:
		{
		MST.DoKeys("{DOWN 11}");
		break;
		}
	case MEM_FORMAT_INT64_HEX:
		{
		MST.DoKeys("{DOWN 12}");
		break;
		}
	case MEM_FORMAT_INT64_UNSIGNED:
		{
		MST.DoKeys("{DOWN 13}");
		break;
		}
	}
	
	// And choose it
	MST.DoKeys("{ENTER}");

	// Remember memory format
	m_MemoryFormat = format;

	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: MEM_FORMAT UIMemory::GetMemoryFormat(void)
// Description: Get the format of the memory window. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A MEM_FORMAT value containing the format of the memory window: MEM_FORMAT_ASCII, MEM_FORMAT_WCHAR, 
//	MEM_FORMAT_BYTE, MEM_FORMAT_SHORT, MEM_FORMAT_SHORT_HEX, MEM_FORMAT_SHORT_UNSIGNED, MEM_FORMAT_LONG, MEM_FORMAT_LONG_HEX, 
//	MEM_FORMAT_LONG_UNSIGNED, MEM_FORMAT_REAL, MEM_FORMAT_REAL_LONG, MEM_FORMAT_INT64, MEM_FORMAT_INT64_HEX, MEM_FORMAT_INT64_UNSIGNED
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
	MEM_FORMAT UIMemory::GetMemoryFormat(void)		//must only set format with SetMemoryFormat!
	{
	return m_MemoryFormat;
	}


// BEGIN_HELP_COMMENT
// Function: int UIMemory::GetMemoryWidth(void)
// Description: Get the width of the memory window. NOTE: NIY
// Return: An integer containing the width of the memory window.
// END_HELP_COMMENT
int UIMemory::GetMemoryWidth(void)			//must only set width with SetMemoryWidth!			
{
	return 0;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIMemory::EnableToolBar(BOOL bEnable)
// Description: Enables or disables the edit control in memory window
// Param: bEnable If the parameter is TRUE, edit control will be enabled. If FALSE - disabled.
// Return: A Boolean value that indicates whether the toggle operatin was sucessfull (TRUE) or not.
// END_HELP_COMMENT

BOOL UIMemory::EnableToolBar(BOOL bEnable)
{
	if((  MST.WEditExists(GetLocString(IDSS_MEMORY_ADDRESS_EDIT)) && bEnable) || 
		(!MST.WEditExists(GetLocString(IDSS_MEMORY_ADDRESS_EDIT)) && !bEnable))
		return TRUE;

	// Bring up the popup context menu
	MST.DoKeys("+({F10})");
	//Go to the "Toggle Toolbar" menu item
	MST.DoKeys("{DOWN 4}");

	// Toggle it
	MST.DoKeys("{ENTER}");

	// Check that the edit control exists
	if((  MST.WEditExists(GetLocString(IDSS_MEMORY_ADDRESS_EDIT)) && bEnable) || 
		(!MST.WEditExists(GetLocString(IDSS_MEMORY_ADDRESS_EDIT)) && !bEnable))
		return TRUE;
	else 
		return FALSE;
}

// BEGIN_HELP_COMMENT
// Function: CString UIMemory::GetColumns(void)
// Description: Gets number of columns in memory window
// Param: No Params
// Return: CString Number of columns
// END_HELP_COMMENT
CString UIMemory::GetColumns(void)
{	
	CString Columns;
	MST.WComboText("@1", Columns);
	return Columns;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIMemory::SetColumns(CString Columns)
// Description: Sets number of columns in memory window
// Param: Columns A number of columns or "<Auto>"
// Return: A Boolean value that indicates whether the set column operatin was sucessfull (TRUE) or not.
// END_HELP_COMMENT
BOOL UIMemory::SetColumns(CString Columns)
{
	if(!IsActive())
		{
		LOG->RecordInfo("ERROR in UIMemory::GoToAddress(): Memory window not active");
		return ERROR_ERROR;
		}

	MST.WComboItemClk("@1", Columns);
	if(Columns == GetColumns())
		return TRUE;

	LOG->RecordInfo("ERROR in UIMemory::SetColumns(): Number of columns was not set correctly");
	return ERROR_ERROR;
}

// BEGIN_HELP_COMMENT
// Function: CString UIMemory::GetCurrentSymbol(void)
// Description: Gets the address or symbol which appears in the Address edit box in the memory window
// Return: CString that contains the address or symbol which appears in the Address edit box in the memory window
// Param: No Params
// END_HELP_COMMENT
CString UIMemory::GetCurrentSymbol(void)
{
	CString symbol;
	Activate();

	if(!IsActive())
	{
		LOG->RecordInfo("ERROR in UIMemory::GetCurrentSymbol(): Memory window not active");
		return (CString)"";
	}

	if(!MST.WEditExists(GetLocString(IDSS_MEMORY_ADDRESS_EDIT)))
	{
		LOG->RecordInfo("ERROR in UIMemory::GetCurrentSymbol(): The Address edit box does not exist");
		return (CString)"";
	}

	MST.WEditSetFocus(GetLocString(IDSS_MEMORY_ADDRESS_EDIT));
	MST.WEditText(GetLocString(IDSS_MEMORY_ADDRESS_EDIT), symbol);

	return symbol;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIMemory::ToogleReEvaluation(void)
// Description: Toggles Re-evaluation in memory window
// Param: No Params
// Return: A Boolean value that indicates whether the toggle operatin was sucessfull (TRUE) or not.
// END_HELP_COMMENT

BOOL UIMemory::ToogleReEvaluation(void)
{

	UIOptionsTabDlg uiopt;
	uiopt.Display();
	uiopt.ShowPage(TAB_DEBUG, 6);

	// Check the status of the "Hexadecimal display" check box
	int stat = MST.WCheckState("@9");
	if(0 == stat)
		MST.WCheckCheck("@9");
	else
		MST. WCheckUnCheck("@9");
	uiopt.OK();
	return TRUE;

}



// BEGIN_HELP_COMMENT
// Function: BOOL UIMemory::CycleMemoryFormat(int count)
// Description: Cycles though memory formats
// Param: count A number of "Next Format" changes that will be done 
// Return: A Boolean value that indicates whether the cycle operatin was sucessfull (TRUE) or not..
// END_HELP_COMMENT

BOOL UIMemory::CycleMemoryFormat(int count)
{

	for(int ii = 0; ii < count; ii++)
	{
		// Do cycle using hot keys
		MST.DoKeys("+%({F11})");
	
		// Change m_MemoryFormat
		switch(m_MemoryFormat)
		{
		case MEM_FORMAT_ASCII:
			m_MemoryFormat = MEM_FORMAT_INT64_UNSIGNED;
			break;
		case MEM_FORMAT_WCHAR:
			m_MemoryFormat = MEM_FORMAT_ASCII;		
			break;
		case MEM_FORMAT_BYTE:
			m_MemoryFormat = MEM_FORMAT_WCHAR;		
			break;
		case MEM_FORMAT_SHORT:
			m_MemoryFormat = MEM_FORMAT_BYTE;		
			break;
		case MEM_FORMAT_SHORT_HEX:
			m_MemoryFormat = MEM_FORMAT_SHORT;		
			break;
		case MEM_FORMAT_SHORT_UNSIGNED:
			m_MemoryFormat = MEM_FORMAT_SHORT_HEX;		
			break;
		case MEM_FORMAT_LONG:
			m_MemoryFormat = MEM_FORMAT_SHORT_UNSIGNED;		
			break;
		case MEM_FORMAT_LONG_HEX:
			m_MemoryFormat = MEM_FORMAT_LONG;		
			break;
		case MEM_FORMAT_LONG_UNSIGNED:
			m_MemoryFormat = MEM_FORMAT_LONG_HEX;		
			break;
		case MEM_FORMAT_REAL:
			m_MemoryFormat = MEM_FORMAT_LONG_UNSIGNED;		
			break;
		case MEM_FORMAT_REAL_LONG:
			m_MemoryFormat = MEM_FORMAT_REAL;		
			break;
		case MEM_FORMAT_INT64:
			m_MemoryFormat = MEM_FORMAT_REAL_LONG;		
			break;
		case MEM_FORMAT_INT64_HEX:
			m_MemoryFormat = MEM_FORMAT_INT64;		
			break;
		case MEM_FORMAT_INT64_UNSIGNED:
			m_MemoryFormat = MEM_FORMAT_INT64_HEX;		
			break;
		}
			
	}

	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIMemory::ToggleDockingView()
// Description: Toggles the Docking View for memory window
// Return: A Boolean value that indicates whether the toggle operatin was sucessfull (TRUE) or not.
// END_HELP_COMMENT

BOOL UIMemory::ToggleDockingView()
{
	Activate();

	if(!IsActive())
		{
		LOG->RecordInfo("ERROR in UIMemory::ToggleDockingView(): Memory window not active");
		return FALSE;
		}
	// Bring up the popup context menu
	MST.DoKeys("+({F10})");
	//Go to the "Docking view" menu item
	MST.DoKeys("{DOWN 5}");

	// Toggle it
	MST.DoKeys("{ENTER}");

	return TRUE;
}




// BEGIN_HELP_COMMENT
// Function: BOOL UIMemory::EnableDockingView(BOOL bEnable)
// Description: Enables or disables the Docking View for memory window
// Param: bEnable If the parameter is TRUE, Docking View will be enabled. If FALSE - disabled.
// Return: A Boolean value that indicates whether the toggle operatin was sucessfull (TRUE) or not.
// END_HELP_COMMENT

BOOL UIMemory::EnableDockingView(BOOL bEnable)
{
	Activate();

	if(!IsActive())
		{
		LOG->RecordInfo("ERROR in UIMemory::EnableDockingView(): Memory window not active");
		return FALSE;
		}

	if((IsDockingViewEnabled() && bEnable) || (!IsDockingViewEnabled() && !bEnable))
		return TRUE;

	// Bring up the popup context menu
	MST.DoKeys("+({F10})");
	//Go to the "Docking view" menu item
	MST.DoKeys("{DOWN 5}");

	// Toggle it
	MST.DoKeys("{ENTER}");

	// Check that the window was enabled/disabled
	if((IsDockingViewEnabled() && bEnable) || (!IsDockingViewEnabled() && !bEnable))
		return TRUE;
	else 
		return FALSE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIMemory::IsDockingViewEnabled(BOOL bEnable)
// Description: Check if Docking View is enabled for memory window
// Param: No Params
// Return: A Boolean value that indicates whether Docking View is enabled (TRUE) or not.
// END_HELP_COMMENT

BOOL UIMemory::IsDockingViewEnabled(void)
{
	BOOL bResult, bInitiallyMaximized;
	CString csTitle;

	Activate();

	if(!IsActive())
		{
		LOG->RecordInfo("ERROR in UIMemory::IsDockingViewEnabled(): Memory window not active");
		return FALSE;
		}

	HWND hwnd = HWnd();

	// Compiler gives the error that WIsMaximized is not a member of MSTest, so we use standard Windows function
	//if(MST.WIsMaximized(hwnd))
	if(IsZoomed(hwnd))
		bInitiallyMaximized = TRUE;
	else 
	{
		bInitiallyMaximized = FALSE;
		// MSTest.WMaxWnd doesn't work here for some reason, so we use standard Windows function
		// MST.WMaxWnd(hwnd);
		ShowWindow(hwnd, SW_MAXIMIZE);
	}

	MST.WGetText(UIWB.HWnd(), csTitle);
	if(-1 == csTitle.Find("["+ GetLocString(IDSS_MEM_WND_TITLE)+"]"))
		bResult = TRUE;
	else
		bResult = FALSE;


	if(!bInitiallyMaximized)
		// Compiler gives the error that WResWnd is not a member of MSTest, so we use standard Windows function
		//MST.WResWnd(hwnd);
		ShowWindow(hwnd, SW_RESTORE);

	return bResult;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uireg.h ===
///////////////////////////////////////////////////////////////////////////////
//  UIREG.H
//
//  Created by :            Date :
//      WayneBr             1/14/94
//
//  Description :
//      Declaration of the UIRegisters class
//

#ifndef __UIREG_H__
#define __UIREG_H__

#include "..\sym\qcqp.h"
#include "..\shl\udockwnd.h"

#include "dbgxprt.h"

#ifndef __UIDOCKWND_H__
	#error include 'udockwnd.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//  UIRegisters symbols

// enums must start at 1
const MaxReg=24;   

// Intel Specific
enum {EAX=1 , EBX , ECX , EDX , ESI , EDI , EIP , EBP , ESP , EFL , CS , DS , ES , SS , FS , GS };

// 68k Specific
enum {D0=1, D1, D2, D3, D4, D5, D6, D7,
	   A0,   A1, A2, A3, A4, A5, A6, A7,
	   PC,   SR,  X,  N,  Z,  V,  C };


///////////////////////////////////////////////////////////////////////////////
//  UIRegisters class

// BEGIN_CLASS_HELP
// ClassName: UIRegisters
// BaseClass: UIDockWindow
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS UIRegisters : public UIDockWindow

	{
	UIWND_COPY_CTOR(UIRegisters, UIDockWindow);

	virtual BOOL Activate(void);
	virtual UINT GetID(void) const
		{	return IDW_CPU_WIN; }

	virtual BOOL AttachActive(void);
	virtual BOOL Find(void);

	// Initialization
	public:

	// Data
	private:
		int m_option;

	// UIWindow overrides
	public:
		virtual BOOL IsValid(void) const;
		virtual BOOL IsActive(void);	// derived classes must provide their own Activate (usually a DoCommand)


	// Utilities
	public:
		int GetRegister(int reg);
		BOOL SetRegister(int reg, LPCSTR value);

		BOOL ToggleFloatingPoint(void);
		CString GetRegister(CString csRegister, int *pnValue);
		BOOL SetRegister(CString csRegister, CString szValue, int nValue, BOOL bValueIsCString = TRUE);
		BOOL RegisterDisplayed(CString csRegister);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uistack.h ===
///////////////////////////////////////////////////////////////////////////////
//  UISTACK.H
//
//  Created by :            Date :
//      WayneBr             1/14/94
//
//  Description :
//      Declaration of the UIStack class
//

#ifndef __UISTACK_H__
#define __UISTACK_H__

#include "..\sym\qcqp.h"
#include "..\shl\udockwnd.h"

#include "dbgxprt.h"

#ifndef __UIDOCKWND_H__
	#error include 'udockwnd.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//  UIStack class : public UIDockWindow

// BEGIN_CLASS_HELP
// ClassName: UIStack
// BaseClass: UIDockWindow
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS UIStack : public UIDockWindow
	{
	UIWND_COPY_CTOR(UIStack, UIDockWindow);

	virtual BOOL Activate(void);
	virtual UINT GetID(void) const
		{	return IDW_CALLS_WIN; }

	virtual BOOL AttachActive(void);
	virtual BOOL Find(void);

	// Initialization
	public:

	// Data
	private:
		int m_option;

	// UIWindow overrides
	public:
		virtual BOOL IsValid(void) const;
		virtual BOOL IsActive(void);	// derived classes must provide their own Activate (usually a DoCommand)


	// Utilities
	public:
		CString GetFunction(int level = 0);
		CString GetAllFunctions(void);
		int  NavigateStack(int level = 0);
		BOOL GoToFrame(int level);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uireg.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UIREG.CPP
//
//  Created by :            Date :
//      WayneBr                 1/14/94
//
//  Description :
//      Implementation of the UIRegisters class
//

#include "stdafx.h"
#include "uireg.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\cmdids.h"
#include "..\shl\uwbframe.h"
#include "..\shl\wbutil.h"
#include "Strings.h"
#include "..\sym\reg.h"
#include "..\SRC\cosource.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: BOOL UIRegisters::IsValid(void) const
// Description: Determine if the registers window is a valid window.
// Return: A Boolean that indicates whether the registers window is valid (TRUE) or not.
// END_HELP_COMMENT
BOOL UIRegisters::IsValid(void) const
	{
	return UIWindow::IsValid();
	}

// BEGIN_HELP_COMMENT
// Function: BOOL UIRegisters::AttachActive(void)
// Description: Attach to the registers window if it's the active window.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIRegisters::AttachActive(void)
	{
	HWND hwnd;

    if(hwnd = MST.WFndWndWait(GetLocString(IDSS_REG_WND_TITLE), FW_FULL, 2))
		return Attach(hwnd);
	else
		return Attach(FindFirstChild(UIWB.HWnd(), IDW_CPU_WIN));
	}

// BEGIN_HELP_COMMENT
// Function: BOOL UIRegisters::Find(void)
// Description: Find the registers window and attach to it
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIRegisters::Find(void)
	{
	int pkgId ;
	switch(GetID())
	{
	case 0:
		pkgId = 0 ;
		break ;
	case IDDW_PROJECT:
		pkgId = PACKAGE_VPROJ ;
		break;
	case IDW_LOCALS_WIN: 
		pkgId = PACKAGE_VCPP ;
		break ;
	default:
		break;
	}
	return Attach(UIWB.GetToolbar(GetID(),pkgId));
	}

// BEGIN_HELP_COMMENT
// Function: BOOL UIRegisters::IsActive(void)
// Description: Determine if the registers window is active.
// Return: A Boolean value that indicates whether the registers window is active (TRUE) or not.
// END_HELP_COMMENT
BOOL UIRegisters::IsActive(void)
	{
	HWND hwnd = MST.WGetFocus();
	return (hwnd == HWnd()) || IsChild(HWnd(), hwnd);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL UIRegisters::Activate(void)
// Description: Bring up the registers window.
// Return: A Boolean value that indicates whether the registers window is active (TRUE) or not.
// END_HELP_COMMENT
BOOL UIRegisters::Activate(void)
{
	UIWB.DoCommand(IDM_VIEW_REGS, DC_MNEMONIC);
	return AttachActive();
}

// BEGIN_HELP_COMMENT
// Function: void UIRegisters::ToggleFloatingPoint(void)
// Description: Toggles the Floating Point menu item in the Registers window context menu 
// Return: A Boolean value that indicates whether the Floating Point menu item was toggled successfully (TRUE) or not.
// END_HELP_COMMENT
BOOL UIRegisters::ToggleFloatingPoint(void)
{
	
	// Verify that window is active
	if(!IsActive())
		return FALSE;

	// Bring up the popup context menu
	MST.DoKeys("+({F10})");

	//Go to the desired menu item
	MST.DoKeys("{DOWN}");

	// Toggle it
	MST.DoKeys("{ENTER}");

	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: int UIRegisters::GetRegister(int reg)
// Description: Get the value of one of the registers in the registers window.
// Return: An integer that contains the value of the specified register.
// Param: reg An integer that specifies the 1-based index into the set of registers.
// END_HELP_COMMENT
int  UIRegisters::GetRegister(int reg)
	{
	ASSERT(reg <= MaxReg);
	char buffer[10];
	CString count=itoa(reg,buffer,10);
	CString Keys = "^{HOME}{TAB "+count+"}+{END}^(c)";
	MST.DoKeys(Keys);
	CString cstr;
	GetClipText(cstr);
	return (atoi(cstr));
	};

// BEGIN_HELP_COMMENT
// Function: CString UIRegisters::GetRegister(CString csRegister, int *pnValue)
// Description: Get the value of one of the registers.
// Return: A CString that contains the value of the specified register.
// Param : CString csRegister a string that specifies the register
// Param int* pnValue A pointer to integer that contains the value of the specified register.
// END_HELP_COMMENT
CString UIRegisters::GetRegister(CString csRegister, int *pnValue)

{
	CString csReturnedValue;
	CString csRegisterInfo;
	char szRegisterInfo[4096];
	char *ptr;

	// Verify that window is active
	if(!IsActive())
		return CString("");

	// Find the register
	CString Keys = "^{END}^(+{HOME})^(c)";
	MST.DoKeys(Keys);

	// TODO(dklem - 8/2/99): without this we get the text that was previously in the clipboard.
	Sleep(500);

	// Get text from Clipboard
	GetClipText(csRegisterInfo);
	lstrcpyn(szRegisterInfo, LPCTSTR(csRegisterInfo), sizeof(szRegisterInfo));

	// Now remove the selection
	MST.DoKeys("^{HOME}");	

	// need to distinguish between EI and EIP.
	if(csRegister == "EI")
		csRegister = "EI=";
	// need to distinguish between ES and ESI.
	else if(csRegister == "ES")
		csRegister = "ES =";
	//xbox need to work around flag AC because it might be found inside a hex value
	else if (csRegister == "AC")
		csRegister = "AC=";

	if(NULL == (ptr = strstr(szRegisterInfo, LPCTSTR(csRegister))))
	{
		LOG->RecordInfo( (LPCSTR) "Can not find register %s in Registry window", LPCTSTR(csRegister));
		return CString("");
	}

	// Find the register in the returned string
	ptr = strstr(ptr, "=");
	while(*(++ptr) == ' ');

	// Find the next space
	for(int ii = 0; *(ptr + ii) != '\0'; ii++)
	{
		if(*(ptr + ii) == ' ' || *(ptr + ii) == '\r')
		{
			*(ptr + ii) = '\0';
			break;
		}
	}

	// Fill the CString return value
	csReturnedValue = ptr;

	// Set the int return value
	if(pnValue)
	{
		char *stop;
		*pnValue = strtol(ptr, &stop, 16);
	}

	return csReturnedValue;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIRegisters::SetRegister(int reg, LPCSTR value)
// Description: Set the value of the specified register in the registers window.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: reg An integer that specifies the 1-based index into the set of registers.
// Param: value A pointer to a string that contains the value to set the specified register to.
// END_HELP_COMMENT
BOOL UIRegisters::SetRegister(int reg, LPCSTR value)
	{
	ASSERT(reg <= MaxReg);
	char buffer[10];
	CString count=itoa(reg,buffer,10);
	CString Keys = "^{HOME}{TAB "+count+"}";
	MST.DoKeys(Keys);
	// call func that excapes the dokeys controls chars use TRUE flag
	MST.DoKeys(value,TRUE);
	return TRUE;
	};


// BEGIN_HELP_COMMENT
// Function: BOOL IUIRegisters::SetRegister(CString csRegister, CString szValue, int nValue, BOOL bValueIsCString = TRUE)
// Description: Set the value of the specified register.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param : CString csRegister CString that specifies the register to be set
// Param : CString szValue A CString that contains the value to set the specified register to
// Param : int nValue An int that contains the value to set the specified register to
// Param : bValueIsCString A BOOL that indicats if value is represented in the form of CString (TRUE) or int
// END_HELP_COMMENT
BOOL UIRegisters::SetRegister(CString csRegister, CString szValue, int nValue, BOOL bValueIsCString /* TRUE */)
{
	CString csRegisterInfo;
	char szRegisterInfo[4096];
	char szRegister[128];
	char *ptr;

	int ii;
	int nLine = 0;
	int nColumn = 0;
	int nNewLinePos = 0;

	// Verify that window is active
	if(!IsActive())
		return FALSE;

	// Find the register
	// MST.DoKeys("^{HOME}");	
	// MST.DoKeys("^+{END}");	
	// MST.DoKeys("^C");	

	CString Keys = "^{END}^(+{HOME})^(c)";
	MST.DoKeys(Keys);

	// TODO(dklem - 8/2/99): without this we get the text that was previously in the clipboard.
	Sleep(500);

	// Get text from Clipboard
	GetClipText(csRegisterInfo);
	lstrcpyn(szRegisterInfo, LPCTSTR(csRegisterInfo), sizeof(szRegisterInfo));

	// Now remove the selection
	MST.DoKeys("^{HOME}");	

	// need to distinguish between EI and EIP.
	if(csRegister == "EI")
		csRegister = "EI=";
	// need to distinguish between ES and ESI.
	else if(csRegister == "ES")
		csRegister = "ES =";

	if(NULL == (ptr = strstr(szRegisterInfo, LPCTSTR(csRegister))))
	{
		LOG->RecordInfo( (LPCSTR) "Can not find register %s in Registry window", LPCTSTR(csRegister));
		return FALSE;
	}

	// Now we need to find the line that containd the string
	for(ii = 0; *(szRegisterInfo + ii) != '\0' && ((szRegisterInfo + ii) < ptr); ii++)
	{
		if(*(szRegisterInfo + ii) == '\n')
		{
			nLine++;
			nNewLinePos = ii;
		}
	}

	// Now we need to find the column (or offset from the begining of the line in other words)
	for(ii = nNewLinePos; *(szRegisterInfo + ii) != '\0' && ((szRegisterInfo + ii) < ptr); ii++)
	{
		if(*(szRegisterInfo + ii) == '=')
			nColumn++;
	}

	// We counted how many '='s were before the register we are looking for.  So the correct column will be the next '='
	nColumn++;

	// Now locate the caret at the correct position
	MST.DoKeys("^{HOME}");	

	// Down
	for(ii = 0; ii < nLine; ii++)
		MST.DoKeys("{DOWN}");	
	// Right
	for(ii = 0; ii < nColumn; ii++)
		MST.DoKeys("{TAB}");	

	// Type string
	if(bValueIsCString)
		MST.DoKeys(szValue, TRUE);
	else
	{
		sprintf(szRegister, "%x", nValue);
		MST.DoKeys(szRegister);	
	}

	return TRUE;
}

// BEGIN_HELP_COMMENT
// added by dverma 3/21/2000
// Function: BOOL UIRegisters::RegisterExists(CString csRegister)
// Description: Checks whether the given register is displayed in the registers window
// Return: A Boolean that indicates whether the given register was displayed or not
// Param : CString that specifies the register to checked
// END_HELP_COMMENT
BOOL UIRegisters::RegisterDisplayed(CString csRegister)
{
	CString csRegisterInfo;
	char szRegisterInfo[4096];

	// Verify that window is active
	if(!IsActive())
	{
		LOG->RecordInfo( (LPCSTR) "UIReg failure : Register Window Not Active.");
		return FALSE;
	}

	CString Keys = "^{END}^(+{HOME})^(c)";
	MST.DoKeys(Keys);

	// TODO(dklem - 8/2/99): without this we get the text that was previously in the clipboard.
	Sleep(500);

	// Get text from Clipboard
	GetClipText(csRegisterInfo);
	lstrcpyn(szRegisterInfo, LPCTSTR(csRegisterInfo), sizeof(szRegisterInfo));

	// Now remove the selection
	MST.DoKeys("^{HOME}");	

	// need to distinguish between EI and EIP.
	if(csRegister == "EI")
		csRegister = "EI=";
	// need to distinguish between ES and ESI.
	else if(csRegister == "ES")
		csRegister = "ES =";

	//	need to check for MM strings as they may be wrongly detected as part of XMM
	if (csRegister.GetLength() > 2)
	{
		if ((csRegister[0] == 'M') && (csRegister[1] == 'M'))
			csRegister = " " + csRegister;
	}

	if(NULL == strstr(szRegisterInfo, LPCTSTR(csRegister)))
		return FALSE;
	else 
		return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uistack.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UISTACK.CPP
//
//  Created by :            Date :
//      WayneBr                 1/14/94
//
//  Description :
//      Implementation of the UIStack class
//

#include "stdafx.h"
#include "uistack.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\cmdids.h"
#include "..\shl\uwbframe.h"
#include "..\shl\wbutil.h"
#include "Strings.h"
#include "..\sym\reg.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


// BEGIN_HELP_COMMENT
// Function: CString UIStack::GetFunction(int level /* 0 */)
// Description: Get the call stack description string at the given call stack level (index).
// Return: A CString that contains the call stack description string from the given call stack level.
// Param: level An integer that contains the 0-based index into the call stack. (Default value is 0.)
// END_HELP_COMMENT
CString UIStack::GetFunction(int level /* 0 */)
	{
	char buffer[10];
	CString count=itoa(level,buffer,10);
	CString Keys = "^{HOME}{DOWN "+count+"}+{END}^(c)";
	MST.DoKeys(Keys);
	CString cstr;
	GetClipText(cstr);
	return cstr;
	};

// BEGIN_HELP_COMMENT
// Function: CString UIStack::GetAllFunctions(void)
// Description: Get all the call stack frame descriptions for all frames on the call stack.
// Return: A CString that contains a newline-delimited list of call stack frames.
// END_HELP_COMMENT
CString UIStack::GetAllFunctions(void)
	{
	//
	//	Reverse selection sequence to workaround ORCA #171
//	CString Keys = "^{HOME}^(+{END})^(c)";
	CString Keys = "^{END}^(+{HOME})^(c)";

	MST.DoKeys(Keys);
	CString cstr;
	GetClipText(cstr);
	return cstr;
	};
#include "costack.h"
// BEGIN_HELP_COMMENT
// Function: int UIStack::NavigateStack(int level /* 0 */)
// Description: Navigate to the specified call stack frame & checks if the line number is correct.
// Return: A int value that indicates success. -1 if no source file is avail; 0 if not success (line number does not match). >0 - line number
// Param: level An integer that contains the 0-based index into the call stack. (Default value is 0.)
// END_HELP_COMMENT
int UIStack::NavigateStack(int level /* 0 */)
{
	CString str=GetFunction(level); //puts the cursor to the "level" frame
	// turn off automatic msg handling so we can detect find source and return appropriately.
	// emmang@xbox - SetHandleMsgs(FALSE) does not appear to be working properly,
	// if FindSource dialog is thrown up, m_pTarget	still handles it (with ESC)
	UIWB.m_pTarget->SetHandleMsgs(FALSE);
	MST.DoKeys("{ENTER}");
	// wait up to 2 seconds to cancel Find Source dlg
	if(WaitForWndWithCtrl(IDSS_CANCEL)  /* = 3000*/)// MST.WFndWndWait(GetLocString(IDSS_FS_TITLE), FW_DEFAULT, 2))
	{
		MST.WButtonClick(GetLocString(IDSS_CANCEL)); //didn't find source
		LOG->RecordInfo("NavigateStack - frame no:%d '%s'. No source file available", level, str);
		UIWB.m_pTarget->SetHandleMsgs(TRUE);
	}
	else
	{ // verification of the line number we ended up on
		UIWB.m_pTarget->SetHandleMsgs(TRUE);
		Frame frame( str );
		if(frame.GetLineNumber( str ))
		{
			int nline = UIWB.GetEditorCurPos(GECP_LINE); /*GetLineNumber()*/
			if(nline == atoi(str) )
				return nline;
			else
			{
				LOG->RecordInfo("ERROR: NavigateStack - frame no:%d '%s'. expected line %s, hit line %d", level, frame, str, nline);
				return 0;
			}
		}
		else
			LOG->RecordInfo("NavigateStack - frame no:%d '%s' - no line number", level, frame);
	}
	return -1;
};


// BEGIN_HELP_COMMENT
// Function: BOOL UIStack::GoToFrame(int level)
// Description: Go to to the specified call stack frame.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: level An integer that contains the 0-based index into the call stack.
// END_HELP_COMMENT
BOOL UIStack::GoToFrame(int level)

	{
	char szkeys[64];
	if(level<0)level=0;
	sprintf(szkeys, "^({HOME}){DOWN %d}", level);
	MST.DoKeyshWnd(HWnd(), szkeys);

	// verification here
	return TRUE;
	};


// BEGIN_HELP_COMMENT
// Function: BOOL UIStack::IsValid(void) const
// Description: Determine if the call stack window is a valid window.
// Return: A Boolean that indicates whether the call stack window is valid (TRUE) or not.
// END_HELP_COMMENT
BOOL UIStack::IsValid(void) const
	{
	return UIWindow::IsValid();
	}

// BEGIN_HELP_COMMENT
// Function: BOOL UIStack::AttachActive(void)
// Description: Attach to the call stack window if it's the active window.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIStack::AttachActive(void)
	{
	HWND hwnd;

    if(hwnd = MST.WFndWndWait(GetLocString(IDSS_STACK_WND_TITLE), FW_FULL, 2))
		return Attach(hwnd);
	else
		return Attach(FindFirstChild(UIWB.HWnd(), IDW_CALLS_WIN));
	}

// BEGIN_HELP_COMMENT
// Function: BOOL UIStack::Find(void)
// Description: Find the call stack window and attach to it
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIStack::Find(void)
	{
	int pkgId ;
	switch(GetID())
	{
	case 0:
		pkgId = 0 ;
		break ;
	case IDDW_PROJECT:
		pkgId = PACKAGE_VPROJ ;
		break;
	case IDW_LOCALS_WIN: 
		pkgId = PACKAGE_VCPP ;
		break ;
	default:
		break;
	}
	return Attach(UIWB.GetToolbar(GetID(),pkgId));
	}

// BEGIN_HELP_COMMENT
// Function: BOOL UIStack::IsActive(void)
// Description: Determine if the call stack window is active.
// Return: A Boolean value that indicates whether the call stack window is active (TRUE) or not.
// END_HELP_COMMENT
BOOL UIStack::IsActive(void)
	{
	HWND hwnd = MST.WGetFocus();
	return (hwnd == HWnd()) || IsChild(HWnd(), hwnd);
	}

// BEGIN_HELP_COMMENT
// Function: BOOL UIStack::Activate(void)
// Description: Bring up the call stack window.
// Return: A Boolean value that indicates whether the call stack window is active (TRUE) or not.
// END_HELP_COMMENT
#include "guitarg.h"
BOOL UIStack::Activate(void)
{
	UIWB.DoCommand(IDM_VIEW_STACK, DC_MNEMONIC);
	// we're hitting a timing problem where the callstack window doesn't come up fast enough so we
	// grab text from the wrong window to verify function information (usually the src or asm windows).
	Sleep(100);
	return AttachActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uithread.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UITHREAD.CPP
//
//  Created by :            Date :
//      WayneBr                 1/14/94
//
//  Description :
//      Implementation of the UIThreads class
//

#include "stdafx.h"
#include "uithread.h"
#include "testxcpt.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\cmdids.h"
#include "..\sym\vcpp32.h"
#include "..\shl\uwbframe.h"
#include "guiv1.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


// BEGIN_HELP_COMMENT
// Function: BOOL UIThreads::Activate(void)
// Description: Open the Threads dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIThreads::Activate(void)
{
	UIWB.DoCommand(IDM_RUN_THREADS, DC_MNEMONIC);
	if (WaitAttachActive(5000)) {
		return TRUE;
	}
	return FALSE;
}

// BEGIN_HELP_COMMENT
// Function: CString UIThreads::ThreadToString(DWORD thread)
// Description: Convert a thread ID value to a string. For example, the thread value 0x95 is converted to the string 00000095.
// Return: A CString that contains the thread value converted to a string.
// Param: thread An unsigned long that contains the thread value.
// END_HELP_COMMENT
CString UIThreads::ThreadToString(DWORD thread)
	{
	CString sThread;
	sprintf(sThread.GetBuffer(255), "%.8x", thread);
	return sThread;
	};

// BEGIN_HELP_COMMENT
// Function: BOOL UIThreads::FreezeThread(DWORD thread)
// Description: Suspend the specified thread.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: thread An unsigned long that contains the thread ID of the thread to suspend.
// END_HELP_COMMENT
BOOL UIThreads::FreezeThread(DWORD thread)
	{
	CString sListItem;
	CString sThread = ThreadToString(thread);
	EXPECT(IsActive() && MST.WListEnabled(GetLabel(VCPP32_DLG_THREAD_LIST)));
	int limit = MST.WListCount(GetLabel(VCPP32_DLG_THREAD_LIST));
	for (int x=1; x< limit; x++)
	{
		MST.WListItemText(GetLabel(VCPP32_DLG_THREAD_LIST), x, sListItem);
		if (sListItem.Find(sThread) != -1 ) { break; };   // is thread in list item?
	};
	if ( x > limit )  return FALSE;      //thread not found
	MST.WListItemClk(GetLabel(VCPP32_DLG_THREAD_LIST), x);
	EXPECT(IsActive() && MST.WButtonEnabled(GetLabel(VCPP32_DLG_THREAD_SUSPEND)));
	MST.WButtonClick(GetLabel(VCPP32_DLG_THREAD_SUSPEND));
	return TRUE;
	};

// BEGIN_HELP_COMMENT
// Function: BOOL UIThreads::ThawThread(DWORD thread)
// Description: Resume the specified thread.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: thread An unsigned long that contains the thread ID of the thread to resume.
// END_HELP_COMMENT
BOOL UIThreads::ThawThread(DWORD thread)
	{
	CString sListItem;
	CString sThread = ThreadToString(thread);
	EXPECT(IsActive() && MST.WListEnabled(GetLabel(VCPP32_DLG_THREAD_LIST)));
	int limit = MST.WListCount(GetLabel(VCPP32_DLG_THREAD_LIST));
	for (int x=1; x< limit; x++)
	{
		MST.WListItemText(GetLabel(VCPP32_DLG_THREAD_LIST), x, sListItem);
		if (sListItem.Find(sThread) != -1 ) { break; };   // is thread in list item?
	};
	if ( x > limit )  return FALSE;      //thread not found
	MST.WListItemClk(GetLabel(VCPP32_DLG_THREAD_LIST), x);
	EXPECT(IsActive() && MST.WButtonEnabled(GetLabel(VCPP32_DLG_THREAD_RESUME)));
	MST.WButtonClick(GetLabel(VCPP32_DLG_THREAD_RESUME));
	return TRUE;
	};

// BEGIN_HELP_COMMENT
// Function: BOOL UIThreads::SetCurrentThread(DWORD thread)
// Description: Set the specified thread to be the current thread.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: thread An unsigned long that contains the thread ID of the thread to activate.
// END_HELP_COMMENT
BOOL UIThreads::SetCurrentThread(DWORD thread)
	{
	CString sListItem;
	CString sThread = ThreadToString(thread);
	EXPECT(IsActive() && MST.WListEnabled(GetLabel(VCPP32_DLG_THREAD_LIST)));
	int limit = MST.WListCount(GetLabel(VCPP32_DLG_THREAD_LIST));
	for (int x=1; x< limit; x++)
	{
		MST.WListItemText(GetLabel(VCPP32_DLG_THREAD_LIST), x, sListItem);
		if (sListItem.Find(sThread) != -1 ) { break; };   // is thread in list item?
	};
	if ( x > limit )  return FALSE;      //thread not found
	MST.WListItemClk(GetLabel(VCPP32_DLG_THREAD_LIST), x);
	EXPECT(IsActive() && MST.WButtonEnabled(GetLabel(VCPP32_DLG_THREAD_FOCUS)));
	MST.WButtonClick(GetLabel(VCPP32_DLG_THREAD_FOCUS));
	return TRUE;
	};

// BEGIN_HELP_COMMENT
// Function: INT  UIThreads::GetCurrentThread(void)
// Description: Get the thread ID of the currently active thread.
// Return: An unsigned long that specifies the currently active thread.
// END_HELP_COMMENT
DWORD  UIThreads::GetCurrentThread(void)   //assumes first item in listbox is current thread.
	{
	CString sListItem;
	EXPECT(IsActive() && MST.WListEnabled(GetLabel(VCPP32_DLG_THREAD_LIST)));
	int limit = MST.WListCount(GetLabel(VCPP32_DLG_THREAD_LIST));
	for (int x=1; x< limit; x++)
	{
		MST.WListItemText(GetLabel(VCPP32_DLG_THREAD_LIST), x, sListItem);
		if (sListItem[0]=='*' ) { break; };   // this thread has the focus
	};
	ASSERT(x <= limit);
	CString sThread= sListItem.Mid(1,8);
	return strtoul(sThread,NULL,10);
	};


// BEGIN_HELP_COMMENT
// Function: BOOL UIThreads::GetThreadInfo(CThreadInfo& ThreadInfo)
// Description: Gets info about the specified thread from the Threads dlg.
// Return: A boolean value that indicates success or failure. TRUE if successful, FALSE if not.
// Param: ThreadInfo - A CThreadInfo object that receives information about the thread. The strID field of this object specifies for which thread to get info.
// END_HELP_COMMENT
BOOL UIThreads::GetThreadInfo(CThreadInfo& ThreadInfo)

{
	char szThisFunction[] = "UIThreads::GetThreadInfo";

	// verify threads dlg is up.
	if(!IsActive())
	{
		LOG->RecordInfo("ERROR in %s: threads dlg isn't active.", szThisFunction);
		return FALSE;
	}

	// stores the line of info for a thread in the threads list.
	CString strThreadInfo;
	int intThreadCount = MST.WListCount("@1");

	// search each thread info line in the list until we find the one containing the specified ID.
	for(int intThread = 1; intThread <= intThreadCount; intThread++)
	
	{
		// get the line containing the next thread's info.
		MST.WListItemText("@1", intThread, strThreadInfo);
		
		// verify that the string is long enough to contain a valid thread id 
		// (8 hex digits, prepended by 1 char for the focus state);
		if(strThreadInfo.GetLength() < 9)
		{
			LOG->RecordInfo("ERROR in %s: thread info string %d not long enough to specify id: \"%s\".", 
				szThisFunction, intThread, strThreadInfo);
			return FALSE;
		}

		// check if we found the matching thread id.
		if(strThreadInfo.Mid(1, 8) == ThreadInfo.strID)
			break;
	}
	
	// verify that we found the specified thread in the list.
	if(intThread > intThreadCount)
	{
		LOG->RecordInfo("ERROR in %s: thread with ID %s does not exist.", szThisFunction, ThreadInfo.strID);
		return FALSE;
	}

	// determine the focus state.
	if(strThreadInfo[0] == '*')
		ThreadInfo.bHasFocus = TRUE;
	else
		ThreadInfo.bHasFocus = FALSE;

	// truncate the string to the left of the suspend count.
	strThreadInfo = strThreadInfo.Right(strThreadInfo.GetLength() - 10);

	// make sure the string is long enough to hold the suspend count.
	if(strThreadInfo.GetLength() < 1)
	{
		LOG->RecordInfo("ERROR in %s: thread info string not long enough to specify suspend count: \"%s\".", 
			szThisFunction, strThreadInfo);
		return FALSE;
	}

	// find the space that terminates the suspend count.
	int iSpace = strThreadInfo.Find(" ");

	// make sure we found it.
	if(iSpace == -1)
	{
		LOG->RecordInfo("ERROR in %s: couldn't find space that terminates suspend count: \"%s\".", 
			szThisFunction, strThreadInfo);
		return FALSE;
	}

	// extract the suspend count.
	ThreadInfo.intSuspend = atoi(strThreadInfo.Mid(0, iSpace));	
	// truncate the string to the left of the priority.
	strThreadInfo = strThreadInfo.Right(strThreadInfo.GetLength() - iSpace - 1);
	strThreadInfo.TrimLeft();
	// find the space that terminates the priority count.
	iSpace = strThreadInfo.Find(" ");

	// make sure we found it.
	if(iSpace == -1)
	{
		LOG->RecordInfo("ERROR in %s: couldn't find space that terminates priority: \"%s\".", 
			szThisFunction, strThreadInfo);
		return FALSE;
	}

	// extract the priority.
	ThreadInfo.intPriority = atoi(strThreadInfo.Mid(0, iSpace));	
	// truncate the string to the left of the location.
	strThreadInfo = strThreadInfo.Right(strThreadInfo.GetLength() - iSpace - 1);
	strThreadInfo.TrimLeft();
	// the remaining string should be the location name (trim the end just in case).
	strThreadInfo.TrimRight();
	ThreadInfo.strLocation = strThreadInfo;
	
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIThreads::SetThreadFocus(LPCSTR szThreadID)
// Description: Selects a thread in the Threads dlg and clicks the Set Focus button.
// Return: A boolean value that indicates success or failure. TRUE if successful, FALSE if not.
// Param: szThreadID - A string specifying the ID of the thread to set focus to.
// END_HELP_COMMENT
BOOL UIThreads::SetThreadFocus(LPCSTR szThreadID)

{
	char szThisFunction[] = "UIThreads::SetThreadFocus";

	// select the thread.
	if(!SelectThread(szThreadID))
	{
		LOG->RecordInfo("ERROR in %s: couldn't select thread with ID '%s'.", szThisFunction, szThreadID);
		return FALSE;
	}

	// set the focus to it.
	if(MST.WButtonEnabled(GetLocString(IDSS_THREAD_SET_FOCUS)))
		MST.WButtonClick(GetLocString(IDSS_THREAD_SET_FOCUS));
	else
	{
		LOG->RecordInfo("ERROR in %s: couldn't find '%s' button in threads dlg.",
			szThisFunction, GetLocString(IDSS_THREAD_SET_FOCUS));
		return FALSE;
	}

	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIThreads::SuspendThread(LPCSTR szThreadID)
// Description: Selects a thread in the Threads dlg and clicks the Suspend button.
// Return: A boolean value that indicates success or failure. TRUE if successful, FALSE if not.
// Param: szThreadID - A string specifying the ID of the thread to suspend.
// END_HELP_COMMENT
BOOL UIThreads::SuspendThread(LPCSTR szThreadID)

{
	char szThisFunction[] = "UIThreads::SuspendThread";

	// select the thread.
	if(!SelectThread(szThreadID))
	{
		LOG->RecordInfo("ERROR in %s: couldn't select thread with ID '%s'.", szThisFunction, szThreadID);
		return FALSE;
	}

	// suspend it.
	if(MST.WButtonEnabled(GetLocString(IDSS_THREAD_SUSPEND)))
		MST.WButtonClick(GetLocString(IDSS_THREAD_SUSPEND));
	else
	{
		LOG->RecordInfo("ERROR in %s: couldn't find '%s' button in threads dlg.",
			szThisFunction, GetLocString(IDSS_THREAD_SUSPEND));
		return FALSE;
	}

	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIThreads::ResumeThread(LPCSTR szThreadID)
// Description: Selects a thread in the Threads dlg and clicks the Resume button.
// Return: A boolean value that indicates success or failure. TRUE if successful, FALSE if not.
// Param: szThreadID - A string specifying the ID of the thread to resume.
// END_HELP_COMMENT
BOOL UIThreads::ResumeThread(LPCSTR szThreadID)

{
	char szThisFunction[] = "UIThreads::ResumeThread";

	// select the thread.
	if(!SelectThread(szThreadID))
	{
		LOG->RecordInfo("ERROR in %s: couldn't select thread with ID '%s'.", szThisFunction, szThreadID);
		return FALSE;
	}

	// resume it.
	if(MST.WButtonEnabled(GetLocString(IDSS_THREAD_RESUME)))
		MST.WButtonClick(GetLocString(IDSS_THREAD_RESUME));
	else
	{
		LOG->RecordInfo("ERROR in %s: couldn't find '%s' button in threads dlg.",
			szThisFunction, GetLocString(IDSS_THREAD_RESUME));
		return FALSE;
	}

	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIThreads::SelectThread(LPCSTR szThreadID)
// Description: Selects a thread in the Threads dlg.
// Return: A boolean value that indicates success or failure. TRUE if successful, FALSE if not.
// Param: szThreadID - A string specifying the ID of the thread to select.
// END_HELP_COMMENT
BOOL UIThreads::SelectThread(LPCSTR szThreadID)

{
	char szThisFunction[] = "UIThreads::SelectThread";

	// verify threads dlg is up.
	if(!IsActive())
	{
		LOG->RecordInfo("ERROR in %s: threads dlg isn't active.", szThisFunction);
		return FALSE;
	}

	// stores the line of info for a thread in the threads list.
	CString strThreadInfo;
	int intThreadCount = MST.WListCount("@1");

	// search each thread info line in the list until we find the one containing the ID.
	for(int intThread = 1; intThread <= intThreadCount; intThread++)
	
	{
		// get the line containing the next thread's info.
		MST.WListItemText("@1", intThread, strThreadInfo);
		
		// check if we found the matching thread ID.
		if(strThreadInfo.Find(szThreadID) != -1)
		{
			// select the thread in the dlg.
			MST.WListItemClk("@1", intThread);
			return TRUE;
		}
	}

	LOG->RecordInfo("ERROR in %s: couldn't find thread with ID \"%s\".", szThisFunction, szThreadID);
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uithread.h ===
///////////////////////////////////////////////////////////////////////////////
//  UITHREAD.H
//
//  Created by :            Date :
//      WayneBr             1/14/94
//
//  Description :
//      Declaration of the UIThreads class
//

#ifndef __UITHREAD_H__
#define __UITHREAD_H__

#include "..\..\udialog.h"
#include "..\shl\wbutil.h"

#include "dbgxprt.h"

#ifndef __UIDIALOG_H__
   #error include 'udialog.h' before including this file
#endif


// BEGIN_CLASS_HELP
// ClassName: CThreadInfo
// BaseClass: none
// Category: Debug
// END_CLASS_HELP

class CThreadInfo
{
public:
	BOOL bHasFocus;
	CString strID;
	int intSuspend;
	int intPriority;
	CString strLocation;
};


///////////////////////////////////////////////////////////////////////////////
//  UIThreads class

// BEGIN_CLASS_HELP
// ClassName: UIThreads
// BaseClass: UIDialog
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS UIThreads : public UIDialog
	{

// base class overrides
public:	
	UIWND_COPY_CTOR (UIThreads, UIDialog) ;
	virtual CString ExpectedTitle (void) const{return GetLocString(IDSS_THREAD_TITLE);}
	virtual BOOL Activate(void);


	// Internal Utilities
	private:
	CString ThreadToString(DWORD thread);

	// Utilities
	public:
		BOOL FreezeThread(DWORD thread);
		BOOL ThawThread(DWORD thread);
		BOOL SetCurrentThread(DWORD thread);
		DWORD  GetCurrentThread(void);
		BOOL GetThreadInfo(CThreadInfo& ThreadInfo);
		BOOL SetThreadFocus(LPCSTR szThreadID);
		BOOL SuspendThread(LPCSTR szThreadID);
		BOOL ResumeThread(LPCSTR szThreadID);
		BOOL SelectThread(LPCSTR szThreadID);
	};

#endif // __UITHREAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uivar.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UIVAR.CPP
//
//  Created by :            Date :
//      MichMa              	10/20/94
//
//  Description :
//      Implementation of the UIVariables class
//

#include "stdafx.h"
#include "uivar.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


// BEGIN_HELP_COMMENT
// Function: BOOL UIVariables::Activate(void)
// Description: Bring up the variables window.
// Return: A Boolean value that indicates whether the variables window is active (TRUE) or not.
// END_HELP_COMMENT
BOOL UIVariables::Activate(void)

	{
	UIWB.DoCommand(IDM_VIEW_VARS, DC_MNEMONIC);
//REVIEW (chriskoz) do not understand the purpose of this idiot sequence
//	commented out the offending code & replaced with AttachActive() which makes sense
//	HWND hwnd;
//    if(hwnd = MST.WFndWndWait(GetLocString(IDSS_VAR_WND_TITLE), FW_FULL, 2))
//		return Attach(hwnd);
//	else
//		return Attach(FindFirstChild(UIWB.HWnd(), IDW_LOCALS_WIN));
	return AttachActive();
	}


// BEGIN_HELP_COMMENT
// Function: int UIVariables::SetValue(LPCSTR value, int row /* ROW_CURRENT */)
// Description: Set the value for the expression at the row specified in the variables window.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: value A pointer to a string that contains the value.
// Param: row An integer that specifies the 1-based row of the variables window. Use ROW_CURRENT to specify the current row; ROW_BOTTOM to specify the last row; and ROW_ALL to specify all rows. (Default value is ROW_CURRENT.)
// END_HELP_COMMENT
int UIVariables::SetValue(LPCSTR value, int row /* ROW_CURRENT */)
	
	{
	SelectRows(row);
	MST.DoKeys("{TAB}");

	int i = 0;
 
	while(!MST.WEditExists("@1") && (++i < 10))
		Sleep(500);

	if(i == 10)

		{
		LOG->RecordInfo("ERROR in UIVariables::SetValue(): "
						"edit field did not appear within 5 seconds");

		return ERROR_ERROR;
		}

	MST.WEditSetText("@1", value);
	MST.DoKeys("{ENTER}");
	while(MST.WEditExists("@1"));
	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int UIVariables::SetPane(int pane)
// Description: Set the current pane to the specified pane in the variables window.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: pane A value that specifies the pane to activate: PANE_THIS, PANE_AUTO, PANE_LOCALS.
// END_HELP_COMMENT
int UIVariables::SetPane(int pane)

	{
	// REVIEW (michma): UIDockWindow::ActivatePane() is broken.
	// REVIEW (chriskoz) it's not broken but difficult to get(use ::WCustomExists())
	//	return ActivatePane(GetLocString(pane)) ? ERROR_SUCCESS : ERROR_ERROR;

	char pane_str[128];
	strncpy(pane_str, GetLocString(pane), 128);
	

	// cycle through panes until we find the pane
	for(int i = 0; i < TOTAL_VAR_PANES; i++)
		{
//		if(GetName(1) == this_str)
		Sleep(500);
//		::WCustomSetClass("Afx:400000:0"); //obsolete
//		if(::WCustomExists(pane_str,0)!=0) //obsolete
//		if(::WFndWndC(pane_str,"Afx:400000:0",FW_ACTIVE,0)!=NULL)
		if(::WFndWndC(pane_str,NULL,FW_ACTIVE,0)!=NULL) //we don't want to rely on th above class name
			break;
		MST.DoKeys("^({PGDN})");
		}
	
/*		if(MST.FindWndWait(pane_str,1)
			break;
		else
			MST.DoKeys("^({PGDN})");
*/ //there is no way to use FindWndWait
	if(i == TOTAL_VAR_PANES)
		{
		LOG->RecordInfo("ERROR in UIVariables::SetPane(): "
						"can't find %s pane", pane_str);

		return ERROR_ERROR;
		}	
	return ERROR_SUCCESS;
	}

// BEGIN_HELP_COMMENT
// Function: CString UIVariables::GetFunction(int level /* 0 */)
// Description: Get the call stack description string at the given call stack level (index).  It assumes that the Variables window already has focus.
// Return: A CString that contains the call stack description string from the given call stack level.
// Param: level An integer that contains the 0-based index into the call stack. (Default value is 0.)
// END_HELP_COMMENT
CString UIVariables::GetFunction(int level /* 0 */)
{
	// First we must give the combo box focus.  It may not be that important here, but for
	// certain situations it seems necessary.  See NavigateStack for more details.

//	MST.DoKeys("%+O{Escape}");
	MST.WComboSetFocus(GetLocString(IDSS_VAR_WND_CALLS));

	CString str;
	MST.WComboItemText(GetLocString(IDSS_VAR_WND_CALLS), level + 1, str);
	return str;
}

// BEGIN_HELP_COMMENT
// Function: CString UIVariables::GetAllFunctions(void)
// Description: Get all the call stack frame descriptions for all frames on the call stack.
// Return: A CString that contains a newline-delimited list of call stack frames.
// END_HELP_COMMENT
CString UIVariables::GetAllFunctions(void)
{
	// First we must give the combo box focus.  It may not be that important here, but for
	// certain situations it seems necessary.  See NavigateStack for more details.

//	MST.DoKeys("%+O{Escape}");
	MST.WComboSetFocus(GetLocString(IDSS_VAR_WND_CALLS));

	int nItems = MST.WComboCount(GetLocString(IDSS_VAR_WND_CALLS));

	CString str, temp;
	for (int i = 0; i < nItems; i++)
	{
		MST.WComboItemText(GetLocString(IDSS_VAR_WND_CALLS), i + 1, temp);
		str += temp + '\n';
	}
	return str;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIVariables::NavigateStack(int level /* 0 */)
// Description: Navigate to the specified call stack frame.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: level An integer that contains the 0-based index into the call stack. (Default value is 0.)
// END_HELP_COMMENT
BOOL UIVariables::NavigateStack(int level /* 0 */)
{
	// First we must give the combo box focus.  This seems to be necessary due to an MSTest bug.
	// The reason I think that is because, if the combo box is not given focus, after 
	// displaying the Variables window, then the WComboExists("C&ontext") call is successful,
	// while the WComboItemClk("C&ontext", n) call is not.  This really doesn't make any 
	// sense.  If the combo is given focus first then both calls are successful. (JPG).

//	MST.DoKeys("%+O{Escape}");
	MST.WComboSetFocus(GetLocString(IDSS_VAR_WND_CALLS));

	CString str = GetLocString(IDSS_VAR_WND_CALLS);
	if (MST.WComboExists(str))
		MST.WComboItemClk(str, level + 1);
	else
		return FALSE;
//REVIEW(chriskoz): FInd Source handled by CTarget
	// verification here
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIVariables::SelectLocal(LPCSTR szLocal)
// Description: Selects the row in the locals pane containing the specified local.
// Return: An boolean that indicates success. TRUE if successful; FALSE otherwise.
// Param: szLocal A pointer to a string that contains the name of the local.
// END_HELP_COMMENT
BOOL UIVariables::SelectLocal(LPCSTR szLocal)

{
	// select the locals pane in the variables window.
	if(SetPane(PANE_LOCALS) != ERROR_SUCCESS)
	{
		LOG->RecordInfo("ERROR in UIVariables::SelectLocal() - can't select locals pane.");
		return FALSE;
	}

	// start looking from the first row in the locals pane.
	SelectRows(1);
	// tracks the last local selected.
	CString strLastLocal;
	// tracks the currently selected locally.
	CString strCurrentLocal = GetName();

	// loop until we find a name field that matches the local.
	while(strCurrentLocal != szLocal)

	{
		strLastLocal = strCurrentLocal;
		// select the next row in the locals pane.
		SelectRows(ROW_NEXT);
		// get the local name from the row.
		strCurrentLocal = GetName();
		
		// if it matches the last local, we've reached the end of the list (or found a sequential duplicate).
		if(strCurrentLocal == strLastLocal)
		{
			LOG->RecordInfo("ERROR in UIVariables::SelectLocal(): "
							"can't find local \"%s\". reached end of the list.", szLocal);
			return FALSE;
		}
	}

	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: int UIVariables::GetLocalsCount(void)
// Description: Returns the number of locals in the Locals pane of the variables window.
// Return: An integer specifying the number of locals.
// END_HELP_COMMENT
int UIVariables::GetLocalsCount(void)

{
	char szThisFunc[] = "UIVariables::GetLocalsCount()";
	
	// select the locals pane in the variables window.
	if(SetPane(PANE_LOCALS) != ERROR_SUCCESS)
	{
		LOG->RecordInfo("ERROR in %s - can't select locals pane.", szThisFunc);
		return FALSE;
	}

	// start with the first row in the locals pane.
	SelectRows(1);
	// tracks the last local selected.
	CString strLastLocal;
	// tracks the currently selected locally.
	CString strCurrentLocal = GetName();
	// tracks the locals count.
	int intLocalsCount = 0;

	// loop until we get to the end of the locals list (when the current local matches the last local).
	while(strCurrentLocal != strLastLocal)
	{
		// increment the locals count.
		intLocalsCount++;
		// the current local now becomes the last local.
		strLastLocal = strCurrentLocal;
		// select the next row in the locals pane.
		SelectRows(ROW_NEXT);
		// get the local name from the current row.
		strCurrentLocal = GetName();
	}

	return intLocalsCount;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIVariables::SelectAuto(LPCSTR szName)
// Description: Selects the row in the auto pane containing the specified auto.
// Return: An boolean that indicates success. TRUE if successful; FALSE otherwise.
// Param: szName A pointer to a string that contains the name of the auto.
// END_HELP_COMMENT
BOOL UIVariables::SelectAuto(LPCSTR szName)

{
	// select the auto pane in the variables window.
	if(SetPane(PANE_AUTO) != ERROR_SUCCESS)
	{
		LOG->RecordInfo("ERROR in UIVariables::SelectAuto() - can't select auto pane.");
		return FALSE;
	}

	return SelectRow(szName);
}

// BEGIN_HELP_COMMENT
// Function: int UIVariables::GetAutoCount(void)
// Description: Returns the number of items in the Auto pane of the variables window.
// Return: An integer specifying the number of items in the Auto pane.
// END_HELP_COMMENT
int UIVariables::GetAutoCount(void)

{
	const char* const THIS_FUNCTION = "UIVariables::GetAutoCount";
	
	// select the locals pane in the variables window.
	if(SetPane(PANE_AUTO) != ERROR_SUCCESS)
	{
		LOG->RecordInfo("ERROR in %s - can't select locals pane.", THIS_FUNCTION);
		return FALSE;
	}

	return GetRowCount();
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIVariables::SelectRow(LPCSTR szName)
// Description: Selects the row in the current pane containing the specified name field.
// Return: An boolean that indicates success. TRUE if successful; FALSE otherwise.
// Param: szName A pointer to a string that contains the name in the row to select.
// END_HELP_COMMENT
BOOL UIVariables::SelectRow(LPCSTR szName)

{
	const char* const THIS_FUNCTION = "UIVariables::SelectRow";

	// start looking from the first row in the pane.
	SelectRows(1);
	// tracks the name in the last row selected.
	CString strLastName;
	// tracks the currently selected name.
	CString strCurrentName = GetName();

	// loop until we find a name field that matches the one specified.
	while(strCurrentName != szName)

	{
		strLastName = strCurrentName;
		// select the next row in the pane.
		SelectRows(ROW_NEXT);
		// get the name from the row.
		strCurrentName = GetName();
		
		// if it matches the last name, we've reached the end of the list (or found a sequential duplicate).
		if(strCurrentName == strLastName)
		{
			LOG->RecordInfo("ERROR in %s: can't find name \"%s\". reached end of the list.", THIS_FUNCTION, szName);
			return FALSE;
		}
	}

	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: int UIVariables::GetRowCount(void)
// Description: Returns the number of rows in the current pane of the variables window.
// Return: An integer specifying the number of rows.
// END_HELP_COMMENT
int UIVariables::GetRowCount(void)

{
	// start with the first row in the pane.
	SelectRows(1);
	// tracks the last local selected.
	CString strLastName;
	// tracks the currently selected row.
	CString strCurrentName = GetName();
	// tracks the row count.
	int intRowCount = 0;

	// loop until we get to the end of the list (when the current name matches the last name).
	while(strCurrentName != strLastName)
	{
		// increment the row count.
		intRowCount++;
		// the current now becomes the last row.
		strLastName = strCurrentName;
		// select the next row in the pane.
		SelectRows(ROW_NEXT);
		// get the name from the current row.
		strCurrentName = GetName();
	}

	return intRowCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uivar.h ===
///////////////////////////////////////////////////////////////////////////////
//  UIVAR.H
//
//  Created by :            Date :
//      MichMa              	10/20/94
//
//  Description :
//		Declaration of the UIVariables class
//

#ifndef __UIVAR_H__
#define __UIVAR_H__

#include "uieewnd.h"

#ifndef __UIEEWND_H__
	#error include 'uieewnd.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//  UIVariables class


#define PANE_THIS	IDSS_VAR_PANE_THIS
#define PANE_AUTO	IDSS_VAR_PANE_AUTO
#define PANE_LOCALS	IDSS_VAR_PANE_LOCALS

#define TOTAL_VAR_PANES 3

// BEGIN_CLASS_HELP
// ClassName: UIVariables
// BaseClass: UIEEWindow
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS UIVariables : public UIEEWindow
	
	{
	UIWND_COPY_CTOR(UIVariables, UIEEWindow);

	virtual BOOL Activate(void);
	virtual UINT GetID(void) const {return IDW_LOCALS_WIN;}
	//todo: needs its own id

	// Public utilities
	public:
		int SetValue(LPCSTR value, int row = ROW_CURRENT);
		int SetPane(int pane);
		BOOL SelectLocal(LPCSTR szLocal);
		int GetLocalsCount(void);

		BOOL SelectRow(LPCSTR szName);
		int GetRowCount(void);

		BOOL SelectAuto(LPCSTR szName);
		int GetAutoCount(void);

		// The following functions are intended to completely mimic that of the same functions in UIStack.  
		CString GetFunction(int level = 0);
		CString GetAllFunctions(void);
		BOOL NavigateStack(int level = 0);
	};

#endif //__UIVAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\eds\cofile.h ===
///////////////////////////////////////////////////////////////////////////////
//	COFILE.H
//
//	Created by :			Date :
//		DavidGa					1/10/94
//
//	Description :
//		Declaration of the COFile component object class
//

#ifndef __COFILE_H__
#define __COFILE_H__

#include "ueditor.h"
#include "..\shl\ucommdlg.h"

#include "edsxprt.h"

#define ERROR_ERROR -1

// use to tell Create() which type of file to create.
enum FILE_TYPE {
		FILE_ACTIVE_SERVER_PAGE	= IDSS_NEW_ACTIVE_SERVER_PAGE,	
		FILE_BINARY				= IDSS_NEW_BINARY,			
		FILE_BITMAP				= IDSS_NEW_BITMAP,
		FILE_HEADER				= IDSS_NEW_HEADER,
		FILE_SOURCE				= IDSS_NEW_CPP_SOURCE,
		FILE_CURSOR				= IDSS_NEW_CURSOR, 
		FILE_HTML_PAGE			= IDSS_NEW_HTML_PAGE,			  	
		FILE_ICON				= IDSS_NEW_ICON,
		FILE_MACRO				= IDSS_NEW_MACRO,
		FILE_ODBC_SCRIPT		= IDSS_NEW_ODBC_SCRIPT,
		FILE_RESOURCE_SCRIPT	= IDSS_NEW_RESOURCE_SCRIPT,
		FILE_RESOURCE_TEMPLATE	= IDSS_NEW_RESOURCE_TEMPLATE,
		FILE_TEXT				= IDSS_NEW_TEXT
};

///////////////////////////////////////////////////////////////////////////////
// COFile class

// BEGIN_CLASS_HELP
// ClassName: COFile
// BaseClass: none
// Category: Editors
// END_CLASS_HELP
class EDS_CLASS COFile
{
public:
	COFile();

// Data
protected:
	CString m_strFileName;
	UIEditor m_editor;

// Operations
public:
	int Create(UINT idsType, LPCSTR szSaveAs = NULL, LPCSTR szProject = NULL);
	virtual int AttachActive(void);
	virtual int Open(LPCSTR szFileName, LPCSTR szChDir = NULL, EOpenAs oa = OA_AUTO);
	virtual int Save(void);
	virtual int SaveAs(LPCSTR szFileName, BOOL bOverWrite = FALSE);
	virtual int Close(BOOL bSaveChanges = FALSE);
	virtual inline BOOL AttachActiveEditor(void)
		{	return m_editor.AttachActive(); }

// Generic features
public:
	virtual LPCSTR Cut(CString* pstr = NULL);
	virtual LPCSTR Copy(CString* pstr = NULL);
	virtual void Paste(void);
	virtual void Delete(void);
	virtual void Undo(void);
	virtual void Redo(void);

// Attributes
	LPCSTR GetFileName(void);
};

#endif //__COFILE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\eds\edsxprt.h ===
///////////////////////////////////////////////////////////////////////////////
//	edsxprt.h (editors export)
//
//	Created by :			Date :
//		BrianCr				01/03/95
//
//	Description :
//		Editors DLL defines
//

#ifndef __EDSXPRT_H__
#define __EDSXPRT_H__

#ifdef EXPORT_EDITORS
	#define EDS_CLASS AFX_EXT_CLASS
	#define EDS_API   AFX_EXT_API
	#define EDS_DATA  AFX_EXT_DATA
#else
	#define EDS_CLASS __declspec(dllimport)
	#define EDS_API   __declspec(dllimport)
	#define EDS_DATA  __declspec(dllimport)

	#ifdef _DEBUG 
		#pragma comment(lib, "edsd.lib")
	#else
		#pragma comment(lib, "eds.lib")
	#endif
#endif

#endif // __EDSXPRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\eds\eds.cpp ===
/////////////////////////////////////////////////////////////////////////////
// eds.cpp
//
// email	date		change
// briancr	01/11/95	created
//
// copyright 1994 Microsoft

#include "stdafx.h"
#include "afxdllx.h"

#define new DEBUG_NEW

///////////////////////////////////////////////////////////////////////////////
//	DLL support

static AFX_EXTENSION_MODULE extensionDLL = { NULL, NULL };

extern "C" __declspec(dllexport) int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("Editors DLL Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(extensionDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(extensionDLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("Editors DLL Terminating!\n");
		// Terminate the library before destructors are called
		AfxTermExtensionModule(extensionDLL);
	}
	return 1;   // ok

	UNREFERENCED_PARAMETER(lpReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\eds\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		BrianCr				09/06/94
//
//	Description :
//		source file that includes just the standard includes
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\eds\cofile.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	COFILE.CPP
//
//	Created by :			Date :
//		DavidGa					1/20/94
//
//	Description :
//		Implementation of the COFile component object class
//

#include "stdafx.h"
#include "cofile.h"
#include "testxcpt.h"
#include "mstwrap.h"
#include "guiv1.h"
#include "guitarg.h"
#include "..\..\udialog.h"
#include "..\..\testutil.h"
#include "..\shl\uiwbmsg.h"
#include "..\shl\uwbframe.h"
#include "..\shl\cowrkspc.h"
#include "..\shl\wbutil.h"
#include "..\shl\newfldlg.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

COFile::COFile()
{
}


// BEGIN_HELP_COMMENT
// Function: int COFile::AttachActive(void)
// Description: Attach an editor to the active file.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// END_HELP_COMMENT
int COFile::AttachActive(void)
{
	return m_editor.AttachActive() ? ERROR_SUCCESS : ERROR_ERROR;
}

	
// BEGIN_HELP_COMMENT
// Function: int COFile::Create(UINT idsType, LPCSTR szSaveAs /*=NULL*/, LPCSTR szProject /* NULL */)
// Description: Create a new file and corresponding editor in the IDE.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: idsType The type of file and editor to create: IDSS_NEW_SOURCE, IDSS_NEW_PROJECT, IDSS_NEW_RC, IDSS_NEW_RCT, IDSS_NEW_BINARY, IDSS_NEW_BITMAP, IDSS_NEW_ICON.
// Param: szSaveAs A pointer to a string that contains the name to save the new file with. NULL indicates don't save (no name specified). (The default value is NULL.)
// Param: szProject A pointer to a string that contains the name of the project to add the file to. NULL indicates don't add it to project. (The default value is NULL.)
// END_HELP_COMMENT
int COFile::Create(UINT idsType, LPCSTR szSaveAs /*=NULL*/, LPCSTR szProject /* NULL */)
{

	HWND hwnd = UIWB.GetActiveEditor();

	// TODO (michma): we temporarily handle adding new files to projects in a separate block. this function shouldn't
	// be calling UIWB.CreateNewFile at all, but since it has been doing so for creating files without adding them to
	// projects, we'll leave it for now. i've added a block to handle adding new files to projects below.
	if(szProject)
	
	{
		UINewFileDlg uiNewFileDlg ;
		
		// TODO (michma): add error checking for each action.
		uiNewFileDlg.Display() ;
		uiNewFileDlg.NewFileTab() ;
		uiNewFileDlg.SelectFromList(GetLocString(idsType));
		uiNewFileDlg.AddToProject(TRUE);
		uiNewFileDlg.SetProject(szProject);
		uiNewFileDlg.SetName(szSaveAs, FILES);

		MST.WButtonClick(GetLabel(IDOK));
		uiNewFileDlg.WaitUntilGone(2000) ;
  		WaitForInputIdle(g_hTargetProc, 10000);
	}

	else
		UIWB.CreateNewFile(GetLocString(idsType)) ;
	
	int k = 0;

	do
	{
		m_editor = UIWB.GetActiveEditor();	// wait for a new editor
		if( (k++ > 4) && (m_editor == hwnd) )
		{
			// TODO(michma): we are failing to get a new editor in some cases, but not sure why.
			// one example: when the sys acceptance test creates a new html page and adds it to
			// an activex control project.
			break;
			m_editor.Detach();
			return ERROR_ERROR;
		}
		Sleep(1000);
	} while( m_editor == hwnd );

	if( !m_editor.IsValid() )
		return ERROR_ERROR;
		
	// if the file was added to a project, it has already been named, and the user can save it later.
	if(szProject)
		return ERROR_SUCCESS;

	// give the new file a name and save it.
	if(szSaveAs == NULL)
		return ERROR_SUCCESS;
	else
		return SaveAs(szSaveAs);
}


// BEGIN_HELP_COMMENT
// Function: int COFile::Open(LPCSTR szFileName, LPCSTR szChDir /*=NULL*/, EOpenAs oa /*=OA_AUTO*/)
// Description: Open a file and its corresponding editor in the IDE.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szFileName A pointer to a string that contains the name of the file to open.
// Param: szChDir A pointer to a string that contains the path to the file. NULL if szFileName includes a path or szFileName is in the current directory). (The default value is NULL.)
// Param: oa A value that indicates the editor to use when opening the file: OA_AUTO, OA_TEXT, OA_BINARY, OA_MAKEFILE. (The default value is OA_AUTO.)
// END_HELP_COMMENT
int COFile::Open(LPCSTR szFileName, LPCSTR szChDir /*=NULL*/, EOpenAs oa /*=OA_AUTO*/)
{
	const char* const THIS_FUNCTION = "COFile::Open";

	// REVIEW(michma, 10/26/97): is this necessary? i can see a reason for wanting to point
	// a COSource object at different files for different times, and no Detach function is provided.
	//ASSERT( !m_editor.IsValid() );		// new files go into new editors, not existing ones.

	UIFileOpenDlg ufod = UIWB.FileOpenDlg();
	if (!ufod.IsValid()) {
		LOG->RecordInfo("%s: unable to open the File Open dialog (UIFileOpenDlg::IsValid failed).", THIS_FUNCTION);
		return ERROR_ERROR;
	}

    if( szChDir != NULL )
        ufod.SetPath(szChDir);
    ufod.SetName(szFileName);
	ufod.SetEditor(oa);

	if (!ufod.OK(FALSE)) {
		LOG->RecordInfo("%s: unable to close the File Open dialog with the OK button (UIFileOpenDlg::OK failed).", THIS_FUNCTION);
		return ERROR_ERROR;
	}

	UIWBMessageBox mb;
	while( mb.WaitAttachActive(3000) != NULL )
	{
		if( mb.ButtonExists(MSG_NO) )
			// this will handle "do you want to save" msg box
			mb.ButtonClick(MSG_NO);
	}

	ufod.WaitUntilGone(1500);	// the only files that take a while are RC, which causes the whole system to wait while it compiles

	if (WaitForInputIdle(g_hTargetProc, 60000) == WAIT_TIMEOUT)
		LOG->RecordFailure("File took more than 60 seconds to load");

	
	// Get a pointer to the filename only; i.e. remove any path prefix.	
	const char *p = szFileName + strlen(szFileName) - 1;
	while (*(p-1) != '\\' && p != szFileName)
		p--;

	// If the new file pops up as a separate, MDI window....
	if (MST.WFndWnd(p, FW_ACTIVE | FW_PART | FW_CHILDOK | FW_NOCASE))
	{
		m_editor.AttachActive();
		m_strFileName = szFileName;

		if( m_editor.IsValid() )
			return ERROR_SUCCESS;
		else
			return ERROR_ERROR;
	}
	else
	{
		LOG->RecordInfo("Assuming %s is opened in Workspace window", szFileName);
		return ERROR_SUCCESS;
	}
}

// BEGIN_HELP_COMMENT
// Function: int COFile::Save(void)
// Description: Save the file.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// END_HELP_COMMENT
int COFile::Save(void)
{
	const char* const THIS_FUNCTION = "COFile::Save";

	if (!m_editor.IsValid()) {
		LOG->RecordInfo("%s: the editor for the current file '%s' is not valid (UIEditor::IsValid failed).", THIS_FUNCTION, m_editor.GetTitle());
		return ERROR_ERROR;
	}
	if (!m_editor.Activate()) {
		LOG->RecordInfo("%s: cannot activate the editor for the current file '%s' (UIEditor::Activate failed).", THIS_FUNCTION, m_editor.GetTitle());
		return ERROR_ERROR;
	}

	UIWB.DoCommand(ID_FILE_SAVE, DC_MNEMONIC);
	// REVIEW: handle any problems
	// REVIEW: verify that 'dirty' marker is gone from titlebar?
	return ERROR_SUCCESS;
}

// BEGIN_HELP_COMMENT
// Function: int COFile::SaveAs(LPCSTR szFileName, BOOL bOverWrite /*=FALSE*/)
// Description: Save the file with the name given in szFileName.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szFileName A pointer to a string that contains the filename to use.
// Param: bOverWrite A Boolean value that indicates whether to overwrite an existing file (TRUE) or not. (The default value is FALSE.)
// END_HELP_COMMENT
int COFile::SaveAs(LPCSTR szFileName, BOOL bOverWrite /*=FALSE*/)
{
	const char* const THIS_FUNCTION = "COFile::SaveAs";

	if (!m_editor.IsValid()) {
		LOG->RecordInfo("%s: the editor for the current file '%s' is not valid (UIEditor::IsValid failed).", THIS_FUNCTION, m_editor.GetTitle());
		return ERROR_ERROR;
	}
	if (!m_editor.Activate()) {
		LOG->RecordInfo("%s: cannot activate the editor for the current file '%s' (UIEditor::Activate failed).", THIS_FUNCTION, m_editor.GetTitle());
		return ERROR_ERROR;
	}

	UIFileSaveAsDlg ufsad = UIWB.FileSaveAsDlg();
	if (!ufsad.IsValid()) {
		LOG->RecordInfo("%s: unable to open the File Save As dialog (UIFileSaveAsDlg::IsValid failed).", THIS_FUNCTION);
		return ERROR_ERROR;
	}

    ufsad.SetName(szFileName);

    ufsad.OK(FALSE);
	int k = 0;
	while( !ufsad.WaitUntilGone(0) )
	{
		UIWBMessageBox umb;
		if( umb.WaitAttachActive(1000) )
		{
			if( umb.ButtonExists( MSG_NO ) )		// assume yes/no options are "Overwrite?" questions
			{
				if( bOverWrite )
					umb.ButtonClick( MSG_YES );
				else {
					umb.ButtonClick( MSG_NO );
					ufsad.Cancel();
			}
			}
			else
				MST.DoKeys("~");		// answer any other messageboxes with the default	// REVIEW
		}
		else
		{
			if( !MST.WButtonFocus(GetLabel(IDOK)) )		// if the Save As dialog is still active, but
				return ERROR_ERROR;						// the OK button doesn't have focus, something went wrong
		}
	}
	
	m_strFileName = szFileName;
	return ERROR_SUCCESS;
}

// BEGIN_HELP_COMMENT
// Function: int COFile::Close(BOOL bSaveChanges /* = FALSE */)
// Description: Close the file and its associated editor.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: bSaveChanges A Boolean value that indicates whether to save changes (TRUE) or not before closing the file. (The default value is FALSE.)
// END_HELP_COMMENT
int COFile::Close(BOOL bSaveChanges /* = FALSE */)
{
	const char* const THIS_FUNCTION = "COFile::Close";

	if (!m_editor.IsValid()) {
		LOG->RecordInfo("%s: the editor for the current file '%s' is not valid (UIEditor::IsValid failed).", THIS_FUNCTION, m_editor.GetTitle());
		return ERROR_ERROR;
	}
	if (!m_editor.Activate()) {
		LOG->RecordInfo("%s: cannot activate the editor for the current file '%s' (UIEditor::Activate failed).", THIS_FUNCTION, m_editor.GetTitle());
		return ERROR_ERROR;
	}

	UIWB.DoCommand(ID_FILE_CLOSE, DC_MNEMONIC);
	
	UIMessageBox uiSaveAlert;
	if (uiSaveAlert.WaitAttachActive(500))
	{
		if (bSaveChanges)
			uiSaveAlert.ButtonClick(MSG_YES);	
		else
			uiSaveAlert.ButtonClick(MSG_NO);	
	}
	
	// wait for up to a second for the editor to close
	for (int i = 0; i < 10; i++) {
		if (!m_editor.IsValid()) {
			break;
		}
		Sleep(100);
	}
	if (i >= 10) {
		LOG->RecordInfo("%s: after closing and waiting 1 second, the editor is still valid for the current file '%s' (UIEditor::IsValid succeeded).", THIS_FUNCTION, m_editor.GetTitle());
		return ERROR_ERROR;
	}
	else {
		return ERROR_SUCCESS;
	}
}

// BEGIN_HELP_COMMENT
// Function: LPCSTR COFile::GetFileName(void)
// Description: Get the filename of this file.
// Return: A pointer to a string that contains the filename of this file.
// END_HELP_COMMENT
LPCSTR COFile::GetFileName(void)
{
	return m_strFileName;	// STUB
}

// BEGIN_HELP_COMMENT
// Function: LPCSTR COFile::Cut(CString* pstr /*=NULL*/)
// Description: Perform a cut action in the editor associated with this file.
// Return: A pointer to a string that contains the text placed in the clipboard as a result of the cut.
// Param: pstr A pointer to a CString that will contain the text placed in the clipboard as a result of the cut operation. If this parameter is NULL, the return value will also be NULL. (The default value is NULL.)
// END_HELP_COMMENT
LPCSTR COFile::Cut(CString* pstr /*=NULL*/)
{
	UIWB.DoCommand(ID_EDIT_CUT, DC_ACCEL);		// should work anywhere
	if( pstr == NULL )
		return NULL;
	GetClipText(*pstr);		// if test wants string, they must provide the buffer
	return *pstr;
}

// BEGIN_HELP_COMMENT
// Function: LPCSTR COFile::Copy(CString* pstr /*=NULL*/)
// Description: Perform a copy operation in the editor associated with this file.
// Return: A pointer to a string that contains the text placed in the clipboard as a result of the cut.
// Param: pstr A pointer to a CString that will contain the text placed in the clipboard as a result of the cut operation. If this parameter is NULL, the return value will also be NULL. (The default value is NULL.)
// END_HELP_COMMENT
LPCSTR COFile::Copy(CString* pstr /*=NULL*/)
{
	UIWB.DoCommand(ID_EDIT_COPY, DC_ACCEL);		// should work anywhere
	if( pstr == NULL )
		return NULL;
	GetClipText(*pstr);
	return *pstr;
}

// BEGIN_HELP_COMMENT
// Function: void COFile::Paste(void)
// Description: Perform a paste operation in the editor associated with this file.
// Return: none
// END_HELP_COMMENT
void COFile::Paste(void)
{
	UIWB.DoCommand(ID_EDIT_PASTE, DC_ACCEL);		// should work anywhere
}

// BEGIN_HELP_COMMENT
// Function: void COFile::Delete(void)
// Description: Perform a delete operation in the editor associated with this file.
// Return: none
// END_HELP_COMMENT
void COFile::Delete(void)
{
	UIWB.DoCommand(ID_EDIT_CLEAR, DC_ACCEL);    // should work anywhere
}

// BEGIN_HELP_COMMENT
// Function: void COFile::Undo(void)
// Description: Perform an undo operation in the editor associated with this file.
// Return: none
// END_HELP_COMMENT
void COFile::Undo(void)
{
	UIWB.DoCommand(ID_EDIT_UNDO, DC_ACCEL);		// should work anywhere
}

// BEGIN_HELP_COMMENT
// Function: void COFile::Redo(void)
// Description: Peform a redo operation in the editor associated with this file.
// Return: none
// END_HELP_COMMENT
void COFile::Redo(void)
{
	UIWB.DoCommand(ID_EDIT_REDO, DC_ACCEL);		// should work anywhere
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uiwatch.h ===
///////////////////////////////////////////////////////////////////////////////
//  UIWATCH.H
//
//  Created by :            Date :
//      MichMa              	1/17/94
//
//  Description :
//		Declaration of the UIWatch class
//

#ifndef __UIWATCH_H__
#define __UIWATCH_H__

#include "uieewnd.h"

#ifndef __UIEEWND_H__
	#error include 'uieewnd.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//  UIWatch class

#define NAME_NOT_EDITABLE  0
#define NAME_IS_EDITABLE  -1

#define PANE_WATCH1	IDSS_WATCH_PANE_WATCH1
#define PANE_WATCH2	IDSS_WATCH_PANE_WATCH2
#define PANE_WATCH3	IDSS_WATCH_PANE_WATCH3
#define PANE_WATCH4	IDSS_WATCH_PANE_WATCH4

// BEGIN_CLASS_HELP
// ClassName: UIWatch
// BaseClass: UIEEWindow
// Category: Debug
// END_CLASS_HELP
class DBG_CLASS UIWatch : public UIEEWindow
	
	{
	UIWND_COPY_CTOR(UIWatch, UIEEWindow);

	virtual BOOL Activate(void);
	virtual UINT GetID(void) const {return IDW_WATCH_WIN;}

	// Public utilities
	public:

		int SetPane(int pane);
		int SetName(LPCSTR name, int row = ROW_CURRENT);

		int SetValue(LPCSTR value, int row = ROW_CURRENT, 
					 int name_editability = NAME_IS_EDITABLE);

		int Delete(int start_row = ROW_CURRENT, int total_rows = 1);
		BOOL SelectWatch(LPCSTR szWatch);
		int GetWatchCount(void);
	};

#endif //__UIWATCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\dbg\uiwatch.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UIWATCH.CPP
//
//  Created by :            Date :
//      MichMa              	1/17/94
//
//  Description :
//      Implementation of the UIWatch class
//

#include "stdafx.h"
#include "uiwatch.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


// BEGIN_HELP_COMMENT
// Function: BOOL UIWatch::Activate(void)
// Description: Bring up the watch window.
// Return: A Boolean value that indicates whether the watch window is active (TRUE) or not.
// END_HELP_COMMENT
BOOL UIWatch::Activate(void)

	{
	UIWB.DoCommand(IDM_VIEW_WATCH, DC_ACCEL);
	HWND hwnd;

    if(hwnd = MST.WFndWndWait(GetLocString(IDSS_WATCH_WND_TITLE), FW_FULL, 2))
		return Attach(hwnd);
	else
		return Attach(FindFirstChild(UIWB.HWnd(), IDW_WATCH_WIN));
	}


// BEGIN_HELP_COMMENT
// Function: int UIWatch::SetName(LPCSTR name, int row /* ROW_CURRENT */)
// Description: Set the name of the expression at the specified row in the watch window.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: name A pointer to a string that specifies the name to set in the watch window.
// Param: row An integer that specifies the 1-based row of the watch window. Use ROW_CURRENT to specify the current row; ROW_BOTTOM to specify the last row; and ROW_ALL to specify all rows. (Default value is ROW_CURRENT.)
// END_HELP_COMMENT
int UIWatch::SetName(LPCSTR name, int row /* ROW_CURRENT */)
	{
	//REVIEW (michma) this function could have timing problems.
	// needs to have precautions like UIVariables::SetValue.
	SelectRows(row);
	MST.DoKeys("{TAB}");
	MST.WEditSetText("", name);
	MST.DoKeys("{ENTER}");
	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int UIWatch::SetValue(LPCSTR value, int row /* ROW_CURRENT */,
// Description: Set the value of the expression at the specified row in the watch window.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: value A pointer to a string that contains the value.
// Param: row An integer that specifies the 1-based row of the watch window. Use ROW_CURRENT to specify the current row; ROW_BOTTOM to specify the last row; and ROW_ALL to specify all rows. (Default value is ROW_CURRENT.)
// END_HELP_COMMENT
int UIWatch::SetValue(LPCSTR value, int row /* ROW_CURRENT */,
					  int name_editability /* NAME_IS_EDITABLE */)
	
	{
	//REVIEW (michma) this function could have timing problems.
	// needs to have precautions like UIVariables::SetValue.

	SelectRows(row);
	MST.DoKeys("{TAB}");
	
	if(name_editability == NAME_IS_EDITABLE)
		MST.DoKeys("{TAB}");

	MST.WEditSetText("", value);
	MST.DoKeys("{ENTER}");
	return ERROR_SUCCESS;
	}

	
// BEGIN_HELP_COMMENT
// Function: int UIWatch::Delete(int start_row /* ROW_CURRENT */, int total_rows /* 1 */)
// Description: Delete an expression from the watch window.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: start_row An integer that specifies the 1-based row of the watch window. Use ROW_CURRENT to specify the current row; ROW_BOTTOM to specify the last row; and ROW_ALL to specify all rows. (Default value is ROW_CURRENT.)
// Param: total_rows An integer that specifies the number of rows to delete. (Default value is 1.)
// END_HELP_COMMENT
int UIWatch::Delete(int start_row /* ROW_CURRENT */, int total_rows /* 1 */)
	{
	SelectRows(start_row, total_rows);
	MST.DoKeys("{DELETE}");
	return ERROR_SUCCESS;
	}							


int UIWatch::SetPane(int pane)
	{
	return ActivatePane(GetLocString(pane)) ? ERROR_SUCCESS : ERROR_ERROR;
	}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWatch::SelectWatch(LPCSTR szWatch)
// Description: Selects the row in the watch window containing the specified watch.
// Return: An boolean that indicates success. TRUE if successful; FALSE otherwise.
// Param: szLocal A pointer to a string that contains the name of the watch.
// END_HELP_COMMENT
BOOL UIWatch::SelectWatch(LPCSTR szWatch)

{
	// start looking from the first row in the watch window.
	SelectRows(1);
	// tracks the last watch selected.
	CString strLastWatch;
	// tracks the currently selected watch.
	CString strCurrentWatch = GetName(ROW_CURRENT, METHOD_PROP_PAGE);

	// loop until we find a name field that matches the watch.
	while(strCurrentWatch != szWatch)

	{
		strLastWatch = strCurrentWatch;
		// select the next row in the watch window.
		SelectRows(ROW_NEXT);
		// get the watch name from the row.
		strCurrentWatch = GetName(ROW_CURRENT, METHOD_PROP_PAGE);
		
		// if it matches the last watch, we've reached the end of the list (or found a sequential duplicate).
		if(strCurrentWatch == strLastWatch)
		{
			LOG->RecordInfo("ERROR in UIWatch::SelectWatch(): "
							"can't find watch \"%s\". reached end of the list.", szWatch);
			return FALSE;
		}
	}

	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: int UIWatch::GetWatchCount(void)
// Description: Returns the number of locals in the Locals pane of the variables window.
// Return: An integer specifying the number of locals.
// END_HELP_COMMENT
int UIWatch::GetWatchCount(void)

{
	char szThisFunc[] = "UIWatch::GetWatchCount()";
	
	// start with the first row in the watch window.
	SelectRows(1);
	// tracks the last watch selected.
	CString strLastWatch;
	// tracks the currently selected watch.
	CString strCurrentWatch = GetName(ROW_CURRENT, METHOD_PROP_PAGE);
	// tracks the watch count.
	int intWatchCount = 0;

	// loop until we get to the end of the watch list (when the current watch matches the last watch).
	while(strCurrentWatch != strLastWatch)
	{
		// increment the watch count.
		intWatchCount++;
		// the current watch now becomes the last watch.
		strLastWatch = strCurrentWatch;
		// select the next row in the watch window.
		SelectRows(ROW_NEXT);
		// get the watch name from the current row.
		strCurrentWatch = GetName(ROW_CURRENT, METHOD_PROP_PAGE);
	}

	// we expect the last watch item to be empty.
	if(strCurrentWatch != "")
	{
		LOG->RecordInfo("ERROR in UIWatch::GetWatchCount(): "
						"last watch item was \"%s\". expected empty item.", strCurrentWatch);
		return intWatchCount;
	}
	else
	{
		// the last watch item row counted was empty, so we subtract it here.
		if(intWatchCount > 0)
			return intWatchCount - 1;
		// however if we didn't find any non-empty items, then we didn't count the last item in the first place.
		else
			return 0;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\eds\macrodlg.h ===
///////////////////////////////////////////////////////////////////////////////
//  UMACRODLG.H
//
//  Created by :            Date :
//      EnriqueP              2/4/94
//
//  Description :
//      Declaration of the UIMacrosDlg class
//

#ifndef __UMACRODLG_H__
#define __UMACRODLG_H__
#include "..\..\udialog.h"
#include "..\sym\auto1.h"
#include "guiv1.h"
#include "edsxprt.h"

#ifndef __UIDIALOG_H__
	#error include 'udialog.h' before including this file
#endif
#define ERROR_ERROR -1

///////////////////////////////////////////////////////////////////////////////
//  UIMacrosDlg class


///////////////////////////////////////////////////////////////////////////////
 
// BEGIN_CLASS_HELP
// ClassName: UIMacrosDlg
// BaseClass: UIDialog
// Category: Editors
// END_CLASS_HELP
class EDS_CLASS UIMacrosDlg : public UIDialog 
	{
    UIWND_COPY_CTOR (UIMacrosDlg, UIDialog) ; 

// General Utilities
	public:
			
			HWND Display(void) ;
			
			
	public:
			int SelectMacroFile(CString FileName);
			int SelectMacro(CString MacroName); 
			int RunMacro(void);
			HWND Close(void);
   } ;

#endif //__UMACRODLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\eds\macrodlg.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UCUSTDLG.CPP
//
//  Created by :            Date :
//      IvanL	             9/10/96
//                                
//  Description :
//      Implementation of the UIMacrosDlg class    
//

#include "stdafx.h"
#include "macrodlg.h"
#include "w32repl.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\cmdids.h"
#include "..\shl\uwbframe.h"




#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: HWND UIMacrosDlg::Display() 
// Description: Bring up the Tools.Macro dialog
// Return: The HWND of the Customize dialog.
// END_HELP_COMMENT
HWND UIMacrosDlg::Display() 
{       
	AttachActive();           // Check if is already up
	if (!IsValid())
	{
		UIWB.DoCommand(IDM_MACROS, DC_MNEMONIC);
		AttachActive();
	}
	return WGetActWnd(0); 
}


// BEGIN_HELP_COMMENT
// Function: HWND UIMacrosDlg::SelectMacroFile(CString FileName) 
// Description: Selects a macro file from the Files dropdown.
// Return: int .
// Param: FileName 
// END_HELP_COMMENT
int UIMacrosDlg::SelectMacroFile(CString MacroFile) 
{       
   MST.WComboItemClk(GetLabel(AUTO1_IDC_MACROFILE),MacroFile) ;
   return ERROR_SUCCESS ;
}

// BEGIN_HELP_COMMENT
// Function: HWND UIMacrosDlg::SelectMacro(CString MacroName)
// Description: Selects a macro to run from the macros drop down.
// Return: int 
// Param: MacroName 
// END_HELP_COMMENT
int UIMacrosDlg::SelectMacro(CString MacroName) 
{       
   MST.WComboItemClk(GetLabel(AUTO1_IDC_MACROS),MacroName);
   return ERROR_SUCCESS ;

}

// BEGIN_HELP_COMMENT
// Function: HWND UIMacrosDlg::RunMacro() 
// Description: Runs the selected macro
// Return: int .
// END_HELP_COMMENT
int UIMacrosDlg::RunMacro(void) 
{       
   MST.WButtonClick(GetLabel(AUTO1_ID_RUN));
   return ERROR_SUCCESS ;
}

// BEGIN_HELP_COMMENT
// Function: HWND UIMacrosDlg::Close() 
// Description: Closes down the macros dialog.
// Return: int .
// END_HELP_COMMENT
HWND UIMacrosDlg::Close(void) 
{       
   MST.WButtonClick(GetLabel(IDCANCEL));
   return ERROR_SUCCESS ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\eds\ufindinf.h ===
///////////////////////////////////////////////////////////////////////////////
//	UFNDINF.H
//
//	Created by :			Date :
//		DavidGa					12/9/93
//
//	Description :
//		Declaration of the UFindInFilesDlg class
//

#ifndef __UIFNDINF_H__
#define __UIFNDINF_H__

#include "..\..\udialog.h"
#include "..\shl\wbutil.h"

#include "edsxprt.h"

#ifndef __UIDIALOG_H__
	#error include 'udialog.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//	UISymbolBrowser class

// BEGIN_CLASS_HELP
// ClassName: UIFindInFilesDlg
// BaseClass: UIDialog
// Category: Editors
// END_CLASS_HELP
class EDS_CLASS UIFindInFilesDlg : public UIDialog
{
	UIWND_COPY_CTOR(UIFindInFilesDlg, UIDialog);

// Utilities
public:
	virtual CString ExpectedTitle(void) const
		{	return GetLocString(IDSS_FIF_TITLE); }
	void AddFile(LPCSTR szFile);
	void FindWhat(LPCSTR szFind);
	void DoFind(void);
};

#endif //__UIFNDINF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\eds\ueditor.h ===
///////////////////////////////////////////////////////////////////////////////
//	UEDITOR.H
//
//	Created by :			Date :
//		DavidGa					9/23/93
//
//	Description :
//		Declaration of the UIEditor class
//

#ifndef __UIEDITOR_H__
#define __UIEDITOR_H__

#include "..\..\uwindow.h"

#include "edsxprt.h"

#ifndef __UIWINDOW_H__
	#error include 'uwindow.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//	UIEditor class

// BEGIN_CLASS_HELP
// ClassName: UIEditor
// BaseClass: UIWindow
// Category: Editors
// END_CLASS_HELP
class EDS_CLASS UIEditor : public UIWindow
{
	UIWND_COPY_CTOR(UIEditor, UIWindow);

// Utilities
public:
	operator HWND ( ) {return HWnd();} ;
	virtual BOOL AttachActive(void);
	virtual BOOL IsActive(void);
	virtual BOOL Activate(void);
	CString GetTitle(void) const;
	BOOL Close(BOOL bLoseChanges = TRUE);
};

#endif //__UIEDITOR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\eds\ufindinf.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	UFNDINF.CPP
//
//	Created by :			Date :
//		DavidGa					9/20/93
//
//	Description :
//		Implementation of the UIFindInFilesDlg class
//

#include "stdafx.h"
#include "ufindinf.h"
#include "testxcpt.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\vcpp32.h"
#include "guiv1.h"
#include "..\shl\uioutput.h"
#include "..\shl\uwbframe.h"

// this dialog is in sushi\vcpp32's RC file (MSVC.RC)

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: void UIFindInFilesDlg::AddFile(LPCSTR szFile)
// Description: Add a file to the list of selected files to search in the Selected Files list box.
// Return: none
// Param: szFile A pointer to a string that contains the filename of the file to add to the list of files to search. This is usually a full path to the file.
// END_HELP_COMMENT
void UIFindInFilesDlg::AddFile(LPCSTR szFile)
{
	ExpectValid();
	MST.WEditSetText(GetLabel(1152), szFile);	// REVIEW: what if szFile contains '*' or '?'
	MST.WButtonClick(GetLabel(VCPP32_DLG_GREP_ADD));		// we could Add All in that case
}

// BEGIN_HELP_COMMENT
// Function: void UIFindInFilesDlg::FindWhat(LPCSTR szFind)
// Description: Set the text to search for in the list of files in the Find What edit box.
// Return: none
// Param: szFind A pointer to a string containing the text to search for in the list of files.
// END_HELP_COMMENT
void UIFindInFilesDlg::FindWhat(LPCSTR szFind)
{
	ExpectValid();
	MST.WComboSetText(GetLabel(VCPP32_DLG_GREP_FINDWHAT), szFind);
}

// BEGIN_HELP_COMMENT
// Function: void UIFindInFilesDlg::DoFind(void)
// Description: Perform the find in files. Call this function after setting the list of files with UIFindInFilesDlg::AddFile and the text to search for with UIFindInFilesDlg::FindWhat.
// Return: none
// END_HELP_COMMENT
void UIFindInFilesDlg::DoFind(void)
{
	ExpectValid();
	// do the find
	MST.WButtonClick(GetLabel(IDOK));

	WaitUntilGone(10000);
	EXPECT( UIWB.IsActive() );

	UIOutput uo = UIWB.ShowDockWindow(IDW_OUTPUT_WIN);
	int nSeconds = 0;
	while(nSeconds++ < 30)
	{
		DoKeys("^{end}+{up}^c");	// select last line of file, and copy it
		CString str;
		GetClipText(str);
		if( (str.Find(GetLocString(IDSS_FIF_OCCURANCES)) >= 0) ||		// "occurrence(s) have been found."
			(str.Find(GetLocString(IDSS_FIF_NOTFOUND)) >= 0) )			// "' was not found."
			break;		// the search is done when one of these lines appears at the bottom
		LOG->Comment((LPCSTR)str);
		Sleep(1000);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\eds\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		BrianCr				09/06/94
//
//	Description :
//		Precompiled header for all of the core MFC files
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\eds\ufindrep.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	UFINDREP.CPP
//
//	Created by :			Date :
//		DavidGa					4/13/94
//
//	Description :
//		Implementation of the UIFindDlg and UIReplaceDlg classes
//

#include "stdafx.h"
#include "ufindrep.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\cmdids.h"
#include "..\sym\vcpp32.h"
#include "..\sym\vshell.h"
#include "..\shl\uwbframe.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

///////////////////////////////////////////////////////////////////////////////
//	UIFindDlg class

// base class overrides
BOOL UIFindDlg::VerifyUnique(void) const
{
	return VerifyDlgItemClass(VSHELL_IDC_FIND_WHAT, GL_COMBOBOX);
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIFindDlg::Activate(void)
// Description: Open the Find dialog.
// Return: A Boolean that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIFindDlg::Activate(void)
{
	UIWB.DoCommand(ID_EDIT_FIND_DLG, DC_MNEMONIC);
	if (WaitAttachActive(5000)) {
		return TRUE;
	}
	return FALSE;
}

// BEGIN_HELP_COMMENT
// Function: HWND UIFindDlg::Close(void)
// Description: Close the Find dialog.
// Return: NULL, if successful; the HWND of the Find dialog, if it failed to close.
// END_HELP_COMMENT
HWND UIFindDlg::Close(void)
{
	return UIDialog::Cancel();
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIFindDlg::SetFindString(LPCSTR szFind)
// Description: Set the text given in szFind in the Find What edit box in the Find dialog.
// Return: A Boolean that indicates success. TRUE if successful; FALSE otherwise.
// Param: szFind A pointer to a string containing the text to enter in the Find What edit box in the Find dialog.
// END_HELP_COMMENT
BOOL UIFindDlg::SetFindString(LPCSTR szFind)
{
	MST.WComboSetText(GetLabel(VSHELL_IDC_FIND_WHAT), szFind);
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIFindDlg::SetMatchWord(BOOL bMatchWord)
// Description: Check or uncheck the Match Whole Word Only checkbox based on the value of bMatchWord.
// Return: A Boolean that indicates success. TRUE if successful; FALSE otherwise.
// Param: bMatchWord A Boolean value that, if TRUE means check the Match Whole Word Only checkbox, and if FALSE means uncheck it. (Default value is FALSE.)
// END_HELP_COMMENT
BOOL UIFindDlg::SetMatchWord(BOOL bMatchWord /*= FALSE*/)
{
	if (bMatchWord) {
		MST.WCheckCheck(GetLabel(VSHELL_IDC_FIND_WHOLEWORD));
	}
	else {
		MST.WCheckUnCheck(GetLabel(VSHELL_IDC_FIND_WHOLEWORD));
	}
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIFindDlg::SetMatchCase(BOOL bMatchCase)
// Description: Check or uncheck the Match Case checkbox based on the value of bMatchCase.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: bMatchCase A Boolean value that, if TRUE means check the Match Case checkbox, and if FALSE means uncheck it. (Default value is FALSE.)
// END_HELP_COMMENT
BOOL UIFindDlg::SetMatchCase(BOOL bMatchCase /*= FALSE*/)
{
	if (bMatchCase) {
		MST.WCheckCheck(GetLabel(VSHELL_IDC_FIND_MATCHUPLO));
	}
	else {
		MST.WCheckUnCheck(GetLabel(VSHELL_IDC_FIND_MATCHUPLO));
	}
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIFindDlg::SetRegularExpression(BOOL bRegExpr)
// Description: Check or uncheck the Regular Expression checkbox based on the value of bRegExpr.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: bRegExpr A Boolean value that, if TRUE means check the Regular Expression checkbox, and if FALSE means uncheck it. (Default value is FALSE.)
// END_HELP_COMMENT
BOOL UIFindDlg::SetRegularExpression(BOOL bRegExpr)
{
	if (bRegExpr) {
		MST.WCheckCheck(GetLabel(VSHELL_IDC_FIND_REGEXP));
	}
	else {
		MST.WCheckUnCheck(GetLabel(VSHELL_IDC_FIND_REGEXP));
	}
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIFindDlg::SetDirection(UIFindDlg::FindDirection fd)
// Description: Set the find direction in the Find dialog box.
// Return: A Boolean value that indicates succees. TRUE if successful; FALSE otherwise.
// Param: fd A value that indicates the find direction. FD_UP to set the find direction to up; FD_DOWN to set the find direction to down. (Default value is FD_DOWN.)
// END_HELP_COMMENT
BOOL UIFindDlg::SetDirection(UIFindDlg::FindDirection fd /*= FD_DOWN*/)
{
	if (fd == FD_UP) {
		MST.WOptionClick(GetLabel(VSHELL_IDC_FIND_UP));
	}
	else {
		if (fd == FD_DOWN) {
			MST.WOptionClick(GetLabel(VSHELL_IDC_FIND_DOWN));
		}
		else {
			ASSERT(0);
			// REVIEW(briancr): we need to set an the error type and string here
			return FALSE;
		}
	}
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIFindDlg::FindNext(void)
// Description: Perform the find operation by clicking the Find Next button in the Find dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIFindDlg::FindNext(void)
{
	MST.WButtonClick(GetLabel(VSHELL_IDC_FIND_NEXT));
	// REVIEW(briancr): we need to set an error type and string here if the dialog doesn't go away
	return WaitUntilGone(1000);
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIFindDlg::SetBookmarks(void)
// Description: Perform the set bookmarks operation by clicking on the Set Bookmarks on All button in the Find dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIFindDlg::SetBookmarks(void)
{
	MST.WButtonClick(GetLabel(VSHELL_IDC_FIND_MARK_ALL));
	// REVIEW(briancr): we need to set an error type and string here if the dialog doesn't go away
	return WaitUntilGone(1000);
}

///////////////////////////////////////////////////////////////////////////////
//	UIReplaceDlg class

// base class overrides
BOOL UIReplaceDlg::VerifyUnique(void) const
{
	return VerifyDlgItemClass(VCPP32_ID_REPLACE_REPLACEWITH, GL_COMBOBOX);
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIReplaceDlg::Activate(void)
// Description: Open the Replace dialog.
// Return: NULL, if successful; the HWND of the Replace dialog, if it failed to close.
// END_HELP_COMMENT
BOOL UIReplaceDlg::Activate(void)
{
	UIWB.DoCommand(ID_EDIT_REPLACE, DC_MNEMONIC);
	if (WaitAttachActive(5000)) {
		return TRUE;
	}
	return FALSE;
}

// BEGIN_HELP_COMMENT
// Function: HWND UIReplaceDlg::Close(void)
// Description: Close the Replace dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
HWND UIReplaceDlg::Close(void)
{
	return UIDialog::Cancel();
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIReplaceDlg::SetFindString(LPCSTR szFind)
// Description: Enter the text given in szFind in the Find What edit box in the Replace dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: szFind A pointer to a string that contains the text to enter in the Find What edit box in the Replace dialog.
// END_HELP_COMMENT
BOOL UIReplaceDlg::SetFindString(LPCSTR szFind)
{
	MST.WComboSetText(GetLabel(VCPP32_ID_REPLACE_WHAT), szFind);
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIReplaceDlg::SetReplaceString(LPCSTR szReplace)
// Description: Enter the text given in szReplace in the Replace With edit box in the Replace dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: szReplace A pointer to a string that contains the text to enter in the Replace With edit box in the Replace dialog.
// END_HELP_COMMENT
BOOL UIReplaceDlg::SetReplaceString(LPCSTR szReplace)
{
	MST.WComboSetText(GetLabel(VCPP32_ID_REPLACE_REPLACEWITH), szReplace);
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIReplaceDlg::SetMatchWord(BOOL bMatchWord)
// Description: Check or uncheck the Match Whole Word Only checkbox based on the value of bMatchWord.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: bMatchWord A Boolean value that, if TRUE means check the Match Whole Word Only checkbox, and if FALSE means uncheck it. (Default value is FALSE.)
// END_HELP_COMMENT
BOOL UIReplaceDlg::SetMatchWord(BOOL bMatchWord /*= FALSE*/)
{
	if (bMatchWord) {
		MST.WCheckCheck(GetLabel(VCPP32_ID_REPLACE_WHOLEWORD));
	}
	else {
		MST.WCheckUnCheck(GetLabel(VCPP32_ID_REPLACE_WHOLEWORD));
	}
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIReplaceDlg::SetMatchCase(BOOL bMatchCase)
// Description: Check or uncheck the Match Case checkbox based on the value of bMatchCase.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: bMatchCase A Boolean value that, if TRUE means check the Match Case checkbox, and if FALSE means uncheck it. (Default value is FALSE.)
// END_HELP_COMMENT
BOOL UIReplaceDlg::SetMatchCase(BOOL bMatchCase /*= FALSE*/)
{
	if (bMatchCase) {
		MST.WCheckCheck(GetLabel(VCPP32_ID_REPLACE_MATCHUPLO));
	}
	else {
		MST.WCheckUnCheck(GetLabel(VCPP32_ID_REPLACE_MATCHUPLO));
	}
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIReplaceDlg::SetRegularExpression(BOOL bRegExpr)
// Description: Check or uncheck the Regular Expression checkbox based on the value of bRegExpr.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: bRegExpr A Boolean value that, if TRUE means check the Regular Expression checkbox, and if FALSE means uncheck it. (Default value is FALSE.)
// END_HELP_COMMENT
BOOL UIReplaceDlg::SetRegularExpression(BOOL bRegExpr)
{
	if (bRegExpr) {
		MST.WCheckCheck(GetLabel(VCPP32_ID_REPLACE_REGEXP));
	}
	else {
		MST.WCheckUnCheck(GetLabel(VCPP32_ID_REPLACE_REGEXP));
	}
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIReplaceDlg::SetReplaceScope(UIReplaceDlg::ReplaceScope rs)
// Description: Set the replace scope in the Replace dialog box.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: fd A value that indicates the scope of the find and replace operation: RS_WHOLEFILE to set the replace scope to the whole file; RS_SELECTION to set the replace scope to the selection. (Default value is RS_WHOLEFILE.)
// END_HELP_COMMENT
BOOL UIReplaceDlg::SetReplaceScope(UIReplaceDlg::ReplaceScope rs)
{
	if (rs == UIReplaceDlg::RS_WHOLEFILE) {
		MST.WOptionClick(GetLabel(VCPP32_IDC_REPLACEMODEWHOLEFILE));
	}
	else {
		if (rs == UIReplaceDlg::RS_SELECTION) {
			MST.WOptionClick(GetLabel(VCPP32_IDC_REPLACEMODESELECTION));
		}
		else {
			ASSERT(0);
			// REVIEW(briancr): we need to set the error type and string here
			return FALSE;
		}
	}
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIReplaceDlg::FindNext(void)
// Description: Perform the find operation by clicking the Find Next button in the Replace dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIReplaceDlg::FindNext(void)
{
	if (!MST.WButtonEnabled(GetLabel(VCPP32_ID_REPLACE_FINDNEXT))) {
		// REVIEW(briancr): we need to set the error type and string here
		return FALSE;
	}
	MST.WButtonClick(GetLabel(VCPP32_ID_REPLACE_FINDNEXT));
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIReplaceDlg::Replace(void)
// Description: Perform the replace operation by clicking the Replace button in the Replace dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIReplaceDlg::Replace(void)
{
	if (!MST.WButtonEnabled(GetLabel(VCPP32_ID_REPLACE_REPLACE))) {
		// REVIEW(briancr): we need to set the error type and string here
		return FALSE;
	}
	MST.WButtonClick(GetLabel(VCPP32_ID_REPLACE_REPLACE));
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIReplaceDlg::ReplaceAll(void)
// Description: Perform the replace all operation by clicking the Replace All button in the Replace dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
int UIReplaceDlg::ReplaceAll(void)
{
	MST.WButtonClick(GetLabel(VCPP32_ID_REPLACE_REPLACEALL));
	CString str = UIWB.GetStatusText();		// X occurance(s) have been replaced
	int n;
	sscanf(str, "%d", &n);
	return n;	// return how many were replaced
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\eds\ufindrep.h ===
///////////////////////////////////////////////////////////////////////////////
//	UFINDREP.H
//
//	Created by :			Date :
//		DavidGa					4/13/94
//
//	Description :
//		Declaration of the UIFindDlg and UIReplaceDlg classes
//

#ifndef __UIFINDREP_H__
#define __UIFINDREP_H__

#include "..\..\udialog.h"

#include "edsxprt.h"

#ifndef __UIDIALOG_H__
	#error include 'udialog.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//	UIFindDlg class

//enum { DIR_DOWN = FALSE, DIR_UP = TRUE };

// BEGIN_CLASS_HELP
// ClassName: UIFindDlg
// BaseClass: UIDialog
// Category: Editors
// END_CLASS_HELP
class EDS_CLASS UIFindDlg : public UIDialog
{
// data types
public:
	enum FindDirection { FD_DOWN, FD_UP };

// base class overrides
public:	
	UIWND_COPY_CTOR(UIFindDlg, UIDialog);

	virtual BOOL VerifyUnique(void) const;
	virtual BOOL Activate(void);
	virtual HWND Close(void);

// operations
public:
	BOOL SetFindString(LPCSTR szFind);
	BOOL SetMatchWord(BOOL bMatchWord = FALSE);
	BOOL SetMatchCase(BOOL bMatchCase = FALSE);
	BOOL SetRegularExpression(BOOL bRegExpr = FALSE);
	BOOL SetDirection(FindDirection fd = FD_DOWN);

	BOOL FindNext(void);
	BOOL SetBookmarks(void);
};

///////////////////////////////////////////////////////////////////////////////
//	UIReplaceDlg class

// BEGIN_CLASS_HELP
// ClassName: UIReplaceDlg
// BaseClass: UIDialog
// Category: Editors
// END_CLASS_HELP
class EDS_CLASS UIReplaceDlg : public UIDialog
{
// data types
public:
	enum ReplaceScope { RS_WHOLEFILE, RS_SELECTION };

// base class overrides
public:
	UIWND_COPY_CTOR(UIReplaceDlg, UIDialog);
	virtual BOOL VerifyUnique(void) const;
	virtual BOOL Activate(void);
	virtual HWND Close(void);

// operations
public:
	BOOL SetFindString(LPCSTR szFind);
	BOOL SetReplaceString(LPCSTR szReplace);
	BOOL SetMatchWord(BOOL bMatchWord = FALSE);
	BOOL SetMatchCase(BOOL bMatchCase = FALSE);
	BOOL SetRegularExpression(BOOL bRegExpr = FALSE);
	BOOL SetReplaceScope(ReplaceScope rs = RS_WHOLEFILE);

	BOOL FindNext(void);
	BOOL Replace(void);
	int ReplaceAll(void);
};

#endif //__UIFINDREP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\eds\ueditor.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	UEDITOR.CPP
//
//	Created by :			Date :
//		DavidGa					9/25/93
//
//	Description :
//		Implementation of the UIEditor class
//

#include "stdafx.h"
#include "ueditor.h"
#include "testxcpt.h"
#include "mstwrap.h"
#include "..\shl\uiwbmsg.h"
#include "..\shl\uwbframe.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: BOOL UIEditor::AttachActive(void)
// Description: Initialize this object by attaching to the active editor window.
// Return: A Boolean value that indicates success. TRUE if successfully attached to the active editor window; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIEditor::AttachActive(void)
{
	return Attach(UIWB.GetActiveEditor());
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIEditor::IsActive(void)
// Description: Determine if this editor window is active.
// Return: A Boolean value that indicates success. TRUE if the editor window is active; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIEditor::IsActive(void)
{
	return UIWB.IsActive() && (UIWB.GetActiveEditor() == HWnd());
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIEditor::Activate(void)
// Description: Activate this editor window by giving the window the focus.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIEditor::Activate(void)
{
	return UIWB.SetActiveEditor(HWnd());
}

// BEGIN_HELP_COMMENT
// Function: CString UIEditor::GetTitle(void) const
// Description: Get the title of this editor window.
// Return: A CString containing the title of this window.
// END_HELP_COMMENT
CString UIEditor::GetTitle(void) const
{
	if( IsZoomed(HWnd()) )		// return portion of main caption
	{							// that would have been the editor's caption
		CString str = UIWB.GetText();
		int nLeftBracket = str.ReverseFind( '[' );
		EXPECT( -1 != nLeftBracket );
		EXPECT( str[str.GetLength()-1] == ']' );
		str = str.Mid( nLeftBracket+1 );
		return str.Left( str.GetLength()-1 );
	}
	else
	{
		return GetText();
	}
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIEditor::Close(BOOL bLoseChanges /*=TRUE*/)
// Description: Close this editor window.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: bLoseChanges A Boolean value that indicates whether to lose changes (TRUE) or save them (FALSE). (The default value is TRUE.)
// END_HELP_COMMENT
BOOL UIEditor::Close(BOOL bLoseChanges /*=TRUE*/)
{
//	if( !IsActive() && UIWB.SetActiveEditor(HWnd()) )
//		return FALSE;

	MST.DoKeys("^{F4}");	// File/Close can close too much in RC files

	UIWBMessageBox mb;
	while( mb.WaitAttachActive(500) )
	{
		if( mb.ButtonExists(MSG_NO) )
			mb.ButtonClick(MSG_NO);
		else
			EXPECT( FALSE );	// this shouldn't happen
	}

	return TRUE ; // WaitUntilGone(4000);		// give it 2 seconds to disappear
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\cocompon.h ===
///////////////////////////////////////////////////////////////////////////////
//  COCOMPON.H
//
//  Created by :            Date :
//      MichMa               5/7/97
//															
//  Description :
//      Declaration of the COComponent base class and component-specific derivatives.
//

#ifndef __COCOMPON_H__
#define __COCOMPON_H__

#include "prjxprt.h"


///////////////////////////////////////////////////////////////////////////////
// COComponent class
//
// all component classes should inherit from this base class, adding component-specifc
// wizard options, and overriding WizardFunc to handle the component-specific wizard.
//
// BEGIN_CLASS_HELP
// ClassName: COComponent
// BaseClass: None
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS COComponent

{
public:
	CString m_strGalleryName;		// name used in various gallery dlgs, help
	CString m_strFileName;			// name used in the gallery list and filename field
	CString m_strDescription;		// description displayed in gallery dlg

	virtual BOOL WizardFunc(void) = 0;		// function to handle the component-specific wizard.
};


///////////////////////////////////////////////////////////////////////////////
// ActiveXControlContainmentComponent class
//
// BEGIN_CLASS_HELP
// ClassName: ActiveXControlContainmentComponent
// BaseClass: COComponent
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS ActiveXControlContainmentComponent : public COComponent
{
public:
	// constructor initializes inherited COComponent and other members.
	ActiveXControlContainmentComponent(void);
	// title of the wizard dlg.
	CString m_strWizardDlgTitle;
	// handles the component's wizard.
	virtual BOOL WizardFunc(void);
};


///////////////////////////////////////////////////////////////////////////////
// ClipboardAssistantComponent class
//
// BEGIN_CLASS_HELP
// ClassName: ClipboardAssistantComponent
// BaseClass: COComponent
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS ClipboardAssistantComponent : public COComponent
{
public:
	// constructor initializes inherited COComponent and other members.
	ClipboardAssistantComponent(void);
	// title of the wizard dlg.
	CString m_strWizardDlgTitle;
	// TODO(michma): add member variables to represent the changeable options in the wizard.
	// handles the component's wizard.
	virtual BOOL WizardFunc(void);
};


///////////////////////////////////////////////////////////////////////////////
// DialogBarComponent class
//
// BEGIN_CLASS_HELP
// ClassName: DialogBarComponent
// BaseClass: COComponent
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS DialogBarComponent : public COComponent

{
public:
	
	// for "Default docking edge" option (m_etDocking, below).
	typedef enum {EDGE_TOP = 1, EDGE_BOTTOM, EDGE_LEFT, EDGE_RIGHT} EDGE_TYPE;

	// constructor initializes inherited COComponent and other members.
	DialogBarComponent(void);

	// title of the first (and only) wizard dlg.
	CString m_strWizardDlgTitle;

	// these correspond to options in the Dialog Bar component wizard.
	CString m_strName;
	CString m_strMemberVar;
	CString m_strFrame;
	EDGE_TYPE m_etDocking;
	BOOL m_bVisible;
	BOOL m_bDockable;

	// handles the Dialog Bar component wizard.
	virtual BOOL WizardFunc(void);
};


///////////////////////////////////////////////////////////////////////////////
// DocumentRegistrationComponent class
//
// BEGIN_CLASS_HELP
// ClassName: DocumentRegistrationComponent
// BaseClass: COComponent
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS DocumentRegistrationComponent : public COComponent
{
public:
	// constructor initializes inherited COComponent and other members.
	DocumentRegistrationComponent(void);
	// title of the wizard dlg.
	CString m_strWizardDlgTitle;
	// these correspond to options in the component's wizard.
	CString m_strExtension;
	// handles the component's wizard.
	virtual BOOL WizardFunc(void);
};


///////////////////////////////////////////////////////////////////////////////
// IdleTimeProcessingComponent class
//
// BEGIN_CLASS_HELP
// ClassName: IdleTimeProcessingComponent
// BaseClass: COComponent
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS IdleTimeProcessingComponent : public COComponent
{
public:
	
	// constructor initializes inherited COComponent and other members.
	IdleTimeProcessingComponent(void);
	// title of the wizard dlg.
	CString m_strWizardDlgTitle;
	// these correspond to options in the component's wizard.
	// TODO: add support for setting wizard options to non-defaults.
	// handles the component's wizard.
	virtual BOOL WizardFunc(void);
};


///////////////////////////////////////////////////////////////////////////////
// MAPIComponent class
//
// BEGIN_CLASS_HELP
// ClassName: MAPIComponent
// BaseClass: COComponent
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS MAPIComponent : public COComponent

{
public:
	
	// constructor initializes inherited COComponent and other members.
	MAPIComponent(void);

	// title of the wizard dlg.
	CString m_strWizardDlgTitle;

	// these correspond to options in the component's wizard.
	// TODO: add support for setting wizard options.

	// handles the component's wizard.
	virtual BOOL WizardFunc(void);
};


///////////////////////////////////////////////////////////////////////////////
// OwnerDrawControlsComponent class
//
// BEGIN_CLASS_HELP
// ClassName: OwnerDrawControlsComponent
// BaseClass: COComponent
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS OwnerDrawControlsComponent : public COComponent

{
public:
	
	// constructor initializes inherited COComponent and other members.
	OwnerDrawControlsComponent(void);

	// title of the wizard dlg.
	CString m_strWizardDlgTitle;

	// these correspond to options in the component's wizard.
	// TODO: add support for setting wizard options.
	
	// handles the component's wizard.
	virtual BOOL WizardFunc(void);
};


///////////////////////////////////////////////////////////////////////////////
// PaletteComponent class
//
// BEGIN_CLASS_HELP
// ClassName: PaletteComponent
// BaseClass: COComponent
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS PaletteComponent : public COComponent

{
public:
	
	// constructor initializes inherited COComponent and other members.
	PaletteComponent(void);

	// title of the wizard dlg.
	CString m_strWizardDlgTitle;

	// these correspond to options in the component's wizard.
	// TODO: add support for setting wizard options.

	// handles the component's wizard.
	virtual BOOL WizardFunc(void);
};


///////////////////////////////////////////////////////////////////////////////
// PopUpMenuComponent class
//
// BEGIN_CLASS_HELP
// ClassName: PopUpMenuComponent
// BaseClass: COComponent
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS PopUpMenuComponent : public COComponent

{
public:
	
	// constructor initializes inherited COComponent and other members.
	PopUpMenuComponent(void);

	// title of the wizard dlg.
	CString m_strWizardDlgTitle;

	// these correspond to options in the component's wizard.
	// TODO: add support for setting wizard options.

	// handles the component's wizard.
	virtual BOOL WizardFunc(void);
};


///////////////////////////////////////////////////////////////////////////////
// ProgressDialogComponent class
//
// BEGIN_CLASS_HELP
// ClassName: ProgressDialogComponent
// BaseClass: COComponent
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS ProgressDialogComponent : public COComponent

{
public:
	
	// constructor initializes inherited COComponent and other members.
	ProgressDialogComponent(void);

	// title of the wizard dlg.
	CString m_strWizardDlgTitle;

	// these correspond to options in the component's wizard.
	// TODO: add support for setting wizard options.

	// handles the component's wizard.
	virtual BOOL WizardFunc(void);
};


///////////////////////////////////////////////////////////////////////////////
// SplashScreenComponent class
//
// BEGIN_CLASS_HELP
// ClassName: SplashScreenComponent
// BaseClass: COComponent
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS SplashScreenComponent : public COComponent

{
public:
	
	// constructor initializes inherited COComponent and other members.
	SplashScreenComponent(void);

	// title of the wizard dlg.
	CString m_strWizardDlgTitle;

	// these correspond to options in the component's wizard.
	// TODO: add support for setting wizard options.

	// handles the component's wizard.
	virtual BOOL WizardFunc(void);
};


///////////////////////////////////////////////////////////////////////////////
// SplitBarsComponent class
//
// BEGIN_CLASS_HELP
// ClassName: SplitBarsComponent
// BaseClass: COComponent
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS SplitBarsComponent : public COComponent

{
public:
	
	// constructor initializes inherited COComponent and other members.
	SplitBarsComponent(void);

	// title of the wizard dlg.
	CString m_strWizardDlgTitle;

	// these correspond to options in the component's wizard.
	// TODO: add support for setting wizard options.

	// handles the component's wizard.
	virtual BOOL WizardFunc(void);
};


///////////////////////////////////////////////////////////////////////////////
// StatusBarComponent class
//
// BEGIN_CLASS_HELP
// ClassName: StatusBarComponent
// BaseClass: COComponent
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS StatusBarComponent : public COComponent

{
public:
	
	// for date/time display options in the wizard (sdtDate, sdtTime, below).
	typedef enum {STATUS_DISPLAY_NONE = 1, STATUS_DISPLAY_DEFAULT, STATUS_DISPLAY_CUSTOM} STATUS_DISPLAY_TYPE;

	// constructor initializes inherited COComponent and other members.
	StatusBarComponent(void);

	// title of the wizard dlg.
	CString m_strWizardDlgTitle;

	// these correspond to options in the component's wizard.
	// TODO: add support for the rest of the wizard options.
	STATUS_DISPLAY_TYPE m_sdtDate;
	STATUS_DISPLAY_TYPE m_sdtTime;

	// handles the component's wizard.
	virtual BOOL WizardFunc(void);
};


///////////////////////////////////////////////////////////////////////////////
// SystemInfoComponent class
//
// BEGIN_CLASS_HELP
// ClassName: SystemInfoComponent
// BaseClass: COComponent
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS SystemInfoComponent : public COComponent
{
public:
	// constructor initializes inherited COComponent and other members.
	SystemInfoComponent(void);
	// title of the wizard dlg.
	CString m_strWizardDlgTitle;
	// handles the component's wizard.
	virtual BOOL WizardFunc(void);
};


///////////////////////////////////////////////////////////////////////////////
// TipOfTheDayComponent class
//
// BEGIN_CLASS_HELP
// ClassName: TipOfTheDayComponent
// BaseClass: COComponent
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS TipOfTheDayComponent : public COComponent

{
public:
	
	// constructor initializes inherited COComponent and other members.
	TipOfTheDayComponent(void);

	// title of the wizard dlg.
	CString m_strWizardDlgTitle;

	// these correspond to options in the component's wizard.
	// TODO: add support for setting wizard options.

	// handles the component's wizard.
	virtual BOOL WizardFunc(void);
};


///////////////////////////////////////////////////////////////////////////////
// ToolTipsComponent class
//
// BEGIN_CLASS_HELP
// ClassName: ToolTipsComponent
// BaseClass: COComponent
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS ToolTipsComponent : public COComponent

{
public:
	
	// constructor initializes inherited COComponent and other members.
	ToolTipsComponent(void);

	// title of the wizard dlg.
	CString m_strWizardDlgTitle;

	// these correspond to options in the component's wizard.
	// TODO: add support for setting wizard options.

	// handles the component's wizard.
	virtual BOOL WizardFunc(void);
};


///////////////////////////////////////////////////////////////////////////////
// WindowsMultiMediaComponent class
//
// BEGIN_CLASS_HELP
// ClassName: WindowsMultiMediaComponent
// BaseClass: COComponent
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS WindowsMultiMediaComponent : public COComponent
{
public:
	// constructor initializes inherited COComponent and other members.
	WindowsMultiMediaComponent(void);
	// title of the wizard dlg.
	CString m_strWizardDlgTitle;
	// handles the component's wizard.
	virtual BOOL WizardFunc(void);
};


///////////////////////////////////////////////////////////////////////////////
// WindowsSocketsComponent class
//
// BEGIN_CLASS_HELP
// ClassName: WindowsSocketsComponent
// BaseClass: COComponent
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS WindowsSocketsComponent : public COComponent
{
public:
	// constructor initializes inherited COComponent and other members.
	WindowsSocketsComponent(void);
	// title of the wizard dlg.
	CString m_strWizardDlgTitle;
	// handles the component's wizard.
	virtual BOOL WizardFunc(void);
};


///////////////////////////////////////////////////////////////////////////////
// WindowsSocketsComponent class
//
// BEGIN_CLASS_HELP
// ClassName: CActiveXControl
// BaseClass: COComponent
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS CActiveXControl : public COComponent
{
public:
	// constructor initializes inherited COComponent and other members.
	CActiveXControl(LPCSTR lpCtrlName, LPCSTR lpCtrlDesc=NULL);
	// title of the wizard dlg.
	CString m_strWizardDlgTitle;
	// handles the component's wizard.
	virtual BOOL WizardFunc(void);
};


#endif //__COCOMPON_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\cocompon.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  COCOMPON.CPP
//
//  Created by :            Date :
//      MichMa					5/7/97
//
//  Description :
//      Implementation of the COComponent base class and component-specific derivatives.
//
#include "stdafx.h"
#include "cocompon.h"
#include "mstwrap.h"
#include "..\shl\wbutil.h"
#include "guiv1.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


///////////////////////////////////////////////////////////////////////////////
// ActiveXControlContainmentComponent class


// BEGIN_HELP_COMMENT
// Function: ActiveXControlContainmentComponent::ActiveXControlContainmentComponent(void)
// Description: Constructs a ActiveXControlContainmentComponent object.
// Return: none.
// END_HELP_COMMENT
ActiveXControlContainmentComponent::ActiveXControlContainmentComponent(void)
{
	// these settings are constant.
	m_strGalleryName	= GetLocString(IDSS_COMP_ACTX_CONT_GAL_NAME);
	m_strFileName		= GetLocString(IDSS_COMP_ACTX_CONT_FILE_NAME);
	m_strDescription	= GetLocString(IDSS_COMP_ACTX_CONT_DESC);
	m_strWizardDlgTitle = GetLocString(IDSS_COMP_ACTX_CONT_WIZ_TITLE);
}


// BEGIN_HELP_COMMENT
// Function: BOOL ActiveXControlContainmentComponent::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the ActiveXControlContainmentComponent object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL ActiveXControlContainmentComponent::WizardFunc(void)

{
	// wait up to 3 seconds for the wizard dlg to become active.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! ActiveXControlContainmentComponent::WizardFunc - wizard not active");
		return FALSE;
	}

	// finish the wizard.
	MST.DoKeys("{ENTER}");

 	// wait up to 5 seconds for the wizard dlg to go away. 
	// the changes this wizard makes don't take much time.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_NOEXIST | FW_PART, 5))
	{
		LOG->RecordInfo("ERROR! ActiveXControlContainmentComponent::WizardFunc - wizard still active");
		return FALSE;
	}

	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// ClipboardAssistantComponent class


// BEGIN_HELP_COMMENT
// Function: ClipboardAssistantComponent::ClipboardAssistantComponent(void)
// Description: Constructs a ClipboardAssistantComponent object.
// Return: none.
// END_HELP_COMMENT
ClipboardAssistantComponent::ClipboardAssistantComponent(void)
{
	// these settings are constant.
	m_strGalleryName	= GetLocString(IDSS_COMP_CLIP_ASST_GAL_NAME);
	m_strFileName		= GetLocString(IDSS_COMP_CLIP_ASST_FILE_NAME);
	m_strDescription	= GetLocString(IDSS_COMP_CLIP_ASST_DESC);
	m_strWizardDlgTitle = GetLocString(IDSS_COMP_CLIP_ASST_WIZ_TITLE);
	// TODO(michma): add support for initializing the wizard options to their defaults.
}


// BEGIN_HELP_COMMENT
// Function: BOOL ClipboardAssistantComponent::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the ClipboardAssistantComponent object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL ClipboardAssistantComponent::WizardFunc(void)

{
	// wait up to 3 seconds for the wizard dlg to become active.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! ClipboardAssistantComponent::WizardFunc - wizard not active");
		return FALSE;
	}

	// continue past the 3 dlgs in the wizard.
	// TODO(michma): add support for changing the wizard options.
	for(int i = 0; i < 3; i++)
		MST.DoKeys("{ENTER}");

 	// wait up to 5 seconds for the wizard dlg to go away. 
	// the changes this wizard makes don't take much time.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_NOEXIST | FW_PART, 5))
	{
		LOG->RecordInfo("ERROR! ClipboardAssistantComponent::WizardFunc - wizard still active");
		return FALSE;
	}
	
	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// DialogBarComponent class


// BEGIN_HELP_COMMENT
// Function: DialogBarComponent::DialogBarComponent(void)
// Description: Constructs a DialogBarComponent object.
// Return: none.
// END_HELP_COMMENT
DialogBarComponent::DialogBarComponent(void)
{
	// these settings are constant.
	m_strGalleryName	= GetLocString(IDSS_COMP_DLG_BAR_GAL_NAME);
	m_strFileName		= GetLocString(IDSS_COMP_DLG_BAR_FILE_NAME);
	m_strDescription	= GetLocString(IDSS_COMP_DLG_BAR_DESC);	
	m_strWizardDlgTitle = GetLocString(IDSS_COMP_DLG_BAR_WIZ_TITLE);
	// these are wizard defaults.
	m_strName		= "My Dialog Bar";
	m_strMemberVar	= "m_wndMyDialogBar";
	m_strFrame		= "CMainFrame";
	m_etDocking		= EDGE_TOP;
	m_bVisible		= TRUE;
	m_bDockable		= TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL DialogBarComponent::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the DialogBarComponent object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL DialogBarComponent::WizardFunc(void)

{
	// wait up to 3 seconds for the wizard dlg to become active.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_DEFAULT, 3))
	{
		LOG->RecordInfo("ERROR! DialogBarComponent::WizardFunc - wizard not active");
		return FALSE;
	}

	// set the wizard options.
	MST.WEditSetText("@1", m_strName);
	MST.WEditSetText("@2", m_strMemberVar);
	MST.WComboItemClk("@1", m_strFrame);

	char szDocking[4];
	sprintf(szDocking, "@%d", m_etDocking);
	MST.WOptionSelect(szDocking);
	
	if(m_bVisible)
		MST.WCheckCheck("@1");
	else
		MST.WCheckUnCheck("@1");

	if(m_bDockable)
		MST.WCheckCheck("@2");
	else
		MST.WCheckUnCheck("@2");

	// finish the wizard.
	MST.DoKeys("{ENTER}");

	// wait up to 3 seconds for the wizard dlg to go away.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_NOEXIST, 3))
	{
		LOG->RecordInfo("ERROR! DialogBarComponent::WizardFunc - wizard dlg still active");
		return FALSE;
	}

	// wait up to 15 seconds for the confirmation dlg to become active (title is superset of wizard dlg).
	// during that time, the wizard will be modifying project files.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_PART, 15))
	{
		LOG->RecordInfo("ERROR! DialogBarComponent::WizardFunc - confirmation dlg not active");
		return FALSE;
	}

	// confirm.
	MST.DoKeys("{ENTER}");

	// wait up to 3 seconds for the confirmation dlg to go away.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_PART | FW_NOEXIST, 3))
	{
		LOG->RecordInfo("ERROR! DialogBarComponent::WizardFunc - confirmation still active");
		return FALSE;
	}

	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// DocumentRegistrationComponent class


// BEGIN_HELP_COMMENT
// Function: DocumentRegistrationComponent::DocumentRegistrationComponent(void)
// Description: Constructs a DocumentRegistrationComponent object.
// Return: none.
// END_HELP_COMMENT
DocumentRegistrationComponent::DocumentRegistrationComponent(void)
{
	// these settings are constant.
	m_strGalleryName	= GetLocString(IDSS_COMP_DOC_REG_GAL_NAME);
	m_strFileName		= GetLocString(IDSS_COMP_DOC_REG_FILE_NAME);
	m_strDescription	= GetLocString(IDSS_COMP_DOC_REG_DESC);	
	m_strWizardDlgTitle = GetLocString(IDSS_COMP_DOC_REG_WIZ_TITLE);
	// this is the only wizard option. note that the default is blank but it must be filled in for
	// the wizard to complete, so we set a usable default here.
	m_strExtension = "tst";
}


// BEGIN_HELP_COMMENT
// Function: BOOL DocumentRegistrationComponent::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the DocumentRegistrationComponent object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL DocumentRegistrationComponent::WizardFunc(void)

{
	// wait up to 3 seconds for the wizard dlg to become active.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! DocumentRegistrationComponent::WizardFunc - wizard not active");
		return FALSE;
	}

	// set the extension as specified by the user, and finish the wizard.
	MST.DoKeys(m_strExtension);
	MST.DoKeys("{ENTER}");

	// this wizard has two dlgs, both with the same title. so to keep track of where we are we need
	// to look for a button. the first dlg has a "cancel" and "ok" button, the second one just has "ok".
	// wait for the wizard dlg to go away.
	while(MST.WButtonExists(GetLocString(IDSS_CANCEL)));

	// wait up to 15 seconds for the confirmation dlg to become active.
	// some files are munged during this time.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_PART, 15))
	{
		LOG->RecordInfo("ERROR! DocumentRegistrationComponent::WizardFunc - confirmation dlg not active");
		return FALSE;
	}

	// continue past the confirmation dlg.
	MST.DoKeys("{ENTER}");
	
	// wait up to 3 seconds for cancellation dlg to go away.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_NOEXIST | FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! DocumentRegistrationComponent::WizardFunc - confirmation dlg still active");
		return FALSE;
	}

	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// IdleTimeProcessingComponent class


// BEGIN_HELP_COMMENT
// Function: IdleTimeProcessingComponent::IdleTimeProcessingComponent(void)
// Description: Constructs a IdleTimeProcessingComponent object.
// Return: none.
// END_HELP_COMMENT
IdleTimeProcessingComponent::IdleTimeProcessingComponent(void)
{
	// these settings are constant.
	m_strGalleryName	= GetLocString(IDSS_COMP_IDLE_TIME_PROC_GAL_NAME);
	m_strFileName		= GetLocString(IDSS_COMP_IDLE_TIME_PROC_FILE_NAME);
	m_strDescription	= GetLocString(IDSS_COMP_IDLE_TIME_PROC_DESC);	
	m_strWizardDlgTitle = GetLocString(IDSS_COMP_IDLE_TIME_PROC_WIZ_TITLE);
}


// BEGIN_HELP_COMMENT
// Function: BOOL IdleTimeProcessingComponent::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the IdleTimeProcessingComponent object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL IdleTimeProcessingComponent::WizardFunc(void)

{
	// wait up to 3 seconds for the wizard dlg to become active.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! IdleTimeProcessingComponent::WizardFunc - wizard not active");
		return FALSE;
	}

	// finish the wizard.
	MST.DoKeys("{ENTER}");

	// wait up to 3 seconds for the wizard dlg to go away (no need to wait for file munging, etc.)
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_NOEXIST | FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! IdleTimeProcessingComponent::WizardFunc - wizard still active");
		return FALSE;
	}

	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// MAPIComponent class


// BEGIN_HELP_COMMENT
// Function: MAPIComponent::MAPIComponent(void)
// Description: Constructs a MAPIComponent object.
// Return: none.
// END_HELP_COMMENT
MAPIComponent::MAPIComponent(void)
{
	// these settings are constant.
	m_strGalleryName	= GetLocString(IDSS_COMP_MAPI_GAL_NAME);
	m_strFileName		= GetLocString(IDSS_COMP_MAPI_FILE_NAME);
	m_strDescription	= GetLocString(IDSS_COMP_MAPI_DESC);	
	m_strWizardDlgTitle = GetLocString(IDSS_COMP_MAPI_WIZ_TITLE);
}


// BEGIN_HELP_COMMENT
// Function: BOOL MAPIComponent::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the MAPIComponent object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL MAPIComponent::WizardFunc(void)

{
	// wait up to 3 seconds for the wizard dlg to become active.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_DEFAULT, 3))
	{
		LOG->RecordInfo("ERROR! MAPIComponent::WizardFunc - wizard not active");
		return FALSE;
	}

	// finish the wizard.
	MST.DoKeys("{ENTER}");

	// wait up to 3 seconds for the wizard dlg to go away.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_NOEXIST, 3))
	{
		LOG->RecordInfo("ERROR! MAPIComponent::WizardFunc - wizard dlg still active");
		return FALSE;
	}

	// wait up to 3 seconds for the confirmation dlg to become active (title is superset of wizard dlg).
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_PART, 15))
	{
		LOG->RecordInfo("ERROR! MAPIComponent::WizardFunc - confirmation dlg not active");
		return FALSE;
	}

	// confirm.
	MST.DoKeys("{ENTER}");

	// wait up to 3 seconds for the confirmation dlg to go away.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_PART | FW_NOEXIST, 3))
	{
		LOG->RecordInfo("ERROR! MAPIComponent::WizardFunc - confirmation still active");
		return FALSE;
	}

	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// OwnerDrawControlsComponent class


// BEGIN_HELP_COMMENT
// Function: OwnerDrawControlsComponent::OwnerDrawControlsComponent(void)
// Description: Constructs a OwnerDrawControlsComponent object.
// Return: none.
// END_HELP_COMMENT
OwnerDrawControlsComponent::OwnerDrawControlsComponent(void)
{
	// these settings are constant.
	m_strGalleryName	= GetLocString(IDSS_COMP_OWNER_DRAW_CTRLS_GAL_NAME);
	m_strFileName		= GetLocString(IDSS_COMP_OWNER_DRAW_CTRLS_FILE_NAME);
	m_strDescription	= GetLocString(IDSS_COMP_OWNER_DRAW_CTRLS_DESC);	
	m_strWizardDlgTitle = GetLocString(IDSS_COMP_OWNER_DRAW_CTRLS_WIZ_TITLE);
}


// BEGIN_HELP_COMMENT
// Function: BOOL OwnerDrawControlsComponent::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the OwnerDrawControlsComponent object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL OwnerDrawControlsComponent::WizardFunc(void)

{
	// wait up to 3 seconds for the wizard dlg to become active.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! OwnerDrawControlsComponent::WizardFunc - wizard not active");
		return FALSE;
	}

	// finish the wizard.
	MST.DoKeys("{ENTER}");

	// wait up to 3 seconds for the wizard dlg to go away.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_NOEXIST | FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! OwnerDrawControlsComponent::WizardFunc - wizard still active");
		return FALSE;
	}

	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// PaletteComponent class


// BEGIN_HELP_COMMENT
// Function: PaletteComponent::PaletteComponent(void)
// Description: Constructs a PaletteComponent object.
// Return: none.
// END_HELP_COMMENT
PaletteComponent::PaletteComponent(void)
{
	// these settings are constant.
	m_strGalleryName	= GetLocString(IDSS_COMP_PALETTE_GAL_NAME);
	m_strFileName		= GetLocString(IDSS_COMP_PALETTE_FILE_NAME);
	m_strDescription	= GetLocString(IDSS_COMP_PALETTE_DESC);	
	m_strWizardDlgTitle = GetLocString(IDSS_COMP_PALETTE_WIZ_TITLE);
}


// BEGIN_HELP_COMMENT
// Function: BOOL PaletteComponent::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the PaletteComponent object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL PaletteComponent::WizardFunc(void)

{
	// wait up to 3 seconds for the wizard dlg to become active.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! PaletteComponent::WizardFunc - wizard not active");
		return FALSE;
	}

	// finish the wizard.
	MST.DoKeys("{ENTER}");

	// wait up to 3 seconds for the wizard dlg to go away.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_NOEXIST | FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! PaletteComponent::WizardFunc - wizard still active");
		return FALSE;
	}

	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// PopUpMenuComponent class


// BEGIN_HELP_COMMENT
// Function: PopUpMenuComponent::PopUpMenuComponent(void)
// Description: Constructs a PopUpMenuComponent object.
// Return: none.
// END_HELP_COMMENT
PopUpMenuComponent::PopUpMenuComponent(void)
{
	// these settings are constant.
	m_strGalleryName	= GetLocString(IDSS_COMP_POPUP_MENU_GAL_NAME);
	m_strFileName		= GetLocString(IDSS_COMP_POPUP_MENU_FILE_NAME);
	m_strDescription	= GetLocString(IDSS_COMP_POPUP_MENU_DESC);	
	m_strWizardDlgTitle = GetLocString(IDSS_COMP_POPUP_MENU_WIZ_TITLE);
}


// BEGIN_HELP_COMMENT
// Function: BOOL PopUpMenuComponent::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the PopUpMenuComponent object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL PopUpMenuComponent::WizardFunc(void)

{
	// wait up to 3 seconds for the wizard dlg to become active.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! PopUpMenuComponent::WizardFunc - wizard not active");
		return FALSE;
	}

	// finish the wizard.
	MST.DoKeys("{ENTER}");

	// wait up to 3 seconds for the wizard dlg to go away.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_NOEXIST | FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! PopUpMenuComponent::WizardFunc - wizard still active");
		return FALSE;
	}

	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// ProgressDialogComponent class


// BEGIN_HELP_COMMENT
// Function: ProgressDialogComponent::ProgressDialogComponent(void)
// Description: Constructs a ProgressDialogComponent object.
// Return: none.
// END_HELP_COMMENT
ProgressDialogComponent::ProgressDialogComponent(void)
{
	// these settings are constant.
	m_strGalleryName	= GetLocString(IDSS_COMP_PROGRESS_DLG_GAL_NAME);
	m_strFileName		= GetLocString(IDSS_COMP_PROGRESS_DLG_FILE_NAME);
	m_strDescription	= GetLocString(IDSS_COMP_PROGRESS_DLG_DESC);
	m_strWizardDlgTitle = GetLocString(IDSS_COMP_PROGRESS_DLG_WIZ_TITLE);
}


// BEGIN_HELP_COMMENT
// Function: BOOL ProgressDialogComponent::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the ProgressDialogComponent object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL ProgressDialogComponent::WizardFunc(void)

{
	// wait up to 3 seconds for the wizard dlg to become active.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! ProgressDialogComponent::WizardFunc - wizard not active");
		return FALSE;
	}

	// finish the wizard.
	MST.DoKeys("{ENTER}");

	// wait up to 3 seconds for the wizard dlg to go away.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_NOEXIST | FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! ProgressDialogComponent::WizardFunc - wizard still active");
		return FALSE;
	}

	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// SplashScreenComponent class


// BEGIN_HELP_COMMENT
// Function: SplashScreenComponent::SplashScreenComponent(void)
// Description: Constructs a SplashScreenComponent object.
// Return: none.
// END_HELP_COMMENT
SplashScreenComponent::SplashScreenComponent(void)
{
	// these settings are constant.
	m_strGalleryName	= GetLocString(IDSS_COMP_SPLASH_SCREEN_GAL_NAME);
	m_strFileName		= GetLocString(IDSS_COMP_SPLASH_SCREEN_FILE_NAME);
	m_strDescription	= GetLocString(IDSS_COMP_SPLASH_SCREEN_DESC);
	m_strWizardDlgTitle = GetLocString(IDSS_COMP_SPLASH_SCREEN_WIZ_TITLE);
}


// BEGIN_HELP_COMMENT
// Function: BOOL SplashScreenComponent::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the SplashScreenComponent object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL SplashScreenComponent::WizardFunc(void)

{
	// wait up to 3 seconds for the wizard dlg to become active.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! SplashScreenComponent::WizardFunc - wizard not active");
		return FALSE;
	}

	// finish the wizard.
	MST.DoKeys("{ENTER}");

	// wait up to 3 seconds for the wizard dlg to go away.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_NOEXIST | FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! SplashScreenComponent::WizardFunc - wizard still active");
		return FALSE;
	}

	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// SplitBarsComponent class


// BEGIN_HELP_COMMENT
// Function: SplitBarsComponent::SplitBarsComponent(void)
// Description: Constructs a SplitBarsComponent object.
// Return: none.
// END_HELP_COMMENT
SplitBarsComponent::SplitBarsComponent(void)
{
	// these settings are constant.
	m_strGalleryName	= GetLocString(IDSS_COMP_SPLIT_BARS_GAL_NAME);
	m_strFileName		= GetLocString(IDSS_COMP_SPLIT_BARS_FILE_NAME);
	m_strDescription	= GetLocString(IDSS_COMP_SPLIT_BARS_DESC);
	m_strWizardDlgTitle = GetLocString(IDSS_COMP_SPLIT_BARS_WIZ_TITLE);
}


// BEGIN_HELP_COMMENT
// Function: BOOL SplitBarsComponent::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the SplitBarsComponent object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL SplitBarsComponent::WizardFunc(void)

{
	// wait up to 3 seconds for the wizard dlg to become active.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! SplitBarsComponent::WizardFunc - wizard not active");
		return FALSE;
	}

	// finish the wizard.
	MST.DoKeys("{ENTER}");

	// wait up to 3 seconds for the wizard dlg to go away.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_NOEXIST | FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! SplitBarsComponent::WizardFunc - wizard still active");
		return FALSE;
	}

	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// StatusBarComponent class


// BEGIN_HELP_COMMENT
// Function: StatusBarComponent::StatusBarComponent(void)
// Description: Constructs a StatusBarComponent object.
// Return: none.
// END_HELP_COMMENT
StatusBarComponent::StatusBarComponent(void)
{
	// these settings are constant.
	m_strGalleryName	= GetLocString(IDSS_COMP_STATUS_BAR_GAL_NAME);
	m_strFileName		= GetLocString(IDSS_COMP_STATUS_BAR_FILE_NAME);
	m_strDescription	= GetLocString(IDSS_COMP_STATUS_BAR_DESC);
	m_strWizardDlgTitle = GetLocString(IDSS_COMP_STATUS_BAR_WIZ_TITLE);
	// these are wizard options.
	// note that we must tell the wizard to display either the date or time for the wizard to complete.
	m_sdtDate = STATUS_DISPLAY_DEFAULT;
	m_sdtTime = STATUS_DISPLAY_DEFAULT;
}


// BEGIN_HELP_COMMENT
// Function: BOOL StatusBarComponent::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the StatusBarComponent object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL StatusBarComponent::WizardFunc(void)

{
	// wait up to 3 seconds for the wizard dlg to become active.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! StatusBarComponent::WizardFunc - wizard not active");
		return FALSE;
	}

	// set the date display option.
	char szDisplay[4];
	sprintf(szDisplay, "@%d", m_sdtDate);
	MST.WOptionSelect(szDisplay);

	// advance to the next page of the wizard.
	MST.DoKeys("{ENTER}");

	// we know the next page is up when a certain option button appears.
	if(!MST.WFndWndWaitC(GetLocString(IDSS_DONT_DISPLAY_TIME), "Button", FW_DEFAULT, 3))
	{
		LOG->RecordInfo("ERROR! StatusBarComponent::WizardFunc - 2nd page of wizard not active");
		return FALSE;
	}

	// set the time display option.
	sprintf(szDisplay, "@%d", m_sdtTime);
	MST.WOptionSelect(szDisplay);

	// finish the wizard.
	MST.DoKeys("{ENTER}");
	MST.DoKeys("{ENTER}");

	// wait up to 3 seconds for the wizard dlg to go away.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_NOEXIST | FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! StatusBarComponent::WizardFunc - wizard still active");
		return FALSE;
	}

	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// SystemInfoComponent class


// BEGIN_HELP_COMMENT
// Function: SystemInfoComponent::SystemInfoComponent(void)
// Description: Constructs a SystemInfoComponent object.
// Return: none.
// END_HELP_COMMENT
SystemInfoComponent::SystemInfoComponent(void)
{
	// these settings are constant.
	m_strGalleryName	= GetLocString(IDSS_COMP_SYS_INFO_GAL_NAME);
	m_strFileName		= GetLocString(IDSS_COMP_SYS_INFO_FILE_NAME);
	m_strDescription	= GetLocString(IDSS_COMP_SYS_INFO_DESC);
	m_strWizardDlgTitle = GetLocString(IDSS_COMP_SYS_INFO_WIZ_TITLE);
}


// BEGIN_HELP_COMMENT
// Function: BOOL SystemInfoComponent::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the SystemInfoComponent object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL SystemInfoComponent::WizardFunc(void)

{
	// wait up to 3 seconds for the wizard dlg to become active.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! SystemInfoComponent::WizardFunc - wizard not active");
		return FALSE;
	}

	// finish the wizard.
	MST.DoKeys("{ENTER}");

	// wait up to 3 seconds for the wizard dlg to go away.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_NOEXIST | FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! SystemInfoComponent::WizardFunc - wizard still active");
		return FALSE;
	}

	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// TipOfTheDayComponent class


// BEGIN_HELP_COMMENT
// Function: TipOfTheDayComponent::TipOfTheDayComponent(void)
// Description: Constructs a TipOfTheDayComponent object.
// Return: none.
// END_HELP_COMMENT
TipOfTheDayComponent::TipOfTheDayComponent(void)
{
	// these settings are constant.
	m_strGalleryName	= GetLocString(IDSS_COMP_TIP_OF_DAY_GAL_NAME);
	m_strFileName		= GetLocString(IDSS_COMP_TIP_OF_DAY_FILE_NAME);
	m_strDescription	= GetLocString(IDSS_COMP_TIP_OF_DAY_DESC);
	m_strWizardDlgTitle = GetLocString(IDSS_COMP_TIP_OF_DAY_WIZ_TITLE);
}


// BEGIN_HELP_COMMENT
// Function: BOOL TipOfTheDayComponent::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the TipOfTheDayComponent object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL TipOfTheDayComponent::WizardFunc(void)

{
	// wait up to 3 seconds for the wizard dlg to become active.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! TipOfTheDayComponent::WizardFunc - wizard not active");
		return FALSE;
	}

	// finish the wizard.
	MST.DoKeys("{ENTER}");

	// wait up to 3 seconds for the wizard dlg to go away.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_NOEXIST | FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! TipOfTheDayComponent::WizardFunc - wizard still active");
		return FALSE;
	}

	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// ToolTipsComponent class


// BEGIN_HELP_COMMENT
// Function: ToolTipsComponent::ToolTipsComponent(void)
// Description: Constructs a ToolTipsComponent object.
// Return: none.
// END_HELP_COMMENT
ToolTipsComponent::ToolTipsComponent(void)
{
	// these settings are constant.
	m_strGalleryName	= GetLocString(IDSS_COMP_TOOLTIPS_GAL_NAME);
	m_strFileName		= GetLocString(IDSS_COMP_TOOLTIPS_FILE_NAME);
	m_strDescription	= GetLocString(IDSS_COMP_TOOLTIPS_DESC);
	m_strWizardDlgTitle = GetLocString(IDSS_COMP_TOOLTIPS_WIZ_TITLE);
}


// BEGIN_HELP_COMMENT
// Function: BOOL ToolTipsComponent::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the ToolTipsComponent object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL ToolTipsComponent::WizardFunc(void)

{
	// wait up to 3 seconds for the wizard dlg to become active.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! ToolTipsComponent::WizardFunc - wizard not active");
		return FALSE;
	}

	// finish the wizard.
	MST.DoKeys("{ENTER}");

	// wait up to 3 seconds for the wizard dlg to go away.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_NOEXIST | FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! ToolTipsComponent::WizardFunc - wizard still active");
		return FALSE;
	}

	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// WindowsMultiMediaComponent class


// BEGIN_HELP_COMMENT
// Function: WindowsMultiMediaComponent::WindowsMultiMediaComponent(void)
// Description: Constructs a WindowsMultiMediaComponent object.
// Return: none.
// END_HELP_COMMENT
WindowsMultiMediaComponent::WindowsMultiMediaComponent(void)
{
	// these settings are constant.
	m_strGalleryName	= GetLocString(IDSS_COMP_WIN_MM_GAL_NAME);
	m_strFileName		= GetLocString(IDSS_COMP_WIN_MM_FILE_NAME);
	m_strDescription	= GetLocString(IDSS_COMP_WIN_MM_DESC);
	m_strWizardDlgTitle = GetLocString(IDSS_COMP_WIN_MM_WIZ_TITLE);
}


// BEGIN_HELP_COMMENT
// Function: BOOL WindowsMultiMediaComponent::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the WindowsMultiMediaComponent object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL WindowsMultiMediaComponent::WizardFunc(void)

{
	// wait up to 3 seconds for the wizard dlg to become active.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! WindowsMultiMediaComponent::WizardFunc - wizard not active");
		return FALSE;
	}

	// finish the wizard.
	MST.DoKeys("{ENTER}");

	// wait up to 3 seconds for the wizard dlg to go away.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_NOEXIST | FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! WindowsMultiMediaComponent::WizardFunc - wizard still active");
		return FALSE;
	}

	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// WindowsSocketsComponent class


// BEGIN_HELP_COMMENT
// Function: WindowsSocketsComponent::WindowsSocketsComponent(void)
// Description: Constructs a WindowsSocketsComponent object.
// Return: none.
// END_HELP_COMMENT
WindowsSocketsComponent::WindowsSocketsComponent(void)
{
	// these settings are constant.
	m_strGalleryName	= GetLocString(IDSS_COMP_WIN_SOCKETS_GAL_NAME);
	m_strFileName		= GetLocString(IDSS_COMP_WIN_SOCKETS_FILE_NAME);
	m_strDescription	= GetLocString(IDSS_COMP_WIN_SOCKETS_DESC);
	m_strWizardDlgTitle = GetLocString(IDSS_COMP_WIN_SOCKETS_WIZ_TITLE);
}


// BEGIN_HELP_COMMENT
// Function: BOOL WindowsSocketsComponent::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the WindowsSocketsComponent object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL WindowsSocketsComponent::WizardFunc(void)

{
	// wait up to 3 seconds for the wizard dlg to become active.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! WindowsSocketsComponent::WizardFunc - wizard not active");
		return FALSE;
	}

	// finish the wizard.
	MST.DoKeys("{ENTER}");

	// wait up to 3 seconds for the wizard dlg to go away.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_NOEXIST | FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! WindowsSocketsComponent::WizardFunc - wizard still active");
		return FALSE;
	}

	return TRUE;
}



///////////////////////////////////////////////////////////////////////////////
// WindowsSocketsComponent class


// BEGIN_HELP_COMMENT
// Function: CActiveXControl::CActiveXControl(void)
// Description: Constructs a CActiveXControl object.
// Return: none.
// END_HELP_COMMENT
CActiveXControl::CActiveXControl(LPCSTR lpCtrlName, LPCSTR lpCtrlDesc /*=NULL*/)
{
	// these settings are constant.
	m_strGalleryName	= lpCtrlName;
	m_strFileName		= lpCtrlName;
	m_strDescription	= lpCtrlDesc;
	m_strWizardDlgTitle = "Confirm Classes"; //GetLocString(???);
}


// BEGIN_HELP_COMMENT
// Function: BOOL CActiveXControl::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the CActiveXControl object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL CActiveXControl::WizardFunc(void)

{
	// wait up to 3 seconds for the wizard dlg to become active.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! CActiveXControl::WizardFunc - wizard not active");
		return FALSE;
	}

	// finish the wizard.
	MST.DoKeys("{ENTER}");

	// wait up to 3 seconds for the wizard dlg to go away.
	if(!MST.WFndWndWait(m_strWizardDlgTitle, FW_NOEXIST | FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! CActiveXControl::WizardFunc - wizard still active");
		return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		BrianCr				09/06/94
//
//	Description :
//		source file that includes just the standard includes
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\odbcdlgs.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UCWZDLG.CPP
//
//  Created by :            Date :
//      Ivanl              3/07/94
//				  
//  Description :
//      Implementation of the UIClassWizard class
//

#include "stdafx.h"
#include "odbcdlgs.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\appwz.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


// BEGIN_HELP_COMMENT
// Function: HWND UISqlDataSources::Display(void)
// Description: Display the SQL Data Sources dialog. This dialog is used during AppWizard. This function is NYI.
// Return: The HWND of the SQL Data Sources dialog, if successful; NULL otherwise.
// END_HELP_COMMENT
 HWND UISqlDataSources::Display(void)
 {
 	return NULL ;
 }

// BEGIN_HELP_COMMENT
// Function: int UISqlDataSources::SetODBCName(CString ds) 
// Description: Set the name of the SQL data source in the SQL Data Sources dialog.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: ds A CString that contains the name of the SQL data source.
// END_HELP_COMMENT
 int  UISqlDataSources::SetODBCName(CString ds) 
 {
 	DataSource(ODBC_SOURCE);
	MST.WComboItemDblClk(GetLabel(CLSWIZ_IDC_ODBC_SOURCES), ds) ;
	return ERROR_SUCCESS ;
 }

 // BEGIN_HELP_COMMENT
// Function: int UISqlDataSources::SetODBCName(int ds) 
// Description: Set the name of the SQL data source in the SQL Data Sources dialog.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: ds A CString that contains the name of the SQL data source.
// END_HELP_COMMENT
 int  UISqlDataSources::SetODBCName(int ds) 
 {
 	DataSource(ODBC_SOURCE);
	MST.DoKeys("{TAB}") ; // Tab to the edit control.
	MST.WComboItemDblClk(GetLabel(CLSWIZ_IDC_ODBC_SOURCES), ds) ;
	return ERROR_SUCCESS ;
 }

 // BEGIN_HELP_COMMENT
// Function: int UISqlDataSources::SetDAOName(CString ds) 
// Description: Set the name of the SQL data source in the SQL Data Sources dialog.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: ds A CString that contains the name of the SQL data source.
// END_HELP_COMMENT
 int  UISqlDataSources::SetDAOName(CString ds) 
 {
 	DataSource(DAO_SOURCE);
	MST.DoKeys("{TAB}") ; // Tab to the edit control.
	MST.WEditSetText(GetLabel(CLSWIZ_IDC_DAO_SOURCE), ds) ;
	return ERROR_SUCCESS ;
 }



 // BEGIN_HELP_COMMENT
// Function: int UISqlDataSources::DataSource(Int Type)
// Description: Selects the type of data source ODBC or DAO
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: ds A CString that contains the name of the SQL data source.
// END_HELP_COMMENT
 int  UISqlDataSources::DataSource(DBSOURCES source) 
 {
	MST.WOptionClick(GetLabel(source));
	return ERROR_SUCCESS ;
 }

 // BEGIN_HELP_COMMENT
// Function: int UISqlDataSources::RecordSetType(REC_SET_TYPE Type)
// Description: Selects record set type Snap shot, dynaset, tables.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: ds A CString that contains the name of the SQL data source.
// END_HELP_COMMENT
 int  UISqlDataSources::RecordSetType(REC_SET_TYPE Type) 
 {
 	MST.WOptionClick(GetLabel(Type));
	return ERROR_SUCCESS ;
 }

 // BEGIN_HELP_COMMENT
// Function: int UISqlDataSources::DetectDirtyCol(int Yes = 1) 
// Description: Check the Detect Dirty col option
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: ds A CString that contains the name of the SQL data source.
// END_HELP_COMMENT
 int  UISqlDataSources::DetectDirtyCol(int Yes /* = 1 */) 
 {
	if(Yes)
		MST.WCheckCheck(GetLabel(CLSWIZ_IDC_AUTODETECT));
	else
		MST.WCheckUnCheck(GetLabel(CLSWIZ_IDC_AUTODETECT));

	return ERROR_SUCCESS ;
 }

 // BEGIN_HELP_COMMENT
// Function: int UISqlDataSources::BindAllCol(int Yes = 1) 
// Description: Specify if you want to set the Bind All collumn option.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: ds A CString that contains the name of the SQL data source.
// END_HELP_COMMENT
 int  UISqlDataSources::BindAllCol(int Yes /* = 1*/) 
 {
	if(Yes)
		MST.WCheckCheck(GetLabel(CLSWIZ_IDC_BIND_ALL));
	else
		MST.WCheckUnCheck(GetLabel(CLSWIZ_IDC_BIND_ALL));
	return ERROR_SUCCESS ;
 }

// BEGIN_HELP_COMMENT
// Function: int UISqlDataSources::Close(int OK /* = 1 */)
// Description: Close the SQL Data Sources dialog by clicking on either OK or Cancel.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: OK An integer that specifies which button to click on to dismiss the dialog. 1 to click on OK, 0 to click on Cancel. (Default value is 1.)
// END_HELP_COMMENT
 int UISqlDataSources::Close(int OK /* = 1 */)
 {
 	if (OK)
	{
	  	MST.DoKeys("{ENTER}") ;
	}
	else 
	{
		MST.DoKeys("{ESC}") ;
	}
   return ERROR_SUCCESS ;
 }  

   // UISqlServerLogIn class functions 
// BEGIN_HELP_COMMENT
// Function: int UISqlServerLogIn::ID(CString ID)
// Description: Set the ID in the SQL Server Log In dialog.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: ID A CString that contains the ID.
// END_HELP_COMMENT
int UISqlServerLogIn::ID(CString ID)
{
	MST.WEditSetText(GetLabel(0x7533), ID) ;
	return ERROR_SUCCESS ;
}
// BEGIN_HELP_COMMENT
// Function: int UISqlServerLogIn::Pw(CString pw)
// Description: Set the password in the SQL Server Log In dialog.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: pw A CString that contains the password.
// END_HELP_COMMENT
int UISqlServerLogIn::Pw(CString pw)
{
	MST.WEditSetText(GetLabel(0x7534),pw) ;
	return ERROR_SUCCESS ;
}

// BEGIN_HELP_COMMENT
// Function: int UISqlServerLogIn::Close(int OK/* = 1 */)
// Description: Close the SQL Server Log In dialog by clicking either the OK button or the Cancel button.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: OK An integer that specifies which button to click on to dismiss the dialog. 1 to click on OK, 0 to click on Cancel. (Default value is 1.)
// END_HELP_COMMENT
int UISqlServerLogIn::Close(int OK/* = 1 */)
{
	if (OK)
	{
	 	MST.DoKeys("{ENTER}") ;
	}
	else 
	{
		MST.DoKeys("{ESC}") ;
	}
   return ERROR_SUCCESS ;
} 

	// UISelectTables functions ;
// BEGIN_HELP_COMMENT
// Function: int UISelectTables::Name(CString tbName)
// Description: Set the table name in the Select Tables dialog by name. (See Name(int) to set the name by index.)
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: tbName A CString that contains the name of the table.
// END_HELP_COMMENT
int UISelectTables::Name(CString tbName)
{
	MST.DoKeys("{TAB 2}") ; // Tabs to the listbox.
	MST.WListItemDblClk(NULL,tbName) ;
	return ERROR_SUCCESS ;
}

// BEGIN_HELP_COMMENT
// Function: int UISelectTables::Name(int index /*= 1*/)
// Description: Set the table name in the Select Tables dialog by index. (See Name(CString) to set the name by name.)
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: index An integer that contains the index into the list of tables.
// END_HELP_COMMENT
int UISelectTables::Name(int index /*= 1*/)
{
	MST.DoKeys("{TAB 2}") ; // Tabs to the listbox 
	MST.WListItemDblClk(NULL,index);
	return ERROR_SUCCESS ;
}

// BEGIN_HELP_COMMENT
// Function: int UISelectTables::Close(int OK /* = 1 */)
// Description: Close the Select Tables dialog by clicking either the OK button or the Cancel button.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: OK An integer that specifies which button to click on to dismiss the dialog. 1 to click on OK, 0 to click on Cancel. (Default value is 1.)
// END_HELP_COMMENT
int UISelectTables::Close(int OK /* = 1 */)
{
	if (OK)
	{
	 	MST.DoKeys("{ENTER}") ;
		WaitForWndWithCtrl(APPWZ_IDC_DATA_SOURCE,3000) ;
		MST.DoKeys("{TAB}") ; // Tab to the main dialog.

	}
	else 
	{
		MST.DoKeys("{ESC}") ;
	}
   return ERROR_SUCCESS ;
}             
 
// BEGIN_HELP_COMMENT
// Function: int UISelectRecordSet::Close(int OK /* = 1*/)
// Description: Close the Select Record Set dialog by clicking either the OK button or the Cancel button.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: OK An integer that specifies which button to click on to dismiss the dialog. 1 to click on OK, 0 to click on Cancel. (Default value is 1.)
// END_HELP_COMMENT
int UISelectRecordSet::Close(int OK /* = 1*/)
{
	if (OK)
	{
	 	MST.DoKeys("{ENTER}") ;
	}
	else 
	{
		MST.DoKeys("{ESC}") ;
	}
   return ERROR_SUCCESS ;
} 

// BEGIN_HELP_COMMENT
// Function: UIDataBaseDlgs *UISelectRecordSet::New() 
// Description: Bring up the Database dialog.
// Return: A pointer to a UIDataBaseDlgs object that represents the dialog opened.
// END_HELP_COMMENT
UIDataBaseDlgs *UISelectRecordSet::New() 
{
	static UIDataBaseDlgs dbdlgs ;
	dbdlgs.WaitForSources() ;
	return &dbdlgs ;
}

// BEGIN_HELP_COMMENT
// Function: int UIDataBaseDlgs::WaitForSources() 
// Description: Wait for the SQL Data Sources dialog to exist.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// END_HELP_COMMENT
int UIDataBaseDlgs::WaitForSources() 
	 {
	 	if (WaitForWndWithCtrl(0x1F5,1000))
			return ERROR_SUCCESS ;
		return ERROR_ERROR ;
	 }
// BEGIN_HELP_COMMENT
// Function: int UIDataBaseDlgs::WaitForLogin() 
// Description: Wait for the Server Log In dialog to exist
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// END_HELP_COMMENT
int UIDataBaseDlgs::WaitForLogin() 
 	 {
	 if (WaitForWndWithCtrl(0x7539,1000))
			return ERROR_SUCCESS ;
		return ERROR_ERROR ;
	 }

// BEGIN_HELP_COMMENT
// Function: int UIDataBaseDlgs::WaitForTables()
// Description: Wait for the Select Tables dialog to exist.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// END_HELP_COMMENT
int UIDataBaseDlgs::WaitForTables()
	 {
	 	if (WaitForWndWithCtrl(0x3F0,1000))
			return ERROR_SUCCESS ;
		return ERROR_ERROR ;
	 }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		BrianCr				09/06/94
//
//	Description :
//		Precompiled header for all of the core MFC files
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\coprject.h ===
///////////////////////////////////////////////////////////////////////////////
//  COPRJECT.H 
//
//  Created by :            Date :
//      IvanL               1/17/94
//															
//  Description :
//      Declaration of the COProject class
//

#ifndef __COPROJECT_H__
#define __COPROJECT_H__

#include "..\..\testutil.h"
#include "..\sym\projprop.h"
#include "..\shl\uwbframe.h"
#include "..\shl\wbutil.h"
#include "uprojwiz.h"
#include "uprjtdlg.h"
#include "..\wrk\uiwrkspc.h"
#include "uogaldlg.h"
#include "cocompon.h"
#include "uictrlwz.h"

#include "prjxprt.h"

#define ERROR_ERROR -1

// option for SetLocalTarget()
typedef enum {NO_DEFAULT_DBG_EXE = 0, DEFAULT_DBG_EXE_CONTAINER = 2, DEFAULT_DBG_EXE_BROWSER = 3} DEFAULT_DBG_EXE_TYPE;
// for SetDebugInfo()
enum DEBUG_INFO_TYPE {NO_DEBUG_INFO = 1, LINE_NUMBERS_ONLY, C7_COMPATIBLE, PROGRAM_DATABASE, EC_PROGRAM_DATABASE};
// options for SetRemotePath()
typedef enum {PREPEND_REMOTE_PATH, FULL_PATH_SUPPLIED} SRT_OPT;
// build types
enum BUILD_TYPE	{BUILD_DEBUG = IDSS_BUILD_DEBUG, BUILD_RELEASE = IDSS_BUILD_RELEASE};

// target types
typedef enum {TARGET_WIN32_X86_DEBUG, TARGET_WIN32_X86_RELEASE,
			  TARGET_MAC_68K_DEBUG, TARGET_MAC_68K_RELEASE,
			  TARGET_MAC_PPC_DEBUG, TARGET_MAC_PPC_RELEASE,
			  // added xbox types
			  TARGET_XBOX_DEBUG, TARGET_XBOX_RELEASE,
			  TARGET_USER, TARGET_CURRENT} TARGET_TYPE;

#define CURRENT_CONFIG	0
#define ALL_CONFIGS		1

// symbols to make New() more readable.

#define CUR_DIR			NULL		// don't change directory when creating project.
#define NO_NEW_SUB_DIR	""			// don't create new subdirectory for project.

// used by SetCustomBuildOptions()
#define EXCLUDE_CONFIG_LEVEL 0
#define INCLUDE_CONFIG_LEVEL 1

// File adding options for New(), correspond to UIWBFrame::CreateNewProject() options.

#define ADD_ALL_SOURCE		0x00000001
#define ADD_ALL_HEADERS		0x00000002
#define ADD_ALL_RES_SCRIPTS	0x00000004
#define ADD_ALL_DEF_FILES	0x00000008
#define ADD_ALL_ODL_FILES	0x00000010
#define ADD_ALL_LIBS		0x00000020
#define ADD_ALL_OBJ_FILES	0x00000040
#define ADD_ALL_FILES		0x00000080
#define ADD_FILE			0x00000100
#define ADD_FILES_MYSELF    0x00000200

// SetOptions constants. //these work for all controls.
#define OPTION_ON			1
#define OPTION_OFF			2

// Project properties categories
// MOVED TO UPRJTDLG.H.

// Project properties
typedef enum {PR_TARGET, PR_BUILD_CMD} PROJ_PROPERTIES;

// AppWizard app properties.

// BEGIN_CLASS_HELP
// ClassName: APPWIZ_OPTIONS
// BaseClass: none
// Category: Project
// END_CLASS_HELP
struct PRJ_CLASS APPWIZ_OPTIONS
{
		APPWIZ_OPTIONS();	 
	 	BOOL m_bUseMFCDLL;

		enum OLESupport { AW_OLE_NONE, AW_OLE_CONTAINER, AW_OLE_MINISERVER, AW_OLE_FULLSERVER, AW_OLE_CONTAINERSERVER };
		OLESupport m_OLECompound;
		
		// Review: These are not yet used.
		int m_Type ;
	 	int m_DBase ;
	 	int m_OLEAuto ;
	 	int m_ToolBar ;
	 	int m_StatusBar ;
	 	int m_Printing ;
	 	int m_Help ;
	 	int m_Language ;
	 	int m_Comments ;
	 	int m_VCMakefile ;
		int m_AboutBox ;
};

						
// New Project properties.

// BEGIN_CLASS_HELP
// ClassName: PROJOPTIONS
// BaseClass: none
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS PROJOPTIONS
{	public:
		LPCSTR szName ;
		LPCSTR szDir; 		
		PROJTYPE iType ;
		LPCSTR szNewSubDir;
		// For VCE
		int ProjFileOpt ;
		LPCSTR szProjFilesPath ;
		LPCSTR szRemotePath ;
		LPCSTR szRemoteFile ;
	
		PROJOPTIONS(LPCSTR Name, PROJTYPE Type)
		{	szName = Name;
			iType = Type;
			szNewSubDir = NULL ;
			szDir = NULL ;
			ProjFileOpt = 0 ;
			szProjFilesPath = NULL;
			szRemotePath = NULL;
		 	szRemoteFile = NULL ;
		}

	PROJOPTIONS(LPCSTR Name)
		{	ASSERT(0) ; // We should always have a project name and type.
			UNREFERENCED_PARAMETER(Name);
		}

		PROJOPTIONS()
		{   szName = "" ;
			iType = UIAW_PT_APP ;
			szDir = "" ;
			szNewSubDir = "";
			ProjFileOpt = CNP_ADD_FILES_MYSELF ;
			szProjFilesPath = "";
			szRemotePath = "" ;
		 	szRemoteFile = "" ;
		}
} ;


// BEGIN_CLASS_HELP
// ClassName: CProjWizOptions
// BaseClass: none
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS CProjWizOptions

{
public:
	
	// sets defaults for options all projects share.
	CProjWizOptions(void);
	
	// options that all projects share.
	PROJTYPE m_ptType;
	CString	m_strName;
	CString m_strLocation;
	PROJ_WORKSPACE m_pwWorkspace;
	PROJ_HIERARCHY m_phHierarchy;
	CString m_strParent; 
	int m_iPlatforms;

	// handles the project-specific wizard.
	virtual BOOL WizardFunc(void) = 0;
};


// BEGIN_CLASS_HELP
// ClassName: CControlWizOptions
// BaseClass: CProjWizOptions
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS CControlWizOptions : public CProjWizOptions

{
public:
	
	// sets defaults for control wizard options.
	CControlWizOptions(void);

	// step 1 options.
	int m_iNumControls;
	BOOL m_bRuntimeLicense;
	BOOL m_bGenerateComments;
	BOOL m_bGenerateHelpFiles;

	// step 2 options.
	// TODO(michma): support editing of class and file names.
	BOOL m_bActivatesWhenVisible;
	BOOL m_bInvisibleAtRuntime;
	BOOL m_bAvailableInInsertObjectDlg;
	BOOL m_bAboutBox;
	BOOL m_bSimpleFrameControl;
	// TODO (michma): support subclass option.
	// TODO(michma): support advanced options.

	// handles the project-specific wizard.
	virtual BOOL WizardFunc(void);
};


// BEGIN_CLASS_HELP
// ClassName: CATLCOMWizOptions
// BaseClass: CProjWizOptions
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS CATLCOMWizOptions : public CProjWizOptions

{
public:
	
	// sets defaults for atl com wizard options.
	CATLCOMWizOptions(void);
	
	// for specifying the atl com project's server type.
	typedef enum {ATL_COM_SERVER_DLL = 1, ATL_COM_SERVER_EXE, ATL_COM_SERVER_SERVICE} ATL_COM_SERVER_TYPE;

	// step 1 options.
	ATL_COM_SERVER_TYPE m_acstServerType;
	BOOL m_bAllowMergingOfProxyStubCode;
	BOOL m_bSupportMFC;

	// handles the project-specific wizard.
	virtual BOOL WizardFunc(void);
};


// BEGIN_CLASS_HELP
// ClassName: CWin32AppWizOptions
// BaseClass: CProjWizOptions
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS CWin32AppWizOptions : public CProjWizOptions
{
public:
	// sets defaults for win32 app wizard options.
	CWin32AppWizOptions(void);
	// for specifying the win32 app type.
	typedef enum {EMPTY_PROJECT = 1, SIMPLE_APP, HELLO_WORLD_APP} APP_TYPE;
	// step 1 options.
	APP_TYPE m_AppType;
	// handles the project-specific wizard.
	virtual BOOL WizardFunc(void);
};


// BEGIN_CLASS_HELP
// ClassName: CISAPIExtensionWizOptions
// BaseClass: CProjWizOptions
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS CISAPIExtensionWizOptions : public CProjWizOptions
{
public:
	// sets defaults for isapi extension wizard options.
	CISAPIExtensionWizOptions(void);
	// for specifying the way to link to mfc.
	typedef enum {LINK_AS_SHARED_DLL = 1, LINK_AS_STATIC_LIB} MFC_LINKAGE;
	// step 1 options.
	MFC_LINKAGE m_MFCLinkage;
	BOOL m_bGenerateFilter;
	CString m_strFilterClassName;
	CString m_strFilterDescription;
	BOOL m_bGenerateExtension;
	CString m_strExtensionClassName;
	CString m_strExtensionDescription;
	// handles the project-specific wizard.
	virtual BOOL WizardFunc(void);
};


// BEGIN_CLASS_HELP
// ClassName: CWin32DllWizOptions
// BaseClass: CProjWizOptions
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS CWin32DllWizOptions : public CProjWizOptions
{
public:
	// sets defaults for win32 dll wizard options.
	CWin32DllWizOptions(void);
	// for specifying the win32 dll type.
	typedef enum {EMPTY_PROJECT = 1, SIMPLE_DLL, DLL_EXPORTS_SYMBOLS} DLL_TYPE;
	// step 1 options.
	DLL_TYPE m_DllType;
	// handles the project-specific wizard.
	virtual BOOL WizardFunc(void);
};


// BEGIN_CLASS_HELP
// ClassName: CXboxGameOptions
// BaseClass: CProjWizOptions
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS CXboxGameOptions : public CProjWizOptions
{
public:
	// sets defaults for xbox game options.
	CXboxGameOptions(void);
	// add add'l fields here
	virtual BOOL WizardFunc(void);
};


// BEGIN_CLASS_HELP
// ClassName: CXboxStaticLibOptions
// BaseClass: CProjWizOptions
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS CXboxStaticLibOptions : public CProjWizOptions
{
public:
	// sets defaults for xbox game options.
	CXboxStaticLibOptions(void);
	// add add'l fields here
	virtual BOOL WizardFunc(void);
};


// builds configuration strings (i.e. "test - Win32 Debug")

// BEGIN_CLASS_HELP
// ClassName: ConfigStr
// BaseClass: none
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS ConfigStr
	
	{
	private:
	
		CString m_cstrProj;
		PLATFORM_TYPE m_ptPlatform;
		BUILD_TYPE m_btBuild;
		CString m_cstrConfig;

		CString BuildString(void);
	
	public:

		ConfigStr(void){}
		ConfigStr(LPCSTR szProj, PLATFORM_TYPE ptPlatform, BUILD_TYPE btBuild);

		CString SetProject(LPCSTR szProj);
		CString SetPlatform(PLATFORM_TYPE ptPlatform);
		CString SetBuild(BUILD_TYPE btBuild);
		CString SetString(LPCSTR szProj, PLATFORM_TYPE ptPlatform, BUILD_TYPE btBuild);

		CString GetProject(void){return m_cstrProj;}
		PLATFORM_TYPE GetPlatform(void){return m_ptPlatform;}
		BUILD_TYPE GetBuild(void){return m_btBuild;}
		CString GetString(void){return m_cstrConfig;}
	};


// see ConfigStr.

// BEGIN_CLASS_HELP
// ClassName: ConfigStrArray
// BaseClass: none
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS ConfigStrArray

	{
	private:
		CPtrArray m_configs;

	public:

		CString Add(LPCSTR szProj, PLATFORM_TYPE ptPlatform, BUILD_TYPE btBuild);
		CString Add(ConfigStr &config_str);
		CString InsertAt(int intIndex, LPCSTR szProj, PLATFORM_TYPE ptPlatform, BUILD_TYPE btBuild);
		CString InsertAt(int intIndex, ConfigStr &config_str);

		int GetSize(void){return m_configs.GetSize();}
		ConfigStr operator[](int intIndex);

		void RemoveAt(int intIndex, int intCount = 1){m_configs.RemoveAt(intIndex, intCount);}
		void RemoveAll(void){m_configs.RemoveAll();}
 	};


// Stuff needed for Class View verification.

// BEGIN_CLASS_HELP
// ClassName: CMemberInfo
// BaseClass: none
// Category: Project
// END_CLASS_HELP
struct CMemberInfo
{
	enum TYPE { FUNCTION, DATA };
	enum ACCESS { PUBLIC, PRIVATE, PROTECTED, GLOBAL };

	CString		m_strName;					// Name of member.
	CString		m_strDataType;				// Return type for functions, data type for data.
	TYPE		m_Type; 					// Function or data?
	ACCESS		m_Access;					// Public, private, protected, or global?

	~CMemberInfo();

    void ClearAll();

    LPCSTR GetName() const { return (LPCSTR)m_strName; }
	LPCSTR GetDataType() const { return (LPCSTR)m_strDataType; }
	TYPE GetType() const { return m_Type; }
	ACCESS GetAccess() const { return m_Access; }

};

// BEGIN_CLASS_HELP
// ClassName: CGlobalInfo
// BaseClass: none
// Category: Project
// END_CLASS_HELP
typedef CMemberInfo CGlobalInfo;			// They're treated identically.

// BEGIN_CLASS_HELP
// ClassName: CClassInfo
// BaseClass: none
// Category: Project
// END_CLASS_HELP
struct CClassInfo 
{
    CString m_strName;									// Name of class.
    CString m_strBase;									// Name of base class.
	CTypedPtrList<CPtrList, CMemberInfo*> m_listMembers;

	~CClassInfo();

    void ClearAll();
    LPCSTR GetName() const { return (LPCSTR)m_strName; }
};

// BEGIN_CLASS_HELP
// ClassName: COProject
// BaseClass: none
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS COProject
{
// ctor/dtor
public:
	COProject(void);
	~COProject();

public:
// components
	BOOL AddComponent(COComponent *pComponent, LPCSTR szLocation = NULL);
	BOOL EnableComponents(LPCSTR szLocation = NULL);
	BOOL DisableComponents(void);
public:
	int InsertNewATLObject(LPCSTR szObjectName);

private:
	// used to track whether components are being added in batches or not
	// (i.e. if the dlg is already open when AddComponent is called, we are in batch mode).
	UIOGalleryDlg m_uigal;

public:

// new/open/attach
	int New(LPCSTR szProjName, PROJTYPE ProjType , LPCSTR szDir = NULL,
			 LPCSTR szNewSubDir = NULL, int ProjFileOpt = CNP_ADD_FILES_MYSELF,
			 LPCSTR szProjFilesPath = NULL,
			 LPCSTR szRemotePath = NULL,
			 LPCSTR szRemoteFile = NULL);
	
	int BuildNew(LPCSTR szProjName, PROJTYPE ProjType, LPCSTR szDir = NULL,
			 	  LPCSTR szNewSubDir = NULL, int ProjFileOpt = 0,
			 	  LPCSTR szProjFilesPath = NULL,
			 	  LPCSTR szRemotePath = NULL,
				  LPCSTR szRemoteFile = NULL);
	
	int New(PROJOPTIONS &stOptions );
	
	int New(CProjWizOptions *pProjWizOpt);
	
	int NewProject(PROJTYPE ptProjType, LPCSTR szProjName, LPCSTR projdir, 
				  int intPlatforms, BOOL AddToWorkspace=FALSE);

	int InsertProject(PROJTYPE ptProjType, LPCSTR szProjName, int intPlatforms, 
					  PROJ_HIERARCHY phProjHier = TOP_LEVEL_PROJ, 
                                          LPCSTR szTopLevelProj = NULL);

	int NewAppWiz(LPCSTR projname, LPCSTR projdir, int platforms, const APPWIZ_OPTIONS* = NULL, LPCSTR apptype = NULL);

private:
	// shared by NewProject, InsertProject, and NewAppWiz.
	void SetNewProjectPlatforms(int intPlatforms);
	void ReplaceExistingProjectIfNecessary(void);
	int WaitForProjectNameToBeIncludedInIDETitle(LPCSTR szProjName);

public:

	int Open(LPCSTR szProjName = NULL, int iMethod = 1, BOOL LogWarning = TRUE) ;
    HWND AppWizard(int iClose = FALSE);

	int Attach(void);

// save
	int Save(int wait = FALSE, LPCSTR file = NULL);
	int SaveAs(LPCSTR szFileName) {return FALSE ; UNREFERENCED_PARAMETER(szFileName); } ;

// close
	int Close(int iSave = 0) ;

// delete
	int DeleteMakeFile(); 		
	int DeleteFromProjectDir(LPCSTR strDelTarget = NULL);
	int RemoveIntermediateDir();
	int RemoveTargetDir();		

// build
	int Build(int iWait = 3, DWORD interval=1000) ;
	int RebuildAll(int iWait = 3, DWORD interval=1000) ; 
	int StopBuild();
	int VerifyBuild(BOOL LogErrors = TRUE,int * iErr= NULL, int * iWarn = NULL, BOOL WrnsAsErrs = FALSE) ;
   	int GetErrorCount() ;
	int GetWarningCount() ;
	int UpdateRemoteFile(LPCSTR local_file = NULL,
						 TARGET_TYPE target = TARGET_CURRENT,
						 PLATFORM_TYPE platform = PLATFORM_USER);	

	int WaitUntilBuildDone(int Min = 3, DWORD dwSleep=1000) ;
    int ExportMakefile();

// ClassView orientation
	void VerifyClasses(LPCSTR szBaseLineFilename);
	void VerifySingleClass(const CClassInfo&);
	void VerifySingleGlobal(const CGlobalInfo&);
	void NavigateToDeclaration(const CClassInfo&, LPCSTR);
	void NavigateToDeclaration(const CGlobalInfo&);
	void NavigateToDefinition(const CClassInfo&, LPCSTR);

private:
	void GetClassInfo(CStdioFile&, CClassInfo *);
	void GetGlobalInfo(CStdioFile&, CGlobalInfo *);

// execute
public:
	int Execute(int iRebuild = 0) ;

// project attributes
	LPCSTR GetFullPath() 		{return (const char *) m_FullPath ; };
	LPCSTR GetName() 			{return (const char *) m_ProjName ;} ;
	LPCSTR GetDir() 			{return (const char *) m_ProjDir ;} ;
	LPCSTR GetIntermediateDir(); // This is in the General section and is a relative path
	LPCSTR GetOutputFile();		 // This is in the Linker section and contructs the full path
	LPCSTR GetOutputXbeFile();   // This is in the Xbox Image (ImageBld) section and contructs the full path

	BOOL IsOpen(void);

// manipulate files
	int AddFiles		(LPCSTR szFileNames, LPCSTR szGroup ="") ;
	int RemoveFiles	(LPCSTR szFileNames, LPCSTR szGroup= "" ) ;
	int RemoveAll		(LPCSTR	szGrpName = NULL) ;
	int SelectFile		(LPCSTR szFileName,LPCSTR szGrpName = "&*%#~**********") ;
	int SelectDependentFile(CString File,CString Group = "") ;

	int GetFileProperty(PROJ_PROP_CATEGORIES iCategory, LPCSTR szGrpName , LPCSTR szFileName,UINT iCtrlId) ;
      CString GetFileProperty(PROJ_PROP_CATEGORIES iCategory,LPCSTR szGrpName ,LPCSTR szFileName,UINT iCtrlId,CString szValue = "") ;

	int SetFileProperty(PROJ_PROP_CATEGORIES iCategory,LPCSTR szGrpName, LPCSTR szFileName ,UINT iCtrlId, UINT iNewValue ) ;
	int SetFileProperty(PROJ_PROP_CATEGORIES iCategory,LPCSTR szGrpName, LPCSTR szFileName ,UINT iCtrlId, LPCSTR szNewValue ) ;

// manipulate groups
	int NewGroup(CString Name) ;
	int RemoveGroup(){ return FALSE ; } ; // REVIEW(Ivan) Implement these.
	int RenameGroup(){ return FALSE ; } ;
	int SelectGroup	(LPCSTR szGrpName) ;
	int SelectDependenciesGroup(CString Group = "") ;

	int GetGroupProperty(PROJ_PROP_CATEGORIES iCategory, LPCSTR szGrpName ,UINT iCtrlId ) ;
      CString GetGroupProperty(PROJ_PROP_CATEGORIES iCategory,LPCSTR szGrpName ,UINT iCtrlId,CString szValue = "") ;

	int SetGroupProperty(PROJ_PROP_CATEGORIES iCategory,LPCSTR szGrpName ,UINT iCtrlId, UINT iNewValue ) ;
	int SetGroupProperty(PROJ_PROP_CATEGORIES iCategory,LPCSTR szGrpName ,UINT iCtrlId, LPCSTR szNewValue ) ;

// manipulate targets
	int AddTarget(LPCSTR Name, int Type , BOOL Debug =FALSE) ;
	int AddTarget(LPCSTR Name, LPCSTR CopyFrom) ;
	int SetTarget(LPCSTR Target);
	int SetTarget(TARGET_TYPE target);
	int DeleteTarget(LPCSTR Target) ;
	int RenameTarget(LPCSTR OldName, LPCSTR NewName) ;

	CString GetRemoteTarget(void);
	LPCSTR GetTarget(int Target = 0) ;
	TARGET_TYPE GetCurrentTarget(void);
	int SetLocalTarget(LPCSTR localfile, LPCSTR config = NULL, DEFAULT_DBG_EXE_TYPE ddetDefaultDbgExe = NO_DEFAULT_DBG_EXE);
	int SetExeForDebugSession(LPCSTR path, LPCSTR config = NULL, DEFAULT_DBG_EXE_TYPE ddetDefaultDbgExe = NO_DEFAULT_DBG_EXE){return SetLocalTarget(path, config, ddetDefaultDbgExe);}
	int SetOutputTarget(LPCSTR localfile);
	int SetOutputFile(LPCSTR localfile);
	int SetProgramArguments(LPCSTR progargs, LPCSTR config = NULL);
	int SetDebugInfo(DEBUG_INFO_TYPE DebugInfo);

// manipulate project
	int MakeProjectExternal(LPCSTR sName = NULL) ;

	int AddSQLDataSource(CString &DSN,CString &User,CString &Psw,LPCSTR DataBase=NULL);
	int ValidatePassword(CString &User,CString &Psw,LPCSTR DataBase=NULL);

public:
	int SetRemotePath(LPCSTR remote_file,	
					  TARGET_TYPE target = TARGET_CURRENT,
					  SRT_OPT srt_opt = PREPEND_REMOTE_PATH,
					  PLATFORM_TYPE platform = PLATFORM_USER);
	
	int SetAdditionalDLLs(LPCSTR szDLLs);
	int RemoveAdditionalDLLs(int iDll);
	int SetLocateOtherDLLs(TOGGLE_TYPE t);
	int SetPlatform(int platform);
	int ToggleBSCGeneration(TOGGLE_TYPE t);
	
	int SetCustomBuildOptions(LPCSTR szDescription, 
							  CStringArray &cstrArrayBuildCmds,
							  CStringArray &cstrArrayOutputFiles,
							  ConfigStrArray &csArrayConfigs);
	
	int SetCustomBuildOptions(LPCSTR szDescription, 
							  CStringArray &cstrArrayBuildCmds,
							  CStringArray &cstrArrayOutputFiles,
							  ConfigStrArray &csArrayConfigs, 
							  CStringArray &cstrArrayFiles,
							  int intConfigInclusion = INCLUDE_CONFIG_LEVEL);

private:
	
	// used by SetCustomBuildOptions().
	int SetCustomBuildOptionsCore(LPCSTR szDescription, 
								  CStringArray &cstrArrayBuildCmds,
								  CStringArray &cstrArrayOutputFiles);

	// used by SetCustomBuildOptionsCore().
	void SetCustomBuildLists(LPCSTR szListAccel, CStringArray &cstrArrayList);
	
public:						  

    int GetProjProperty(PROJ_PROP_CATEGORIES iCategory,UINT iCtrlId, CString szValue) ;
	CString GetProjProperty(PROJ_PROP_CATEGORIES iCategory,UINT iCtrlId) ;
	int SetProjProperty(PROJ_PROP_CATEGORIES iCategory,UINT iCtrlId, UINT iNewValue ) ;
	int SetProjProperty(PROJ_PROP_CATEGORIES iCategory,UINT iCtrlId, LPCSTR szNewValue ) ;

	CString GetProjectItemProp(int P_PropID)  ;
	int SetBuildCommand(LPCSTR command, int index = 0);

// misc
	BOOL ActivateProjWnd();
	void SetPathMembers() ;

// helper functions
protected:

	// this function is taken directly from uwbframe.h
	HWND CreateNewProject(LPCSTR szProjName, PROJTYPE ProjType, LPCSTR szDir = NULL,
						  LPCSTR szNewSubDir = NULL, int ProjFileOpt = 0,
						  LPCSTR szProjFilesPath = NULL,
						  LPCSTR szRemotePath = NULL,
						  LPCSTR szRemoteFile = NULL);


	UIWorkspaceWindow* NewProjectWindow(void);
	BOOL DeleteProjectWindow(void);

	UIWorkspaceWindow* GetProjectWindow(void);

private:
	HWND hActive ;
   	INT SetOption(INT iCategory,UINT iCtrlId, LPCSTR szNewValue) ;
	INT SetOption(INT iCategory,UINT iCtrlId, UINT szNewValue) ;

// data
protected:
	CString m_FullPath, m_ProjName, m_ProjDir, m_OutputFile, m_InterDir ;
	HWND m_hWnd ;
	UIWorkspaceWindow* m_pProjWnd;
 	UIProjOptionsTabDlg m_uPrjOptDlg;
} ;
#endif //__COPROJECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\prjxprt.h ===
///////////////////////////////////////////////////////////////////////////////
//	prjxprt.h (project export)
//
//	Created by :			Date :
//		BrianCr				01/03/95
//
//	Description :
//		Project DLL defines
//

#ifndef __PRJXPRT_H__
#define __PRJXPRT_H__

#ifdef EXPORT_PROJECT
	#define PRJ_CLASS AFX_EXT_CLASS
	#define PRJ_API   AFX_EXT_API
	#define PRJ_DATA  AFX_EXT_DATA
#else
	#define PRJ_CLASS __declspec(dllimport)
	#define PRJ_API   __declspec(dllimport)
	#define PRJ_DATA  __declspec(dllimport)

	#ifdef _DEBUG 
		#pragma comment(lib, "prjd.lib")
	#else
		#pragma comment(lib, "prj.lib")
	#endif
#endif

#endif // __PRJXPRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\odbcdlgs.h ===
///////////////////////////////////////////////////////////////////////////////
//  ODBCDLGS.H
//
//  Created by :            Date :
//      IvanL              6/17/94
//
//  Description :
//      Declaration of the UISqldialogs class
//

#ifndef __ODBCDLGS_H__
#define __ODBCDLGS_H__

#include "..\..\udialog.h"
#include "..\sym\clswiz.h"
#include "prjxprt.h"

#ifndef __UIDIALOG_H__
	#error include 'udialog.h' before including this file
#endif

#define ERROR_ERROR -1

///////////////////////////////////////////////////////////////////////////////
//  UISqldialogs class 

 
typedef enum {DAO_SOURCE =CLSWIZ_IDC_DAO , ODBC_SOURCE= CLSWIZ_IDC_ODBC} DBSOURCES ;
typedef enum {SNAPSHOT_TYPE = CLSWIZ_IDC_SNAPSHOT, DYNASET_TYPE =CLSWIZ_IDC_DYNASET , TABLES_TYPE = CLSWIZ_IDC_TABLE} REC_SET_TYPE ;

// BEGIN_CLASS_HELP
// ClassName: UISqlDataSources
// BaseClass: UIDialog
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS UISqlDataSources : public UIDialog 
	{
    UIWND_COPY_CTOR (UISqlDataSources, UIDialog) ; 

// Private data
    private:
			int m_ActiveSource ;
// General Utilities
	public:
			inline CString ExpectedTitle(void) const
			{ return ("Data Options"); }// REVIEW : LOCALIZATION 
			
			HWND Display(void) ;
			int DataSource(DBSOURCES source);
			int RecordSetType(REC_SET_TYPE Type);
			int DetectDirtyCol(int Yes = 1) ;
			int BindAllCol(int Yes = 1) ;
			int  SetODBCName(CString ds) ;
			int  SetODBCName(int ds) ;
			int  SetDAOName(CString ds) ;
			int Close(int OK = 1) ;
   } ;

// BEGIN_CLASS_HELP
// ClassName: UISqlServerLogIn
// BaseClass: UIDialog
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS UISqlServerLogIn : public UIDialog 
	{
    UIWND_COPY_CTOR (UISqlServerLogIn, UIDialog) ; 

// General Utilities
	public:
			inline CString ExpectedTitle(void) const
			{ return ("SQL Server Login"); }		// Options

			int ID(CString ID) ;
			int Pw(CString pw) ;        
			int Close(int OK = 1) ;             
 } ; 

 // BEGIN_CLASS_HELP
// ClassName: UISelectTables
// BaseClass: UIDialog
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS UISelectTables : public UIDialog 
	{
    UIWND_COPY_CTOR (UISelectTables, UIDialog) ; 

// General Utilities
	public:
			inline CString ExpectedTitle(void) const
			{ return ("Select Database Tables"); }		// Options

			int Name(CString tbName) ;
			int Name(int index = 1) ;
			int Close(int OK = 1) ;             
 } ; 

// BEGIN_CLASS_HELP
// ClassName: UIDataBaseDlgs
// BaseClass: None
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS UIDataBaseDlgs
{
	CString m_DBasePath ;

	public:
	 UISqlDataSources Sources ;
	 UISqlServerLogIn login ;
	 UISelectTables	  tables ;
	int WaitForSources() ;
	 
	int WaitForLogin();
	int WaitForTables() ;
	void SetDataBasePath(CString Path)
	{
		m_DBasePath = Path ;
	}
	CString GetDataBasePath()
	{
		return m_DBasePath ;
	}


	 
} ;

// BEGIN_CLASS_HELP
// ClassName: UISelectRecordSet
// BaseClass: UIDialog
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS UISelectRecordSet : public UIDialog 
	{
    UIWND_COPY_CTOR (UISelectRecordSet, UIDialog) ; 

// General Utilities
	public:
			inline CString ExpectedTitle(void) const
			{ return ("Select a Record Set"); }		// Options

			int Class(CString Name) ;
			UIDataBaseDlgs *New() ;
			int Close(int OK = 1) ;
			             
 } ; 



#endif //__ODBCDLGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\coprject.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  COPRJECT.CPP
//
//  Created by :            Date :
//      IvanL               1/17/94
//
//  Description :
//      Implementation of the COProject class
//

#include "stdafx.h"
#include <process.h>
#include <stdlib.h>
#include <stdarg.h>
#include <errno.h>
#include "coprject.h"
#include "testxcpt.h"
#include "mstwrap.h"
#include "..\sym\cmdids.h"
#include "..\sym\vproj.h"
#include "..\sym\props.h"
#include "..\sym\projprop.h"
#include "..\sym\vproj.h"
#include "..\sym\vres.h"
#include "..\sym\optnlink.h"
#include "..\sym\xboxsyms.h"
#include "guiv1.h"
#include "..\..\umsgbox.h"
#include "..\shl\ucommdlg.h"
#include "..\shl\uioutput.h"
#include "..\shl\coconnec.h"
#include "..\shl\uwbframe.h"
#include "..\shl\wbutil.h"
#include "..\wrk\uiwrkspc.h"
#include "uappwiz.h"
#include "uitarget.h"
#include "uprjfile.h"
#include "uidepdlg.h"
#include "..\shl\uiwbmsg.h"
#include "..\shl\uopenwrk.h"
#include "..\..\testutil.h"
#include "..\shl\newfldlg.h"

#include "guitarg.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// macro that determines whether the COProject object is valid
#define VERIFY_VALID_PROJECT(message)			\
	ASSERT(IsOpen());							\
	if (!IsOpen()) {							\
		LOG->RecordInfo("%s: the project is not opened. %s", THIS_FUNCTION, (LPCSTR)(message));  \
		return ERROR_ERROR;						\
	}

#define MAXFILEPATH _MAX_DRIVE+_MAX_DIR+_MAX_FNAME+_MAX_EXT
CString MyGetLabel(UINT id) ;

CString GROUP_WAS_OMITTED ="&*%#~**********@+==" ;

// The following defines are here temporarily until PROJPROP.H is updated. REVIEW(IVANL) remove ASAP.
#define P_QA_ProjItemType                       PROJ_FAKE + 95
#define QA_TypeIs_Target                        0
#define QA_TypeIs_Group                         1
#define QA_TypeIs_File                          2
#define QA_TypeIs_DepGroup                      3
#define QA_TypeIs_DepFile                       4

APPWIZ_OPTIONS::APPWIZ_OPTIONS()
{
	 m_bUseMFCDLL = TRUE;
		m_OLECompound = AW_OLE_NONE;

		// Initialize all currently unused members to known value.
		m_Type = m_DBase = m_OLEAuto = m_ToolBar = m_StatusBar = m_Printing 
		= m_Help = m_Language = m_Comments = m_VCMakefile = m_AboutBox = 0;
}

CMemberInfo::~CMemberInfo()
{
	ClearAll();
}

CClassInfo::~CClassInfo()
{
	ClearAll();
}

void CClassInfo::ClearAll()
{ 
    m_strName.Empty(); 
    m_strBase.Empty(); 

	POSITION pos = m_listMembers.GetHeadPosition();
	while(pos != NULL)
	{
		delete m_listMembers.GetAt(pos);
		m_listMembers.GetNext(pos);
	}

	m_listMembers.RemoveAll();
}

void CMemberInfo::ClearAll()
{ 
    m_strName.Empty(); 
	m_strDataType.Empty();
}

 
COProject::COProject(void)
: m_pProjWnd(NULL)
{
}

COProject::~COProject()
{
	// delete the project window
	DeleteProjectWindow();
}


// BEGIN_HELP_COMMENT
// Function: int COProject::SelectDependenciesGroup(CString Group /* = ""*/)
// Description: Select the dependencies folder for a particular group in the project window.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: Group A CString that contains the name of the group to select the dependencies folder for. An empty string means use the current group.
// END_HELP_COMMENT
int COProject::SelectDependenciesGroup(CString Group /* = ""*/)
{
	const char* const THIS_FUNCTION = "COProject::SelectDependeciesGroup";

	VERIFY_VALID_PROJECT("Unable to select dependencies group.")

	CString szCur = "", Prev = "" ;
	// make project window active.
	ActivateProjWnd();
	// if a dependencies group is currently selected.
	if (Group.IsEmpty())
		Group = UIWB.GetItemProperty(P_GroupName) ;       // Get active groupname
	if (ERROR_ERROR == SelectGroup((const char *) Group)) // If group couldn't be found
		return ERROR_ERROR ;
	MST.DoKeys("{ENTER}") ;
	for (int i = 1; i ;)
		{
			MST.DoKeys("{DOWN}") ;
			szCur = UIWB.GetItemProperty(P_QA_ProjItemType) ;
			if ((atoi(szCur)) == QA_TypeIs_DepGroup)
				return ERROR_SUCCESS ;
			szCur = UIWB.GetItemProperty(P_ProjItemName) ;
			if (Prev == szCur) // We are at the end
				return ERROR_ERROR ;
			Prev = szCur ;
		}
	return ERROR_ERROR ;
}

// BEGIN_HELP_COMMENT
// Function: int COProject::SelectDependentFile(CString File,CString Group /* = ""*/)
// Description: Select a file in the dependencies folder for a particular group in the project window.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: File A CString that contains the name of the file to select.
// Param: Group A CString that contains the name of the group that contains the dependencies folder. An empty string means use the current group.
// END_HELP_COMMENT
int COProject::SelectDependentFile(CString File,CString Group /* = ""*/)
{
	const char* const THIS_FUNCTION = "COProject::SelectDependentFile";

	VERIFY_VALID_PROJECT("Unable to select dependent file.")

	if (ERROR_ERROR == SelectDependenciesGroup(Group))
		return ERROR_ERROR ;
	CString Prev = "", szCur = "" ;
	MST.DoKeys("{ENTER}") ; //EXPAND DEP GROUP
	for (int i = 1; i ; )
		{
			CString Prev, szCur ;
			MST.DoKeys("{DOWN}") ;
			szCur = UIWB.GetItemProperty(P_ProjItemName) ;
			if (szCur == File)
				return ERROR_SUCCESS ;
			if (Prev == szCur) // We are at the end
				return ERROR_ERROR ;
			Prev = szCur ;
		}
	return ERROR_ERROR ;
}

// BEGIN_HELP_COMMENT
// Function: int COProject::NewGroup(CString Name)
// Description: Add a new group to the current project.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: Name A CString that contains the name of the new group.
// END_HELP_COMMENT
int COProject::NewGroup(CString Name)
{
	const char* const THIS_FUNCTION = "COProject::NewGroup";

	VERIFY_VALID_PROJECT("Unable to create a new group.")

	UIWB.DoCommand(IDM_PROJITEM_ADD_GROUP , DC_MNEMONIC);   // make project editor MDI active
	if (Name.IsEmpty())
	{
		MST.DoKeys("{ESC}") ;
		return ERROR_ERROR ;
	}
	if (!UIWB.WaitOnWndWithCtrl(VPROJ_IDC_GROUPNAME,3000)) // If the dialog didn't show up
		return ERROR_ERROR ;
	MST.WEditSetText(GetLabel(VPROJ_IDC_GROUPNAME),(const char *) Name);// uffer(Name.GetLength())) ;
	MST.WButtonClick(GetLabel(IDOK)) ;
	return ERROR_SUCCESS ;
}

// BEGIN_HELP_COMMENT
// Function: BOOL COProject::ActivateProjWnd()
// Description: Activate the project window.
// Return: UIMainFrame::DoCommand()
// END_HELP_COMMENT
BOOL COProject::ActivateProjWnd()
{
    return UIWB.DoCommand(IDM_VIEW_WORKSPACE, DC_MNEMONIC);
}

// BEGIN_HELP_COMMENT
// Function: int COProject::Close(int iSave)
// Description: Close the project and project window.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: iSave A Boolean value that indicates whether to save the project before closing (TRUE) or not.
// END_HELP_COMMENT
int COProject::Close(int iSave)
{
	const char* const THIS_FUNCTION = "COProject::Close";

	VERIFY_VALID_PROJECT("Unable to close the project.")

	// Make sure that the project window has focus.
	ActivateProjWnd();
	if(iSave==TRUE && Save()!=ERROR_SUCCESS)
		return ERROR_ERROR;
	return UIWB.CloseProject()? ERROR_SUCCESS: ERROR_ERROR;


/* 	
	//if (UIWB.GetItemProperty(P_ProjIsExternalMakeFile) == "1")
	//      return ERROR_SUCCESS ;
	if (iSave)
		Save() ;
	UIWB.DoCommand(ID_FILE_CLOSE, DC_MNEMONIC);

	UIWBMessageBox mb;
	while( mb.WaitAttachActive(3000) != NULL )
	{
		if( mb.ButtonExists(MSG_NO) )
			// this will handle "do you want to save" msg box
			mb.ButtonClick(MSG_NO);
		else
			// this will handle "access denied" msg box for read-only projects
			MST.DoKeys("~");
	}

	return ERROR_SUCCESS;
*/
}

int COProject::Attach(void)
{
	// bring up the project window
	NewProjectWindow();

	// determine if the window is valid
	return ERROR_SUCCESS;
}


// BEGIN_HELP_COMMENT
// Function: int COProject::GetErrorCount()
// Description: Get the number of errors reported by the last build of the project.
// Return: An integer containing the number of errors.
// END_HELP_COMMENT
int COProject::GetErrorCount()
{
	const char* const THIS_FUNCTION = "COProject::GetErrorCount";

	VERIFY_VALID_PROJECT("Unable to get the error count.")

	return UIWB.GetErrorCount() ;
}
// BEGIN_HELP_COMMENT
// Function: int COProject::GetWarningCount()
// Description: Get the number of warning reported by the last build of the project.
// Return: An integer containing the number of warnings.
// END_HELP_COMMENT
int COProject::GetWarningCount()
{
	const char* const THIS_FUNCTION = "COProject::GetWarningCount";

	VERIFY_VALID_PROJECT("Unable to get the warning count.")

	return UIWB.GetWarningCount() ;
}

// BEGIN_HELP_COMMENT
// Function: int COProject::VerifyBuild(BOOL LogErrors /* TRUE */, int * iErr /* NULL */, int * iWarn /* NULL */,  BOOL WrnsAsErrs /*= FALSE*/)
// Description: Determine whether the last build of the project was successful or not. An unsuccessful build contains errors (or warnings treated as errors).
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: LogErrors A Boolean value that indicates whether to record the results of the last build in the log (TRUE) or not.
// Param: iErr A pointer to an integer that will contain the number of errors reported by the last build.
// Param: iWarn A pointer to an integer that will contain the number of warnings reported by the last build.
// Param: WrnsAsErrs A Boolean value that indicates whether to treat warnings as errors (TRUE) or not. (Default value is FALSE.)
// END_HELP_COMMENT
int COProject::VerifyBuild(BOOL LogErrors /* TRUE */, int * iErr /* NULL */, int * iWarn /* NULL */,  BOOL WrnsAsErrs /*= FALSE*/)
{
	const char* const THIS_FUNCTION = "COProject::VerifyBuild";

	VERIFY_VALID_PROJECT("Unable to verify the build.")

    int Error = UIWB.GetErrorCount() ;
	int Warn  = UIWB.GetWarningCount() ;

	if (iErr)
		*iErr = Error ;
	if (iWarn)
	{       CString msg = " There were Warnings: " ;
		char szwn[] = "               " ;
		_itoa(*iWarn,szwn,10) ;
		msg + szwn ;
		LOG->RecordInfo((const char *) msg) ;
		*iWarn =Warn ;
	}
	if (Error || (Warn && WrnsAsErrs))
	{
		if (LogErrors)
		{
			char szTmpPath[MAX_PATH];
			if (GetTempPath(MAX_PATH, szTmpPath) == 0)
			{
				LOG->RecordInfo("COProject::VerifyBuild() - Couldn't get path to temp directory.  Build file not created");
				AfxThrowFileException(CFileException::generic);
				return ERROR_ERROR;
			}

			CString strBuildLog=CString(szTmpPath)+CTime::GetCurrentTime().Format("%y%H%M%S.%j");
			// CString strBuildLog;
			// GetTempFileName(szTmpPath, "prj", 0, strBuildLog.GetBuffer(MAX_PATH));
			// strBuildLog.ReleaseBuffer();
			// Save Output Window
			UIOutput OutWin;
			OutWin.Activate();
			UIFileSaveAsDlg SaveOutWin = UIWB.FileSaveAsDlg();
		    EXPECT( SaveOutWin.IsValid() );
			SaveOutWin.SetName(strBuildLog);
			SaveOutWin.OK(TRUE);
			LOG->RecordTextFile(strBuildLog, "Build log");
			ActivateProjWnd();
		}
		return ERROR_ERROR ;
	}
	else
		return ERROR_SUCCESS ;
}

// BEGIN_HELP_COMMENT
// Function: int COProject::WaitUntilBuildDone(int Min /* 3 */,DWORD dwSleep=1000)
// Description: Wait until the current build is finished or the amount of time specified has elasped. 
// Return: An integer that indicates success. ERROR_SUCCESS if the build completes within the time specified; ERROR_ERROR otherwise.
// Param: Min An integer that contains the number of minutes to wait for the build to complete.
// Param: dwSleep An DWORD that contains the number of milliseconds to wait between checks to see if build is done
// END_HELP_COMMENT
int COProject::WaitUntilBuildDone(int Min /* 3 */, DWORD dwSleep /* 1000 */)
{	DWORD dwMillSec = Min * 60000 ;   
	for ( DWORD dwDone = 0; dwDone <= dwMillSec; dwDone += dwSleep)
	{	
		Sleep(dwSleep);		// wait 
		if (UIWB.CanWeBuild())    // If the IDE is in a CanBuild state, we are done building
		{
		   		MST.DoKeys("{ESC}") ;
				Sleep(2000) ;
		   		return ERROR_SUCCESS ;
		}	
	}
	MST.DoKeys("{ESC}") ;
	return ERROR_ERROR;	

	// EventHandler
//	if(pEventHandler->WaitForBuildFinish(Min) == true)  
//		return ERROR_SUCCESS;
//	else
//		return ERROR_ERROR;
}


// BEGIN_HELP_COMMENT
// Function: int COProject::New(PROJOPTIONS &ProjOpts)
// Description: Create a new project and project window.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: ProjOpts A PROJOPTIONS structure that defines the project. szName is a pointer to a string that contains the name of the project. szDir is a pointer to a string that contains the directory for the project. iType is a value that indicates the type of project: UIAW_PT_APPWIZ, UIAW_PT_APPWIZ_DLL, UIAW_PT_APP, UIAW_PT_DLL, UIAW_PT_CONSOLE, UIAW_PT_STATIC_LIBRARY, UIAW_PT_DUMMY_EXEC, UIAW_PT_DUMMY_DLL. szNewSubDir is a pointer to a string that contains the new subdirectory for the project. ProjFileOpt is a value that indicates which files to add: ADD_ALL_SOURCE, ADD_ALL_HEADERS, ADD_ALL_RES_SCRIPTS, ADD_ALL_DEF_FILES, ADD_ALL_ODL_FILES, ADD_ALL_LIBS, ADD_ALL_OBJ_FILES, ADD_ALL_FILES, ADD_FILE, ADD_FILES_MYSELF. szProjFilesPath is a pointer to a string containing the path that contains the project files to be added. szRemotePath is a pointer to a string that contains the remote executable path for this project. szRemoteFile is a pointer to a string that contains the remote executable filename for this project.
// END_HELP_COMMENT
int COProject::New(PROJOPTIONS &ProjOpts)
{   
	const char* const THIS_FUNCTION = "COProject::New";

    HWND hWnd;

	if (!ProjOpts.szName)
	{
		LOG->RecordInfo("%s: no project name given. Unable to create a new project.", THIS_FUNCTION);
		MST.DoKeys("{ESC 2}") ; // Just close the dialog.
		return ERROR_ERROR ;
	}
	else
	{
		
		hWnd = CreateNewProject(ProjOpts.szName,
								ProjOpts.iType,
								ProjOpts.szDir,
								ProjOpts.szNewSubDir,
								ProjOpts.ProjFileOpt,
								ProjOpts.szProjFilesPath,
								ProjOpts.szRemotePath,
								ProjOpts.szRemoteFile ) ;
	}

	SetPathMembers() ;
	if(!(IsWindow(hWnd)))
		{return ERROR_ERROR ;}
	Sleep(3) ;
	MST.DoKeys("{ESC}") ;

	//if (MST.WFndWnd("Add to Source",FW_DEFAULT | FW_PART | FW_ACTIVE))
	Sleep(3);
	MST.DoKeys("{ESC}");
		
	SetPathMembers() ;
	// Add files if user asks for that.
/*
	if( ProjFileOpt & CNP_ADD_ALL_SOURCE )
		upf.AddAllFiles(UIPF_FOT_SOURCE, szProjFilesPath);

	if (ProjFileOpt & CNP_ADD_FILE)
		upf.AddFile(szProjFilesPath);
*/
	// the project should now be valid
	ASSERT(IsOpen());

	m_hWnd = hWnd ;

	return ERROR_SUCCESS ;
}

// BEGIN_HELP_COMMENT
// Function: int COProject::New(LPCSTR szProjName, int ProjType, LPCSTR szDir /* NULL */, LPCSTR szNewSubDir /* NULL */, int ProjFileOpt /* 0 */, LPCSTR szProjFilesPath /* NULL */, LPCSTR szRemotePath /* NULL */, LPCSTR szRemoteFile /* NULL */)
// Description: Create a new project and project window.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szProjName A pointer to a string that contains the name of the project.
// Param: ProjType is a value that indicates the type of project: UIAW_PT_APPWIZ, UIAW_PT_APPWIZ_DLL, UIAW_PT_APP, UIAW_PT_DLL, UIAW_PT_CONSOLE, UIAW_PT_STATIC_LIBRARY, UIAW_PT_DUMMY_EXEC, UIAW_PT_DUMMY_DLL.
// Param: szDir A pointer to a string that contains the directory for the project. (Default value is NULL.)
// Param: szNewSubDir A pointer to a string that contains the new subdirectory for the project.  This subdirectory will be based off szDir, so it cannot contain root, UNC, or drive specifiers. (Default value is NULL.)
// Param: ProjFileOpt A value that indicates which files to add: ADD_ALL_SOURCE, ADD_ALL_HEADERS, ADD_ALL_RES_SCRIPTS, ADD_ALL_DEF_FILES, ADD_ALL_ODL_FILES, ADD_ALL_LIBS, ADD_ALL_OBJ_FILES, ADD_ALL_FILES, ADD_FILE, ADD_FILES_MYSELF. (Default value is 0.)
// Param: szProjFilesPath A pointer to a string containing the path that contains the project files to be added. (Default value is NULL.)
// Param: szRemotePath A pointer to a string that contains the remote executable path for this project. (Default value is NULL.)
// Param: szRemoteFile A pointer to a string that contains the remote executable filename for this project. (Default value is NULL.)
// END_HELP_COMMENT
int COProject::New(LPCSTR szProjName, 
				   PROJTYPE ProjType,
				   	LPCSTR szDir /* NULL */,
					LPCSTR szNewSubDir /* NULL */,
					int ProjFileOpt /* 0 */,
					LPCSTR szProjFilesPath /* NULL */,
					LPCSTR szRemotePath /* NULL */,
					LPCSTR szRemoteFile /* NULL */)
{
	const char* const THIS_FUNCTION = "COProject::New";

	HWND hwnd = CreateNewProject(szProjName, ProjType, szDir, szNewSubDir,ProjFileOpt,
								szProjFilesPath, szRemotePath, szRemoteFile);


	// the project should be valid
	ASSERT(IsOpen());

	if((ProjType == UIAW_PT_APPWIZ_DLL )|| (ProjType ==UIAW_PT_APPWIZ))
	{
		if (hwnd)
		{
			m_hWnd = hwnd ;
			SetPathMembers() ;
			return ERROR_SUCCESS ;
		}
		else
			return ERROR_ERROR ;
	}
	
	Sleep(2000) ;
	SetPathMembers() ;
	CString strTitle;
	WGetText(WGetActWnd(0), strTitle.GetBuffer(MAX_PATH));
	strTitle.ReleaseBuffer();
	strTitle.MakeUpper();
	if (strTitle.Find(GetName()) == -1) {
		LOG->RecordInfo("%s: Verifying project was created. Expected project name '%s' in title bar '%s'.", THIS_FUNCTION, GetName(), strTitle);
		return ERROR_ERROR ;
	}
	else
	{
		m_hWnd = hwnd ;
		return ERROR_SUCCESS ;
	}
}


// BEGIN_HELP_COMMENT
// Function: int COProject::BuildNew(LPCSTR szProjName, PROJTYPE ProjType, LPCSTR szDir /* NULL */, LPCSTR szNewSubDir /* NULL */, int ProjFileOpt /* 0 */, LPCSTR szProjFilesPath /* NULL */, LPCSTR szRemotePath /* NULL */, LPCSTR szRemoteFile /* NULL */)
// Description: Create a new project and build it.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szProjName A pointer to a string that contains the name of the project.
// Param: ProjType is a value that indicates the type of project: UIAW_PT_APPWIZ, UIAW_PT_APPWIZ_DLL, UIAW_PT_APP, UIAW_PT_DLL, UIAW_PT_CONSOLE, UIAW_PT_STATIC_LIBRARY, UIAW_PT_DUMMY_EXEC, UIAW_PT_DUMMY_DLL.
// Param: szDir A pointer to a string that contains the directory for the project. (Default value is NULL.)
// Param: szNewSubDir A pointer to a string that contains the new subdirectory for the project. (Default value is NULL.)
// Param: ProjFileOpt A value that indicates which files to add: ADD_ALL_SOURCE, ADD_ALL_HEADERS, ADD_ALL_RES_SCRIPTS, ADD_ALL_DEF_FILES, ADD_ALL_ODL_FILES, ADD_ALL_LIBS, ADD_ALL_OBJ_FILES, ADD_ALL_FILES, ADD_FILE, ADD_FILES_MYSELF. (Default value is 0.)
// Param: szProjFilesPath A pointer to a string containing the path that contains the project files to be added. (Default value is NULL.)
// Param: szRemotePath A pointer to a string that contains the remote executable path for this project. (Default value is NULL.)
// Param: szRemoteFile A pointer to a string that contains the remote executable filename for this project. (Default value is NULL.)
// END_HELP_COMMENT
int COProject::BuildNew(LPCSTR szProjName, PROJTYPE ProjType,
						 LPCSTR szDir /* NULL */,
						 LPCSTR szNewSubDir /* NULL */,
						 int ProjFileOpt /* 0 */,
						 LPCSTR szProjFilesPath /* NULL */,
						 LPCSTR szRemotePath /* NULL */,
						 LPCSTR szRemoteFile /* NULL */)
{
/*      EXPECT(IsWindow(CreateNewProject(szProjName, ProjType, szDir, szNewSubDir,
										  ProjFileOpt, szProjFilesPath, szRemotePath,
	REVIEW: why does this fail?                       szRemoteFile)));*/

	New(szProjName, ProjType, szDir, szNewSubDir, ProjFileOpt, szProjFilesPath, szRemotePath, szRemoteFile);

	// the project should be valid
	ASSERT(IsOpen());

	if(GetUserTargetPlatforms() == PLATFORM_MAC_68K)
		{
		Build();
		return UpdateRemoteFile();
		}

	return Build();
}


// BEGIN_HELP_COMMENT
// Function: int COProject::NewProject(PROJTYPE ptProjType, LPCSTR szProjName, LPCSTR projdir,int intPlatforms, BOOL AddToWorkspace /*=FALSE*/)
// Description: Create a new project.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szProjType A PROJTYPE value that indicates the type of project to create.
// Param: szProjName A pointer to a string that contains the name of the project.
// Param: intPlatforms A combination of PLATFORM_TYPE values that indicates the platforms the project will target.
// Param: ProjDir A pointer to a string that contains the location for the project.
// Param: AddToWorkspace TRUE - if want to add it to the existing workspace, FALSE if create new workspace.
// END_HELP_COMMENT
int COProject::NewProject(PROJTYPE ptProjType, LPCSTR szProjName, LPCSTR projdir, 
						  int intPlatforms, BOOL AddToWorkspace /*=FALSE*/)
{
	const char* const THIS_FUNCTION = "COProject::NewProject";

	// bring up the "new project" dlg.
	UIProjectWizard uprjwiz = AppWizard();
 	
	// make sure the dlg came up.
	if(!uprjwiz.HWnd())
		{		
		LOG->RecordInfo("ERROR in %s: can't activate new project dlg", THIS_FUNCTION);
		return ERROR_ERROR;
		}

	// set the project info and complete creation.
	Sleep(1000);	// BJoyce: we are too fast
	uprjwiz.SetProjType(ptProjType);
	uprjwiz.SetName(szProjName);
	uprjwiz.SetAddToWorkspace(AddToWorkspace);

/*
	(Now, no projects need to update the platforms - BJoyce)
	if(ptProjType!=DATABASE_PROJECT)	//no platforms for Database project
		SetNewProjectPlatforms(intPlatforms);
*/

	uprjwiz.SetLocation(projdir);
	uprjwiz.Create();
	// dismiss connect to datasource dialog
	if(ptProjType==DATABASE_PROJECT)
	{	//get rid of the Data Source window
		HWND hwnd;
		if (hwnd = MST.WFndWndWait(GetLocString(IDS_SELECT_DSN), FW_PART, 1))
		{	// click the mouse to make this window active
			LOG->RecordInfo("Found Window: '%s'", GetLocString(IDS_SELECT_DSN));
			MST.WSetActWnd(hwnd) ;

			RECT rcPage;
			GetClientRect(hwnd, &rcPage);
			ClickMouse( VK_LBUTTON ,hwnd, rcPage.left+150, rcPage.top - 15 );	  // Click on first Tab	(left most)
		}
		if(MST.WButtonExists(GetLabel(IDCANCEL)))
		MST.WButtonClick(GetLabel(IDCANCEL)); //get rid of the window
	}

	// Quick Hack, just "Finish" and "OK", update this for better testing
	// of Custom AppWizards
	//ReplaceExistingProjectIfNecessary();
	uprjwiz.Finish();
	MST.WButtonClick(GetLabel(IDOK));

	if(!(ptProjType==DATABASE_PROJECT && AddToWorkspace!=FALSE))
	{ // this will never be included in ide title for data project added to the workspace
		if(WaitForProjectNameToBeIncludedInIDETitle(szProjName) != ERROR_SUCCESS)

		{		
		LOG->RecordInfo("ERROR in %s: ide title not updated with project name %s",
						THIS_FUNCTION, szProjName);

		return ERROR_ERROR;
		}

	}
	NewProjectWindow();
//	SetPathMembers();
	return ERROR_SUCCESS;
}


// BEGIN_HELP_COMMENT
// Function: int COProject::InsertProject(PROJTYPE ptProjType, LPCSTR szProjName, int intPlatforms, PROJ_HIERARCHY phProjHier = TOP_LEVEL_PROJ, LPCSTR szTopLevelProj = NULL)
// Description: Inserts a new project.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szProjType A PROJTYPE value that indicates the type of project to create.
// Param: szProjName A pointer to a string that contains the name of the project.
// Param: intPlatforms A combination of PLATFORM_TYPE values that indicates the platforms the project will target.
// Param: phProjHier A PROJECT_HIERARCHY value indicating a top-levl or subproject. The default is TOP_LEVEL_PROJ.
// Param: szTopLevelProj A pointer to a string that contains the name of the top-level project under which the new subproject is to be inserted.
// END_HELP_COMMENT
int COProject::InsertProject(PROJTYPE ptProjType, LPCSTR szProjName, int intPlatforms,
							 PROJ_HIERARCHY phProjHier /* TOP_LEVEL_PROJ */, 
							 LPCSTR szTopLevelProj /* NULL */)

	{
	const char* const THIS_FUNCTION = "COProject::InsertProject";

#ifdef OLD_INSERT_DIALOG
	// bring up the "insert project" dlg.
	UIProjectWizard uprjwiz;
	UINewFileDlg nwflDlg ;
	MST.DoKeys(GetLocString(IDSS_INSERT_PROJ_ACCEL));

	
	if(!uprjwiz.WaitAttachActive(3000))
		{		
		LOG->RecordInfo("ERROR in %s: can't activate insert project dlg", THIS_FUNCTION);
		return ERROR_ERROR;
		}
#endif	// OLD_INSERT_DIALOG
	UIProjectWizard uprjwiz = AppWizard(); 
	// set the project info and complete creation (can't set location when inserting proj).
	Sleep(1000);	// BJoyce: we are too fast
	uprjwiz.SetProjType(ptProjType);
	uprjwiz.SetName(szProjName);
	uprjwiz.SetHierarchy(phProjHier);	// top-level or subproject?

	if(phProjHier == SUB_PROJ)
		uprjwiz.SetTopLevelProj(szTopLevelProj);

	SetNewProjectPlatforms(intPlatforms);
	uprjwiz.Create();

	// Quick Hack, just "Finish" and "OK", update this for better testing
	// of Custom AppWizards
	// ReplaceExistingProjectIfNecessary();
	uprjwiz.Finish();
	MST.WButtonClick(GetLabel(IDOK));

	return ERROR_SUCCESS;

}


// shared by NewProject(), InsertProject(), and NewAppWiz().
void COProject::SetNewProjectPlatforms(int intPlatforms)
	
	{  

	UINewFileDlg nwflDlg ;
	// turn off any undesired platforms (all are on by default).
	if(!((intPlatforms & PLATFORM_WIN32_X86) || (intPlatforms & PLATFORM_WIN32S_X86) || (intPlatforms & PLATFORM_WIN32_MIPS) || (intPlatforms & PLATFORM_WIN32_ALPHA)))
		nwflDlg.SetProjPlatform(GetLocString(IDSS_PLATFORM_WIN32));

	if(!(intPlatforms & PLATFORM_MAC_68K))
		nwflDlg.SetProjPlatform(GetLocString(IDSS_PLATFORM_MAC68K));

	if(!(intPlatforms & PLATFORM_MAC_PPC))
		nwflDlg.SetProjPlatform(GetLocString(IDSS_PLATFORM_MACPPC));
	
	}


void COProject::ReplaceExistingProjectIfNecessary(void)
	{
	// wait up to 3 seconds for file replace msg box to come up.
	if(MST.WFndWndWaitC(GetLocString(IDSS_REPLACE_EXISTING_FILE), "Static", FW_PART, 3))
		MST.WButtonClick(GetLocString(IDSS_YES));
	if (MST.WFndWndWait(GetLocString(IDSS_WORKBENCH_TITLEBAR), FW_FULL|FW_ALL|FW_FOCUS, 2))
		MST.WButtonClick(GetLocString(IDSS_YES));
	}


// shared by NewProject() and InsertProject().
int COProject::WaitForProjectNameToBeIncludedInIDETitle(LPCSTR szProjName)
	
	{
	const char* const THIS_FUNCTION = "COProject::WaitForProjectNameToBeIncludedInIDETitle";

	// when project creation is finished and the ide is ready to continue,
	// the title will be appended with the project name.
	// this has changed - project name now comes first in title
	CString cstrExpectedTitle = (CString)szProjName + " - " + (GetLocString(IDSS_WORKBENCH_TITLEBAR));
	CString cstrActualTitle;
	
	// wait up to 10 seconds for the ide title to be updated.
	for(int i = 0; i < 10; i++)
		
		{
		Sleep(1000);
		// get the ide title.
		MST.WGetText(UIWB.HWnd(), cstrActualTitle);
		
		if(cstrActualTitle == cstrExpectedTitle)
			break;
		}

	// if title wasn't found in 10 seconds, log an error.
	if(i == 10)
		
		{		
		LOG->RecordInfo("ERROR in %s: ide title not updated with project name %s",
						THIS_FUNCTION, szProjName);

		return ERROR_ERROR;
		}
	
	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COProject::NewAppWiz(LPCSTR projname, LPCSTR projdir, int platform, const APPWIZ_OPTIONS* pOptions, LPCSTR apptype)
// Description: Create a new AppWizard project.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: projname A pointer to a string that contains the name of the AppWizard project.
// Param: projdir A pointer to a string that contains the path for the AppWizard project.
// Param: platform A value that indicates the platform to create the AppWizard project for: PLATFORM_WIN32_X86, PLATFORM_WIN32S_X86, PLATFORM_MAC_68K, PLATFORM_MAC_PPC, PLATFORM_WIN32_MIPS, PLATFORM_WIN32_ALPHA, PLATFORM_WIN32_PPC, PLATFORM_CURRENT, PLATFORM_USER, PLATFORM_NON_USER.
// Param: pOptions A structure containing appwizard options.
// Param: apptype A pointer to a string that contains application type.
// END_HELP_COMMENT
int COProject::NewAppWiz(LPCSTR projname, LPCSTR projdir, int platforms, const APPWIZ_OPTIONS *pOptions /*=NULL*/, LPCSTR apptype /* = NULL */)
{
	const char* const THIS_FUNCTION = "COProject::NewAppWiz";

	UIProjectWizard uprjwiz = AppWizard();
	UIAppWizard uaw;

	// set the project directory and name
	if(projdir)
		uprjwiz.SetDir(projdir);
	uprjwiz.SetName(projname);

	if (apptype != NULL)
	{
		const char* const JAVA_APPWIZ = "Java Applet Wizard";

		if (strcmp(apptype,JAVA_APPWIZ) == 0)
		{
			// Special proj type specified - so ignore special steps
			uprjwiz.SetProjType(apptype);
			uaw.Create();           // goes to step 1
			// Do a kluge hack for now 
			// Bug 6292
			uaw.NextPage();         // step 2
			uaw.NextPage();         // step 3
		}
		else
		{
			// Special proj type specified - so ignore special steps
			uprjwiz.SetProjType(apptype);
			uaw.Create();           // goes to step 1
		}
	}
	else
	{
		uprjwiz.SetProjType(UIAW_PT_APPWIZ);

		SetNewProjectPlatforms(platforms);
		uaw.Create();           // goes to step 1

                if( uaw.GetPage() != UIAW_APPTYPE )
                {
                        LOG->RecordInfo("%s: clicking Create button didn't move to step 1. Unable to create a new AppWizard project.", THIS_FUNCTION);
                        MST.DoKeys("{ESC 5}");
                        return ERROR_ERROR;
                }
                uaw.NextPage();         // step 2
                uaw.NextPage();         // move to step 3

                // set options for step 3
                if (pOptions) {
                        int aOLEOptions[] = { UIAW_OLE_NONE, UIAW_OLE_CONTAINER, UIAW_OLE_MINI_SERVER, UIAW_OLE_FULL_SERVER, UIAW_OLE_CONTAINER_SERVER };
                        // the index into the array (pOptions->mOLECompound) cannot be less than 0 or greater than the number of items in the array
                        ASSERT(pOptions->m_OLECompound >= 0 && pOptions->m_OLECompound < sizeof(aOLEOptions)/sizeof(int));
                        // set the OLE option
                        uaw.SetOLEOptions(aOLEOptions[pOptions->m_OLECompound]);
                }
                if (pOptions && (pOptions->m_OLEAuto == 1)) {
					uaw.SetOLEOptions2(APPWZ_IDCD_AUTOMATION);
				}

                uaw.NextPage();         // step 4

                // set options for step 4
                if (pOptions  && (pOptions->m_Help == 1)) {
//					uaw.SetProjOptions(APPWZ_IDCD_POHELP);
					uaw.SetFeatures(APPWZ_IDCD_POHELP);
				}

                uaw.NextPage();         // step 5

                // Set options for step 5;
                if (pOptions)
                {
                        if (pOptions->m_bUseMFCDLL)
                                uaw.SetProjOptions(UIAW_PROJ_MFCDLL);
                        else
                                uaw.SetProjOptions(UIAW_PROJ_MFCSTATIC);
                }
	}

	if( uaw.Finish() != UIAW_CONFIRM )
	{
		LOG->RecordInfo("%s: clicking Finish button didn't move to Confirmation screen. Unable to create a new AppWizard project.", THIS_FUNCTION);
		return ERROR_ERROR;
	}

	if( uaw.ConfirmCreate() == FALSE )
	{
		LOG->RecordInfo("%s: problem generating project. Unable to create a new AppWizard project.", THIS_FUNCTION);
		return ERROR_ERROR;
	}
    ActivateProjWnd(); // Give focus to workspace window.

	// bring up the project window
	NewProjectWindow();

	// set up the member variables that contain information about this project
	SetPathMembers();

	return ERROR_SUCCESS;
}



// BEGIN_HELP_COMMENT
// Function: int COProject::Open(LPCSTR szProjName, int iMethod, BOOL LogWarning /* = TRUE */)
// Description: Open a project and the project window.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szProjName A pointer to a string containing the filename of the project to open. This is usually a full path to the project file.
// Param: iMethod Unused.
// Param: LogWarning A Boolean value that indicates whether to log any warnings that occur when opening a project (TRUE) or not. (Default value is TRUE.)
// END_HELP_COMMENT
int COProject::Open(LPCSTR szProjName, int iMethod, BOOL LogWarning /* = TRUE */)
{
	const char* const THIS_FUNCTION = "COProject::Open";

	BOOL bDone;
	int i;
	DWORD dwControl;
	DWORD dwProcessId;
	
	// if the given project name is NULL, use the member that specifies the name
	if (szProjName == NULL)
	{
		if (m_ProjName.IsEmpty()) {
			LOG->RecordInfo("%s: project name not given. Unable to open project.", THIS_FUNCTION);
			return ERROR_ERROR;
		}
		else
			szProjName = (const char *) m_FullPath ;
	}

	// open the project file via the Open Workspace dialog
	UIOpenWorkspaceDlg uiOpenWrkDlg;

	// open the Open Workspace dialog
	uiOpenWrkDlg.Display();

	// set the filename
	uiOpenWrkDlg.SetName(szProjName);

	// click OK
	if (!uiOpenWrkDlg.OK(FALSE)) {
		LOG->RecordInfo("%s: cannot dismiss the Open Workspace dialog. Unable to open the project.", THIS_FUNCTION);
		return ERROR_ERROR;
	}

	SetPathMembers();

	// get the process ID of UIWB
	GetWindowThreadProcessId(UIWB.HWnd(), &dwProcessId);

	// after opening a project, any number of dialogs/message boxes can come
	// up before the project is actually opened

	// we will loop looking for any of the message boxes that can potentially
	// come up until the project workspace window comes up, we timeout, or
	// we get too many message boxes/dialogs before seeing the project
	// workspace window
	
	// set up array of controls to wait for
	// 0: Save As dialog; 0x441 is the Save Files As Type static text
	// 1: message box with Yes button
	// 2: message box with OK button
	int aControls[] = { VRES_stc2, VPROJ_IDC_PLATFORMS, MSG_YES, MSG_OK };

	bDone = FALSE;
	// we shouldn't loop more than five times
	for (i = 0; i < 5 && !bDone; i++) {
		// wait for the IDE to be idle
		WaitForInputIdle(g_hTargetProc, 60000);
		// wait for one of the controls in the array to be displayed
		dwControl = WaitForMultipleControls(dwProcessId, sizeof(aControls)/sizeof(int), aControls, 2000);

		switch (dwControl) {
			case WAIT_TIMEOUT: {
				// we timed out; this means we didn't find any of the windows we expected
				bDone = TRUE;
				break;
			}
			case WAIT_CONTROL_0: {
				// Save As dialog
				UIFileSaveAsDlg uisaveas;

				if (uisaveas.AttachActive()) {
					LOG->RecordInfo("%s: Save As dialog detected when opening the project. Clicking default button (Save).", THIS_FUNCTION);

					// Change the value if necessary and save it.
					uisaveas.SetName(uisaveas.GetName() + "new");

					// dismiss it with the default button
					MST.DoKeys("{ENTER}");
					Sleep(2000);					
				}
				else
					LOG->RecordInfo("%s: Couldn't attach to Save As dialog", THIS_FUNCTION);

				break;
			}

			case WAIT_CONTROL_1: {
				// Platform selection box from opening an external project
				LOG->RecordInfo("%s: Platforms dialog detected", THIS_FUNCTION);

				/* REVIEW: VerifyClass() && VerifyUnique() are both failing 
				   in the call to dlg.AttachActive(), so to work-around we are
				   just hitting ENTER for now.

				UIDialog dlg;

				// attach to the active message box
				if (dlg.AttachActive()) {
					LOG->RecordInfo("%s: Clicked OK", THIS_FUNCTION);
					// dismiss it with the default button
					dlg.OK();
					Sleep(2000);					
				}
				else
					LOG->RecordInfo("%s: Couldn't attach to Platform message box", THIS_FUNCTION);
				*/
				
				LOG->RecordInfo("%s: hit ENTER", THIS_FUNCTION);
				MST.DoKeys("{ENTER}");
				Sleep(2000);
				break;
			}

			case WAIT_CONTROL_2: {
				// message box with a Yes button
				UIWBMessageBox uimsg;
				LOG->RecordInfo("%s: Yes/No message box detected", THIS_FUNCTION);
				
				// attach to the active message box
				uimsg.Attach(MST.WGetActWnd(0)) ;
				// REVIEW(Ivanl) AttachActive was failing, we are bypassing it for now.
				//if (uimsg.AttachActive()) 
					{
					LOG->RecordInfo("%s: Yes/No message box contains '%s'", THIS_FUNCTION, (LPCSTR)uimsg.GetMessageText());

					// if the message box text contains the string 'replace,'
					// then we need to handle this as the case when the
					// wrapper makefile is created but one already exists on
					// the disk
					if ((uimsg.GetMessageText()).Find(GetLocString(IDSS_REPLACE)) != -1) {
						LOG->RecordInfo("%s: Clicked Yes", THIS_FUNCTION);
						MST.WButtonClick(GetLocString(IDSS_YES));
						Sleep(2000);
					}
					// If the message box text contains a message pertaining to the fact
					// that a file is marked read-only, so it has to be saved to a different 
					// filename, then say no.
					else if ((uimsg.GetMessageText()).Find(GetLocString(IDSS_READ_ONLY)) != -1) {
						LOG->RecordInfo("%s: Clicked No", THIS_FUNCTION);
						MST.WButtonClick(GetLocString(IDSS_NO));
						Sleep(2000);					
					}
					else {
						LOG->RecordInfo("%s: Clicked Default", THIS_FUNCTION);
						// dismiss the dialog with the default button
						MST.DoKeys("{ENTER}") ;
						Sleep(2000);					
					}
				}
				break;
			}
			case WAIT_CONTROL_3: {
				// TODO(michma - 5/22/98): for some reason on nt5 we have a timing problem where
				// UIWBMessageBox::AttachActive (below) fails if we don't wait for a second. it's almost
				// as if nt is notifying us about WAIT_CONTROL_3 before the message box is up, or maybe
				// control id's on nt have changed and we are finding a different WAIT_CONTROL_3.
				Sleep(1000);
				// message box with an OK button
				LOG->RecordInfo("%s: OK message box detected", THIS_FUNCTION);

				UIWBMessageBox uimsg;

				// attach to the active message box
				if (uimsg.AttachActive()) {
					LOG->RecordInfo("%s: OK message box contains '%s'", THIS_FUNCTION, (LPCSTR)uimsg.GetMessageText());
					LOG->RecordInfo("%s: Clicked default", THIS_FUNCTION);
					// dismiss it with the default button
					MST.DoKeys("{ENTER}");
					Sleep(2000);					
				}
				else
					LOG->RecordInfo("%s: Couldn't attach to message box", THIS_FUNCTION);
				break;
			}
			default: {
				LOG->RecordInfo("%s: WaitForMultipleControls() returned an unknown value. Unable to open the project.", THIS_FUNCTION);
				return ERROR_ERROR;
				break;
			}
		}
	}

	// bring up the project window
	NewProjectWindow();

	// is it valid?

	SetPathMembers();

	return ERROR_SUCCESS;
}

// BEGIN_HELP_COMMENT
// Function: int COProject::Save(int wait == FALSE, LPCSTR file = NULL)
// Description: Save the project.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: wait A Boolean value that indicates whether to wait for the file to be completely written before returning (TRUE) or not. (Default value is FALSE.)
// Param: file A pointer to a string that contains the name of the project file. This parameter is only required if wait is set to TRUE. (Default value is NULL.)
// END_HELP_COMMENT
int COProject::Save(int wait /* FALSE */, LPCSTR file /* NULL */)
{
	const char* const THIS_FUNCTION = "COProject::Save";

	VERIFY_VALID_PROJECT("Unable to save the project.")

	CTime timeStart;
	CTimeSpan timeSpan;

	CFileStatus statusFile;

	ActivateProjWnd();
	
	// get the current time
	timeStart = CTime::GetCurrentTime();

	// save the project
	UIWB.DoCommand(IDM_SAVE_WORKSPACE, DC_MNEMONIC);
	WaitForInputIdle(g_hTargetProc, 2000); //safety

	// are we supposed to wait for the file to be saved?
	if (wait) {
		// the filename must be supplied
		ASSERT(file && file[0] != '\0');
		if (!file || file[0] == '\0') {
			LOG->RecordInfo("COProject::Save() filename not specified.");
			return ERROR_ERROR;
		}

		// Wait 5 minutes for the save to finish.
        if (WaitForInputIdle(g_hTargetProc, 5 * 60000) == WAIT_TIMEOUT)	{
				LOG->RecordInfo("COProject::Save() timed out because saving took longer than 5 minutes");
				return ERROR_ERROR;
		}
	}

	return ERROR_SUCCESS;

}

// BEGIN_HELP_COMMENT
// Function: int COProject::AddFiles(LPCSTR szFileName, LPCSTR szGrpName)
// Description: Add the files given by the filespec in szFileName to the specified group in the project.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szFileName A pointer to a string that contains the filespec describing the files to add. Wildcards (* and ?) are permitted.
// Param: szGrpName A pointer to a string that contains the name of the group to add the files to.
// END_HELP_COMMENT
int COProject::AddFiles(LPCSTR szFileName, LPCSTR szGrpName)
{
	const char* const THIS_FUNCTION = "COProject::AddFiles";

	VERIFY_VALID_PROJECT("Unable to add files to the project.")

	CString Files = szFileName ; //make me a CString object from szFileName for ease of manipulation
	int iNextName = 0 ;

	HWND hOrig = WGetActWnd(0) ;
	UIWB.DoCommand(IDM_PROJITEM_ADD_FILES, DC_MNEMONIC);	// DevStudio96:11551, don't use MNENOMIC
	
//      control IDs, obtained from Spy++
#define ID_FSAD_FILENAME                0x480

	if (!UIWB.WaitOnWndWithCtrl(ID_FSAD_FILENAME,3000))
	   return ERROR_ERROR ;
	
	LOG->RecordInfo("Add File(s) %s", szFileName);

	MST.WEditSetText(GetLabel(ID_FSAD_FILENAME), szFileName) ;
	Sleep(250);	// Win2000 needs this sleep (BJoyce)
	
	// If the name has a wildcard,  filter the listbox and multi-select
	if((Files.Find('*')>=0) || (Files.Find('?')>=0) )
	{
		LOG->RecordInfo("Multiple File Select");
		MST.DoKeys("{ENTER}") ; //To fill up the Files listbox
		Sleep(500);
		//set focus to Files listbox
		MST.DoKeys("+{TAB}");
		Sleep(250);
		MST.DoKeys(" "); //turn on selection
		Sleep(250);
		MST.DoKeys("+{END}"); //select all files
		Sleep(500);
		// what files are we going to add according to the selection
		CString strTemp;
		MST.WGetText(::GetDlgItem(WGetActWnd(0), ID_FSAD_FILENAME), strTemp);
		LOG->RecordInfo("Which files are we adding - %s", strTemp);

		MST.WButtonClick(GetLabel(IDOK)) ; // Add and Close dialog.
	}
	else  //
	{
		LOG->RecordInfo("Only one file");
		HWND hWnd = WGetActWnd(0) ;       // Dialog handle
		
		MST.WButtonClick(GetLabel(IDOK)) ;  // Add and Close dialog.
		// Did an error occur?
		if ((WGetActWnd(0) != hWnd) && (WGetActWnd(0) != hOrig))  // We got an error message
		{ // Press enter and cancel operation.
			if (WGetActWnd(0) != hWnd)
				MST.DoKeys("{ENTER}") ;
			MST.DoKeys("{ESC}") ;
			return ERROR_ERROR ;
		}
	}

	HWND hWait = (HWND) 1 ;
	int i = 0 ;

	while( i )        // Scan for a minute.
	{
		if(UIWB.WaitOnWndWithCtrl(8,3000)) //Wait for an error message to show up, if it shows up exit
		{       
            MST.DoKeys("{ESC}") ;
			return ERROR_ERROR ;
		}
		else
			if (WGetActWnd(0) == hOrig) // if we are back to the editor
			{
				return ERROR_SUCCESS ;
			}
		i-- ;
	}
	return ERROR_SUCCESS;
}


// BEGIN_HELP_COMMENT
// Function: int COProject::RemoveFiles(LPCSTR szFileNames, LPCSTR szGrpName )
// Description: Remove the files named in szFileNames from the specified group in the project.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szFileNames A pointer to a string that contains the list of files (separated by semicolons (;)) to remove from the group.
// Param: szGrpName A pointer to a string that contains the name of the group.
// END_HELP_COMMENT
int COProject::RemoveFiles(LPCSTR szFileNames, LPCSTR szGrpName )
{
	const char* const THIS_FUNCTION = "COProject::RemoveFiles";

	VERIFY_VALID_PROJECT("Unable to remove files from the project.")

    CString szFile, szSpaces ;
	CString Files = szFileNames ; //make me a CString object from szFileName for ease of manipulation
	int iNextName = 0 ;

// REVIEW(briancr): you don't remove files via the Files dialog. This function needs to be changed.
	ASSERT(0);
	return ERROR_ERROR;
#if 0
	// Bring up the Files dialog
	UIWB.DoCommand(IDM_PROJITEM_ADD_FILES, DC_MNEMONIC);
	if (!UIWB.WaitOnWndWithCtrl(VPROJ_IDC_EDITPROJ_GROUP,3000))
	   return ERROR_ERROR ;

	// Select the desired group to remove file from
	MST.WListItemClk(GetLabel(VPROJ_IDC_EDITPROJ_GROUP),(LPSTR)szGrpName) ;

	for (; !Files.IsEmpty(); )
	{
	// Get a name from the Files list
		if((iNextName = Files.Find(';')) != -1) // If there are more than one filename
		{
			szFile = Files.Left(iNextName) ;
		}
		else
		{
			szFile = Files ;
			Files = "" ; //Prepare to end the loop.
			iNextName = -1 ;
		}

		// Remove any leading and trailing spaces from the name.
		szSpaces =szFile.SpanExcluding("' '") ;
		if(szSpaces.IsEmpty())  // If there were leading spaces
		{
			szSpaces =szFile.SpanIncluding("' '") ;
			szFile = (szFile.Right(szFile.GetLength() - szSpaces.GetLength())).SpanExcluding("' '") ;
		}
		else // If there were no leading spaces assign szFile to the extracted string without spaces.
		{
			szFile = szSpaces ;
		}

		// Remove the file from the listbox of project filenames.
		if (!MST.WListItemExists(GetLabel(VPROJ_IDC_EDITPROJ_GROUP),szFile.GetBuffer(szFile.GetLength())))
			{
				MST.DoKeys("{ESC}") ;
				return ERROR_ERROR ;
			}
		else
			{
				MST.WListItemDblClk(GetLabel( VPROJ_IDC_EDITPROJ_GROUP),szFile.GetBuffer(szFile.GetLength())) ;
				Files = Files.GetBuffer(Files.GetLength()) + iNextName + 1 ;
				Files.ReleaseBuffer() ;
			}
	}
	MST.WButtonClick(GetLabel(VPROJ_IDCLOSE)) ;

	return ERROR_SUCCESS ;

#endif
}

// BEGIN_HELP_COMMENT
// Function: int COProject::RemoveAll(LPCSTR szGrpName)
// Description: Remove all files from the specified group in the project. This function is NYI.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szGrpName A pointer to a string that contains the name of the group.
// END_HELP_COMMENT
int COProject::RemoveAll(LPCSTR szGrpName)
{
	const char* const THIS_FUNCTION = "COProject::RemoveAll";

	VERIFY_VALID_PROJECT("Unable to remove all files from the project.")

 return ERROR_ERROR ; //NYI

}

// Directory / File delete utilities (REVIEW)IVANL Does Delnode exist on MIPS?? HOPE SO!!
CString CommandLine = "CMD /C \"echo y | rd /s \"", arg ;
// BEGIN_HELP_COMMENT
// Function: int COProject::DeleteMakeFile()
// Description: Delete the makefile associated with the project.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// END_HELP_COMMENT
int COProject::DeleteMakeFile()
{
	HWND hOrig = WGetActWnd(0) ;
	KillFile (m_FullPath);
	return WaitForOriginalWnd(hOrig, 20) ;
}

// BEGIN_HELP_COMMENT
// Function: int COProject::DeleteFromProjectDir(LPCSTR strDelTarget)
// Description: Delete all files in the project directory.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: strDelTarget A pointer to a string that contains a relative path to append to the project directory, or a full path if there is no project open. This parameter can be NULL.
// END_HELP_COMMENT
int COProject::DeleteFromProjectDir(LPCSTR strDelTarget)
{
	HWND hOrig = WGetActWnd(0) ;
	CString wild = "*.*" ;
	if (m_ProjDir.IsEmpty())
		if (strDelTarget == NULL)
		{
			LOG->RecordInfo("You have to provide a Delete Target if no project is open. ::DeleteFromProjectDir()") ;
			return ERROR_ERROR ;
		}
		else
		m_ProjDir = strDelTarget ;
	else
		m_ProjDir +=strDelTarget ;
	return KillAllFiles(m_ProjDir) ;
	
}

// BEGIN_HELP_COMMENT
// Function: int COProject::RemoveIntermediateDir()
// Description: Delete the directory that contains the intermediate files generated by building the project.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// END_HELP_COMMENT
int COProject::RemoveIntermediateDir()
{
	HWND hOrig = WGetActWnd(0) ;
	return KillAllFiles(GetIntermediateDir());
	return WaitForOriginalWnd(hOrig, 20) ;
}

// BEGIN_HELP_COMMENT
// Function: int COProject::RemoveTargetDir()
// Description: Delete the directory that contains the target files generated by building the project.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// END_HELP_COMMENT
int COProject::RemoveTargetDir()
{
	HWND hOrig = WGetActWnd(0) ;
	// need to go grab the m_OutputFile since it might have been changed by someone
	// during testing. It can happen.
	GetOutputFile();

	char drive[_MAX_DRIVE];   char dir[_MAX_DIR];
	char fname[_MAX_FNAME];   char ext[_MAX_EXT];

	_splitpath( m_OutputFile, drive, dir, fname, ext );
	CString strTemp = drive;
	strTemp += dir;

	return KillAllFiles(strTemp);
	
}

// Configurations / Targets
// BEGIN_HELP_COMMENT
// Function: int COProject::AddTarget(LPCSTR Name, int Type , BOOL Debug/* =FALSE*/)
// Description: Add a new target to the project.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: Name A pointer to a string that contains the name of the new target.
// Param: Type A value that indicates the type of target to add: TARGET_WIN32_X86_DEBUG, TARGET_WIN32_X86_RELEASE, TARGET_MAC_68K_DEBUG, TARGET_MAC_68K_RELEASE, TARGET_MAC_PPC_DEBUG, TARGET_MAC_PPC_RELEASE, TARGET_USER, TARGET_CURRENT.
// Param: Debug A Boolean value that indicates whether to make this target debug (TRUE) or not. (Default value is FALSE.)
// END_HELP_COMMENT
int COProject::AddTarget(LPCSTR Name, int Type , BOOL Debug/* =FALSE*/)
{
	const char* const THIS_FUNCTION = "COProject::AddTarget";

	VERIFY_VALID_PROJECT("Unable to add a target to the project.")

	UIProjectTarget tr ;
	int ret ;
	tr.Show() ;
	ret = tr.New(Name,Type,Debug) ;
	tr.Close() ;
	if (ret)
		return ERROR_SUCCESS ;
	else
		return ERROR_ERROR ;
}

// BEGIN_HELP_COMMENT
// Function: int COProject::AddTarget(LPCSTR Name, LPCSTR CopyFrom)
// Description: Add a new target to the project by deriving from an existing target.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: Name A pointer to a string that contains the name of the new target.
// Param: CopyFrom A pointer to a string that contains the name of the target to derive this target from.
// END_HELP_COMMENT
int COProject::AddTarget(LPCSTR Name, LPCSTR CopyFrom)
{
	const char* const THIS_FUNCTION = "COProject::AddTarget";

	VERIFY_VALID_PROJECT("Unable to add a target to the project.")

	UIProjectTarget tr ;
	int ret ;
	tr.Show() ;
	ret = tr.New(Name,CopyFrom) ;
	tr.Close() ;
	if (ret)
		return ERROR_SUCCESS ;
	else
		return ERROR_ERROR ;

}

// BEGIN_HELP_COMMENT
// Function: int COProject::SetTarget(LPCSTR Target)
// Description: Select one of the targets for this project.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: Target A pointer to a string that contains the name of the target to select.
// END_HELP_COMMENT
int COProject::SetTarget(LPCSTR target)
{
	const char* const THIS_FUNCTION = "COProject::SetTarget";

	VERIFY_VALID_PROJECT("Unable to select a target.")

	UIProjectTarget tr;
	int ret;
	tr.Show();
	ret = tr.SetTarget(target);
	tr.Close();
	return ret ? ERROR_SUCCESS : ERROR_ERROR;
	}


int COProject::SetTarget(TARGET_TYPE target)

// todo: this function allows the user to set the current project target using
// portable symbols instead of strings, which will ease maintainence. however,
// this function still needs to be implemented.  see definition of TARGET_TYPE
// in coprject.h.  note that a target of TARGET_USER should set the current
// target to that specified by the user.  the user-specified platform can be
// retrieved with GetUserTargetPlatforms().  currently there is no standard way
// for a test to find out if it is targetting a retail target or a debug target.

	{
	return ERROR_SUCCESS;
	}


TARGET_TYPE COProject::GetCurrentTarget(void)

// todo: this function allows the user to get the current project target using
// portable symbols instead of strings, which will ease maintainence. however,
// this function still needs to be implemented.  see definition of TARGET_TYPE
// in coprject.h.

	{
	return TARGET_WIN32_X86_DEBUG;
	}


// BEGIN_HELP_COMMENT
// Function: int COProject::DeleteTarget(LPCSTR Target)
// Description: Delete one of the targets for this project.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: Target A pointer to a string that contains the name of the target to delete.
// END_HELP_COMMENT
int COProject::DeleteTarget(LPCSTR Target)
{
	const char* const THIS_FUNCTION = "COProject::DeleteTarget";

	VERIFY_VALID_PROJECT("Unable to delete a target from the project.")

	UIProjectTarget tr ;
	int ret ;
	tr.Show() ;
	ret = tr.Delete(Target) ;
	tr.Close() ;
	if (ret)
		return ERROR_SUCCESS ;
	else
		return ERROR_ERROR ;
}
// BEGIN_HELP_COMMENT
// Function: int COProject::RenameTarget(LPCSTR OldName, LPCSTR NewName)
// Description: Change the name of one of the targets in this project.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: OldName A pointer to a string that contains the name of the target to change.
// Param: NewName A pointer to a string that contains the new name for the target.
// END_HELP_COMMENT
int COProject::RenameTarget(LPCSTR OldName, LPCSTR NewName)
{
	const char* const THIS_FUNCTION = "COProject::RenameTarget";

	VERIFY_VALID_PROJECT("Unable to rename a target.")

	UIProjectTarget tr ;
	int ret ;
	tr.Show() ;
	ret = tr.Rename(OldName,NewName) ;
	tr.Close() ;
	if (ret)
		return ERROR_SUCCESS ;
	else
		return ERROR_ERROR ;

}
// BEGIN_HELP_COMMENT
// Function: LPCSTR COProject::GetTarget(int Target /* = 0 Active target */)
// Description: Get the name of the either the active target or the specified target.
// Return: A pointer to a string that contains the name of the target specified.
// Param: Target An integer that contains a 1-based index into the list of targets. 0 will retrieve the name of the current target. (Default value is 0.)
// END_HELP_COMMENT
LPCSTR COProject::GetTarget(int Target /* = 0 Active target */)
{
	const char* const THIS_FUNCTION = "COProject::GetTarget";

	ASSERT(IsOpen());
	if (!IsOpen()) {
		LOG->RecordInfo("%s: the project is invalid (not opened). Unable to get a target.", THIS_FUNCTION);
		return NULL;						\
	}

	UIProjectTarget tr ;
	const char * ret ;
	tr.Show() ;
	ret = tr.GetTarget(Target) ;
	tr.Close() ;
	return ret ;
}

// BEGIN_HELP_COMMENT
// Function: COProject::Execute(int iRebuild)
// Description: Execute the current project. This function does not execute the project under the debugger.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: iRebuild An Boolean value that indicates whether to rebuild the project before executing, if asked (TRUE) or not.
// END_HELP_COMMENT
COProject::Execute(int iRebuild)
{
	const char* const THIS_FUNCTION = "COProject::Execute";

	VERIFY_VALID_PROJECT("Unable to execute the project.")

	HWND hWnd = WGetActWnd(0) ;
	UIWB.DoCommand(IDM_PROJECT_EXECUTE, DC_ACCEL);

	// Did we get a rebuild messagebox?
	Sleep(2) ; // Wait to see if we get a messagebox to rebuild.

	if(WGetActWnd(0) != hWnd)
	{
		if (iRebuild)
		{
			MST.DoKeys("{ENTER}"); // Take default
			WaitUntilBuildDone(3) ; //Wait on build for 5 minutes. (REVIEW) return here if exceeds max time.
			UIWB.DoCommand(IDM_PROJECT_EXECUTE, DC_ACCEL);
		}
		else
		{       MST.DoKeys("{ESC}");
		}
	}
  return ERROR_SUCCESS ;
}

	// Target
// BEGIN_HELP_COMMENT
// Function: int COProject::Build(int iWait, DWORD interval /*1000*/)
// Description: Build the current target in this project.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: iWait An integer that contains the amount of time in minutes to wait for the build to complete.
// Param: interval An DWORD that contains the amount of time in milliseconds to wait between checks for build completion
// END_HELP_COMMENT
int COProject::Build(int iWait, DWORD interval /*1000*/)
{       // iWait how many MINUTES to wait.
	const char* const THIS_FUNCTION = "COProject::Build";

	VERIFY_VALID_PROJECT("Unable to build the project.")

	
	UIWB.DoCommand(IDM_PROJITEM_BUILD, DC_MNEMONIC);
	return WaitUntilBuildDone(iWait, interval) ;
}

// BEGIN_HELP_COMMENT
// Function: int COProject::RebuildAll(int iWait /* 3 */,DWORD interval /*1000*/)
// Description: Perform a complete rebuild of the current target in this project.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: iWait An integer that contains the amount of time in minutes to wait for the build to complete.
// Param: interval An DWORD that contains the amount of time in milliseconds to wait between checks for build completion
// END_HELP_COMMENT
int COProject::RebuildAll(int iWait /* 3 */, DWORD interval /*1000*/)
{  // iWait how many MINUTES to wait.
	const char* const THIS_FUNCTION = "COProject::RebuildAll";

	VERIFY_VALID_PROJECT("Unable to rebuild the project.")

	UIWB.DoCommand(IDM_PROJITEM_REBUILD_ALL, DC_MNEMONIC) ;
	return WaitUntilBuildDone(iWait, interval) ;
}

// BEGIN_HELP_COMMENT
// Function: int COProject::StopBuild()
// Description: Stop the current build.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// END_HELP_COMMENT
int COProject::StopBuild()
{
	const char* const THIS_FUNCTION = "COProject::StopBuild";

	VERIFY_VALID_PROJECT("Unable to stop building the project.")

	UIWB.DoCommand(IDM_PROJECT_STOP_BUILD, DC_MNEMONIC) ;
	return ERROR_SUCCESS ;
}

// BEGIN_HELP_COMMENT
// Function: CString COProject::GetProjectItemProp(int P_PropID)
// Description: Get the name of the item indicated by P_PropID.
// Return: A CString that contains the name of the item.
// Param: P_PropID An integer that contains the ID of the item.
// END_HELP_COMMENT
CString COProject::GetProjectItemProp(int P_PropID)
{
	const char* const THIS_FUNCTION = "COProject::GetProjectItemProp";

	VERIFY_VALID_PROJECT("Unable to get the property.")

	return UIWB.GetItemProperty(P_PropID) ;
}
/*
int COProject::SelectFile(LPCSTR szFile, LPCSTR szGrp)
{
	UIWB.SelectProjItem(ITM_GROUP,szGrp) ;
	UIWB.SelectProjItem(ITM_FILE,szFile) ;
	return ERROR_ERROR ;
}

int COProject::SelectGroup(LPCSTR szGrpName)
{
	UIWB.WaitOnWndWithCtrl(IDOK,3000 ) ;
	UIWB.SelectProjItem(ITM_GROUP,szGrpName) ;
	return ERROR_ERROR ; // Didn't find the group.
}
 */


// BEGIN_HELP_COMMENT
// Function: int COProject::SelectFile(LPCSTR szFile, LPCSTR szGrp)
// Description: Select a file in the project window.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szFile A pointer to a string that contains the name of the file to select.
// Param: szGrp A pointer to a string that contains the name of the group that contains the file. The value can be an empty string, if the group is not known.
// END_HELP_COMMENT
int COProject::SelectFile(LPCSTR szFile, LPCSTR szGrp)
{
	const char* const THIS_FUNCTION = "COProject::SelectFile";

	VERIFY_VALID_PROJECT("Unable to select a file in the project.")

//      UIWB.SelectProjItem(ITM_GROUP,szGrp) ;
//      UIWB.SelectProjItem(ITM_FILE,szFile) ;

	CString stGrp = szGrp ;
	CString stFile = szFile ;
	stFile.MakeUpper() ;

	// make project window active.
	ActivateProjWnd();

	// If a group was not provided.
	if(stGrp == "")
		stGrp = UIWB.GetItemProperty(P_GroupName) ;
	if(!stGrp.IsEmpty())
	{       // Select the provided group
		if (SelectGroup(stGrp)== ERROR_ERROR)
		return ERROR_ERROR ;
	}
	else
		return ERROR_ERROR ;
	// Now that we have selected the group, find the file.
	CString szPrev = "" ;
	CString szCur = "" ;
	MST.DoKeys("{ENTER}") ;

	for (int i = 1; i ; )
		{
			MST.DoKeys("{DOWN}") ;
			szCur = UIWB.GetItemProperty(P_ProjItemName) ;
			szCur.MakeUpper() ;
			if(szCur == stFile) // We found the desired file
			{
				return ERROR_SUCCESS ;
			}
			else
			{
				CString szGroup ;
				szGroup = UIWB.GetItemProperty(P_GroupName) ;
				szGroup.MakeUpper();
				stGrp.MakeUpper() ;

				if(szGroup != stGrp)  // Did we run into another group?
					return ERROR_ERROR ;

				szPrev.MakeUpper() ; szCur.MakeUpper() ;
				if(szPrev == szCur) // We reached the end of the list
				{
					i = 0 ; // We didn't find it.
				}
				szPrev = szCur ;
			}
		}
	return ERROR_ERROR ;
}

// BEGIN_HELP_COMMENT
// Function: int COProject::SelectGroup(LPCSTR szGrpName)
// Description: Select a group in the project window.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szGrpName A pointer to a string that contains the name of the group to select in the project window.
// END_HELP_COMMENT
int COProject::SelectGroup(LPCSTR szGrpName)
{
	const char* const THIS_FUNCTION = "COProject::SelectGroup";

	VERIFY_VALID_PROJECT("Unable to select a group in the project.")

	// Activate project window
	ActivateProjWnd();
	//Select the Project folder
	MST.DoKeys("{BS 4}") ; // Only need 3
	// Expand all
	MST.DoKeys("{*}") ;
	// Show groups only
	MST.DoKeys("{ENTER 2}") ;
	// Loop through the groups to find the desired group.
	CString szPrev = "", szCur ;
	CString stGrpName(szGrpName) ;
	stGrpName.MakeUpper() ;
	for (int i = 1; i ; )
		{
			MST.DoKeys("{DOWN}") ;
			szCur = UIWB.GetItemProperty(P_GroupName) ;
			szCur.MakeUpper() ;
			if(szCur == stGrpName) // We found the desired group
				return ERROR_SUCCESS ;
			if(szPrev == szCur) // We reached the end of the list
				return ERROR_ERROR ; // We didn't find it.
			szPrev = szCur ;
		}
	return ERROR_ERROR ; // Didn't find the group.
}

// BEGIN_HELP_COMMENT
// Function: int COProject::SetProjProperty(PROJ_PROP_CATEGORIES iCategory,UINT iCtrlId, UINT iNewValue )
// Description: Set a value-based property of the project. (See SetProjProperty(PROJ_PROP_CATEGORIES, UINT, LPCSTR) to set text-based properties.) This function will set project properties such as general, debugger, compiler, linker, resource, and browser.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: iCategory A value that indicates the category of the property: CT_GENERAL, CT_EXT_DBGOPTS, CT_MAKE_TYPE_LIB, CT_COMPILER, CT_RESOURCE, CT_BROWSER, CT_LINKER.
// Param: iCtrlId An integer that contains the ID of the control that modifies the property.
// Param: iNewValue An integer that contains the new value of the property.
// END_HELP_COMMENT
int COProject::SetProjProperty(PROJ_PROP_CATEGORIES iCategory, UINT iCtrlId, UINT iNewValue)
{
	const char* const THIS_FUNCTION = "COProject::SetProjProperty";

	VERIFY_VALID_PROJECT("Unable to set a project property.")

	int iResult;
	// Display the Project Options dialog.

	UIProjOptionsTabDlg uipo;        // REVIEW(EnriqueP) Attach and use OK()
	uipo.AttachActive();
	if (!uipo.IsValid())
	{
		uipo.Display();
		uipo.AttachActive();
	}
	
	iResult = uipo.SetProjOption(iCategory, iCtrlId, iNewValue);

	MST.WButtonClick(GetLabel(IDOK)) ;
	return iResult;
}
	

// BEGIN_HELP_COMMENT
// Function: int COProject::SetProjProperty(PROJ_PROP_CATEGORIES iCategory,UINT iCtrlId, LPCSTR szNewValue )
// Description: Set a text-based property of the project. (See SetProjProperty(PROJ_PROP_CATEGORIES, UINT, UINT) to set value-based properties.) This function will set project properties such as general, debugger, compiler, linker, resource, and browser.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: iCategory A value that indicates the category of the property: CT_GENERAL, CT_EXT_DBGOPTS, CT_MAKE_TYPE_LIB, CT_COMPILER, CT_RESOURCE, CT_BROWSER, CT_LINKER.
// Param: iCtrlId An integer that contains the ID of the control that modifies the property.
// Param: szNewValue An pointer to a string that contains the new value of the property.
// END_HELP_COMMENT
int COProject::SetProjProperty(PROJ_PROP_CATEGORIES iCategory,UINT iCtrlId, LPCSTR szNewValue)
{
	const char* const THIS_FUNCTION = "COProject::SetPropProperty";

	VERIFY_VALID_PROJECT("Unable to set a project property.")

	int iResult;

	UIProjOptionsTabDlg uipo;        // REVIEW(EnriqueP) Attach and use OK()
	uipo.AttachActive();
	if (!uipo.IsValid())
	{
		uipo.Display();
		uipo.AttachActive();
	}

	iResult = uipo.SetProjOption(iCategory, iCtrlId, szNewValue);

	MST.WButtonClick(GetLabel(IDOK)) ;
	return iResult;
}


//Project
// BEGIN_HELP_COMMENT
// Function: int COProject::GetProjProperty(PROJ_PROP_CATEGORIES iCategory,UINT iCtrlId,CString szValue)
// Description: Get the value of a property of this project. (See GetProjProperty(PROJ_PROP_CATEGORIES, UINT) to get text-based properties.) This function will get project properties such as general, debugger, compiler, linker, resource, and browser. This function in NYI.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: iCategory A value that indicates the category of the property: CT_GENERAL, CT_EXT_DBGOPTS, CT_MAKE_TYPE_LIB, CT_COMPILER, CT_RESOURCE, CT_BROWSER, CT_LINKER.
// Param: iCtrlId An integer that contains the ID of the control that identifies the property.
// Param: szNewValue A CString that adds no value that I can see.
// END_HELP_COMMENT
int COProject::GetProjProperty(PROJ_PROP_CATEGORIES iCategory, UINT iCtrlId, CString szValue)
{
	const char* const THIS_FUNCTION = "COProject::GetProjProperty";

	VERIFY_VALID_PROJECT("Unable to get a project property.")

	return ERROR_ERROR ;
}

// BEGIN_HELP_COMMENT
// Function: CString COProject::GetProjProperty(PROJ_PROP_CATEGORIES iCategory,UINT iCtrlId)
// Description: Get the text value of a property of this project. (See GetProjProperty(PROJ_PROP_CATEGORIES, UINT, CString) to get value-based properties.) This function will get project properties such as general, debugger, compiler, linker, resource, and browser. This function in NYI.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: iCategory A value that indicates the category of the property: CT_GENERAL, CT_EXT_DBGOPTS, CT_MAKE_TYPE_LIB, CT_COMPILER, CT_RESOURCE, CT_BROWSER, CT_LINKER.
// Param: iCtrlId An integer that contains the ID of the control that identifies the property.
// END_HELP_COMMENT
CString COProject::GetProjProperty(PROJ_PROP_CATEGORIES iCategory, UINT iCtrlId)
{
	const char* const THIS_FUNCTION = "COProject::GetProjProperty";

	VERIFY_VALID_PROJECT("Unable to get a project property.")

	CString strResult = "";

	UIProjOptionsTabDlg uipo;        // REVIEW(EnriqueP) Attach and use OK()
	uipo.AttachActive();
	if (!uipo.IsValid())
	{
		uipo.Display();
		uipo.AttachActive();
	}

	strResult = uipo.GetProjOptionStr(iCategory, iCtrlId);

	MST.WButtonClick(GetLabel(IDOK)) ;

	return strResult;
}


//Group
// BEGIN_HELP_COMMENT
// Function: int COProject::GetGroupProperty(PROJ_PROP_CATEGORIES iCategory,LPCSTR szGrpName, UINT iCtrlId)
// Description: Get the value of a property for the given group. (See GetGroupProperty(PROJ_PROP_CATEGORIES, LPCSTR, UINT, CString) to get text-based properties.) This function in NYI.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: iCategory A value that indicates the category of the property: CT_GENERAL, CT_EXT_DBGOPTS, CT_MAKE_TYPE_LIB, CT_COMPILER, CT_RESOURCE, CT_BROWSER, CT_LINKER.
// Param: szGrpName A pointer to a string that contains the name of the group to get properties for.
// Param: iCtrlId An integer that contains the ID of the control that identifies the property.
// END_HELP_COMMENT
int  COProject::GetGroupProperty(PROJ_PROP_CATEGORIES iCategory, LPCSTR szGrpName, UINT iCtrlId)
{
	const char* const THIS_FUNCTION = "COProject::GetGroupProperty";

	VERIFY_VALID_PROJECT("Unable to get a group property.")

	return ERROR_ERROR ;
}

// BEGIN_HELP_COMMENT
// Function: CString COProject::GetGroupProperty(PROJ_PROP_CATEGORIES  iCategory,LPCSTR szGrpName ,UINT iCtrlId,CString szValue)
// Description: Get the text value of a property for the given group. (See GetGroupProperty(PROJ_PROP_CATEGORIES, LPCSTR, UINT) to get value-based properties.) This function in NYI.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: iCategory A value that indicates the category of the property: CT_GENERAL, CT_EXT_DBGOPTS, CT_MAKE_TYPE_LIB, CT_COMPILER, CT_RESOURCE, CT_BROWSER, CT_LINKER.
// Param: szGrpName A pointer to a string that contains the name of the group to get properties for.
// Param: iCtrlId An integer that contains the ID of the control that identifies the property.
// Param: szValue A CString that contains the value of the property for the group.
// END_HELP_COMMENT
CString COProject::GetGroupProperty(PROJ_PROP_CATEGORIES  iCategory,LPCSTR szGrpName ,UINT iCtrlId,CString szValue)
{
	const char* const THIS_FUNCTION = "COProject::GetGroupProperty";

	VERIFY_VALID_PROJECT("Unable to get a group property.")

	return "" ;
}

// BEGIN_HELP_COMMENT
// Function: int COProject::SetGroupProperty(PROJ_PROP_CATEGORIES  iCategory,LPCSTR szGrpName ,UINT iCtrlId, UINT iNewValue )
// Description: Set the value of a property for the given group. (See SetGroupProperty(PROJ_PROP_CATEGORIES, LPCSTR, UINT, LPCSTR) to set text-based properties.)
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: iCategory A value that indicates the category of the property: CT_GENERAL, CT_EXT_DBGOPTS, CT_MAKE_TYPE_LIB, CT_COMPILER, CT_RESOURCE, CT_BROWSER, CT_LINKER.
// Param: szGrpName A pointer to a string that contains the name of the group to get properties for.
// Param: iCtrlId An integer that contains the ID of the control that identifies the property.
// Param: iNewValue An integer that contains the new value for the property.
// END_HELP_COMMENT
int COProject::SetGroupProperty(PROJ_PROP_CATEGORIES  iCategory,LPCSTR szGrpName ,UINT iCtrlId, UINT iNewValue )
{
	const char* const THIS_FUNCTION = "COProject::SetGroupProperty";

	VERIFY_VALID_PROJECT("Unable to set a group property.")

	UIProjOptionsTabDlg uipo;        // REVIEW(EnriqueP) Attach and use OK()
	uipo.AttachActive();
	if (!uipo.IsValid())
	{
		uipo.Display();
		uipo.AttachActive();
	}
	uipo.SelectGroup(szGrpName) ; // REVIEW(Ivanl) Need to pass in a target name.
	return SetOption(iCategory,iCtrlId, iNewValue) ;

}

// BEGIN_HELP_COMMENT
// Function: int COProject::SetGroupProperty(PROJ_PROP_CATEGORIES  iCategory,LPCSTR szGrpName ,UINT iCtrlId, LPCSTR szNewValue )
// Description: Set the text value of a property for the given group. (See SetGroupProperty(PROJ_PROP_CATEGORIES, LPCSTR, UINT, UINT) to set value-based properties.)
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: iCategory A value that indicates the category of the property: CT_GENERAL, CT_EXT_DBGOPTS, CT_MAKE_TYPE_LIB, CT_COMPILER, CT_RESOURCE, CT_BROWSER, CT_LINKER.
// Param: szGrpName A pointer to a string that contains the name of the group to get properties for.
// Param: iCtrlId An integer that contains the ID of the control that identifies the property.
// Param: szNewValue A pointer to a string that contains the text value for the property.
// END_HELP_COMMENT
int COProject::SetGroupProperty(PROJ_PROP_CATEGORIES  iCategory,LPCSTR szGrpName ,UINT iCtrlId, LPCSTR szNewValue )
{       // Display the Project Options dialog.
	const char* const THIS_FUNCTION = "COProject::SetGroupProperty";

	VERIFY_VALID_PROJECT("Unable to set a group property.")

	UIProjOptionsTabDlg uipo;        // REVIEW(EnriqueP) Attach and use OK()
	uipo.AttachActive();
	if (!uipo.IsValid())
	{
		uipo.Display();
		uipo.AttachActive();
	}
	uipo.SelectGroup(szGrpName) ; // REVIEW(Ivanl) Need to pass in a target name.
	return SetOption(iCategory,iCtrlId, szNewValue) ;
}


//File .
// BEGIN_HELP_COMMENT
// Function: int COProject::GetFileProperty(PROJ_PROP_CATEGORIES iCategory,LPCSTR szGrpName ,LPCSTR szFileName,UINT iCtrlId)
// Description: Get the value of a property for the given file. (See GetFileProperty(PROJ_PROP_CATEGORIES, LPCSTR, LPCSTR, UINT, CString) to get text-based properties.) This function in NYI.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: iCategory A value that indicates the category of the property: CT_GENERAL, CT_EXT_DBGOPTS, CT_MAKE_TYPE_LIB, CT_COMPILER, CT_RESOURCE, CT_BROWSER, CT_LINKER.
// Param: szGrpName A pointer to a string that contains the name of the group that contains the file.
// Param: szFileName A pointer to a string that contains the file to get properties for.
// Param: iCtrlId An integer that contains the ID of the control that identifies the property.
// END_HELP_COMMENT
int COProject::GetFileProperty(PROJ_PROP_CATEGORIES iCategory,LPCSTR szGrpName ,LPCSTR szFileName,UINT iCtrlId)
{
	const char* const THIS_FUNCTION = "COProject::GetFileProperty";

	VERIFY_VALID_PROJECT("Unable to get a file property.")

	return ERROR_ERROR ;
}

// BEGIN_HELP_COMMENT
// Function: CString COProject::GetFileProperty(PROJ_PROP_CATEGORIES iCategory,LPCSTR szGrpName ,LPCSTR szFileName,UINT iCtrlId,CString szValue)
// Description: Get the text value of a property for the given file. (See GetFileProperty(PROJ_PROP_CATEGORIES, LPCSTR, LPCSTR, UINT) to get value-based properties.) This function in NYI.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: iCategory A value that indicates the category of the property: CT_GENERAL, CT_EXT_DBGOPTS, CT_MAKE_TYPE_LIB, CT_COMPILER, CT_RESOURCE, CT_BROWSER, CT_LINKER.
// Param: szGrpName A pointer to a string that contains the name of the group that contains the file.
// Param: szFileName A pointer to a string that contains the file to get properties for.
// Param: iCtrlId An integer that contains the ID of the control that identifies the property.
// Param: szValue A CString that contains the text value of the property for the given file.
// END_HELP_COMMENT
CString COProject::GetFileProperty(PROJ_PROP_CATEGORIES iCategory,LPCSTR szGrpName ,LPCSTR szFileName,UINT iCtrlId,CString szValue)
{
	const char* const THIS_FUNCTION = "COProject::GetFileProperty";

	VERIFY_VALID_PROJECT("Unable to get a file property.")

	return "" ;
}

// BEGIN_HELP_COMMENT
// Function: int COProject::SetFileProperty(PROJ_PROP_CATEGORIES iCategory,LPCSTR szGrpName, LPCSTR szFileName ,UINT iCtrlId, UINT iNewValue )
// Description: Set the value of a property for the given file. (See SetFileProperty(PROJ_PROP_CATEGORIES, LPCSTR, LPCSTR, UINT, LPCSTR) to set text-based properties.)
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: iCategory A value that indicates the category of the property: CT_GENERAL, CT_EXT_DBGOPTS, CT_MAKE_TYPE_LIB, CT_COMPILER, CT_RESOURCE, CT_BROWSER, CT_LINKER.
// Param: szGrpName A pointer to a string that contains the name of the group that contains the file.
// Param: szFileName A pointer to a string that contains the file to set properties for.
// Param: iCtrlId An integer that contains the ID of the control that identifies the property.
// Param: iNewValue An integer that contains the new value for the property.
// END_HELP_COMMENT
int COProject::SetFileProperty(PROJ_PROP_CATEGORIES iCategory,LPCSTR szGrpName, LPCSTR szFileName ,UINT iCtrlId, UINT iNewValue )
{       // Display the Project Options dialog.
	const char* const THIS_FUNCTION = "COProject::SetFileProperty";

	VERIFY_VALID_PROJECT("Unable to set a file property.")

	UIProjOptionsTabDlg uipo;        // REVIEW(EnriqueP) Attach and use OK()
	uipo.AttachActive();
	if (!uipo.IsValid())
	{
		uipo.Display();
		uipo.AttachActive();
	}
	uipo.SelectGroup(szFileName,szGrpName) ; // REVIEW(Ivanl) Need to pass in a target name.
	return SetOption(iCategory,iCtrlId, iNewValue) ;

}

// BEGIN_HELP_COMMENT
// Function: int COProject::SetFileProperty(PROJ_PROP_CATEGORIES iCategory,LPCSTR szGrpName, LPCSTR szFileName ,UINT iCtrlId, LPCSTR szNewValue )
// Description: Set the value of a property for the given file. (See SetFileProperty(PROJ_PROP_CATEGORIES, LPCSTR, LPCSTR, UINT, UINT) to set value-based properties.)
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: iCategory A value that indicates the category of the property: CT_GENERAL, CT_EXT_DBGOPTS, CT_MAKE_TYPE_LIB, CT_COMPILER, CT_RESOURCE, CT_BROWSER, CT_LINKER.
// Param: szGrpName A pointer to a string that contains the name of the group that contains the file.
// Param: szFileName A pointer to a string that contains the file to set properties for.
// Param: iCtrlId An integer that contains the ID of the control that identifies the property.
// Param: szNewValue A pointer to a string that contains the text value for the property.
// END_HELP_COMMENT
int COProject::SetFileProperty(PROJ_PROP_CATEGORIES iCategory,LPCSTR szGrpName, LPCSTR szFileName ,UINT iCtrlId, LPCSTR szNewValue )
{       // Display the Project Options dialog.
	const char* const THIS_FUNCTION = "COProject::SetFileProperty";

	VERIFY_VALID_PROJECT("Unable to set a file property.")

	UIProjOptionsTabDlg uipo;        // REVIEW(EnriqueP) Attach and use OK()
	uipo.AttachActive();
	if (!uipo.IsValid())
	{
		uipo.Display();
		uipo.AttachActive();
	}
	uipo.SelectGroup(szFileName,szGrpName) ; // REVIEW(Ivanl) Need to pass in a target name.
	return SetOption(iCategory,iCtrlId, szNewValue) ;

}

// BEGIN_HELP_COMMENT
// Function: int COProject::SetOption(INT iCategory,UINT iCtrlId, LPCSTR szNewValue)
// Description: Set the text value of the project option specified by iCtrlId in the given category (iCategory). (See SetOption(UINT, UINT, UINT) to set value-based options.)
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: iCategory An integer that contains the project category that contains the option to set. This is the ID of a control on the property page in the project options dialog.
// Param: iCtrlId An integer that contains the ID of the control that identifies the option to set.
// Param: szNewValue A pointer to a string that contains the value to set the option to.
// END_HELP_COMMENT
int COProject::SetOption(INT iCategory,UINT iCtrlId, LPCSTR szNewValue)
 {
 	const char* const THIS_FUNCTION = "COProject::SetOption";

	VERIFY_VALID_PROJECT("Unable to set a project option.")

/*     if (UIWB.GetItemProperty(P_ProjIsExternalMakeFile) == "1")
	{
	UITabbedDialog PropTab ;
	PropTab.ShowPage(iCategory,6) ;
	if (!(hActive =ControlOnPropPage(iCtrlId)) ) // If the control is not on the page, try advanced.
		{       // Somewhat redundant since external projs don't have advanced, but who know what, things change!
			CString szItem = MyGetLabel(VPROJ_IDC_ADVANCED_OPT);
			if(!WButtonExists(szItem.GetBuffer(szItem.GetLength())))
			{
				return -1 ; // The control doesnt exist. (REVIEW) change return to constant error code.
			}
			WButtonClick(szItem.GetBuffer(szItem.GetLength())) ;
			Sleep(2000) ; // Wait for the dialog to show
			UITabbedDialog tabAdv ;
			if (!tabAdv.ShowPage(iCtrlId,8))
				return  ERROR_ERROR;
			hActive = ControlOnPropPage(iCtrlId) ;
		}
	}
	else
	{ */

//      MST.DoKeys("{TAB}") ;
	UITabbedDialog PropTab ;
	if (iCategory == CT_IMAGEBLD)
		PropTab.ShowPage("Xbox Image");
	else
		PropTab.ShowPage(iCategory,6) ;
	// If the control is not on the page, go through the categories listbox
	if (!(hActive =ControlOnPropPage(iCtrlId)))
		{       CString itemSt ="@" ;
			char * numSt = "                                 " ;
			int iCts ;
					//If no Categories combobox, error
			if ( (iCts =MST.WComboCount(MyGetLabel(VPROJ_IDC_COMBO1))) == -1)
			{
				MST.DoKeys("{ESC 2}") ;
				return ERROR_ERROR ;
			}
			// Loop through the categories combobox looking for the control.
			for (int i = 1; i < iCts+1; i++)
			{
				MST.WComboItemClk(MyGetLabel(VPROJ_IDC_COMBO1),itemSt+ _itoa(i,numSt, 10)) ;
				if ((hActive =ControlOnPropPage(iCtrlId)))
					i = iCts+1 ;
			}
		}
		if (!hActive) // The control wasn't found
		{
			MST.DoKeys("{ESC 2}") ;
			return ERROR_ERROR ;
		}

		/*      CString szItem = MyGetLabel(VPROJ_IDC_ADVANCED_OPT) ;
			if(!WButtonExists(szItem.GetBuffer(szItem.GetLength())))
			{
				return -1 ; // The control doesnt exist. (REVIEW) change return to constant error code.
			}
			WButtonClick(szItem.GetBuffer(szItem.GetLength())) ;
			Sleep(2000) ; // Wait for the dialog to show
			UITabbedDialog myTesttab ;
			if (!myTesttab.ShowPage(iCtrlId,8))
				return -1 ;
			hActive = ControlOnPropPage(iCtrlId) ;
		  */
//      }
	// We now have the page with the desired control.
	HWND hCtl = GetDlgItem(hActive,iCtrlId) ;
	CString szLabel, szNewText ;
	int iCtrlClass ;
	szNewText = szNewValue ;
	// We need the label, to call MSTest APIs.
	szLabel =MyGetLabel(iCtrlId) ;

	iCtrlClass = GetDlgControlClass(hCtl) ;
	// Determine the control class type
	switch (GetDlgControlClass(hCtl))
	{
		case(GL_COMBOBOX):
			MST.WComboItemDblClk(szLabel.GetBuffer(szLabel.GetLength()),(char *)szNewValue) ;
		break ;
		case (GL_LISTBOX):
			MST.WListItemDblClk(szLabel.GetBuffer(szLabel.GetLength()),(char *) szNewValue) ;
		break ;
		case (GL_EDIT):
			WSetText(hCtl,szNewText.GetBuffer(szNewText.GetLength())) ;
		break ;
		default:
		{
			MST.DoKeys("{ESC 2}")  ;
			return ERROR_ERROR ;
		}
	}

	// Close the dialog
	MST.DoKeys ("{ENTER}") ;
	Sleep(2000) ; // As we close the dialog
	if (IsWindowVisible(hActive))
	{
		MST.WButtonClick(GetLabel(IDOK)) ;
		Sleep(2000) ;
		if (IsWindowVisible(hActive)) // if OK didn't close the dialog
		{
			MST.DoKeys("{ESC 2}") ;
			return ERROR_ERROR ;
		}
		LOG->RecordInfo("{ENTER} did not close the Options Modal dialog");
	}
	return ERROR_SUCCESS ;
}

// BEGIN_HELP_COMMENT
// Function: INT COProject::SetOption(INT iCategory, UINT iCtrlId, UINT iNewValue)
// Description: Set the value of the project option specified by iCtrlId in the given category (iCategory). (See SetOption(UINT, UINT, LPCSTR) to set text-based options.)
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: iCategory An integer that contains the project category that contains the option to set. This is the ID of a control on the property page in the project options dialog.
// Param: iCtrlId An integer that contains the ID of the control that identifies the option to set.
// Param: iNewValue An integer that contains the value to set the option to.
// END_HELP_COMMENT
INT COProject::SetOption(INT iCategory, UINT iCtrlId, UINT iNewValue)
{
	const char* const THIS_FUNCTION = "COProject::SetOption";

	VERIFY_VALID_PROJECT("Unable to set a project option.")

/*  (UIWB.GetItemProperty(P_ProjIsExternalMakeFile) == "1")
	{
	UITabbedDialog PropTab ;
	PropTab.ShowPage(iCategory,6) ;
	if (!(hActive =ControlOnPropPage(iCtrlId)) ) // If the control is not on the page, try advanced.
		{  // Somewhat redundant since external projs don't have advanced, but who know what, things change!
			CString szItem = MyGetLabel(VPROJ_IDC_ADVANCED_OPT);
			if(!WButtonExists(szItem.GetBuffer(szItem.GetLength())))
			{
				return -1 ; // The control doesnt exist. (REVIEW) change return to constant error code.
			}
			WButtonClick(szItem.GetBuffer(szItem.GetLength())) ;
			Sleep(2000) ; // Wait for the dialog to show
			UITabbedDialog tabAdv ;
			if (!tabAdv.ShowPage(iCtrlId,8))
				return  ERROR_ERROR;
			hActive = ControlOnPropPage(iCtrlId) ;
		}
	}
	else
	{         */
	UITabbedDialog PropTab ;
	PropTab.ShowPage(iCategory,6) ;
	// If the control is not on the page, go through the categories listbox
	if (!(hActive =ControlOnPropPage(iCtrlId)))
		{       CString itemSt ="@" ;
			char * numSt = "                                 " ;
			int iCts ;
					//If no Categories combobox, error
			if ( (iCts =MST.WComboCount(MyGetLabel(VPROJ_IDC_COMBO1))) == -1)
			{
				MST.DoKeys("{ESC 2}") ;
				return ERROR_ERROR ;
			}
			// Loop through the categories combobox looking for the control.
			for (int i = 1; i < iCts+1; i++)
			{
				MST.WComboItemClk(MyGetLabel(VPROJ_IDC_COMBO1),itemSt+ _itoa(i,numSt, 10)) ;
				if ((hActive =ControlOnPropPage(iCtrlId)))
					i = iCts+1 ;
			}
		}
		if (!hActive) // The control wasn't found
		{
			MST.DoKeys("{ESC 2}") ;
			return ERROR_ERROR ;
		}
	//}
	
	// We now have the page with the desired control.
	HWND hCtl = GetDlgItem(hActive,iCtrlId) ;
	CString szLabel ;
	CString index = "@" ;
	char * sz = "      " ;
		
	// We need the label, to call MSTest APIs.
	 szLabel = MyGetLabel(iCtrlId) ;
	 // We need a string out of iNewValue to use MSTest combo/list item APIs to click.
	 _itoa(iNewValue, sz, 10) ;
	 index = index + sz ;

	switch (GetDlgControlClass(hCtl))
	{
		case(GL_CHECKBOX):
		{
			if(iNewValue == OPTION_ON)
				MST.WCheckCheck(szLabel.GetBuffer(szLabel.GetLength())) ;
			else
				MST.WCheckUnCheck(szLabel.GetBuffer(szLabel.GetLength())) ;
		}
		break ;
		case(GL_RADIOBUTTON):
			if(iNewValue == OPTION_ON)
				MST.WOptionClick(szLabel.GetBuffer(szLabel.GetLength())) ;
		break ;
		case (GL_BUTTON):
			if(iNewValue == OPTION_ON)
				MST.WButtonClick(szLabel.GetBuffer(szLabel.GetLength())) ;
		break ;
		case(GL_COMBOBOX):
			MST.WComboItemDblClk(GetLabel(iCtrlId),index) ;
		break ;
		case (GL_LISTBOX):
			MST.WListItemDblClk(GetLabel(iCtrlId),index) ;
		break ;
		case (GL_EDIT):
			MST.WEditClick(szLabel.GetBuffer(szLabel.GetLength())) ;
		break ;
		default:
		{
			MST.DoKeys("{ESC 2}") ;
			return ERROR_ERROR ;
		}
	}

	// Close the dialog
	MST.DoKeys ("{ENTER}") ;
	Sleep(2000) ; // As we close the dialog
	if (IsWindowVisible(hActive))
	{
		MST.WButtonClick(GetLabel(IDOK)) ;
		Sleep(2000) ;
		if (IsWindowVisible(hActive)) // if OK didn't close the dialog
		{
			MST.DoKeys("{ESC 2}") ;
			return ERROR_ERROR ;
		}
		LOG->RecordInfo("{ENTER} did not close the Options Modal dialog");
	}
	return ERROR_SUCCESS ;
}


CString MyGetLabel(UINT id)
{
	HWND hwndDialog = ControlOnPropPage(id);
	HWND hwndControl = GetDlgItem(hwndDialog, id);
	EXPECT( IsWindow(hwndControl) );

	int iClass = GetLabelNo(hwndControl);

	switch( iClass )
	{
		case GL_STATIC:
		case GL_BUTTON:
			return GetText(hwndControl);
		case GL_EDIT:
		case GL_LISTBOX:
		case GL_COMBOBOX:
		{
			HWND hwndLabel = GetWindow(hwndControl, GW_HWNDPREV);
			EXPECT( hwndLabel != NULL );
			EXPECT( GetLabelNo(hwndLabel) == GL_STATIC );
			return GetText(hwndLabel);
		}
		case GL_DIALOG:
		case GL_NONE:
		default:
			EXPECT(FALSE);
	}
	return CString("");
}

// BEGIN_HELP_COMMENT
// Function: int COProject::MakeProjectExternal(LPCSTR sName/* =NULL*/)
// Description: Make the project an external project.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: LPCSTR A pointer to a string that contains the new name of the project, if desired. NULL means don't rename the project. (Default value is NULL.)
// END_HELP_COMMENT
int COProject::MakeProjectExternal(LPCSTR sName/* =NULL*/)
{
	const char* const THIS_FUNCTION = "COProject::MakeProjectExternal";

	CFile fUserFile ;
	CFileException e;
	char zero = '0' ;
	if (!sName)
	{       if (m_FullPath.IsEmpty())
			return ERROR_ERROR ;
		sName =(const char *)  m_FullPath ;
	}

   if( !(fUserFile.Open( sName, CFile::modeReadWrite, &e )))
   {
	return ERROR_ERROR ;
   }

  fUserFile.Seek(60, CFile::begin) ;

  fUserFile.Write(&zero, sizeof(char)) ;
  fUserFile.Close() ;
  return ERROR_SUCCESS ;
}

void COProject::SetPathMembers()
{
	const char* const THIS_FUNCTION = "COProject::SetPathMembers";

	CString szBuf, fname, Drive, Ext, Path ;
	m_FullPath = UIWB.GetProjPath() ;
	_splitpath((const char *) m_FullPath,Drive.GetBuffer(_MAX_DRIVE), Path.GetBuffer(_MAX_DIR),
			 m_ProjName.GetBuffer(_MAX_FNAME), Ext.GetBuffer(_MAX_EXT) );

	Drive.ReleaseBuffer() ;
	Path.ReleaseBuffer() ;
	m_ProjName.ReleaseBuffer() ;
	Ext.ReleaseBuffer() ;
	m_ProjName.MakeUpper();
	m_ProjDir = Drive+Path;
}

// BEGIN_HELP_COMMENT
// Function: int COProject::SetPlatform(PLATFORM_TYPE platform)
// Description: Set the current platform for the project.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: platform A value that specifies the platform: PLATFORM_WIN32_X86, PLATFORM_WIN32S_X86, PLATFORM_WIN32_MIPS, PLATFORM_MAC_68K, PLATFORM_MAC_PPC.
// END_HELP_COMMENT
int COProject::SetPlatform(int platform)
{
	const char* const THIS_FUNCTION = "COProject::SetTarget";

	VERIFY_VALID_PROJECT("Unable to set project platform.")

	int index;

	switch(platform)
		{
		case PLATFORM_WIN32_X86:
		case PLATFORM_WIN32S_X86:
		case PLATFORM_WIN32_MIPS:
		case PLATFORM_WIN32_ALPHA:
			index = 1;
			break;
		case PLATFORM_MAC_68K:
			index = 2;
			break;
		case PLATFORM_MAC_PPC:
			index = 3;
			break;
		default:
			return ERROR_ERROR;
		}
		
	UIWB.DoCommand(IDM_PROJECT_SETTINGS, DC_MNEMONIC);
	UITabbedDialog uitd;
	uitd.WaitAttachActive(3000);
	uitd.SetOption(VPROJ_IDC_EXTOPTS_PLATFORM, VPROJ_IDC_EXTOPTS_PLATFORM, index);
	MST.WButtonClick(GetLabel(IDOK));
	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COProject::SetRemotePath(LPCSTR remote_file, TARGET_TYPE target /*= TARGET_CURRENT*/, SRT_OPT srt_opt /*= PREPEND_REMOTE_PATH*/, PLATFORM_TYPE platformad /*= PLATFORM_USER*/)
// Description: Set the remote path for this project. This is used for remote transfer and remote debugging.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: remote_file A pointer to a string that contains the remote file name.
// Param: target A value that indicates the target to set the remote path for: TARGET_WIN32_X86_DEBUG, TARGET_WIN32_X86_RELEASE, TARGET_MAC_68K_DEBUG, TARGET_MAC_68K_RELEASE, TARGET_MAC_PPC_DEBUG, TARGET_MAC_PPC_RELEASE, TARGET_USER, TARGET_CURRENT. (Default value is TARGET_CURRENT.)
// Param: srt_opt A value that indicates whether the full remote path is supplied or to prepend the given path to the existing remote path: PREPEND_REMOTE_PATH, FULL_PATH_SUPPLIED. (Default value is PREPEND_REMOTE_PATH.)
// Param: platform A value that specifies the platform: PLATFORM_WIN32_X86, PLATFORM_WIN32S_X86, PLATFORM_WIN32_MIPS, PLATFORM_MAC_68K, PLATFORM_MAC_PPC. (Default value is PLATFORM_USER.)
// END_HELP_COMMENT
int COProject::SetRemotePath(LPCSTR remote_file,
							 TARGET_TYPE target /* TARGET_CURRENT */,
							 SRT_OPT srt_opt /* PREPEND_REMOTE_PATH */,
							 PLATFORM_TYPE platform /* PLATFORM_USER */)

{
	const char* const THIS_FUNCTION = "COProject::SetRemotePath";

	VERIFY_VALID_PROJECT("Unable to set the remote path.")

	CString remote_target;
	ASSERT(target == TARGET_CURRENT);       // todo: add support for changing target
										
	if(srt_opt == PREPEND_REMOTE_PATH)
		{
		CString remote_path = gpConnec->GetUserRemoteLocalPath(platform);
		remote_target = remote_path + remote_file;
		}

	else
		remote_target = remote_file;
								
	/* pre-xbox stuff
	UIWB.DoCommand(IDM_PROJECT_SETTINGS, DC_MNEMONIC);
	UITabbedDialog uitd;
	uitd.WaitAttachActive(3000);
	
	if(uitd.SetOption(VPROJ_IDC_REMOTE_TARGET, VPROJ_IDC_REMOTE_TARGET,
					  remote_target) != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COProject::SetRemotePath(): "
			  "failed to set remote path option");

		return ERROR_ERROR;
		}

	MST.WButtonClick(GetLabel(IDOK));
	return ERROR_SUCCESS;
	*/

	// xbox version	follows
	/*
	UIWB.DoCommand(IDM_PROJECT_SETTINGS, DC_MNEMONIC);
	UITabbedDialog uitd;
	uitd.AttachActive();

	// show debug page and select dll category	
	uitd.ShowPage(GetLocString(IDSS_TB_DEBUG));
	MST.WComboItemClk("@1", "@1");

	MST.DoKeys("{TAB}",FALSE, 250); //switch focus to the edit box
	Sleep(250); //safety
	MST.DoKeys("{TAB}",FALSE, 250);
	Sleep(250);
	MST.DoKeys("{TAB}",FALSE, 250);
	Sleep(250);
	MST.DoKeys("{TAB}",FALSE, 250);
	Sleep(250);
	MST.DoKeys(remote_target,TRUE);
	Sleep(250);
	MST.DoKeys("{TAB}",FALSE, 250); //switch focus away
	MST.WButtonClick(GetLabel(IDOK));
	*/
	SetProjProperty(CT_DEBUG, DBG_IDC_REMOTE_TARGET, remote_file);
	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COProject::SetAdditionalDLLs(LPCSTR szDLLs)
// Description: Set additional DLLs to be loaded when debugging this project.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: LPCSTR A pointer to a string that contains the name of the additional DLL to add.
// END_HELP_COMMENT
int COProject::SetAdditionalDLLs(LPCSTR szDLLs)
{
	const char* const THIS_FUNCTION = "COProject::SetAdditionalDLLs";

	VERIFY_VALID_PROJECT("Unable to set additional DLLs.")

	UIWB.DoCommand(IDM_PROJECT_SETTINGS, DC_MNEMONIC);
	UITabbedDialog uitd;
	uitd.AttachActive();

	// TODO (michma): this function cannot work until it is
	// able to select the targets for which it wants to load dlls.
	// when more than one target platform is selected,
	// the dll list is disabled.

	// show debug page and select dll category	
	uitd.ShowPage(GetLocString(IDSS_TB_DEBUG));
	MST.WComboItemClk("@1", "@2");

	MST.DoKeys("{TAB}",FALSE, 1000); //switch focus to the custom conrol
	Sleep(1000); //safety
	MST.DoKeys(szDLLs,TRUE);
	Sleep(1000); //safety
	MST.DoKeys("{TAB}",FALSE, 1000); //switch focus away
	MST.WButtonClick(GetLabel(IDOK));
	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COProject::RemoveAdditionalDLLs(int iDll)
// Description: Remove a dll from the Additional Dlls list.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: int iDll - An integer specifying which dll in the list to remove.
// END_HELP_COMMENT
int COProject::RemoveAdditionalDLLs(int iDll)
{
	const char* const THIS_FUNCTION = "COProject::RemoveAdditionalDLLs";

	VERIFY_VALID_PROJECT("Unable to remove additional DLLs.")

	UIWB.DoCommand(IDM_PROJECT_SETTINGS, DC_MNEMONIC);
	UITabbedDialog uitd;
	uitd.AttachActive();

	// TODO (michma): this function cannot work until it is
	// able to select the targets for which it wants to load dlls.
	// when more than one target platform is selected,
	// the dll list is disabled.

	// show debug page and select dll category	
	uitd.ShowPage(GetLocString(IDSS_TB_DEBUG));
	MST.WComboItemClk("@1", "@2");

	MST.DoKeys("{TAB}",FALSE, 1000); //switch focus to the custom conrol
	Sleep(1000); //safety
	
	// cursor down to the dll we are removing.
	for(int i = 1; i < iDll; i++)
		MST.DoKeys("{DOWN}");

	// remove the dll.
	MST.DoKeys("{DEL}");
	Sleep(1000); //safety
	MST.DoKeys("{TAB}",FALSE, 1000); //switch focus away
	MST.WButtonClick(GetLabel(IDOK));
	return ERROR_SUCCESS;
	}


// emmang@xbox
// BEGIN_HELP_COMMENT
// Function: int COProject::SetLocateOtherDLLs(LPCSTR szDLLs)
// Description: Sets whether additional DLLs will be located when debugging this project.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: LPCSTR A pointer to a string that contains the name of the additional DLL to add.
// END_HELP_COMMENT
int COProject::SetLocateOtherDLLs(TOGGLE_TYPE choice)
{
	/*
	const char* const THIS_FUNCTION = "COProject::SetLocateOtherDLLs";

	VERIFY_VALID_PROJECT("Unable to set locate other DLLs.")

	UIWB.DoCommand(IDM_PROJECT_SETTINGS, DC_MNEMONIC);
	UITabbedDialog uitd;
	uitd.AttachActive();

	// TODO (michma): this function cannot work until it is
	// able to select the targets for which it wants to load dlls.
	// when more than one target platform is selected,
	// the dll list is disabled.

	// show debug page and select dll category	
	uitd.ShowPage(GetLocString(IDSS_TB_DEBUG));
	MST.WComboItemClk("@1", "@2");

	if (choice == TOGGLE_ON)
		MST.WCheckCheck("Try to locate other DLLs");
	else
		MST.WCheckUnCheck("Try to locate other DLLs");
	MST.WButtonClick(GetLabel(IDOK));
	return ERROR_SUCCESS;
	*/
	return SetProjProperty(CT_DEBUG, DBG_IDC_TRY_LOCATE_DLLS, (choice == TOGGLE_ON ? 1 : 0));
}


// BEGIN_HELP_COMMENT
// Function: CString COProject::GetRemoteTarget(void)
// Description: Get the project's remote path.
// Return: A CString that contains the project's remote path.
// END_HELP_COMMENT
CString COProject::GetRemoteTarget(void)
{
	const char* const THIS_FUNCTION = "COProject::GetRemoteTarget";

	VERIFY_VALID_PROJECT("Unable to get remote target.")

	UIWB.DoCommand(IDM_PROJECT_SETTINGS, DC_MNEMONIC);
	UITabbedDialog uitd;
	uitd.AttachActive();
	CString remote = uitd.GetOptionStr(VPROJ_IDC_REMOTE_TARGET,VPROJ_IDC_REMOTE_TARGET);
	MST.WButtonClick(GetLabel(IDOK));
	return remote;
	}


// BEGIN_HELP_COMMENT
// Function: int COProject::SetBuildCommand(LPCSTR command)
// Description: Set the build command if this project is an external project.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: LPCSTR A pointer to a string that contains the build command.
// Param: index The 1 based index of the configuration to choose.  0 (default) selects all configurations.
// END_HELP_COMMENT
int COProject::SetBuildCommand(LPCSTR command, int index /* = 0 */)
{
	const char* const THIS_FUNCTION = "COProject::SetBuildCommand";

	UIWB.DoCommand(IDM_PROJECT_SETTINGS, DC_MNEMONIC);
	UITabbedDialog uitd;
	uitd.AttachActive();
	if (index != 0)		// Make sure the configuration at the given index is selected.
	{
		char buf[5];
		wsprintf(buf, "@%d", index);
		MST.WListItemClk(buf, GetLocString(IDSS_LISTBOX_BUILD_SETTING_CFG));
	}
	uitd.SetOption(VPROJ_IDC_EXTOPTS_CMDLINE, VPROJ_IDC_EXTOPTS_CMDLINE, command);
	MST.WButtonClick(GetLabel(IDOK));
	return ERROR_SUCCESS;
	}

int ExecuteShellCMD(char *cmd, ...) {                   // Args should be char*, last one=NULL!
	va_list marker;
	int     retval;
	CString szCommand;
	char*   szTemp;
	CString szSYSTEMlog;

	va_start(marker, cmd);
	for (szTemp = cmd; szTemp != NULL; szTemp = va_arg(marker, char*))
		szCommand = (szCommand + szTemp) + " ";
	va_end( marker );

	GetTempFileName(".", "prj", 0, szSYSTEMlog.GetBuffer(MAX_PATH));
	szSYSTEMlog.ReleaseBuffer();
	switch (retval = system(szCommand + ">" + szSYSTEMlog + " 2>&1 ")) {
		case  0: if (errno!=ENOENT) return ERROR_SUCCESS;
		case -1:
			LOG->RecordFailure((LPCSTR) "system(\"%s\") failed.", (LPCSTR) szCommand);
			switch (errno) {
				case E2BIG:   LOG->RecordFailure((LPCSTR) "Argument list is too big"); break;
				case ENOENT:  LOG->RecordFailure((LPCSTR) "Command interpreter not found"); break;
				case ENOEXEC: LOG->RecordFailure((LPCSTR) "CMD interpreter has invalid format"); break;
				case ENOMEM:  LOG->RecordFailure((LPCSTR) "Not enough memory to run command"); break;
				default:      LOG->RecordFailure((LPCSTR) "errno=%d is not documented", errno); break;
			}
			break;
		default:LOG->RecordFailure((LPCSTR) "Returned %d=system(\"%s\")", retval, (LPCSTR) szCommand);
	}
	LOG->RecordTextFile(szSYSTEMlog, "System log");
	return ERROR_ERROR;
}


// BEGIN_HELP_COMMENT
// Function: int COProject::UpdateRemoteFile(LPCSTR local_file /*= NULL*/, TARGET_TYPE target /*= CURRENT_TARGET*/, PLATFORM_TYPE platform /*= PLATFORM_USER*/)
// Description: Update the remote file from the host machine to the remote machine.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: local_file A pointer to a string that contains the local filename of the file to transfer. This parameter is only used when PLATFORM_WIN32S_X86 is specified by the platform parameter. (Default value is NULL.)
// Param: target A value that indicates the target to set the remote path for: TARGET_WIN32_X86_DEBUG, TARGET_WIN32_X86_RELEASE, TARGET_MAC_68K_DEBUG, TARGET_MAC_68K_RELEASE, TARGET_MAC_PPC_DEBUG, TARGET_MAC_PPC_RELEASE, TARGET_USER, TARGET_CURRENT. (Default value is TARGET_CURRENT.)
// Param: platform A value that specifies the platform: PLATFORM_WIN32_X86, PLATFORM_WIN32S_X86, PLATFORM_WIN32_MIPS, PLATFORM_MAC_68K, PLATFORM_MAC_PPC. (Default value is PLATFORM_USER.)
// END_HELP_COMMENT
int COProject::UpdateRemoteFile(LPCSTR local_file /* NULL */,
								TARGET_TYPE target /* CURRENT_TARGET */,
								PLATFORM_TYPE platform /* PLATFORM_USER */)

{
	const char* const THIS_FUNCTION = "COProject::UpdateRemoteFile";

	VERIFY_VALID_PROJECT("Unable to update the remote file.")

	ASSERT(target == TARGET_CURRENT);       //todo: add support for changing target

	// GetUserTargetPlatforms() must only return 1 platform!
		
	PLATFORM_TYPE true_platform = (platform != PLATFORM_USER) ? platform :
								  (PLATFORM_TYPE)GetUserTargetPlatforms();
	
	switch(true_platform)
	
		{
		case PLATFORM_WIN32_X86:        // since the ide doesn't handle remote
		case PLATFORM_WIN32_MIPS:
		case PLATFORM_WIN32_ALPHA:
		case PLATFORM_WIN32S_X86:       // copies to win32/s machines, we must
									// be told what the local file name is.
			{
			ASSERT(local_file != NULL);
			CString remote_file = local_file;

			remote_file = gpConnec->GetUserRemoteSharePath(platform) +
						  remote_file.Right(remote_file.GetLength() -
											remote_file.ReverseFind('\\') - 1);

			// some debugees are part of the slm project so they
			// get copied to the win32/s machine as read-only.
			// however that causes subsequent copies to fail
			// which will invalidate the test if the debugee
			// really needs to be updated.
			
			SetFileAttributes(remote_file, FILE_ATTRIBUTE_NORMAL);
			CopyFile(local_file, remote_file, FALSE);
			break;
			}
																	

		case PLATFORM_MAC_68K:
		case PLATFORM_MAC_PPC:
			{
			UIWB.DoCommand(IDM_PROJECT_TOOL_MECR, DC_MNEMONIC);
			break;
			}

		default:
			{
			ASSERT(0);
			}
		}

	WaitUntilBuildDone(30);       // need 30 minutes to copy appwiz app to mac via serial.
	return VerifyBuild();        // ditto
	}


// BEGIN_HELP_COMMENT
// Function: int COProject::SetLocalTarget(LPCSTR localfile, LPCSTR config, DEFAULT_DBG_EXE_TYPE ddetDefaultDbgExe /* NO_DEFAULT_DBG_EXE */)
// Description: Set the name of the executable for debugging with this project.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: localfile A pointer to a string that contains the name of the executable for debugging. If this parameter is NULL, the ddetDefaultDbgExe parameter determines which local target is selected.
// Param: config A pointer to a string that contains the name of the configuration for which to set the local target. If this parameter is NULL (default), the default configuration is set. 
// Param: ddetDefaultDbgExe (optional) A DEFAULT_DBG_EXE_TYPE enum that specifies which default debug exe to use (DEFAULT_DEBUG_EXE_CONTAINER, DEFAULT_DBG_EXE_BROWSER). the default is NO_DEFAULT_DBG_EXE.
// END_HELP_COMMENT
int COProject::SetLocalTarget(LPCSTR localfile, LPCSTR config, DEFAULT_DBG_EXE_TYPE ddetDefaultDbgExe /* NO_DEFAULT_DBG_EXE */)
{
	
	// TODO (michma): this function should be using UIProjOptionsTabDlg for all the project settings manipulation.
	const char* const THIS_FUNCTION = "COProject::SetLocalTarget";

	VERIFY_VALID_PROJECT("Unable to set local target name.")

	UIWB.DoCommand(IDM_PROJECT_SETTINGS, DC_MNEMONIC);
	UIProjOptionsTabDlg uiProjOptDlg;
	uiProjOptDlg.Display();

	if(config)
	{
		// REVIEW(michma): why won't SelectTarget work? ShowPage (below) fails if we use it.
		//uiProjOptDlg.SelectTarget(config);
		uiProjOptDlg.GiveFocusToConfigList();
		MST.DoKeys(config);
		// this will give focus back to the settings side of the project settings dlg.
		MST.DoKeys("{TAB 2}");
	}
	
	if(!uiProjOptDlg.ShowPage(GetLocString(IDSS_TB_DEBUG)))
		
		{
		LOG->RecordInfo("WARNING in COProject::SetLocalTarget: "
						"could not find page \"%s\" in dialog", 
						(LPCSTR)GetLocString(IDSS_TB_DEBUG));

		MST.DoKeys("{ESC}");
		return ERROR_ERROR;		
		}

	if(!MST.WComboItemExists("@1", GetLocString(IDSS_CATEGORY_GENERAL)))
		
		{
		LOG->RecordInfo("WARNING in COProject::SetLocalTarget: "
						"could not find category \"%s\" in page %s", 
						(LPCSTR)GetLocString(IDSS_CATEGORY_GENERAL),
						(LPCSTR)GetLocString(IDSS_TB_DEBUG));

		MST.DoKeys("{ESC}");
		return ERROR_ERROR;		
		}

	else
		MST.WComboItemClk("@1", 1);		// set category to General		

	if(!MST.WEditExists(GetLocString(IDSS_EXE_FOR_DBG_SESSION)))
		
		{
		LOG->RecordInfo("WARNING in COProject::SetLocalTarget: "
						"could not find edit field \"%s\" in category \"%s\" of page \"%s\"", 
						(LPCSTR)GetLocString(IDSS_EXE_FOR_DBG_SESSION), 
						(LPCSTR)GetLocString(IDSS_CATEGORY_GENERAL),
						(LPCSTR)GetLocString(IDSS_TB_DEBUG));

		MST.DoKeys("{ESC}");
		return ERROR_ERROR;		
		}

	// if a literal file is specified, enter it.
	if(localfile)
		MST.WEditSetText("@1", localfile);
	// else select the default debug executable specified (either the test container or the internet browser).
	else
	{
		// the button (an arrow button) for this pop-up menu is the first "Button" on the page.
		MST.WButtonClick("@1");
		// select the default debug exe specified (the DEFAULT_DBG_EXE_TYPE is mapped accordingly)
		for(int i = 0; i < ddetDefaultDbgExe; i++)
			MST.DoKeys("{DOWN}");
		// commit the selection from the pop-up menu.
		MST.DoKeys("{ENTER}");
	}

	
	MST.WButtonClick(GetLocString(IDSS_OK));
	return uiProjOptDlg.WaitUntilGone(5000) ? ERROR_SUCCESS : ERROR_ERROR;
	}


// BEGIN_HELP_COMMENT
// Function: int COProject::SetOutputFile(LPCSTR localfile)
// Description: Set the location for the output executable.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: LPCSTR A pointer to a string that contains the location of the output executable.
// END_HELP_COMMENT
int COProject::SetOutputFile(LPCSTR localfile)
{
	const char* const THIS_FUNCTION = "COProject::SetOutputFile";

	VERIFY_VALID_PROJECT("Unable to set output file name.")

	UIWB.DoCommand(IDM_PROJECT_SETTINGS, DC_MNEMONIC);
	UITabbedDialog uitd;
	uitd.WaitAttachActive(1000);

	if(!uitd.ShowPage(GetLocString(IDSS_PROJSET_LINKER)))
		
		{
		LOG->RecordInfo("WARNING in COProject::SetOutputFile: "
						"could not find page \"%s\" in dialog", 
						(LPCSTR)GetLocString(IDSS_PROJSET_LINKER));

		MST.DoKeys("{ESC}");
		return ERROR_ERROR;		
		}

	if(!MST.WComboItemExists("@1", GetLocString(IDSS_CATEGORY_GENERAL)))
		
		{
		LOG->RecordInfo("WARNING in COProject::SetOutputFile: "
						"could not find category \"%s\" in page %s", 
						(LPCSTR)GetLocString(IDSS_CATEGORY_GENERAL),
					    (LPCSTR)GetLocString(IDSS_PROJSET_LINKER));

		MST.DoKeys("{ESC}");
		return ERROR_ERROR;		
		}

	else
		MST.WComboItemClk("@1", 1);		// set category to General		

	if(!MST.WEditExists(GetLocString(IDSS_OUTPUT_FILE)))
		
		{
		LOG->RecordInfo("WARNING in COProject::SetOutputFile: "
						"could not find edit field \"%s\" in category \"%s\" of page \"%s\"", 
						(LPCSTR)GetLocString(IDSS_OUTPUT_FILE), 
						(LPCSTR)GetLocString(IDSS_CATEGORY_GENERAL),
						(LPCSTR)GetLocString(IDSS_PROJSET_LINKER));

		MST.DoKeys("{ESC}");
		return ERROR_ERROR;		
		}

	MST.WEditSetText("@1", localfile);
	MST.WButtonClick(GetLocString(IDSS_OK));
	return uitd.WaitUntilGone(5000) ? ERROR_SUCCESS : ERROR_ERROR;
	}


// BEGIN_HELP_COMMENT
// Function: int COProject::ToggleBSCGeneration(TOGGLE_TYPE t)
// Description: Toggle automatic BSC Generation for the project (off by default).
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: TOGGLE_TYPE t specifies whether to turn automatic BSC off (TOGGLE_OFF) or on (TOGGLE_ON)
// END_HELP_COMMENT
int COProject::ToggleBSCGeneration(TOGGLE_TYPE t)

	{
	const char* const THIS_FUNCTION = "COProject::ToggleBSCGeneration";
	VERIFY_VALID_PROJECT("Unable to toggle bsc generation.")

	// bring up project settings dlg.
	UIWB.DoCommand(IDM_PROJECT_SETTINGS, DC_MNEMONIC);
	UITabbedDialog uitd;
	uitd.WaitAttachActive(1000);

	// select compiler page.
	if(!uitd.ShowPage(GetLocString(IDSS_PROJSET_CPLUSPLUS)))
		
		{
		LOG->RecordInfo("ERROR in COProject::ToggleBSCGeneration: "
						"could not find page \"%s\" in dialog", 
						(LPCSTR)GetLocString(IDSS_PROJSET_CPLUSPLUS));

		MST.DoKeys("{ESC}");
		return ERROR_ERROR;		
		}

	// verify general category exists.
	if(!MST.WComboItemExists("@1", GetLocString(IDSS_CATEGORY_GENERAL)))
		
		{
		LOG->RecordInfo("ERROR in COProject::ToggleBSCGeneration: "
						"could not find category \"%s\" in page %s", 
						(LPCSTR)GetLocString(IDSS_CATEGORY_GENERAL),
					    (LPCSTR)GetLocString(IDSS_PROJSET_CPLUSPLUS));

		MST.DoKeys("{ESC}");
		return ERROR_ERROR;		
		}

	else
		MST.WComboItemClk("@1", 1);		// set category to General		

	// verify "generate browse info" check-box exists.
	if(!MST.WCheckExists(GetLocString(IDSS_GENERATE_BROWSE_INFO)))
		
		{
		LOG->RecordInfo("ERROR in COProject::ToggleBSCGeneration: "
						"could not find check box \"%s\" in page \"%s\"", 
						(LPCSTR)GetLocString(IDSS_GENERATE_BROWSE_INFO),
						(LPCSTR)GetLocString(IDSS_PROJSET_CPLUSPLUS));

		MST.DoKeys("{ESC}");
		return ERROR_ERROR;		
		}

	// toggle check-box state.
	if(t == TOGGLE_ON)
		MST.WCheckCheck(GetLocString(IDSS_GENERATE_BROWSE_INFO));
	else
		MST.WCheckUnCheck(GetLocString(IDSS_GENERATE_BROWSE_INFO));

	// selet browser page.
	if(!uitd.ShowPage(GetLocString(IDSS_PROJSET_BROWSER)))
		
		{
		LOG->RecordInfo("ERROR in COProject::ToggleBSCGeneration: "
						"could not find page \"%s\" in dialog", 
						(LPCSTR)GetLocString(IDSS_PROJSET_BROWSER));

		MST.DoKeys("{ESC}");
		return ERROR_ERROR;		
		}

	// verify "Build browse info file" check-box exists.
	if(!MST.WCheckExists(GetLocString(IDSS_BUILD_BROWSE_INFO_FILE)))
		
		{
		LOG->RecordInfo("ERROR in COProject::ToggleBSCGeneration: "
						"could not find check box \"%s\" in page \"%s\"", 
						(LPCSTR)GetLocString(IDSS_BUILD_BROWSE_INFO_FILE),
						(LPCSTR)GetLocString(IDSS_PROJSET_BROWSER));

		MST.DoKeys("{ESC}");
		return ERROR_ERROR;		
		}

	// toggle check-box state.
	if(t == TOGGLE_ON)
		MST.WCheckCheck(GetLocString(IDSS_BUILD_BROWSE_INFO_FILE));
	else
		MST.WCheckUnCheck(GetLocString(IDSS_BUILD_BROWSE_INFO_FILE));
	
	// close project settings.
	MST.WButtonClick(GetLocString(IDSS_OK));
	uitd.WaitUntilGone(5000) ? ERROR_SUCCESS : ERROR_ERROR;

	// check to see if we get a msg about the project being read-only.
	if(MST.WFndWndWaitC(GetLocString(IDSS_PROJECT_IS_READ_ONLY), "Static", FW_PART, 3))
		{
		// if it's there, ok it and wait for it to disappear.
		MST.DoKeys("{ENTER}");	
		while(MST.WFndWndWaitC(GetLocString(IDSS_PROJECT_IS_READ_ONLY), "Static", FW_PART,1));
		}
		
	return ERROR_SUCCESS;	
	}

	// BEGIN_HELP_COMMENT
// Function: int COProject::SetDebugInfo(DEBUG_INFO_TYPE DebugInfo)
// Description: Select the debug info type (current target assumed).
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: DEBUG_INFO_TYPE DebugInfo specifies the debug info type to select (NO_DEBUG_INFO, LINE_NUMBERS_ONLY, C7_COMPATIBLE, PROGRAM_DATABASE, EC_PROGRAM_DATABASE)
// END_HELP_COMMENT
int COProject::SetDebugInfo(DEBUG_INFO_TYPE DebugInfo)

{
	const char* const THIS_FUNCTION = "COProject::SetDebugInfo";
	VERIFY_VALID_PROJECT("Unable to set debug info.")

	// bring up project settings dlg.
	UIWB.DoCommand(IDM_PROJECT_SETTINGS, DC_MNEMONIC);
	UITabbedDialog uitd;
	uitd.WaitAttachActive(1000);

	// select compiler page.
	if(!uitd.ShowPage(GetLocString(IDSS_PROJSET_CPLUSPLUS)))
		
	{
		LOG->RecordInfo("ERROR in COProject::SetDebugInfo: "
						"could not find page \"%s\" in dialog", 
						(LPCSTR)GetLocString(IDSS_PROJSET_CPLUSPLUS));

		MST.DoKeys("{ESC}");
		return ERROR_ERROR;		
	}

	// verify general category exists.
	if(!MST.WComboItemExists("@1", GetLocString(IDSS_CATEGORY_GENERAL)))
		
	{
		LOG->RecordInfo("ERROR in COProject::SetDebugInfo: "
						"could not find category \"%s\" in page %s", 
						(LPCSTR)GetLocString(IDSS_CATEGORY_GENERAL),
					    (LPCSTR)GetLocString(IDSS_PROJSET_CPLUSPLUS));

		MST.DoKeys("{ESC}");
		return ERROR_ERROR;		
	}

	else
		MST.WComboItemClk("@1", 1);		// set category to General		

	// select the specified debug info option.
	MST.WComboItemClk("@4", DebugInfo);
	// close project settings.
	MST.WButtonClick(GetLocString(IDSS_OK));
	uitd.WaitUntilGone(5000) ? ERROR_SUCCESS : ERROR_ERROR;

	// check to see if we get a msg about the project being read-only.
	if(MST.WFndWndWaitC(GetLocString(IDSS_PROJECT_IS_READ_ONLY), "Static", FW_PART, 3))
	{
		// if it's there, ok it and wait for it to disappear.
		MST.DoKeys("{ENTER}");	
		while(MST.WFndWndWaitC(GetLocString(IDSS_PROJECT_IS_READ_ONLY), "Static", FW_PART,1));
	}
		
	return ERROR_SUCCESS;	
}


// BEGIN_HELP_COMMENT
// Function: int COProject::SetCustomBuildOptions(LPCSTR szDescription, CStringArray &cstrArrayBuildCmds, CStringArray &cstrArrayOutputFiles, ConfigStrArray &csArrayConfigs)
// Description: Set the custom build options (including description, build commands, and output files) for one or more projects or files.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szDescription A pointer to a string that contains the custom build description.
// Param: cstrArrayBuildCmds A reference to a CStringArray that contains the list of custom build commands.
// Param: cstrArrayOutputFiles A reference to a CStringArray that contains the list of custom output files.
// Param: csArrayConfigs A reference to a ConfigStrArray  that contains a list of configurations in the project settings dlg. the specified custom options will be applied to those configurations. 
// END_HELP_COMMENT
int COProject::SetCustomBuildOptions(LPCSTR szDescription, 
									 CStringArray &cstrArrayBuildCmds,
									 CStringArray &cstrArrayOutputFiles,
									 ConfigStrArray &csArrayConfigs)

	{
	const char* const THIS_FUNCTION = "COProject::SetCustomBuildOptions";
	VERIFY_VALID_PROJECT("Unable to set custom build options.")
	// dummy file list.
	CStringArray cstrArrayFiles;

	return SetCustomBuildOptions(szDescription, cstrArrayBuildCmds, cstrArrayOutputFiles, 
								 csArrayConfigs, cstrArrayFiles);
	}


// BEGIN_HELP_COMMENT
// Function: int COProject::SetCustomBuildOptions(LPCSTR szDescription, CStringArray &cstrArrayBuildCmds, CStringArray &cstrArrayOutputFiles, ConfigStrArray &csArrayConfigs, CStringArray &cstrArrayFiles, int intConfigInclusion = INCLUDE_CONFIG_LEVEL)
// Description: Set the custom build options (including description, build commands, and output files) for one or more projects or files.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szDescription A pointer to a string that contains the custom build description.
// Param: cstrArrayBuildCmds A reference to a CStringArray that contains the list of custom build commands.
// Param: cstrArrayOutputFiles A reference to a CStringArray that contains the list of custom output files.
// Param: csArrayConfigs A reference to a ConfigStrArray  that contains a list of configurations in the project settings dlg. the specified custom options will be applied to those configurations. 
// Param: cstrArrayFiles A reference to a CStringArray that contains a list of files inside configurtaions in the project settings dlg. the specified custom options will be applied to those files of the specified configurations.  
// Param: intConfigInclusion An int value indicating whether or not to apply the custom build settings at the configuration level as well as the file level (INCLUDE_CONFIG_LEVEL or EXCLUDE_CONFIG_LEVEL). the default is INCLUDE_CONFIG_LEVEL.
// END_HELP_COMMENT
int COProject::SetCustomBuildOptions(LPCSTR szDescription, 
									 CStringArray &cstrArrayBuildCmds,
									 CStringArray &cstrArrayOutputFiles,
									 ConfigStrArray &csArrayConfigs, 
									 CStringArray &cstrArrayFiles,
									 int intConfigInclusion /* INCLUDE_CONFIG_LEVEL */)

	{
	const char* const THIS_FUNCTION = "COProject::SetCustomBuildOptions";
	VERIFY_VALID_PROJECT("Unable to set custom build options.")

 	// bring up the project settings dlg.
	if(m_uPrjOptDlg.Display() == NULL)
		
		{
		LOG->RecordInfo("ERROR in %s: could not open \"%s\" dlg.", 
						THIS_FUNCTION, GetLocString(IDSS_PROJ_OPTIONS_TITLE));

		// just in case the wrong dlg came up.
		MST.DoKeys("{ESC}");
		return ERROR_ERROR;		
		}

	// get total number of configs listed in project settings.
	int intTotalConfigs = MST.WListCount("@1");
	// we'll delete files from the temp list as we process them.
	CStringArray cstrArrayFilesTmp;
	// gets the number of files displayed for a configuration in the project settings dlg.
	int intTotalFiles;
	// gets the "Input File:" name displayed in the custom build settings page.
	CString cstrInputFile;
	// gets the index of the backslash character in the "Input File:" name.
	int intIndexBackslash;
	// various "for" loop counters.
	int i, f, j;

	// loop through each of the specified configurations.
	for(int c = 0; c < csArrayConfigs.GetSize(); c++)

		{
		// select the configuration.
		m_uPrjOptDlg.SelectTarget(csArrayConfigs[c].GetString());

		// if specified, apply custom build settings to configuration level.
		if(intConfigInclusion == INCLUDE_CONFIG_LEVEL)

			{
			// select custom build settings page.
			if(!m_uPrjOptDlg.ShowPage(GetLocString(IDSS_PROJSET_CUSTBUILD)))
				
				{
				LOG->RecordInfo("ERROR in %s: could not find page \"%s\" for configuration %s.", 
								THIS_FUNCTION, GetLocString(IDSS_PROJSET_CUSTBUILD), 
								csArrayConfigs[c].GetString());

				m_uPrjOptDlg.Cancel();
				return ERROR_ERROR;		
				}

			// set the description, build command, and output file options for the configuration.
			if(SetCustomBuildOptionsCore(szDescription, cstrArrayBuildCmds, cstrArrayOutputFiles) == ERROR_ERROR)
				
				{
				LOG->RecordInfo("ERROR in %s: could not set options for configuration \"%s\".", 
								THIS_FUNCTION, csArrayConfigs[c].GetString());

				m_uPrjOptDlg.Cancel();
				return ERROR_ERROR;		
				}
			}

		// apply custom settings to any specified files in the configuration.
		if(cstrArrayFiles.GetSize() > 0)

			{
			// expand the configuration to reveal the files.
			m_uPrjOptDlg.ExpandConfig();						
			// the config list box item count should go up by the number of files in the config. 
			intTotalFiles = MST.WListCount("@1") - intTotalConfigs;
				
			// verify we have some files to process. 
			if(intTotalFiles == 0)
				{
				LOG->RecordInfo("ERROR in %s: could not expand configuration \"%s\".",
								 THIS_FUNCTION, csArrayConfigs[c].GetString());

				m_uPrjOptDlg.Cancel();
				return ERROR_ERROR;		
				}

			// load up the temp array used to keep track of which files have been processed.
			for(i = 0; i < cstrArrayFiles.GetSize(); i++)
				cstrArrayFilesTmp.Add(cstrArrayFiles[i]);

			// loop through each of the displayed files.
			for (i = 0; i < intTotalFiles; i++)
				
				{
				// select the next file in the configuration.
				m_uPrjOptDlg.GiveFocusToConfigList();
				MST.DoKeys("{DOWN}");

				// verify we can select the custom build settings page for this file. if not, skip to next.
				if(m_uPrjOptDlg.ShowPage(GetLocString(IDSS_PROJSET_CUSTBUILD)))
					
					{
					// get the "Input File:" string for the file.
					MST.WStaticText("@2", cstrInputFile);
					// find the backslash in the "Input File:" string.				
					intIndexBackslash = cstrInputFile.Find("\\");
					
					// verify that we found a backslash.
					if(intIndexBackslash < 0)

						{ 
						LOG->RecordInfo("ERROR in %s: no backslash found in \"Input File:\" string \"%s\".",
										 THIS_FUNCTION, cstrInputFile);

						m_uPrjOptDlg.Cancel();
						return ERROR_ERROR;		
						}

					// extract just the filename from the "Input File:" string (to the right of the backslash).
					cstrInputFile = cstrInputFile.Mid(cstrInputFile.Find("\\") + 1); 

					// loop through each of the unprocessed, specified files.
					for(f = 0; f < cstrArrayFilesTmp.GetSize(); f++)
						
						{
						// check if the "Input File:" file matches a specified file.
						if(cstrArrayFilesTmp[f] == cstrInputFile)
							
							{
							// set the description, build command, and output file options for the file.
							if(SetCustomBuildOptionsCore(szDescription, cstrArrayBuildCmds, cstrArrayOutputFiles) == ERROR_ERROR)
								
								{
								LOG->RecordInfo("ERROR in %s: could not set options for file \"%s\" in "
												"configuration %s", THIS_FUNCTION, cstrArrayFilesTmp[f],
												csArrayConfigs[c].GetString());

								m_uPrjOptDlg.Cancel();
								return ERROR_ERROR;		
								}

							// the specified file has been processed so remove it from the list.
							cstrArrayFilesTmp.RemoveAt(f);
							break;
							}
						}
					}

				// if all the specified files have been processed, 
				// then skip the rest of the files listed in the dlg. 
				if(cstrArrayFilesTmp.GetSize() == 0)
					break;
				}
			
			// check if we didn't find all the specified files in those listed in the dlg.
			if(cstrArrayFilesTmp.GetSize() > 0)
				
				{
				LOG->RecordInfo("ERROR in %s: could not find all specified files in configuration \"%s\"."								"configuration %s", THIS_FUNCTION, cstrArrayFilesTmp[f],
								THIS_FUNCTION, csArrayConfigs[c].GetString());

				m_uPrjOptDlg.Cancel();
				return ERROR_ERROR;		
				}

			// give focus back to configuration list.
			m_uPrjOptDlg.GiveFocusToConfigList();

			// navigate back up to the configuration level.	"i" was incremented for each key DOWN we did
			// except for the one that selected the last specified file to be processed.
			for(j = 0; j < (i + 1); j++)
				MST.DoKeys("{UP}");

			// collapse the configuration.
			m_uPrjOptDlg.CollapseConfig();						

			// the config list box item count should return to the number of configs displayed. 
			if(MST.WListCount("@1") != intTotalConfigs)
				
				{
				LOG->RecordInfo("ERROR in %s: could not collapse configuration \"%s\".",
								 THIS_FUNCTION, csArrayConfigs[c].GetString());

				m_uPrjOptDlg.Cancel();
				return ERROR_ERROR;		
				}
			}
		}

	//m_uPrjOptDlg.OK();
	// VERY CHEESY WORK ARROUND
	// Clickin OK on JPN will fail the test
	// But there is nothing wrong with the app.
	MST.DoKeys("{TAB}");
	MST.DoKeys("{TAB}");
	MST.DoKeys("{TAB}");
	MST.DoKeys("{ENTER}");

	return ERROR_SUCCESS;
	}


int COProject::SetCustomBuildOptionsCore(LPCSTR szDescription, 
										 CStringArray &cstrArrayBuildCmds,
										 CStringArray &cstrArrayOutputFiles)

	{
	const char* const THIS_FUNCTION = "COProject::SetCustomBuildOptionsCore";

	// set the description.
	MST.WEditSetText("@1", szDescription);
	// set the build commands.
	CString Alt = "%" ;
	Alt += ExtractHotKey(GetLocString(IDS_BUILDCOMMANDS));
  	SetCustomBuildLists(Alt.GetBuffer(Alt.GetLength()), cstrArrayBuildCmds);
	// set the output files.
	Alt = "%";
	Alt += ExtractHotKey(GetLocString(IDS_OUTPUTFILE));

	SetCustomBuildLists(Alt.GetBuffer(Alt.GetLength()), cstrArrayOutputFiles);

	return ERROR_SUCCESS;
	}


void COProject::SetCustomBuildLists(LPCSTR szListAccel, CStringArray &cstrArrayList)
	
	{
	// give focus to the edit box
	MST.DoKeys(szListAccel);

	// delete current contents
	MST.DoKeys("{DELETE}^c");

	// enter each of the new items.
	CString csBarfItIn("");
	for(int i = 0; i < cstrArrayList.GetSize(); i++)
		{
		csBarfItIn += cstrArrayList[i] + CString("\r\n");
		}
	MST.WEditSetText("", csBarfItIn);
	}


// BEGIN_HELP_COMMENT
// Function: int COProject::SetOutputTarget(LPCSTR outfile)
// Description: Set the name of the output target when this project is an external project.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: outfile A pointer to a string that contains the name of the output filename.
// END_HELP_COMMENT
int COProject::SetOutputTarget(LPCSTR outfile)
{
	const char* const THIS_FUNCTION = "COProject::SetOutputTarget";

	VERIFY_VALID_PROJECT("Unable to set output target name.")

	UIWB.DoCommand(IDM_PROJECT_SETTINGS, DC_MNEMONIC);
	UITabbedDialog uitd;
	uitd.AttachActive();
	uitd.SetOption(VPROJ_IDC_EXTOPTS_TARGET, VPROJ_IDC_EXTOPTS_TARGET, outfile);
	MST.WButtonClick(GetLabel(IDOK));
	return ERROR_SUCCESS;
	}

// BEGIN_HELP_COMMENT
// Function: HWND COProject::AppWizard(int bSaveChanges /*= FALSE*/)
// Description: Bring up the AppWizard (New Project) dialog.
// Return: The HWND of the AppWizard (New Project) dialog.
// Param: bSaveChanges A Boolean value that specifies whether to save the dirty files before closing them. (Default value is FALSE.)
// END_HELP_COMMENT
// this function is taken directly from uwbframe.cpp because it does not belong there
HWND COProject::AppWizard(int bSaveChanges /*=FALSE*/)
{
	const char* const THIS_FUNCTION = "COProject::AppWizard";

//	DWORD dwProcessId;

	ActivateProjWnd();

	UINewFileDlg nwFlDlg ;
	
	nwFlDlg.Display() ;
	nwFlDlg.NewProjectTab() ;
	WaitForInputIdle(g_hTargetProc, 60000);

//	nwFlDlg.SelectFromList(GetLocString(IDSS_NEW_PROJECT));
	
	/* UIWB.DoCommand(ID_FILE_NEW, DC_MNEMONIC);   // cannot use CreateNewFile, because that checks for new MDI child

	UIDialog nd(0x64, GL_LISTBOX);      // AFX_IDC_LISTBOX?
//  (GetLocString(IDSS_NEW_TITLE));
	if( !nd.WaitAttachActive(1000) )
	{
		LOG->RecordInfo("%s: could not open the File/New dialog. Unable to start AppWizard.", THIS_FUNCTION);
		MST.DoKeys("{ESC 5}") ;
		return NULL;
	}

	MST.WListItemClk("", GetLocString(IDSS_NEW_PROJECT));
    */
	//nd.OK();
/*	MST.WButtonClick(GetLabel(IDOK)) ;

	// get the process ID of UIWB
	GetWindowThreadProcessId(UIWB.HWnd(), &dwProcessId);
	// wait until we don't get any Save Changes? message boxes
	for (int i = 0; i < 20; i++) {
		// 8 is the Yes button
		if (WaitForSingleControl(dwProcessId, 8, 500) == WAIT_CONTROL_0) {
			if (bSaveChanges) {
				// click Yes
				MST.WButtonClick(GetLabel(8));
			}
			else {
				// click No
				MST.WButtonClick(GetLabel(9));
			}
		}
		else {
			break;
		}
	}

	// too many Save Changes? message boxes
	if (i >= 20) {
		LOG->RecordInfo("%s: detected more than 20 Save Changes? message boxes when creating new project. Unable to start AppWizard.", THIS_FUNCTION);
		return NULL;
	}

	// wait for the new project dialog to be displayed
	if (WaitForSingleControl(dwProcessId, VPROJ_IDC_WORKSPACE_NAME, 10000) != WAIT_CONTROL_0) {
		LOG->RecordInfo("%s: cannot find the New Project dialog (WaitForSingleControl timed out). Unable to start AppWizard.", THIS_FUNCTION);
		return NULL;
	}

	// attach to the new project dialog
	UIAppWizard uaw;
	if (!uaw.WaitAttachActive(2000)) {
		// Cancel out of the dialog and exit.
		LOG->RecordInfo("%s: could not open the New Project dialog (UIAppWizard::WaitAttachActive failed). Unable to start AppWizard.", THIS_FUNCTION);
		MST.DoKeys("{ESC 3}");
		return NULL;
	}
	  */
	Sleep(500) ;
	UIAppWizard uaw = MST.WGetActWnd(0)	;

	return uaw;
}


// BEGIN_HELP_COMMENT
// Function: HWND COProject::CreateNewProject(LPCSTR szProjName, PROJTYPE ProjType, LPCSTR szDir, LPCSTR szNewSubDir, int ProjFileOpt, LPCSTR szProjFilesPath, LPCSTR szRemotePath, LPCSTR szRemoteFile)
// Description: This function creates a new project.
// Return: The HWND of the workspace window.
// Param: szProjName - Name of project to create.
// Param: ProjType - Type of project.  UIAW_PT_APPWIZ, etc.
// Param: szDir - Directory in which to create the project.
// Param: szNewSubDir - Further subdirectory specifier for project.  Based off of szDir.
// Param: ProjFileOpt - Not currently used.
// Param: szProjFilesPath - Not currently used.
// Param: szRemotePath - Not currently used.
// Param: szRemoteFile - Not currently used.
// END_HELP_COMMENT
HWND COProject::CreateNewProject(LPCSTR szProjName, 
								PROJTYPE ProjType,
								LPCSTR szDir /* NULL */,
								LPCSTR szNewSubDir /* NULL */,
				/* Not used */	int ProjFileOpt /* 0 */,
				/* Not used */	LPCSTR szProjFilesPath /* NULL */,
				/* Not used */	LPCSTR szRemotePath /* NULL */,
				/* Not used */	LPCSTR szRemoteFile /* NULL */)

{
	const char* const THIS_FUNCTION = "COProject::CreateNewProject";

	// REVIEW(briancr):why is all the AppWizard work done at this level?
	// Shouldn't the AppWz class traverse the AppWizard pages as the
	// caller sets attributes of the wizard?

	EXPECT(UIWB.IsValid() & UIWB.IsActive());
	UIWB.DeleteProject(szProjName, szDir);          

	CString DirPath  = szDir ;
	UIAppWizard uaw = AppWizard();

	uaw.SetProjType(ProjType) ;

	if( szDir != NULL && *szDir != '\0')
		uaw.SetDir(DirPath);

	if( szNewSubDir != NULL && *szNewSubDir != '\0')
	{                       
		if (szNewSubDir[0] == '\\' || (strlen(szNewSubDir) > 1 && szNewSubDir[1] == ':'))
			LOG->RecordInfo("%s: Illegal subdirectory specified for new project: %s", THIS_FUNCTION, szNewSubDir);
		else
			uaw.SetSubDir(szNewSubDir);
	}

	uaw.SetName(szProjName) ;
	
	uaw.Create();

	// create a new AppWizard EXE project
	if (ProjType == UIAW_PT_APPWIZ)   // Just handles the default AppWizard project.
	{  // This will create a default AppWizard application.
		UIWindow uiMsgbox  ;
		if (!UIWB.WaitOnWndWithCtrl(APPWZ_IDC_RADIO1,2000))
		{
			LOG->RecordInfo("%s: could not find the first AppWizard EXE page. Unable to create new project.", THIS_FUNCTION);
			 // Cancel out of the dialog and exit.
			 MST.DoKeys("{ESC 5}") ;
			 return NULL ;
		}
		MST.WButtonClick(GetLabel(APPWZ_IDC_END)) ;
		if (!UIWB.WaitOnWndWithCtrl(APPWZ_IDC_OUTPUT,2000))
		{
			LOG->RecordInfo("%s: could not find the summary AppWizard EXE page. Unable to create new project.", THIS_FUNCTION);
			 MST.DoKeys("{ESC 5}") ;
			 return NULL ;
		}

		MST.WButtonClick(GetLabel(IDOK))  ;
		uiMsgbox.AttachActive() ;
		Sleep(1500) ; // Shouldn't take that long. REVIEW(Ivan) shaky ..
	}
	// create a new AppWizard DLL project
	else if(ProjType ==UIAW_PT_APPWIZ_DLL)   // Just handles the default AppWizard project.
	{  // This will create a default AppWizard application.
		UIWindow uiMsgbox  ;
		if (!UIWB.WaitOnWndWithCtrl(APPWZ_IDC_RADIO3,2000))
		{
			LOG->RecordInfo("%s: could not find the first AppWizard DLL page. Unable to create new project.", THIS_FUNCTION);
			 // Cancel out of the dialog and exit.
			 MST.DoKeys("{ESC 5}") ;
			 return NULL ;
		}
		MST.WButtonClick(GetLabel(IDOK)) ;
		if (!UIWB.WaitOnWndWithCtrl(APPWZ_IDC_OUTPUT,2000))
		{
			LOG->RecordInfo("%s: could not find the summary AppWizard DLL page. Unable to create new project.", THIS_FUNCTION);
			 MST.DoKeys("{ESC 5}") ;
			 return NULL ;
		}

		MST.WButtonClick(GetLabel(IDOK))  ;
		uiMsgbox.AttachActive() ;
		Sleep(1500) ; // Shouldn't take that long. REVIEW(Ivan) shaky ..
		return MST.WGetActWnd(0) ;
	}
	// create a new project
	else {
		WaitForInputIdle(g_hTargetProc, 60000);
	}

	// bring up the project window
	NewProjectWindow();

	// return the HWND of the project window
	return *(GetProjectWindow());
}

UIWorkspaceWindow* COProject::NewProjectWindow(void)
{
	// delete any existing project window
	DeleteProjectWindow();

	ActivateProjWnd();		// Make sure the window is visible.

	m_pProjWnd = new UIWorkspaceWindow;
	m_hWnd = *m_pProjWnd;

	return m_pProjWnd;
}

BOOL COProject::DeleteProjectWindow(void)
{
	delete m_pProjWnd;
	m_pProjWnd = NULL;
	m_hWnd = NULL;

	return TRUE;
}

UIWorkspaceWindow* COProject::GetProjectWindow(void)
{
	return m_pProjWnd;
}

BOOL COProject::IsOpen(void)
{
	return (m_pProjWnd != NULL);
}

// BEGIN_HELP_COMMENT
// Function: HWND COProject::VerifyClasses(LPCSTR pszBaseLineFile)
// Description: This function creates a
// Param: pszBaseLineFile - Name of file containing 
// END_HELP_COMMENT
void COProject::VerifyClasses(LPCSTR pszBaseLineFile)
{
    CClassInfo infoClass;
	CGlobalInfo infoGlobal;
    BOOL bFoundOne = FALSE;

    try
    {
        CStdioFile fileVerify(pszBaseLineFile, CFile::modeRead | CFile::typeText);

	    const int len=100;
		char buf[len];
	    CString str("");

		// Type of object comes first.
		while (fileVerify.ReadString(buf, len))
		{
			// Get a line from the file.
			str = strtok(buf, "\n\r");
			TrimString(&str);

			if (!str.IsEmpty() && str.GetAt(0) != ';')	// If we got something and it wasn't a comment...
			{
				// Get the rest of this thing's info...
				if (strstr(buf, "class "))
				{
					infoClass.ClearAll();
					infoClass.m_strName = strchr(buf, ' ') + 1;
					TrimString(&infoClass.m_strName);
					GetClassInfo(fileVerify, &infoClass);
					VerifySingleClass(infoClass);
				}
				else if (strstr(buf, "global"))
				{
					
					infoGlobal.ClearAll();
					infoGlobal.m_strName = strchr(buf, ' ') + 1;
					TrimString(&infoGlobal.m_strName);

					if (strstr(buf, "globalfunc"))
						infoGlobal.m_Type = CGlobalInfo::FUNCTION;
					else
						infoGlobal.m_Type = CGlobalInfo::DATA;

					GetGlobalInfo(fileVerify, &infoGlobal);
					VerifySingleGlobal(infoGlobal);
				}
			}
		}
    } 
    catch(CFileException *e)
    {
        if(e->m_cause != CFileException::endOfFile)
        {
            CFileStatus status;
            if (CFile::GetStatus(pszBaseLineFile, status))
				LOG->RecordFailure("Couldn't read the file: %s", status.m_szFullName);
			else
				LOG->RecordFailure("Couldn't find the file: %s", pszBaseLineFile);
        }
    }
}

void COProject::GetClassInfo(CStdioFile& file, CClassInfo *pInfo)
{
    CString str("");
    const int len=100;
    char buf[len];

    // Now get rest of information, if any.
    CString strDelimiter("***");
    BOOL bDone = FALSE;

    while (!bDone && file.ReadString(buf, len))
    {
        str = buf;
        TrimString(&str);

        if (!str.IsEmpty() && str.GetAt(0) != ';')
        {
            if (str == strDelimiter)
                bDone = TRUE;
            else if (str.Find("base") > -1)
            {
                pInfo->m_strBase = strtok(buf, ";");
                TrimString(&pInfo->m_strBase);
            }
			else if (str.Find("mf") == 0 || str.Find("md") == 0)
			{
				CMemberInfo* pNew = new CMemberInfo();
				strtok(buf, ";");
				pNew->m_strDataType = strtok(NULL, ";");
				pNew->m_strName	= strtok(NULL, ";");
				TrimString(&pNew->m_strDataType);
				TrimString(&pNew->m_strName);

				CString strAccess = strtok(NULL, ";");	
				TrimString(&strAccess);
				if (!strcmp("private", strAccess))
					pNew->m_Access = CMemberInfo::PRIVATE;
				else if (!strcmp("public", strAccess))
					pNew->m_Access = CMemberInfo::PUBLIC;
				else if (!strcmp("protected", strAccess))
					pNew->m_Access = CMemberInfo::PROTECTED;

				pNew->m_Type = str.GetAt(1) == 'd'? CMemberInfo::DATA: CMemberInfo::FUNCTION;
				pInfo->m_listMembers.AddTail(pNew);
			}
        }
    }
}

void COProject::GetGlobalInfo(CStdioFile& file, CGlobalInfo *pInfo)
{
    CString str("");
    const int len=100;
    char buf[len];

    // Now get rest of information, if any.
    CString strDelimiter("***");
    BOOL bDone = FALSE;

    while (!bDone && file.ReadString(buf, len))
    {
        str = buf;
        TrimString(&str);

        if (!str.IsEmpty() && str.GetAt(0) != ';')
        {
            if (str == strDelimiter)
                bDone = TRUE;
        }
    }
}


void COProject::VerifySingleClass(const CClassInfo& info)
{
	const char* const THIS_FUNCTION = "COProject::VerifySingleClass";

	BOOL bFound = FALSE;	// Has a class member been found?  Used to determine if a shortcut can be taken.
	int status;				// Return status of Select... functions.

    LOG->RecordInfo("Checking class: %s", info.GetName());

	UIWorkspaceWindow wnd;

	BOOL bFindMoreMembers = TRUE;	// Should additional members be searched for?

	// Verify existence of any member functions/data.
	POSITION pos = info.m_listMembers.GetHeadPosition();
	while(bFindMoreMembers)
	{
		wnd.ActivateClassPane();

		CMemberInfo* pMember;		// Only used if the current class has members.
		 
		if (pos == NULL)
			status = wnd.GotoClassDefinition(info.GetName(), NULL, GetName());		// Class has no members specified, so just check for class.
		else
		{
			pMember = info.m_listMembers.GetAt(pos);		// Class has members.

			if (bFound == FALSE)
				 status = wnd.GotoClassMemberDefinition(pMember->GetName(), 
											  pMember->GetType() == CMemberInfo::FUNCTION? UIWorkspaceWindow::Function : UIWorkspaceWindow::Data,
											  NULL,
											  info.GetName(),
											  GetName());
			else	// Shortcut...
			{
				MST.DoKeys("{left 2}");	// Get back to class name and force collapse, otherwise, first members might not be found.				
				status = wnd.GotoClassMemberDefinition(pMember->GetName(),
											 pMember->GetType() == CMemberInfo::FUNCTION? UIWorkspaceWindow::Function : UIWorkspaceWindow::Data,
											 NULL);
			}
		}

		switch(status)
		{
			case ERROR_NO_MEMBER:
				if (pMember->GetType() == CMemberInfo::FUNCTION)
					LOG->RecordFailure("Couldn't find member function %s::%s() in Class View", info.GetName(), pMember->GetName());
				else
					LOG->RecordFailure("Couldn't find data member %s::%s in Class View", info.GetName(), pMember->GetName());
				bFound = FALSE;
			break;

			case ERROR_NO_CLASS:
				LOG->RecordFailure("Couldn't find class %s in the ClassView.", info.GetName());
				bFindMoreMembers = FALSE;
			break;

			case ERROR_NO_PROJECT:
				LOG->RecordFailure("Couldn't find project %s in the ClassView.", GetName());
				bFindMoreMembers = FALSE;
			break;

			case ERROR_GOTO:
				if (pos == NULL)	// We were navigating to a class.
					LOG->RecordFailure("Navigation to wrong place for definition for class %s", info.GetName());
				else				// We were navigating to a class member.
					LOG->RecordFailure("Navigation to wrong place for definition for %s::%s", info.GetName(), pMember->GetName());
				bFound = TRUE;
			break;

			case ERROR_NO_DECLARATION:
				LOG->RecordFailure("ClassView reports that %s::%s has no declaration.", info.GetName(), pMember->GetName());
				bFound = TRUE;
			break;

			case ERROR_NO_DEFINITION:
				if (pos == NULL)	// We were navigating to a class.
					LOG->RecordFailure("ClassView reports that class %s has no definition.", info.GetName());
				else				// We were navigating to a class member.
					LOG->RecordFailure("ClassView reports that %s::%s has no definition.", info.GetName(), pMember->GetName());
				bFound = TRUE;
			break;

			case SUCCESS:
				if (pos != NULL)	// If we were successful navigating to a member definition, try to get to its declaration.
				{
					wnd.ActivateClassPane();

					if (pMember->GetType() == CMemberInfo::FUNCTION && 
						wnd.GotoDeclarationFromHere(pMember->GetName()) != SUCCESS)
						LOG->RecordFailure("Couldn't navigate to member declaration %s::%s", info.GetName(), pMember->GetName());
					bFound = TRUE;
				}

			break;

			default:
				LOG->RecordFailure("%s:  An error occurred in UIWorkspaceWindow::GotoClassMemberDefinition()", THIS_FUNCTION);
				bFindMoreMembers = FALSE;
			break;

		}

		if (pos == NULL)
			bFindMoreMembers = FALSE;

		if (bFindMoreMembers == TRUE)
			info.m_listMembers.GetNext(pos);

	}	// end while.
}

void COProject::VerifySingleGlobal(const CGlobalInfo& info)
{
	const char* const THIS_FUNCTION = "COProject::VerifySingleGlobal";

    LOG->RecordInfo("Checking global symbol: %s", info.GetName());

	UIWorkspaceWindow wnd;
	wnd.ActivateClassPane();

	switch(wnd.GotoGlobalDefinition(info.GetName(),
						  info.GetType() == CGlobalInfo::FUNCTION? UIWorkspaceWindow::Function: UIWorkspaceWindow::Data,
						  NULL,
						  GetName()))
	{
		case ERROR_NO_CLASS:
			LOG->RecordFailure("Couldn't find class %s in the ClassView.", info.GetName());
		break;

		case ERROR_NO_PROJECT:
			LOG->RecordFailure("Couldn't find project %s in ClassView.", GetName());
		break;

		case ERROR_GOTO:
			LOG->RecordFailure("Couldn't navigate to global definition for %s.", GetName());
		break;

		case SUCCESS:
		break;

		default:
			LOG->RecordFailure("%s:  An error occurred in UIWorkspaceWindow::GotoGlobalDefinition()", THIS_FUNCTION);
		break;
	}
}


ConfigStr::ConfigStr(LPCSTR szProj, PLATFORM_TYPE ptPlatform, BUILD_TYPE btBuild)
	{
	SetString(szProj, ptPlatform, btBuild);
	}


CString ConfigStr::SetProject(LPCSTR szProj)
	{
	m_cstrProj = szProj;
	return BuildString();
	}


CString ConfigStr::SetPlatform(PLATFORM_TYPE ptPlatform)
	{
	m_ptPlatform = ptPlatform;
	return BuildString();
	}


CString ConfigStr::SetBuild(BUILD_TYPE btBuild)
	{
	m_btBuild = btBuild;
	return BuildString();
	}


CString ConfigStr::SetString(LPCSTR szProj, PLATFORM_TYPE ptPlatform, BUILD_TYPE btBuild)
	{
	m_cstrProj = szProj;
	m_ptPlatform = ptPlatform;
	m_btBuild = btBuild;
	return BuildString();
	}


CString ConfigStr::BuildString(void)
	
	{
	CString cstrPlatform;
	CString cstrBuild;
	
	switch(m_ptPlatform)
		{
		case PLATFORM_WIN32_X86:
		case PLATFORM_WIN32S_X86:
		case PLATFORM_WIN32_MIPS:
		case PLATFORM_WIN32_ALPHA:
		case PLATFORM_WIN32_PPC:
			cstrPlatform = "Win32";
			break;
		case PLATFORM_MAC_68K:
			cstrPlatform = "Macintosh";
			break;
		case PLATFORM_MAC_PPC:
			cstrPlatform = "Power Macintosh";
			break;
		}

	switch(m_btBuild)
		{
		case BUILD_DEBUG:
			cstrBuild = "Debug";			
			break;
		case BUILD_RELEASE:
			cstrBuild = "Release";			
			break;
		}

	m_cstrConfig = m_cstrConfig = m_cstrProj + " - " + cstrPlatform + " " + cstrBuild;
	return m_cstrConfig;
	}


CString ConfigStrArray::Add(LPCSTR szProj, PLATFORM_TYPE ptPlatform, BUILD_TYPE btBuild)
	{
	m_configs.Add(new ConfigStr(szProj, ptPlatform, btBuild));
  	return ((ConfigStr *)(m_configs[m_configs.GetSize() - 1]))->GetString();
	}


CString ConfigStrArray::Add(ConfigStr &config_str)
	{
	m_configs.Add(new ConfigStr(config_str.GetProject(), config_str.GetPlatform(), config_str.GetBuild()));
  	return ((ConfigStr *)(m_configs[m_configs.GetSize() - 1]))->GetString();
	}


CString ConfigStrArray::InsertAt(int intIndex, LPCSTR szProj, PLATFORM_TYPE ptPlatform, BUILD_TYPE btBuild)
	{
	m_configs.InsertAt(intIndex, new ConfigStr(szProj, ptPlatform, btBuild));
  	return ((ConfigStr *)(m_configs[intIndex]))->GetString();
	}


CString ConfigStrArray::InsertAt(int intIndex, ConfigStr &config_str)
	
	{
	m_configs.InsertAt(intIndex, new ConfigStr(config_str.GetProject(), 
											   config_str.GetPlatform(),
											   config_str.GetBuild()));

  	return ((ConfigStr *)(m_configs[intIndex]))->GetString();
	}


ConfigStr ConfigStrArray::operator[](int intIndex)
	{
	return *((ConfigStr *)(m_configs[intIndex]));
	}

// BEGIN_HELP_COMMENT
// Function: int COProject::SetProgramArguments(LPCSTR progargs, LPCSTR config /* NULL */)
// Description: Set program arguments for the exe (debuggee).
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: LPCSTR A pointer to a string that contains the program arguments.
// Param: config A pointer to a string that contains the name of the configuration for which to set the program arguments. If this parameter is NULL (default), the default configuration is set. 
// END_HELP_COMMENT
int COProject::SetProgramArguments(LPCSTR progargs, LPCSTR config /* NULL */)
{
	const char* const THIS_FUNCTION = "COProject::SetProgramArguments";

	VERIFY_VALID_PROJECT("Unable to set program arguments.")

	UIWB.DoCommand(IDM_PROJECT_SETTINGS, DC_MNEMONIC);
	UIProjOptionsTabDlg uiProjOptDlg;
	uiProjOptDlg.Display();

	if(config)
	{
		// REVIEW(michma): why won't SelectTarget work? ShowPage (below) fails if we use it.
		//uiProjOptDlg.SelectTarget(config);
		uiProjOptDlg.GiveFocusToConfigList();
		MST.DoKeys(config);
		// this will give focus back to the settings side of the project settings dlg.
		MST.DoKeys("{TAB 2}");
	}
	
	if(!uiProjOptDlg.ShowPage(GetLocString(IDSS_TB_DEBUG)))
		
		{
		LOG->RecordInfo("WARNING in COProject::SetProgramArguments: "
						"could not find page \"%s\" in dialog", 
						(LPCSTR)GetLocString(IDSS_TB_DEBUG));

		MST.DoKeys("{ESC}");
		return ERROR_ERROR;		
		}

	if(!MST.WComboItemExists("@1", GetLocString(IDSS_CATEGORY_GENERAL)))
		
		{
		LOG->RecordInfo("WARNING in COProject::SetProgramArguments: "
						"could not find category \"%s\" in page %s", 
						(LPCSTR)GetLocString(IDSS_CATEGORY_GENERAL),
						(LPCSTR)GetLocString(IDSS_TB_DEBUG));

		MST.DoKeys("{ESC}");
		return ERROR_ERROR;		
		}

	else
		MST.WComboItemClk("@1", 1);		// set category to General		

	if(!MST.WEditExists(GetLocString(IDSS_PROGRAM_ARGUMENTS)))
		{
		LOG->RecordInfo("WARNING in COProject::SetProgramArguments: "
						"could not find edit field \"%s\" in category \"%s\" of page \"%s\"", 
						(LPCSTR)GetLocString(IDSS_PROGRAM_ARGUMENTS), 
						(LPCSTR)GetLocString(IDSS_CATEGORY_GENERAL),
						(LPCSTR)GetLocString(IDSS_TB_DEBUG));

		MST.DoKeys("{ESC}");
		return ERROR_ERROR;		
		}

	MST.WEditSetText("@3", progargs);
	MST.WButtonClick(GetLocString(IDSS_OK));
	return uiProjOptDlg.WaitUntilGone(5000) ? ERROR_SUCCESS : ERROR_ERROR;
	}


// BEGIN_HELP_COMMENT
// Function: int COProject::ExportMakefile()
// Description: To create an export makefile that is compatiable with NMAKE.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// END_HELP_COMMENT
int COProject::ExportMakefile()
{  
	const char* const THIS_FUNCTION = "COProject::ExportMakefile";

	VERIFY_VALID_PROJECT("Unable to export makefile.")

	UIWB.DoCommand(IDM_PROJITEM_EXPORT_MAKEFILE, DC_MNEMONIC) ;
	return TRUE;
}



// BEGIN_HELP_COMMENT
// Function: int COProject::AddSQLDataSource()
// Description: To insert the Datasource into the database project
// Param: DSN A name of the DSN to be found in the ODBC dialog
// Param: User A user name for connection dialog
// Param: Psw Apassword for the connection dialog
// Param: DataBase A database name
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// END_HELP_COMMENT
int COProject::AddSQLDataSource(CString &DSN,CString &User,CString &Psw,
								LPCSTR DataBase /*=NULL*/)
{
	BOOL fileDSN=(DSN.Right(4)==".DSN");

    LOG->RecordInfo("Adding datasource %s to the project", DSN);
	UIWB.DoCommand(IDM_PROJ_ADD_DATASOURCE, DC_MNEMONIC);
	if(WaitForInputIdle(g_hTargetProc, 60000) == WAIT_TIMEOUT)
	{
		LOG->RecordFailure("Coudn't bring up the connection dialog");
		return ERROR_ERROR;
	}
	Sleep(1000); //WaitForInputIdle does not work here, big sefety required
	
	HWND hwnd;
	if (hwnd = MST.WFndWndWait(GetLocString(IDS_SELECT_DSN), FW_PART, 5))
	{
		LOG->Comment("Found Window: '%s'", GetLocString(IDS_SELECT_DSN));
		MST.WSetActWnd(hwnd);

		RECT rcPage;
		GetClientRect(hwnd, &rcPage);
		ClickMouse( VK_LBUTTON ,hwnd, rcPage.left+150, rcPage.top - 15 );	  // Click on first Tab	(left most)
		if(fileDSN==FALSE) //ODBC3.0 Registry data source
		{ 	// we end up here with new ODBC connect
			ClickMouse( VK_LBUTTON ,hwnd, rcPage.left+150, rcPage.top + 15 );	  // Click on first Tab	(left most)
			Sleep(1000);
			if(!MST.WViewItemExists("@1", DSN))
			{
				LOG->RecordFailure("Registry Data Source (%s) does not exists", DSN);
				MST.WButtonClick(GetLabel(IDCANCEL)); //close SQL Data Sources dialog
				return ERROR_ERROR;
			}
			MST.WViewItemClk("@1", DSN);
		}
		else // if(fileDSN==TRUE) //ODBC3.0 file data source
		{
			MST.WEditSetText(GetLocString(IDS_DSN_NAME)/*GetLabel(0x75F /* IDC_DSN_NAME) */, DSN);
		}
	}
	else
	{
		LOG->RecordFailure("Coudn't find the Data Source List");
		return ERROR_ERROR;
	}
	MST.WButtonClick(GetLabel(IDOK)); //close SQL Data Sources dialog

	if(ValidatePassword(User,Psw,DataBase)!=ERROR_SUCCESS)
		return ERROR_ERROR; //login failed 
	return ERROR_SUCCESS;
} // COProject::AddSQLDataSource


// BEGIN_HELP_COMMENT
// Function: int COProject::ValidatePassword()
// Description: To accept params database/user/password in SQL server login dialog
// Param: User A user name for connection dialog
// Param: Psw Apassword for the connection dialog
// Param: DataBase A database name (maybe NULL if default to be used)
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// END_HELP_COMMENT
int COProject::ValidatePassword(CString &User,CString &Psw,
								LPCSTR DataBase /*=NULL*/)
{
	LPCSTR Login=User;
	LPCSTR PassWord=Psw;

	WaitForInputIdle(g_hTargetProc, 5000);
	Sleep(500); // big sefety required	
	if(MST.WFndWndWait(GetLocString(IDSS_SQL_LOGIN), FW_PART, 5)==NULL)
	{
		LOG->RecordInfo("Didn't find SQL server login dialog");
		return ERROR_ERROR;
	}	

	MST.WCheckUnCheck("@1");

	MST.WEditSetText(GetLocString(IDS_LOGIN_ID)/*GetLabel(IDC_LOGIN_ID: 0x7534)*/, Login);
	if(PassWord!=NULL)
		MST.WEditSetText(GetLocString(IDS_PASSWORD)/*GetLabel(IDC_PASSWORD_ID: 0x7535)*/, PassWord);
	MST.WButtonClick(GetLocString(IDS_OPTIONS1)/*GetLabel(IDC_OPTIONS: 0x7541)*/);
	
	Sleep(1000); // big sefety required
	if(DataBase!=NULL)
	{
		int tries_tconnect=1;
		if(GetSystem() & SYSTEM_WIN)
			tries_tconnect=2; //one extra retry on Win95
		do
		{
		tries_tconnect--;
		MST.DoKeyshWnd(MST.WGetActWnd(0),"{F4}"); //this should try to login SQL server
		if (WaitForInputIdle(g_hTargetProc, 60000) == WAIT_TIMEOUT)
			LOG->RecordFailure("Coudn't connect to the server");
		Sleep(1000); // WaitForInputIdle doesn't work big sefety required
		UIMessageBox wndMsgBox;
		if (wndMsgBox.AttachActive())		
		{	// If we can attach, then a login error must've occurred.
			if(MST.WStaticExists(GetLocString(IDS_CONN_FAILED)))
			{
				wndMsgBox.ButtonClick();
				if(tries_tconnect)
					LOG->RecordInfo("FAILED: SQL server login");
				else
				{
					MST.WButtonClick(GetLabel(IDCANCEL));
					LOG->RecordFailure("SQL server login failed.");
					return ERROR_ERROR; //login failed
				}
			}
		}
			Sleep(500); // safety
		}while(tries_tconnect>0);

		if(!MST.WComboItemExists("&Database:" /*GetLabel(0x753A) IDC_DATABASE */, DataBase))
		{
			LOG->RecordFailure("Coudn't find the Database %s",DataBase);
			MST.WButtonClick(GetLabel(IDCANCEL));
			return ERROR_ERROR; //no database found
		}
		MST.WComboItemClk("&Database:" /*GetLabel(0x753A)  IDC_DATABASE */, DataBase);
	} //DataBase!=NULL
	
	MST.WButtonClick(GetLabel(IDOK)); //SQL server chosen
	if (WaitForInputIdle(g_hTargetProc, 60000) == WAIT_TIMEOUT)
		LOG->RecordFailure("Coudn't connect to the server");
	Sleep(1000); // WaitForInputIdle doesn't work big sefety required
	UIMessageBox wndMsgBox;
	if (wndMsgBox.AttachActive())		
	{	// If we can attach, then a login error must've occurred.
		if(MST.WStaticExists(GetLocString(IDS_CONN_FAILED)))
		{
			wndMsgBox.ButtonClick();
			LOG->RecordFailure("SQL server login failed.");
			MST.WButtonClick(GetLabel(IDCANCEL));
			return ERROR_ERROR; //login failed
		}
	}
	return ERROR_SUCCESS;
} //COProject::ValidatePassword


// BEGIN_HELP_COMMENT
// Function: BOOL COProject::AddComponent(COComponent *pComponent, LPCSTR szLocation /* NULL */)
// Description: Adds a component to the project.
// Param: COComponent *pComponent - A pointer to an object representing the component to add. The actual type will be a component-specific derivative of COComponent. For a list of these, see COCOMPON.H.
// Param: szLocation (optional) - The directory the component is in. It may be relative (to the Gallery directory) or absolute. If not supplied, the default components directory is used (ex. Developer Studio Components). 
// Return: BOOL - Returns TRUE if the component was successfully added, FALSE if not.
// END_HELP_COMMENT
BOOL COProject::AddComponent(COComponent *pComponent, LPCSTR szLocation /* NULL */)

{
	
	// TODO: allow batch mode to support components in different directories.
	// currently only supports adding all batched components from default component gallery directory.
	BOOL bBatchMode = m_uigal.IsActive();
	
	// if components are being added in "batch mode", the user will have already enabled the gallery,
	// and set it to the directory where all the components are.
	if(!bBatchMode)
	{
		// open the gallery dlg.
		if(!m_uigal.Display())
		{
			LOG->RecordInfo("ERROR! COProject::AddComponent - could not display gallery dlg");
	 		return FALSE;
		}
		// set the directory to look in.
		if(!m_uigal.LookIn(szLocation ? szLocation : GetLocString(IDSS_COMPONENTS_DIR)))
		{
			LOG->RecordInfo("ERROR! COProject::AddComponent - could not change gallery 'look in'");
			m_uigal.Close();
			return FALSE;
		}
	}
	
	// select the component
	if(!m_uigal.SelectComponent((LPCSTR)(pComponent->m_strFileName)))
	{
		LOG->RecordInfo("ERROR! COProject::AddComponent - could not select component");
		m_uigal.Close();
		return FALSE;
	}

	// verify the component's description field
	if(!pComponent->m_strDescription.IsEmpty() &&  
		m_uigal.Description() != pComponent->m_strDescription)
	{
		LOG->RecordInfo("ERROR! COProject::AddComponent - unexpected component description");
		m_uigal.Close();
		return FALSE;
	}

	// insert the component
	if(!m_uigal.Insert((LPCSTR)(pComponent->m_strGalleryName)))
	{
		LOG->RecordInfo("ERROR! COProject::AddComponent - could not insert component");
		m_uigal.Close();
		return FALSE;
	}

	// do the component's wizard, if any.
	if(!(pComponent->WizardFunc()))
	{
		LOG->RecordInfo("ERROR! COProject::AddComponent - could not complete component wizard");
		m_uigal.Close();
		return FALSE;
	}

	// if components are being added in "batch mode", the user won't want the gallery closed.
	if(!bBatchMode)
	{
		// close the gallery dlg.
		if(!m_uigal.Close())
		{
			LOG->RecordInfo("ERROR! COProject::AddComponent - could not close gallery dlg");
			return FALSE;
		}
	}

	return TRUE;	
}


// BEGIN_HELP_COMMENT
// Function: BOOL COProject::EnableComponents(LPCSTR szLocation /* NULL */)
// Description: Opens all initial gallery/components dlgs/windows necessary to add components. This is for tests that add a lot of components consecutively (i.e. batch mode), and want to save time, for example, by not closing and reopening the gallery dlg everytime.
// Param: szLocation (optional) - The directory the components are in. It may be relative (to the Gallery directory) or absolute. If not supplied, the default components directory is used (ex. Developer Studio Components). 
// Return: BOOL - Returns TRUE if the components were sucessfully enabled (i.e. the gallery dlg was opened), FALSE if not.
// END_HELP_COMMENT
BOOL COProject::EnableComponents(LPCSTR szLocation /* NULL */)

{
	// display the component gallery.
	m_uigal.Display();

	// verify the dlg came up.
	if(!m_uigal.IsActive())
	{
		LOG->RecordInfo("ERROR! COProject::EnableComponents - could not open gallery dlg");
		return FALSE;
	}

	// set the directory to look in.
	if(!m_uigal.LookIn(szLocation ? szLocation : GetLocString(IDSS_COMPONENTS_DIR)))
	{
		LOG->RecordInfo("ERROR! COProject::EnableComponents - could not change gallery 'look in'");
		m_uigal.Close();
		return FALSE;
	}

	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL COProject::DisableComponents(void)
// Description: Closes all initial gallery/components dlgs/windows necessary to add components. This is for tests that add a lot of components consecutively (i.e. batch mode), and want to save time, for example, by not closing and reopening the gallery dlg everytime.
// Return: BOOL - Returns TRUE if the components were sucessfully disabled (i.e. the gallery dlg was closed), FALSE if not.
// END_HELP_COMMENT
BOOL COProject::DisableComponents(void)
{
	// close the gallery dlg.
	m_uigal.Close();

	// verify it actually did close.
	if(m_uigal.IsActive())
	{
		LOG->RecordInfo("ERROR! COProject::DisableComponents - could not close gallery dlg");
		return FALSE;
	}

	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: CProjWizOptions::CProjWizOptions(void)
// Description: Constructs a CProjWizOptions object. The default
// Return: none.
// END_HELP_COMMENT
CProjWizOptions::CProjWizOptions(void)
{
	m_strName = "";
	m_strLocation = "";
	m_pwWorkspace = CREATE_NEW_WORKSPACE;
	m_phHierarchy = TOP_LEVEL_PROJ;
	m_strParent = ""; 
	m_iPlatforms = GetUserTargetPlatforms();
}


// BEGIN_HELP_COMMENT
// Function: CControlWizOptions::CControlWizOptions(void)
// Description: Constructs a CControlWizOptions object.
// Return: none.
// END_HELP_COMMENT
CControlWizOptions::CControlWizOptions(void)
{
	// set the project type for UIProjectWizard in COProject::New()
	m_ptType = ACTIVEX_CONTROL;
	// set the activex control wizard defaults.
	m_iNumControls = 1;
	m_bRuntimeLicense = FALSE;
	m_bGenerateComments = TRUE;
	m_bGenerateHelpFiles = FALSE;
	m_bActivatesWhenVisible = TRUE;
	m_bInvisibleAtRuntime = FALSE;
	m_bAvailableInInsertObjectDlg = FALSE;
	m_bAboutBox = TRUE;
	m_bSimpleFrameControl = FALSE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL CControlWizOptions::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the CControlWizOptions object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL CControlWizOptions::WizardFunc(void)

{
	UICtrlWizard uictrlwiz;

 	// wait up to 3 seconds for page 1 of the wizard dlg to come up. 
	if(!MST.WFndWndWait(uictrlwiz.ExpectedTitle(1), FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! CControlWizOptions::WizardFunc - page 1 of wizard not found");
		return FALSE;
	}

	// attach to the wizard dlg.
	uictrlwiz.AttachActive();
	// go to page 2.
	uictrlwiz.NextPage();

 	// wait up to 3 seconds for page 2 of the wizard dlg to come up. 
	if(!MST.WFndWndWait(uictrlwiz.ExpectedTitle(2), FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! CControlWizOptions::WizardFunc - page 2 of wizard not found");
		return FALSE;
	}

	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: CATLCOMWizOptions::CATLCOMWizOptions(void)
// Description: Constructs a CATLCOMWizOptions object.
// Return: none.
// END_HELP_COMMENT
CATLCOMWizOptions::CATLCOMWizOptions(void)
{
	// set the project type for UIProjectWizard in COProject::New()
	m_ptType = ATL_COM;
	// set the atl com wizard defaults.
	m_acstServerType = ATL_COM_SERVER_DLL;
	m_bAllowMergingOfProxyStubCode = FALSE;
	m_bSupportMFC = FALSE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL CATLCOMWizOptions::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the CATLCOMWizOptions object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL CATLCOMWizOptions::WizardFunc(void)

{
	// TODO(michma): this wizard needs its own class like the app wizard and control wizard.

 	// wait up to 3 seconds for page 1 of the wizard dlg to come up. 
	if(!MST.WFndWndWait(GetLocString(IDSS_PROJTYPE_ATL_COM_WIZ), FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! CATLCOMWizOptions::WizardFunc - page 1 of wizard not found");
		return FALSE;
	}

	// set the options for the wizard.
	char szOption[4];
	sprintf(szOption, "@%d", m_acstServerType); 
	MST.WOptionSelect(szOption);

	if(m_bAllowMergingOfProxyStubCode)
		MST.WCheckCheck("@1");
	else
		MST.WCheckUnCheck("@1");

	if(m_bSupportMFC)
		MST.WCheckCheck("@2");
	else
		MST.WCheckUnCheck("@2");

	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: CWin32AppWizOptions::CWin32AppWizOptions(void)
// Description: Constructs a CWin32AppWizOptions object.
// Return: none.
// END_HELP_COMMENT
CWin32AppWizOptions::CWin32AppWizOptions(void)
{
	// set the project type for UIProjectWizard in COProject::New()
	m_ptType = EXE;
	// set the win32 app wizard defaults.
	m_AppType = EMPTY_PROJECT;
}


// BEGIN_HELP_COMMENT
// Function: BOOL CWin32AppWizOptions::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the CWin32AppWizOptions object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL CWin32AppWizOptions::WizardFunc(void)

{
	// TODO(michma): this wizard needs its own class like the app wizard and control wizard.

 	// wait up to 3 seconds for page 1 of the wizard dlg to come up. 
	if(!MST.WFndWndWait(GetLocString(IDSS_PROJTYPE_APPLICATION), FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! CWin32AppWizOptions::WizardFunc - page 1 of wizard not found");
		return FALSE;
	}

	// set the options for the wizard.
	char szOption[4];
	sprintf(szOption, "@%d", m_AppType); 
	MST.WOptionSelect(szOption);
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: CISAPIExtensionWizOptions::CISAPIExtensionWizOptions(void)
// Description: Constructs a CISAPIExtensionWizOptions object.
// Return: none.
// END_HELP_COMMENT
CISAPIExtensionWizOptions::CISAPIExtensionWizOptions(void)
{
	// set the project type for UIProjectWizard in COProject::New()
	m_ptType = ISAPI_EXTENSION;
	// set the isapi extension wizard defaults.
	m_bGenerateFilter = FALSE;
	m_bGenerateExtension = TRUE;
	m_MFCLinkage = LINK_AS_SHARED_DLL;
}


// BEGIN_HELP_COMMENT
// Function: BOOL CISAPIExtensionWizOptions::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the CISAPIExtensionWizOptions object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL CISAPIExtensionWizOptions::WizardFunc(void)

{
	// TODO(michma): this wizard needs its own class like the app wizard and control wizard.

 	// wait up to 3 seconds for page 1 of the wizard dlg to come up. 
	if(!MST.WFndWndWait(GetLocString(IDSS_PROJTYPE_ISAPI_EXTENSION), FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! CISAPIExtensionWizOptions::WizardFunc - page 1 of wizard not found");
		return FALSE;
	}

	// set the options for the wizard.
	// TODO(michma - 11/21/97) need to support non-default class name and description fields.
	if(m_bGenerateFilter)
		MST.WCheckCheck("@1");
	else
		MST.WCheckUnCheck("@1");

	if(m_bGenerateExtension)
		MST.WCheckCheck("@2");
	else
		MST.WCheckUnCheck("@2");

	char szOption[4];
	sprintf(szOption, "@%d", m_MFCLinkage); 
	MST.WOptionSelect(szOption);
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: CWin32DllWizOptions::CWin32DllWizOptions(void)
// Description: Constructs a CWin32DllWizOptions object.
// Return: none.
// END_HELP_COMMENT
CWin32DllWizOptions::CWin32DllWizOptions(void)
{
	// set the project type for UIProjectWizard in COProject::New()
	m_ptType = DLL;
	// set the win32 dll wizard defaults.
	m_DllType = EMPTY_PROJECT;
}


// BEGIN_HELP_COMMENT
// Function: BOOL CWin32DllWizOptions::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the CWin32DllWizOptions object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL CWin32DllWizOptions::WizardFunc(void)

{
	// TODO(michma): this wizard needs its own class like the app wizard and control wizard.

 	// wait up to 3 seconds for page 1 of the wizard dlg to come up. 
	if(!MST.WFndWndWait(GetLocString(IDSS_PROJTYPE_DLL), FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! CWin32DllWizOptions::WizardFunc - page 1 of wizard not found");
		return FALSE;
	}

	// set the options for the wizard.
	char szOption[4];
	sprintf(szOption, "@%d", m_DllType); 
	MST.WOptionSelect(szOption);
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: CXboxGameOptions::CXboxGameOptions(void)
// Description: Constructs a CXboxGameOptions object.
// Return: none.
// END_HELP_COMMENT
CXboxGameOptions::CXboxGameOptions(void)
{
	// set the project type for UIProjectWizard in COProject::New()
	m_ptType = XBOX_PROJECT;
}


// BEGIN_HELP_COMMENT
// Function: CXboxStaticLibOptions::CXboxStaticLibOptions(void)
// Description: Constructs a CXboxStaticLibOptions object.
// Return: none.
// END_HELP_COMMENT
CXboxStaticLibOptions::CXboxStaticLibOptions(void)
{
	// set the project type for UIProjectWizard in COProject::New()
	m_ptType = XBOX_LIB_PROJECT;
}


// BEGIN_HELP_COMMENT
// Function: BOOL CXboxGameOptions::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the CXboxGameOptions object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL CXboxGameOptions::WizardFunc(void)
{
	// no options to set
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL CXboxStaticLibOptions::WizardFunc(void)
// Description: Manipulates the component's wizard, using values stored by the CXboxStaticLibOptions object.
// Return: TRUE if the wizard was successful, FALSE if not.
// END_HELP_COMMENT
BOOL CXboxStaticLibOptions::WizardFunc(void)
{
	// no options to set
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: int COProject::New(CProjWizOptions *pProjWizOpt)
// Description: Creates a new project, including handling of the project-specific wizard. 
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: pProjWizOpt A pointer to a CProjWizOptions derived class that defines the project (ex. the type, the name, the location, project-specific options, etc.). See CProjWizOptions and derived types for more info (in coprject.h)
// END_HELP_COMMENT
int COProject::New(CProjWizOptions *pProjWizOpt)

{
	const char* const THIS_FUNCTION = "COProject::New";

	// bring up the new project dlg.
	UIProjectWizard uprjwiz = AppWizard();
	
	// verify it came up.
	if(!uprjwiz.HWnd())
	{
		LOG->RecordInfo("%s: could not bring up the new project dlg", THIS_FUNCTION);
		return ERROR_ERROR;
	}

	// set the project type.
	uprjwiz.SetProjType(pProjWizOpt->m_ptType);

	// set the project location, if specified.
	if(pProjWizOpt->m_strLocation != "")
		uprjwiz.SetDir(pProjWizOpt->m_strLocation);

	// set the project name.
	uprjwiz.SetName(pProjWizOpt->m_strName);

	// set workspace/dependency option.
	if(pProjWizOpt->m_pwWorkspace == ADD_TO_CURRENT_WORKSPACE)
	{
		// add to current workspace.
		uprjwiz.SetAddToWorkspace(TRUE);
		// if there is a dependency, set it.
		if((pProjWizOpt->m_phHierarchy == SUB_PROJ) && (pProjWizOpt->m_strParent != ""))
			uprjwiz.SetTopLevelProj(pProjWizOpt->m_strParent);
	}
	else
		// create a new workspace.
		uprjwiz.SetAddToWorkspace(FALSE);

	// set the platforms.
	SetNewProjectPlatforms(pProjWizOpt->m_iPlatforms);

	// confirm the creation.
	if(uprjwiz.Create() == NULL)
	{
		LOG->RecordInfo("%s: could not create new project.", THIS_FUNCTION);
		return ERROR_ERROR;
	}

	// do the project-specific wizard.
	if(!pProjWizOpt->WizardFunc())
	{
		LOG->RecordInfo("%s: failed to do wizard.", THIS_FUNCTION);
		return ERROR_ERROR;
	}

	// update UIProjectWizard on what the current window handle is
	// (it will be the handle of the window to whichever page the project-specific wizard left off at).
	uprjwiz.AttachActive();
	// finish the wizard.
	// REVIEW (michma): in NewAppWiz() we check the page returned by Finish(), but only pages for
	// appwizard seem to be supported, not control wizard or atl wizard, etc. so this gets us by for now.
	uprjwiz.Finish();

	// confirm the new project information.
	if(!uprjwiz.ConfirmCreate())
	{
		LOG->RecordInfo("%s: problem generating project.", THIS_FUNCTION);
		return ERROR_ERROR;
	}

	// give focus to workspace window.
    ActivateProjWnd();	
	// bring up the project window
	NewProjectWindow();
	// set up the member variables that contain information about this project.
	SetPathMembers();
	// this will ensure that the ide is done making menu changes, etc., for the new project.
	Sleep(1000);

	return ERROR_SUCCESS;
}


// BEGIN_HELP_COMMENT
// Function: int COProject::InsertNewATLObject(LPCSTR szObjectName)
// Description: Inserts a new ATL object into the current project. 
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szObjectName A pointer to a string specifying the name of the new object.
// END_HELP_COMMENT
int COProject::InsertNewATLObject(LPCSTR szObjectName)

{
	// TODO(michma): the ATL Object Wizard needs its own UI class with full functionality. 
	UIWB.DoCommand(IDM_NEW_ATL_OBJECT, DC_MNEMONIC);

 	// wait up to 3 seconds for the wizard dlg to come up. 
	if(!MST.WFndWndWait(GetLocString(IDSS_ATL_OBJ_WIZ_TITLE), FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! COProject::InsertNewATLObject - ATL Object Wizard dlg not found");
		return ERROR_ERROR;
	}

	// simply select the default "Simple Object" for now.
	MST.DoKeys("{ENTER}");

 	// wait up to 3 seconds for the wizard properties dlg to come up. 
	if(!MST.WFndWndWait(GetLocString(IDSS_ATL_OBJ_WIZ_PROP_TITLE), FW_PART, 3))
	{
		LOG->RecordInfo("ERROR! COProject::InsertNewATLObject - ATL Object Wizard Properties dlg not found");
		return ERROR_ERROR;
	}
	
	// simply enter the shortname of the object for now.
	MST.DoKeys(szObjectName);
	// finish the wizard.
	MST.DoKeys("{ENTER}");

	// wait around a few seconds in case we need to confirm using an existing class id.
	if(MST.WFndWndWaitC(GetLocString(IDSS_USE_EXISTING_CLASS_ID), "Static", FW_PART, 5))
		MST.DoKeys("{ENTER}");

 	// wait up to 10 seconds for the wizard properties dlg to go away. 
	if(!MST.WFndWndWait(GetLocString(IDSS_ATL_OBJ_WIZ_PROP_TITLE), FW_NOEXIST | FW_PART, 10))
	{
		LOG->RecordInfo("ERROR! COProject::InsertNewATLObject - ATL Object Wizard Properties dlg didn't go away");
		return ERROR_ERROR;
	}

	return ERROR_SUCCESS;
}


// BEGIN_HELP_COMMENT
// Function: LPCSTR COProject::GetOutputFile()
// Description: Get the output file from the Project Settings dialog
// Return: A char string that of what is contained in the Link Tab on the setting dialog. If the path is relative, it will build the full path for the file
// Param: <none>
// END_HELP_COMMENT
LPCSTR COProject::GetOutputFile()
{
	m_OutputFile = GetProjProperty(CT_LINKER, LNK_IDC_TARGET_NAME);

	// now lets see if the path is relative
	char drive[_MAX_DRIVE];   char dir[_MAX_DIR];
	char fname[_MAX_FNAME];   char ext[_MAX_EXT];

	_splitpath(m_OutputFile, drive, dir, fname, ext);
	
	// Assumption: if drive is NULL, then this is a reference path
	if (strlen(drive) == 0)
	{
		// we need to append the drectory of the project to the path
		m_OutputFile = m_ProjDir + dir;
	}
	m_OutputFile.Replace('/','\\');
	m_OutputFile += fname;
	m_OutputFile += ext;
	
	return m_OutputFile.GetBuffer(0);
}

// emmang@xbox xbox-specific
// BEGIN_HELP_COMMENT
// Function: LPCSTR COProject::GetOutputXbeFile()
// Description: Get the output file from the Project Settings dialog
// Return: A char string that of what is contained in the Link Tab on the setting dialog. If the path is relative, it will build the full path for the file
// Param: <none>
// END_HELP_COMMENT
LPCSTR COProject::GetOutputXbeFile()
{
	m_OutputFile = GetProjProperty(CT_IMAGEBLD, IMAGEBLD_IDC_XBE_NAME);

	// now lets see if the path is relative
	char drive[_MAX_DRIVE];   char dir[_MAX_DIR];
	char fname[_MAX_FNAME];   char ext[_MAX_EXT];

	_splitpath(m_OutputFile, drive, dir, fname, ext);
	
	// Assumption: if drive is NULL, then this is a reference path
	if (strlen(drive) == 0)
	{
		// we need to append the drectory of the project to the path
		m_OutputFile = m_ProjDir + dir;
	}
	m_OutputFile.Replace('/','\\');
	m_OutputFile += fname;
	m_OutputFile += ext;
	
	return m_OutputFile.GetBuffer(0);
}

// BEGIN_HELP_COMMENT
// Function: LPCSTR COProject::GetIntermediateDir()
// Description: Get the IntermediateDir from the Project Settings dialog on the General Tab
// Return: A char string that of what is contained in the Itermediate Files edit field. This a relative path to the project
// Param: <none>
// END_HELP_COMMENT
LPCSTR COProject::GetIntermediateDir()
{
	UIProjOptionsTabDlg uipo;
	uipo.AttachActive();

	//m_InterDir = uipo.GetGeneralOptionStr(GEN_IDC_INTER_DIR);
	m_InterDir = uipo.GetOptionStr(CT_GENERAL, GEN_IDC_INTER_DIR);
	
	return m_InterDir.GetBuffer(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\prj.cpp ===
/////////////////////////////////////////////////////////////////////////////
// prj.cpp
//
// email	date		change
// briancr	01/11/95	created
//
// copyright 1994 Microsoft

#include "stdafx.h"
#include "afxdllx.h"

#define new DEBUG_NEW

///////////////////////////////////////////////////////////////////////////////
//	DLL support

static AFX_EXTENSION_MODULE extensionDLL = { NULL, NULL };

extern "C" __declspec(dllexport) int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("Project DLL Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(extensionDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(extensionDLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("Project DLL Terminating!\n");
		// Terminate the library before destructors are called
		AfxTermExtensionModule(extensionDLL);
	}
	return 1;   // ok

	UNREFERENCED_PARAMETER(lpReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\uappwiz.h ===
///////////////////////////////////////////////////////////////////////////////
//      UAPPWIZ.H
//
//      Created by :                    Date :
//              DavidGa                                 10/27/93
//
//      Description :
//              Declaration of the UIAppWizard class
//

#ifndef __UIAPPWIZ_H__
#define __UIAPPWIZ_H__

#include "..\sym\appwz.h"
#include "uprojwiz.h"

#include "prjxprt.h"

#ifndef __UPROJWIZ_H__ 
	#error include 'uprojwiz.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//      UIAppWizard class

enum { UIAW_INVALID,                    // it doesn't look like anything of App Wizard's
		UIAW_NEWPROJ,           // New Project dialog
		UIAW_APPTYPE,           // SDI/MDI/Dialog choices
		UIAW_DLGOPTIONS,        // Dialog Project options
		UIAW_DLGFEATURES,       // Dialog Features
		UIAW_DLGCLASSES,        // Dialog Class Names
		UIAW_DBOPTIONS,                 // Database options
		UIAW_OLEOPTIONS,        // OLE options
		UIAW_FEATURES,          // Features
		UIAW_PROJOPTIONS,       // Project options
		UIAW_CLASSES,           // Class Names
		UIAW_CONFIRM,           // Confirmation
		UIAW_PROGRESS,          // Progress dialog
		UIAW_DBSOURCES,                 // Data Sources dialog
		UIAW_MESSAGEBOX };      // Any App Wizard dialog with an OK button

enum { UIAW_APP_SDI = APPWZ_IDC_PTRADIO,
		UIAW_APP_MDI = APPWZ_IDC_PTMDI,
		UIAW_APP_FORM = APPWZ_IDC_PTDLG };

enum { UIAW_DB_NONE = APPWZ_IDC_DB_RADIO,
		UIAW_DB_HEADER = APPWZ_IDC_DB_HEADER,
		UIAW_DB_VIEWONLY = APPWZ_IDC_DB_SIMPLE,
		UIAW_DB_VIEWFILE = APPWZ_IDC_DB_DOCVIEW };

enum { UIAW_OLE_NONE = APPWZ_IDC_NO_INPLACE,
		UIAW_OLE_CONTAINER = APPWZ_IDC_CONTAINER,
		UIAW_OLE_MINI_SERVER = APPWZ_IDC_MSERVER,
		UIAW_OLE_FULL_SERVER = APPWZ_IDC_FSERVER,
		UIAW_OLE_CONTAINER_SERVER = APPWZ_IDC_CSERVER,
		UIAW_OLE_YES_AUTO = APPWZ_IDC_RADIO1,
		UIAW_OLE_NO_AUTO = APPWZ_IDC_AUTOMATION_RADIO };

enum { UIAW_PROJ_COMMENTS = APPWZ_IDCD_POVERBOSE,
		UIAW_PROJ_NOCOMMENTS = APPWZ_IDC_RADIO2,
// REVIEW(briancr): I don't think this is supported for Olympus
//              UIAW_PROJ_EXTERNAL = APPWZ_IDCD_POEXTMAK,
		UIAW_PROJ_INTERNAL = APPWZ_IDC_RADIO3,
		UIAW_PROJ_MFCDLL = APPWZ_IDCD_PODLL,
		UIAW_PROJ_MFCSTATIC = APPWZ_IDCD_PONOTDLL };

// BEGIN_CLASS_HELP
// ClassName: UIAppWizard
// BaseClass: UIProjectWizard
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS UIAppWizard : public UIProjectWizard
{
	UIWND_COPY_CTOR(UIAppWizard, UIProjectWizard);
	virtual void OnUpdate(void) ;
	operator HWND ( ) {return HWnd();}
	operator BOOL ( ) {return (BOOL) HWnd();} ;
		// Data
public:
	int OleInstalled  ;
	BOOL ODBCInstalled ;
	//Pages in the Wizard.
	WORD pg1, pg2, pg3,pg4, pg5, pg6, confirm;

protected:
// Utilities
public:
	inline virtual CString ExpectedTitle(void) const
		{       return ExpectedTitle(-1); }
	virtual CString ExpectedTitle(int nPage) const;
	
	virtual void Initialize() ;
	virtual HWND Create(void);
									   
	void SetAppType(UINT id);
	void SetDBOptions(UINT id);
	void SetOLEOptions(UINT id);
	void SetOLEOptions2(UINT id);
	void SetProjOptions(UINT id);
	void SetFeatures(UINT id);

	void SelectClass(int n);
	void SelectClass(LPCSTR sz);

	CString GetClassName(void);
	CString GetBaseClass(void);
	CString GetSourceFile(void);
	CString GetHeaderFile(void);

// Helper functions
public:
	virtual int GetPage(HWND hwnd = NULL);
	virtual void ExpectPage(int nPage);
	virtual BOOL IsValid(void);

};

#endif //__UIAPPWIZ_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\ucwzdlg.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UCWZDLG.CPP
//
//  Created by :            Date :
//      Ivanl              3/07/94
//                                
//  Description :
//      Implementation of the UIClassWizard class
//

#include "stdafx.h"
#include "odbcdlgs.h"
#include "ucwzdlg.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "guiv1.h"
#include "guitarg.h"
#include "..\shl\wbutil.h"
#include "..\shl\uwbframe.h"
#include "..\sym\cmdids.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

void UIClassWizard::OnUpdate(void)
{
	UIDialog::OnUpdate();
    m_AutoDlg = NULL ;
}

// BEGIN_HELP_COMMENT
// Function: HWND UIClassWizard::Display() 
// Description: Display the ClassWizard dialog.
// Return: The HWND of the ClassWizard dialog, if successful; NULL otherwise.
// END_HELP_COMMENT
HWND UIClassWizard::Display() 
{
    WaitForInputIdle(g_hTargetProc, 60000);
	AttachActive();           // Check if is already up
	if (!IsValid())
	{
     WaitForInputIdle(g_hTargetProc, 60000);
	 //UIWB.DoCommand(IDMY_CLASSWIZARD, DC_MENU);
	 MST.DoKeys("^w");
	 AttachActive();
	}
	return WGetActWnd(0); 
}

// BEGIN_HELP_COMMENT
// Function: HWND UIClassWizard::DeleteFunction(int ClassIndex, int FuncIndex, int ObjectIndex)
// Description: Delete a message map member function from the class.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: ClassIndex An integer that contains the 1-based index into the list of classes in ClassWizard. This specifies the class that contains the function to delete.
// Param: FuncIndex An integer that contains the 1-based index into the list of messages. This specifies the member function to delete.
// Param: ObjectIndex An integer that contains the 1-based index into the list of objects for the selected class. This specifies the object that contains the function to delete.
// END_HELP_COMMENT
int UIClassWizard::DeleteFunction(int ClassIndex, int FuncIndex, int ObjectIndex )
{
	Display() ; //Make sure ClassWiz has is the active window.
	ShowPage(TAB_MESSAGEMAP, 8);
	if (MST.WComboCount(GetLabel(CLSWIZ_IDC_CLASSBOX)) < ClassIndex )
	return ERROR_ERROR ;
	MST.WComboItemDblClk(GetLabel(CLSWIZ_IDC_CLASSBOX), ClassIndex) ;
	if (!WaitForOriginalWnd(HWnd(),2)) // If a dlg comes up press Enter
		    MST.DoKeys("{ENTER}") ;
    if (MST.WListCount(GetLabel(CLSWIZ_IDC_THINGLIST)) < ObjectIndex)
		return ERROR_ERROR ;
	MST.WListItemClk(GetLabel(CLSWIZ_IDC_THINGLIST), ObjectIndex) ;
	if (MST.WListCount(GetLabel(CLSWIZ_IDC_MESSAGELIST)) < FuncIndex)
		return ERROR_ERROR ;
	MST.WListItemClk(GetLabel(CLSWIZ_IDC_MESSAGELIST), FuncIndex) ;
// Delete the selected message handler.
	int MappedCount = MST.WListCount(GetLabel(CLSWIZ_IDC_MAPPEDLIST)) ;
	MST.WButtonClick(GetLabel(CLSWIZ_ID_REMOVE)) ;
	if (!WaitForOriginalWnd(HWnd(),2)) // Press Yes on the alert about deleting the implementation 
		MST.DoKeys("{ENTER}") ;
// Verify that the message handlers are less by one after the delete.
	if (MST.WListCount(GetLabel(CLSWIZ_IDC_MAPPEDLIST)) == MappedCount)
	{
		if (MappedCount)  
		{
			CString cs = "											" ;
			MST.WListText(GetLabel(CLSWIZ_IDC_MAPPEDLIST), cs) ;
			LOG->RecordInfo(cs) ;
		}
		return ID_NODELETE ;
	}       
	return ERROR_SUCCESS;
}

// BEGIN_HELP_COMMENT
// Function: HWND UIClassWizard::Close() 
// Description: Close the ClassWizard dialog.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// END_HELP_COMMENT
HWND UIClassWizard::Close() 
{
   MST.WButtonClick(GetLabel(IDOK)) ;
   if (m_AutoDlg) // Delete this object if used one.
		delete (m_AutoDlg) ;

   return ERROR_SUCCESS ; 
}

// BEGIN_HELP_COMMENT
// Function: int UIClassWizard::ClassCount()
// Description: Gets the number of classes in the active project.
// Return: An integer that indicates the class count.
// END_HELP_COMMENT
int UIClassWizard::GetClassCount()
{
	Display() ; //Make sure ClassWiz has is the active window.
	ShowPage(TAB_MESSAGEMAP, 8);
	return MST.WComboCount(GetLabel(CLSWIZ_IDC_CLASSBOX)) ;
}

// BEGIN_HELP_COMMENT
// Function: int UIClassWizard::AddFunction(int ClassIndex, int FuncIndex, int ObjectIndex)
// Description: Add a message map member function to the class.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: ClassIndex An integer that contains the 1-based index into the list of classes in ClassWizard. This specifies the class that contains the function to add.
// Param: FuncIndex An integer that contains the 1-based index into the list of messages. This specifies the member function to add.
// Param: ObjectIndex An integer that contains the 1-based index into the list of objects for the selected class. This specifies the object that contains the function to add.
// END_HELP_COMMENT
int UIClassWizard::AddFunction(int ClassIndex, int FuncIndex, int ObjectIndex)
{
	Display() ; //Make sure ClassWiz has is the active window.
	ShowPage(TAB_MESSAGEMAP, 8);
	if (MST.WComboCount(GetLabel(CLSWIZ_IDC_CLASSBOX)) < ClassIndex )
	return ERROR_ERROR ;
	MST.WComboItemDblClk(GetLabel(CLSWIZ_IDC_CLASSBOX), ClassIndex) ;
//      if (WaitForWndWithCtrl(8,1000))
	if (!WaitForOriginalWnd(HWnd(),2)) // If a dlg comes up press Enter
		    MST.DoKeys("{ENTER}") ;
    if (MST.WListCount(GetLabel(CLSWIZ_IDC_THINGLIST)) < ObjectIndex)
		return ERROR_ERROR ;
	MST.WListItemClk(GetLabel(CLSWIZ_IDC_THINGLIST), ObjectIndex) ;
	if (MST.WListCount(GetLabel(CLSWIZ_IDC_MESSAGELIST)) < FuncIndex)
		return ERROR_ERROR ;
	MST.WListItemDblClk(GetLabel(CLSWIZ_IDC_MESSAGELIST), FuncIndex) ;
	if (WaitForWndWithCtrl(CLSWIZ_IDC_MEMBERNAME,500))
		{
		 CString cs = "                                            " ;
		 MST.WEditText("",cs) ;
		 MST.DoKeys("{ENTER}") ;
//               if (WaitForWndWithCtrl(3,500)) // If its a duplicate cancel
		if (!WaitForOriginalWnd(HWnd(),2)) // If its a dupliate
			{
			 MST.DoKeys("{ESC 2}") ;
		     LOG->RecordInfo(cs+":  Was a duplicate function") ;
			}
		}
//      if (WaitForWndWithCtrl(3,500)) // If its a duplicate cancel
	if (!WaitForOriginalWnd(HWnd(),2)) // If a dlg comes up press Enter
	{
		 MST.DoKeys("{ESC}") ;
	     LOG->RecordInfo("Duplicate function") ;
	}

	m_ActiveClass = ClassIndex ;
	return ERROR_SUCCESS;
}
	  
	  
// BEGIN_HELP_COMMENT
// Function: int UIClassWizard::AddFunction(int ClassIndex, int FuncIndex, LPCSTR szObject)
// Description: Add a message map member function to the class.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: ClassIndex An integer that contains the 1-based index into the list of classes in ClassWizard. This specifies the class that contains the function to add.
// Param: FuncIndex An integer that contains the 1-based index into the list of messages. This specifies the member function to add.
// Param: szObject A string that contains the name of object ID to use for the function.
// END_HELP_COMMENT
int UIClassWizard::AddFunction(int ClassIndex, int FuncIndex, LPCSTR szObject)
{
	Display() ; //Make sure ClassWiz has is the active window.
	ShowPage(TAB_MESSAGEMAP, 8);
	if (MST.WComboCount(GetLabel(CLSWIZ_IDC_CLASSBOX)) < ClassIndex )
	return ERROR_ERROR ;
	MST.WComboItemClk(GetLabel(CLSWIZ_IDC_CLASSBOX), ClassIndex) ;
    if (!MST.WListItemExists(GetLabel(CLSWIZ_IDC_THINGLIST), szObject))
		return ERROR_ERROR ;
	MST.WListItemClk(GetLabel(CLSWIZ_IDC_THINGLIST), szObject) ;
	if (MST.WListCount(GetLabel(CLSWIZ_IDC_MESSAGELIST)) < FuncIndex)
		return ERROR_ERROR ;
	MST.WListItemDblClk(GetLabel(CLSWIZ_IDC_MESSAGELIST), FuncIndex) ;
	if (WaitForWndWithCtrl(CLSWIZ_IDC_MEMBERNAME,500))
		{
		 CString cs = "                                            " ;
		 MST.WEditText("",cs) ;
		 MST.DoKeys("{ENTER}") ;
		if (!WaitForOriginalWnd(HWnd(),2)) // If its a dupliate
			{
			 MST.DoKeys("{ESC 2}") ;
		     LOG->RecordInfo(cs+":  Was a duplicate function") ;
			}
		}
	if (!WaitForOriginalWnd(HWnd(),2)) // If a dlg comes up press Enter
	{
		 MST.DoKeys("{ESC}") ;
	     LOG->RecordInfo("Duplicate function") ;
	}

	m_ActiveClass = ClassIndex ;
	return ERROR_SUCCESS;
}


// BEGIN_HELP_COMMENT
// Function: int UIClassWizard::AddFunction2(int ClassIndex, int FuncIndex, int ObjectIndex)
// Description: Add a message map member function to the class.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: ClassIndex An integer that contains the 1-based index into the list of classes in ClassWizard. This specifies the class that contains the function to add.
// Param: FuncIndex An integer that contains the 1-based index into the list of messages. This specifies the member function to add.
// Param: ObjectIndex An integer that contains the 1-based index into the list of objects for the selected class. This specifies the object that contains the function to add.
// END_HELP_COMMENT
int UIClassWizard::AddFunction2(int ClassIndex, int FuncIndex, int ObjectIndex)
{
	Display() ; //Make sure ClassWiz has is the active window.
	ShowPage(TAB_MESSAGEMAP, 8);
	if (MST.WComboCount(GetLabel(CLSWIZ_IDC_CLASSBOX)) < ClassIndex )
	return ERROR_ERROR ;
	MST.WComboItemClk(GetLabel(CLSWIZ_IDC_CLASSBOX), ClassIndex) ;
//      if (WaitForWndWithCtrl(8,1000))
/*	if (!WaitForOriginalWnd(HWnd(),2)) // If a dlg comes up press Enter
		    MST.DoKeys("{ENTER}") ;
*/    if (MST.WListCount(GetLabel(CLSWIZ_IDC_THINGLIST)) < ObjectIndex)
		return ERROR_ERROR ;
	MST.WListItemClk(GetLabel(CLSWIZ_IDC_THINGLIST), ObjectIndex) ;
	if (MST.WListCount(GetLabel(CLSWIZ_IDC_MESSAGELIST)) < FuncIndex)
		return ERROR_ERROR ;
	MST.WListItemDblClk(GetLabel(CLSWIZ_IDC_MESSAGELIST), FuncIndex) ;
	if (WaitForWndWithCtrl(CLSWIZ_IDC_MEMBERNAME,500))
		{
		 CString cs = "                                            " ;
		 MST.WEditText("",cs) ;
		 MST.DoKeys("{ENTER}") ;
//               if (WaitForWndWithCtrl(3,500)) // If its a duplicate cancel
		if (!WaitForOriginalWnd(HWnd(),2)) // If its a dupliate
			{
			 MST.DoKeys("{ESC 2}") ;
		     LOG->RecordInfo(cs+":  Was a duplicate function") ;
			}
		}
//      if (WaitForWndWithCtrl(3,500)) // If its a duplicate cancel
	if (!WaitForOriginalWnd(HWnd(),2)) // If a dlg comes up press Enter
	{
		 MST.DoKeys("{ESC}") ;
	     LOG->RecordInfo("Duplicate function") ;
	}

	m_ActiveClass = ClassIndex ;
	return ERROR_SUCCESS;
}
	  
	// Name = ""  Derive from Class type 
	// DotH = "", DotCPP ="" Use default
// BEGIN_HELP_COMMENT
// Function: int UIClassWizard::AddClass(int TypeIndex,CString Name,  CString DotH, CString DotCPP) 
// Description: Add a new class the project via ClassWizard.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: TypeIndex An integer that contains the 1-based index into the list of base classes to derive this class from.
// Param: Name A CString that contains the name of the new class.
// Param: DotH A CString that contains the name of the header file for the new class.
// Param: DotCPP A CString that contains the name of the source file for the new class.
// END_HELP_COMMENT
int UIClassWizard::AddClass(int TypeIndex,CString Name,  CString DotH, CString DotCPP) 
{
 int ret ;
 
  //Display() ; //Make sure ClassWiz is the active window.
  //if(MST.WFndWndWait(GetLocString(IDSS_WORKBENCH_TITLEBAR), FW_FULL, 1)){
  // 	 MST.WButtonClick(GetLocString(IDSS_OK));
  //	 MST.WButtonClick(GetLocString(IDSS_CANCEL));
  //}
 if (m_AddClassDlg.Show()) 
 {
	if(Name.IsEmpty())
	{
		MST.WComboItemText(GetLabel(CLSWIZ_IDC_CLASSTEMPLATE), TypeIndex, Name) ;
		Name.MakeUpper() ;
	 }
	 ret = m_AddClassDlg.SetType(TypeIndex); 
	 if (ret == ERROR_ERROR)
		{
		MST.DoKeys("{ESC}") ;
		return ERROR_ERROR ;
	  }                                              
	 m_AddClassDlg.SetName(Name) ;
	 m_AddClassDlg.SetHeader(DotH) ;
	 m_AddClassDlg.SetCPP(DotCPP) ;
	 m_AddClassDlg.AttachDlgID() ;
	// #ifdef ODBC_OLE
	 if (m_AddClassDlg.CheckOle() == ERROR_SUCCESS)
	 {
		m_AddClassDlg.CheckOle() ;
	 }
	 //#endif 

	 if (m_AddClassDlg.Create() != ERROR_SUCCESS) // If we got an error message 
		{
		MST.DoKeys("{ESC}") ;
		return -99;
		}
	 return ERROR_SUCCESS ;
 }
 else
 {
	 LOG->RecordInfo("Could not open Add Class dialog.");
	 return ERROR_ERROR ;
 }

}


	// Name = ""  Derive from Class type 
	// DotH = "", DotCPP ="" Use default
// BEGIN_HELP_COMMENT
// Function: int UIClassWizard::AddClass(CString BaseClassName,CString Name,  CString DotH, CString DotCPP) 
// Description: Add a new class the project via ClassWizard.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param:  BaseClassName: A base class name
// Param: Name A CString that contains the name of the new class.
// Param: DotH A CString that contains the name of the header file for the new class.
// Param: DotCPP A CString that contains the name of the source file for the new class.
// END_HELP_COMMENT
int UIClassWizard::AddClass2(CString BaseClassName,CString Name,  CString DotH, CString DotCPP) 
{
 int ret ;
 
 Display() ; //Make sure ClassWiz is the active window.

// define TypeIndex;
 int TypeIndex=0;
 CString str;	

 if (m_AddClassDlg.Show()) 
 {
    for (int i=1; i<=MST.WComboCount(GetLabel(CLSWIZ_IDC_CLASSTEMPLATE)); i++)
	{
	  MST.WComboItemText(GetLabel(CLSWIZ_IDC_CLASSTEMPLATE), i, str) ;
	  if( str.Find(BaseClassName) != -1 )
	  {
		  TypeIndex = i;
		  break;
	  }
	}

	if(Name.IsEmpty())
	{
	  MST.WComboItemText(GetLabel(CLSWIZ_IDC_CLASSTEMPLATE), TypeIndex, Name) ;
		Name.MakeUpper() ;
	 }
	 ret = m_AddClassDlg.SetType(TypeIndex); 
	 if (ret == ERROR_ERROR)
		{
		MST.DoKeys("{ESC}") ;
		return ERROR_ERROR ;
	  }                                              
	 m_AddClassDlg.SetName(Name) ;
	 m_AddClassDlg.SetHeader(DotH) ;  
	 m_AddClassDlg.SetCPP(DotCPP) ;	  
	 m_AddClassDlg.AttachDlgID() ;
	// #ifdef ODBC_OLE
	 if (m_AddClassDlg.CheckOle() == ERROR_SUCCESS)
	 {
		m_AddClassDlg.CheckOle() ;
	 }
	 //#endif 

	 if (m_AddClassDlg.Create() != ERROR_SUCCESS) // If we got an error message 
		{
		MST.DoKeys("{ESC}") ;
		return -99;
		}
	 return ERROR_SUCCESS ;
 }
 else
 {
	 LOG->RecordInfo("Could not open Add Class dialog.");
	 return ERROR_ERROR ;
 }

}


// BEGIN_HELP_COMMENT
// Function: int UIClassWizard::ImportClass(CString Name, CString DotH, CString DotCPP) 
// Description: Import an existing class into the project via ClassWizard.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: Name A CString containing the name of the new class.
// Param: DotH A CString containing the name of the header file for the class.
// Param: DotCPP A CString containing the name of the source file for the class.
// END_HELP_COMMENT
int UIClassWizard::ImportClass(CString Name,  CString DotH, CString DotCPP) 
{
	UIImportOrCreateDlg ImpCrDlg ;

	ImpCrDlg.Show() ;
	ImpCrDlg.AddImport() ;
	//if(!WaitForWndWithCtrl(CLSWIZ_IDC_CPPFILENAME,1500))
//              return FALSE ;
	return TRUE ;

}


// BEGIN_HELP_COMMENT
// Function: int UIClassWizard::EditCode()
// Description: Select the Edit Code button the Message Map tab in ClassWizard.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// END_HELP_COMMENT
int UIClassWizard::EditCode()
{
    WaitForInputIdle(g_hTargetProc, 60000);
	ShowPage(TAB_MESSAGEMAP, 8);
	MST.WButtonClick(GetLabel(CLSWIZ_ID_GOTOCODE));
    if (WaitForWndWithCtrl(6,500) || WaitForWndWithCtrl(8,500)) // If prompted to reload the file (bug)
		MST.DoKeys("{ENTER}") ;
	return ERROR_SUCCESS ;
}                                                                                                  

// BEGIN_HELP_COMMENT
// Function: CString UIClassWizard::GetClassFile()
// Description: Get the name of the source file for the currently selected class in ClassWizard.
// Return: A CString containing the name of the source file for the currently selected class.
// END_HELP_COMMENT
CString UIClassWizard::GetClassFile()
{
	HWND hWnd = ControlOnPropPage(CLSWIZ_IDC_FILES) ;
	CString FileName ;
	CString tmp= GetLabel(CLSWIZ_IDC_FILES) ;
	int i = tmp.Find(",") ;                                                                    
	FileName = tmp.Mid(i+2) ;
	return FileName ;
}

// BEGIN_HELP_COMMENT
// Function: int UIClassWizard::SetDataSourceName()
// Description: Set the datasource name to be used when creating Database classes.
// Return: void. 
// END_HELP_COMMENT
void UIClassWizard::SetDataSourceName(CString Name)
{
	m_AddClassDlg.SetDataSourceName(Name) ;         
}

// BEGIN_HELP_COMMENT
// Function: CString UIClassWizard::GetActiveClass()
// Description: Get the name of the currently selected class in ClassWizard.
// Return: A CString that contains the name of the currently selected class.
// END_HELP_COMMENT
CString UIClassWizard::GetActiveClass()
{
	CString Class  = "																		";
	MST.WComboItemText(GetLabel(CLSWIZ_IDC_CLASSBOX),m_ActiveClass, Class) ;
	return Class ;
}

UIAddMethod * UIClassWizard::AddOleMethod() 
{
	if (m_AutoDlg) // Delete this object if we already have had one.
		delete (m_AutoDlg) ;
	UIAddMethod *  MthdDlg = new UIAddMethod ;

	ShowPage(TAB_OLE_AUTOMATION, 8);
	MST.WButtonClick(GetLabel(CLSWIZ_ID_ADDMETHOD)) ;
    WaitForInputIdle(g_hTargetProc, 60000);
	m_AutoDlg = (UIAutomationDlg * ) MthdDlg ;
	return MthdDlg ;
}

UIMemVarDlg * UIClassWizard::AddMemberVar(int index) 
{
	if (m_AddMemDlg) // Delete this object if we already have had one.
		delete (m_AddMemDlg) ;
		m_AddMemDlg = new UIMemVarDlg ;

	ShowPage(TAB_MEMBER_VARIABLES, 8);

	MST.WListItemClk(GetLabel(CLSWIZ_IDC_THINGLIST), index) ;
	MST.WButtonClick(GetLabel(CLSWIZ_ID_ADDVAR)) ;
    WaitForInputIdle(g_hTargetProc, 60000);
	return m_AddMemDlg ;
}

UIMemVarDlg * UIClassWizard::AddMemberVar(CString CtrId) 
{
	if (m_AddMemDlg) // Delete this object if we already have had one.
		delete (m_AddMemDlg) ;
		m_AddMemDlg = new UIMemVarDlg ;

	ShowPage(TAB_MEMBER_VARIABLES, 8);

	MST.WListItemClk(GetLabel(CLSWIZ_IDC_THINGLIST), CtrId) ;
	MST.WButtonClick(GetLabel(CLSWIZ_ID_ADDMETHOD)) ;
    WaitForInputIdle(g_hTargetProc, 60000);
	return m_AddMemDlg ;
}

int UIClassWizard::GetControlCount() 
{
	ShowPage(TAB_MEMBER_VARIABLES, 8);
	return MST.WListCount(GetLabel(CLSWIZ_IDC_THINGLIST)) ;
}

UIAddProperty * UIClassWizard::AddOleProperty() 
{
	if (m_AutoDlg) // Delete this object if we already have had one.
		delete (m_AutoDlg) ;

	UIAddProperty *  PropDlg = new UIAddProperty ;

	ShowPage(TAB_OLE_AUTOMATION, 8);
	MST.WButtonClick(GetLabel(CLSWIZ_ID_ADD_PROP)) ;
    WaitForInputIdle(g_hTargetProc, 60000);
	m_AutoDlg = (UIAutomationDlg * ) PropDlg ;
	return PropDlg ;
}

UIAddEvent * UIClassWizard::AddOleEvent() 
{
	if (m_AutoDlg) // Delete this object if we already have had one.
		delete (m_AutoDlg) ;

	UIAddEvent *  evntDlg = new UIAddEvent ;
	ShowPage(TAB_OLE_EVENTS, 8);
	MST.WButtonClick(GetLabel(CLSWIZ_ID_ADD_CUSTOM)) ;
    WaitForInputIdle(g_hTargetProc, 60000);
	m_AutoDlg = (UIAutomationDlg *) evntDlg ;
	return evntDlg ;
}

// BEGIN_HELP_COMMENT
// Function: int UIAddClassDlg::Show()
// Description: Display the Create New Class dialog from ClassWizard.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// END_HELP_COMMENT
BOOL UIAddClassDlg::Show()
{
	HWND DevStudHnd = MST.WFndWndWait(GetLocString(IDSS_CLW_TITLE),FW_PART,60); //GetLocString(IDSS_WORKBENCH_TITLEBAR)
    if(!DevStudHnd) return FALSE; 
	//Sleep(2000);
	CString strGotoMenuItem = GetLocString(IDS_CLSWZ_NEWCLASS);
	HWND hWnd = ControlOnPropPage(CLSWIZ_ID_ADDCLASS) ;
	if ((GetSystem() & SYSTEM_WIN) || (GetSystem() & SYSTEM_NT)) 
	{
		//*****WMenuEnabled commented out for work around for bug #12931
		//make sure focus is on msdev ide
		//MST.QueSetFocus(DevStudHnd);
		MST.WButtonClick(GetLabel(CLSWIZ_ID_ADDCLASS, hWnd,TRUE)) ;
		//if (!MST.WMenuEnabled(strGotoMenuItem))
		//{
		//	LOG->RecordInfo("Menu item %s doesn't exist or is disabled",strGotoMenuItem);
		//	return FALSE;
		//}
		//else
		//{
			MST.DoKeys("{DOWN}") ;
			MST.DoKeys("{ENTER}") ;
		//}
	}
	Sleep(2000);

	if(!WaitForWndWithCtrl(CLSWIZ_IDC_CLASSTEMPLATE,3000))
	{
		return FALSE ;
	}
	else
	{
		return TRUE ;
	}
	
}

// BEGIN_HELP_COMMENT
// Function: int UIAddClassDlg::SetType(int Type) 
// Description: Set the the base class of the new class in the Create New Class dialog.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: Type An integer that contains the 1-based index into the list of base classes.
// END_HELP_COMMENT
int UIAddClassDlg::SetType(int Type) 
{
	if (MST.WComboCount(GetLabel(CLSWIZ_IDC_CLASSTEMPLATE)) < Type )
		return ERROR_ERROR ;

	MST.WComboSetFocus(GetLabel(CLSWIZ_IDC_CLASSTEMPLATE) ) ;
	MST.DoKeys("{F4}"); ;
	MST.WComboItemClk(GetLabel(CLSWIZ_IDC_CLASSTEMPLATE), Type) ;
	if(MST.WComboIndex(GetLabel(CLSWIZ_IDC_CLASSTEMPLATE)) != Type)
		return ERROR_ERROR ;
	return ERROR_SUCCESS ;
} 

// BEGIN_HELP_COMMENT
// Function: int UIAddClassDlg::SetName(CString Name)
// Description: Set the name of the class in the Create New Class dialog.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: Name A CString containing the name of the new class.
// END_HELP_COMMENT
int UIAddClassDlg::SetName(CString Name)
{
 // If the name has space, use the first half.
 Name = Name.SpanExcluding(" ") ;
 MST.WEditSetText(GetLabel(CLSWIZ_IDC_CLASSNAME),Name) ;

 return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: int UIAddClassDlg::SetHeader(CString DotH)
// Description: Set the name of the header file for the new class in the Create New Class dialog.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: DotH A CString that contains the name of the new header file.
// END_HELP_COMMENT
int UIAddClassDlg::SetHeader(CString DotH)
{  // ToDo: SetCPP doesn't  work properly : it should use the Change Files dialog
if (!DotH.IsEmpty())
	MST.WEditSetText(GetLabel(CLSWIZ_IDC_HFILENAME),DotH) ;
return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: int UIAddClassDlg::SetCPP(CString DotCPP)
// Description: Set the name of the source file for the new class in the Create New Class dialog.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: DotCPP A CString that contains the name of the new header file.
// END_HELP_COMMENT
int UIAddClassDlg::SetCPP(CString DotCPP)
{  // ToDo: SetCPP doesn't  work properly : it should use the Change Files dialog
 if (!DotCPP.IsEmpty())
	MST.WEditSetText(GetLabel(CLSWIZ_IDC_CPPFILENAME),DotCPP) ;
 return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: int UIAddClassDlg::SetDataSourceName()
// Description: Set the datasource name to be used when creating Database classes.
// Return: void. 
// END_HELP_COMMENT
void UIAddClassDlg::SetDataSourceName(CString Name)
{
	m_DBdlgs.SetDataBasePath(Name) ;                
}




// BEGIN_HELP_COMMENT
// Function: int UIAddClassDlg::Create()
// Description: Create the new class in the current project by clicking the Create button in the Create New Class dialog.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// END_HELP_COMMENT
int UIAddClassDlg::Create()
{
	MST.WButtonClick(GetLabel(IDOK)) ;
	if(MST.WFndWndWait(GetLocString(IDSS_WORKBENCH_TITLEBAR), FW_FULL, 2)){
		MST.WButtonClick(GetLocString(IDSS_OK));
		MST.WButtonClick(GetLocString(IDSS_CANCEL));
	}

	// If more information is required, or if duplicate classname then we return with error 
	if(WaitForWndWithCtrl(8,500) || WaitForWndWithCtrl(3,500))
	{
		MST.DoKeys("{ENTER}") ;
		return -99 ;
	} 
	if(WaitForWndWithCtrl(CLSWIZ_IDC_ODBC_SOURCES,500)) // if a Database classs.
	{
	//#ifndef ODBC_OLE
	//MST.DoKeys("{ESC 2}") ;
	//       return -98 ; 
	//#endif ODBC_OLE

	//      m_DBdlgs.WaitForSources() ;
	m_DBdlgs.Sources.SetDAOName(m_DBdlgs.GetDataBasePath()) ;
	m_DBdlgs.Sources.Close() ;

	//      m_DBdlgs.WaitForLogin() ;
	/*      m_DBdlgs.login.ID("sa") ;
		m_DBdlgs.login.Pw("") ;
		m_DBdlgs.login.Close() ;
	
	*/  
	m_DBdlgs.WaitForTables() ;
	m_DBdlgs.tables.Name(1) ;
	MST.DoKeys("{ENTER}") ;
  
	/* MST.DoKeys("{ESC 2}") ;
	 return -98 ; */
	} 
	if(WaitForWndWithCtrl(CLSWIZ_IDC_CLASSNAME,500)) // if a Database classs.
	{
	// Take the default recordset.
		int recSetCnt = MST.WComboCount(GetLabel(CLSWIZ_IDC_CLASSNAME)) ;
		if (recSetCnt<= 1) // If there is no recordset, created a new one.
		{   
			// Support for the new functionality of displaying the Classwizard dialog twice.
			static int cnt = 0 ;
			CString num ;
			num.Format("%i",cnt) ;
			CString name = "CRecSet" ;
			name+=num ;
			cnt++ ;
			MST.WButtonClick(GetLabel(CLSWIZ_ID_ADD));
			
			// Wait for the second instance of ClassWizard
			if(!WaitForWndWithCtrl(CLSWIZ_IDC_CLASSTEMPLATE,1500))
				return ERROR_ERROR ;
			SetName(name) ;
			MST.DoKeys("{ENTER}") ;
			if(!WaitForWndWithCtrl(CLSWIZ_IDC_ODBC_SOURCES,500)) // if a Database classs.
				return ERROR_ERROR ;
			m_DBdlgs.Sources.SetDAOName(m_DBdlgs.GetDataBasePath()) ;
			m_DBdlgs.Sources.Close() ;
			m_DBdlgs.WaitForTables() ;
			m_DBdlgs.tables.Name(1) ;
		}

		MST.DoKeys("{ENTER}") ;
	} 
	return ERROR_SUCCESS ;
}

// BEGIN_HELP_COMMENT
// Function: int UIAddClassDlg::CheckOle()
// Description: Select the OLE automation for the new class in the Create New Class dialog.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// END_HELP_COMMENT
int UIAddClassDlg::CheckOle(OLE_TYPE OleType/*= ID_OLE */)
{
		MST.WOptionClick(GetLabel(OleType));
		return ERROR_SUCCESS ;
}

// BEGIN_HELP_COMMENT
// Function: int UIAddClassDlg::CheckOleCreateable(CString ExtName) 
// Description: Select OLE automation createable by name for the new class in the Create New Class dialog. This function is NYI.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: ExtName A CString that contains the name.
// END_HELP_COMMENT
int UIAddClassDlg::CheckOleCreateable(CString ExtName) 
{
//      if(MST.WCheckEnabled(GetLabel(CLSWIZ_IDC_CREATEABLE)))
//      {
//              MST.WCheckCheck(GetLabel(CLSWIZ_IDC_CREATEABLE));
//              MST.WEditSetText(GetLabel(CLSWIZ_IDC_EXTERNAL_NAME),ExtName) ;
//              return ERROR_SUCCESS ;
//      }
//      return ERROR_ERROR ;    
	ASSERT(FALSE); return ERROR_ERROR;
}

// BEGIN_HELP_COMMENT
// Function: int UIAddClassDlg::CheckAddToGallery(BOOL bCheck /*= TRUE */)
// Description: Checks or unchecks the Add To Object Gallery check box.
// Return: ERROR_SUCCESS or ERROR_ERROR if it failed to do the operation.
// Param: If bCheck is TRUE it makes sure the check box is check. Otherwise it uncheck it if necessary.
// END_HELP_COMMENT
int UIAddClassDlg::CheckAddToGallery(BOOL bCheck /*= TRUE */)
{
	if(MST.WCheckEnabled(GetLabel(CLSWIZ_IDC_ADD_TO_OG)))
	{
		if (bCheck)
			MST.WCheckCheck(GetLabel(CLSWIZ_IDC_ADD_TO_OG));
		else
			MST.WCheckUnCheck(GetLabel(CLSWIZ_IDC_ADD_TO_OG));

		return ERROR_SUCCESS ;
	}
	return ERROR_ERROR ;
}


// BEGIN_HELP_COMMENT
// Function: int UIAddClassDlg::AttachDlgID(int index /*= 1 */)
// Description: Select the dialog (by ID) that's to be associated with the new class in the Create New Class dialog. (See AttachDlgID(CString) to associate dialog by name.)
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: index An integer that contains the 1-based index into the list of dialog templates used to specify the dialog associated with the new class.
// END_HELP_COMMENT
int UIAddClassDlg::AttachDlgID(int index /*= 1 */)
{
	if (MST.WComboEnabled(GetLabel(CLSWIZ_IDC_RESOURCE)))
 
	{
		MST.WComboSetFocus(GetLabel(CLSWIZ_IDC_RESOURCE) );
		MST.DoKeys("{F4}");
		MST.WComboItemClk(GetLabel(CLSWIZ_IDC_RESOURCE), index) ;
		return ERROR_SUCCESS ;
	}

	return ERROR_ERROR ;
}

// BEGIN_HELP_COMMENT
// Function: int UIAddClassDlg::AttachDlgID(CString Name) 
// Description: Select the dialog (by name) that's to be associated with the new class in the Create New Class dialog. (See AttachDlgID(int) to associate dialog by index.)
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: Name A CString that contains the name of the dialog template used to specify the dialog associated with the new class.
// END_HELP_COMMENT
int UIAddClassDlg::AttachDlgID(CString Name) 
{
if (MST.WComboEnabled(GetLabel(CLSWIZ_IDC_RESOURCE)))
 
	{
		MST.WComboSetFocus(GetLabel(CLSWIZ_IDC_RESOURCE) );
		MST.DoKeys("{F4}");
		MST.WComboItemClk(GetLabel(CLSWIZ_IDC_RESOURCE),Name) ;
		return ERROR_SUCCESS ;
	}

	return ERROR_ERROR ;

}

int UIImportOrCreateDlg::Show()
{
	HWND hWnd = ControlOnPropPage(CLSWIZ_ID_ADDCLASS) ;
	MST.WButtonClick(GetLabel(CLSWIZ_ID_ADDCLASS, hWnd,TRUE)) ;
	if(!WaitForWndWithCtrl(CLSWIZ_IDC_CREATECLASS,1500))
		return FALSE ;
	return TRUE ; 
}             

void UIImportOrCreateDlg::AddNew()
{
	MST.WOptionClick(GetLabel(CLSWIZ_IDC_CREATECLASS)) ;
	MST.WButtonClick(GetLabel(IDOK)) ;
	return ;
}             

void UIImportOrCreateDlg::AddImport() 
{
	MST.WOptionClick(GetLabel(CLSWIZ_IDC_IMPORT)) ; 
	MST.WButtonClick(GetLabel(IDOK)) ;
	return ;
}             

HWND UIImportOrCreateDlg::Cancel()
{
	return UIDialog::Cancel() ;
}             
           
int UIAutomationDlg::SetExtName(CString Name)
{
	// Remove the '_' from the Name.ddk_dkdkd_dkdk_dk

	CString temp = Name.SpanExcluding("_") ;
	int cnt ;
	while((cnt = Name.Find("_")) != -1)
	{       
		Name = Name.Right(Name.GetLength()-(cnt+1)) ;
		temp += Name.SpanExcluding("_") ;
	}
	Name = temp ;
	LPCSTR labelName = GetLabel(CLSWIZ_IDC_OLE_NAME); //delete this line
	MST.WComboSetText(GetLabel(CLSWIZ_IDC_OLE_NAME),Name) ;
	return ERROR_SUCCESS ;
}
int UIAutomationDlg::SetExtName(int Index)
{
	CString Name(' ',32);
	MST.WComboItemText(GetLabel(CLSWIZ_IDC_OLE_NAME),Index,Name) ;
	MST.WComboSetText(GetLabel(CLSWIZ_IDC_OLE_NAME),Name) ;
	return ERROR_SUCCESS ;
}

int UIAutomationDlg::SetImplementation(IMPLEMENTATION Type /* = STOCK*/) 
{
	
	switch (Type)
	{
		case STOCK:
			MST.WOptionClick(GetLabel(CLSWIZ_IDC_PREIMPLEMENT));
			break ;
		case CUSTOM:
			MST.WOptionClick(GetLabel(CLSWIZ_IDC_CUSTOM));
			break ;
		case MEMBER_VAR:
			MST.WOptionClick(GetLabel(CLSWIZ_IDC_MEMBERVAR));
			break ;
			
		case GET_SET_MEHOD:
			MST.WOptionClick(GetLabel(CLSWIZ_IDC_GETSET_METHODS));
			break ;
		default:
			MST.WOptionClick(GetLabel(CLSWIZ_IDC_CUSTOM));
	}
	return ERROR_SUCCESS ;
}

CString UIAutomationDlg::SetReturnType(int Index) 
{
	CString Name(' ',30) ;
	MST.WComboSetFocus(GetLabel(CLSWIZ_IDC_RETURN_TYPE));
	MST.DoKeys("{F4}");
	MST.WComboItemDblClk(GetLabel(CLSWIZ_IDC_RETURN_TYPE),Index) ;
	MST.WComboItemText(GetLabel(CLSWIZ_IDC_RETURN_TYPE),Index,Name) ;
	return Name ;
}


int UIAutomationDlg::GetStockCount() 
{       
	return MST.WComboCount(GetLabel(CLSWIZ_IDC_OLE_NAME)) ; 
}

int UIAutomationDlg::GetRetTypeCount() 
{       
	return MST.WComboCount((GetLabel(CLSWIZ_IDC_RETURN_TYPE))) ; 
}

int UIAutomationDlg::ParamTypeCount() 
{
	MST.WComboCount((GetLabel(CLSWIZ_IDC_RETURN_TYPE))) ; 
	MST.DoKeys("{DOWN}") ;
	MST.DoKeys("TEST");//"TEST is just a place holder so we can access the return types
	MST.DoKeys("{TAB}") ;
	return MST.WComboCount((GetLabel(CLSWIZ_IDC_RETURN_TYPE)));
}

int UIAutomationDlg::AddParameter(int Type, CString Name /*= "NULL"*/) 
{
	//Currently the Add Method dialog of the Class Wizard
	//hass problems.
	//Apparently the Parameter list has no string Label associated with it
	//so WListItemClk and WComboItemClk and WComboText fall fail because
	//(GetLabel(CLSWIZ_IDC_PARAM_LIST) returns NULL instead of a pointer to
	//&Parameter list: which is expected by looking at the Class Wizard's RC file
	//To make matters worse, if the External Name field is selected and F4 is used to
	//select a Member function name, then Alt-P doesn't switch
	//focus to the Parameter List
	//THEREFORE, you have focus in the Parameter list prior to calling AddParameter.
	//AND all parameters will be given type short.  Icky, huh?
	//A-RCahn 9-19-1997
	CString ParamName(' ',30) ;
//	MST.WListItemClk("&Parameter list:",Type) ;
//	MST.WListItemClk(GetLabel(CLSWIZ_IDC_PARAM_LIST),Type) ;
//	MST.DoKeys("TEST");
//	MST.DoKeys("{TAB}") ;
//	MST.DoKeys("%(p)");
	//These really aren't doing anything, but they should.
	MST.DoKeys("%(p)");
	MST.DoKeys("{DOWN}") ;
	MST.WComboItemClk("&Parameter list:",Type);
	if (Name == "NULL")
	{
		CString count ;
		count.Format("%d",Type);

		MST.WComboText(GetLabel(CLSWIZ_IDC_PARAM_LIST),ParamName) ;

		// Remove the "*" pointer specifier and replace it with Ptr.
		if(ParamName.Find("*") != -1)
		{       
			ParamName= ParamName.SpanExcluding("*") ;
			ParamName += "Ptr" ;
		}
		ParamName = ParamName +"Param"+count ;
	}
	else 
		ParamName = Name ;
	MST.DoKeys("{ENTER}") ;
	MST.DoKeys("A") ;
	MST.WEditSetText(NULL,ParamName) ;
	MST.DoKeys("{ENTER}") ;
	return ERROR_SUCCESS ;
}

int UIAutomationDlg::Create() 
{
	
	MST.WButtonClick("OK") ;
	return ERROR_SUCCESS ;
}

int UIMemVarDlg::CategoryCount() 
{
	
	return MST.WComboCount(GetLabel(CLSWIZ_IDC_PROPBOX)) ;
}

int UIMemVarDlg::SetVarName(CString Name) 
{
	Name = Name.SpanExcluding(" ") ;
	MST.WEditSetText(GetLabel(CLSWIZ_IDC_MEMBERNAME_EDIT),Name) ;
	return ERROR_SUCCESS ;
}

int UIMemVarDlg::SetCategory(int index) 
{
	if (MST.WComboCount(GetLabel(CLSWIZ_IDC_PROPBOX)) < index )
		return ERROR_ERROR ;

	CString Name;
	MST.WComboItemText(GetLabel(CLSWIZ_IDC_PROPBOX), index, Name) ;
	MST.WComboSetText(GetLabel(CLSWIZ_IDC_PROPBOX), Name) ;
	MST.WComboItemClk(GetLabel(CLSWIZ_IDC_PROPBOX), index) ;
	return ERROR_SUCCESS ;
}

CString UIMemVarDlg::GetCategory(int index) 
{
	if (MST.WComboCount(GetLabel(CLSWIZ_IDC_PROPBOX)) < index )
		return ERROR_ERROR ;

	CString Name;
	MST.WComboItemText(GetLabel(CLSWIZ_IDC_PROPBOX), index, Name) ;
	return Name ;
}


int UIMemVarDlg::SetType(int index)  
{
	
	if (MST.WComboCount(GetLabel(CLSWIZ_IDC_TYPEBOX)) < index )
		return ERROR_ERROR ;

	CString Name;
	MST.WComboItemText(GetLabel(CLSWIZ_IDC_TYPEBOX), index, Name) ;
	MST.WComboSetText(GetLabel(CLSWIZ_IDC_TYPEBOX), Name) ;
	MST.WComboItemClk(GetLabel(CLSWIZ_IDC_TYPEBOX), index) ;
	return ERROR_SUCCESS ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\uictrlwz.h ===
///////////////////////////////////////////////////////////////////////////////
//  UICTRLWZ.H
//
//  Created by :            Date :
//      Ivanl             10/14/94
//
//  Description :
//      Declaration of the UICtrlWizard class
//

#ifndef __UICTRLWZ_H__
#define __UICTRLWZ_H__

#include "..\sym\ctrlwz.h"
#include "uprojwiz.h"
#include "prjxprt.h"

#ifndef __UPROJWIZ_H__
	#error include 'uprojwiz.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//  UICtrlWizard class

///////////////////////////////////////////////////////////////////////////////
// enum EXTWIZ_TYPES { EXTWIZ_CUSTOM, EXTWIZ_APWZ_CLONE, EXTWIZ_PROJ_BASED } ;

// The summary info dialog of ControlWizard defined below
class PRJ_CLASS UICtrlSummaryDlg : public UIDialog 
	{
    UIWND_COPY_CTOR (UICtrlSummaryDlg, UIDialog) ; 

// Private data
    private:
			CString m_ActiveCtrl ;
// General Utilities
	public:
		inline CString ExpectedTitle(void) const
		{ return ("Summary Info"); }// REVIEW : LOCALIZATION 
		
		HWND Display(void) ;
		int SetShortName(CString Name) ;
		int SetCrlClsName(CString Name) ;
		int SetCtrlHName(CString Name) ;
		int SetCtrlCppName(CString Name) ;
		int SetCtrlUsrName(CString Name) ;
		int SetCtrlIDName(CString Name) ;
		int SetPpgClsName(CString Name) ;
		int SetPpgHName(CString Name) ;
		int SetPpgCppName(CString Name) ;
		int SetPpgUsrName(CString Name) ;
		int SetPpgIDName(CString Name) ;
		int Close(int how = 1) ;
   };
					
// BEGIN_CLASS_HELP
// ClassName: UICtrlWizard
// BaseClass: UIProjectWizard
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS UICtrlWizard : public UIProjectWizard 
	{
    UIWND_COPY_CTOR (UICtrlWizard, UIProjectWizard) ; 

// Private data
    private:
	int m_ActiveCtrl ;
	CString m_strPageTitles[2];


// General Utilities
	public:
		UICtrlSummaryDlg SumDlg ;

		virtual CString ExpectedTitle(int page);
		virtual void OnUpdate(void);

		virtual HWND Create(void);
		BOOL SetCount(int count) ;
	   	BOOL SetLicenceOpt(int iLic) ;
		BOOL SetCommentOpt(int icomm) ;
		BOOL SetHelpOpt(int iHelp) ;
		BOOL SetActive(int index) ;
		BOOL SetActive(CString strAct) ;

		BOOL SummaryInfo() ;
		BOOL ActiveIfVisible(int opt) ;
		BOOL Invisible(int opt) ;
		BOOL InInsertDlg(int opt) ;
		BOOL SimpleFrame(int opt) ;
		BOOL SubClassCtrl(int index) ;
		BOOL SubClassCtrl(CString strcls) ;

		CString GetActive() ;
   } ;

#endif //__UICTRLWZ_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\ucwzdlg.h ===
///////////////////////////////////////////////////////////////////////////////
//  UITABDLG.H
//
//  Created by :            Date :
//      Ivanl             1/27/94
//
//  Description :
//      Declaration of the UIClassWizard class
//

#ifndef __UCWZDLG_H__
#define __UCWZDLG_H__
#include "odbcdlgs.h"
#include "..\sym\clswiz.h"
#include "..\sym\vcpp32.h"
#include "..\shl\uitabdlg.h"

#include "prjxprt.h"

#ifndef __UITABDLG_H__
	#error include 'uitabdlg.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//  UIClassWizard class

//	Tools Options tabs	 (These are acually unique control id's found in each page) REVIEW: Use True tab id's
typedef enum{ TAB_CLASSINFO= CLSWIZ_IDC_RESOURCENAME, 
			  TAB_MESSAGEMAP= CLSWIZ_IDC_MESSAGELIST, 
			  TAB_OLE_AUTOMATION=CLSWIZ_IDC_DATA_BINDING, 
			  TAB_OLE_EVENTS= CLSWIZ_ID_ADD_CUSTOM, 
			  TAB_MEMBER_VARIABLES = CLSWIZ_ID_BIND_ALL } ;
typedef enum{ NO_OLE = CLSWIZ_IDC_NO_OLE, AUTOMATION = CLSWIZ_IDC_OLE_AUTO, ID_OLE = CLSWIZ_IDC_OLE_CREATE } OLE_TYPE ;
// The implementation types for OLE Events, Methods, and properties.
typedef enum  {STOCK,CUSTOM,MEMBER_VAR,GET_SET_MEHOD} IMPLEMENTATION ;
#define ID_NODELETE	05 
#define IDSS_CW_TITLE "MFC ClassWizard"   // Move this to .RC

// Control ID's for Directories Page  ( original id's defined in vproj.h)
///////////////////////////////////////////////////////////////////////////////
 
class PRJ_CLASS UIAutomationDlg : public UIDialog 
	{
    UIWND_COPY_CTOR (UIAutomationDlg, UIDialog) ; 

// General Utilities
	public:
			inline CString ExpectedTitle(void) const
			{ return (""); }		// Options
		         
			virtual int SetExtName(int TypeIndex) ;
			virtual int SetExtName(CString Name) ; 
			virtual int SetImplementation(IMPLEMENTATION STOCK) ;     
			virtual int SetIntName(CString Name) {return NULL;} ;             
			virtual int SetReturnType(CString Type) {return NULL;} ;      
			virtual CString SetReturnType(int Index) ;   
			virtual int AddParameter(int Type, CString Name = "NULL") ;
			virtual int ParamTypeCount() ;
			virtual int GetRetTypeCount() ;
			virtual int GetStockCount() ;
			virtual int Create() ;             
 } ; 


class PRJ_CLASS UIMemVarDlg : public UIDialog 
	{
    UIWND_COPY_CTOR (UIMemVarDlg, UIDialog) ; 

// General Utilities
	public:
			inline CString ExpectedTitle(void) const
			{ return (""); }		// Options
		         
			int CategoryCount() ;
			int SetVarName(CString Name) ; 
			int SetCategory(int index) ;     
			int SetType(int index) ; 
  			int SetCategory(CString Strcat) {return ERROR_SUCCESS;};     
			int SetType(CString Type){return ERROR_SUCCESS;} ; 
			CString GetCategory(int index) ;
    			
 } ; 

class PRJ_CLASS UIAddMethod : public UIAutomationDlg 
{
    UIWND_COPY_CTOR (UIAddMethod, UIAutomationDlg) ; 
} ;

class PRJ_CLASS UIAddProperty : public UIAutomationDlg 
{
    UIWND_COPY_CTOR (UIAddProperty, UIAutomationDlg) ; 

} ; 

class PRJ_CLASS UIAddEvent : public UIAutomationDlg 
{
    UIWND_COPY_CTOR (UIAddEvent, UIAutomationDlg) ; 
 } ; 


class PRJ_CLASS UIAddClassDlg : public UIDialog 
	{
    UIWND_COPY_CTOR (UIAddClassDlg, UIDialog) ; 

	UIDataBaseDlgs m_DBdlgs ;
// General Utilities
	public:
			inline CString ExpectedTitle(void) const
			{ return (IDSS_CW_TITLE); }		// Options

			BOOL Show() ;               
			int SetType(int TypeIndex) ;
			int SetName(CString Name) ;        
			int SetHeader(CString DotH) ;      
			int SetCPP(CString DotCPP ) ;
			int CheckOle(OLE_TYPE OleType= ID_OLE);
			int CheckOleCreateable(CString ExtName) ;
			int CheckAddToGallery(BOOL bCheck = TRUE);
			int AttachDlgID(int index = 1) ;
			int AttachDlgID(CString Name) ;
			int Create() ; 
			void SetDataSourceName(CString Name) ;

          
 } ; 
// BEGIN_CLASS_HELP
// ClassName: UIClassWizard
// BaseClass: UITabbedDialog
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS UIClassWizard : public UITabbedDialog 
	{
    UIWND_COPY_CTOR (UIClassWizard, UITabbedDialog) ; 

// Private data
    private:
			int m_ActiveClass ;
			UIAutomationDlg * m_AutoDlg ;
			UIAddClassDlg m_AddClassDlg ;
			UIMemVarDlg * m_AddMemDlg ;
// General Utilities
	public:
			
			inline CString ExpectedTitle(void) const
			{ return (IDSS_CW_TITLE); }		// Options
			
			HWND Display(void) ;
			HWND Close() ;
			virtual void OnUpdate(void);

// Directories 
	public:
			int AddFunction(int ClassIndex, int FuncIndex, LPCSTR szObject);
			int AddFunction(int ClassIndex, int FuncIndex, int ObjectIndex);
			int AddFunction2(int ClassIndex, int FuncIndex, int ObjectIndex);
            int AddClass(int TypeIndex ,CString Name = "", CString DotH = "" , CString DotCPP = "");
            int AddClass2(CString BaseClassName ,CString Name = "", CString DotH = "" , CString DotCPP = "");
			CString GetActiveClass() ;
			int GetClassCount() ;
			int EditCode() ;
			CString GetClassFile() ;
			int DeleteFunction(int ClassIndex, int FuncIndex, int ObjectIndex ) ;
			int ImportClass(CString Name,  CString DotH, CString DotCPP) ;
			UIAddMethod * AddOleMethod() ;
			UIAddProperty *AddOleProperty() ;
			UIAddEvent * AddOleEvent() ;
			UIMemVarDlg * AddMemberVar(int index) ;
			UIMemVarDlg * AddMemberVar(CString CtrId) ;
			int GetControlCount() ;
			void SetDataSourceName(CString Name) ;
   } ;

// BEGIN_CLASS_HELP
// ClassName: UIAddClassDlg
// BaseClass: UIDialog
// Category: Project
// END_CLASS_HELP


// BEGIN_CLASS_HELP
// ClassName: UIImportOrCreateDlg
// BaseClass: UIDialog
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS UIImportOrCreateDlg : public UIDialog 
	{
    UIWND_COPY_CTOR (UIImportOrCreateDlg, UIDialog) ; 

// General Utilities
	public:
			inline CString ExpectedTitle(void) const
			{ return ("Adding a Class"); }// TODO Use String constant not yet available
			
			int Show() ;               
			void AddNew() ;
			void AddImport() ;        
			HWND Cancel();
 } ; 

/* class PRJ_CLASS UIAddMethodDlg : public UIDialog 
	{
    UIWND_COPY_CTOR (UIAddMethodDlg, UIDialog) ; 

// General Utilities
	public:
			inline CString ExpectedTitle(void) const
			{ return (IDSS_CW_TITLE); }		// Options

			int Show() ;               
			int SetType(int TypeIndex) ;
			int SetName(CString Name) ;        
			int SetHeader(CString DotH) ;      
			int SetCPP(CString DotCPP ) ;
			int CheckOle();
			int CheckOleCreateable(CString ExtName) ;
			int AttachDlgID(int index = 1) ;
			int AttachDlgID(CString Name) ;
			int Create() ;             
 } ;  */

#endif //__UCWZDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\uictrlwz.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  uiextwiz.CPP
//
//  Created by :            Date :
//      Ivanl              3/16/95
//				  
//  Description :
//      Implementation of the UICtrlWizard class
//

#include "stdafx.h"
#include "uictrlwz.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\appwz.h"
#include "guiv1.h"
#include "uappwiz.h"
#include "..\shl\uiwbmsg.h"
#include "..\shl\wbutil.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: void UICtrlWizard::OnUpdate(void)
// Description: Initializes members of UICtrlWizard object (called by constructor).
// Return: none.
// END_HELP_COMMENT
void UICtrlWizard::OnUpdate(void)
{
	// set the page titles for later use.
	m_strPageTitles[0] = GetLocString(IDSS_PROJTYPE_OLE_CONTROLWIZ);
    m_strPageTitles[0] += GetLocString(IDSS_AW_TITLE_STEP);
	m_strPageTitles[0] += GetLocString(IDSS_AW_TITLE_1);
	m_strPageTitles[0] += GetLocString(IDSS_AW_TITLE_OF);
	m_strPageTitles[0] += GetLocString(IDSS_AW_TITLE_2);
	m_strPageTitles[1] = GetLocString(IDSS_PROJTYPE_OLE_CONTROLWIZ);
    m_strPageTitles[1] += GetLocString(IDSS_AW_TITLE_STEP);
	m_strPageTitles[1] += GetLocString(IDSS_AW_TITLE_2);
	m_strPageTitles[1] += GetLocString(IDSS_AW_TITLE_OF);
	m_strPageTitles[1] += GetLocString(IDSS_AW_TITLE_2);
}


// BEGIN_HELP_COMMENT
// Function: HWND UICtrlWizard::Create()
// Description: Start the ActiveX ControlWizard sequence from the New Project dialog. The New Project dialog must be displayed before calling this function.
// Return: The HWND of the first page of the ActiveX ControlWizard, if successful; NULL otherwise.
// END_HELP_COMMENT
HWND UICtrlWizard::Create() 
{	
	ExpectPage( UIAW_NEWPROJ );

	SetProjType(GetLocString(IDSS_PROJTYPE_OLE_CONTROLWIZ));
    MST.WButtonClick(GetLabel(IDOK));

   	// Wait five seconds for a "Subdir doesn't exist.  Do you really want to create... blah blah blah" message box.
	if (WaitMsgBoxText(GetLocString(IDSS_CREATE_DIR_PROMPT), 5))
		MST.WButtonClick(GetLabel(MSG_YES));	// Go ahead and say it's ok to create it.

	// Wait around until the Wizard dialog is displayed.
	
	Sleep(2000) ;
	HWND hwnd;
	if (hwnd = MST.WFndWndWait(GetLocString(IDSS_PROJTYPE_OLE_CONTROLWIZ), FW_ALL|FW_NOCASE|FW_PART|FW_FOCUS, 5))
	{
		LOG->Comment("Found '%s'", GetLocString(IDSS_PROJTYPE_OLE_CONTROLWIZ));
		MST.WSetActWnd(hwnd) ;

		RECT rcPage;
		GetClientRect(hwnd, &rcPage);
		ClickMouse( VK_LBUTTON ,hwnd, rcPage.left+50, rcPage.top - 15 );	  // Click on first Tab	(left most)
		ClickMouse( VK_LBUTTON ,hwnd, rcPage.left+50, rcPage.top - 15 );	  // Click on first Tab	(left most)

	}
	if (WaitForWndWithCtrl(IDC_NUMCONTROLS, 2000))
		LOG->RecordInfo("ControlWizard successfully loaded") ;
	else 
		LOG->RecordFailure("Could not load ControlWizard") ;	
  return MST.WGetActWnd(0) ;   
}

// BEGIN_HELP_COMMENT
// Function: BOOL UICtrlWizard::SetCount(int count)
// Description: Set the number of controls in ControlWizard.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: count An integer that contains the number of controls for this project.
// END_HELP_COMMENT
BOOL UICtrlWizard::SetCount(int count) 
{
	CString strCnt;
	strCnt.Format("%d",count) ;
	MST.WEditSetText(GetLabel(IDC_NUMCONTROLS),strCnt);
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UICtrlWizard::SetLicenceOpt(int iLic)
// Description: Set whether or not to include a runtime license with the controls in ControlWizard.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: iLic A Boolean value that indicates whether to include a runtime license (TRUE) or not.
// END_HELP_COMMENT
BOOL UICtrlWizard::SetLicenceOpt(int iLic) 
{
	if(iLic)
		MST.WOptionClick(GetLabel(IDC_LICENSE));
	else
		MST.WOptionClick(GetLabel(IDC_NOLICENSE));
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UICtrlWizard::SetCommentOpt(int icomm)
// Description: Set whether to include source file comments or not in ControlWizard.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: icomm A Boolean value that indicates whether to include source file comments (TRUE) or not.
// END_HELP_COMMENT
BOOL UICtrlWizard::SetCommentOpt(int icomm) 
{
	if(icomm)
		MST.WOptionClick(GetLabel(IDC_COMMENTS));
	else
		MST.WOptionClick(GetLabel(IDC_NOCOMMENTS));
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UICtrlWizard::SetHelpOpt(int icomm)
// Description: Set whether to include help file support or not in ControlWizard.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: icomm A Boolean value that indicates whether to include help file support (TRUE) or not.
// END_HELP_COMMENT
BOOL UICtrlWizard::SetHelpOpt(int icomm) 
{
	if(icomm)
		MST.WOptionClick(GetLabel(IDC_HELPFILES));
	else
		MST.WOptionClick(GetLabel(IDC_NOHELPFILES));
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UICtrlWizard::SetActive(int index)
// Description: Set the active control in ControlWizard.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: index An integer that contains the 1-based index into the list of controls to be generated by ControlWizard.
// END_HELP_COMMENT
BOOL UICtrlWizard::SetActive(int index) 
{	
	CString Name = "												" ;
	MST.WComboItemText(GetLabel(IDC_CTLCOMBO), index, Name) ;
	MST.WComboSetText(GetLabel(IDC_CTLCOMBO), Name) ;
	m_ActiveCtrl = index ;
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: CString UICtrlWizard::GetActive()
// Description: Get the currently selected control in ControlWizard.
// Return: A CString that contains the name of the currently selected control in ControlWizard.
// END_HELP_COMMENT
CString UICtrlWizard::GetActive() 
{	
	CString Name = "												" ;
	MST.WComboItemText(GetLabel(IDC_CTLCOMBO), m_ActiveCtrl, Name) ;
	return Name ;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UICtrlWizard::SummaryInfo()
// Description: Display the summary information for the currently selected control in ControlWizard.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UICtrlWizard::SummaryInfo() 
{
	SumDlg.Display() ;
	return TRUE ;

}

// BEGIN_HELP_COMMENT
// Function: BOOL UICtrlWizard::ActiveIfVisible(int active)
// Description: Set the "Activates when visible" property of the currently selected control.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: active A Boolean value that indicates whether to check (TRUE) or uncheck the "Activates when visible" property.
// END_HELP_COMMENT
BOOL UICtrlWizard::ActiveIfVisible(int active)  
{
	if(active)
		MST.WCheckCheck(GetLabel(IDC_ACTIVATEWHENVISIBLE));
	else
		MST.WCheckUnCheck(GetLabel(IDC_ACTIVATEWHENVISIBLE));
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UICtrlWizard::Invisible(int opt)
// Description: Set the "Invisible at runtime" property of the currently selected control.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: opt A Boolean value that indicates whether to check (TRUE) or uncheck the "Invisible at runtime" property.
// END_HELP_COMMENT
BOOL UICtrlWizard::Invisible(int opt)  
{
	if(opt)
		MST.WCheckCheck(GetLabel(IDC_INVISIBLEATRUNTIME));
	else
		MST.WCheckUnCheck(GetLabel(IDC_INVISIBLEATRUNTIME));
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UICtrlWizard::InInsertDlg(int opt)
// Description: Set the "Available in 'Insert Object' dialog" property of the currently selected control.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: opt A Boolean value that indicates whether to check (TRUE) or uncheck the "Available in 'Insert Object' dialog" property.
// END_HELP_COMMENT
BOOL UICtrlWizard::InInsertDlg(int opt)  
{
	if(opt)
		MST.WCheckCheck(GetLabel(IDC_INSERTABLE));
	else
		MST.WCheckUnCheck(GetLabel(IDC_INSERTABLE));
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UICtrlWizard::SimpleFrame(int opt)
// Description: Set the "Supports simple frame" property of the currently selected control.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: opt A Boolean value that indicates whether to check (TRUE) or uncheck the "Supports simple frame" property.
// END_HELP_COMMENT
BOOL UICtrlWizard::SimpleFrame(int opt)  
{
	if(opt)
		MST.WCheckCheck(GetLabel(IDC_SIMPLEFRAME));
	else
		MST.WCheckUnCheck(GetLabel(IDC_SIMPLEFRAME));
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UICtrlWizard::SubClassCtrl(int index)
// Description: Select the window class by index that the currently selected control should subclass from in ControlWizard. (See SubClassCtrl(CString) to select the window class by name.)
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: index An integer that contains the 1-based index into the list of window classes to subclass from.
// END_HELP_COMMENT
BOOL UICtrlWizard::SubClassCtrl(int index) 
{
	CString Name = "												" ;
	MST.WComboItemText(GetLabel(IDC_BASECLASS), index, Name) ;
	MST.WComboSetText(GetLabel(IDC_BASECLASS), Name) ;
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UICtrlWizard::SubClassCtrl(CString strcls)
// Description: Select the window class by name that the currently selected control should subclass from in ControlWizard. (See SubClassCtrl(int) to select the window class by index.)
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: strcls A CString that contains the name of the window class to subclass from.
// END_HELP_COMMENT
BOOL UICtrlWizard::SubClassCtrl(CString strcls)
{
	MST.WComboSetText(GetLabel(IDC_BASECLASS), strcls) ;
	return TRUE ;
}

// Summary info dialog implementation functions.

// BEGIN_HELP_COMMENT
// Function: BOOL UICtrlSummaryDlg::SetShortName(CString Name)
// Description: Set the short name of the control in the Summary Info dialog in ControlWizard.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: Name A CString that contains the name.
// END_HELP_COMMENT
int UICtrlSummaryDlg::SetShortName(CString Name) 
{
	MST.WEditSetText(GetLabel(IDC_CTLNAME), Name);	
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UICtrlSummaryDlg::SetCrlClsName(CString Name)
// Description: Set the class name of the control in the Summary Info dialog in ControlWizard.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: Name A CString that contains the name.
// END_HELP_COMMENT
int UICtrlSummaryDlg::SetCrlClsName(CString Name) 
{
	MST.WEditSetText(GetLabel(IDC_CTLCLASS), Name);
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UICtrlSummaryDlg::SetCtrlHName(CString Name)
// Description: Set the header filename of the control in the Summary Info dialog in ControlWizard.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: Name A CString that contains the name.
// END_HELP_COMMENT
int UICtrlSummaryDlg::SetCtrlHName(CString Name)
{
	MST.WEditSetText(GetLabel(IDC_CTLIFILE), Name);
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UICtrlSummaryDlg::SetCtrlCppName(CString Name)
// Description: Set the source filename of the control in the Summary Info dialog in ControlWizard.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: Name A CString that contains the name.
// END_HELP_COMMENT
int UICtrlSummaryDlg::SetCtrlCppName(CString Name)
{
	MST.WEditSetText(GetLabel(IDC_CTLIFILE), Name);
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UICtrlSummaryDlg::SetCtrlUsrName(CString Name)
// Description: Set the user type name of the control in the Summary Info dialog in ControlWizard.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: Name A CString that contains the name.
// END_HELP_COMMENT
int UICtrlSummaryDlg::SetCtrlUsrName(CString Name)
{
	MST.WEditSetText(GetLabel(IDC_CTLTYPENAME), Name);
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UICtrlSummaryDlg::SetCtrlIDName(CString Name)
// Description: Set the programmatic ID name of the control in the Summary Info dialog in ControlWizard.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: Name A CString that contains the name.
// END_HELP_COMMENT
int UICtrlSummaryDlg::SetCtrlIDName(CString Name)
{
	MST.WEditSetText(GetLabel(IDC_CTLPROGID), Name);
	return TRUE ;
}

// Prop page functions.	

// BEGIN_HELP_COMMENT
// Function: BOOL UICtrlSummaryDlg::SetPpgClsName(CString Name)
// Description: Set the class name of the property page in the Summary Info dialog in ControlWizard.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: Name A CString that contains the name.
// END_HELP_COMMENT
int UICtrlSummaryDlg::SetPpgClsName(CString Name)
{
	MST.WEditSetText(GetLabel(IDC_PPGCLASS), Name);
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UICtrlSummaryDlg::SetPpgHName(CString Name)
// Description: Set the header filename of the property page in the Summary Info dialog in ControlWizard.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: Name A CString that contains the name.
// END_HELP_COMMENT
int UICtrlSummaryDlg::SetPpgHName(CString Name)
{
	MST.WEditSetText(GetLabel(IDC_PPGHFILE), Name);
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UICtrlSummaryDlg::SetPpgCppName(CString Name)
// Description: Set the source filename of the property page in the Summary Info dialog in ControlWizard.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: Name A CString that contains the name.
// END_HELP_COMMENT
int UICtrlSummaryDlg::SetPpgCppName(CString Name)
{
	MST.WEditSetText(GetLabel(IDC_PPGIFILE), Name);
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UICtrlSummaryDlg::SetPpgUsrName(CString Name)
// Description: Set the user type name of the property page in the Summary Info dialog in ControlWizard.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: Name A CString that contains the name.
// END_HELP_COMMENT
int UICtrlSummaryDlg::SetPpgUsrName(CString Name)
{
	MST.WEditSetText(GetLabel(IDC_PPGTYPENAME), Name);
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UICtrlSummaryDlg::SetPpgIDName(CString Name)
// Description: Set the programmatic ID name of the property page in the Summary Info dialog in ControlWizard.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: Name A CString that contains the name.
// END_HELP_COMMENT
int UICtrlSummaryDlg::SetPpgIDName(CString Name) 
{
	MST.WEditSetText(GetLabel(IDC_PPGPROGID), Name);
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UICtrlSummaryDlg::Close(int how /*= 1*/)
// Description: Close the Summary Info dialog in ControlWizard.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: how A Boolean value that indicates whether to click on the OK button (TRUE) or the Cancel button when closing the Summary Info dialog.
// END_HELP_COMMENT
int UICtrlSummaryDlg::Close(int how /* =1 */) 
{
	if(how)
		MST.WButtonClick(GetLabel(IDOK));
	else 
		MST.WButtonClick(GetLabel(IDCANCEL));
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: HWND UICtrlSummaryDlg::Display(void)
// Description: Display the Summary Info dialog in ControlWizard. The page with the summary info button must be active in ControlWizard.
// Return: The HWND of the Summary Info dialog, if successful; NULL otherwise.
// END_HELP_COMMENT
HWND UICtrlSummaryDlg::Display(void)  
{
	AttachActive();           // Check if is already up
	if (!IsValid())
	{
		MST.WButtonClick(GetLabel(IDC_NAMES)) ;	 
		WaitForWndWithCtrl(IDC_PPGPROGID,1500) ;
		AttachActive();
	}
	return WGetActWnd(0); 
}


// BEGIN_HELP_COMMENT
// Function: CString UICtrlWizard::ExpectedTitle(int page)
// Description: Returns the title of the specified control wizard page.
// Return: A CString containing the title of the specified control wizard page.
// Param: page An int specifying which page you want the title for.
// END_HELP_COMMENT
CString UICtrlWizard::ExpectedTitle(int page)
{
	// wizard only supports 2 pages.
	ASSERT((page >= 1) && (page <= 2));
	// return the title of the specified page.
	return m_strPageTitles[page - 1];
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\uappwiz.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UAPPWIZ.CPP
//
//  Created by :            Date :
//      DavidGa                 10/27/93
//
//  Description :
//      Implementation of the UIAppWizard class
//
													  
#include "stdafx.h"
#include "uappwiz.h"
#include "testxcpt.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "guiv1.h"
#include "..\shl\uiwbmsg.h"
#include "..\shl\wbutil.h"
#include "..\sym\vshell.h"


#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

void UIAppWizard::OnUpdate(void) 
{
	UIProjectWizard::OnUpdate() ;
	Initialize() ;
}

void UIAppWizard::Initialize()
{
	pg1 =APPWZ_IDC_RSC_LANG, pg2 = UIAW_DB_NONE, pg3 = APPWZ_IDC_NO_INPLACE ; 
    pg4 =APPWZ_IDC_PONOTDLL , pg5 =APPWZ_IDCD_POPRINT , pg6 =APPWZ_IDC_CLASS_LIST, confirm  = APPWZ_IDC_OUTPUT ;
	
	m_CurrPage.SetAt(pg1, "Comments/External/MFC libs options") ;
	m_CurrPage.SetAt(pg2, "OLE options") ;
	m_CurrPage.SetAt(pg3, "Database options") ;
	m_CurrPage.SetAt(pg4, "Project type") ;
	m_CurrPage.SetAt(pg5, "Project features") ;
	m_CurrPage.SetAt(pg6, "Classes list") ;
	m_CurrPage.SetAt(confirm, "Confirm dialog") ;

	m_pgArr.Add(&pg1) ;
	m_pgArr.Add(&pg2) ;
	m_pgArr.Add(&pg3) ;
	m_pgArr.Add(&pg4) ;
	m_pgArr.Add(&pg5) ;
	m_pgArr.Add(&pg6) ;
	m_pgArr.Add(&confirm) ;
}

BOOL UIAppWizard::IsValid(void)
{
	if(!WaitForWndWithCtrl(VSHELL_IDC_PROJECTTYPES,1500))
		return FALSE ;
	return TRUE ;

} 
// BEGIN_HELP_COMMENT
// Function: int UIAppWizard::GetPage(HWND hwnd /*=NULL*/)
// Description: Get the current page in the AppWizard sequence.
// Return: A value that indicates the current AppWizard page: UIAW_INVALID, UIAW_NEWPROJ, UIAW_APPTYPE, UIAW_DLGOPTIONS, UIAW_DLGFEATURES, UIAW_DLGCLASSES, UIAW_DBOPTIONS, UIAW_OLEOPTIONS, UIAW_FEATURES, UIAW_PROJOPTIONS, UIAW_CLASSES, UIAW_CONFIRM, UIAW_PROGRESS, UIAW_DBSOURCES, UIAW_MESSAGEBOX.
// Param: hwnd The HWND of the AppWizard dialog. NULL means use the current dialog. (Default value is NULL.)
// END_HELP_COMMENT
int UIAppWizard::GetPage(HWND hwnd /*=NULL*/)
{

    if( hwnd == NULL )
	hwnd = WGetActWnd(0);
    if( !::IsWindow(hwnd) )
	return UIAW_INVALID;
    char acBuf[128];
    ::GetText(hwnd, acBuf, 127);
//    LOG->Comment("GetPage called when '%s' was active", acBuf);

	CString strTitleAppWiz = GetLocString(IDSS_AW_TITLE_APPWIZ);

    if( stricmp(acBuf, GetLocString(IDSS_AW_TITLE_NEWPROJ)) == 0 )
	return UIAW_NEWPROJ;     // New Project page
    else if( strnicmp(acBuf, strTitleAppWiz, strTitleAppWiz.GetLength()) == 0 )
    {
		static CString strStep = GetLocString(IDSS_AW_TITLE_STEP);
		static CString strOf = GetLocString(IDSS_AW_TITLE_OF);
	char* pch = strstr(acBuf, strStep);
	if( pch == NULL )
		{
			UIWBMessageBox mb;      // UIAWMessageBox?
			if( mb.AttachActive() && mb.ButtonExists(MSG_OK) )
		    return UIAW_MESSAGEBOX;  // Some error dialog with an OK button
	    return UIAW_INVALID;     // if it's not a messagebox, I dunno what it is
		}

	EXPECT( strlen(pch) >= (size_t)strStep.GetLength()+1 );
		pch += strStep.GetLength();
	int nPage = *pch - '0';     // Step #
	int nOfPages = 0;


    CString Title = acBuf ;
	CString NumberOfPages ;
	if ((nPage = Title.FindOneOf("123456789")) == -1)
		return UIAW_INVALID ;
	 else
	 {
		Title = Title.Right(Title.GetLength() - nPage) ;
		NumberOfPages = Title ;
		Title = Title.Left(1) ;
		nPage = *(Title.GetBuffer(1)) - '0' ;
	 }

	 // Number of pages.
	  if ((nOfPages = NumberOfPages.FindOneOf("123456789")) != -1)
	  {
	  	NumberOfPages = NumberOfPages.Right(Title.GetLength() - nOfPages) ;
		NumberOfPages = NumberOfPages.Left(1) ;
		nOfPages = *(NumberOfPages.GetBuffer(1)) - '0' ;
	  }


	if( nPage == 1 )
	    return UIAW_APPTYPE;
	if( nOfPages == 4 )
	{
			switch( nPage )
			{
		    case 2:
			return UIAW_DLGOPTIONS;
		    case 3:
			return UIAW_DLGCLASSES;
				case 4:
					return UIAW_DLGFEATURES;
			}
	}
	else if( nOfPages == 6 )
	{
			switch( nPage )
			{
		    case 2:
			return UIAW_DBOPTIONS;
		    case 3:
				    return UIAW_OLEOPTIONS;
			    case 4:
					return UIAW_FEATURES;
				case 5:
			return UIAW_PROJOPTIONS;
		    case 6:
			return UIAW_CLASSES;
			}
	}
    }
	else if( stricmp(acBuf, GetLocString(IDSS_AW_TITLE_CONFIRM)) == 0 )
		return UIAW_CONFIRM;
    else if( stricmp(acBuf, GetLocString(IDSS_AW_TITLE_DBSOURCE)) == 0 )
	return UIAW_DBSOURCES;
    else if( stricmp(acBuf, GetLocString(IDSS_AW_TITLE_PROGRESS)) == 0 )
	return UIAW_PROGRESS;

    return UIAW_INVALID;
}


// BEGIN_HELP_COMMENT
// Function: void UIAppWizard::ExpectPage(int nPage)
// Description: Expect that the given page is currently active in the AppWizard sequence. An exception is thrown if nPage doesn't match the current page.
// Return: none
// Param: nPage A value that contains the expected AppWizard page: UIAW_INVALID, UIAW_NEWPROJ, UIAW_APPTYPE, UIAW_DLGOPTIONS, UIAW_DLGFEATURES, UIAW_DLGCLASSES, UIAW_DBOPTIONS, UIAW_OLEOPTIONS, UIAW_FEATURES, UIAW_PROJOPTIONS, UIAW_CLASSES, UIAW_CONFIRM, UIAW_PROGRESS, UIAW_DBSOURCES, UIAW_MESSAGEBOX.
// END_HELP_COMMENT
void UIAppWizard::ExpectPage(int nPage)
{
	EXPECT( GetPage() == nPage );           // expect we're where we want to be
	EXPECT( nPage == m_nPage );                     // expect that m_nPage is also in sync
}

// BEGIN_HELP_COMMENT
// Function: LPCSTR UIAppWizard::ExpectedTitle(int nPage) const
// Description: Get the title of the given AppWizard page.
// Return: A pointer to a string that contains the title of the given AppWizard page.
// Param: nPage A value that contains the AppWizard page to get the title for: UIAW_NEWPROJ, UIAW_APPTYPE, UIAW_DLGOPTIONS, UIAW_DLGFEATURES, UIAW_DLGCLASSES, UIAW_DBOPTIONS, UIAW_OLEOPTIONS, UIAW_FEATURES, UIAW_PROJOPTIONS, UIAW_CLASSES, UIAW_CONFIRM, UIAW_PROGRESS, UIAW_DBSOURCES.
// END_HELP_COMMENT
CString UIAppWizard::ExpectedTitle(int nPage) const
{
    if( nPage < 0 )
		nPage = m_nPage;
    static CString strTitleAppWiz;
	strTitleAppWiz = GetLocString(IDSS_AW_TITLE_APPWIZ);
    strTitleAppWiz += GetLocString(IDSS_AW_TITLE_STEP);
	CString strOf4 = GetLocString(IDSS_AW_TITLE_OF);
	CString strOf6 = strOf4 + "6";
	strOf4 += "4";

    switch( nPage )
    {
	case UIAW_NEWPROJ:
			strTitleAppWiz = GetLocString(IDSS_AW_TITLE_NEWPROJ);
	    break;
	case UIAW_APPTYPE:
			strTitleAppWiz += "1";
			break;
	case UIAW_DLGOPTIONS:
			strTitleAppWiz += "2";
			strTitleAppWiz += strOf4;
			break;
	case UIAW_DLGFEATURES:
			strTitleAppWiz += "3";
			strTitleAppWiz += strOf4;
			break;
	case UIAW_DLGCLASSES:
			strTitleAppWiz += "4";
			strTitleAppWiz += strOf4;
			break;
	case UIAW_DBOPTIONS:
			strTitleAppWiz += "2";
			strTitleAppWiz += strOf6;
			break;
	case UIAW_OLEOPTIONS:
			strTitleAppWiz += "3";
			strTitleAppWiz += strOf6;
			break;
	case UIAW_FEATURES:
			strTitleAppWiz += "4";
			strTitleAppWiz += strOf6;
			break;
	case UIAW_PROJOPTIONS:
			strTitleAppWiz += "5";
			strTitleAppWiz += strOf6;
			break;
	case UIAW_CLASSES:
			strTitleAppWiz += "6";
			strTitleAppWiz += strOf6;
			break;
	case UIAW_CONFIRM:
	    strTitleAppWiz = GetLocString(IDSS_AW_TITLE_CONFIRM);
			break;
	case UIAW_DBSOURCES:
	    strTitleAppWiz = GetLocString(IDSS_AW_TITLE_DBSOURCE);
			break;
	case UIAW_PROGRESS:
	    strTitleAppWiz = GetLocString(IDSS_AW_TITLE_PROGRESS);
			break;
	default:        // if asked before we calculate m_nPage
	    strTitleAppWiz = GetLocString(IDSS_AW_TITLE_NEWPROJ);
    }
	return strTitleAppWiz;
}

// BEGIN_HELP_COMMENT
// Function: HWND UIAppWizard::Create(void)
// Description: Click the Create button on the New Project dialog.
// Return: The HWND of the dialog displayed after clicking the Create button (either the Add Files dialog or the first page of the AppWizard sequence).
// END_HELP_COMMENT
HWND UIAppWizard::Create(void)
{
	const char* const THIS_FUNCTION = "UIAppWizard::Create";

/*	if (GetPage() != UIAW_NEWPROJ) {
		LOG->RecordInfo("%s: Current AppWizard dialog is not the New Project dialog (expected %d; found %d). Cannot create AppWizard project.", THIS_FUNCTION, UIAW_NEWPROJ, GetPage());
		return NULL;
	}

    int index = MST.WListIndex(GetLabel(VPROJ_IDC_PROJ_TYPE));
    // determine if the project to be created is an AppWizard project or not
	// get the currently selected item in the project type combo box
	CString strProjType;
	MST.WListText(GetLabel(VPROJ_IDC_PROJ_TYPE), strProjType);
	BOOL bAppWiz = FALSE;
	if (strProjType == GetLocString(IDSS_PROJTYPE_APPWIZ_APP) || strProjType == GetLocString(IDSS_PROJTYPE_APPWIZ_DLL)) {
		bAppWiz = TRUE;
	}
  */
     MST.WButtonClick(GetLabel(IDOK));

   	// Wait five seconds for a "Subdir doesn't exist.  Do you really want to create... blah blah blah" message box.
	if (WaitMsgBoxText(GetLocString(IDSS_CREATE_DIR_PROMPT), 5))
		MST.WButtonClick(GetLabel(MSG_YES));	// Go ahead and say it's ok to create it.

	Sleep(2000) ;
	HWND hwnd;
	if (hwnd = MST.WFndWndWait(ExpectedTitle(UIAW_APPTYPE), FW_DEFAULT, 5))
	{
		LOG->Comment("Found '%s'", ExpectedTitle(UIAW_APPTYPE));
		MST.WSetActWnd(hwnd) ;

		RECT rcPage;
		GetClientRect(hwnd, &rcPage);
		ClickMouse( VK_LBUTTON ,hwnd, rcPage.left+50, rcPage.top - 15 );	  // Click on first Tab	(left most)
		ClickMouse( VK_LBUTTON ,hwnd, rcPage.left+50, rcPage.top - 15 );	  // Click on first Tab	(left most)

	}
    int nPage = UpdatePage();
    if( nPage == UIAW_MESSAGEBOX )
	return NULL;     // an error dialog came up instead
	 // if( bAppWiz ) 
    {
	LOG->Comment("Now looking for '%s'", ExpectedTitle(UIAW_APPTYPE));
	MST.WFndWndWait(ExpectedTitle(UIAW_APPTYPE), FW_DEFAULT, 5);
	return NULL;            // ought to be page 1, but we might have changed dirs
    }

	return NULL; // No longer invoke add files dialog after creating new project workspace.
}


// BEGIN_HELP_COMMENT
// Function: void UIAppWizard::SetAppType(UINT id)
// Description: Set the type of AppWizard application (SDI, MDI, or dialog based).
// Return: none
// Param: id The ID of the control to click on that specifies the type of AppWizard application.
// END_HELP_COMMENT
void UIAppWizard::SetAppType(UINT id)
{
	ExpectPage( UIAW_APPTYPE );
	MST.WOptionClick(GetLabel(id));
}

// BEGIN_HELP_COMMENT
// Function: void UIAppWizard::SetDBOptions(UINT id)
// Description: Set the database option for the AppWizard application (none, header files, db view, or db view and file support).
// Return: none
// Param: id An integer containing the ID of the control to click on that specifies the database option.
// END_HELP_COMMENT
void UIAppWizard::SetDBOptions(UINT id)
{
	ExpectPage( UIAW_DBOPTIONS );
	MST.WOptionClick(GetLabel(id));
}

// BEGIN_HELP_COMMENT
// Function: void UIAppWizard::SetOLEOptions(UINT id)
// Description: Set the OLE option for the AppWizard application (none, container, mini-server, full-server, container and server, support for OLE compound files, or support for OLE automation).
// Return: none
// Param: id An integer containing the ID of the control to click on that specifies the OLE option.
// END_HELP_COMMENT
void UIAppWizard::SetOLEOptions(UINT id)
{
	ExpectPage( UIAW_OLEOPTIONS );
	//Determine if the OLE options are enabled.
	if (MST.WOptionEnabled(::GetLabel(id)))
		OleInstalled = TRUE ;
    else OleInstalled =FALSE ;
	MST.WOptionClick(GetLabel(id));
}

// BEGIN_HELP_COMMENT
// Function: void UIAppWizard::SetOLEOptions2(UINT id)
// Description: Set the OLE option for the AppWizard application (none, container, mini-server, full-server, container and server, support for OLE compound files, or support for OLE automation).
// Return: none
// Param: id An integer containing the ID of the control to click on that specifies the OLE option.
// END_HELP_COMMENT
void UIAppWizard::SetOLEOptions2(UINT id)
{
	ExpectPage( UIAW_OLEOPTIONS );
	//Determine if the OLE options are enabled.
	if (MST.WCheckEnabled(::GetLabel(id)))
	{
		MST.WCheckClick(GetLabel(id));
	}
}

// BEGIN_HELP_COMMENT
// Function: void UIAppWizard::SetProjOptions(UINT id)
// Description: Set project options for the AppWizard application (dockable toolbar, status bar, printing, help, 3d controls, MAPI, or WinSockets).
// Return: none
// Param: id An integer that contains the ID of the control to click on that specifies the project option.
// END_HELP_COMMENT
void UIAppWizard::SetProjOptions(UINT id)
{
	ExpectPage( UIAW_PROJOPTIONS );
	MST.WOptionClick(GetLabel(id));
}

// BEGIN_HELP_COMMENT
// Function: void UIAppWizard::SetFeatures(UINT id)
// Description: Set features options for the AppWizard application (dockable toolbar, status bar, printing, help, 3d controls, MAPI, or WinSockets).
// Return: none
// Param: id An integer that contains the ID of the control to click on that specifies the project option.
// END_HELP_COMMENT
void UIAppWizard::SetFeatures(UINT id)
{
	ExpectPage( UIAW_FEATURES );
	if (MST.WCheckEnabled(::GetLabel(id)))
	{
		MST.WCheckClick(GetLabel(id));
	}
}


// BEGIN_HELP_COMMENT
// Function: void UIAppWizard::SelectClass(int n)
// Description: Select a class in the AppWizard class page by index.
// Return: none
// Param: n An integer containing the 1-based index of the class to select into the list of classes.
// END_HELP_COMMENT
void UIAppWizard::SelectClass(int n)
{
    MST.WListItemClk(GetLabel(APPWZ_IDC_CLASS_LIST), n);
}

// BEGIN_HELP_COMMENT
// Function: void UIAppWizard::SelectClass(LPCSTR sz)
// Description: Select a class in the AppWizard class page by name.
// Return: none
// Param: sz A pointer to a string containing the name of the class to select in the list of classes.
// END_HELP_COMMENT
void UIAppWizard::SelectClass(LPCSTR sz)
{
    MST.WListItemClk(GetLabel(APPWZ_IDC_CLASS_LIST), sz);
}

// BEGIN_HELP_COMMENT
// Function: CString UIAppWizard::GetClassName(void)
// Description: Get the name of the selected class from the AppWizard class page.
// Return: A CString containing the name of the selected class.
// END_HELP_COMMENT
CString UIAppWizard::GetClassName(void)         // AACK! This is the same name as a Windows API
{
    CString str;
    MST.WEditText(GetLabel(APPWZ_IDC_CLASS_NAME), str);
    return str;
}

// BEGIN_HELP_COMMENT
// Function: CString UIAppWizard::GetBaseClass(void)
// Description: Get the name of the selected class's base class from the AppWizard class page.
// Return: A CString containing the name of the base class.
// END_HELP_COMMENT
CString UIAppWizard::GetBaseClass(void)
{
    CString str;
    MST.WEditText(GetLabel(APPWZ_IDC_BASE_CLASS), str);
    return str;
}

// BEGIN_HELP_COMMENT
// Function: CString UIAppWizard::GetSourceFile(void)
// Description: Get the name of the source file for the selected class from the AppWizard class page.
// Return: A CString that contains the name of the source file.
// END_HELP_COMMENT
CString UIAppWizard::GetSourceFile(void)
{
    CString str;
    MST.WEditText(GetLabel(APPWZ_IDC_IFILE), str);
    return str;
}

// BEGIN_HELP_COMMENT
// Function: CString UIAppWizard::GetHeaderFile(void)
// Description: Get the name of the header file for the selected class from the AppWizard class page.
// Return: A CString that contains the name of the header file.
// END_HELP_COMMENT
CString UIAppWizard::GetHeaderFile(void)
{
    CString str;
    MST.WEditText(GetLabel(APPWZ_IDC_HFILE), str);
    return str;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\uidepdlg.cpp ===
//////////////////////////////
//  UIDEPDLG.CPP
//
//  Created by :            Date :
//      BrianCr				08/04/95
//
//  Description :
//      Implementation of the UIUpdateDepDialog class
//

#include "stdafx.h"
#include "uidepdlg.h"
#include "..\sym\cmdids.h"
#include "mstwrap.h"
#include "..\shl\uwbframe.h"
#include "guiv1.h"

#define new DEBUG_NEW

// BEGIN_HELP_COMMENT
// Function: BOOL UIUpdateDepDialog::Display(void)
// Description: Bring up the Update Dependencies dialog.
// Return: TRUE if the Update Dependencies dialog is displayed; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIUpdateDepDialog::Display(void)
{
	const char* const THIS_FUNCTION = "UIUpdateDepDialog::Display";
	
	// is the dialog already displayed?
	AttachActive();
	if (!IsValid()) {
		UIWB.DoCommand(IDM_PROJECT_SCAN_ALL, DC_MNEMONIC);
		WaitAttachActive(2000);
	}
	BOOL bDisplayed = IsValid();
	if (!bDisplayed) {
		LOG->RecordInfo("%s: Update Dependencies dialog was not displayed.", THIS_FUNCTION);
	}
	return bDisplayed;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\uidepdlg.h ===
//////////////////////////////
//  UIUPDEP.H
//
//  Created by :            Date :
//      BrianCr				08/04/95
//
//  Description :
//      Declaration of the UIUpdateDepDialog class
//

#ifndef __UIDEPDLG_H__
#define __UIDEPDLG_H__

#include "..\..\udialog.h"
#include "..\shl\wbutil.h"

#include "prjxprt.h"

#ifndef __UIDIALOG_H__
   #error include 'udialog.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
// UIUpdateDepDialog class declaration

// BEGIN_CLASS_HELP
// ClassName: UIUpdateDepDialog
// BaseClass: UIDialog
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS UIUpdateDepDialog: public UIDialog
{
   	UIWND_COPY_CTOR (UIUpdateDepDialog, UIDialog) ;

	virtual CString ExpectedTitle (void) const
		{	return GetLocString(IDSS_UPDATEDEP_TITLE); }

// Utilities
public:
	BOOL Display(void);
};			

#endif //__UIDEPDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\uiextwiz.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  uiextwiz.CPP
//
//  Created by :            Date :
//      Ivanl              10/14/94
//				  
//  Description :
//      Implementation of the UIExtWizard class
//

#include "stdafx.h"
#include "uiextwiz.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\appwz.h"
#include "guiv1.h"
#include "..\shl\uiwbmsg.h"
#include "..\shl\wbutil.h"
#include "uappwiz.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: BOOL UIExtWizard::Create()
// Description: Start the Custom AppWizard sequence from the New Project dialog. The New Project dialog must be displayed before calling this function.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
HWND UIExtWizard::Create() 
{	
	ExpectPage( UIAW_NEWPROJ );

	SetProjType(GetLocString(IDSS_PROJTYPE_CUST_APPWIZ));
    MST.WButtonClick(GetLabel(IDOK));

   	// Wait five seconds for a "Subdir doesn't exist.  Do you really want to create... blah blah blah" message box.
	if (WaitMsgBoxText(GetLocString(IDSS_CREATE_DIR_PROMPT), 5))
		MST.WButtonClick(GetLabel(MSG_YES));	// Go ahead and say it's ok to create it.
	Sleep(2000) ;
	HWND hwnd;
	if (hwnd = MST.WFndWndWait(GetLocString(IDSS_PROJTYPE_CUST_APPWIZ), FW_ALL|FW_NOCASE|FW_PART|FW_FOCUS, 5))
	{
		LOG->Comment("Found '%s'", GetLocString(IDSS_PROJTYPE_CUST_APPWIZ));
		MST.WSetActWnd(hwnd) ;

		RECT rcPage;
		GetClientRect(hwnd, &rcPage);
		ClickMouse( VK_LBUTTON ,hwnd, rcPage.left+50, rcPage.top - 15 );	  // Click on first Tab	(left most)
		ClickMouse( VK_LBUTTON ,hwnd, rcPage.left+50, rcPage.top - 15 );	  // Click on first Tab	(left most)

	}
	else 
  		LOG->Comment("Didn't find %s' dialog.", GetLocString(IDSS_PROJTYPE_CUST_APPWIZ));
  return MST.WGetActWnd(0) ;   
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIExtWizard::SetExtType(int Type)
// Description: Set the type of Custom AppWizard to create: from an existing project, standard AppWizard, or custom.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: Type An integer that contains the ID of the radio button that indicates the type of custom AppWizard to create.
// END_HELP_COMMENT
BOOL UIExtWizard::SetExtType(int Type) 
{
	MST.WOptionClick(GetLabel(Type));
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIExtWizard::SetNumPages(int Pages)
// Description: Set the number of steps (pages) that the custom AppWizard will contain.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: Pages An integer containing the number of steps (pages).
// END_HELP_COMMENT
BOOL UIExtWizard::SetNumPages(int Pages) 
{					
	CString szPg ;
	szPg.Format("%d",Pages) ;
    MST.WEditSetText(GetLabel(IDC_PAGES), szPg);
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIExtWizard::SetBasePrjName(CString PrjName)
// Description: Set the name of the project that the custom AppWizard will be based from. This is only applicable if the custom AppWizard is being created from an existing project.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: PrjName A CString that contains the path and filename of the project to base this custom AppWizard from.
// END_HELP_COMMENT
BOOL UIExtWizard::SetBasePrjName(CString PrjName) 
{
	MST.WEditText(GetLabel(IDC_PAGES), PrjName);
	return TRUE ;

}

// BEGIN_HELP_COMMENT
// Function: BOOL UIExtWizard::SetDllExeType(int Type)
// Description: Set whether this custom AppWizard is for an EXE or a DLL. This is only applicable if the custom AppWizard is being based on a standard AppWizard.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: Type An integer that contains the ID of the radio button that indicates whether to create an EXE Custom AppWizard or a DLL Custom AppWizard.
// END_HELP_COMMENT
BOOL UIExtWizard::SetDllExeType(int Type) 
{
	MST.WOptionClick(GetLabel(Type));
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIExtWizard::SetLangs(int index)
// Description: Set the language supported by this custom AppWizard by index. This is only applicable if the custom AppWizard is baesed on a standard AppWizard. (See SetLangs(CString) to set the language by name.)
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: index An integer that contains the 1-based index into the list of languages to set for this custom AppWizard.
// END_HELP_COMMENT
BOOL UIExtWizard::SetLangs(int index) 
{
	CListBox langLst ;
	langLst.Attach(::GetDlgItem(ControlOnPropPage(IDC_LANGS),IDC_LANGS)) ; 
	langLst.SetItemData(index,1) ;	
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIExtWizard::SetLangs(CString LangStr)
// Description: Set the language supported by this custom AppWizard by name. This is only applicable if the custom AppWizard is baesed on a standard AppWizard. (See SetLangs(int) to set the language by index.) This function is NYI.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: LangStr A CString that contains the name of the language to set for this custom AppWizard.
// END_HELP_COMMENT
BOOL UIExtWizard::SetLangs(CString LangStr) 
{
	return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\uiextwiz.h ===
///////////////////////////////////////////////////////////////////////////////
//  uiextwiz.H
//
//  Created by :            Date :
//      Ivanl             10/14/94
//
//  Description :
//      Declaration of the UIExtWizard class
//

#ifndef __UXTWZDLG_H__
#define __UXTWZDLG_H__

#include "uprojwiz.h"

#include "prjxprt.h"

#ifndef __UPROJWIZ_H__
	#error include 'uprojwiz.h' before including this file
#endif
#include "..\sym\awx.h"

///////////////////////////////////////////////////////////////////////////////
//  UIExtWizard class

///////////////////////////////////////////////////////////////////////////////
enum EXTWIZ_TYPES { EXTWIZ_CUSTOM, EXTWIZ_APWZ_CLONE, EXTWIZ_PROJ_BASED } ;
					
// BEGIN_CLASS_HELP
// ClassName: UIExtWizard
// BaseClass: UIProjectWizard
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS UIExtWizard : public UIProjectWizard 
	{
    UIWND_COPY_CTOR (UIExtWizard, UIProjectWizard) ; 

// Private data
    private:
// General Utilities
	public:
//		inline virtual CString ExpectedTitle(void) const
//		{	return ExpectedTitle(-1); }
	//	virtual CString ExpectedTitle(int nPage) const;
		virtual HWND Create(void);
		BOOL SetExtType(int Type) ;
	   	BOOL SetNumPages(int Pages) ;
		BOOL SetBasePrjName(CString PrjName) ;
		BOOL SetDllExeType(int Type) ;
		BOOL SetLangs(int index) ;
		BOOL SetLangs(CString LangStr) ;

   } ;

#endif //__UXTWZDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\uiwizbar.h ===
///////////////////////////////////////////////////////////////////////////////
//  UIWIZBAR.H
//
//  Created by :            Date :
//      Anita George        9/4/96		copied and modified from UIWIZBAR.h
//
//  Description :
//      Declaration of the UIWizardBar class
//

#ifndef __UIWIZBAR_H__
#define __UIWIZBAR_H__
//#include "odbcdlgs.h"
#include "..\sym\clswiz.h"
//#include "..\sym\vcpp32.h"
#include "..\shl\udockwnd.h"
#include "..\src\cosource.h"

//#include "prjxprt.h"

//#ifndef __UITABDLG_H__
//	#error include 'uitabdlg.h' before including this file
//#endif

#define COMMAND_STR		"WBClassComboActive"

///////////////////////////////////////////////////////////////////////////////
//  UIWizardBar class
///////////////////////////////////////////////////////////////////////////////


// BEGIN_CLASS_HELP
// ClassName: UIWizardBar
// BaseClass: UIDockWindow
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS UIWizardBar : public UIDockWindow
	{
    UIWND_COPY_CTOR (UIWizardBar, UIDockWindow) ; 

	public:
		BOOL InitializeWizBar();
		BOOL AddNewClass();
		void SelectClass(CString strClassName);
		BOOL GotoClassDefinition(LPCSTR pszClassName, COSource* pSrcFile/* = NULL*/, LPCSTR pszClassDef);
		BOOL GotoDefinitionFromHere(LPCSTR pszName, LPCSTR pszClassDef);
} ;

#endif //__UIWIZBAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\uitarget.h ===
///////////////////////////////////////////////////////////////////////////////
//	UITARGET.H
//
//	Created by :			Date :
//		IvanL				2/7/94
//
//	Description :
//		Declaration of the UIProjectTarget class
//

#ifndef __UITARGET_H__
#define __UITARGET_H__

#include "..\..\udialog.h"

#include "prjxprt.h"

#ifndef __UIDIALOG_H__
	#error include 'udialog.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//	UIProjectTarget class

// BEGIN_CLASS_HELP
// ClassName: UIProjectTarget
// BaseClass: UIDialog
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS UIProjectTarget : public UIDialog
{
	UIWND_COPY_CTOR(UIProjectTarget, UIDialog);

// Data
protected:
	CString m_ActTar;

// Utilities
public:
	HWND Show() ;
	int New(LPCSTR Name, int Type, BOOL Debug) ;
	int New(LPCSTR Name, LPCSTR Target) ;
	int Delete(LPCSTR DelName) ;
	int Rename(LPCSTR OldName, LPCSTR NewName) ;
	int SetTarget(LPCSTR Target) ;
	LPCSTR GetTarget(int Index = 0) ;
	HWND Close() ;
private:
	int Select(LPCSTR SelName, BOOL LogWarning = TRUE) ;
	};

#endif //__UITARGET_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\uiwrkspc.h ===
///////////////////////////////////////////////////////////////////////////////
//  UIWKSPC.H
//
//  Created by :            Date :
//      JimGries            4/25/95
//
//  Description :
//      Declaration for the dockable Workspace window.
//

#ifndef __UIWRKSPC_H__
#define __UIWRKSPC_H__

#include "..\shl\udockwnd.h"
#include "..\sym\dockids.h"
#include "..\eds\cosource.h"

#include "prjxprt.h"

#ifndef __UIWRKSPC_H__
    #error include 'udockwnd.h' before including this file
#endif

// The following are error codes returned by UIWorkspaceWindow member functions.
#define SUCCESS					 0
#define ERROR_ERROR				-1
#define ERROR_NO_PROJECT		-2
#define ERROR_NO_RESFILE		-3
#define ERROR_NO_CLASS			-4
#define	ERROR_NO_MEMBER			-5
#define ERROR_NO_RESOURCE		-6
#define ERROR_NO_FILE			-7
#define ERROR_NO_GLOBAL			-8
#define ERROR_NO_DECLARATION	-9
#define ERROR_NO_DEFINITION		-10
#define ERROR_GOTO			    -11

// The following defines are control IDs that are used to acces information on
// property dialogs.  See IDE source Clsview/resource.h
#define IDC_CLASSNAME 1012
#define IDC_FUNCTNAME 1009
#define IDC_DATANAME  1010
#define IDC_TARGNAME  1017

///////////////////////////////////////////////////////////////////////////////
//  UIWorkspaceWindow

// BEGIN_CLASS_HELP
// ClassName: UIWorkspaceWindow
// BaseClass: UIDockWindow
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS UIWorkspaceWindow : public UIDockWindow
{
public:
	void RemoveCharFromString(CString *, char);

	enum MEMBER_TYPE { Function, Data };
	typedef MEMBER_TYPE GLOBAL_TYPE;

    UIWorkspaceWindow();
	operator HWND ( ) {return HWnd();} ;
	operator BOOL() {return  HWnd() == 0;} ;

    virtual BOOL Activate(void);
    UINT GetID(void) const;

	BOOL ActivateBuildPane();
	BOOL ActivateDataPane();
	BOOL ActivateHelpPane();
	BOOL ActivateClassPane();
	BOOL ActivateResourcePane();

	int SelectProject(LPCSTR);
	int SelectClass(LPCSTR, LPCSTR = NULL);
	int SelectGlobal(LPCSTR, GLOBAL_TYPE, LPCSTR = NULL);
	int SelectClassMember(LPCSTR, MEMBER_TYPE, LPCSTR = NULL, LPCSTR = NULL);
	int SelectResource(LPCSTR, LPCSTR, LPCSTR = NULL);
	int SelectResource2(LPCSTR, LPCSTR, LPCSTR = NULL);
	int SelectFile(LPCSTR, LPCSTR = NULL);

	int GotoClassMemberDeclaration(LPCSTR, MEMBER_TYPE, COSource*, LPCSTR = NULL, LPCSTR = NULL);
	int GotoClassMemberDefinition(LPCSTR, MEMBER_TYPE, COSource*, LPCSTR = NULL, LPCSTR = NULL);
	int GotoGlobalDefinition(LPCSTR, GLOBAL_TYPE, COSource*, LPCSTR = NULL);
	int GotoClassDefinition(LPCSTR, COSource*, LPCSTR = NULL);
	int GotoClassDeclaration(LPCSTR, COSource*, LPCSTR = NULL);
	int GotoDefinitionFromHere(LPCSTR);
	int GotoDeclarationFromHere(LPCSTR);

	BOOL SetActiveProject(LPCSTR projName);

};

#endif //__UIWRKSPC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\uitarget.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UITARGET.CPP
//
//  Created by :            Date :
//      Ivanl              2/7/94
//
//  Description :
//      Implementation of the UIProjectTarget class
//

#include "stdafx.h"
#include "uitarget.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\cmdids.h"
#include "..\sym\vproj.h"
#include "guiv1.h"
#include "..\shl\uwbframe.h"
#include "..\shl\wbutil.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: int UIProjectTarget::New(LPCSTR Name, int Type, BOOL Debug)
// Description: Create a new target for the current project.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: Name A pointer to a string that contains name of the new target.
// Param: Type An integer that contains the 1-based index into the list of target types for the new target.
// Param: Debug A Boolean value that indicates whether the new target is debug (true) or retail.
// END_HELP_COMMENT
int UIProjectTarget::New(LPCSTR Name, int Type, BOOL Debug)
{	
	int suc ;
	// If we already have this target, exit.
	if(!(suc = Select(Name, FALSE)))
	{	suc = TRUE ;
	   	CString idx = "@" ;
		char * nb = "                     " ;
		_itoa(Type,nb, 10) ;
		idx +=nb ; 
		MST.WButtonClick(GetLabel(VPROJ_IDC_NEW_TARGET)) ;
		if (UIWB.WaitOnWndWithCtrl(VPROJ_IDC_NEWTARGET_TARGETLIST,3000 ))
		{	
			MST.WEditSetText(GetLabel(VPROJ_IDC_NEWTARGET_NAME),Name) ; 
			if (Type <= MST.WComboCount(GetLabel(VPROJ_IDC_NEWTARGET_PLATFORM))) 		
			{	
				MST.WComboItemClk(GetLabel(VPROJ_IDC_NEWTARGET_PLATFORM),(const char *) idx); //Select type
			}
			if (Debug)
			{
				MST.WCheckCheck(GetLabel(VPROJ_IDC_NEWTARGET_DEBUG)) ; 
			}
			MST.WButtonClick(GetLabel(IDOK)) ;
		}
		else 
			suc = FALSE ; // If New dialog didn't show up
	}
	return suc ;
}

// BEGIN_HELP_COMMENT
// Function: int UIProjectTarget::New(LPCSTR Name, LPCSTR Target)
// Description: Create a new target for the current project.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: Name A pointer to a string that contains name of the new target.
// Param: Target A pointer to a string that contains the name of the target type for the new target.
// END_HELP_COMMENT
int UIProjectTarget::New(LPCSTR Name, LPCSTR Target)
{
	int suc ;
	// If we already have this target, exit.
	if(!(suc = Select(Name, FALSE)))
	{	suc = TRUE ;
		MST.WButtonClick(GetLabel(VPROJ_IDC_NEW_TARGET)) ;
		if (!UIWB.WaitOnWndWithCtrl(VPROJ_IDC_NEWTARGET_TARGETLIST,3000 ))
		{	// if new target dialog didn't show up
			suc = FALSE ;
		}
		MST.WEditSetText(GetLabel(VPROJ_IDC_NEWTARGET_NAME),Name) ;
		MST.WCheckCheck(GetLabel(VPROJ_IDC_NEWTARGET_COPY)) ;
		MST.DoKeys("{TAB}") ; //Tab to the combobox
		if(MST.WComboItemExists(NULL,Target))
			MST.WComboItemClk(NULL,Target) ; //couldn't select type.
		else 
			LOG->RecordInfo("Could not find Targets combobox on the New Targets dialog") ;
			MST.WButtonClick(GetLabel(IDOK)) ;
	}
	return suc ;
}

// BEGIN_HELP_COMMENT
// Function: int UIProjectTarget::Delete(LPCSTR DelName) 
// Description: Delete a target from the current project.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: DelName A pointer to a string that contains the name of the target to delete.
// END_HELP_COMMENT
int UIProjectTarget::Delete(LPCSTR DelName) 
{
	BOOL suc ;
	// Select the target
	if ((suc =Select(DelName)))
		if (suc = MST.WButtonExists(GetLabel(VPROJ_IDC_DELETE_TARGET)))
		{ 
			MST.WButtonClick(GetLabel(VPROJ_IDC_DELETE_TARGET));
			suc = FALSE ;
			// Click YES on the confirmation message box
		 	if (UIWB.WaitOnWndWithCtrl(9,3000)) // 9 = YES
			{
				// MST.WButtonClick(GetLabel(9)) ;
				MST.DoKeys("{ENTER}") ; //Take default. 
				//Verify that it was deleted.
				if (!Select(DelName, FALSE))
					suc = TRUE ;
			}
		}
	return suc ;
}

// BEGIN_HELP_COMMENT
// Function: int UIProjectTarget::Rename(LPCSTR OldName, LPCSTR NewName)
// Description: Change the name of one of the target's in the current project.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: OldName A pointer to a string that contains the old name of the target.
// Param: NewName A pointer to a string that contains the new name for the target.
// END_HELP_COMMENT
int UIProjectTarget::Rename(LPCSTR OldName, LPCSTR NewName)
{ 	
  	BOOL suc ;
	// Select the target
	if ((suc =Select(OldName)))
	{	MST.WButtonClick(GetLabel(VPROJ_IDC_CHANGE_TARGET)) ;
		suc = FALSE ;
		// Wait on the Rename dialog box
		if (UIWB.WaitOnWndWithCtrl(VPROJ_IDC_STATIC_OLDTARGET,3000)) 
		{
			MST.WEditSetText(GetLabel(VPROJ_IDC_RENAME_NEWTARGET), NewName) ;
			MST.WButtonClick(GetLabel(IDOK));
			suc = TRUE ;
		}
		
	}
	return suc ;
}

// BEGIN_HELP_COMMENT
// Function: int UIProjectTarget::Select(LPCSTR SelName, BOOL LogWarning/* = TRUE */) 
// Description: Selects a target in the current project (substrings supported).
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: SelName A pointer to a string that contains the name of the target to select.
// Param: LogWarning A Boolean value that indicates whether to log information if the target isn't in the current project (TRUE) or not.
// END_HELP_COMMENT
int UIProjectTarget::Select(LPCSTR SelName, BOOL LogWarning/* = TRUE */) 

	{
	// REVIEW (michma): ms-test routines only allow initiating substring
	// searches of list box items and not terminating substring searches.
	// so in order to find platform-specific substrings (which terminate
	// a target list item), we need to search ourselves.
	CString target;

	// ms-test list box indexes start at 1, not 0.
	for(int i = 1; i <= MST.WListCount(GetLabel(VPROJ_IDC_TARGET_LIST)); i++)
	
		{
		// get the text of the next target.
		MST.WListItemText(GetLabel(VPROJ_IDC_TARGET_LIST), i, target);
		
		// if target contains SelName, click it.
		if(target.Find(SelName) != -1)
			{
			MST.WListItemClk(GetLabel(VPROJ_IDC_TARGET_LIST), i);
			return (MST.WListIndex(GetLabel(VPROJ_IDC_TARGET_LIST)) == i);
			}	
		}

	// SelName wasn't found in any of the targets.
	if(LogWarning) 
		LOG->RecordInfo("WARNING in UIProjectTarget::Select(): "
						"Couldn't Select target: %s", SelName);
  
   	return FALSE;
	}

// BEGIN_HELP_COMMENT
// Function: HWND UIProjectTarget::Show()
// Description: Display the Targets dialog for the current project.
// Return: The HWND of the Targets dialog, if successful; NULL otherwise.
// END_HELP_COMMENT
HWND UIProjectTarget::Show()
{
	UIWB.DoCommand(IDM_PROJECT_CONFIGURATIONS,DC_MNEMONIC) ;

	// wait up to 5 seconds for dialog to come up.
	if(!MST.WFndWndWait(GetLocString(IDSS_DLG_TITLE_DEF_PROJECT_CONFIG), FW_DEFAULT, 5))
		
		{
		LOG->RecordInfo("WARNING in UIProjectTarget::Show(): couldn't open "
						"%s Dialog", GetLocString(IDSS_DLG_TITLE_DEF_PROJECT_CONFIG));
		
		return NULL;
		}

	return WGetActWnd(0) ;
}

// BEGIN_HELP_COMMENT
// Function: HWND UIProjectTarget::Close()
// Description: Close the Targets dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
HWND UIProjectTarget::Close()
{
	MST.WButtonClick(GetLabel(IDOK)); 
	int i = 0;

	// wait up to 5 seconds for the dialog to go away.
	while(MST.WFndWndWait("Default Project Configuration", FW_DEFAULT,0))
		
		{
		Sleep(500);
		i++;

		if(i > 9)
			
			{
			LOG->RecordInfo("WARNING in UIProjectTarget::Close(): couldn't close "
							"Default Project Configuration Dialog");
			
			return NULL;
			}
		}

	return (HWND) TRUE ; // REVIEW(Ivanl) return some diagnostic value
}

// BEGIN_HELP_COMMENT
// Function: int UIProjectTarget::SetTarget(LPCSTR Target) 
// Description: Set the current target in the project.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: Target A pointer to a string that contains the name of the target to select.
// END_HELP_COMMENT
int UIProjectTarget::SetTarget(LPCSTR Target) 
{
	int suc ;
	suc =Select(Target) ;
	return suc ;
}

// BEGIN_HELP_COMMENT
// Function: LPCSTR UIProjectTarget::GetTarget(int Index /* = 0*/) 
// Description: Get the name of the current target or a specified in the project.
// Return: A pointer to a string that contains the name of the selected target.
// Param: Index An integer that contains a 1-based index into the list of targets. This value is used to specify the target to retrieve the name for. 0 means the currently selected target. (Default value is 0.)
// END_HELP_COMMENT
LPCSTR UIProjectTarget::GetTarget(int Index /* = 0*/) 
{
	static CString str ;
	str.GetBuffer(128) ;
	str.ReleaseBuffer() ;
	if(!Index)
		Index =  MST.WListIndex(GetLabel(VPROJ_IDC_TARGET_LIST)) ;
	MST.WListItemText(GetLabel(VPROJ_IDC_TARGET_LIST),Index, str) ;
	str.ReleaseBuffer() ;
	return (const char *) str ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\uiwizbar.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UIWIZBAR.CPP
//
//  Created by :            Date :
//      Anita George       9/4/96	copied and modified from UCWZDLG.CPP
//                                
//  Description :
//      Implementation of the UIWizardBar class
//

#include "stdafx.h"
#include "odbcdlgs.h"
#include "uiwizbar.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "guiv1.h"
#include "guitarg.h"
#include "..\shl\ucustdlg.h"
#include "..\wrk\uiwrkspc.h"
#include "..\..\umsgbox.h"
//#include "..\sym\vshell.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

BOOL UIWizardBar::InitializeWizBar()  
{
	UICustomizeTabDlg uiTBD;
	uiTBD.DisplayBars();
	MST.DoKeys("{END}"); //selects wizard bar toolbar option at bottom of list
	MST.WButtonClick(GetLabel(VSHELL_IDC_RESET));
	uiTBD.DisplayKeyboardTab();
	//LOG->RecordInfo("MyHnd is %d",MyHnd);
	if (uiTBD.SelectKeyAssignment(GetLocString(IDSS_CUSTKB_MAIN),GetLocString(IDSS_CUSTKB_VIEW),COMMAND_STR)) //MST.WComboExists("#35074"))
	{
		LOG->RecordInfo("in if");
		Sleep(5000);				// TODO: Fix timing problem properly.
		MST.DoKeys("^(+(1))");
		return TRUE;
	}
	else
	{
		LOG->RecordFailure("Did not assign keyboard command to Wizard Bar correctly.");
		return FALSE;
	}
	
}

BOOL UIWizardBar::AddNewClass()  //implementation not complete
//new class functionality not yet in IDE
{
	MST.DoKeys("^(+(1))");  //make sure focus is in class combo of wizbar
	MST.DoKeys("+({F10})");		// Bring up the popup context menu.

	CString strGotoMenuItem = GetLocString(IDSS_NEW_CLASS);

	if (!MST.WMenuExists(strGotoMenuItem))
	{
		LOG->RecordFailure("Menu item %s doesn't exist",strGotoMenuItem);
		return FALSE;
	}
	else
	{
		MST.WMenu(strGotoMenuItem);
		return TRUE;
	}

}

void UIWizardBar::SelectClass(CString strClassName)  
{
	MST.DoKeys("^(+(1))");  //make sure focus is in class combo of wizbar
	MST.DoKeys(strClassName);		// Bring up the popup context menu.
	MST.DoKeys("{ENTER}");
	Sleep(5000);
	//will detect if correct class selected at end of UIWizardBar::GotoDefinitionFromHere
	MST.DoKeys("^(+(1))");  //put focus back in class combo of wizbar
}
// BEGIN_HELP_COMMENT
// Function: int UIWizardBar::GotoClassDefinition(LPCSTR pszClassName, COSource* pSrcFile = NULL)
// Description: Navigates to definition of the given class in the workspace window.  It assumes that the ClassView is currently the active view.  It currently does not support nested classes.
// Parameter: pszClassName Name of class to find in the workspace window.
// Parameter: pSrcFile - Input: Ptr to an allocated COSource object.  Output: Object is attached to source file that was activated by the Goto.  If NULL the parameter is ignored.
// Parameter: pszClassDef Line of code that should be selected when jumping to class definition.
// Return: TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWizardBar::GotoClassDefinition(LPCSTR pszClassName, COSource* pSrcFile/* = NULL*/, LPCSTR pszClassDef)
{
	SelectClass(pszClassName);

	Sleep(5000);

	if (GotoDefinitionFromHere(pszClassName, pszClassDef))
	{
		if (pSrcFile != NULL)
			pSrcFile->AttachActiveEditor();
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}
// BEGIN_HELP_COMMENT
// Function: int UIWizardbar::GotoDefinitionFromHere(LPCSTR pszName)
// Description: Navigates to the definition of the currently selected item in the workspace window.  It assumes that the ClassView is currently the active view.  This function is useful for calling right after successfully calling one of the SelectXXX functions.
// Parameter: pszName Name that should appear in wizardbar class combo.
// Parameter: pszClassDef Line of code that should be selected when jumping to class definition.
// Return: TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWizardBar::GotoDefinitionFromHere(LPCSTR pszName,LPCSTR pszClassDef)
{
	MST.DoKeys("+({F10})");		// Bring up the popup context menu.

	Sleep(10000);

	CString strGotoMenuItem = GetLocString(IDSS_WIZBAR_CLASSDEF);

	if (!MST.WMenuExists(strGotoMenuItem))
	{
		LOG->RecordFailure("Menu item %s doesn't exist",strGotoMenuItem);
		return FALSE;
	}
	else
	{

		MST.WMenu(strGotoMenuItem);

		WaitForInputIdle(g_hTargetProc, 10000);	// Wait for processing to end.
		Sleep(10000);							// Wait for message box to arrive.

		UIMessageBox wndMsgBox;
		if (wndMsgBox.AttachActive())			// If we can attach, then an error must've occurred.
		{
			return FALSE;
			LOG->RecordFailure("error selecting menu item");
			wndMsgBox.ButtonClick();
		}
		else									// A source window must've become active.
		{
			COSource SrcFile;
		
			SrcFile.AttachActiveEditor();
	
			CString strFound = SrcFile.GetSelectedText();
			CString strBase = pszClassDef;

			// Remove spaces from both the source and target strings for comparison.
			UIWorkspaceWindow WS;
			WS.RemoveCharFromString(&strBase, ' ');
			WS.RemoveCharFromString(&strFound, ' ');

			if (strFound.Find(strBase) == -1)
			{
				LOG->RecordFailure("UIWizardBar::GotoDefinitionFromHere() Found: %s\n", (LPCSTR)strFound);
				LOG->RecordInfo("UIWizardbar::GotoDefinitionFromHere() Looking for: %s\n", (LPCSTR)strBase);
				return FALSE;
			}
			else
			{
				LOG->RecordInfo("Went to class definition correctly.");
				return TRUE;
			}
		}  //end else for no msgbox when selecting menu item
	}  //end else for menu item
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\uiwrkspc.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UIWRKSPC.CPP
//
//  Created by :            Date :
//      JimGries            4/25/95         
//
//  Description :
//      Implementation for the UIWorkspaceWindow
//

#include "stdafx.h"
#include "uiwrkspc.h"
#include "..\..\testutil.h"
#include "..\shl\uwbframe.h"
#include "..\shl\upropwnd.h"
#include "..\shl\wbutil.h"
#include "..\sym\cmdids.h"
#include "guiv1.h"
#include "guitarg.h"
#include "mstwrap.h"
#include "..\..\umsgbox.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: UIWorkspaceWindow::UIWorkspaceWindow(void)
// Description: Constructor for Workspace window object.
// END_HELP_COMMENT
UIWorkspaceWindow::UIWorkspaceWindow()
{
    Activate();
    Attach(FindFirstChild(UIWB.HWnd(), IDDW_PROJECT));
}


// BEGIN_HELP_COMMENT
// Function: UIWorkspaceWindow::GetID(void) const
// Return: The ID of the UIWorkspaceWindow.
// END_HELP_COMMENT
UINT UIWorkspaceWindow::GetID(void) const
{
	return IDDW_PROJECT;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWorkspaceWindow::Activate(void)
// Description: Activates the Workspace window.
// Return: TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWorkspaceWindow::Activate(void)
{
    return UIWB.DoCommand(IDM_VIEW_WORKSPACE, DC_MNEMONIC);
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWorkspaceWindow::ActivateBuildPane()
// Description: Activates the Build pane in the workspace window.
// Return: TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWorkspaceWindow::ActivateBuildPane()
{
    return ActivatePane(GetLocString(IDSS_WRKSPC_BUILD_PANE));
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWorkspaceWindow::ActivateDataPane()
// Description: Activates the Data pane in the workspace window.
// Return: TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWorkspaceWindow::ActivateDataPane()
{
    return ActivatePane(GetLocString(IDSS_WRKSPC_DATA_PANE));
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWorkspaceWindow::ActivateHelpPane()
// Description: Activates the Help pane in the workspace window.
// Return: TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWorkspaceWindow::ActivateHelpPane()
{
    return ActivatePane(GetLocString(IDSS_WRKSPC_HELP_PANE));
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWorkspaceWindow::ActivateClassPane()
// Description: Activates the Class browser pane in the workspace window.
// Return: TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWorkspaceWindow::ActivateClassPane()
{
    return ActivatePane(GetLocString(IDSS_WRKSPC_CLASS_PANE));
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWorkspaceWindow::ActivateResourcePane()
// Description: Activates the Resource pane in the workspace window.
// Return: TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWorkspaceWindow::ActivateResourcePane()
{
    return ActivatePane(GetLocString(IDSS_WRKSPC_RESOURCE_PANE));
}

// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::SelectProject(LPCSTR pszProjectName)
// Description: Selects the given project in the workspace window.  It assumes that the ClassView or FileView is currently the active view.
// Parameter: pszProjectName Name of project to select.
// Return: SUCCESS if successful, or ERROR_ERROR if some other problem occurred.
// END_HELP_COMMENT
int UIWorkspaceWindow::SelectProject(LPCSTR pszProjectName)
{
	ASSERT(pszProjectName);

	// Contract all children.
	MST.DoKeys("{Home}{Left}");

	// Type the name of the item to find.
	MST.DoKeys(pszProjectName, TRUE);

	// Popup the property page for the currently active item.
	MST.DoKeys("%({Enter})");

	int ret = SUCCESS;

	CStatic wndStatic;
	if (wndStatic.Attach(FindFirstChild(MST.WGetActWnd(0), IDC_TARGNAME)) == 0)
		ret = ERROR_NO_PROJECT;
	else
	{
		CString strFoundName;
		wndStatic.GetWindowText(strFoundName);

		if (strnicmp(strFoundName, pszProjectName, strlen(pszProjectName)))
			 ret = ERROR_NO_PROJECT; 

		wndStatic.Detach();
	}

	// Dismiss the properties dialog.	
	MST.DoKeys("{Escape}");

	return ret;
}
// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::SelectClass(LPCSTR pszClassName, LPCSTR pszProjectName = NULL)
// Description: Selects the given class in the workspace window.  It assumes that the ClassView is currently the active view.  It currently does not support nested classes.  This function leaves the class view in a state suitable for use by SelectClassMember.
// Parameter: pszClassName Name of class to find in the workspace window.
// Parameter: pszProjectName Name of project in which the class resides.  If NULL it assumes the current project.
// Return: SUCCESS if successful; ERROR_NO_CLASS if class wasn't found, or ERROR_ERROR if some other problem occurred.
// END_HELP_COMMENT
int UIWorkspaceWindow::SelectClass(LPCSTR pszClassName, LPCSTR pszProjectName /* = NULL */)
{
	ASSERT(pszClassName);

	int ret = SUCCESS;

	if (pszProjectName)
		ret = SelectProject(pszProjectName);

	if (ret == SUCCESS)
	{
		// We have to wait here until the ClassView is able to display the class
		// information.  WaitForInputIdle() does not work here.  This loop assumes
		// that there will be some selectable node underneath the project node at
		// all times!
		BOOL bReady = FALSE;
		int nSec = 30;
		while (!bReady && ret == SUCCESS)
		{
			// Attempt to open the property page for the first class or the Globals node.
			MST.DoKeys("{Left}{Left}{Right}{Right}");
			
			MST.DoKeys("%({Enter})");

			CString str;
			MST.WGetText(NULL, str);
			MST.DoKeys("{Escape}");

			if (str.Find(GetLocString(IDSS_WRKSPC_CLASS_PROP_PAGE)) != -1 || 
				str.Find(GetLocString(IDSS_WRKSPC_GLOBALS_PROP_PAGE)) != -1 ||
				str.Find(GetLocString(IDSS_WRKSPC_INTERFACE_PROP_PAGE)) != -1)
			{
				bReady = TRUE;
				MST.DoKeys("{Left}");	// Go back to project node.
			}
			else
			{
				if (--nSec != 0)	// If we still have some waiting time...
				{
					LOG->RecordInfo("Waiting up to %d more second(s) for project node to display classes...", nSec);
					Sleep(1000);
				}
				else				// We've timed out.
				{
					LOG->RecordFailure("Timeout waiting for project node to open.");
					ret = ERROR_ERROR;
				}
			}
		}

		if (ret == SUCCESS)	// If classes are now expanded in the ClassView...
		{
			// Expand the immediate children of this project, wait up to 30 seconds for response.
			MST.DoKeys("{Left}{Right}", FALSE, 30000);

			// Type the name of the item to find.
			MST.DoKeys(pszClassName, TRUE, 10000);

			// Popup the property page for the currently active item.
			MST.DoKeys("%({Enter})");

			CStatic wndStatic;
			if (wndStatic.Attach(FindFirstChild(MST.WGetActWnd(0), IDC_CLASSNAME)) == 0)
				ret = ERROR_NO_CLASS;
			else
			{
				CString strFoundName;
				wndStatic.GetWindowText(strFoundName);

				if (strncmp(strFoundName, pszClassName, strlen(pszClassName)))
					 ret = ERROR_NO_CLASS; 

				wndStatic.Detach();
			}

			// Dismiss the properties dialog.	
			MST.DoKeys("{Escape}");
		}
	}

	WaitForInputIdle(g_hTargetProc, 10000);

	return ret;
}

// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::SelectGlobal(LPCSTR pszGlobalName, LPCSTR pszProjectName = NULL)
// Description: Selects the given global symbol in the workspace window.  It assumes that the ClassView is currently the active view.  
// Parameter: pszGlobalName Name of global symbol to find in the workspace window.
// Parameter: type Is this a function or data global?
// Parameter: pszProjectName Name of project in which the global resides.  If NULL it assumes the current project.
// Return: SUCCESS if successful; ERROR_NO_GLOBAL if class wasn't found, or ERROR_ERROR if some other problem occurred.
// END_HELP_COMMENT
int UIWorkspaceWindow::SelectGlobal(LPCSTR pszGlobalName, GLOBAL_TYPE type, LPCSTR pszProjectName /* = NULL */)
{
	ASSERT(pszGlobalName);
	CString strGlobalName(pszGlobalName);

	int ret = SUCCESS;

	if (pszProjectName)
		ret = SelectProject(pszProjectName);

	if (ret == SUCCESS)
	{
		// Expand the globals node of this project.  We may have to search for it since, a project could define a "Globals" class.
		MST.DoKeys("{Left}{Right}", FALSE, 30000);

		int nCountDown = 3;
		BOOL bFound = FALSE;
		while(bFound == FALSE && ret == SUCCESS)
		{
			MST.DoKeys(GetLocString(IDSS_WRKSPC_GLOBALS_ITEM_NAME));

			// Popup the property page for this globals node.
			MST.DoKeys("%({Enter})");

			if (MST.WStaticExists(GetLocString(IDSS_WRKSPC_NO_PROPERTIES)))
				bFound = TRUE;
			else
			{
				if (--nCountDown != 0)
				{
					Sleep(1000);	// Give time for property dialog to go away, if not found yet.
					LOG->RecordInfo("Trying up to %d more times to find the Globals node", nCountDown);
				}
				else
				{
					LOG->RecordFailure("Timeout trying to find globals node.");
					ret = ERROR_ERROR;
				}
			}

			// Dismiss the properties dialog.	
			MST.DoKeys("{Escape}");
		}
	}

	if (ret == SUCCESS)
	{
		// We must've found it by now, so expand it.
		MST.DoKeys("{Right}");

		// Type the name of the item to find.
		MST.DoKeys(pszGlobalName, TRUE);

		// Popup the property page for the currently active item.
		MST.DoKeys("%({Enter})");
		
		CStatic wndStatic;
		for (int i = 0; i < 5; i++)
		{
			if  (wndStatic.Attach(FindFirstChild(MST.WGetActWnd(0), type == Function? IDC_FUNCTNAME : IDC_DATANAME)))
				break;
			Sleep(200);
		}

		if (wndStatic.m_hWnd == NULL)
			ret = ERROR_ERROR;
		else
		{			
			CString strFoundName;
			wndStatic.GetWindowText(strFoundName);

			RemoveCharFromString(&strFoundName, ' ');
			RemoveCharFromString(&strGlobalName, ' ');

			if (strGlobalName.Find(strFoundName) == -1)
				 ret = ERROR_NO_GLOBAL; 

			wndStatic.Detach();
		}

		// Dismiss the properties dialog.	
		MST.DoKeys("{Escape}");
	}

	WaitForInputIdle(g_hTargetProc, 10000);

	return ret;
}
// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::SelectClassMember(LPCSTR pszMemberName, LPCSTR pszClassName = NULL, LPCSTR pszProjectName = NULL)
// Description: Selects the given item in the workspace window.  It assumes that the ClassView is currently the active view and that the class whose member your looking for is currently selected and not expanded.  If another class is currently expanded you could get an erroneous success if the member your trying to select is in the other class as well.
// Parameter: pszMemberName Name of class member to find in the workspace window.
// Parameter: type Is this a function or data member?
// Parameter: pszClassName Name of class in which to find this member.  If NULL, the function assumes the desired class is currently selected and unexpanded.
// Parameter: pszProjectName Name of project in which the class resides.  This parameter must be supplied if pszClassName is not NULL.
// Return: SUCCESS if successful.  ERROR_NO_MEMBER if member wasn't found. Or the return code from SelectClass() or SelectProject().
// END_HELP_COMMENT
int UIWorkspaceWindow::SelectClassMember(LPCSTR pszMemberName, MEMBER_TYPE type, LPCSTR pszClassName /*= NULL */, LPCSTR pszProjectName /* = NULL */)
{
	ASSERT(pszMemberName);
	CString strMemberName(pszMemberName);

	// Make sure that either both the classname and project name is specified or neither is.
	ASSERT(!((!!pszClassName) ^ (!!pszProjectName)));

	int ret = SUCCESS;

	if (pszClassName != NULL)
		ret = SelectClass(pszClassName, pszProjectName);

	if (ret == SUCCESS)
	{
		// Expand the children of the class.
		MST.DoKeys("{Right}");

		// Type the name of the item to find.
		MST.DoKeys(pszMemberName, TRUE);

		// Popup the property page for the currently active item.
		MST.DoKeys("%({Enter})");

		CStatic wndStatic;
		for (int i = 0; i < 5; i++)
		{
			if  (wndStatic.Attach(FindFirstChild(MST.WGetActWnd(0), type == Function? IDC_FUNCTNAME : IDC_DATANAME)))
				break;
			Sleep(200);
		}

		if (wndStatic.m_hWnd == NULL)
			ret = ERROR_ERROR;
		else
		{
			CString strFoundName;
			wndStatic.GetWindowText(strFoundName);

			RemoveCharFromString(&strFoundName, ' ');
			RemoveCharFromString(&strMemberName, ' ');

			if (strMemberName.Find(strFoundName) == -1)
				 ret = ERROR_NO_MEMBER; 

			wndStatic.Detach();
		}

		// Dismiss the properties dialog.	
		MST.DoKeys("{Escape}");
	}

	WaitForInputIdle(g_hTargetProc, 10000);

	return ret;
}

// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::SelectResource(LPCSTR pszResourceType, LPCSTR pszResourceName)
// Description: Selects the given item in the workspace window.  It sets ResourceView as currently the active view.
// Parameter: pszResourceType Type of resource.  Dialog, Accelerator, etc.  This parameter is a string in order to support user defined resources.
// Parameter: pszResourceName Name of class member to find in the workspace window.
// Parameter: pszResourceFile Name of resource file to search.
// Return: SUCCESS if successful.  ERROR_NO_RESFILE, ERROR_NO_RESOURCE.
// END_HELP_COMMENT
int UIWorkspaceWindow::SelectResource(LPCSTR pszResourceType, LPCSTR pszResourceName, LPCSTR pszResourceFile /* = NULL */)
{
	ASSERT(pszResourceType && pszResourceName);
	
	if(ActivateResourcePane()==FALSE)
		return ERROR_NO_RESOURCE;

	int ret = SUCCESS;
	Sleep(1000); //XTRA SAFETY
	// Close all of the resources of the topmost folder.
	MST.DoKeys("{Home}{Left}{Right}", FALSE);
	Sleep(2000); //XTRA SAFETY
	WaitForInputIdle(g_hTargetProc, 10000); //wait for idle if resources are expanding

	MST.DoKeys(pszResourceType, TRUE);	// Type the name of the resource type to search.
	Sleep(2000); //XTRA SAFETY
	MST.DoKeys("{NUMPAD+}");			// Expand the resources for the given type.
	Sleep(2000); //XTRA SAFETY
	MST.DoKeys(pszResourceName, TRUE);	// Type the name of the resource.
	Sleep(2000); //extra safety
	// Popup the property page for the currently active item.
	UIControlProp prop = UIWB.ShowPropPage(TRUE);
	BOOL bvalid=prop.IsValid();

	if(prop.GetID()!=pszResourceName)
		ret = ERROR_NO_RESOURCE;	

	// Dismiss the properties dialog.	
	MST.DoKeys("{Escape}");

	return ret;
}


// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::SelectResource(LPCSTR pszResourceType, LPCSTR pszResourceName)
// Description: Selects the given item in the workspace window.  It sets ResourceView as currently the active view.
// Parameter: pszResourceType Type of resource.  Dialog, Accelerator, etc.  This parameter is a string in order to support user defined resources.
// Parameter: pszResourceName Name of resource to find in the workspace window.
// Parameter: pszResourceFile Name of resource file to search.
// Return: SUCCESS if successful.  ERROR_NO_RESFILE, ERROR_NO_RESOURCE, ERROR_ERROR if it fails to open the property page.
// END_HELP_COMMENT
int UIWorkspaceWindow::SelectResource2(LPCSTR pszResourceType, LPCSTR pszResourceName, LPCSTR pszResourceFile /* = NULL */)
{
	ASSERT(pszResourceType && pszResourceName);
	
	if(ActivateResourcePane()==FALSE)
		return ERROR_NO_RESOURCE;

	int ret = SUCCESS;

	// Loop through all resources of given type until it finds or fails

	CString szType = (CString)pszResourceType;
	UIControlProp prop;
	BOOL bReady = FALSE;
	int nodeNumber = 0;

	while( !bReady )
	{
		// Close all of the resources of the topmost folder.
		MST.DoKeys("{Home}{Left}{Right}", FALSE, 10000); //wait for idle if resources are expanding

		MST.DoKeys(pszResourceType, TRUE);	// Type the name of the resource type to search.
		MST.DoKeys("{Right}");			// Expand the resources for the given type.
		nodeNumber++;
		for( int j = 0; j < nodeNumber; j++ )
		{
			MST.DoKeys("{Down}", FALSE, 500);
		}

		// Popup the property page for the currently active item.
		prop = UIWB.ShowPropPage(TRUE);
		if(!prop.IsValid())
		{
			LOG->RecordInfo("The Property Page is not valid");
		}
		MST.WGetText(NULL, szType);
		if (szType.Find(pszResourceType) != -1)
		{
		 	if(prop.GetID() == pszResourceName)
				bReady = TRUE;
		}
		else
		{
			ret = ERROR_NO_RESOURCE;
			bReady = TRUE;
		}
		// Dismiss the properties dialog.	
		MST.DoKeys("{Escape}");
	}	

	return ret;
}


// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::SelectFile(LPCSTR pszFilename, LPCSTR pszProjectName = NULL)
// Description: Selects the given file workspace window's FileView.  It assumes that the FileView is currently the active view.
// Parameter: pszFilename Name of file to select in the workspace window.
// Parameter: pszProjectName Name of project in which the class resides.  If NULL it assumes the current project.
// Return: SUCCESS if successful, ERROR_NO_FILE if file wasn't found, or the return code from SelectProject().
// END_HELP_COMMENT
int UIWorkspaceWindow::SelectFile(LPCSTR pszFilename, LPCSTR pszProjectName /* = NULL */)
{
	ASSERT(FALSE);	// NOT FULLY IMPLEMENTED YET!
	ASSERT(pszFilename);

	int ret = SUCCESS;

	if (pszProjectName)
		ret = SelectProject(pszProjectName);
		
	if (ret == SUCCESS)
	{
		// Fully expand the children of the selected project folder.
		MST.DoKeys("*", TRUE);

		// Type the name of the item to find.
		MST.DoKeys(pszFilename, TRUE);

		// Popup the property page for the currently active item.
		MST.DoKeys("%({Enter})");
		
		// Assume property dialog is up.  Check for any static control on that window that
		// contains the validation string.  

		ret = ERROR_NO_FILE;// control ID of static control containing filename is VPROJ_IDC_FILE_NAME	

		// Dismiss the properties dialog.	
		MST.DoKeys("{Escape}");
	}
	return ret;
}

// BEGIN_HELP_COMMENT
// Function: void UIWorkspaceWindow::RemoveCharFromString(CString *pStr, char c)
// Description: Removes all instances of the char specified from the string given
// Parameter: pStr - The string to remove the character from.
// Parameter: c - The character to remove
// END_HELP_COMMENT
void UIWorkspaceWindow::RemoveCharFromString(CString *pStr, char c)
{
	char* pBuf = new char[pStr->GetLength()+1];

	int i, j;
	for (i = j = 0; i < pStr->GetLength(); i++)
		if (pStr->GetAt(i) != c)
			pBuf[j++] = pStr->GetAt(i);

	pBuf[j] = '\0';

	*pStr = pBuf;

	delete [] pBuf;
}

// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::GotoClassDefinition(LPCSTR pszClassName, COSource* pSrcFile = NULL, LPCSTR pszProjectName = NULL)
// Description: Navigates to definition of the given class in the workspace window.  It assumes that the ClassView is currently the active view.  It currently does not support nested classes.
// Parameter: pszClassName Name of class to find in the workspace window.
// Parameter: pSrcFile - Input: Ptr to an allocated COSource object.  Output: Object is attached to source file that was activated by the Goto.  If NULL the parameter is ignored.
// Parameter: pszProjectName Name of project in which the class resides.  If NULL it assumes the current project.
// Return: SUCCESS if successful;  ERROR_NO_DEFINITION if declaration couldn't be found, or whatever GotoDefinitionFromHere(), or SelectClass() returns.
// END_HELP_COMMENT
int UIWorkspaceWindow::GotoClassDefinition(LPCSTR pszClassName, COSource* pSrcFile/* = NULL*/, LPCSTR pszProjectName /*= NULL*/)
{
	int ret;

	ret = SelectClass(pszClassName, pszProjectName);

	if (ret == SUCCESS)
		ret = GotoDefinitionFromHere(pszClassName);

	if (ret == SUCCESS)
	{
		if (pSrcFile != NULL)
			pSrcFile->AttachActiveEditor();
	}

	return ret;
}

// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::GotoGlobalDefinition(LPCSTR pszGlobalName, COSource* pSrcFile = NULL, LPCSTR pszProjectName = NULL)
// Description: Navigates to the definition of the given global symbol in the workspace window.  It assumes that the ClassView is currently the active view.  
// Parameter: pszGlobalName Name of global symbol to find in the workspace window.
// Parameter: type Is this a function or data global?
// Parameter: pSrcFile - Input: Ptr to an allocated COSource object.  Output: Object is attached to source file that was activated by the Goto.  If NULL, the parameter is ignored.
// Parameter: pszProjectName Name of project in which the global resides.  If NULL it assumes the current project.
// Return: SUCCESS if successful; ERROR_NO_GLOBAL if class wasn't found; Whatever SelectGlobal() or GotoDefinitionFromHere() return.
// END_HELP_COMMENT
int UIWorkspaceWindow::GotoGlobalDefinition(LPCSTR pszGlobalName, GLOBAL_TYPE type, COSource* pSrcFile/* = NULL*/, LPCSTR pszProjectName /* = NULL */)
{
	int ret;

	ret = SelectGlobal(pszGlobalName, type, pszProjectName);

	if (ret == SUCCESS)
		ret = GotoDefinitionFromHere(pszGlobalName);

	if (ret == SUCCESS)
	{
		if (pSrcFile != NULL)
			pSrcFile->AttachActiveEditor();
	}

	return ret;

}

// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::GotoClassMemberDefinition(LPCSTR pszMemberName, MEMBER_TYPE type, COSource* pSrcFile = NULL, LPCSTR pszClassName = NULL, LPCSTR pszProjectName = NULL)
// Description: Navigates to the definition of the given class member.  It assumes that the ClassView is currently the active view.  
// Parameter: pszMemberName Name of class member to find in the workspace window.
// Parameter: type Is this a function or data member?
// Parameter: pSrcFile - Input: Ptr to an allocated COSource object.  Output: Object is attached to source file that was activated by the Goto.  If NULL, the parameter is ignored.
// Parameter: pszClassName Name of class in which to find this member.  If NULL, the function assumes the desired class is currently selected and unexpanded.
// Parameter: pszProjectName Name of project in which the class resides.  This parameter must be supplied if pszClassName is not NULL.
// Return: SUCCESS if successful; ERROR_NO_MEMBER if member wasn't found. Or the return code from SelectClassMember() or GotoDefinitionFromHere().
// END_HELP_COMMENT
int UIWorkspaceWindow::GotoClassMemberDefinition(LPCSTR pszMemberName, MEMBER_TYPE type, COSource* pSrcFile, LPCSTR pszClassName /*= NULL */, LPCSTR pszProjectName /* = NULL */)
{
	int ret;

	ret = SelectClassMember(pszMemberName, type, pszClassName, pszProjectName);

	if (ret == SUCCESS)
		ret = GotoDefinitionFromHere(pszMemberName);

	if (ret == SUCCESS)
	{
		if (pSrcFile != NULL)
			pSrcFile->AttachActiveEditor();
	}

	return ret;
}

// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::GotoClassMemberDeclaration(LPCSTR pszMemberName, MEMBER_TYPE type, COSource* pSrcFile = NULL, LPCSTR pszClassName = NULL, LPCSTR pszProjectName = NULL)
// Description: Navigates to the declaration of the given class member.  It assumes that the ClassView is currently the active view.  
// Parameter: pszMemberName Name of class member to find in the workspace window.
// Parameter: type Is this a function or data member?
// Parameter: pSrcFile - Input: Ptr to an allocated COSource object.  Output: Object is attached to source file that was activated by the Goto.  If NULL, the parameter is ignored.
// Parameter: pszClassName Name of class in which to find this member.  If NULL, the function assumes the desired class is currently selected and unexpanded.
// Parameter: pszProjectName Name of project in which the class resides.  This parameter must be supplied if pszClassName is not NULL.
// Return: SUCCESS if successful. ERROR_NO_MEMBER if member wasn't found. Or the return code from GotoDeclarationFromHere() or SelectClassMember().
// END_HELP_COMMENT
int UIWorkspaceWindow::GotoClassMemberDeclaration(LPCSTR pszMemberName, MEMBER_TYPE type, COSource* pSrcFile, LPCSTR pszClassName /*= NULL */, LPCSTR pszProjectName /* = NULL */)
{
	int ret;

	ret = SelectClass(pszClassName, pszProjectName);
	if (ret == SUCCESS)
		ret = GotoDeclarationFromHere(pszMemberName);

	if (ret == SUCCESS)
	{
		if (pSrcFile != NULL)
			pSrcFile->AttachActiveEditor();
	}
		
	return ret;
}

// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::GotoDefinitionFromHere(LPCSTR pszName)
// Description: Navigates to the definition of the currently selected item in the workspace window.  It assumes that the ClassView is currently the active view.  This function is useful for calling right after successfully calling one of the SelectXXX functions.
// Parameter: pszName Name that should appear in source line navigated to.
// Return: SUCCESS if successful; ERROR_GOTO if definition wasn't gone to; ERROR_NO_DEFINITION if definition couldn't be found.
// END_HELP_COMMENT
int UIWorkspaceWindow::GotoDefinitionFromHere(LPCSTR pszName)
{
	static BOOL bFirst = 1;	// Need to maximize a MDI Child window the first time
	if(bFirst)
	{
		COSource JunkFile;	// Open text file that will be maximized and then closed.
		JunkFile.Create();
		UIWB.DoCommand(MENU_FILE, DC_MENU);
		MST.DoKeys("{esc}");
		MST.DoKeys("{left}{down 5}{enter}");
		JunkFile.Close();
		UIWB.DoCommand(IDM_WINDOW_ERRORS, DC_MNEMONIC);		// Open Output window
		UIWB.DoCommand(IDM_VIEW_WORKSPACE, DC_MNEMONIC);	// Set focus back to workspace window
		bFirst = 0;
	}
	
	CString szCaption, szTestCaption ;
	MST.WGetText(NULL, szCaption) ;			// Get current MDI Main Frame caption for compare
	int ret = SUCCESS;
	MST.DoKeys("+({F10})");		// Bring up the popup context menu.

	CString strGotoMenuItem = GetLocString(IDSS_WRKSPC_GOTO_DEFINITION);

	if (!MST.WMenuExists(strGotoMenuItem))
		ret = ERROR_NO_DEFINITION;

	MST.WMenu(strGotoMenuItem);
		
	WaitForInputIdle(g_hTargetProc, 5000);	// Wait for processing to end.
	// Sleep(5000);				// Wait for message box to arrive.

	int nCount = 0;
	MST.WGetText(NULL, szTestCaption);		// Test MDI Main Frame caption until it changes
	while (szCaption == szTestCaption && nCount < 7)
	{
		LOG->RecordInfo("Trying up to %d more times to find the Editor", nCount);
		LOG->RecordInfo("Current caption is %s and original caption is %s ", szTestCaption.GetBuffer(szTestCaption.GetLength()), szCaption.GetBuffer(szCaption.GetLength()));
		Sleep(1000);
		nCount += 1;
		MST.WGetText(NULL, szTestCaption);
	}

	UIMessageBox wndMsgBox;
	if (wndMsgBox.AttachActive())			// If we can attach, then an error must've occurred.
	{
		ret = ERROR_NO_DEFINITION;
		wndMsgBox.ButtonClick();
	}
	else									// A source window must've become active.
	{
		COSource SrcFile;
		
		SrcFile.AttachActiveEditor();

		// Select to end of line.
		MST.DoKeys("+({End})");

		CString strFound = SrcFile.GetSelectedText();
		CString strBase = pszName;

		// Remove spaces from both the source and target strings for comparison.
		RemoveCharFromString(&strBase, ' ');
		RemoveCharFromString(&strFound, ' ');

		if (strFound.Find(strBase) == -1)
		{
			TRACE("UIWorkspaceWindow::GotoDefinitionFromHere() Found: %s\n", (LPCSTR)strFound);
			TRACE("UIWorkspaceWindow::GotoDefinitionFromHere() Looking for: %s\n", (LPCSTR)strBase);
			ret = ERROR_GOTO;
		}
	}
	
	return ret;
}

// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::GotoDeclarationFromHere(LPCSTR pszName)
// Description: Navigates to the declaration of the currently selected item in the workspace window.  It assumes that the ClassView is currently the active view.  This function is useful for calling right after successfully calling one of the SelectXXX functions.
// Parameter: pszName Name that should appear in source line navigated to.
// Return: SUCCESS if successful;  ERROR_GOTO if definition wasn't gone to; ERROR_NO_DECLARATION if declaration couldn't be found.
// END_HELP_COMMENT
int UIWorkspaceWindow::GotoDeclarationFromHere(LPCSTR pszName)
{
	int ret = SUCCESS;
	MST.DoKeys("+({F10})");		// Bring up the popup context menu.

	CString strGotoMenuItem = GetLocString(IDSS_WRKSPC_GOTO_DECLARATION);

	/* GAC looking for non-existant menu breaks javasys sniff
	if (!MST.WMenuExists(strGotoMenuItem))
		ret = ERROR_NO_DECLARATION;
	*/

	MST.WMenu(strGotoMenuItem);

	WaitForInputIdle(g_hTargetProc, 5000);
	Sleep(1000) ;
	UIMessageBox wndMsgBox;
	if (wndMsgBox.AttachActive())
	{
		ret = ERROR_NO_DECLARATION;
		wndMsgBox.ButtonClick();
	}
	else
	{
		COSource SrcFile;
		
		SrcFile.AttachActiveEditor();

		// Select to end of line.
		MST.DoKeys("+({End})");

		CString strFound = SrcFile.GetSelectedText();
		CString strBase = pszName;

		// Remove spaces from both the source and target strings for comparison.
		RemoveCharFromString(&strBase, ' ');
		RemoveCharFromString(&strFound, ' ');

		if (strFound.Find(strBase) == -1)
		{
			TRACE("UIWorkspaceWindow::GotoDeclarationFromHere() Found: %s\n", (LPCSTR)strFound);
			TRACE("UIWorkspaceWindow::GotoDeclarationFromHere() Looking for: %s\n", (LPCSTR)strBase);
			ret = ERROR_GOTO;
		}
	}
	
	return ret;
}

// BEGIN_HELP_COMMENT
// Function: int UIWorkspaceWindow::SetActiveProject(LPCSTR projName)
// Description: Sets the active project inside the workspace 
// Return: none
// END_HELP_COMMENT
BOOL UIWorkspaceWindow::SetActiveProject(LPCSTR projName)
{
	ASSERT(projName);
	if(ActivateBuildPane()==FALSE)
		return FALSE;

	int ret = TRUE;
	// Close all tree and expands projects only
	MST.DoKeys("{Home}{Left}{Right}", FALSE, 10000); //wait for idle
	MST.DoKeys(projName, TRUE);	// Type the name of the project to search.
	Sleep(500); //xtra safety
	MST.DoKeys("+{F10}");
	Sleep(1000); //xtra safety
	MST.DoKeys("v", FALSE, 1000);
	return ret;
} // SetActiveProject
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\uprjfile.h ===
///////////////////////////////////////////////////////////////////////////////
//  UPRJFILE.H
//
//  Created by :            Date :
//      MichMa              12/01/93
//
//  Description :
//      Declaration of the UIProjectFiles class
//

#ifndef __UIPRJFILE_H__
#define __UIPRJFILE_H__

#include "..\..\udialog.h"

#include "prjxprt.h"

#ifndef __UIDIALOG_H__
   #error include 'udialog.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//  UIQuickWatch class

#define UIPF_TITLE       		"Project Files"
#define UIPF_BTN_ADD     		"&Add"
#define UIPF_BTN_ADD_ALL 		"Add A&ll"
#define UIPF_EB_FILENAME 		"File &Name:"

#define UIPF_CB_FILES_OF_TYPE	"List Files of &Type:"
#define UIPF_FOT_SOURCE			"@1"
#define UIPF_FOT_HEADER			"@2"
#define UIPF_FOT_RES_SCRIPT		"@3"
#define UIPF_FOT_DEF_FILE		"@4"
#define UIPF_FOT_ODL_FILE		"@5"
#define UIPF_FOT_LIB			"@6"
#define UIPF_FOT_OBJ_FILE		"@7"
#define UIPF_FOT_ALL			"@8"

// BEGIN_CLASS_HELP
// ClassName: UIProjectFiles
// BaseClass: UIDialog
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS UIProjectFiles : public UIDialog

   {
   UIWND_COPY_CTOR(UIProjectFiles, UIDialog);

   // Utilities

   public:
      CString ExpectedTitle(void) const {return UIPF_TITLE;}
      BOOL AddAllFiles(LPCSTR szType = UIPF_FOT_ALL, LPCSTR szProjFilesPath = NULL);
	  BOOL AddFile(LPCSTR szFileName);
	  virtual HWND Close(void);
   };

#endif //__UIPRJFILE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\uprjfile.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UPRJFILE.CPP
//
//  Created by :            Date :
//      MichMa              12/01/93
//
//  Description :
//      Implementation of the UIProjectFiles class
//

#include "stdafx.h"
#include "uprjfile.h"
#include "mstwrap.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


// BEGIN_HELP_COMMENT
// Function: BOOL UIProjectFiles::AddFile(LPCSTR szFileName)
// Description: Add a file to the current project via the Add Files dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: szFileName A pointer to a string that contains the name of the file to add.
// END_HELP_COMMENT
BOOL UIProjectFiles::AddFile(LPCSTR szFileName)
	{
	MST.WEditSetText(UIPF_EB_FILENAME, szFileName); 
	MST.WButtonClick(UIPF_BTN_ADD);
	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIProjectFiles::AddAllFiles(LPCSTR szType /* UIPF_FOT_SOURCE */, LPCSTR szProjFilesPath /* NULL */)   
// Description: Add all files (filtered by the given filter) in the directory specified to the current project via the Add Files dialog.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: szType A pointer to a string that contains the types of files to filter. This string is one of the strings found in the Files of Type combo box in the Add Files dialog.
// Param: szProjFilesPath A pointer to a string that contains the path to the directory that contains the files to be added.
// END_HELP_COMMENT
BOOL UIProjectFiles::AddAllFiles(LPCSTR szType /* UIPF_FOT_SOURCE */, LPCSTR szProjFilesPath /* NULL */)   
	
	{
	char szCurDir[256];
	
	if(szProjFilesPath)
		{
		GetCurrentDirectory(256, szCurDir);
		MST.WEditSetText(UIPF_EB_FILENAME, szProjFilesPath);
		MST.WEditSetFocus(UIPF_EB_FILENAME);
		MST.DoKeys("{ENTER}");
		}
	
	MST.WComboItemClk(UIPF_CB_FILES_OF_TYPE, szType);
	MST.WButtonClick(UIPF_BTN_ADD_ALL);

 	if(szProjFilesPath)
		{
		MST.WEditSetText(UIPF_EB_FILENAME, szCurDir);
		MST.WEditSetFocus(UIPF_EB_FILENAME);
		MST.DoKeys("{ENTER}");
		}

	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: HWND UIProjectFiles::Close(void)
// Description: Close the Add Files dialog.
// Return: NULL if successful; the HWND of the Add Files dialog otherwise.
// END_HELP_COMMENT
HWND UIProjectFiles::Close(void)
{
	HWND hwnd = UIDialog::Close();
	MST.WFndWndWait("Scan Dependencies", FW_DEFAULT, 2);
	while (MST.WFndWnd("Scan Dependencies", FW_DEFAULT));  //TODO: get rid of literals.
	return hwnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\uogaldlg.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  uogaldlg.cpp
//
//  Created by :            Date :
//      EnriqueP              10/11/94
//	Modified by:			Date:
//		Anita George			8/12/96
//		added functions for new File-Open-like Gallery UI
//				  
//  Description :
//      Implementation of the UIOGalleryDlg class	 
//

#include "stdafx.h"
#include "uogaldlg.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\cmdids.h"
#include "..\shl\uwbframe.h"
#include "guiv1.h"
#include "guitarg.h"
//#include "..\..\umsgbox.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: HWND UIOGalleryDlg::Display() 
// Description: Bring up the Object Gallery dialog.
// Return: The HWND of the Object Gallery dialog, if successful; NULL otherwise.
// END_HELP_COMMENT
HWND UIOGalleryDlg::Display() 
{	
	AttachActive();		  // Check if is already up
	Sleep(5000);
	if (!IsValid())
	{
		//WaitForInputIdle(g_hTargetProc, 60000);
        LOG->RecordInfo("added sleep for timing problem-AnitaG");
		Sleep(5000);
		UIWB.DoCommand(IDM_GALLERY, DC_MNEMONIC);
		MST.WFndWndWait(ExpectedTitle(), FW_DIALOG, 60);
		//Sleep(20000);

		//UIDialog gallocdlg("Insert Component");	// REVIEW: Invalid Gallery dlg Use	GetLocString(IDSS_INVALID_GALLEERY)

		//gallocdlg.AttachActive();
		AttachActive();

		//if (!gallocdlg.IsValid())
		if (!IsValid())
		{
			LOG->RecordFailure("Couldn't bring up Gallery dialog.");
			return NULL;	// Error bringing up the gallery
		}
		else
		{
			Sleep(1000);
			return MST.WGetActWnd(0); 
		}

	}
	else
	{
		Sleep(1000);
		return MST.WGetActWnd(0); 
	}
}


// BEGIN_HELP_COMMENT
// Function: HWND UIOGalleryDlg::Close( void ) 
// Description: Closes the Object Gallery Main dialog and detaches the component list view.
// Return: The HWND of the window that remains after closing the Gallery.
// END_HELP_COMMENT
HWND UIOGalleryDlg::Close( void )
{
	m_OgletList.Detach();
	UIDialog::Close();
	WaitUntilGone(1000);
	Sleep(2000);

	return MST.WGetActWnd(0); 
}


// BEGIN_HELP_COMMENT
// Function: int UIOGalleryDlg::Import( CString& strOglet, BOOL bCopyToGallery /* = FALSE */)
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int UIOGalleryDlg::Import( CString& strOglet, BOOL bCopyToGallery /* = FALSE */)
{
	UOGCustomDlg custDlg;
	UOGImportDlg impDlg;

	Display();
	custDlg.Display();
	impDlg.Display();
	impDlg.SetName(strOglet);
	impDlg.CopyToGallery(bCopyToGallery);
	int bResult = impDlg.Import();
	custDlg.Close();

	return bResult; 
}

// BEGIN_HELP_COMMENT
// Function: HWND UIOGalleryDlg::Insert( CString& strOglet) 
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
HWND UIOGalleryDlg::Insert( CString& strOglet)
{
	Display();
	if (!SelectComponent(strOglet) )
	{
		LOG->Comment("Can't find oglet %s in the gallery", strOglet);
		return NULL;
	}
	if(!MST.WButtonEnabled(GetLabel(ID_OG_INSERT) ) )
	{
		LOG->Comment("Can't insert component because there is no project loaded");
		return NULL;
	}
	MST.WButtonClick(GetLabel(ID_OG_INSERT)); 
	return MST.WGetActWnd(0);
}

// BEGIN_HELP_COMMENT
// Function: HWND UIOGalleryDlg::Insert( UINT nOglet) 
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
HWND UIOGalleryDlg::Insert( int nOglet)
{
	Display();
	if (SelectComponent(nOglet) == -1 )
	{
		LOG->Comment("Can't Insert component %d because it was not found", nOglet);
		return NULL;
	}
	
	if(!MST.WButtonEnabled(GetLabel(ID_OG_INSERT) ) )  
	{
		LOG->Comment("Can't insert component because there is no project loaded");
		return NULL;
	}

	MST.WButtonClick(GetLabel(ID_OG_INSERT)); 
	Sleep(1000);
	MST.DoKeys("{ENTER}");  //REVIEW: OK Apply dialog for OGX or OCX 
	Sleep(1000);

	return MST.WGetActWnd(0);
}

// BEGIN_HELP_COMMENT
// Function: int UIOGalleryDlg::SelectComponent( CString& strOglet )	
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int UIOGalleryDlg::SelectComponent( CString& strOglet )	
{
        short const LINE_LEN=4; // no of components in one line
	Display();
	// REVIEW:Give Listbox the focus
//	m_OgletList.Attach( GetDlgItem(ID_OG_LISTCTRL) );
	int nOglets = m_OgletList.GetItemCount();
	if (nOglets == 0)
	{
		LOG->Comment("This OG Page is empty");
		return 0;
	}
	
	
	int iOglet=0;
	while ( (strOglet != GetSelectedComponentText() ) && nOglets-- )
	{
		if((iOglet+1)%LINE_LEN!=0)
                     MST.DoKeys("{RIGHT}");	// Select next oglet with right arrow key
                else
                {  // the last oglet in the line, select the first in the next line
                    MST.DoKeys("{LEFT}");MST.DoKeys("{LEFT}");MST.DoKeys("{LEFT}"); 
                    MST.DoKeys("{DOWN}"); 
                }
                iOglet++; 
	}

	if (strOglet != GetSelectedComponentText() )
	{
		LOG->Comment(" The component %s can't be selected because it was not found", strOglet);
		return 0;
	}
	return 1;
}

// BEGIN_HELP_COMMENT
// Function: int UIOGalleryDlg::SelectComponent( UINT nOglet )	
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int UIOGalleryDlg::SelectComponent( int nOglet )	
{
    //short const LINE_LEN=4; // no of components in one line

	Display();
	// REVIEW:Give Listbox the focus
//	m_OgletList.Attach( GetDlgItem(ID_OG_LISTCTRL) 
	int nOglets = m_OgletList.GetItemCount();
	if (nOglets == 0)
	{
		LOG->Comment("This OG Page is empty");
		return 0;
	}
	
	//find how many component appear in a line
	MST.DoKeys("{HOME}");
	MST.DoKeys("{RIGHT 10}");	//to make sure the last item in the line is selected
	int nLineIndex = m_OgletList.GetNextItem(-1, LVNI_SELECTED);
	int LINE_LEN = nLineIndex+1;
	MST.DoKeys("{HOME}");

	//set iOriginalOglet to equal the index of the selected item in the list view
	int iOriginalOglet = m_OgletList.GetNextItem(-1, LVNI_SELECTED);
	//if GetNextItem returns -1, a selected item was not found
	if (iOriginalOglet == -1)
	{
		LOG->Comment("No component is selected");
		return 0;
	}

	int iOglet = iOriginalOglet;
	while ( nOglet != iOglet )
	{
		if((iOglet+1)%LINE_LEN!=0)
                MST.DoKeys("{RIGHT}");	// Select next oglet with right arrow key
        else
                {  // the last oglet in the line, select the first in the next line
					for ( int i = 1; i < LINE_LEN; ++i )
					{
                    MST.DoKeys("{LEFT}");
					}
                    MST.DoKeys("{DOWN}"); 
                }
		iOglet = m_OgletList.GetNextItem(-1, LVNI_SELECTED);
		ASSERT(iOglet != -1);	// No Oglet is selected
		
		if (iOglet == iOriginalOglet)		// If we've looked at all of them
			break;
// If we reach the end and the component to select is not the last one then go to the begining.
		if ( (iOglet == (nOglets -1) ) && (nOglet != (nOglets-1) ) )		
		{
			MST.DoKeys("{HOME}");
			iOglet = m_OgletList.GetNextItem(-1, LVNI_SELECTED);
			ASSERT(iOglet != -1);	// No component is selected
		}
	}

	if (nOglet != iOglet )
	{
		LOG->Comment("The component %d can't be selected because it was not found", nOglet);
		return -1;
	}
	return iOglet;		// iOglet is zero based 
}


// BEGIN_HELP_COMMENT
// Function: LPTSTR UIOGalleryDlg::GetSelectedComponentText(void)
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
LPTSTR UIOGalleryDlg::GetSelectedComponentText(void)
{
	// Get selected item
	int iOglet = m_OgletList.GetNextItem(-1, LVNI_SELECTED);
	ASSERT(iOglet != -1);	// No component is selected

/*	LV_ITEM lvItem;
	lvItem.iItem = iOglet;
	lvItem.iSubItem = 0;
	lvItem.mask = LVIF_PARAM;

	if( !m_OgletList.GetItem(&lvItem) )
		return NULL;				// Something went wrong
	
*/	static char ogText[32];
	
	m_OgletList.GetItemText(iOglet, 0, ogText, 31); // This creates an access violation. Looks like address spaces problem

	
	return ogText;
}


// BEGIN_HELP_COMMENT
// Function: int UIOGalleryDlg::ActivateCategory( CString& strCategory )
// Description: Select a page in the Object Gallery dialog by name. (See SelectPage(UINT) to select a page by index.)
// Return: The HWND of the selected page, if successful; NULL otherwise.
// Param: szPageName A pointer to a string that contains the name of the page.
// END_HELP_COMMENT
int UIOGalleryDlg::ActivateCategory( CString& strCategory )	
{
	Display();

//     Check if Category is already selected
	CString strOriginalPage, strCurPage;
	strOriginalPage = GetActivePageText();
	if (strOriginalPage == strCategory)
		return 0; 

//	Start looking from the first page
	
	strCurPage = ActivateFirstPage();
	int cPage = 1;

	while (	( strCurPage != strCategory ) &&  ( strCurPage != ActivateNextPage() ) )
	{
		strCurPage = GetActivePageText();
		cPage++;
	}
	
	if (  strCurPage != strCategory)
	{
//		WriteWarning(" The Page %s can't be found", szPageName);
	
	// Restore original page
		ActivateCategory( strOriginalPage);					
		return -1;	
	}

	// Page was found, return page number.
	return cPage; 	
}

// BEGIN_HELP_COMMENT
// Function: LPTSTR UIOGalleryDlg::ActivateCategory( UINT nPage ) 
// Description: Select a page in the Object Gallery dialog by index. (See SelectPage(LPCSTR) to select a page by name.)
// Return: The HWND of the selected page, if successful; NULL otherwise.
// Param: nPage An integer that contains the 1-based index of the page to select.
// END_HELP_COMMENT
LPTSTR UIOGalleryDlg::ActivateCategory( UINT nPage )	
{
	Display();

	ActivateFirstPage();
	for ( unsigned int i = 1; i < nPage; i++)
		ActivateNextPage();

//	return the text of the Active Category
	return GetActivePageText(); 
}


// BEGIN_HELP_COMMENT
// Function: HWND UIOGalleryDlg::CreateCategory( CString& strCategory )
// Description: Close the Object Gallery Customize dialog.
// Return: The HWND of the Object Gallery dialog, if successful; the HWND of the Object Gallery Customize dialog otherwise.
// END_HELP_COMMENT
HWND UIOGalleryDlg::CreateCategory( CString& strCategory )
{
	UOGCustomDlg custDlg;

	Display();
	custDlg.Display();
	// custDlg.ActivateCategories();	REVIEW: TODO.  We assume the Categories Listbox has focus
	
	// Move to last row, the new entry row
	MST.DoKeys("{END}");		
	MST.DoKeys(strCategory);

	// Accept new name
	MST.DoKeys("{ENTER}");	
	custDlg.Close();

	return MST.WGetActWnd(0); 
}




// *********** Internal Functions

UINT UIOGalleryDlg::GetPageCount(void)
{
	ActivateFirstPage();

	CString strCurPage;
	strCurPage = GetActivePageText();
	unsigned int nPages = 1;	// There will always be at least 1 category

	while (	strCurPage != ActivateNextPage() )
	{
		strCurPage = GetActivePageText();
		nPages++;
	}

	ActivateFirstPage();

	return nPages;
}

LPTSTR UIOGalleryDlg::GetActivePageText(void)
{
	Display();
	
	HWND hTabs = GetTabHWnd();
	static char szTabText[32];
	GetWindowText( hTabs, szTabText,31 );
	
	return szTabText;
}	
	
LPTSTR UIOGalleryDlg::ActivateFirstPage(void)
{
	Display();

	HWND hTabs = GetTabHWnd();
	RECT rcTabs; 
	GetClientRect(hTabs, &rcTabs);

	// Click on view to give it focus	
	ClickMouse( VK_LBUTTON ,hTabs, rcTabs.left+50, rcTabs.top - 4 );	  
	// Click on first Tab	(left most)
	ClickMouse( VK_LBUTTON ,hTabs, rcTabs.left+50, rcTabs.top + 4 );
	
  	return GetActivePageText();
}

LPTSTR UIOGalleryDlg::ActivateNextPage( BOOL bRight /* TRUE */)
{
	Display();

	if ( !bRight )
		MST.DoKeys("^{PGUP}");
	else
		MST.DoKeys ("^{PGDN}") ;

	return GetActivePageText();
}	 

HWND UIOGalleryDlg::GetTabHWnd(void)
{
	Display();

	char szActWindowText[32];
	GetWindowText( WGetActWnd(0), szActWindowText,31 );

	HWND hSubDialog = ::GetDlgItem( WGetActWnd(0) , ID_OG_SUBDIALOG);
	ASSERT(hSubDialog);
	HWND hTab = ::GetDlgItem( hSubDialog , ID_OG_TABCTRL);
	ASSERT(hTab);

	return hTab;
}

////************************  Other OG functions


// BEGIN_HELP_COMMENT
// Function: BOOL UIOGalleryDlg::DeleteOGDatabase(CString& strPath) 
// Description: Delete the Object Gallery database file.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: strPath A CString that contains the name of the path to the IDE\Template directory
// END_HELP_COMMENT
BOOL UIOGalleryDlg::DeleteOGDatabase(CString& strPath) 
{	
	
	CString strOGPath = strPath; //"e:\\ide\\Template\\"
	KillFile(strOGPath.GetBuffer(strOGPath.GetLength()), "gallery.dat");
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIOGalleryDlg::RenameOGDatabase(CString& strPath, CString& strNewName, ROGD_VAL nRenameVal /* = ROGD_REPLACE */) 
// Description: Delete the Object Gallery database file.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: strPath A CString that contains the name of the path to the IDE\Template directory
// END_HELP_COMMENT
BOOL UIOGalleryDlg::RenameOGDatabase(CString& strPath, CString& strNewName, ROGD_VAL nRenameVal /* = ROGD_REPLACE */) 
{	
	
	CString strOGPath = strPath; //"e:\\ide\\template\\"
	ASSERT(!strOGPath.IsEmpty());

	strNewName = strOGPath + strNewName;
	strOGPath += "gallery.dat";

	TRY
	{
		if (nRenameVal != ROGD_RESTORE)
			CFile::Rename(strOGPath.GetBuffer(strOGPath.GetLength()), strNewName.GetBuffer(strNewName.GetLength()));
		else
			CFile::Rename( strNewName.GetBuffer(strNewName.GetLength()), strOGPath.GetBuffer(strOGPath.GetLength()));
	}
	CATCH( CFileException, e )
	{
		#ifdef _DEBUG
		if (nRenameVal != ROGD_RESTORE)
			afxDump << "File " << strOGPath << " not found, cause = "
				<< e->m_cause << "\n";
		else
			afxDump << "File " << strNewName << " not found, cause = "
				<< e->m_cause << "\n";
		#endif
	}
	END_CATCH

	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: LPTSTR UIOGalleryDlg::GetGalleryDir(CString& strPath) 
// Description: Delete the Object Gallery database file.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: strPath A CString that contains the name of the path to the IDE
// END_HELP_COMMENT
LPTSTR UIOGalleryDlg::GetGalleryDir(CString& strPath)
{
	static CString strOGPath = strPath;		//  = "e:\\ide\\bin\\"
	int iBin = strOGPath.ReverseFind('\\');

	ASSERT(iBin != -1);	// make sure is a valid path
	
	// truncate last '\\'
	strOGPath = strOGPath.Left(iBin);	
	// Look for installation directory
	iBin = strOGPath.ReverseFind('\\');
	strOGPath = strOGPath.Left((iBin+1));
	strOGPath += "Template\\";

	return strOGPath.GetBuffer(strOGPath.GetLength());
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIOGalleryDlg::VerifyFilesInDir(CStringList* pFileList, CString& strPath) 
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
BOOL UIOGalleryDlg::VerifyFilesInDir(CStringList* pFileList, CString& strPath) 
{
	POSITION pos = pFileList->GetHeadPosition();
	BOOL bResult = TRUE;
	while (pos != NULL)
	{
		CString strFile; 
		if (!strPath.IsEmpty())
			strFile = strPath + "\\";	
		else
			strFile.Empty();

		// Get filename from list
		strFile += pFileList->GetNext(pos);
		
		if (GetFileAttributes( strFile ) == -1 )
		{
			bResult = FALSE;
			LOG->Comment("File %s could not be found", strFile);
		}
	}
	
	return bResult;
}


/**************************************************************/
//  UOGCustomDlg class  

HWND UOGCustomDlg::Display(void)
{
	AttachActive();		  // Check if is already up
	if (!IsValid())
	{
		MST.WButtonClick(GetLabel( ID_OG_CUSTOMIZE ));  
	 	AttachActive();
		if (!IsValid())
			return NULL;
	}

	return 	MST.WGetActWnd(0); 
}

/**************************************************************/
//  UOGImportDlg class  

HWND UOGImportDlg::Display(void)
{
	AttachActive();		  // Check if is already up
	if (!IsValid())
	{
		MST.WButtonClick(GetLabel( ID_OG_IMPORT ));  
	 	AttachActive();
		if (!IsValid())
			return NULL;
	}

	return 	MST.WGetActWnd(0); 
}

int UOGImportDlg::SetName(CString& strName)
{
	MST.WEditSetText(GetLabel(ID_OG_FILE_NAME),strName) ;
	return TRUE;
}	

int UOGImportDlg::CopyToGallery(BOOL bCopyToGallery /* = TRUE */)
{
	if (bCopyToGallery)
	{
		MST.WCheckCheck(GetLabel(ID_OG_COPY_TO_GALLERY)) ;
	}
	else
	{
		MST.WCheckUnCheck(GetLabel(ID_OG_COPY_TO_GALLERY)) ;
	}
	return TRUE;
}	

int UOGImportDlg::Import(void)
{
	if (!IsValid())
		Display();
	
	MST.WButtonClick(GetLabel( ID_OG_IMPORT_IMPORT ));  

	// Check to see if Import succeded, look if Customize dialog is active

	UOGCustomDlg dlgCust;
	dlgCust.WaitAttachActive(4000);
	if (!dlgCust.IsValid())
	{
		// Some alert popped up, Import failed, OK alert and exit Import dialog
		MST.DoKeys("{ENTER}");
		MST.DoKeys("{ESC}");
		return 0;
	}
	
	return 1;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIOGalleryDlg::FindFileInGallery(CString OgxName)
// Description: Looks at location in Gallery to verify if ogx exists or not.
// Return: Returns 1 if ogx appears in Gallery,0 if it doesn't, 
// 2 if a different ogx appears, and 3 if project folder not found, 4 if gallery doesn't display.
// Param: Name of the project. Name of the ogx.
// END_HELP_COMMENT
int UIOGalleryDlg::FindFileInGallery(CString ProjName, CString OgxName) 
{
	if (Display() != NULL)
	{
		UIFileDlg::SetName(ProjName);
		MST.DoKeys("{ENTER}");
		Sleep(3000);
		//if error message does not occur
		if (!WaitMsgBoxText(GetLocString(IDSS_NOFILE), 10000))
		{
			MST.DoKeys("{BACKSPACE}");
			//do shift tab to give focus to listview
			MST.DoKeys("+({TAB})");
			MST.DoKeys("{UP}");
			CString FileName = UIFileDlg::GetName();
			if (FileName != "")
			{
				if ((OgxName.Find(FileName)) != -1)
				{
					LOG->Comment("OGX found in gallery");
					return 1;
				}
				else
				{
					LOG->Comment("different OGX selected");
					return 2;
				}
			}
			else //if blank string then file doesn't exist
			{
				LOG->Comment("OGX not found in gallery");
				return 0;
			}
			//Close();
		}
		else //if error message appears
		{
			Sleep(3000);
			MST.WButtonClick(GetLocString(IDSS_OK));
			//Close();
			LOG->RecordInfo("Project folder not found in gallery.");
			return 3;
		}
	}
	else  //if gallery didn't display
	{
		return 4;
	}
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIOGalleryDlg::FindClassInClassView(CString ProjName,CString ClassName)
// Description: Selects class from classview.
// Return: BOOL TRUE if class is found, FALSE if class not found.
// Param: Name of the class you're looking for.
// END_HELP_COMMENT
BOOL UIOGalleryDlg::FindClassInClassView(CString ProjName, CString ClassName) 
{
	BOOL bResults = FALSE;
	UIWorkspaceWindow WorkSpaceWnd; //create project workspace window object
	//if project workspace activates properly
	if (WorkSpaceWnd.Activate())  
	{
		//if classview activates properly
		if (WorkSpaceWnd.ActivateClassPane())
		{
			int ClassSelected = WorkSpaceWnd.SelectClass(ClassName, ProjName);
			if (ClassSelected == 0)  //0 = successful
			{
				bResults = TRUE;
				LOG->Comment("Class selected properly");
			}
		}
		else
		{
			LOG->RecordFailure("Could not activate ClassView.");
		}
	}
	else
	{
		LOG->RecordFailure("Could not activate project workspace window.");
	}
	return bResults;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIOGalleryDlg::AddToGallery()
// Description: Creates ogx from selected class in classview by selecting Add to Gallery
// context menu item.  This function assumes a class is already selected in ClassView.
// Return: None
// Param: None
// END_HELP_COMMENT
void UIOGalleryDlg::AddToGallery() 
{
	MST.DoKeys("+({F10})");		// Bring up the popup context menu.
	CString strGotoMenuItem = GetLocString(IDSS_WRKSPC_ADDTOGALLERY);
	if (MST.WMenuExists(strGotoMenuItem))
	{
		MST.DoKeys("{DOWN 2}") ; //need to do this to get focus on context menu
		MST.WMenu(strGotoMenuItem);
		Sleep(2000);
	}
	else
	{
		LOG->RecordFailure("Add to Gallery menu item doesn't exist.");
	}
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIOGalleryDlg::AddToProject(CString FolderName, CString FileName)
// Description: Selects file from gallery and adds it to current project.
// Return: None
// Param: Name of the class to create ogx from.
// END_HELP_COMMENT
void UIOGalleryDlg::AddToProject(CString FolderName, CString FileName, CString FullFileName)
{
	if (FindFileInGallery(FolderName, FullFileName) == 1)  
	{
		
		//MST.WButtonClick(GetLocString(IDS_INSERTCOMP));
		DoKeys("{ENTER}");
		HWND DlgWnd = MST.WFndWndWaitC(FileName,"STATIC",FW_PART,60);
		//if confirmation dialog comes up
		if (DlgWnd != 0)
		{
			//LOG->RecordInfo("Clicking OK");
			MST.WButtonClick(GetLocString(IDSS_OK));
			//LOG->RecordInfo("WaitUntilGone");
			WaitUntilGone(4000);
			//LOG->RecordInfo("Clicking yes");
			MST.WButtonClick(GetLocString(IDSS_YES));
			//LOG->RecordInfo("WaitUntilGone");
			WaitUntilGone(4000);
		}
		else
		{
			LOG->RecordFailure("Insert confirmation dialog didn't display.");
		}
	}
	else
	{
		LOG->RecordFailure("Did not select file in Gallery properly.");
	}
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIOGalleryDlg::DeleteFileInGallery(CString FolderName, CString FullFileName, CString OgxFileName)
// Description: Deletes a file in the gallery.  Cleanup for gallery sniff.
// Return: BOOL
// Param: None
// END_HELP_COMMENT
BOOL UIOGalleryDlg::DeleteFileInGallery(CString FolderName, CString FullFileName, CString OgxFileName) 

{
	BOOL bResult;
	int FileFound = FindFileInGallery(FolderName, FullFileName);
	if (FileFound == 1)  
	{
		Sleep(5000);
		MST.DoKeys("{DELETE}");
		Sleep(5000);
		CString str;
		MST.WGetText(NULL, str);

		//verify delete confirmation window is up
		if (str.Find(GetLocString(IDSS_DELETE_TITLE)) != -1)
		{
			//verify correct file is going to be deleted
			if (MST.WFndWndWaitC(OgxFileName,"STATIC",FW_PART,60) != 0)
			{
				DoKeys("{ENTER}");
				//can't use yes and no text because the delete dlg is a system
				//dialog - will get localized when OS is localized but when VC
				//still English
				//MST.WButtonClick(GetLocString(IDSS_YES));
				WaitUntilGone(4000);
				bResult = TRUE;
			}
			else
			{
				DoKeys("{TAB}");
				DoKeys("{ENTER}");
				//MST.WButtonClick(GetLocString(IDSS_NO));
				WaitUntilGone(4000);
				LOG->RecordFailure("Almost deleted wrong file.");
				bResult = FALSE;
			}
		}
		else
		{
			LOG->RecordFailure("Delete confirmation dialog did not come up.");
			bResult = FALSE;
		}
	}
	else  //FindFileInGallery returns something different then 1
	{
		//0 means no file found, 3 means no project folder found
		if (FileFound == 0 || FileFound == 3)
		{
			bResult = TRUE;
		}
		else //FindFileInGallery returns 2 or 4
		{
			LOG->RecordFailure("Error trying to find OGX file to delete.");
			bResult = FALSE;
		}
	}
	Sleep(3000);
	Close();
	return bResult;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIOGalleryDlg::LookIn(LPCSTR szLocation)
// Description: Sets the "Look In" field of the gallery dlg. The gallery dlg must be open.
// Param: LPCSTR szLocation - a string specifying the folder to look in.
// Return: BOOL - TRUE if the location was successfully changed. FALSE if not.
// END_HELP_COMMENT
BOOL UIOGalleryDlg::LookIn(LPCSTR szLocation)
{
	
	// gallery dlg must be active.
	if(!IsActive())
	{
		LOG->Comment("ERROR! UIOGalleryDlg::LookIn - gallery dlg not active");
		return FALSE;
	}

	// calls the base class to set the path (UIFileDlg::SetPath).
	SetPath(szLocation);
	// get the handle of dlg that is active after waiting 1 second.
	Sleep(1000);
	HWND hwnd = MST.WGetActWnd(0);

	// if the handle doesn't match that for the gallery dlg, an unexpected dlg came up.
	if(hwnd != HWnd())
	{
		// check if the "file/folder does not exist" dlg came up.
		if(MST.WFndWndC(GetLocString(IDSS_OG_FILE_NOT_EXIST), "STATIC", FW_PART))
			LOG->Comment("ERROR! UIOGalleryDlg::LookIn - %s does not exist.", szLocation);
		else
			LOG->Comment("ERROR! UIOGalleryDlg::LookIn - unknown error");

		// hopefully this will cancel whatever dlg came up.
		MST.DoKeys("{ESC}");
		return FALSE;
	}

	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: int UIOGalleryDlg::SelectComponent(LPCSTR szComp)	
// Description: Selects a component from the gallery dialog. The component must be showing in the list.
// Param: LPCSTR szComp - The name of the component to select.
// Return: BOOL - Returns TRUE if the component was successfully selected, FALSE if not.
// END_HELP_COMMENT
BOOL UIOGalleryDlg::SelectComponent(LPCSTR szComp)	

{
	// gallery dlg must be active
	if(!IsActive())
	{
		LOG->Comment("ERROR! UIOGalleryDlg::SelectComponent - gallery dlg not active");
		return FALSE;
	}

	// make sure the component list box exists and is enabled.
	if(MST.WViewEnabled("@1")==FALSE)
	{
		LOG->Comment("ERROR! UIOGalleryDlg::SelectComponent - component list not enabled");
		return FALSE;
	}
//TODO: Remove temp test
	char lpszBuffer[128];
	::WViewGetClass(lpszBuffer);
	int count=MST.WViewCount("@1");
	LOG->Comment("Class ListView (%s) count: %d",lpszBuffer, count);
//End of temp test
	// give the component list focus.
	MST.WViewSetFocus     ("@1");
	MST.WViewItemClk("@1", szComp);
//TODO: Remove after having investigated why it does not work
	int result=MST.WViewSelItem("@1", szComp);
	LOG->Comment("Result:(%d) of WViewSelItem, Item:(%s)", result, szComp);
//End of investigation

	CString strCompCurrent;
	MST.DoKeys("{TAB}");			// tab to the edit field (can't read with WEditText)
	MST.DoKeys("^(c)");				// copy contents to the clipboard
	GetClipText(strCompCurrent);	// grab the clipboard
		
	if(strCompCurrent == szComp)	// see if we have a match
		return TRUE;

	LOG->Comment("ERROR! UIOGalleryDlg::SelectComponent - could not find component %s", szComp); 	 
	return FALSE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIOGalleryDlg::Insert(LPCSTR szComponent)	
// Description: Inserts the currently selected component from the gallery dlg and confirms the insertion.
// Param: LPCSTR szComponent - The name of the component being inserted.
// Return: BOOL - TRUE if the insert operation was sucessful (at which time the component-specific wizard dlg will be active, if one exists), FALSE if not.
// END_HELP_COMMENT
BOOL UIOGalleryDlg::Insert(LPCSTR szComponent)	

{
	// gallery dlg must be active.
	if(!IsActive())
	{
		LOG->Comment("ERROR! UIOGalleryDlg::Insert - gallery dlg not active");
		return FALSE;
	}

	// expected text of Insert button.
	CString strInsert = GetLocString(IDSS_OG_INSERT);

	// make sure the insert button exists and is enabled.
	if(!MST.WButtonEnabled(strInsert))
	{
		LOG->Comment("ERROR! UIOGalleryDlg::Insert - %s button doesn't exist", strInsert);
		return FALSE;
	}
	
	// click the insert button.
	MST.WButtonClick(strInsert);
	UIDialog confirmDlg(GetLocString(IDSS_WORKBENCH_TITLEBAR));
	confirmDlg.AttachActive();
	confirmDlg.IsValid();
	// the confirmation dlg should contain this text. 
//	CString strConfirm = GetLocString(IDSS_OG_INSERT_CONFIRM1) + szComponent + GetLocString(IDSS_OG_INSERT_CONFIRM2);
//	if(!MST.WFndWndWaitC(strConfirm, "STATIC", FW_PART, 3))
	//REVIEW (chriskoz): The check above is to strict. Does not make sense for ActiveX controls.
	//Also, correct localization of "IDSS_OG_INSERT_CONFIRM1 + szComponent + IDSS_OG_INSERT_CONFIRM2" will be impossible
	//We'd better drop this confirm check but it's still here below:
	HWND hexist; //handle of the static control in the confirm dialog
	LOG->Comment("ISValid retrned:'%d'",confirmDlg.IsValid());
	if(//!confirmDlg.IsValid() ||
		!MST.WFndWndWaitC(GetLocString(IDSS_OG_INSERT_CONFIRM1), "STATIC", FW_ACTIVE | FW_PART, 3) ||
		!(hexist=MST.WFndWndWaitC(GetLocString(IDSS_OG_INSERT_CONFIRM2), "STATIC", FW_ACTIVE | FW_PART, 3)) )
	{
		LOG->Comment("ERROR! UIOGalleryDlg::Insert - no confirmation dlg");
		return FALSE;
	}

	CString strOK = GetLocString(IDSS_OK);

	// make sure the ok button exists and is enabled.
	if(!MST.WButtonEnabled(strOK))
	{
		LOG->Comment("ERROR! UIOGalleryDlg::Insert - %s button doesn't exist", strOK);
		return FALSE;
	}

	CString strConfirm;
	MST.WGetText(hexist, strConfirm);
	// confirm.
	confirmDlg.OK();

 	// wait up to 3 seconds for the confirmation dlg to go away.
	if(!MST.WFndWndWaitC(strConfirm, "STATIC", FW_PART | FW_NOEXIST, 3) )
	{
		LOG->Comment("ERROR! UIOGalleryDlg::Insert - confirmation dlg didn't go away");
		// OK didn't work, try hitting ESC to make it go away.
		MST.DoKeys("{ESC}");
		return FALSE;
	}

	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: CString UIOGalleryDlg::Description(void)	
// Description: Gets the description of the currently selected component in the gallery dlg.
// Return: CString - The component description.
// END_HELP_COMMENT
CString UIOGalleryDlg::Description(void)	

{
	// gallery dlg must be active
	if(!IsActive())
	{
		LOG->Comment("ERROR! UIOGalleryDlg::Insert - gallery dlg not active");
		return (CString)"";
	}

	CString description;
	MST.WStaticText("@4", description);
	return description;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\uprjtdlg.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UPRJTDLG.CPP
//
//  Created by :            Date :
//      EnriqueP              2/7/94
//				  
//  Description :
//      Implementation of the UIProjOptionsTabDlg class	 
//

#include "stdafx.h"
#include "uprjtdlg.h"
#include "mstwrap.h"
#include "..\sym\cmdids.h"
#include "..\sym\optncplr.h"
#include "..\sym\optnlink.h"
#include "guiv1.h"
#include "..\shl\uwbframe.h"
#include "Strings.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: HWND UIProjOptionsTabDlg::Display() 
// Description: Bring up the Project Settings tabbed dialog.
// Return: The HWND of the dialog, if successful; NULL otherwise.
// END_HELP_COMMENT
HWND UIProjOptionsTabDlg::Display() 
{	
	AttachActive();		  // Check if is already up
	if (!IsValid())
	{
		UIWB.DoCommand(IDM_PROJECT_SETTINGS, DC_MNEMONIC);
	 	AttachActive();
	}
	return WGetActWnd(0); 
}


// BEGIN_HELP_COMMENT
// Function: int UIProjOptionsTabDlg::SelectFile (CString szFile,CString szGrp, CString szTarget ) 
// Description: Select a file in the Project Settings dialog to work with.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szFile A CString that contains the name of the file to select.
// Param: szGrp A CString that contains the name of the group that contains the file to select.
// Param: szTarget A CString that contains the name of the target that contains the file to select.
// END_HELP_COMMENT
int UIProjOptionsTabDlg::SelectFile (CString szFile,CString szGrp, CString szTarget ) 
{
	if(!szTarget.IsEmpty())
		UIWB.SelectProjItem(PROJITEM_TARGET,szTarget) ;
	if(!szGrp.IsEmpty())
		UIWB.SelectProjItem(PROJITEM_GROUP,szGrp) ;
	UIWB.SelectProjItem(PROJITEM_FILE,szFile) ;
	return ERROR_SUCCESS ; 
}


// BEGIN_HELP_COMMENT
// Function: int UIProjOptionsTabDlg::SelectGroup(CString szGrp, CString szTarget) 
// Description: Select a group in the Project Settings dialog to work with.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szGrp A CString that contains the name of the group to select.
// Param: szTarget A CString that contains the name of the target that contains the group to select.
// END_HELP_COMMENT
int UIProjOptionsTabDlg::SelectGroup(CString szGrp, CString szTarget) 
{
	if(!szTarget.IsEmpty())
		UIWB.SelectProjItem(PROJITEM_TARGET,szTarget) ;
	UIWB.SelectProjItem(PROJITEM_GROUP,szGrp) ;
	return ERROR_SUCCESS ; 
}


// BEGIN_HELP_COMMENT
// Function: int UIProjOptionsTabDlg::SelectTarget(CString szTarget) 
// Description: Select a target in the Project Settings dialog to work with.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szTarget A CString that contains the name of the target to select.
// END_HELP_COMMENT
int UIProjOptionsTabDlg::SelectTarget(CString szTarget) 
{  	
	UIWB.SelectProjItem(PROJITEM_TARGET,szTarget) ;
	return ERROR_SUCCESS ; 
}


// BEGIN_HELP_COMMENT
// Function: HWND UIProjOptionsTabDlg::ShowCompilerTab(PROJSET_TAB tabCompiler /* = TAB_CPLUSPLUS */)
// Description: Display the compiler options tab in the Project Settings dialog.
// Return: The HWND of the compiler options tab, if successful; NULL otherwise.
// Param: tabCompiler A TAB specifier for the compiler to show.  Can be one of TAB_CPLUSPLUS or TAB_FORTRAN.  TAB_COMPILER can also be used and is equivalent to TAB_CPLUSPLUS for backwards compatibility.
// END_HELP_COMMENT
HWND UIProjOptionsTabDlg::ShowCompilerTab(PROJSET_TAB tabCompiler /* = TAB_CPLUSPLUS */)
{
	ASSERT(tabCompiler == TAB_CPLUSPLUS || 
		   tabCompiler == TAB_COMPILER || 
		   tabCompiler == TAB_FORTRAN);
	ShowPage(GetLocString(tabCompiler));

	return GetCurrentPage();
}


int GetCategory(UIProjOptionsTabDlg::PROJSET_TAB iTab, UINT iCtrlId)
{
	switch (iTab)
	{
		case UIProjOptionsTabDlg::TAB_DEBUG :
			switch (iCtrlId)
			{
				case 	DBG_IDC_CATEGORY: 
				case 	DBG_IDC_DEFAULT: 
				case 	DBG_IDC_EXE_FOR_SESSION:
				case 	DBG_IDC_WORKDIR:
				case 	DBG_IDC_ARGS:
				case 	DBG_IDC_REMOTE_TARGET:
							return DBG_GENERAL;

				case	DBG_IDC_TRY_LOCATE_DLLS:
							return DBG_ADDITIONAL_DLLS;
			
			}
			break;

		case UIProjOptionsTabDlg::TAB_COMPILER :
			switch (iCtrlId)
			{
				case 	CL_IDC_CATEGORY: 
				case	CL_IDC_DEFAULT: 
				case	CL_IDC_OPTIONS:
				case	CL_IDC_WARN_LEVEL:
				case	CL_IDC_DEBUG_INFO:
				case	CL_IDC_OPTIMIZATIONS:
				case	CL_IDC_WARN_AS_ERRORS:
				case	CL_IDC_GEN_BROWSE_INFO:
				case	CL_IDC_PREPROC_DEF : 
								return CL_GENERAL;

				case	CL_IDC_AUTOPCH:
				case	CL_IDC_AUTONAME:
				case	CL_IDC_USEPCH:
				case	CL_IDC_USENAME:
				case	CL_IDC_CREATEPCH:
				case	CL_IDC_CREATENAME:
								return CL_PRECOMPILE_H;

				case    CL_IDC_ADD_INCLUDE:
								if (GetLang() == CAFE_LANG_JAPANESE)
									return 7;
								return CL_PREPROCESSOR;		
			}
			break;

		case UIProjOptionsTabDlg::TAB_LINKER :
			switch (iCtrlId)
			{
				case 	LNK_IDC_CATEGORY: 
				case	LNK_IDC_DEFAULT: 
				case	LNK_IDC_OPTIONS:
				case	LNK_IDC_TARGET_NAME:
				case	LNK_IDC_OBJ_LIB_MOD:
				case	LNK_IDC_GEN_DEBUG_INFO:
				case	LNK_IDC_IGNORE_DEF_LIBS:
				case	LNK_IDC_LINK_INCREMENT:
				case	LNK_IDC_GEN_MAPFILE : 
				case	LNK_IDC_ENABLE_PROFILE :
							return LNK_GENERAL;

				case	LNK_IDC_ADDL_LIB_PATH :
							return LNK_INPUT;
			}
			break;

		case UIProjOptionsTabDlg::TAB_IMAGEBLD :
			switch (iCtrlId)
			{
				case 	IMAGEBLD_IDC_CATEGORY: 
				case	IMAGEBLD_IDC_DEFAULT: 
				case	IMAGEBLD_IDC_XBE_NAME:
				case	IMAGEBLD_IDC_AUTOCOPY_OFF:
							return IMAGEBLD_GENERAL;

				case	IMAGEBLD_IDC_TITLE_ID:
				case	IMAGEBLD_IDC_TITLE_NAME:
				case	IMAGEBLD_IDC_PUBLISHER_NAME:
							return IMAGEBLD_TITLE;
			}
			break;

		default:
			;
	}

	LOG->RecordFailure("Invalid control ID passed to GetCategory(%d, %d)", iTab, iCtrlId);
	return -1;
}


UIProjOptionsTabDlg::PROJSET_TAB StringIDToTab(PROJ_PROP_CATEGORIES ProjPropCat)
{
	switch (ProjPropCat)
	{
		//case CT_GENERAL			: return UIProjOptionsTabDlg::TAB_GENERAL;
		case CT_DEBUG			: return UIProjOptionsTabDlg::TAB_DEBUG;
		case CT_MAKE_TYPE_LIB	: return UIProjOptionsTabDlg::TAB_MAKE_TYPE_LIB;
		case CT_COMPILER		: return UIProjOptionsTabDlg::TAB_COMPILER;
		case CT_RESOURCE		: return UIProjOptionsTabDlg::TAB_RESOURCE;
		case CT_BROWSER			: return UIProjOptionsTabDlg::TAB_BROWSER;
		case CT_LINKER			: return UIProjOptionsTabDlg::TAB_LINKER;
		case CT_IMAGEBLD		: return UIProjOptionsTabDlg::TAB_IMAGEBLD;
		default:
			return UIProjOptionsTabDlg::TAB_GENERAL;
	}
}
	
// emmang@xbox xbox specific
// BEGIN_HELP_COMMENT
// Function: int UIProjOptionsTabDlg::SetProjOption(PROJ_PROP_CATEGORIES ProjPropCat, UINT iCtrlId, int iNewValue)
// Description: Set a value-based option for the currently selected target, group, or file in the Project Settings dialog. (See SetLinkerOption(UINT, LPCSTR) to set text-based linker options.)
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: iCtrlId An integer that contains the ID of the control for the option to set.
// Param: iNewValue An integer that contains the new value of the option.
// END_HELP_COMMENT
int UIProjOptionsTabDlg::SetProjOption(PROJ_PROP_CATEGORIES ProjPropCat, UINT iCtrlId, int iNewValue)
{
	ShowProjSettingsTab(StringIDToTab(ProjPropCat));
	SetOption(TAB_CURRENT, CL_IDC_CATEGORY, GetCategory(StringIDToTab(ProjPropCat), iCtrlId));
	return SetOption(TAB_CURRENT, iCtrlId, iNewValue);
}

// emmang@xbox xbox specific
// BEGIN_HELP_COMMENT
// Function: int UIProjOptionsTabDlg::SetProjOption(PROJ_PROP_CATEGORIES ProjPropCat, UINT iCtrlId, LPCSTR szNewValue)
// Description: Set a text-based option for the currently selected target, group, or file in the Project Settings dialog. (See SetLinkerOption(UINT, int) to set value-based linker options.)
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: iCtrlId An integer that contains the ID of the control for the option to set.
// Param: szNewValue A pointer to a string that contains the new value of the option.
// END_HELP_COMMENT
int UIProjOptionsTabDlg::SetProjOption(PROJ_PROP_CATEGORIES ProjPropCat, UINT iCtrlId, LPCSTR szNewValue)
{
	ShowProjSettingsTab(StringIDToTab(ProjPropCat));
	SetOption(TAB_CURRENT, CL_IDC_CATEGORY, GetCategory(StringIDToTab(ProjPropCat), iCtrlId));
	return SetOption(TAB_CURRENT, iCtrlId, szNewValue);
}
			

// emmang@xbox xbox specific
// BEGIN_HELP_COMMENT
// Function: int UIProjOptionsTabDlg::GetProjOption( UINT iCtrlId )
// Description: Get a value-based option for the currently selected target, group, or file in the Project Settings dialog. (See GetLinkerOptionStr(UINT) to get text-based linker options.)
// Return: An integer that contains the value of the linker option.
// Param: iCtrlId An integer that contains the ID of the control for the option to get.
// END_HELP_COMMENT
int UIProjOptionsTabDlg::GetProjOption(PROJ_PROP_CATEGORIES ProjPropCat, UINT iCtrlId)
{
	ShowProjSettingsTab(StringIDToTab(ProjPropCat));
	SetOption(TAB_CURRENT, CL_IDC_CATEGORY, GetCategory(StringIDToTab(ProjPropCat), iCtrlId));
	return GetOption(TAB_CURRENT, iCtrlId);
}

// emmang@xbox xbox specific
// BEGIN_HELP_COMMENT
// Function: LPCSTR UIProjOptionsTabDlg::GetProjOptionStr( UINT iCtrlId )
// Description: Get a text-based option for the currently selected target, group, or file in the Project Settings dialog. (See GetLinkerOptionStr(UINT) to get value-based linker options.)
// Return: A pointer to a string that contains the value of the linker option.
// Param: iCtrlId An integer that contains the ID of the control for the option to get.
// END_HELP_COMMENT
LPCSTR UIProjOptionsTabDlg::GetProjOptionStr(PROJ_PROP_CATEGORIES ProjPropCat, UINT iCtrlId)
{
	ShowProjSettingsTab(StringIDToTab(ProjPropCat));
	SetOption(TAB_CURRENT, CL_IDC_CATEGORY, GetCategory(StringIDToTab(ProjPropCat), iCtrlId));
	return GetOptionStr(TAB_CURRENT, iCtrlId);
}


// BEGIN_HELP_COMMENT
// Function: HWND UIProjOptionsTabDlg::ShowProjSettingsTab(void)
// Description: Display the  options tab in the Project Settings dialog that is indicate by iTab. see enum  PROJSET_TAB for a list of defines
// Return: The HWND of the options page tab, if successful; NULL otherwise.
// END_HELP_COMMENT
HWND UIProjOptionsTabDlg::ShowProjSettingsTab(UINT iTab)
{
	// see enum  PROJSET_TAB for a list of defines
	ShowPage(GetLocString(iTab));

	return GetCurrentPage();
}

int UIProjOptionsTabDlg::ExpandConfig(void)
	{
	GiveFocusToConfigList();
	MST.DoKeys("{RIGHT}");
	return ERROR_SUCCESS;
	}


int UIProjOptionsTabDlg::CollapseConfig(void)
	{
	GiveFocusToConfigList();
	MST.DoKeys("{LEFT}");
	return ERROR_SUCCESS;
	}


int UIProjOptionsTabDlg::GiveFocusToConfigList(void)
	{
	MST.WListSetFocus("@1");
	// REVIEW (michma): need to add verification?
	return ERROR_SUCCESS;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\uprjtdlg.h ===
///////////////////////////////////////////////////////////////////////////////
//  UPRJTDLG.H
//
//  Created by :            Date :
//      EnriqueP              2/7/94
//
//  Description :
//      Declaration of the UIProjOptionsTabDlg class
//

#ifndef __UPRJTDLG_H__
#define __UPRJTDLG_H__

#include "..\sym\vproj.h"
#include "..\sym\optnrc.h"
#include "..\shl\uitabdlg.h"
#include "..\shl\wbutil.h"
// emmang@xbox.com
#include "..\sym\xboxsyms.h"

#include "prjxprt.h"

#ifndef __UITABDLG_H__
	#error include 'uitabdlg.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//  UIProjOptionsTabDlg class

typedef enum
{
	CT_GENERAL			= VPROJ_IDC_PROJ_USEMFC,
	CT_EXT_DBGOPTS		= VPROJ_IDC_EXTOPTS_TARGET,
	CT_DEBUG			= VPROJ_IDC_PROG_WORKDIR,
	CT_MAKE_TYPE_LIB	= 19204, // REVIEW: get ID from OLE page
	CT_COMPILER			= 18723, // REVIEW: can't find control with this ID
	CT_RESOURCE			= OPTNRC_IDC_RESIGNPATH,
	CT_BROWSER			= VPROJ_IDC_BSCMAKE_DEFERRED, 
	CT_LINKER			= 19158, // REVIEW: can't find control with this ID
	CT_IMAGEBLD			= 15624
} PROJ_PROP_CATEGORIES ; 


//////////////////  GENERAL PAGE   //////////////////////////////////////////////
// Control ID's for General Page  ( original id's defined in vproj.h)
#define GEN_IDC_MFC				VPROJ_IDC_PROJ_USEMFC	 // Combo box
#define GEN_IDC_INTER_DIR		VPROJ_IDC_OUTDIRS_INT	 // Edit box
#define GEN_IDC_TARGET_DIR		VPROJ_IDC_OUTDIRS_TRG	 // Edit box

// Indexes for GEN_IDC_MFC combo box  in Directories Page
#define GEN_MFC_NOT_USED			1
#define GEN_MFC_STATIC				2
#define GEN_MFC_DLL					3

//////////////////  DEBUG PAGE   //////////////////////////////////////////////////////
// Control ID's for Debug Page  ( original id's defined in vproj.h)
#define DBG_IDC_CATEGORY		16112 /*VPROJ_IDC_MINI_PAGE*/	 	// Combo box
#define DBG_IDC_DEFAULT			16074 /*VPROJ_IDC_SET_DEFAULT*/	// Button
#define DBG_IDC_OPTIONS			16017 /*VPROJ_IDC_OPTSTR*/	 	// Multi line Edit box
#define DBG_IDC_EXE_FOR_SESSION	VPROJ_IDC_CALLING_PROG
#define DBG_IDC_WORKDIR			VPROJ_IDC_PROG_WORKDIR
#define DBG_IDC_ARGS			VPROJ_IDC_PROG_ARGS
#define DBG_IDC_REMOTE_TARGET	VPROJ_IDC_REMOTE_TARGET
#define DBG_IDC_TRY_LOCATE_DLLS VPROJ_IDC_LOAD_DLL_PROMPT

// **** Pre defined index values for Category combo
#define DBG_GENERAL				1		
#define DBG_ADDITIONAL_DLLS		2

//////////////////  MAKE TYPE LIB PAGE   //////////////////////////////////////////////
// Control ID's for Make Type Lib Page  ( original id's defined in vproj.h)



//////////////////  C/C++ COMPILER PAGE   //////////////////////////////////////////////
// Control ID's for C/C++ Compiler Page  ( original id's defined in vproj.h)
#define CL_IDC_CATEGORY			16112 /*VPROJ_IDC_MINI_PAGE*/	 	// Combo box
#define CL_IDC_DEFAULT			16074 /*VPROJ_IDC_SET_DEFAULT*/	// Button
#define CL_IDC_OPTIONS			16017 /*VPROJ_IDC_OPTSTR*/	 	// Multi line Edit box

// **** Pre defined index values for Category combo
#define CL_GENERAL				1		
#define CL_INTELX86				2
#define CL_CUSTOMIZE			3
#define CL_CUSTOMIZE_CXX		4
#define CL_LIST_FILES			5
#define CL_OPTIMIZATION			6
#define CL_PRECOMPILE_H			7
#define CL_PREPROCESSOR			8


// ********   General Mini Page control Id's

#define CL_IDC_WARN_LEVEL		18723	 	// Combo box
#define CL_IDC_DEBUG_INFO		18784		// Combo box
#define CL_IDC_OPTIMIZATIONS	18832	 	// Combo box
#define CL_IDC_WARN_AS_ERRORS	18724	 	// Check box
#define CL_IDC_GEN_BROWSE_INFO	18816		// Check box
#define CL_IDC_PREPROC_DEF		18896	 	// Edit Box		

// **** Pre defined values

#define CL_WARN_LEVEL_NONE		1		// Warning level combo indexes
#define CL_WARN_LEVEL_1			2
#define CL_WARN_LEVEL_2			3
#define CL_WARN_LEVEL_3			4
#define CL_WARN_LEVEL_4			5

// ********   Precompiled Headers controls ID's

#define CL_IDC_AUTOPCH			OPTNCPLR_IDC_AUTOPCH	 		// Check box
#define CL_IDC_AUTONAME			OPTNCPLR_IDC_AUTOPCHNAME	 	// Edit box
#define CL_IDC_CREATEPCH		OPTNCPLR_IDC_CREATEPCH	 		// Check box
#define CL_IDC_CREATENAME		OPTNCPLR_IDC_CREATENAME	 		// Edit box
#define CL_IDC_USEPCH			OPTNCPLR_IDC_USEPCH		 		// Check box
#define CL_IDC_USENAME			OPTNCPLR_IDC_USENAME	 		// Edit box
 
// ********   Preprocesser control ID's (emmang@xbox.com)

#define CL_IDC_ADD_INCLUDE		OPTNCPLR_IDC_INCLUDE


//////////////////  RESOURCE COMPILER PAGE   //////////////////////////////////////////////
// Control ID's for Resource Compiler Page  ( original id's defined in vproj.h)

//////////////////  BROWSE INFO PAGE   //////////////////////////////////////////////
// Control ID's for Browse Info Page  ( original id's defined in vproj.h)

//////////////////  LINKER PAGE   //////////////////////////////////////////////
// Control ID's for Linker Page  ( original id's defined in optnlink.h)

#define LNK_IDC_CATEGORY		16112 /*VPROJ_IDC_MINI_PAGE*/	 	// Combo box
#define LNK_IDC_DEFAULT			16074 /*VPROJ_IDC_SET_DEFAULT*/	// Button
#define LNK_IDC_OPTIONS			16017 /*VPROJ_IDC_OPTSTR*/	 	// Multi line Edit box

// **** Pre defined index values for Category combo
#define LNK_GENERAL				1		
#define LNK_CUSTOMIZE			2
#define LNK_DEBUG				3
#define LNK_INPUT				4
#define LNK_IMAGE_ATTRIBS		5


// ********   General Mini Page control Id's

#define LNK_IDC_TARGET_NAME			OPTNLINK_IDC_OUT	 		// Edit Box
#define LNK_IDC_OBJ_LIB_MOD			OPTNLINK_IDC_LIBS			// Edit Box
#define LNK_IDC_GEN_DEBUG_INFO		OPTNLINK_IDC_LNK_DBGFULL	// Check box
#define LNK_IDC_IGNORE_DEF_LIBS		OPTNLINK_IDC_EXLIB		 	// Check box
#define LNK_IDC_LINK_INCREMENT		OPTNLINK_IDC_INCLINK		// Check box
#define LNK_IDC_GEN_MAPFILE			OPTNLINK_IDC_MAPGEN		 	// Check box		
#define LNK_IDC_ENABLE_PROFILE		OPTNLINK_IDC_PROFILE	 	// Check box	

// added by emmang@xbox.com
#define LNK_IDC_MODULES				19088
#define LNK_IDC_ADDL_LIB_PATH		19092

// Project items on the Project Settings dialog listbox .
enum { PROJITEM_TARGET = 0, PROJITEM_GROUP, PROJITEM_FILE } ;

///////////////////////////////////////////////////////////////////////////////
 
// BEGIN_CLASS_HELP
// ClassName: UIProjOptionsTabDlg
// BaseClass: UITabbedDialog
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS UIProjOptionsTabDlg : public UITabbedDialog 
	{
    UIWND_COPY_CTOR (UIProjOptionsTabDlg, UITabbedDialog) ; 

// General Utilities
public:
	inline CString ExpectedTitle(void) const
	{ return GetLocString(IDSS_PROJ_OPTIONS_TITLE); }	   // Project Options
	
	HWND Display(void) ;

// Configuration pane utilities.
public:
	int ExpandConfig(void);
	int CollapseConfig(void);
	int GiveFocusToConfigList(void);
			
// Compiler Page Utilities
public:

	//	Project Settings tabs.  This enumeration sets up a mapping of 
	//  string IDs to symbols used when choosing a particular dialog
	//  tab to display for Project Settings.  Note that some symbols
	//  are identically defined in order to keep existing tests
	//  that relied on them from breaking.  The strings are derived
	//  from the window captions of the tabs.
	enum  PROJSET_TAB
	{
				TAB_GENERAL =        IDSS_PROJSET_GENERAL, 
				TAB_EXT_DBGOPTS =    IDSS_PROJSET_DEBUG, 
				TAB_DEBUG =          IDSS_PROJSET_DEBUG,
				TAB_CUSTBUILD =      IDSS_PROJSET_CUSTBUILD,
				TAB_COMPILER =       IDSS_PROJSET_CPLUSPLUS,
				TAB_CPLUSPLUS =      IDSS_PROJSET_CPLUSPLUS, 
				TAB_FORTRAN =        IDSS_PROJSET_FORTRAN,
				TAB_LINKER =         IDSS_PROJSET_LINKER,
				TAB_RESOURCE =       IDSS_PROJSET_RESOURCES, 
				TAB_MAKE_TYPE_LIB =  IDSS_PROJSET_TYPE_LIB, 
				TAB_BROWSER =        IDSS_PROJSET_BROWSER,
				TAB_IMAGEBLD =       IDSS_PROJSET_IMAGEBLD,
	};

	int SetProjOption(PROJ_PROP_CATEGORIES, UINT iCtrlId, int iNewValue) ;
	int SetProjOption(PROJ_PROP_CATEGORIES, UINT iCtrlId, LPCSTR szNewValue) ;
	int GetProjOption(PROJ_PROP_CATEGORIES, UINT iCtrlId);
	LPCSTR GetProjOptionStr(PROJ_PROP_CATEGORIES, UINT iCtrlId);

	HWND ShowCompilerTab(PROJSET_TAB = TAB_CPLUSPLUS);

	int SelectFile (CString szFileName,CString szGrpName = "", CString szTarget = "" );
	int SelectGroup(CString szGrpName, CString szTarget = ""  ) ;
	int SelectTarget(CString szTarget);


public:
	// Utility Project Tab methods
	HWND ShowProjSettingsTab(UINT iTab);	
   } ;

#endif //__UPRJTDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\uogaldlg.h ===
///////////////////////////////////////////////////////////////////////////////
//  uogaldlg.h
//
//  Created by :            Date :
//      EnriqueP              10/11/94
//
//  Description :
//      Declaration of the UIOGalleryDlg class
//

#ifndef __UIOG_DLG_H__
#define __UIOG_DLG_H__

#include "..\sym\vproj.h"
#include "..\shl\ucommdlg.h"
#include "..\shl\wbutil.h"
#include "prjxprt.h"
#include "afxcmn.h"			// Win95 controls
#include "..\wrk\uiwrkspc.h"


#ifndef __UIWINDOW_H__
   #error include 'udialog.h' before including this file
#endif


///////////////////////////////////////////////////////////////////////////////
//  UIOGalleryDlg, UOGCustomDlg & UOGImportDlg   Symbols

#define ID_OG_TABCTRL			0x402	// Control that has all the Tabs in the main dialog
#define ID_OG_CUSTOMIZE			0x03F5  // Customize button in main dialog
#define ID_OG_INSERT			0x03F2	// Insert button in main dialog
#define ID_OG_LISTCTRL			0x0406	// List Control in OG Main dialog 
#define ID_OG_SUBDIALOG			0x0001	// Window that contains list control and tab control

#define ID_OG_IMPORT			0x0006  // Import button in Customize dialog

#define ID_OG_FILE_NAME			0x0480	// File Name edit box in Import Dialog
#define ID_OG_COPY_TO_GALLERY	0x0412	// Copy to Gallery check box in Import Dialog
#define ID_OG_IMPORT_IMPORT		0x0001	// Import button in Import Dialog

typedef enum {ROGD_REPLACE = 0, ROGD_RESTORE} ROGD_VAL;

///////////////////////////////////////////////////////////////////////////////
//  UIOGalleryDlg class

// BEGIN_CLASS_HELP
// ClassName: UIOGalleryDlg
// BaseClass: UIDialog
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS UIOGalleryDlg : public UIFileDlg
{
   	UIWND_COPY_CTOR (UIOGalleryDlg, UIFileDlg) ;
public:
	virtual ~UIOGalleryDlg() { }

	inline CString ExpectedTitle(void) const
        { return  GetLocString(IDSS_OG_TITLE); }            // REVIEW:Title:  GetLocString(IDSS_OG_TITLE)

// Attributes
public:
	
	CListCtrl	m_OgletList;	// List control that contains components

// API'S
public:
	HWND Display(void);
	HWND Close(void);
	BOOL LookIn(LPCSTR szLocation);
	int Import( CString& strOglet, BOOL bCopyToGallery = FALSE);
	HWND Insert( CString& strOglet);
	HWND Insert( int nOglet);
	BOOL Insert(LPCSTR szComponent);

	int SelectComponent( CString& strOglet );
	int SelectComponent( int nOglet );
	BOOL SelectComponent(LPCSTR szComp);
	LPTSTR GetSelectedComponentText(void);

	CString	Description(void);

	int ActivateCategory( CString& strCategory );
	LPTSTR ActivateCategory( UINT nPage );
	HWND CreateCategory( CString& strCategory );

	int FindFileInGallery(CString ProjName, CString OgxName); 
	BOOL FindClassInClassView(CString ProjName, CString ClassName); 
	void AddToProject(CString FolderName, CString FileName, CString FullFileName); 
	void AddToGallery();
	BOOL DeleteFileInGallery(CString FolderName,CString FullFileName, CString OgxFileName); 

/*	BOOL VerifyInsert( OG_TEMPLATE ogTemplate);	*/

// Internal Functions
public:
	UINT GetPageCount(void);
	LPTSTR GetActivePageText(void);
	LPTSTR ActivateFirstPage(void);
	LPTSTR ActivateNextPage( BOOL bRight = TRUE);
	HWND GetTabHWnd(void);

// Other OG Functions
public:
	BOOL DeleteOGDatabase(CString& strPath);
	BOOL RenameOGDatabase(CString& strPath, CString& strNewName, ROGD_VAL nRestore = ROGD_REPLACE);
	LPTSTR GetGalleryDir(CString& strPath);

	BOOL VerifyFilesInDir(CStringList* pFileList, CString& strPath ); 
};

/**************************************************************/
//  UOGCustomDlg class  

class PRJ_CLASS UOGCustomDlg : public UIDialog
{
   	UIWND_COPY_CTOR (UOGCustomDlg, UIDialog) ;

// API'S
public:
	HWND Display(void);
	// HWND Close(void);  Do we need to overide it?

	inline CString ExpectedTitle(void) const
	{ return GetLocString(IDSS_OG_CUSTOM_TITLE); }		// REVIEW:Title:  GetLocString(IDSS_OG_CUSTOM_TITLE)

};

/**************************************************************/
//  UOGImportDlg class  

class PRJ_CLASS UOGImportDlg : public UIDialog
{
   	UIWND_COPY_CTOR (UOGImportDlg, UIDialog) ;

// API'S
public:
	HWND Display(void);
	// HWND Close(void);  Do we need to overide it?
	int SetName(CString& strName);
	int CopyToGallery( BOOL bCopyToGallery = TRUE);
	int Import(void);

	inline CString ExpectedTitle(void) const
	{ return "Import Component"; }		// REVIEW:Title:  GetLocString(IDSS_OG_IMPORT)

};

#endif //__UIOG_DLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\utstapwz.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	UTSTAPWZ.CPP
//
//	Created by :			Date :
//		Ivanl				12/29/94
//
//	Description :
//		Implementation of the UITestAppWizard class. 
//		This class corresponds to the Testing AppWizard, a custom appwizard used for snap tests.
													  
#include "stdafx.h"
#include "utstapwz.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\appwz.h"
#include "guiv1.h"
#include "..\shl\uiwbmsg.h"
#include "..\shl\wbutil.h"
 
#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

void UITestAppWizard::OnUpdate()
{
	UIProjectWizard::OnUpdate() ;
	Initialize() ;
//	m_pgArr.RemoveAll() ;
} 

void UITestAppWizard::Initialize()
{

  	pg0 =IDC_ITERATION, pg1 =APPWZ_IDC_RSC_LANG, pg2 = UIAW_DB_NONE, pg3 = APPWZ_IDC_NO_INPLACE ; 
    pg4 =APPWZ_IDC_PONOTDLL , pg5 =APPWZ_IDCD_POPRINT , pg6 =APPWZ_IDC_CLASS_LIST, confirm  = APPWZ_IDC_OUTPUT ;
	
	m_CurrPage.SetAt(pg0, "Custom dialog for the test appwizard") ;
	m_CurrPage.SetAt(pg1, "Comments/External/MFC libs options") ;
	m_CurrPage.SetAt(pg2, "OLE options") ;
	m_CurrPage.SetAt(pg3, "Database options") ;
	m_CurrPage.SetAt(pg4, "Project type") ;
	m_CurrPage.SetAt(pg5, "Project features") ;
	m_CurrPage.SetAt(pg6, "Classes list") ;
	m_CurrPage.SetAt(confirm, "Confirm dialog") ;

	m_pgArr.Add(&pg0) ;
	m_pgArr.Add(&pg1) ;
	m_pgArr.Add(&pg2) ;
	m_pgArr.Add(&pg3) ;
	m_pgArr.Add(&pg4) ;
	m_pgArr.Add(&pg5) ;
	m_pgArr.Add(&pg6) ;
	m_pgArr.Add(&confirm) ;
}

void UITestAppWizard::SetIteration(CString iteration)
{
	MST.WEditSetText(GetLabel(IDC_ITERATION),iteration) ;
};

CString UITestAppWizard::GetIteration()
{
	CString iteration ;
	MST.WListText(GetLabel(IDC_ITERATION),iteration) ;
	return iteration ;
} ;

HWND UITestAppWizard::Create() 
{	
	ExpectPage( UIAW_NEWPROJ );

    //BOOL bAppWiz = MST.WComboItemClk(GetLabel(APPWZ_IDC_PTCOMBO), "extwiz.dll");
	SetProjType("Testing AppWizard");
    MST.WButtonClick(GetLabel(IDOK));

   	// Wait five seconds for a "Subdir doesn't exist.  Do you really want to create... blah blah blah" message box.
	if (WaitMsgBoxText(GetLocString(IDSS_CREATE_DIR_PROMPT), 5))
		MST.WButtonClick(GetLabel(MSG_YES));	// Go ahead and say it's ok to create it.

	// Wait around until the Wizard dialog is displayed.
	if (WaitForWndWithCtrl(IDC_ITERATION, 2000))
		LOG->RecordInfo("Custom AppWizard successfully loaded") ;
	else 
		LOG->RecordFailure("Could not load Custom AppWizard") ;	
  return MST.WGetActWnd(0) ;   
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\utstapwz.h ===
///////////////////////////////////////////////////////////////////////////////
//	UTSTAPWZ.H
//
//	Created by :			Date :
//		Ivanl				12/29/94
//
//	Description :
//		Declaration of the UITestAppWizard class
//
#define IDC_ITERATION 1294

#ifndef __UTSTAPWZ_H__
#define __UTSTAPWZ_H__

#include "uappwiz.h"

#include "prjxprt.h"

#ifndef __UIAPPWIZ_H__ 
	#error include 'uappwiz.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//	UITestAppWizard class

// BEGIN_CLASS_HELP
// ClassName: UITestAppWizard
// BaseClass: UIAppWizard
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS UITestAppWizard: public UIAppWizard
{
	UIWND_COPY_CTOR(UITestAppWizard, UIAppWizard);
	virtual void OnUpdate(void);
	
	// Data
	WORD pg0 , pg1, pg2, pg3,pg4, pg5, pg6, confirm;

protected:
// Utilities
public:

	virtual void Initialize() ;
	virtual HWND Create(void);
	void SetIteration(CString iteration) ;
	CString GetIteration() ;
	
};

#endif //__UTSTAPWZ__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\uprojwiz.h ===
///////////////////////////////////////////////////////////////////////////////
//	UAPPWIZ.H
//
//	Created by :			Date :
//		Ivanl				10/14/94
//
//	Description :
//		Declaration of the UIProjectWizard class; Any wizard which creates a project
//

#ifndef __UPROJWIZ_H__
#define __UPROJWIZ_H__

#include "..\..\udialog.h"
#include "..\sym\vproj.h"
#include "..\shl\newfldlg.h"
#include "Strings.h"
#include "prjxprt.h"

#ifndef __UIDIALOG_H__
	#error include 'udialog.h' before including this file
#endif

#include <afxtempl.h>
///////////////////////////////////////////////////////////////////////////////
//	UIProjectWizard class

// The following enumeration lists the types of projects that can currently
// be opened by the IDE. Each item in this enum corresponds to a string ID,
// which in-turn identifies a string that matches a project type.  There are
// actually two sets here, one for the COProject class and one for the 
// UIProjectWizard.  This was done so as to not break any tests, by removing
// any of the previously defined symbols.  The two sets exists here rather 
// than split across two headers for easier maintenance.  However, if a 
// restructuring of CAFE ever occurs, this should definitely be reconsidered. 
enum PROJTYPE 
{		
		UIAW_PT_APPWIZ = IDSS_PROJTYPE_APPWIZ_APP,
		UIAW_PT_APPWIZ_DLL = IDSS_PROJTYPE_APPWIZ_DLL,
		UIAW_PT_OCX = IDSS_PROJTYPE_OLE_CONTROLWIZ,		
		UIAW_PT_APP = IDSS_PROJTYPE_APPLICATION,
		UIAW_PT_DLL = IDSS_PROJTYPE_DLL,
		UIAW_PT_CONSOLE = IDSS_PROJTYPE_CONSOLE,
		UIAW_PT_STATIC_LIBRARY = IDSS_PROJTYPE_STATIC_LIB,
		UIAW_PT_QUICKWIN = IDSS_PROJTYPE_QUICKWIN,
		UIAW_PT_STD_GRAPH = IDSS_PROJTYPE_STD_GRAPH,
		UIAW_PT_GENPROJ = IDSS_PROJTYPE_GENPROJECT,
		UIAW_PT_EXT_TARG = IDSS_PROJTYPE_EXT_TARG,
		UIAW_PT_CUST_APPWIZ = IDSS_PROJTYPE_CUST_APPWIZ,
		UIAW_PT_JAVA_PROJECT = IDSS_PROJTYPE_JAVA_PROJECT,
		UIAW_PT_JAVA_APPWIZ = IDSS_PROJTYPE_JAVA_APPWIZ,
		UIAW_PT_MAKEFILE = IDSS_PROJTYPE_EXT_TARG,
		UIAW_PT_XBOX = IDSS_PROJTYPE_XBOX_GAME,
		UIAW_PT_XBOX_LIB = IDSS_PROJTYPE_XBOX_LIB,

		APPWIZ_EXE = IDSS_PROJTYPE_APPWIZ_APP,
		APPWIZ_DLL = IDSS_PROJTYPE_APPWIZ_DLL,
		APPWIZ_OCX = IDSS_PROJTYPE_OLE_CONTROLWIZ,			
		EXE = IDSS_PROJTYPE_APPLICATION,		
		DLL = IDSS_PROJTYPE_DLL,		
		CONSOLE_APP = IDSS_PROJTYPE_CONSOLE,	
		STATIC_LIBRARY = IDSS_PROJTYPE_STATIC_LIB,
		DATABASE_PROJECT = IDSS_PROJTYPE_DATABASE,
		ACTIVEX_CONTROL = IDSS_PROJTYPE_OLE_CONTROLWIZ,
		GENERIC_PROJECT = IDSS_PROJTYPE_GENPROJECT,
		ATL_COM = IDSS_PROJTYPE_ATL_COM_WIZ,
		ISAPI_EXTENSION = IDSS_PROJTYPE_ISAPI_EXTENSION,
		XBOX_PROJECT = IDSS_PROJTYPE_XBOX_GAME,
		XBOX_LIB_PROJECT = IDSS_PROJTYPE_XBOX_LIB
};

// for inserting projects.
enum PROJ_HIERARCHY {TOP_LEVEL_PROJ, SUB_PROJ};

// for creating projects.
enum PROJ_WORKSPACE {CREATE_NEW_WORKSPACE, ADD_TO_CURRENT_WORKSPACE};

// BEGIN_CLASS_HELP
// ClassName: UIProjectWizard
// BaseClass: UIDialog
// Category: Project
// END_CLASS_HELP
class PRJ_CLASS UIProjectWizard : public UIDialog
{
	UIWND_COPY_CTOR(UIProjectWizard, UIDialog);
	virtual void OnUpdate(void);

// Data
public:
BOOL IsValid() ;
UINewFileDlg m_FlNewDlg ;

protected:
	int m_nPage;
//	CTypedPtrMap<CMapPtrToPtr, WORD, CString> m_CurrPage ;
	CMap<WORD, WORD &, CString, LPCSTR> m_CurrPage ;
	CPtrArray m_pgArr ;


// Utilities
public:
	inline virtual CString ExpectedTitle(void) const
		{	return ExpectedTitle(-1); }
	virtual CString ExpectedTitle(int nPage) const;

	virtual void Initialize() { };
	int NextPage(void);
	int NextPage(int);	//Specify a specific control ID For WaitWndWithCtrl
	int PrevPage(void);
	int Finish(void);
	int Finish(int);	//Specify a specific control ID For WaitWndWithCtrl
	virtual HWND Cancel(void);

	void SetProjType(PROJTYPE);
	void SetProjType(CString Name); // Name as it shows up in the combobox.
	void SetName(LPCSTR szName);
	void SetHierarchy(PROJ_HIERARCHY phProjHier);
	void SetTopLevelProj(LPCSTR szProjName);
	void SetLocation(LPCSTR szPath); // simpler, more up-to-date version of SetDir().
	void SetDir(LPCSTR szName);
	void SetSubDir(LPCSTR szName);
	void SetPlatform(int iPlatform) ;
	void SetAddToWorkspace(BOOL AddToWorkspace);
	virtual HWND Create(void);
	virtual BOOL ConfirmCreate(void);
	  
	// Helper functions
public:
	virtual WORD GetCurrentPage() ;
	virtual WORD GoToPage(int ID) ;
	virtual int GetPage(HWND hwnd = NULL);
	virtual int UpdatePage(void);
	virtual void ExpectPage(int nPage);
	HWND GetSubDialog(void);
	LPCSTR GetLabel(UINT id);
};

#endif //__UPROJWIZ_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		BrianCr				09/06/94
//
//	Description :
//		source file that includes just the standard includes
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		BrianCr				09/06/94
//
//	Description :
//		Precompiled header for all of the core MFC files
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\prj\uprojwiz.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UPROJWIZ.CPP
//
//  Created by :            Date :
//      Ivanl                 10/14/94
//
//  Description :
//      Implementation of the UIProjectWizard class
//
													  
#include "stdafx.h"
#include "uprojwiz.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\appwz.h"
#include "..\sym\vproj.h"
#include "..\shl\ucommdlg.h"
#include "..\shl\uwbframe.h"
#include "..\shl\wbutil.h"
#include "..\shl\uiwbmsg.h"
#include "uappwiz.h"
#include "guitarg.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

void UIProjectWizard::OnUpdate(void)
{
	UIDialog::OnUpdate();
    m_nPage = GetPage();
}

WORD UIProjectWizard::GetCurrentPage()
{
	//Go through the array and find which control exists on the active page. 
	for(int i = 0; i < m_pgArr.GetSize(); i++)
	{
		WORD * ctlId ;
		ctlId = (WORD *)m_pgArr.GetAt(i) ;
		if (ControlOnPropPage(* ctlId))
			return *ctlId ;	 // Returns the ID which uniquely identifys the active page.
	} 
	return NULL ;
}


WORD UIProjectWizard::GoToPage(int ID) 
{
 	// Find the page we are on
 	WORD GoNext = 0;
	WORD wActive = GetCurrentPage() ;
	//if we are sitting at the control we want, just return
	if (ID == wActive)
		return wActive ;
	// Find the relationship between the wanted and active pages
 	for(int i =0; i < m_pgArr.GetSize(); i++)
	{	
		if (*((WORD *)(m_pgArr.GetAt(i))) == ID)
		{											     
			GoNext = 0 ;
			break ; 
		}
		if (*((WORD *)(m_pgArr.GetAt(i))) == wActive)
		{	
			GoNext = 1 ;
			break ; 
		}
	}
	// If the active page is before the one we want, move forward, else move backwards.
	if (GoNext) 
	{
		do
			NextPage() ;
		while(GetCurrentPage() != ID) ; 			
	} 
	else
	{
		do
			PrevPage() ;
		while(GetCurrentPage() != ID);			
	}
   return GetCurrentPage() ;
}

BOOL UIProjectWizard::IsValid() 
{
	if(!WaitForWndWithCtrl(VSHELL_IDC_PROJECTTYPES,1500))
		return FALSE ;
	return TRUE ;

} 

int UIProjectWizard::GetPage(HWND hwnd /*=NULL*/)
{

    if( hwnd == NULL )
        hwnd = WGetActWnd(0);
    if( !::IsWindow(hwnd) )
        return UIAW_INVALID;

	return -1 ; //Place holder.
 }

int UIProjectWizard::UpdatePage(void)
{
    AttachActive();
    return m_nPage;
}

void UIProjectWizard::ExpectPage(int nPage)
{
}

CString UIProjectWizard::ExpectedTitle(int nPage) const
{
  return CString(""); // Place holder  
}

int UIProjectWizard::NextPage(void)
{
	HWND hmsg;
    MST.WButtonClick(::GetLabel(IDOK));
	 // If prompted about an GUID already exists, or any other error message, say YES.
    if( (hmsg=WaitForWndWithCtrl(8,500)) || (hmsg=WaitForWndWithCtrl(6,500)) )
		MST.DoKeyshWnd(hmsg,"{ENTER}") ;

    return UpdatePage();
}
int UIProjectWizard::NextPage(int ctrlID)
{
	HWND hmsg;
    MST.WButtonClick(::GetLabel(IDOK));
	// This NextPage member function expects that a dialog will arise
	//with a control with the passed ID that needs pressing
    if (hmsg=WaitForWndWithCtrl(ctrlID,500)) 
		MST.DoKeyshWnd(hmsg,"{ENTER}") ;

    return UpdatePage();
}

int UIProjectWizard::PrevPage(void)
{
	if( GetCurrentPage() ==  APPWZ_IDC_OUTPUT)
	    MST.DoKeyshWnd(HWnd(),"{ESC}") ;
	else
		MST.WButtonClick(::GetLabel(APPWZ_IDC_BACK));
    return UpdatePage();
}

int UIProjectWizard::Finish(void)
{
	HWND hmsg;
    MST.WButtonClick(GetLocString(IDSS_PROJWIZ_FINISH));
	 // If prompted about an GUID already exists, or any other error message, say YES.
    if( (hmsg=WaitForWndWithCtrl(6,500)) || (hmsg=WaitForWndWithCtrl(8,500)) )
		MST.DoKeyshWnd(hmsg,"{ENTER}") ;

    return UpdatePage();
}
int UIProjectWizard::Finish(int ctrlID)
{
	HWND hmsg;
    MST.WButtonClick(GetLocString(IDSS_PROJWIZ_FINISH));
	// This Finish member function expects that a dialog will arise
	//with a control with the passed ID that needs pressing
    if (hmsg=WaitForWndWithCtrl(ctrlID,500))
		MST.DoKeyshWnd(hmsg,"{ENTER}") ;

    return UpdatePage();
}

HWND UIProjectWizard::Cancel(void)
{
	HWND hwnd = UIDialog::Cancel();
    UpdatePage();
	return hwnd;
}

HWND UIProjectWizard::Create(void)
{
   MST.WButtonClick(GetLabel(IDOK));

   	// Wait five seconds for a "Subdir doesn't exist.  Do you really want to create... blah blah blah" message box.
	if (WaitMsgBoxText(GetLocString(IDSS_CREATE_DIR_PROMPT), 5))
		MST.WButtonClick(GetLabel(MSG_YES));	// Go ahead and say it's ok to create it.
    DWORD dwProcessId ;

    GetWindowThreadProcessId(UIWB.HWnd(), &dwProcessId);

	// wait until we don't get any Save Changes? message boxes
	for (int i = 0; i < 20; i++) {
		// 8 is the Yes button
		if (WaitForSingleControl(dwProcessId, 8, 500) == WAIT_CONTROL_0) {
	//		if (bSaveChanges) {
				// click Yes
				MST.WButtonClick(GetLabel(GL_SCROLLBAR));
		//	}
		//	else {
				// click No
				MST.WButtonClick(GetLabel(GL_SLIDER));
		//	}
		}
		else {
			break;
		}
	}

	// too many Save Changes? message boxes
	if (i >= 20) {
		LOG->RecordInfo("%s: detected more than 20 Save Changes? message boxes when creating new project. Unable to start AppWizard.", "UIProjectWizard::Create");
		return NULL;
	}


   return MST.WGetActWnd(0); 

}

BOOL UIProjectWizard::ConfirmCreate(void)
{
	int WaitMore = 60000 ;
	ExpectPage( UIAW_CONFIRM );
    MST.WButtonClick(GetLabel(IDOK));

    if( GetPage() == UIAW_MESSAGEBOX )
        return FALSE;

	// Wait for the source control dialog up to 1 minute,
	
    WaitForInputIdle(g_hTargetProc, 60000);

	if(IsWindow(HWnd())) // If the AppWiz Dlg is still a window, we have a problem.
	    return FALSE ;

	// Get rid of the Source control dialog if it shows up. REVIEW(Ivanl) process source control later!
	MST.DoKeys("{ESC}") ;
 
/*
	(Let's handle this in the tests, shall we?  - BJoyce)	
	// This handles the case where newly created project has a name similar to that of an already registered project.
	if(UIWB.WaitOnWndWithCtrl(0x6,2000))
	{
		LOG->RecordInfo("Message box came up and clicked the default: Probably a project name has been reused.");
		 MST.DoKeys("{ENTER}") ;
	
	}
*/

/*
	(This was only a temporary situation during V5 development - BJoyce)   
	//This handles the case where newly created project has a name similar to that of an already registered project.
	if(UIWB.WaitOnWndWithCtrl(0x6, 2000))
	{
		LOG->RecordInfo("Message box came up and clicked the default: Probably a project name has been reused.");
		MST.DoKeys("{ENTER}");
	}
*/

    return TRUE;
}

void UIProjectWizard::SetProjType(PROJTYPE type)
{
//    ExpectPage( UIAW_NEWPROJ );
	SetProjType(GetLocString(type));
	Sleep (1000);    // BJoyce - 266MHZ machines are fast!

//    MST.WListItemClk(GetLabel(VPROJ_IDC_PROJ_TYPE), GetLocString(type));
}

void UIProjectWizard::SetName(LPCSTR szName)
{
  //  ExpectPage( IDC_PROJ_NAME );
	m_FlNewDlg.SetName(szName) ;
}

// toggle either the "Top level project" or "Subproject of:" 
// option buttons in the "Insert Project" dlg.
void UIProjectWizard::SetHierarchy(PROJ_HIERARCHY phProjHier)
{
	MST.WOptionSelect(GetLabel(VSHELL_IDC_ADDTOCURRENTWORKSPACE));
	if(phProjHier == TOP_LEVEL_PROJ)
		; //Just do nothing we this is default setting.
	else
		MST.WCheckCheck(GetLabel(VSHELL_IDC_DEPENDENCYOF));
}


// set the "Subproject of:" combo box in the "Insert Project" dlg.
void UIProjectWizard::SetTopLevelProj(LPCSTR szProjName)
	{
	// dependency checkbox must be checked for combo box (below) to be enabled.
	MST.WCheckCheck(GetLabel(VSHELL_IDC_DEPENDENCYOF));
	// combo box in question should be 1st in tab order. it has no label. 
	MST.WComboItemClk("@1", (CString)szProjName);
	}


void UIProjectWizard::SetLocation(LPCSTR szPath) // simpler, more up-to-date version of SetDir().
	{
	if(szPath)
		m_FlNewDlg.SetLocation(szPath) ;
	}


void UIProjectWizard::SetDir(LPCSTR szName)
{
 
	MST.WButtonClick(GetLabel(VSHELL_IDC_BROWSE));
    WaitForInputIdle(g_hTargetProc, 10000);
	UIDialog dlgBrowse;
	MST.WFndWndWait(GetLocString(IDSS_CHOOSE_DIR_TITLE), FW_CASE | FW_FOCUS | FW_HIDDENNOTOK, 5);
	dlgBrowse.WaitAttachActive(2000);
	MST.WEditSetText(NULL, szName);	// ID from ucommdlg.h

	// this first ok will close the dlg on nt4 and win95 if the specified dir was already current.
	// otherwise this ok will just change dirs.
	MST.WButtonClick(GetLabel(IDOK));
	WaitForInputIdle(g_hTargetProc, 10000);

	// if the ide had to change dirs, then this ok will close the dlg on nt4 and win95.
	if (dlgBrowse.IsActive())
	{
		MST.WButtonClick(GetLabel(IDOK));
		WaitForInputIdle(g_hTargetProc, 10000);
	}
	
	// todo(michma): a third ok is needed on win98 due to a bug where they change the
	// capitalization of the directory selected in the listbox on the 2nd ok. weird.
	if (dlgBrowse.IsActive())
	{
		MST.WButtonClick(GetLabel(IDOK));
		WaitForInputIdle(g_hTargetProc, 10000);
	}
}

void UIProjectWizard::SetProjType(CString Name)
{
//	MST.DoKeyshWnd(HWnd(),"^{TAB}") ; //review (chriskoz) bogus tab
	m_FlNewDlg.NewProjectTab() ;
	m_FlNewDlg.SelectFromList(Name) ;
}

// The intent of this function is to set a subdirectory off of the base directory that
// we're currently set at.  Most likely a SetDir() call preceded this call.
void UIProjectWizard::SetSubDir(LPCSTR szName)
{

/*
	(Let's not get too protective here, this stops logo testing. - BJoyce)
	// Make sure that there is no drive or root specifier on the subdirectory name.
	// This case also effectively filters UNC paths, which are also not allowed.
	if (szName[0] == '\\' || (strlen(szName) > 1 && szName[1] == ':'))
	{
		ASSERT(FALSE);		// Assert in debug.
		return;				// Just return in retail.
	}
*/

	CString Name(' ', MAX_PATH);
	MST.WEditText(GetLabel(VSHELL_IDC_LOCATIONFORPROJECT), Name);		// Get the current working directory.
	if (Name.ReverseFind('\\') != (Name.GetLength() -1))
		Name+=(CString ) "\\";	// append a trailing backslash only if it doesn't exist
	Name+=szName;	// append the subdirectory specifier.
	MST.WEditSetText(GetLabel(VSHELL_IDC_LOCATIONFORPROJECT), Name);	// Set the new directory.
}

void UIProjectWizard::SetPlatform(int iType) 
{
    ASSERT( iType <= MST.WListCount(GetLabel(VSHELL_IDC_PLATFORMS)) );
	MST.WListItemClk(GetLabel(VSHELL_IDC_PLATFORMS), iType, 8);		// make sure to click in checkbox
}


void UIProjectWizard::SetAddToWorkspace(BOOL AddToWorkspace) 
{
	// expected the Project pane of new dialog to be open
	if(AddToWorkspace)
		MST.WOptionClick(GetLabel(0x52e2));		// make sure to click in checkbox
	else
		MST.WOptionClick(GetLabel(0x52e1));		// make sure to click in checkbox
}

HWND UIProjectWizard::GetSubDialog(void)	// return the child dialog (the current page)
{
	HWND hwnd = GetWindow(HWnd(), GW_CHILD);
	hwnd = GetWindow(hwnd, GW_HWNDLAST);
	char acClass[32];
	::GetClassName(hwnd, acClass, 31);
	if( strcmp(acClass, "#32770") != 0 )	// REVIEW: there is only one sub-dialog, isn't there?
		return NULL;						// if not, we may need to find the Visible one.
	return hwnd;
}

LPCSTR UIProjectWizard::GetLabel(UINT id)
{
	HWND hwnd = GetSubDialog();
	LPCSTR sz = NULL;
	if( hwnd != NULL )
		sz = ::GetLabel(id, hwnd, TRUE);		// try to find it in the sub-dialog (if there is on)
	if( sz != NULL )
		return sz;
	else
		return ::GetLabel(id);			// but if it doesn't work, try in the main dialog (e.g. the Next/Back buttons)
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\export.h ===
///////////////////////////////////////////////////////////////////////////////
//	export.h (res export)
//
//	Created by :			Date :
//		ScotF			06/20/97
//
//	Description :
//		res DLL defines
//

#ifndef __RESXPRT_H__
#define __RESXPRT_H__

#ifdef EXPORT_RES
	#define RES_CLASS AFX_EXT_CLASS
	#define RES_API   AFX_EXT_API
	#define RES_DATA  AFX_EXT_DATA
#else
	#define RES_CLASS __declspec(dllimport)
	#define RES_API   __declspec(dllimport)
	#define RES_DATA  __declspec(dllimport)

	#ifdef _DEBUG 
		#pragma comment(lib, "resd.lib")
	#else
		#pragma comment(lib, "res.lib")
	#endif
#endif

#endif // __RESXPRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\coresscr.h ===
///////////////////////////////////////////////////////////////////////////////
//  CORESSCR.H
//
//  Created by :            Date :
//      EnriqueP                 1/7/94
//
//  Description :
//      Declaration of the COResScript class
//

#ifndef __CORESSCR_H__
#define __CORESSCR_H__

#include "uresedit.h"
#include "..\eds\cofile.h"
#include "..\wrk\uiwrkspc.h"

#include "export.h"

#define ERROR_ERROR -1

///////////////////////////////////////////////////////////////////////////////
//  COResScript class

// BEGIN_CLASS_HELP
// ClassName: COResScript
// BaseClass: COFile
// Category: Editors
// END_CLASS_HELP
class RES_CLASS COResScript : public COFile 
{

public:
	COResScript();
// Attributes

// Data
private:
    
// Generic Utilities
public:
    

//File I/O
public:
	int Create( LPCSTR szSaveAs = NULL );			 	// RC files
	int Open(LPCSTR szFileName, LPCSTR szChDir = NULL );
//	int Close(void);
//	int Save(UINT nParam);
//	int SaveAs(LPCSTR szName, UINT nFileType);

// Resource management									
public:
	int CreateResource( UINT idResType );	     	// Used for predefined resource types	
	int CreateResource( LPCSTR szResName );			// Used for custom resource types	   		
	int CreateResource(UINT idResType, UIResEditor& resEditor);
	int OpenResource(UINT idResType, LPCSTR szResName, UIResEditor& resEditor);
	int AddMenu(LPCSTR szMenuName, LPCSTR szMenuItem, UIResEditor& resEditor);
	int ChangeDialogCaption( LPCSTR szDialogCaption, UIResEditor& resEditor);
	int ChangeDialogID( LPCSTR szNewDialogID, LPCSTR szOldDialogID);
/*	int OpenResource(UINT nResId, RC_TYPE rcType);
	int DeleteResource(UINT nResId, RC_TYPE rcType);
	int CopyResource(UINT nResId, RC_TYPE rcType);
	int CutResource(UINT nResId, RC_TYPE rcType);
	int PasteResource(UINT nResId, RC_TYPE rcType);
	int ExportResource(UINT nResId, RC_TYPE rcType, LPCSTR szName, UINT nFileType);	   */

	
//  To be implemented later

//  CStrint MoveResource(UINT nResId, RC_TYPE rcType, UINT nRCid2);
//	int ImportResource(LPCSTR szName);
//	void CloseAllRes(void);
	
//	LPCSTR GetResProp(UINT nPropId, UINT nRCid);
//	int SetResProp(UINT nPropId, LPCSTR szProp);

};

///////////////////////////////////////////////////////////////////////////////
// COResScript #defines



#endif //__CORESSCR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\dllmain.cpp ===
/////////////////////////////////////////////////////////////////////////////
// dllmain.cpp
//
// email	date		change
// michma	06/17/97	created
//
// copyright 1997 Microsoft

#include "stdafx.h"
#include "afxdllx.h"

#define new DEBUG_NEW

///////////////////////////////////////////////////////////////////////////////
//	DLL support

static AFX_EXTENSION_MODULE extensionDLL = { NULL, NULL };

extern "C" __declspec(dllexport) int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("Res DLL Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(extensionDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(extensionDLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("Res DLL Terminating!\n");
		// Terminate the library before destructors are called
		AfxTermExtensionModule(extensionDLL);
	}
	return 1;   // ok

	UNREFERENCED_PARAMETER(lpReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\coresscr.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	CORESSCR.CPP
//
//	Created by :			Date :
//		EnriqueP					1/24/94
//
//	Description :
//		Implementation of the COResScript component object class
//

#include "stdafx.h"
#include "coresscr.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\cmdids.h"
#include "..\sym\vres.h"
#include "guiv1.h"
#include "guitarg.h"
#include "..\shl\uwbframe.h"
#include "Strings.h"
#include "..\shl\wbutil.h"
#include "..\shl\upropwnd.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

COResScript::COResScript()
{
 
}

// BEGIN_HELP_COMMENT
// Function: int COResScript::Create(LPCSTR szSaveAs /*=NULL*/)
// Description: Create a new resource script in the IDE.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szSaveAs A pointer to a string that contains the name to save the new file with. NULL indicates don't save (no name specified). (The default value is NULL.)
// END_HELP_COMMENT
int COResScript::Create(LPCSTR szSaveAs /*=NULL*/)
{
	return COFile::Create(IDSS_NEW_RC, szSaveAs);		
}

// BEGIN_HELP_COMMENT
// Function: int COResScript::Open(LPCSTR szFileName, LPCSTR szChDir /*=NULL*/)
// Description: Open a resource script file and its editor in the IDE.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szFileName A pointer to a string that contains the name of the file to open.
// Param: szChDir A pointer to a string that contains the path to the file. NULL if szFileName includes a path or szFileName is in the current directory). (The default value is NULL.)
// END_HELP_COMMENT
int COResScript::Open(LPCSTR szFileName, LPCSTR szChDir /*=NULL*/)
{
	return COFile::Open(szFileName, szChDir, OA_AUTO);
}

// BEGIN_HELP_COMMENT
// Function: int COResScript::CreateResource(UINT idResType)
// Description: Add a resource to this resource script.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: idResType An value that contains the type of resource to add: IDSS_RT_ACCELERATOR, IDSS_RT_BINARY, IDSS_RT_BITMAP, IDSS_RT_CURSOR, IDSS_RT_DIALOG, IDSS_RT_ICON, IDSS_RT_MENU, IDSS_RT_STRING_TABLE, IDSS_RT_VERSION.
// END_HELP_COMMENT
int COResScript::CreateResource( UINT idResType )	   // This one uses the string table
{
	const char* const THIS_FUNCTION = "COResScript::CreateResource";

	CString strResType = GetLocString(idResType);

	UIWB.DoCommand(IDM_RESOURCE_NEW, DC_MNEMONIC);
	Sleep(1000) ; // Wait a little for the dialog to be displayed.
	MST.WButtonClick(GetLabel(VRES_IDC_CUSTOMTYPE));
	
	UIDialog nrd(VRES_IDC_TYPE_NAME, GL_EDIT);
	if( !nrd.WaitAttachActive(2000) )
	{
		LOG->RecordInfo("%s: could not open Resource/New dialog", THIS_FUNCTION);
		return ERROR_ERROR;
	}

	MST.WEditSetText(GetLabel(VRES_IDC_TYPE_NAME), strResType);

	if (!MST.WButtonEnabled(GetLabel(IDOK)))  // Timeout supposedly defaults to 5 sec.
	{
		LOG->RecordFailure("%s: timeout waiting for OK button on New Resource Dialog to become enabled.", THIS_FUNCTION);
		return ERROR_ERROR;
	}

	nrd.OK();
	nrd.WaitUntilGone(2000);

	WaitForInputIdle(g_hTargetProc, 10000);

	// verify the resource editor window came up
	BOOL bFound = FALSE;
	strResType.MakeUpper();	// We need to compare using matching case.
	for (int i = 0; i < 5; i++) {
		if (MST.WFndWndWait(strResType, FW_PART, 2) != 0){
		bFound = TRUE;
		break;
		}

	/*	HWND hwndEd = UIWB.GetActiveEditor();
    	CString title = ::GetText(hwndEd);
 		title.MakeUpper();
		if (title.Find(strResType) >= 0) {
			bFound = TRUE;} */
			
		
		Sleep(500);
	}

	if (!bFound) {
		LOG->RecordInfo("%s: did not find resource editor window '%s'. Could not create resource editor.", THIS_FUNCTION, (LPCSTR)strResType);
		return ERROR_ERROR;
	}

	return ERROR_SUCCESS;
}

// BEGIN_HELP_COMMENT
// Function: int COResScript::CreateResource( LPCSTR szResName )
// Description: Add a resource to this resource script. This function, since it takes the name of the type of resource as a pointer to a string, is generally used for custom resource types.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szResName A pointer to a string that contains the name of the resource to add.
// END_HELP_COMMENT
int COResScript::CreateResource( LPCSTR szResName )		// This one is generally used for custom resource types
{
	UIWB.DoCommand(IDM_RESOURCE_NEW, DC_MNEMONIC);
	if( MST.WFndWndWait(GetLocString(IDSS_NEW_RES_TITLE), FW_PART, 2) == 0 )	// make sure the dialog comes up
		return ERROR_ERROR;		
	MST.WButtonClick(GetLabel(VRES_IDC_CUSTOMTYPE));
        Sleep(2000);
	MST.DoKeys(szResName);				// Type Name of resource .... 

	if (!MST.WButtonEnabled(GetLabel(IDOK)))  // Timeout supposedly defaults to 5 sec.
	{
		LOG->RecordFailure("Timeout waiting for OK button on New Resource Dialog to become enabled.");
		return ERROR_ERROR;
	}

	MST.WButtonClick(GetLabel(IDOK));

	if( MST.WFndWndWait(szResName, FW_PART, 2)  == 0 ) // Wait for the editor to come up and verify the Caption
		return ERROR_ERROR;

	return ERROR_SUCCESS;
}

// BEGIN_HELP_COMMENT
// Function: int COResScript::CreateResource(UINT idResType, UIResEditor& resEditor)
// Description: Add a resource to this resource script.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: idResType An value that contains the type of resource to add: IDSS_RT_ACCELERATOR, IDSS_RT_BINARY, IDSS_RT_BITMAP, IDSS_RT_CURSOR, IDSS_RT_DIALOG, IDSS_RT_ICON, IDSS_RT_MENU, IDSS_RT_STRING_TABLE, IDSS_RT_VERSION.
// Param: resEditor A reference to a UIResEditor object that will contain the resource editor created.
// END_HELP_COMMENT
int COResScript::CreateResource(UINT idResType, UIResEditor& resEditor)
{
	const char* const THIS_FUNCTION = "COResScript::CreateResource";

	// create the resource
	if (CreateResource(idResType) == ERROR_SUCCESS) {
		resEditor = UIWB.GetActiveEditor();
		if (resEditor.IsValid()) {
			return ERROR_SUCCESS;
		}
		else {
			LOG->RecordInfo("%s: resource editor '%s' is not valid (UIResEditor::IsValid failed).", THIS_FUNCTION, resEditor.GetTitle());
		}
	}
	else {
		LOG->RecordInfo("%s: cannot create resource editor %d (COResScript::CreateResource failed).", THIS_FUNCTION, idResType);
	}

	return ERROR_ERROR;
}


// BEGIN_HELP_COMMENT
// Function: int COResScript::OpenResource(UINT idResType, LPCSTR szResName, UIResEditor& resEditor)
// Description: Open a resource.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: idResType An value that contains the type of resource: IDSS_RT_ACCELERATOR, IDSS_RT_BINARY, IDSS_RT_BITMAP, IDSS_RT_CURSOR, IDSS_RT_DIALOG, IDSS_RT_ICON, IDSS_RT_MENU, IDSS_RT_STRING_TABLE, IDSS_RT_VERSION.
// Param: szResName A pointer to a string that contains the name of the resource.
// Param: resEditor A reference to a UIResEditor object that will contain the resource editor created.
// END_HELP_COMMENT
int COResScript::OpenResource(UINT idResType, LPCSTR szResName, UIResEditor& resEditor)
{
	const char* const THIS_FUNCTION = "COResScript::OpenResource";

	CString strResType = GetLocString(idResType);
	UIWorkspaceWindow uiwksp;

	if( !uiwksp.ActivateResourcePane() )
	{
		LOG->RecordInfo("%s: cannot activate resource pane (UIWorkspaceWindow::ActivateResourcePane failed).", THIS_FUNCTION);
	}

	// create the resource
	if (uiwksp.SelectResource(strResType, szResName) == SUCCESS)
	{
		MST.DoKeys("{Enter}");
		resEditor = UIWB.GetActiveEditor();
		if (resEditor.IsValid()) 
		{
			return ERROR_SUCCESS;
		}
		else
		{
			LOG->RecordInfo("%s: resource editor '%s' is not valid (UIResEditor::IsValid failed).", THIS_FUNCTION, resEditor.GetTitle());
		}
	}
	else
	{
		LOG->RecordInfo("%s: cannot select resource %d (UIWorkspaceWindow::SelectResource failed).", THIS_FUNCTION, idResType);
	}

	return ERROR_ERROR;
}

// BEGIN_HELP_COMMENT
// Function: int COResScript::AddMenu(LPCSTR szMenuName, LPCSTR szMenuItem, UIResEditor& resEditor)
// Description: Add menu to the end of menu bar of opened Menu resource and also add the first menu item to this menu.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szMenuName A pointer to a string that contains the name of the new menu.
// Param: szMenuItem A pointer to a string that contains the name of the new first menu item.
// Param: resEditor A reference to a UIResEditor object that will contain the resource editor created.
// END_HELP_COMMENT
int COResScript::AddMenu(LPCSTR szMenuName, LPCSTR szMenuItem, UIResEditor& resEditor)
{
	const char* const THIS_FUNCTION = "COResScript::AddMenu";

	resEditor = UIWB.GetActiveEditor();
	if (!resEditor.IsValid()) 
	{
		LOG->RecordInfo("%s: resource editor '%s' is not valid (UIResEditor::IsValid failed).", THIS_FUNCTION, resEditor.GetTitle());
		return ERROR_ERROR;
	}

	MST.DoKeys("+{Tab}");	 // Get to the rigt-most menu placeholder
	MST.DoKeys(szMenuName);	 // Type in the Menu name
	MST.DoKeys("{Enter}");	 
	MST.DoKeys(szMenuItem);	 // Type in the Menu item name
	MST.DoKeys("{Enter}");	 
	MST.DoKeys("{Up}");	 

	UIControlProp prop;

	prop = UIWB.ShowPropPage(TRUE);
	if( !prop.IsValid() )
	{
		LOG->RecordInfo("%s: cannot validate property page (UIControlProp::IsValid failed).", THIS_FUNCTION);
	}
	if( !prop.SetID((CString)"ID_" + szMenuName + "_" + szMenuItem) )
	{
		LOG->RecordInfo("%s: could not set the menu item ID.", THIS_FUNCTION);
		return ERROR_ERROR;
	}

	// Dismiss the properties dialog.	
	MST.DoKeys("{Escape}");

	return ERROR_SUCCESS;
}

// BEGIN_HELP_COMMENT
// Function: int COResScript::ChangeDialogCaption( LPCSTR szDialogCaption, UIResEditor& resEditor)
// Description: Change the Dialog Caption; assume that the dialog resource is opened at the time
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szDialogCaption A pointer to a string that contains the dialog caption.
// Param: resEditor A reference to a UIResEditor object that will contain the resource editor created.
// END_HELP_COMMENT
int COResScript::ChangeDialogCaption( LPCSTR szDialogCaption, UIResEditor& resEditor)
{
	const char* const THIS_FUNCTION = "COResScript::ChangeDialogCaption";

	resEditor = UIWB.GetActiveEditor();
	if (!resEditor.IsValid()) 
	{
		LOG->RecordInfo("%s: resource editor '%s' is not valid (UIResEditor::IsValid failed).", THIS_FUNCTION, resEditor.GetTitle());
		return ERROR_ERROR;
	}

	MST.DoKeys(szDialogCaption);	 // Type in the Dialog caption
	MST.DoKeys("{Enter}");	 

	return ERROR_SUCCESS;
}

// BEGIN_HELP_COMMENT
// Function: int COResScript::ChangeDialogID( LPCSTR szDialogID, LPCSTR szOldDialogID)
// Description: Change the Dialog ID
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szNewDialogID A pointer to a string that contains the new dialog ID.
// Param: szOldDialogID A pointer to a string that contains the old dialog ID.
// END_HELP_COMMENT
int COResScript::ChangeDialogID( LPCSTR szNewDialogID, LPCSTR szOldDialogID)
{

	const char* const THIS_FUNCTION = "COResScript::ChangeDialogID";

//	CString strResType = GetLocString(IDSS_RT_DIALOG);
	UIWorkspaceWindow uiwksp;
	UIControlProp prop;

	if( !uiwksp.ActivateResourcePane() )
	{
		LOG->RecordInfo("%s: cannot activate resource pane (UIWorkspaceWindow::ActivateResourcePane failed).", THIS_FUNCTION);
	}

	if (uiwksp.SelectResource(GetLocString(IDSS_RT_DIALOG), szOldDialogID) == SUCCESS)
	{
		prop = UIWB.ShowPropPage(TRUE);
		if( !prop.IsValid() )
		{
			LOG->RecordInfo("%s: cannot validate property page (UIControlProp::IsValid failed).", THIS_FUNCTION);
		}
		if( !prop.SetID(szNewDialogID) )
		{
			LOG->RecordInfo("%s: could not set the new Dialog ID.", THIS_FUNCTION);
			return ERROR_ERROR;

		}

		// Dismiss the properties dialog.	
		MST.DoKeys("{Escape}");

	}
	else
	{
		LOG->RecordInfo("%s: cannot select resource %s (UIWorkspaceWindow::SelectResource failed).", THIS_FUNCTION, szOldDialogID);
	}

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\udlgedit.h ===
///////////////////////////////////////////////////////////////////////////////
//	UDLGEDIT.H
//
//	Created by :			Date :
//		EnriqueP				8/13/93
//
//	Edited by :				Date :			Reason :
//		ScottSe					8/20/96			Updated control defines
//
//	Description :
//		Declaration of the UIDlgEdit class
//

#ifndef __UIDLGEDIT_H__
#define __UIDLGEDIT_H__

#include "uresedit.h"

#include "export.h"

#ifndef __UIRESEDIT_H__
	#error include 'uresedit.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// UIDlgEdit class

// BEGIN_CLASS_HELP
// ClassName: UIDlgEdit
// BaseClass: UIResEditor
// Category: Editors
// END_CLASS_HELP
class RES_CLASS UIDlgEdit : public UIResEditor
{
public:
	UIWND_COPY_CTOR(UIDlgEdit, UIResEditor);
	virtual void OnUpdate(void);

// Data
protected:
	HWND m_hwndDialog;

// Attributes
public:
	virtual BOOL IsValid(void) const;

// Utilities
public:	
	BOOL  DropControl(int nControl, int cX, int cY );
	inline HWND GetDialog(void)
		{	return m_hwndDialog; }

};

//  Control Palette control identifiers


#define CT_ARROW       0
#define CT_PICTURE			1
#define CT_TEXT				2
#define CT_EDIT				3
#define CT_GROUP			4
#define CT_BUTTON			5
#define CT_CHECK			6
#define CT_RADIO			7
#define CT_DROPDOWN			8
#define CT_LIST				9
#define CT_HSCROLL			10
#define CT_VSCROLL			11
#define CT_SPIN				12
#define CT_PROGRESS			13
#define CT_SLIDER			14
#define CT_HOTKEY			15
#define CT_LISTCTL			16
#define CT_TREE				17
#define CT_TAB				18
#define CT_ANIMATE			19
#define CT_RICHEDIT			20
#define CT_DATETIMEPICKER	21
#define CT_MONTHCALENDAR	22
#define CT_IPADDRESS		23
#define CT_USER				24		// use this line for VC98
//#define CT_USER				21		// use this line for VC97

/*
'*  Strings found in SGetPropTitle
'*      DLG_CONTROL_TITLE ( CT_FOO ) == "Foo"

GLOBAL DLG_CONTROL_TITLE (12) AS STRING
DLG_CONTROL_TITLE (0)   = "Dialog Properties"           ' for the dialog frame
DLG_CONTROL_TITLE (1)   = "Picture"
DLG_CONTROL_TITLE (2)   = "Text"
DLG_CONTROL_TITLE (3)   = "Edit"
DLG_CONTROL_TITLE (4)   = "Group Box"
DLG_CONTROL_TITLE (5)   = "Push Button"
DLG_CONTROL_TITLE (6)   = "Check Box"
DLG_CONTROL_TITLE (7)   = "Radio Button"
DLG_CONTROL_TITLE (8)   = "Combo Box"
DLG_CONTROL_TITLE (9)   = "List Box"
DLG_CONTROL_TITLE (10)  = "Scrollbar"
DLG_CONTROL_TITLE (11)  = "Scrollbar"
DLG_CONTROL_TITLE (12)  = "User Control"  */

#endif //__UIDLGEDIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\udlgedit.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	UDLGEDIT.CPP
//
//	Created by :			Date :
//		EnriqueP				8/13/93
//
//	Description :
//		Implementation of the UIDlgEdit class
//

#include "stdafx.h"
#include "mstwrap.h"
#include "..\shl\wbutil.h"
#include "udlgedit.h"
#include "..\..\testutil.h"
#include "..\sym\dockids.h"
#include "..\shl\uwbframe.h"
#include "..\sym\reg.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: BOOL UIDlgEdit::IsValid(void) const
// Description: Determine whether the dialog editor is valid by determining if the window is valid, visible, the Resource Symbols menu item is enabled, and the title is correct.
// Return: A Boolean value that indicates whether the window is valid: TRUE if it's valid; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIDlgEdit::IsValid(void) const
{
	return UIResEditor::IsValid() && IsValidType(m_pszTypeText[ED_DIALOG]);
}

void UIDlgEdit::OnUpdate(void)
{
	UIResEditor::OnUpdate();

	if( !IsValid() )
		m_hwndDialog = NULL;
	else
	{
	    HWND hwndTop = GetDlgItem(HWnd(), 59648);    	// Get the Top Window
	    HWND hwndScroll1 = GetWindow(hwndTop, GW_CHILD ); // Get the 1st Scrollbar
	    HWND hwndCanvas =  GetWindow(hwndScroll1, GW_HWNDLAST );  // Get the Canvas (last in Zorder)
	    m_hwndDialog = GetWindow(hwndCanvas, GW_CHILD);  		// The Dialog frame is the child
	}
}

/*  DropControl
'*      Drops a specified control relative to the client are of the dialog
'*      for give editor window.		  */

// BEGIN_HELP_COMMENT
// Function: BOOL UIDlgEdit::DropControl(int nControl, int cX, int cY )
// Description: Drop the specified control in the dialog editor.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: nControl An integer containing the number of the control, which is a zero-based index into the control palette.
// Param: cX An integer containing the X (horizontal) position where the control should be dropped relative to the upper left corner of the dialog editor.
// Param: cY An integer containing the Y (vertical) position where the control should be dropped relative to the upper left corner of the dialog editor.
// END_HELP_COMMENT
BOOL UIDlgEdit::DropControl(int nControl, int cX, int cY )
{
	HWND hwndCtrl = UIWB.GetToolbar( IDDW_CONTROLS,PACKAGE_VRES );
    	
	OnUpdate();
    // Drop the control relative to the dialog client area.

    // Try finding the control pallet by using the caption.	
	if (hwndCtrl == NULL)
	{
		hwndCtrl = MST.WFndWnd(GetLocString(10013),FW_DEFAULT) ;
	}
	if (hwndCtrl == NULL)
	{
	  		return FALSE;
	}
	else				 //REVIEW: What if toolbar is hidden
    {   
		CRect	rcPalette;
    
    	GetClientRect(hwndCtrl, &rcPalette);
		
        //Size of buttons in toolbar = 24x22
		int nCols = ( rcPalette.right + 1 ) / 24;
    	DragMouse(VK_LBUTTON, 
    		hwndCtrl, 13+((nControl % nCols)*24), 13+((nControl/nCols)*21), 
    		m_hwndDialog, cX, cY);
    }
  	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\uimgedit.h ===
///////////////////////////////////////////////////////////////////////////////
//	UIMGEDIT.H
//
//	Created by :			Date :
//		EnriqueP				8/13/93
//
//	Description :
//		Declaration of the UIImgEdit class
//

#ifndef __UIMGEDIT_H__
#define __UIMGEDIT_H__

#include "uresedit.h"

#include "export.h"

#ifndef __UIRESEDIT_H__
	#error include 'uresedit.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// UIImgEdit class

// BEGIN_CLASS_HELP
// ClassName: UIImgEdit
// BaseClass: UIResEditor
// Category: Editors
// END_CLASS_HELP
class RES_CLASS UIImgEdit : public UIResEditor
{
	UIWND_COPY_CTOR(UIImgEdit, UIResEditor);

// Attributes
public:
	virtual BOOL IsValid(void) const;

// Utilities
public:
	void ClickInGraphTB(int nButton, int cX, int cY);
	void ClickImgTool(int nImgTool);
	void ClickColorMode( int nColor, int  nButton);
	void SetColor(int nColor, int nButton = VK_LBUTTON);
	HWND GetPane(int nPane);
	void ClickMouse(int nButton, int nPane, int cX, int cY, int nMag = 1);
	void DragMouse(int nButton, int nPane, int cX1, int cY1, int cX2, int cY2, int nMag = 1);
	HWND FontDialog(void);
	void SetFont(LPCSTR szFontName = NULL, int nSize = -1, int nStyle = -1);
	BOOL IsStandalone(void);
	virtual int GetEditorType(void);
};


// Accelerators specific to the image editor

#define ACC_ZOOM     		"m"
#define ACC_ZOOM_OUT        "+{<}"
#define ACC_ZOOM_IN         "+{>}"
#define ACC_BRUSH_BIGGER    "{+}"
#define ACC_BRUSH_SMALLER  	"{-}"
#define ACC_NEXT_FG_COLOR 	"{]}"
#define ACC_NEXT_BK_COLOR	"{}}"

//  Graphics Palette tool identifiers

#define GT_SELECT         0
#define GT_LASSO          1
#define GT_PICKER         2
#define GT_ERASER         3
#define GT_FILL           4
#define GT_ZOOM           5
#define GT_PENCIL         6
#define GT_BRUSH          7
#define GT_SPRAY          8
#define GT_LINE           9
#define GT_CURVE         10
#define GT_TEXT          11
#define GT_RECT          12
#define GT_COMBORECT     13
#define GT_FILLRECT      14
#define GT_ROUND         15
#define GT_COMBOROUND    16
#define GT_FILLROUND     17
#define GT_ELLIPSE       18
#define GT_COMBOELLIPSE   19
#define GT_FILLELLIPSE    20
#define GT_POLY           21
#define GT_COMBOPOLY      22
#define GT_FILLPOLY       23
#define GT_NUMTOOLS       24   //Total number of tools...used to init array


//  Graphics Palette Image Well identifiers

#define IW_ERASER_SIZE4          1
#define IW_ERASER_SIZE6          4
#define IW_ERASER_SIZE8          7
#define IW_ERASER_SIZE10        10
#define IW_SELECT_OPAQUE         4
#define IW_SELECT_TRANS          7
#define IW_SHAPE_ROUND_LG        0
#define IW_SHAPE_ROUND_MED       1
#define IW_SHAPE_ROUND_SM        2
#define IW_SHAPE_SQUARE_LG       3
#define IW_SHAPE_SQUARE_MED      4
#define IW_SHAPE_SQUARE_SM       5
#define IW_SHAPE_RLEAN_LG        6
#define IW_SHAPE_RLEAN_MED       7
#define IW_SHAPE_RLEAN_SM        8
#define IW_SHAPE_LLEAN_LG        9
#define IW_SHAPE_LLEAN_MED      10
#define IW_SHAPE_LLEAN_SM       11
#define IW_SPRAY_SM              0
#define IW_SPRAY_MED             2
#define IW_SPRAY_LG             10
#define IW_ZOOM_1x               1
#define IW_ZOOM_2x               4
#define IW_ZOOM_6x               7
#define IW_ZOOM_8x              10
#define IW_THICKNESS1            -1
#define IW_THICKNESS2            -4
#define IW_THICKNESS3            -7
#define IW_THICKNESS4           -10
#define IW_THICKNESS5           -13

enum { PANE_LEFT, PANE_RIGHT };

#endif //__UIMGEDIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\uaccedit.h ===
///////////////////////////////////////////////////////////////////////////////
//	UACCEDIT.H
//
//	Created by :			Date :
//		DavidGa					3/25/94
//
//	Description :
//		Declaration of the UIAccEdit class
//

#ifndef __UIACCEDIT_H__
#define __UIACCEDIT_H__

#include "urestabl.h"

#include "export.h"

#ifndef __UIRESTABL_H__
	#error include 'urestabl.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// UIAccEdit class

// BEGIN_CLASS_HELP
// ClassName: UIAccEdit
// BaseClass: UIResTableEditor
// Category: Editors
// END_CLASS_HELP
class RES_CLASS UIAccEdit : public UIResTableEditor
{
public:
	UIWND_COPY_CTOR(UIAccEdit, UIResTableEditor);

// Attributes
public:
	virtual BOOL IsValid(void) const;

// Utilities
public:	
	int AddAccel(LPCSTR szChar, LPCSTR  szId = NULL, DWORD dwKeyMods = 0x0, BOOL bNextKeyType = FALSE);
	void EditAccel(LPCSTR szChar = NULL, LPCSTR szId = NULL, DWORD dwKeyMods = 0x0);
	BOOL FindAccel(LPCSTR szChar = NULL, LPCSTR szId = 0);
	CString GetKey(int line = -1);
	DWORD GetKeyMods(int line = -1);
};

#define ACC_NO_CONTROL	0x2
#define ACC_CONTROL		0x3
#define ACC_NO_ALT		0x8
#define ACC_ALT			0xB
#define ACC_NO_SHIFT	0x20
#define ACC_SHIFT		0x30
#define ACC_ASCII		0x80
#define ACC_VIRTKEY		0xB0

#endif //__UIACCEDIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\umenedit.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	UMENEDIT.CPP
//
//	Created by :			Date :
//		EnriqueP				8/13/93
//
//	Description :
//		Implementation of the UIMenEdit class
//

#include "stdafx.h"
#include "umenedit.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: BOOL UIMenEdit::IsValid(void) const
// Description: Determine whether the menu editor is valid by determining if the window is valid, visible, the Resource Symbols menu item is enabled, and the title is correct.
// Return: A Boolean value that indicates whether the window is valid: TRUE if it's valid; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIMenEdit::IsValid(void) const
{
	return UIResEditor::IsValid() && IsValidType(m_pszTypeText[ED_MENU]);
}

// BEGIN_HELP_COMMENT
// Function: HWND UIMenEdit::GetMenuBar(void)
// Description: Get the HWND to the menu bar in the menu bar editor.
// Return: The HWND of the menu bar in the menu bar editor.
// END_HELP_COMMENT
HWND UIMenEdit::GetMenuBar(void)
{
	HWND hwndChild = GetWindow(HWnd(), GW_CHILD);
    HWND hwndCanvas = GetDlgItem(hwndChild, -1 );

	return GetDlgItem(hwndCanvas, 200 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\umenedit.h ===
///////////////////////////////////////////////////////////////////////////////
//	UMENEDIT.H
//
//	Created by :			Date :
//		EnriqueP				8/13/93
//
//	Description :
//		Declaration of the UIMenEdit class
//

#ifndef __UIMENEDIT_H__
#define __UIMENEDIT_H__

#include "uresedit.h"

#include "export.h"

#ifndef __UIRESEDIT_H__
	#error include 'uresedit.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// UIMenEdit class

// BEGIN_CLASS_HELP
// ClassName: UIMenEdit
// BaseClass: UIResEditor
// Category: Editors
// END_CLASS_HELP
class RES_CLASS UIMenEdit : public UIResEditor
{
	UIWND_COPY_CTOR(UIMenEdit, UIResEditor);

// Attributes
public:
	virtual BOOL IsValid(void) const;

// Utilities
public:
	HWND GetMenuBar(void);

};

// Menu Prop Page mnemonics

#define UIME_MN_SEPARATOR   "%s"
#define UIME_MN_CHECKED     "%k"
#define UIME_MN_POPUP       "%p"
#define UIME_MN_GRAYED      "%g"
#define UIME_MN_INACTIVE    "%n"
#define UIME_MN_HELP        "%l"
#define UIME_MN_BREAK       "%b"
#define UIME_MN_PROMPT      "%m"


// Strings found in SGetPropTitle

#define PT_MENUBAR    "Menu Properties"       //prop page title for the menu bar
#define PT_MENUITEM   "Menu Item Properties"  // for men

#endif //__UIMENEDIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\uaccedit.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	UACCEDIT.CPP
//
//	Created by :			Date :
//		DavidGa					3/25/94
//
//	Description :
//		Implementation of the UIAccEdit class
//

#include "stdafx.h"
#include "uaccedit.h"
#include "testxcpt.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\cmdids.h"
#include "..\sym\vres.h"
#include "..\sym\shrdres.h"
#include "..\sym\props.h"
#include "..\shl\upropwnd.h"
#include "..\shl\uwbframe.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: BOOL UIAccEdit::IsValid(void) const
// Description: Determine whether the accelerator editor is valid by determining if the window is valid, visible, the Resource Symbols menu item is enabled, and the title is correct.
// Return: A Boolean value that indicates whether the window is valid: TRUE if it's valid; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIAccEdit::IsValid(void) const
{
	return UIResTableEditor::IsValid() && IsValidType(m_pszTypeText[ED_ACCEL]);
}

// BEGIN_HELP_COMMENT
// Function: int UIAccEdit::AddAccel(LPCSTR szChar, LPCSTR  szId /*=NULL*/, DWORD dwKeyMods /*=0x0*/, BOOL bNextKeyType /*=FALSE*/)
// Description: Add an accelerator to the accelerator editor.
// Return: An integer value that contains the line number in the editor of the new accelerator.
// Param: szChar A pointer to a string that contains the accelerator key to add.
// Param: szId A pointer to a string that contains the name of the ID for this accelerator. NULL indicates use the default name. (The default is NULL.)
// Param: dwKeyMods A bit field that indicates the modifier keys to apply to this accelerator: ACC_CONTROL, ACC_NO_CONTROL, ACC_ALT, ACC_NO_ALT, ACC_SHIFT, ACC_NO_SHIFT, ACC_ASCII, ACC_VIRTKEY. (The default is 0.)
// Param: bNextKey A Boolean value that indicates whether to use the next key typed (TRUE) or not. This parameter is NYI. (The default is FALSE.)
// END_HELP_COMMENT
int UIAccEdit::AddAccel(LPCSTR szChar, LPCSTR  szId /*=NULL*/, DWORD dwKeyMods /*=0x0*/, BOOL bNextKeyType /*=FALSE*/)
{
	UIWB.DoCommand(IDM_NEW_ACCELERATOR, DC_ACCEL);
	
	UIControlProp upp;
	EXPECT( upp.WaitAttachActive(1000) );
	MST.WComboSetText(upp.GetLabel(VRES_IDC_KEY), szChar);
	if( szId != NULL )
		MST.WComboSetText(GetLabel(SHRDRES_IDC_ID), szId);
	if( dwKeyMods & ACC_CONTROL )
		MST.WCheckCheck(GetLabel(VRES_IDC_CTRL));
	else if( dwKeyMods & ACC_NO_CONTROL )
		MST.WCheckUnCheck(GetLabel(VRES_IDC_CTRL));
	if( dwKeyMods & ACC_ALT )
		MST.WCheckCheck(GetLabel(VRES_IDC_ALT));
	else if( dwKeyMods & ACC_NO_ALT )
		MST.WCheckUnCheck(GetLabel(VRES_IDC_ALT));
	if( dwKeyMods & ACC_SHIFT )
		MST.WCheckCheck(GetLabel(VRES_IDC_SHIFT));
	else if( dwKeyMods & ACC_NO_SHIFT )
		MST.WCheckUnCheck(GetLabel(VRES_IDC_SHIFT));
	if( dwKeyMods & ACC_ASCII )
		MST.WOptionClick(GetLabel(VRES_IDC_ASCII));
	else if( dwKeyMods & ACC_VIRTKEY )
		MST.WOptionClick(GetLabel(VRES_IDC_VIRTKEY));

	int n = GetCurLine();
	UIWB.ShowPropPage(FALSE);	// validate new string
	return n;
}

// BEGIN_HELP_COMMENT
// Function: void UIAccEdit::EditAccel(LPCSTR szChar /*=NULL*/, LPCSTR  szId /*=NULL*/, DWORD dwKeyMods /*=0x0*/)
// Description: Edit the currently selected accelerator in the accelerator editor.
// Return: none
// Param: szChar A pointer to a string that contains the new accelerator key for the selected accelerator.
// Param: szId A pointer to a string that contains the new name of the ID for this accelerator. NULL indicates use the current name. (The default is NULL.)
// Param: dwKeyMods A bit field that indicates the modifier keys to apply to this accelerator: ACC_CONTROL, ACC_NO_CONTROL, ACC_ALT, ACC_NO_ALT, ACC_SHIFT, ACC_NO_SHIFT, ACC_ASCII, ACC_VIRTKEY. (The default is 0.)
// END_HELP_COMMENT
void UIAccEdit::EditAccel(LPCSTR szChar /*=NULL*/, LPCSTR  szId /*=NULL*/, DWORD dwKeyMods /*=0x0*/)
{
	UIControlProp upp = UIWB.ShowPropPage(TRUE);
	if( szChar != NULL )
		MST.WComboSetText(upp.GetLabel(VRES_IDC_KEY), szChar);
	if( szId != NULL )
		MST.WComboSetText(GetLabel(SHRDRES_IDC_ID), szId);
	if( dwKeyMods & ACC_CONTROL )
		MST.WCheckCheck(GetLabel(VRES_IDC_CTRL));
	else if( dwKeyMods & ACC_NO_CONTROL )
		MST.WCheckUnCheck(GetLabel(VRES_IDC_CTRL));
	if( dwKeyMods & ACC_ALT )
		MST.WCheckCheck(GetLabel(VRES_IDC_ALT));
	else if( dwKeyMods & ACC_NO_ALT )
		MST.WCheckUnCheck(GetLabel(VRES_IDC_ALT));
	if( dwKeyMods & ACC_SHIFT )
		MST.WCheckCheck(GetLabel(VRES_IDC_SHIFT));
	else if( dwKeyMods & ACC_NO_SHIFT )
		MST.WCheckUnCheck(GetLabel(VRES_IDC_SHIFT));
	if( dwKeyMods & ACC_ASCII )
		MST.WOptionClick(GetLabel(VRES_IDC_ASCII));
	else if( dwKeyMods & ACC_VIRTKEY )
		MST.WOptionClick(GetLabel(VRES_IDC_VIRTKEY));
	UIWB.ShowPropPage(FALSE);
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIAccEdit::FindAccel(LPCSTR sz /*=NULL*/, LPCSTR szId /*=0*/)
// Description: Determine if the given accelerator is defined. This function is NYI.
// Return: A Boolean value that indicates success; TRUE if successful; FALSE otherwise.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
BOOL UIAccEdit::FindAccel(LPCSTR sz /*=NULL*/, LPCSTR szId /*=0*/)
{
	ASSERT(FALSE);	// NYI
	return FALSE;
}

// BEGIN_HELP_COMMENT
// Function: CString UIAccEdit::GetKey(int line /*=-1*/)
// Description: Get the accelerator key associated with the accelerator on the specified line (line).
// Return: A CString containing the key associated with the accelerator on the specified line.
// Param: line An integer containing the line to get the accelerator key for. -1 means use the current line. (The default is -1.)
// END_HELP_COMMENT
CString UIAccEdit::GetKey(int line /*=-1*/)
{
	if( line >= 0 )
		SelectLine(line);	// REVIEW: reset to previous selection?
	return UIWB.GetProperty(P_Key);
}

// BEGIN_HELP_COMMENT
// Function: DWORD UIAccEdit::GetKeyMods(int line /*=-1*/)
// Description: Get the accelerator key modifiers for the accelerator on the specified line (line).
// Return: A bit field that indicates the modifier keys to apply to this accelerator: ACC_CONTROL, ACC_NO_CONTROL, ACC_ALT, ACC_NO_ALT, ACC_SHIFT, ACC_NO_SHIFT, ACC_ASCII, ACC_VIRTKEY.
// Param: line An integer containing the line to get the accelerator modifier keys for. -1 means use the current line. (The default is -1.)
// END_HELP_COMMENT
DWORD UIAccEdit::GetKeyMods(int line /*=-1*/)
{
	if( line >= 0 )
		SelectLine(line);	// REVIEW: reset to previous selection?

	DWORD dw;
	CString str;
	str = UIWB.GetProperty(P_Ctrl);
	if( str == "1" )
		dw |= ACC_CONTROL;
	str = UIWB.GetProperty(P_Alt);
	if( str == "1" )
		dw |= ACC_ALT;
	str = UIWB.GetProperty(P_Shift);
	if( str == "1" )
		dw |= ACC_SHIFT;
	str = UIWB.GetProperty(P_Type);
	if( str == "1" )
		dw |= ACC_ASCII;

	return dw;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\uimgedit.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	UIMGEDIT.CPP
//
//	Created by :			Date :
//		EnriqueP				8/13/93
//
//	Description :
//		Implementation of the UIImgEdit class
//

#include "stdafx.h"
#include "uimgedit.h"
#include "testxcpt.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\dockids.h"
#include "..\sym\vres.h"
#include "..\sym\props.h"
#include "guiv1.h"
#include "..\shl\ucommdlg.h"
#include "..\shl\uwbframe.h"
#include "..\sym\reg.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: BOOL UIImgEdit::IsValid(void) const
// Description: Determine whether the image editor is valid by determining if the window is valid, visible, and the Image menu is enabled.
// Return: A Boolean value that indicates whether the window is valid: TRUE if it's valid; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIImgEdit::IsValid(void) const
{
	return UIEditor::IsValid();
}

/*  ClickInGraphTB
'*      Graphics selection utility called by higher level selection
'*      functions.  Not intended to  be called directly by tests.
*/
void UIImgEdit::ClickInGraphTB ( int nButton, int cX, int cY )
{
    HWND hwndGraphTB = UIWB.GetToolbar( IDDW_GRAPHICS,PACKAGE_VRES );
    EXPECT(hwndGraphTB != 0);

	::ClickMouse(nButton, hwndGraphTB, cX, cY);
}


/*  XClickImgTool
'*      Selects a graphics palette tool.  See
'*      the top of this file for tool index constants. */

// BEGIN_HELP_COMMENT
// Function: void UIImgEdit::ClickImgTool ( int nImgTool )
// Description: Select an image editing tool from the Graphics palette.
// Return: none
// Param: nImgTool A value that indicates the tool to select: GT_SELECT, GT_LASSO, GT_PICKER, GT_ERASER, GT_FILL, GT_ZOOM, GT_PENCIL, GT_BRUSH, GT_SPRAY, GT_LINE, GT_CURVE, GT_TEXT, GT_RECT, GT_COMBORECT, GT_FILLRECT, GT_ROUND, GT_COMBOROUND, GT_FILLROUND, GT_ELLIPSE, GT_COMBOELLIPSE, GT_FILLELLIPSE, GT_POLY, GT_COMBOPOLY, GT_FILLPOLY.
// END_HELP_COMMENT
void UIImgEdit::ClickImgTool ( int nImgTool )
{
	int nX = 14 + ( ( nImgTool % 3 ) * 24 );
    int nY = 24 + ( ( nImgTool / 3 ) * 24 );
    ClickInGraphTB(VK_LBUTTON, nX, nY);
}


/*  ClickColorMode    Clicks on Screen, Reverse or Black
 *      Color selection utility called by higher level selection
 *      functions.  Not intended to  be called directly by tests.
 *		REVIEW(Enrique): This function is dependent on the size of the toolbar and
 *						 will not work as expected on certain cases.
 */

void UIImgEdit::ClickColorMode( int nColor, int  nButton)
{

	// get the handle of the color toolbar (or we timeout)
	HWND hwndColorTB = NULL;
	for (int time = 0; time < 40 && hwndColorTB == NULL; time++) {
		Sleep(250);
		hwndColorTB = UIWB.GetToolbar(IDDW_COLORS,PACKAGE_VRES);
	}

	if (hwndColorTB == NULL) {
		LOG->RecordInfo("UIImgEdit::ClickColorMode: unable to get the handle of the color toolbar.");
		return;
	}

	CString cstrImgType = UIWB.GetProperty(P_ExternFile);	 // REVIEW(Enriquep) Implement GetImageType()

	cstrImgType.MakeUpper();
	
	int cX, cY;			   // Used to store the point where mouse will click 

	if ( (cstrImgType.Find(".BMP") != -1))   //  Is this a bitmap?
	{
		cX = 40;	  			// Click on first solid color position (black)
		cY = 17;
	}
	else
	{										 // Is an Icon or a Cursor
	    if (nColor == -1)
		{
	    	cX = 40;   			// nColor == -1  (Inverse)
	        cY = 34;
		}
		else
		{
			if (nColor == 0)  	// (Screen)
			{
		        cX = 40;
		        cY = 17;
			}
		    else  				// Reset to Black  if nColor > 0      
			{
			    cX = 67;
			    cY = 17;
			}
		}
	}
		  									
	::ClickMouse(nButton, hwndColorTB, cX, cY);
}

/* SetColor: Sets the foreground or background color to the specified color number. This function 
 *	uses the keyboard to navigate to the desired color. This function automatically adjusts color
 *  positions according to the type of palette that is currently active.
 *  nColor == -1   Inverse					 Cursors or Icons only
 *  nColor == 0    Screen or transparent		 Cursors or Icons only
 *  nColor >= 1    Position of a solid color starting with Black as 1.
 */

// BEGIN_HELP_COMMENT
// Function: void UIImgEdit::SetColor(int nColor, int nButton /* VK_LBUTTON */)
// Description: Set the foreground (left mouse button) or background (right mouse button) color in the image editor.
// Return: none
// Param: nColor An integer that represents the position of the color on the color palette. This value is 1-based value, starting with black as 1. For cursors and icons: -1 means use the inverse color; 0 means use the screen or transparent color.
// Param: nButton The mouse button to assign the color to: VK_LBUTTON, VK_RBUTTON. (Default value is VK_LBUTTON.)
// END_HELP_COMMENT
void  UIImgEdit::SetColor(int nColor, int nButton /* VK_LBUTTON */)   //REVIEW: Use CM_FOREGROUND or CM_BACKGROUND instead of button constants.
{
	ASSERT( (nButton == VK_LBUTTON) || (nButton == VK_RBUTTON) );
	ASSERT( nColor > -2 );	 // -1 = inverse, 0 = screen, 1 to n = solid colors

    ClickColorMode(nColor, nButton);
	CString strBKMode(ACC_NEXT_FG_COLOR);			// Default is foreground mode
    if (nColor > 0)   					// If color != inverse or screen
	{
        if (nButton == VK_RBUTTON)
            strBKMode = ACC_NEXT_BK_COLOR;   		// Set background color

        for (int i = 1; i <= nColor - 1; i++)		// Navigates thru colors
        	MST.DoKeys(strBKMode);
    }
}

// BEGIN_HELP_COMMENT
// Function: HWND UIImgEdit::GetPane(int nPane)
// Description: Get the HWND of one of the panes in the image editor.
// Return: The HWND of the requested pane. NULL if the requested pane does not exist.
// Param: nPane A value that indicates the pane to get the HWND for: PANE_LEFT, PANE_RIGHT.
// END_HELP_COMMENT
HWND UIImgEdit::GetPane(int nPane)
{
	HWND hLeft = HWnd();
	HWND hRight = NULL;

	hLeft = GetWindow(HWnd(), GW_CHILD);	// view	or toolbar
	hLeft = GetWindow(hLeft, GW_HWNDLAST);	// view
	hLeft = GetWindow(hLeft, GW_CHILD);		// first interesting window
	while( hLeft != NULL )
	{
		char acClass[32];
		GetClassName(hLeft, acClass, 31);
		if( strnicmp(acClass, "Afx:", 4 ) == 0 )
		{
			if( hRight == NULL )	// get the two windows of class "Afx:...."
				hRight = hLeft;
			else
				break;
		}
		hLeft = GetWindow(hLeft, GW_HWNDNEXT);
	}

	CRect rcLeft, rcRight;
	GetWindowRect(hLeft, &rcLeft);
	GetWindowRect(hRight, &rcRight);
	if( rcLeft.left > rcRight.left )
	{
		ASSERT( rcLeft.left > rcRight.right );	// just to make sure
		HWND hTemp = hLeft;		// if I have them backwards, swap them
		hLeft = hRight;
		hRight = hTemp;
	}

	switch( nPane )
	{
		case PANE_LEFT:
			return hLeft;
		case PANE_RIGHT:
			return hRight;
		default:
			ASSERT(FALSE);		// no such pane
	}
	return NULL;
}

// BEGIN_HELP_COMMENT
// Function: void UIImgEdit::ClickMouse(int nButton, int nPane, int cX, int cY, int nMag /*=1*/)
// Description: Click the mouse at the given coordinates in the given pane in the image editor. The coordinates are relative to the upper left corner of the pane.
// Return: none
// Param: nButton A value that indicates which button to click in the image editor: VK_LBUTTON, VK_MBUTTON, VK_RBUTTON.
// Param: nPane A value that indicates which pane of the image editor to click in: PANE_LEFT, PANE_RIGHT.
// Param: cX An integer that contains the X (horizontal) position to click. This position is relative to the upper left corner of the pane.
// Param: cY An integer that contains the Y (vertical) position to click. This position is relative to the upper left corner of the pane.
// Param: nMag An integer that contains the magnification in the image editor. This value is used to click a particular "bit" in the image editor by multiplying the X and Y coordinates by nMag. (Default value is 1.)
// END_HELP_COMMENT
void UIImgEdit::ClickMouse(int nButton, int nPane, int cX, int cY, int nMag /*=1*/)
{
	HWND hPane = GetPane(nPane);
	cX = 6 + cX * nMag;
	cY = 6 + cY * nMag;

	::ClickMouse(nButton, hPane, cX, cY);
}

// BEGIN_HELP_COMMENT
// Function: void UIImgEdit::DragMouse(int nButton, int nPane, int cX1, int cY1, int cX2, int cY2, int nMag /*=1*/)
// Description: Drag the mouse from the beginning coordinates to the ending coordinates in the given pane in the image editor. The coordinates are relative to the upper left corner of the pane.
// Return: none
// Param: nButton A value that indicates which button to click and hold while dragging in the image editor: VK_LBUTTON, VK_MBUTTON, VK_RBUTTON.
// Param: nPane A value that indicates which pane of the image editor to drag in: PANE_LEFT, PANE_RIGHT.
// Param: cX1 An integer that contains the X (horizontal) position to start the drag. This position is relative to the upper left corner of the pane.
// Param: cY1 An integer that contains the Y (vertical) position to start the drag. This position is relative to the upper left corner of the pane.
// Param: cX1 An integer that contains the X (horizontal) position to end the drag. This position is relative to the upper left corner of the pane.
// Param: cY1 An integer that contains the Y (vertical) position to end the drag. This position is relative to the upper left corner of the pane.
// Param: nMag An integer that contains the magnification in the image editor. This value is used to click and drag across particular "bits" in the image editor by multiplying the X and Y coordinates by nMag. (Default value is 1.)
// END_HELP_COMMENT
void UIImgEdit::DragMouse(int nButton, int nPane, int cX1, int cY1, int cX2, int cY2, int nMag /*=1*/)
{
	HWND hPane = GetPane(nPane);
	cX1 = 6 + cX1 * nMag;
	cY1 = 6 + cY1 * nMag;
	cX2 = 6 + cX2 * nMag;
	cY2 = 6 + cY2 * nMag;

	::DragMouse(nButton, hPane, cX1, cY1, hPane, cX2, cY2);
}

HWND UIImgEdit::FontDialog(void)
{
	HWND hwnd = UIWB.GetToolbar(IDDW_TEXTTOOL,PACKAGE_VRES);	// text tool hwnd
	if( !::IsWindowVisible(hwnd) )
	{
		ClickImgTool(GT_TEXT);	// only click if necessary, as this erases previous text
		EXPECT( ::IsWindowVisible(hwnd) );
	}
	hwnd = GetWindow(hwnd, GW_CHILD);			// child, which is parent of button and edit
	MST.WButtonClick(GetLabel(VRES_IDC_SETFONT, hwnd));

	UIFontDlg ufd;
	if( !ufd.WaitAttachActive(5000) )
		LOG->RecordInfo("Could not open Font dialog for text tool; '%s' is active", (LPCSTR)ufd.GetText());
	ufd.IsValid();
	return ufd;
}

// BEGIN_HELP_COMMENT
// Function: void UIImgEdit::SetFont(LPCSTR szFontName /*=NULL*/, int nSize /*=-1*/, int nStyle /*=-1*/)
// Description: Set the font to be used by the text tool in the image editor.
// Return: none
// Param: szFontName A pointer to a string that contains the name of the font. NULL means use the current font. (Default value is NULL.)
// Param: nSize An integer that contains the point size of the font. -1 means use the current point size. (Default value is -1.)
// Param: nStyle An index into the list of font styles. -1 means use the current style. This value is usually: 1 for regular style; 2 for italic style; 3 for bold style; and 4 for bold italic style.
// END_HELP_COMMENT
void UIImgEdit::SetFont(LPCSTR szFontName /*=NULL*/, int nSize /*=-1*/, int nStyle /*=-1*/)
{
	UIFontDlg ufd = FontDialog();
	
	if( szFontName != NULL )	// NULL means leave it as is
		ufd.SetName(szFontName);
	if( nSize >= 0 )				// <0 means leave it as is
		ufd.SetSize(nSize);
	if( nStyle >= 0 )			// <0 means leave it as is
		ufd.SetStyle(nStyle);	// style is just a base-1 index - you must know the font

	ufd.OK();
	ufd.WaitUntilGone(1000);
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIImgEdit::IsStandalone(void)
// Description: Determine if the image editor is stand alone or part of a resource script. (If a resource script window is open, this function assumes this image editor belongs to that script.)
// Return: A Boolean value that indicates whether the image editor is stand alone. TRUE if it's stand alone; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIImgEdit::IsStandalone(void)
{
	return IsValid() && !UIResEditor::IsValid();	// it's an image editor, but not a resource
}

// BEGIN_HELP_COMMENT
// Function: int UIImgEdit::GetEditorType(void)
// Description: Get the specific type of image editor. This function is NYI.
// Return: A value indicating the type of image editor: ED_CURSOR, ED_ICON, ED_BITMAP.
// END_HELP_COMMENT
int UIImgEdit::GetEditorType(void)
{
	if( !IsValid() )
		return -2;		// ED_UNKNOWN

// REVIEW(briancr): this function would not work the way it's implemented, even on Dolphin
// controls with the given IDs do not exist
	ASSERT(0);
	return -2;

#if 0

	HWND hwndSplitterView = ::GetWindow(HWnd(), GW_CHILD);	// the view is the only child of the frame
	HWND hwnd = GetDlgItem(hwndSplitterView, VRES_IDC_HOTSPOT);
	if( hwnd && (GetDlgControlClass(hwnd) == GL_STATIC) )	// does it have a HotSpot indicator?
		return ED_CURSOR;
	hwnd = GetDlgItem(hwndSplitterView, VRES_IDC_IMAGELIST);
	if( hwnd && (GetDlgControlClass(hwnd) == GL_STATIC) )	// does it have a device indicator?
		return ED_ICON;
	return ED_BITMAP;	// what else could it be?
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\uresbrws.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	URESBRWS.CPP
//
//	Created by :			Date :
//		EnriqueP				8/13/93
//
//	Description :
//		Implementation of the UIResBrowser class
//

#include "stdafx.h"
#include "uresbrws.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "guiv1.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: BOOL UIResBrowser::IsValid(void) const
// Description: Determine whether the resource browser is valid by determining if the window is valid, visible, the window contains a list box, and it's not a string table editor or accelerator editor.
// Return: A Boolean value that indicates whether the window is valid: TRUE if it's valid; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIResBrowser::IsValid(void) const
{
	if( !UIEditor::IsValid() )	// bypass UIResEditor and UIResTable
		return FALSE;

	return (GetTitle().Find('(') < 0) &&	// has listbox, and isn't (Stringtable) or (Accelerator)
			(GetDlgControlClass(m_hwndListbox) == GL_LISTBOX);
}

// BEGIN_HELP_COMMENT
// Function: int UIResBrowser::SelectFolder(int nFolder)
// Description: Select a folder in the resource browser by folder type (see also SelectFolder(LPCSTR)).
// Return: An integer that contains the line of the selected folder in the resource browser.
// Param: nFolder A value that contains the folder to select in the resource browser: ED_DIALOG, ED_MENU, ED_CURSOR, ED_ICON, ED_BITMAP, ED_STRING, ED_ACCEL, ED_VERSION, ED_BINARY.
// END_HELP_COMMENT
int UIResBrowser::SelectFolder(int nFolder)
{
	ASSERT( (nFolder >= ED_DIALOG) && (nFolder <= ED_VERSION) );
	LPCSTR sz = m_pszTypeText[nFolder] + 1;
	CString str(sz, strlen(sz) - 1);	// string minus parens
	return SelectFolder(str);
}

// BEGIN_HELP_COMMENT
// Function: int UIResBrowser::SelectFolder(LPCSTR szFolder)
// Description: Select a folder in the resource browser by name (see also SelectFolder(int)).
// Return: An integer that contains the line of the selected folder in the resource browser.
// Param: szFolder A pointer to a string that contains the name of the folder to select.
// END_HELP_COMMENT
int UIResBrowser::SelectFolder(LPCSTR szFolder)
{
	if( !IsActive() && !Activate() )
	{
		LOG->RecordInfo("Could not activate resource browser");
		return -1;
	}

	// TODO:
	// shortcut: Close/Open folder at top level to list only sub-folders
	// Select each line in the list
	// If it is a folder (id == ?)
	// and it is the right folder (caption == ?)
	// then stop

	if( !MST.WListItemExists(NULL, szFolder) )	// list doesn't have strings
		return -1;
	MST.WListItemClk(NULL, szFolder);
	return GetCurLine();
}

// BEGIN_HELP_COMMENT
// Function: int UIResBrowser::OpenFolder(int nOpen)
// Description: Open or close the selected folder in the resource editor.
// Return: An integer containing the number of items in the folder. Positive if the folder is opened; negative if the folder is closed.
// Param: nOpen A value that indicates the action to perform on the folder: CLOSE_FOLDER, OPEN_FOLDER, OPEN_FOLDER_ALL.
// END_HELP_COMMENT
int UIResBrowser::OpenFolder(int nOpen)
{
	if( !IsActive() && !Activate() )
	{
		LOG->RecordInfo("Could not activate resource browser");
		return 0;
	}
	int n = GetLineCount();
	if( nOpen == CLOSE_FOLDER )	// or FALSE
		MST.DoKeys("-", TRUE);
	else if( nOpen == OPEN_FOLDER_ALL )
		MST.DoKeys("*", TRUE);
	else						// OPEN_FOLDER or TRUE
		MST.DoKeys("+", TRUE);
	return GetLineCount() - n;	// return number of items in folder
}

// BEGIN_HELP_COMMENT
// Function: int UIResBrowser::FindResource(LPCSTR szId, int nFolder)
// Description: Select an item within a folder (by folder type) in the resource browser (see also FindResource (LPCSTR, LPCSTR)).
// Return: An integer that contains the line of the selected item in the resource browser.
// Param: szId A pointer to a string that contains the name of the item to select within the given folder.
// Param: nFolder A value that contains the folder to select in the resource browser: ED_DIALOG, ED_MENU, ED_CURSOR, ED_ICON, ED_BITMAP, ED_STRING, ED_ACCEL, ED_VERSION, ED_BINARY.
// END_HELP_COMMENT
int UIResBrowser::FindResource(LPCSTR szId, int nFolder)
{
	ASSERT( (nFolder >= ED_DIALOG) && (nFolder <= ED_VERSION) );
	LPCSTR sz = m_pszTypeText[nFolder] + 1;
	CString str(sz, strlen(sz) - 1);	// string minus parens
	return FindResource(szId, str);
}

// BEGIN_HELP_COMMENT
// Function: int UIResBrowser::FindResource(LPCSTR szId, LPCSTR szFolder /*=NULL*/)
// Description: Select an item within a folder (by folder name) in the resource browser (see also FindResource (LPCSTR, int)).
// Return: An integer that contains the line of the selected item in the resource browser.
// Param: szId A pointer to a string that contains the name of the item to select within the given folder.
// Param: szFolder A pointer to a string that contains the name of the folder to select.
// END_HELP_COMMENT
int UIResBrowser::FindResource(LPCSTR szId, LPCSTR szFolder /*=NULL*/)
{
	if( !IsActive() && !Activate() )
	{
		LOG->RecordInfo("Could not activate resource browser");
		return -1;
	}

	if( szFolder != NULL )
	{
		SelectFolder(szFolder);
		OpenFolder(TRUE);
	}
	if( !MST.WListItemExists(NULL, szId) )
		return -1;
	MST.WListItemClk(NULL, szId);
	return GetCurLine();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\uresbrws.h ===
///////////////////////////////////////////////////////////////////////////////
//	URESBRWS.H
//
//	Created by :			Date :
//		DavidGa					3/25/94
//
//	Description :
//		Declaration of the UIResBrowser class
//

#ifndef __UIRESBRWS_H__
#define __UIRESBRWS_H__

#include "urestabl.h"

#include "export.h"

#ifndef __UIRESTABL_H__
	#error include 'urestabl.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// UIResBrowser class

// BEGIN_CLASS_HELP
// ClassName: UIResBrowser
// BaseClass: UIResTableEditor
// Category: Editors
// END_CLASS_HELP
class RES_CLASS UIResBrowser : public UIResTableEditor
{
public:
	UIWND_COPY_CTOR(UIResBrowser, UIResTableEditor);

// Attributes
public:
	virtual BOOL IsValid(void) const;

// Utilities
public:	
	int SelectFolder(int nFolder);	// ED_*
	int SelectFolder(LPCSTR szFolder);
	int OpenFolder(int nOpen);
	int FindResource(LPCSTR szId, int nFolder);
	int FindResource(LPCSTR szId, LPCSTR szFolder = NULL);
};

enum { CLOSE_FOLDER, OPEN_FOLDER, OPEN_FOLDER_ALL };

#endif //__UIRESBRWS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\uresedit.h ===
///////////////////////////////////////////////////////////////////////////////
//	URESEDIT.H
//
//	Created by :			Date :
//		DavidGa					9/23/93
//
//	Description :
//		Declaration of the UIEditor class
//

#ifndef __UIRESEDIT_H__
#define __UIRESEDIT_H__

#include "..\eds\ueditor.h"

#include "export.h"

#ifndef __UIEDITOR_H__
	#error include 'ueditor.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//	UIResEditor class

// BEGIN_CLASS_HELP
// ClassName: UIResEditor
// BaseClass: UIEditor
// Category: Editors
// END_CLASS_HELP
class RES_CLASS UIResEditor : public UIEditor
{
	UIWND_COPY_CTOR(UIResEditor, UIEditor);

// Data
protected:
	static LPCSTR* m_pszTypeText;

// Attributes
public:
	virtual BOOL IsValid(void) const;
	virtual BOOL IsValidType(LPCSTR szType) const;

// Utilities
public:
	BOOL ExportResource(LPCSTR szFileName);
};

enum
{
	ED_BROWSER = -1, 
	ED_DIALOG = 0, 
	ED_MENU, 
	ED_CURSOR, 
	ED_ICON, 
	ED_BITMAP, 
	ED_STRING, 
	ED_ACCEL, 
	ED_VERSION, 
	ED_BINARY
};

#endif //__UIRESEDIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\ustredit.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	USTREDIT.CPP
//
//	Created by :			Date :
//		EnriqueP				8/13/93
//
//	Description :
//		Implementation of the UIStrEdit class
//

#include "stdafx.h"
#include "ustredit.h"
#include "testxcpt.h"
#include "mstwrap.h"
#include "..\sym\cmdids.h"
#include "..\sym\shrdres.h"
#include "..\sym\props.h"
#include "..\shl\upropwnd.h"
#include "..\shl\uwbframe.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: BOOL UIStrEdit::IsValid(void) const
// Description: Determine whether the string editor is valid by determining if the window is valid, visible, the Resource Symbols menu item is enabled, and the title is correct.
// Return: A Boolean value that indicates whether the window is valid: TRUE if it's valid; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIStrEdit::IsValid(void) const
{
	return UIResTableEditor::IsValid() && IsValidType(m_pszTypeText[ED_STRING]);
}

// BEGIN_HELP_COMMENT
// Function: int UIStrEdit::AddString(LPCSTR szCaption, LPCSTR szId /*=NULL*/, BOOL bIdFirst /*=FALSE*/)
// Description: Add a string to the string editor.
// Return: An integer that contains the 1-based line number where the string was added.
// Param: szCaption A pointer to a string that contains the text of the string to add.
// Param: szId A pointer to a string that contains the name of the ID to assign to this string. NULL means use the default ID name. (Default value is NULL.)
// Param: bIdFirst A Boolean value that indicates whether to set the ID first (TRUE) or the text of the string first (FALSE). (Default value is FALSE.)
// END_HELP_COMMENT
int UIStrEdit::AddString(LPCSTR szCaption, LPCSTR szId /*=NULL*/, BOOL bIdFirst /*=FALSE*/)
{
	UIWB.DoCommand(IDM_NEW_STRING, DC_ACCEL);
	UIControlProp upp;
	EXPECT( upp.WaitAttachActive(1000) );
	if( bIdFirst )
	{
		if( szId != NULL )
			MST.WComboSetText(upp.GetLabel(SHRDRES_IDC_ID), szId);	// ID first
		MST.WEditSetText(upp.GetLabel(SHRDRES_IDC_CAPTION), szCaption);
	}
	else
	{
		MST.WEditSetText(upp.GetLabel(SHRDRES_IDC_CAPTION), szCaption);	// caption first
		if( szId != NULL )
			MST.WComboSetText(upp.GetLabel(SHRDRES_IDC_ID), szId);
	}
	int n = GetCurLine();
	UIWB.ShowPropPage(FALSE);	// validate new string
	return n;
}

// BEGIN_HELP_COMMENT
// Function: void UIStrEdit::EditString(LPCSTR szCaption /*=NULL*/, LPCSTR szId /*=NULL*/)
// Description: Edit the selected string in the string editor.
// Return: none
// Param: szCaption A pointer to a string that contains the new text for the selected string. NULL means use the existing text. (Default value is NULL.)
// Param: szId A pointer to a string that contains the name of the new ID for the selected string. NULL means use the existing ID name. (Default value is NULL.)
// END_HELP_COMMENT
void UIStrEdit::EditString(LPCSTR szCaption /*=NULL*/, LPCSTR szId /*=NULL*/)
{
	UIControlProp upp = UIWB.ShowPropPage(TRUE);
	if( szCaption != NULL )
		MST.WEditSetText(upp.GetLabel(SHRDRES_IDC_CAPTION), szCaption);
	if( szId != NULL )
		MST.WComboSetText(upp.GetLabel(SHRDRES_IDC_ID), szId);
	UIWB.ShowPropPage(FALSE);
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIStrEdit::FindString(LPCSTR szCaption /*=NULL*/, LPCSTR szId /*=0*/)
// Description: Select a string in the string editor. This function is NYI.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: szCaption A pointer to a string that contains the text of the string to select.
// Param: szId A pointer to a string that contains the name of the ID of the string to select.
// END_HELP_COMMENT
BOOL UIStrEdit::FindString(LPCSTR szCaption /*=NULL*/, LPCSTR szId /*=0*/)
{
	ASSERT(FALSE);	// NYI
	return FALSE;
}

// BEGIN_HELP_COMMENT
// Function: CString UIStrEdit::GetString(int line /*=-1*/)
// Description: Get the text of the string at the given line in the string editor.
// Return: A CString containing the text of the string.
// Param: line An integer that contains the 1-based line to retrieve the text for.
// END_HELP_COMMENT
CString UIStrEdit::GetString(int line /*=-1*/)
{
	if( line >= 0 )
		SelectLine(line);	// REVIEW: reset to previous selection?
	return UIWB.GetProperty(P_String);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\uresedit.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	URESEDIT.CPP
//
//	Created by :			Date :
//		DavidGa					9/25/93
//
//	Description :
//		Implementation of the UIResEditor class
//

#include "stdafx.h"
#include "uresedit.h"
#include "..\sym\cmdids.h"
#include "..\shl\uwbframe.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: BOOL UIResEditor::IsValid(void) const
// Description: Determine whether the resource editor is valid by determining if the window is valid, visible, and the Resource Symbols menu item is enabled.
// Return: A Boolean value that indicates whether the window is valid: TRUE if it's valid; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIResEditor::IsValid(void) const
{
	if( !UIEditor::IsValid() )
		return FALSE;

	return UIWB.IsCommandEnabled(IDM_EDIT_SYMBOLS);
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIResEditor::IsValidType(LPCSTR szType) const
// Description: Determine whether the resource editor is the type specified.
// Return: A Boolean value that indicates whether the resource editor is the type specified. TRUE if it is; FALSE otherwise.
// Param: szType A pointer to a string that contains the type of resource editor expected.
// END_HELP_COMMENT
BOOL UIResEditor::IsValidType(LPCSTR szType) const
{
	CString strTitle = GetText();
	if( szType != NULL )
		return strTitle.Find(szType) >= 0;
	else
	{
		for( int n = 0; m_pszTypeText[n] != NULL; n++ )
		{
			if( strTitle.Find(m_pszTypeText[n]) >= 0 )
				return TRUE;
		}
		return FALSE;
	}
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIResEditor::ExportResource(LPCSTR szFileName)
// Description: Export a resource.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: szFileName A pointer to a string that contains the filename to export the resource to. This parameter usually contains a full path to the file.
// END_HELP_COMMENT
BOOL UIResEditor::ExportResource(LPCSTR szFileName)
{
	// TODO: Make sure this editor has focus FIRST
	UIWB.ExportResource(szFileName);
	return TRUE;
}

LPCSTR aszTypes[] =
{
	"(Dialog)",		// must be in same order as above enum in header file!
	"(Menu)",
	"(Cursor)",
	"(Icon)",
	"(Bitmap)",
	"(String Table)",
	"(Accelerator)",
	"(Version)",
	"(\"",			// binary files are anything with a quoted name in parens
	NULL	// must be last item in array
};

LPCSTR* UIResEditor::m_pszTypeText = aszTypes;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\urestabl.h ===
///////////////////////////////////////////////////////////////////////////////
//	URESTABL.H
//
//	Created by :			Date :
//		DavidGa					3/25/94
//
//	Description :
//		Declaration of the UIResTableEditor class
//

#ifndef __UIRESTABL_H__
#define __UIRESTABL_H__

#include "uresedit.h"

#include "export.h"

#ifndef __UIRESEDIT_H__
	#error include 'uresedit.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// UIResTableEditor class

// BEGIN_CLASS_HELP
// ClassName: UIResTableEditor
// BaseClass: UIResEditor
// Category: Editors
// END_CLASS_HELP
class RES_CLASS UIResTableEditor : public UIResEditor
{
public:
	UIWND_COPY_CTOR(UIResTableEditor, UIResEditor);
	virtual void OnUpdate(void);

// Data
protected:
	HWND m_hwndListbox;

// Attributes
public:
	virtual BOOL IsValid(void) const;
	inline HWND GetListbox(void)
		{	return m_hwndListbox; }

// Utilities
public:	
	BOOL SelectLine(int line, BOOL bMulti = FALSE);
	CString GetCaption(int line = -1);
	CString GetId(int line = -1);
	int GetCurLine(void);
	int GetLineCount(void);
};

#endif //__UIRESTABL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\urestabl.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	URESTABL.CPP
//
//	Created by :			Date :
//		EnriqueP				8/13/93
//
//	Description :
//		Implementation of the UIResTableEditor class
//

#include "stdafx.h"
#include "urestabl.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\props.h"
#define __UNDO_H__			// Prevents #inclusion of some SUSHI headers
#define __SLOBWND_H__
#include "..\sym\slob.h"
#include "guiv1.h"
#include "..\shl\uwbframe.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: BOOL UIResTableEditor::IsValid(void) const
// Description: Determine whether the resource table editor is valid by determining if the window is valid, visible, the Resource Symbols menu item is enabled, and the only child window is a list box.
// Return: A Boolean value that indicates whether the window is valid: TRUE if it's valid; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIResTableEditor::IsValid(void) const
{
	if( !UIResEditor::IsValid() )
		return FALSE;

    HWND hwndView = GetWindow(HWnd(), GW_CHILD);   	// view, with listbox and column captions
	if( hwndView == NULL )
		return FALSE;
    HWND hwndList = GetWindow(hwndView, GW_CHILD);	// the listbox is the only child of the view
	if( hwndList == NULL )
			return FALSE;
	return GetDlgControlClass(hwndList) == GL_LISTBOX;
}

void UIResTableEditor::OnUpdate(void)
{
	UIResEditor::OnUpdate();

	if( !IsValid() )
		m_hwndListbox = NULL;
	else
	{
	    HWND hwndView = GetWindow(HWnd(), GW_CHILD);   	// view, with listbox and column captions
	    m_hwndListbox = GetWindow(hwndView, GW_CHILD);	// the listbox is the only child of the view
	}
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIResTableEditor::SelectLine(int line, BOOL bMulti /*=FALSE*/)
// Description: Select a line in the resource table editor.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: line An integer that contains the 1-based line to select.
// Param: bMulti A Boolean value that indicates whether to select muliple lines (hold down the control key while selecting the line) (TRUE) or not. (Default value is FALSE.)
// END_HELP_COMMENT
BOOL UIResTableEditor::SelectLine(int line, BOOL bMulti /*=FALSE*/)
{
	if( !IsActive() && !Activate() )
	{
		LOG->RecordInfo("Could not activate string table");
		return FALSE;
	}
	else
	{
		if( !bMulti )
			MST.WListItemClk(NULL, line+1);	// no caption - only one listbox, and it has the focus
		else
			MST.WListItemCtrlClk(NULL, line+1);	// ctrl-click to mutli-select
		return GetCurLine() == line;
	}
}

// BEGIN_HELP_COMMENT
// Function: CString UIResTableEditor::GetCaption(int line /*=-1*/)
// Description: Get the caption of the resource table editor.
// Return: A CString that contains the caption of the resource table editor.
// Param: line An integer that contains the line to select in the resource editor. Why is this parameter here? -1 means don't select any line. (Default value is -1.)
// END_HELP_COMMENT
CString UIResTableEditor::GetCaption(int line /*=-1*/)
{
	if( line >= 0 )
		SelectLine(line);	// REVIEW: reset to previous selection?
	return UIWB.GetProperty(P_Caption);
}

// BEGIN_HELP_COMMENT
// Function: CString UIResTableEditor::GetId(int line /*=-1*/)
// Description: Get the ID of the resource table editor.
// Return: A CString containing the ID of the resource table editor.
// Param: line An integer that contains the line to select in the resource editor. Why is this parameter here? -1 means don't select any line. (Default value is -1.)
// END_HELP_COMMENT
CString UIResTableEditor::GetId(int line /*=-1*/)
{
	if( line >= 0 )
		SelectLine(line);
	return UIWB.GetProperty(P_ID);
}

// BEGIN_HELP_COMMENT
// Function: int UIResTableEditor::GetCurLine(void)
// Description: Get the current line in the resource table editor.
// Return: An integer that contains the line currently selected in the table editor.
// END_HELP_COMMENT
int UIResTableEditor::GetCurLine(void)
{
//	return MST.WListIndex(NULL);
	return ::SendMessage(m_hwndListbox, LB_GETCURSEL, 0, 0);
}

// BEGIN_HELP_COMMENT
// Function: int UIResTableEditor::GetLineCount(void)
// Description: Get the number of lines in the resource table editor.
// Return: An integer containing the number of lines in the table editor.
// END_HELP_COMMENT
int UIResTableEditor::GetLineCount(void)
{
//	return MST.WListCount(NULL);
	return ::SendMessage(m_hwndListbox, LB_GETCOUNT, 0, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\ustredit.h ===
///////////////////////////////////////////////////////////////////////////////
//	USTREDIT.H
//
//	Created by :			Date :
//		DavidGa					3/25/94
//
//	Description :
//		Declaration of the UIStrEdit class
//

#ifndef __UISTREDIT_H__
#define __UISTREDIT_H__

#include "urestabl.h"

#include "export.h"

#ifndef __UIRESTABL_H__
	#error include 'urestabl.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// UIStrEdit class

// BEGIN_CLASS_HELP
// ClassName: UIStrEdit
// BaseClass: UIResTableEditor
// Category: Editors
// END_CLASS_HELP
class RES_CLASS UIStrEdit : public UIResTableEditor
{
public:
	UIWND_COPY_CTOR(UIStrEdit, UIResTableEditor);

// Attributes
public:
	virtual BOOL IsValid(void) const;

// Utilities
public:	
	BOOL AddString(LPCSTR szCaption, LPCSTR id = NULL, BOOL bIdFirst = FALSE);
	void EditString(LPCSTR szCaption = NULL, LPCSTR szId = NULL);
	BOOL FindString(LPCSTR szCaption = NULL, LPCSTR szId = 0);
	CString GetString(int line = -1);
};

#endif //__UISTREDIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\usymdlg.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	USYMDLG.CPP
//
//	Created by :			Date :
//		DavidGa					9/20/93
//
//	Description :
//		Implementation of the UISymbolBrowser class
//

#include "stdafx.h"
#include "usymdlg.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\vres.h"

// this dialog is in sushi\vres's RC file (VRES.RC)

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: int UISymbolBrowser::CountSymbols(BOOL bReadOnly)
// Description: Get the number of symbols displayed in the symbol browser dialog.
// Return: An integer that contains the number symbols displayed in the symbol browser dialog.
// Param: bReadOnly A Boolean value that indicates whether to include read only symbols (TRUE) in the count or not.
// END_HELP_COMMENT
int UISymbolBrowser::CountSymbols(BOOL bReadOnly)
{
	if( bReadOnly )
		MST.WCheckCheck(GetLabel(VRES_ID_SYM_SHOWREADONLY));
	else
		MST.WCheckUnCheck(GetLabel(VRES_ID_SYM_SHOWREADONLY));

	return MST.WListCount(GetLabel(VRES_IDC_SYM_LIST));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\usymdlg.h ===
///////////////////////////////////////////////////////////////////////////////
//	USYMDLG.H
//
//	Created by :			Date :
//		DavidGa					9/20/93
//
//	Description :
//		Declaration of the UISymbolBrowser class
//

#ifndef __UISYMDLG_H__
#define __UISYMDLG_H__

#include "..\..\udialog.h"
#include "..\shl\wbutil.h"

#include "export.h"

#ifndef __UIDIALOG_H__
	#error include 'udialog.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//	UISymbolBrowser class

// BEGIN_CLASS_HELP
// ClassName: UISymbolBrowser
// BaseClass: UIDialog
// Category: Editors
// END_CLASS_HELP
class RES_CLASS UISymbolBrowser : public UIDialog
{
	UIWND_COPY_CTOR(UISymbolBrowser, UIDialog);

// Utilities
public:
	virtual CString ExpectedTitle(void) const
		{	return GetLocString(IDSS_SB_TITLE); }
	int CountSymbols(BOOL bReadOnly);
};

#endif //__UISYMDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\cmdarray.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  CMDARRAY.CPP
//
//  Created by :            Date :
//      DavidGa                 9/16/93
//
//  Description :
//      CMD_STRUCT array for DoCommand function in the Workbench
//
// changes for new manubar 1/30/95 GeorgeCh - File/Edit/View/Insert/Tools/Window

#include "stdafx.h"
#include "uwbframe.h"
#include "..\sym\cmdids.h"
#include "Strings.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

CMD_STRUCT UIWBFrame::m_aCmdTable[] =
{
//	idCommand,				{ idMenu1,			idMenu2,			idMenu3 },			szMnemonic,	szAccel,

	// file commands

	ID_FILE_NEW,			{ IDS_FILEMENU,		IDS_NEW,			0 },				"%fn",		"^n",
    ID_FILE_OPEN,			{ IDS_FILEMENU,		IDS_OPEN,			0 },				"%fo",		"^o",
    ID_FILE_CLOSE,			{ IDS_FILEMENU,		IDS_CLOSE,			0 },				"%fc",      NULL,
    ID_FILE_SAVE,			{ IDS_FILEMENU,		IDS_SAVE,			0 },				"%fs",		"^s",
    ID_FILE_SAVE_AS,		{ IDS_FILEMENU,		IDS_SAVEAS,			0 },				"%fa",		"{f12}",
    IDM_OPEN_WORKSPACE,		{ IDS_FILEMENU,		IDS_OPENWRK,		0 },				"%fw",		NULL,
	IDM_SAVE_WORKSPACE,		{ IDS_FILEMENU,		IDS_SAVEWRK,		0 },				"%fv",		NULL,
    IDM_CLOSE_WORKSPACE,	{ IDS_FILEMENU,		IDS_CLOSEWRK,		0 },				"%fk",		NULL,
    IDM_FILE_SAVE_ALL,		{ IDS_FILEMENU,		IDS_SAVEALL,		0 },				"%fl",		NULL,
    IDM_EDIT_GREP,			{ IDS_FILEMENU,		IDS_FINDINFILES,	0 },				"%ff",		NULL,
    ID_FILE_PAGE_SETUP,		{ IDS_FILEMENU,		IDS_PAGESETUP,		0 },				"%fu",		NULL,
    ID_FILE_PRINT,			{ IDS_FILEMENU,		IDS_PRINT,			0 },				"%fp",		"^p",
    ID_APP_EXIT,			{ IDS_FILEMENU,		IDS_EXIT,			0 },				"%fx",		"%{f4}",

	// edit commands

    ID_EDIT_UNDO,			{ IDS_EDITMENU,		IDS_UNDO,			0 },				"%eu",		"^z",
    ID_EDIT_REDO,			{ IDS_EDITMENU,		IDS_REDO,			0 },				"%er",		"^a",
    ID_EDIT_CUT,			{ IDS_EDITMENU,		IDS_CUT,			0 },				"%et",		"^(x)",
    ID_EDIT_COPY,			{ IDS_EDITMENU,		IDS_COPY,			0 },				"%ec",		"^c",
    ID_EDIT_PASTE,			{ IDS_EDITMENU,		IDS_PASTE,			0 },				"%ep",		"^v",
    ID_EDIT_CLEAR,			{ IDS_EDITMENU,		IDS_CLEAR,			0 },				"%ed",		"{DEL}",
    ID_EDIT_SELECT_ALL,		{ IDS_EDITMENU,		IDS_SELECTALL,		0 },				"%el",		NULL,
    ID_EDIT_FIND_DLG,		{ IDS_EDITMENU,		IDS_FIND,			0 },				"%ef",		"%{f3}",
    ID_EDIT_REPLACE,		{ IDS_EDITMENU,		IDS_REPLACE,		0 },				"%ee",		NULL,
    IDM_GOTO_LINE,			{ IDS_EDITMENU,		IDS_GOTO,			0 },				"%eg",		"^(g)",
	IDM_RUN_SETBREAK,		{ IDS_EDITMENU,		IDS_BREAKPOINTS,	0 },				"%ek",		"^(b)",
    IDM_BOOKMARKS,			{ IDS_EDITMENU,		IDS_BOOKMARK,		0 },				"%eb",		NULL,

    IDM_WINDOW_SHOWPROPERTIES,{ IDS_EDITMENU,	IDS_PROPERTIES,		0 },				"%eo",		"%({ENTER})",

	// view commands

    IDM_EDIT_SYMBOLS,		{ IDS_VIEWMENU,		IDS_RESSYMBOLS,		0 },				"%vy",		NULL,
    IDM_FILE_SETINCLUDES,	{ IDS_VIEWMENU,		IDS_RESINCLUDES,	0 },				"%vn",		NULL,
    ID_WINDOW_FULLSCREEN,	{ IDS_VIEWMENU,		IDS_FULLSCREEN,		0 },				"%vu",		NULL,
    IDM_TOOLBAR_EDIT,		{ IDS_VIEWMENU,		IDS_TOOLBARS,		0 },				"%vt",		NULL,
    IDM_WINDOW_ERRORS,		{ IDS_VIEWMENU,		IDS_OUTPUT,			0 },				"%vo",		"%2",
    IDMY_CLASSWIZARD,		{ IDS_VIEWMENU,		IDS_CLASSWIZARD,	0 },				"%vw",		"^w",
    IDM_VIEW_WORKSPACE,		{ IDS_VIEWMENU,		IDS_WORKSPACE,		0 },				"%vp",		"%0", 
    IDM_VIEW_GLOBALWORKSPACE, { IDS_VIEWMENU,	IDS_GLOBALWORKSPACE, 0 },				"%vg",		"%+0", 
	IDM_VIEW_WATCH,			{ IDS_VIEWMENU,		IDS_VIEWDEBUGWNDS,			IDS_WATCH		},				"%vda",		"%3",
    IDM_VIEW_VARS,			{ IDS_VIEWMENU,		IDS_VIEWDEBUGWNDS,			IDS_VARIABLES	},				"%vdv",		"%4",
    IDM_VIEW_REGS,			{ IDS_VIEWMENU,		IDS_VIEWDEBUGWNDS,			IDS_REGISTERS	},				"%vdr",		"%5",
    IDM_VIEW_MEM,			{ IDS_VIEWMENU,		IDS_VIEWDEBUGWNDS,			IDS_MEMORY		},				"%vdm",		"%6",
    IDM_VIEW_STACK,			{ IDS_VIEWMENU,		IDS_VIEWDEBUGWNDS,			IDS_CALLSTACK	},				"%vdc",		"%7",
    IDM_VIEW_ASM,			{ IDS_VIEWMENU,		IDS_VIEWDEBUGWNDS,			IDS_DISASSEMBLY	},				"%vdd",		"%8",
	IDM_VIEW_TOPIC,			{ IDS_VIEWMENU,		IDS_TOPICWND,		0 },				"%vt",		"%1",
	IDM_VIEW_RESULTS,		{ IDS_VIEWMENU,		IDS_RESULTWND,		0 },				"%vr",		NULL,

	// insert commands

    IDM_GALLERY,			{ IDS_PROJECTMENU,	IDS_ADDTOPROJECT,	IDS_GALLERY },				"%ic",		NULL,

	// project commands

	IDM_ADDMENU,			{ IDS_PROJECTMENU,	IDS_ADDTOPROJECT,	0 },				"%ii",		NULL,
    IDM_PROJITEM_ADD_FILES,	{ IDS_PROJECTMENU,	IDS_ADDTOPROJECT,	IDS_ADDFILES },				"%ii",		NULL,
    IDM_PROJ_ADD_DATASOURCE,{ IDS_PROJECTMENU,	IDS_ADDTOPROJECT,	IDS_DATACON },				"%pad",		NULL,
    IDM_PROJ_ACTIVEPROJMENU,{ IDS_PROJECTMENU,	IDS_SETACTIVEPROJ,	0 },				"%pv",		NULL,
    IDM_PROJECT_TARGET,		{ IDS_INSERTMENU,	IDS_TARGET,			0 },				"%ip",		NULL,
    IDM_INSERT_FROM_FILE,	{ IDS_INSERTMENU,	IDS_INSERTFILE,		0 },				"%if",		NULL,
    IDM_PROJITEM_COMPILE,	{ IDS_BUILDMENU,	IDS_COMPILE,		0 },				"%bc",		"^({F8})",
    IDM_PROJITEM_BUILD,		{ IDS_BUILDMENU,	IDS_BUILD,			0 },				"%bb",		"+({F8})",
    IDM_PROJITEM_REBUILD_ALL,{ IDS_BUILDMENU,	IDS_REBUILDALL,		0 },				"%br",		"%({F8})",
    IDM_PROJECT_STOP_BUILD,	{ IDS_BUILDMENU,	IDS_STOPBUILD,		0 },				"%bb",		"^({BREAK})",
    IDM_PROJECT_EXECUTE,	{ IDS_BUILDMENU,	IDS_EXECUTE,		0 },				"%bx",		"^({F5})",
    IDM_PROJECT_SETTINGS,	{ IDS_PROJECTMENU,	IDS_SETTINGS,		0 },				"%bs",		NULL,
    IDM_PROJECT_CONFIGURATIONS, { IDS_BUILDMENU,IDS_DEFALTCONFIG,   0 },                            "%bf",          NULL,

    IDM_PROJECT_SCAN_ALL,	{ IDS_BUILDMENU,	IDS_UPDATEDEP,		0 },				"%ba",		NULL,
    IDM_PROJECT_EXPORT_MAKEFILE,{ IDS_BUILDMENU,        IDS_EXPORTMAK,          0 },                            "%bk",          NULL,
    IDM_RUN_PROFILE,		{ IDS_TOOLSMENU,	IDS_PROFILE,		0 },				"%tf",		NULL,

	// resource commands

    IDM_NEW_ATL_OBJECT,		{ IDS_INSERTMENU,	IDS_NEW_ATL_OBJECT, 0 },				"%ia",		NULL,
	IDM_RESOURCE_NEW,		{ IDS_INSERTMENU,	IDS_NEWRESOURCE,	0 },				"%ir",		"^r",
	IDMY_TEST,				{ IDS_LAYOUTMENU,	IDS_TESTDLG,		0 },				"%lt",		"^t",
	IDM_VIEWASPOPUP,		{ 0,				0,					0 },				"^+{f10}{DOWN 4}{ENTER}",NULL,
    IDM_NEW_STRING,			{ IDS_INSERTMENU,	IDS_NEWSTRING,		0 },				"%iw",		"{insert}",
    IDM_NEW_ACCELERATOR,	{ IDS_INSERTMENU,	IDS_NEWACCELERATOR,	0 },				"%ia",		"{insert}",
    IDM_INVERTCOLORS,		{ IDS_IMAGEMENU,	IDS_INVERTCOLORS,	0 },				"%ii",		NULL,
    IDM_FLIPBSHH,			{ IDS_IMAGEMENU,	IDS_FLIPHORIZ,		0 },				"%ih",		"x",
    IDM_FLIPBSHV,			{ IDS_IMAGEMENU,	IDS_FLIPVERT,		0 },				"%iv",		"y",
    IDM_ROT90,				{ IDS_IMAGEMENU,	IDS_ROTATE90,		0 },				"%i9",		"z",
    IDM_NEW_STRINGBLOCK,	{ IDS_INSERTMENU,	IDS_NEWSTRINGBLOCK,	0 },				"%iw",		NULL,
    IDM_DELETE_STRINGBLOCK,	{ IDS_INSERTMENU,	IDS_DELSTRINGBLOCK,	0 },				"%id",		NULL,
	IDM_GRIDSETTINGS,		{ IDS_LAYOUTMENU,	IDS_GUIDESETTINGS,	0 },				"%lg",		NULL,
	IDM_RESOURCE_EXPORT,	{ 0,				0,					0 },			"+({F10}e",		NULL,
	IDM_NEWDEVIMG,			{ IDS_IMAGEMENU,	IDS_NEWDEVIMG,		0 },				"%mn",		"{insert}",
	IDM_TOOLBAR_WIZARD,		{ IDS_IMAGEMENU,	IDS_TOOLBAR_EDITOR, 0 },				"%it",		NULL,				
	
	// debug commands

    IDM_BUILD_DEBUG_GO,		{ IDS_BUILDMENU,	IDS_DEBUG,			IDS_GO },			"%bdg",		"{f5}",
    IDM_BUILD_DEBUG_TRACEINTO,{ IDS_BUILDMENU,	IDS_DEBUG,			IDS_STEPINTO },		"%bdi",		"{f8}",
    IDM_BUILD_DEBUG_TOCURSOR,{ IDS_BUILDMENU,	IDS_DEBUG,			IDS_STEPTOCURSOR },	"%bdc",		"{f7}",
    IDM_BUILD_DEBUG_ATTACH, { IDS_BUILDMENU,	IDS_DEBUG,			IDS_ATTACHTOPROCESS},"%bda",	NULL,
    IDM_CONNECTION,			{ IDS_BUILDMENU,	IDS_CONNECTION,		0 },				"%tn",		NULL,
    IDM_RUN_GO,				{ IDS_DEBUGMENU,	IDS_GO,				0 },				"%dg",		"{f5}",
    IDM_RUN_RESTART,		{ IDS_DEBUGMENU,	IDS_RESTART,		0 },				"%dr",		"+({f5})",
    IDM_RUN_STOPDEBUGGING,	{ IDS_DEBUGMENU,	IDS_STOPDEBUGGING,	0 },				"%dd",		"%({f5})",
    IDM_RUN_BREAK,			{ IDS_DEBUGMENU,	IDS_BREAK,			0 },				"%db",		NULL,
    IDM_RUN_TOCURSOR,		{ IDS_DEBUGMENU,	IDS_STEPTOCURSOR,	0 },				"%dc",		"{f7}",
    IDM_RUN_TRACEINTO,		{ IDS_DEBUGMENU,	IDS_STEPINTO,		0 },				"%di",		"{f8}",
    IDM_RUN_STEPOVER,		{ IDS_DEBUGMENU,	IDS_STEPOVER,		0 },				"%do",		"{f10}",
    IDM_RUN_STOPAFTERRETURN,{ IDS_DEBUGMENU,	IDS_STOPRETURN,		0 },				"%du",		"+({f7})",
    IDM_RUN_QUICKWATCH,		{ IDS_DEBUGMENU,	IDS_QUICKWATCH,		0 },				"%dq",		"+({f9})",
    IDM_RUN_EXCEPTIONS,		{ IDS_DEBUGMENU,	IDS_EXCEPTIONS,		0 },				"%de",		NULL,
    IDM_RUN_THREADS,		{ IDS_DEBUGMENU,	IDS_THREADS,		0 },				"%dt",		NULL,

	// tools commands

    IDM_CUSTOMIZE,			{ IDS_TOOLSMENU,	IDS_CUSTOMIZE,		0 },				"%tc",		NULL,
    IDM_OPTIONS,			{ IDS_TOOLSMENU,	IDS_OPTIONS,		0 },				"%to",		NULL,
    ID_TOOLS_RECORD,		{ IDS_TOOLSMENU,	IDS_RECORD,			0 },				"%tr",		"^+R",
    ID_TOOLS_PLAYBACK,		{ IDS_TOOLSMENU,	IDS_PLAYBACK,		0 },				"%tp",		"^+P",
    IDM_PROJECT_TOOL_MECR,	{ IDS_TOOLSMENU,	IDS_UPDATEREMOTE,	0 },				"%tu",		NULL,
    IDM_BROWSE_QUERY,		{ IDS_TOOLSMENU,	IDS_BROWSE,			0 },				"%tw",		"^{F11}",       
    IDM_MACROS,				{ IDS_TOOLSMENU,	IDS_MACROS,			0 },				"%tm",		NULL,
    IDM_TOOLS_RUNMENU,		{ IDS_TOOLSMENU,	IDS_TOOLSRUN,		0 },				"%tu",		"NULL",
	IDM_QUERY_GROUPBYMENU,	{ IDS_QUERYMENU,	IDS_GROUPBY,		0 },				"%qg",		"NULL",
	IDM_QUERY_VERIFYMENU,	{ IDS_QUERYMENU,	IDS_VERIFYSQL,		0 },				"%qv",		"NULL",
	// window commands

    ID_WINDOW_NEW,			{ IDS_WINDOWMENU,	IDS_NEWWINDOW,		0 },				"%wn",		NULL,   
    ID_WINDOW_SPLIT,		{ IDS_WINDOWMENU,	IDS_SPLITWINDOW,	0 },				"%wp",		NULL,
    ID_WINDOW_HIDE,			{ IDS_WINDOWMENU,	IDS_HIDEWINDOW,		0 },				"%wd",		"+({ESC})",
    ID_WINDOW_CASCADE,		{ IDS_WINDOWMENU,	IDS_CASCADE,		0 },				"%wc",		NULL,
    ID_WINDOW_TILE_HORZ,	{ IDS_WINDOWMENU,	IDS_TILEHORIZ,		0 },				"%wh",		NULL,
    ID_WINDOW_TILE_VERT,	{ IDS_WINDOWMENU,	IDS_TILEVERT,		0 },				"%wt",		NULL,
    ID_WINDOW_CLOSE_ALL,	{ IDS_WINDOWMENU,	IDS_CLOSEALL,		0 },				"%wl",		NULL,

	// help commands

	IDM_HELP_TIPOFTHEDAY,	{ IDS_HELPMENU,		IDS_TIPOFTHEDAY,	0 },				"%hp",		NULL,
	IDM_HELP_IVBOOKMARKS,	{ IDS_HELPMENU,		IDS_IVBOOKMARKS,	0 },				"%hm",		NULL,
	IDM_HELP_DEFINESUBSETS,	{ IDS_HELPMENU,		IDS_DEFINESUBSETS,	0 },				"%hd",		"^(+d)",
	IDM_HELP_SELECTSUBSETS,	{ IDS_HELPMENU,		IDS_SELECTSUBSETS,	0 },				"%hb",		NULL,
	IDM_HELP_SEARCH,		{ IDS_HELPMENU,		IDS_SEARCH,			0 },				"%hs",		NULL,

	// popup menus, without commands

    MENU_FILE,				{ IDS_FILEMENU,		0,					0 },				"%f",		NULL,
    MENU_EDIT,				{ IDS_EDITMENU,		0,					0 },				"%e",		NULL,
    MENU_VIEW,				{ IDS_VIEWMENU,		0,					0 },				"%v",		NULL,
	MENU_INSERT,			{ IDS_INSERTMENU,	0,					0 },				"%i",		NULL,
    MENU_PROJECT,			{ IDS_PROJECTMENU,	0,					0 },				"%p",		NULL,
    MENU_BUILD,				{ IDS_BUILDMENU,	0,					0 },				"%b",		NULL,
    MENU_DEBUG,				{ IDS_DEBUGMENU,	0,					0 },				"%d",		NULL,
    MENU_TOOLS,				{ IDS_TOOLSMENU,	0,					0 },				"%t",		NULL,
    MENU_WINDOW,			{ IDS_WINDOWMENU,	0,					0 },				"%w",		NULL,
    MENU_HELP,				{ IDS_HELPMENU,		0,					0 },				"%h",		NULL,
    MENU_IMAGE,				{ IDS_IMAGEMENU,	0,					0 },				"%m",		NULL,
    MENU_LAYOUT,			{ IDS_LAYOUTMENU,	0,					0 },				"%l",		NULL,

// keep this line last!!!
    0,						{ 0,				0,					0 },				NULL,		NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\uveredit.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	UVEREDIT.CPP
//
//	Created by :			Date :
//		EnriqueP				8/13/93
//
//	Description :
//		Implementation of the UIVerEdit class
//

#include "stdafx.h"
#include "uveredit.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: BOOL UIVerEdit::IsValid(void) const
// Description: Determine whether the version editor is valid by determining if the window is valid, visible, the Resource Symbols menu item is enabled, and the title is correct.
// Return: A Boolean value that indicates whether the window is valid: TRUE if it's valid; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIVerEdit::IsValid(void) const
{
	return UIResEditor::IsValid() && IsValidType(m_pszTypeText[ED_VERSION]);
}

// Add Utilities here
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\res\uveredit.h ===
///////////////////////////////////////////////////////////////////////////////
//	UVEREDIT.H
//
//	Created by :			Date :
//		EnriqueP				12/1/93
//
//	Description :
//		Declaration of the UIVerEdit class
//

#ifndef __UIVEREDIT_H__
#define __UIVEREDIT_H__

#include "uresedit.h"

#include "export.h"

#ifndef __UIRESEDIT_H__
	#error include 'uresedit.h' before including this file for PCH
#endif

///////////////////////////////////////////////////////////////////////////////
// UIVerEdit class

// BEGIN_CLASS_HELP
// ClassName: UIVerEdit
// BaseClass: UIResEditor
// Category: Editors
// END_CLASS_HELP
class RES_CLASS UIVerEdit : public UIResEditor
{
public:
	UIWND_COPY_CTOR(UIVerEdit, UIResEditor);
	

// Data
protected:
	

// Attributes
public:
	virtual BOOL IsValid(void) const;

// Utilities
	

};

// Strings found in SGetPropTitle


#endif //__UIVEREDIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\coconnec.cpp ===
//////////////////////////////////////////////////////////////////////////////
//  COCONNEC.CPP
//
//  Created by :            Date :
//      MichMa                  9/16/94
//
//  Description :
//      Implementation of the COConnection class
//

#include "stdafx.h"
#include "coconnec.h"
#include "testxcpt.h"
#include "..\..\testutil.h"
#include "guiv1.h"
#include "mstwrap.h"
#include "uwbframe.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

SHL_DATA COConnection *gpConnec;

int platform_id[] = {IDSS_PLATFORM_WIN32, IDSS_PLATFORM_WIN32,                                     
					 IDSS_PLATFORM_MAC68K, IDSS_PLATFORM_MACPPC,
					 IDSS_PLATFORM_WIN32, IDSS_PLATFORM_WIN32,
					 IDSS_PLATFORM_WIN32, IDSS_PLATFORM_XBOX};                                     

int connection_id[7][4] =          
	{IDSS_CONNECTION_LOCAL, IDSS_CONNECTION_SERIAL, 0, IDSS_CONNECTION_TCPIP,             
	 0, IDSS_CONNECTION_SERIAL, 0, 0,                                                  
	 0, IDSS_CONNECTION_SERIAL, IDSS_CONNECTION_APPLETALK, IDSS_CONNECTION_TCPIP,               
	 0, IDSS_CONNECTION_SERIAL, IDSS_CONNECTION_APPLETALK, IDSS_CONNECTION_TCPIP,
	 IDSS_CONNECTION_LOCAL, 0, 0, 0,   //review: do mips, alpha, or powerpc
	 IDSS_CONNECTION_LOCAL, 0, 0, 0,   //have non-local connections?
	 0, 0, 0, IDSS_CONNECTION_TCPIP};

int settings_title_id[7][4] =                                                                                                                                                                                        
	{0, IDSS_DLG_TITLE_WIN32_SERIAL, 0, IDSS_DLG_TITLE_WIN32_TCPIP,
	 0, IDSS_DLG_TITLE_WIN32_SERIAL, 0, 0,
	 0, IDSS_DLG_TITLE_MAC68K_SERIAL, IDSS_DLG_TITLE_MAC68K_APPLETALK, IDSS_DLG_TITLE_MAC68K_TCPIP,                         
	 0, IDSS_DLG_TITLE_MACPPC_SERIAL, IDSS_DLG_TITLE_MACPPC_APPLETALK, IDSS_DLG_TITLE_MACPPC_TCPIP, 
	 0, 0, 0, 0,        //review: do mips, alpha, or powerpc have non-local connection?  
	 0, 0, 0, 0,       //if not no settings dlg title needed
	 0, 0, 0, IDSS_DLG_TITLE_WIN32_TCPIP};

int baud_rate_id[] = {IDSS_BAUD_300, IDSS_BAUD_600, IDSS_BAUD_1200, IDSS_BAUD_1800, 
					  IDSS_BAUD_2400, IDSS_BAUD_4800, IDSS_BAUD_7200, IDSS_BAUD_9600,
					  IDSS_BAUD_14400, IDSS_BAUD_19200, IDSS_BAUD_38400, IDSS_BAUD_57600};

int connector_id[] = {IDSS_CONNECTOR_COM1, IDSS_CONNECTOR_COM2, 
					  IDSS_CONNECTOR_COM3, IDSS_CONNECTOR_COM4};
					   
int data_bits_id[]	  = {IDSS_DATA_BITS_5, IDSS_DATA_BITS_6, IDSS_DATA_BITS_7, IDSS_DATA_BITS_8};                              
int flow_control_id[] = {IDSS_FLOW_CONTROL_HARDWARE, IDSS_FLOW_CONTROL_XONXOFF};          
int stop_bits_id[]    = {IDSS_STOP_BITS_1, IDSS_STOP_BITS_1_PT_5, IDSS_STOP_BITS_2};                         
int parity_id[]       = {IDSS_PARITY_NONE, IDSS_PARITY_ODD, IDSS_PARITY_EVEN};                           

CString user_arg_base[] = {"target_platforms", "connections",                                           //todo: localize
						   "remote_zone", "remote_machine_name", "remote_password",
						   "connector", "baud_rate", "data_bits",
						   "parity", "stop_bits", "flow_control",
						   "remote_local_path", "remote_share_path",
						   "remote_ip_address"};


COConnection::COConnection(PLATFORM_TYPE platform, CSettings **psettings)

	{
	m_platform = platform;
	m_connection = (CONNECTION_TYPE)psettings[0]->GetIntValue(settingConnection);
	m_local_path = psettings[0]->GetTextValue(settingRemoteLocalPath);
	m_share_path = psettings[0]->GetTextValue(settingRemoteSharePath);

	switch(m_connection)
		{
		case CONNECTION_TCP_IP:
			m_pConnecSettings = psettings[1];
			break;
		case CONNECTION_SERIAL:
			m_pConnecSettings = psettings[2];
			break;
		case CONNECTION_APPLETALK:
			m_pConnecSettings = psettings[3];
			break;
		}			
	}

// BEGIN_HELP_COMMENT
// Function: int COConnection::OpenConnectionDlg(void)
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::OpenConnectionDlg(void)
	
	{
	UIWB.DoCommand(IDM_CONNECTION, DC_MNEMONIC);
	m_uicon = MST.WFndWndWait(m_uicon.ExpectedTitle(), FW_DEFAULT, 10);
	
	if(!m_uicon.HWnd())
	
		{
		LOG->RecordInfo("ERROR in COConnection::OpenConnectionDlg(): "
					 "failed to open connection dlg");
		
		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::OpenSettingsDlg(PLATFORM_TYPE platform, 
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::OpenSettingsDlg(PLATFORM_TYPE platform, 
								  CONNECTION_TYPE connection)

	{
	if(OpenConnectionDlg() != ERROR_SUCCESS)
	
		{
		LOG->RecordInfo("ERROR in COConnection::OpenSettingsDlg(): "
					 "failed to open connection dlg");
		
		return ERROR_ERROR;
		}

	if(platform != PLATFORM_CURRENT)
		if(SetPlatformCore(platform) != ERROR_SUCCESS)
	
			{
			LOG->RecordInfo("ERROR in COConnection::OpenSettingsDlg(): "
						 "failed to set platform");
		
			CloseAllDlgs();
			return ERROR_ERROR;
			}

	if(connection != CONNECTION_CURRENT)
		if(SetConnectionCore(connection, platform) != ERROR_SUCCESS) 

			{
			LOG->RecordInfo("ERROR in COConnection::OpenSettingsDlg(): "
						 "failed to set connection");
		
			CloseAllDlgs();
			return ERROR_ERROR;
			}

	int current_platform = GetPowerOfTwo(GetPlatformCore());
	int current_connection = GetPowerOfTwo(GetConnectionCore());

	if((m_uiconset =
	   m_uicon.Settings(GetLocString(settings_title_id[current_platform][current_connection])))
	   == NULL)

			{
			LOG->RecordInfo("ERROR in COConnection::OpenSettingsDlg(): "
						 "failed to open settings dlg");
		
			CloseAllDlgs();
			return ERROR_ERROR;
			}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::CloseAllDlgs(void)
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::CloseAllDlgs(void)

	{
	if(m_uiconset.IsActive())
		if(m_uiconset.Close() != NULL)

			{
			LOG->RecordInfo("ERROR in COConnection::CloseAllDlgs(): "
						 "failed to close settings dlg");
		
			return ERROR_ERROR;
			}

	if(m_uicon.IsActive())
		if(m_uicon.OK() != NULL)
 
			{
			LOG->RecordInfo("ERROR in COConnection::CloseAllDlgs(): "
						 "failed to close connection dlg");
		
			return ERROR_ERROR;
			}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetPlatformCore(PLATFORM_TYPE platform)
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetPlatformCore(PLATFORM_TYPE platform)
	
	{
    if(m_uicon.SetPlatform(GetLocString(platform_id[GetPowerOfTwo(GetTruePlatform(platform))])) 
       != ERROR_SUCCESS)
	
		{
		LOG->RecordInfo("ERROR in COConnection::SetPlatformCore(): "
					 "failed to set platform");
		
		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetConnectionCore(CONNECTION_TYPE connection,
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetConnectionCore(CONNECTION_TYPE connection,
									PLATFORM_TYPE platform)

	{
	PLATFORM_TYPE true_platform = GetTruePlatform(platform);
	 
	CONNECTION_TYPE true_connection =
		(connection != CONNECTION_USER) ? connection : 
		(CONNECTION_TYPE)GetUserConnections(platform);

	if(m_uicon.SetConnection(GetLocString(connection_id[GetPowerOfTwo(true_platform)]
										 [GetPowerOfTwo(true_connection)]))
										 != ERROR_SUCCESS)
	
		{
		LOG->RecordInfo("ERROR in COConnection::SetConnectionCore(): "
					 "failed to set connection");
		
		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetZoneCore(LPCSTR zone, PLATFORM_TYPE platform)
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetZoneCore(LPCSTR zone, PLATFORM_TYPE platform)
	
	{
	CString true_zone = zone ? zone : m_pConnecSettings->GetTextValue(settingRemoteZone);
	
	if(m_uiconset.SetZone(true_zone) != ERROR_SUCCESS)
	
		{
		LOG->RecordInfo("ERROR in COConnection::SetZoneCore(): "
					 "failed to set zone");
		
		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetMachineNameCore(LPCSTR machine_name, 
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetMachineNameCore(LPCSTR machine_name, 
									 PLATFORM_TYPE platform)

	{
	CString true_machine_name = machine_name ? machine_name :
								m_pConnecSettings->GetTextValue(settingRemoteMachName);

	if(m_uiconset.SetMachineName(true_machine_name) != ERROR_SUCCESS)
	
		{
		LOG->RecordInfo("ERROR in COConnection::SetMachineNameCore(): "
					 "failed to set machine name");
		
		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetPasswordCore(LPCSTR password, 
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetPasswordCore(LPCSTR password, CONNECTION_TYPE connection,
								  PLATFORM_TYPE platform)

	{
	// TODO(michma): v6 IDE no longer supports password. since it is disabled in the UI
	// we must ignore it here.
	return ERROR_SUCCESS;

	CString true_password;
	CONNECTION_TYPE true_connection = GetTrueConnection(connection, platform);

	switch(true_connection)
		{
		case CONNECTION_APPLETALK:
			true_password = password ? password :
				m_pConnecSettings->GetTextValue(settingRemoteATPassword);
			break;
		case CONNECTION_TCP_IP:
			true_password = password ? password :
				m_pConnecSettings->GetTextValue(settingRemoteIPPassword);
			break;
		default:
			return ERROR_ERROR;
		}

	if(m_uiconset.SetPassword(true_password, true_connection) != ERROR_SUCCESS)
	
		{
		LOG->RecordInfo("ERROR in COConnection::SetPasswordCore(): "
					 "failed to set password");
		
		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetConnectorCore(CONNECTOR_TYPE connector, 
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetConnectorCore(CONNECTOR_TYPE connector, 
								   PLATFORM_TYPE platform)

	{        
	CONNECTOR_TYPE true_connector = (connector != CONNECTOR_USER) ? connector :
		(CONNECTOR_TYPE)m_pConnecSettings->GetIntValue(settingConnector);
	
	if(m_uiconset.SetConnector(GetLocString(connector_id[true_connector])) != ERROR_SUCCESS)
	
		{
		LOG->RecordInfo("ERROR in COConnection::SetConnectorCore(): "
					 "failed to set connector");
		
		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetBaudRateCore(BAUD_RATE_TYPE baud_rate, 
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetBaudRateCore(BAUD_RATE_TYPE baud_rate, 
								  PLATFORM_TYPE platform)

	{
	BAUD_RATE_TYPE true_baud_rate = (baud_rate != BAUD_RATE_USER) ? baud_rate :
		(BAUD_RATE_TYPE)m_pConnecSettings->GetIntValue(settingBaudRate);

	if(m_uiconset.SetBaudRate(GetLocString(baud_rate_id[true_baud_rate])) != ERROR_SUCCESS)
	
		{
		LOG->RecordInfo("ERROR in COConnection::SetBaudRateCore(): "
					 "failed to set baud rate");
		
		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetDataBitsCore(DATA_BITS_TYPE data_bits, 
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetDataBitsCore(DATA_BITS_TYPE data_bits, 
								  PLATFORM_TYPE platform)

	{
	DATA_BITS_TYPE true_data_bits = (data_bits != DATA_BITS_USER) ? data_bits :
		(DATA_BITS_TYPE)m_pConnecSettings->GetIntValue(settingDataBits);

	if(m_uiconset.SetDataBits(GetLocString(data_bits_id[true_data_bits])) != ERROR_SUCCESS)
	
		{
		LOG->RecordInfo("ERROR in COConnection::SetDataBitsCore(): "
					 "failed to set data bits");
		
		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetParityCore(PARITY_TYPE parity,        PLATFORM_TYPE platform)
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetParityCore(PARITY_TYPE parity,     PLATFORM_TYPE platform)

	{
	PARITY_TYPE true_parity = (parity != PARITY_USER) ? parity :
		(PARITY_TYPE)m_pConnecSettings->GetIntValue(settingParity);

	if(m_uiconset.SetParity(GetLocString(parity_id[true_parity])) != ERROR_SUCCESS)
	
		{
		LOG->RecordInfo("ERROR in COConnection::SetParityCore(): "
			  "failed to set parity");
		
		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetStopBitsCore(STOP_BITS_TYPE stop_bits, 
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetStopBitsCore(STOP_BITS_TYPE stop_bits, 
								  PLATFORM_TYPE platform)

	{
	STOP_BITS_TYPE true_stop_bits = (stop_bits != STOP_BITS_USER) ? stop_bits :
		(STOP_BITS_TYPE)m_pConnecSettings->GetIntValue(settingStopBits);

	if(m_uiconset.SetStopBits(GetLocString(stop_bits_id[true_stop_bits])) != ERROR_SUCCESS)
	
		{
		LOG->RecordInfo("ERROR in COConnection::SetStopBitsCore(): "
			  "failed to set stop bits");
		
		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetFlowControlCore(FLOW_CONTROL_TYPE flow_control, 
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetFlowControlCore(FLOW_CONTROL_TYPE flow_control, 
									 PLATFORM_TYPE platform)

	{
	FLOW_CONTROL_TYPE true_flow_control = 
		(flow_control != FLOW_CONTROL_USER) ? flow_control : 
		(FLOW_CONTROL_TYPE)m_pConnecSettings->GetIntValue(settingFlowControl);

	if(m_uiconset.SetFlowControl(GetLocString(flow_control_id[true_flow_control]))
	   != ERROR_SUCCESS)
	
		{
		LOG->RecordInfo("ERROR in COConnection::SetFlowControlCore(): "
					 "failed to set flow control");
		
		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetIPAddressCore(LPCSTR ip_address,
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetIPAddressCore(LPCSTR ip_address, PLATFORM_TYPE platform)
	
	{
	CString true_ip_address = ip_address ? ip_address : 
		m_pConnecSettings->GetTextValue(settingRemoteIPAddress);

	if(m_uiconset.SetIPAddress(true_ip_address) != ERROR_SUCCESS)
	
		{
		LOG->RecordInfo("ERROR in COConnection::SetIPAddressCore(): "
					 "failed to set ip address");
		
		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetPlatform(PLATFORM_TYPE platform /* PLATFORM_USER */)
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetPlatform(PLATFORM_TYPE platform /* PLATFORM_USER */)

	{
	if(OpenConnectionDlg() != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetPlatform(): "
					 "failed to open connection dlg");

		return ERROR_ERROR;
		}
	
	if(SetPlatformCore(platform) != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetPlatform(): "
					 "failed to set platform");

		CloseAllDlgs();
		return ERROR_ERROR;
		}

	if(CloseAllDlgs() != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetPlatform(): "
					 "failed to close all dlgs");

		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetConnection(CONNECTION_TYPE connection /* CONNECTION_USER */,
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetConnection(CONNECTION_TYPE connection /* CONNECTION_USER */,
								PLATFORM_TYPE platform /* PLATFORM_USER */)

	{
	if(OpenConnectionDlg() != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetConnection(): "
					 "failed to open connection dlg");

		return ERROR_ERROR;
		}
	
	if(platform != PLATFORM_CURRENT)
		if(SetPlatformCore(platform) != ERROR_SUCCESS)

			{
			LOG->RecordInfo("ERROR in COConnection::SetConnection(): "
						 "failed to set platform");

			CloseAllDlgs();
			return ERROR_ERROR;
			}

	if(SetConnectionCore(connection, platform) != ERROR_SUCCESS) 

		{
		LOG->RecordInfo("ERROR in COConnection::SetConnection(): "
					 "failed to set connection");
		
		CloseAllDlgs();
		return ERROR_ERROR;
		}

	if(CloseAllDlgs() != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetConnection(): "
					 "failed to close all dlgs");

		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetZone(LPCSTR zone /* ZONE_USER */,
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetZone(LPCSTR zone /* ZONE_USER */,
						  PLATFORM_TYPE platform /* PLATFORM_USER */)

	{
	if(OpenSettingsDlg(platform, CONNECTION_APPLETALK) != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetZone(): "
					 "failed to open settings dlg");
	
		return ERROR_ERROR;
		}

	if(SetZoneCore(zone, platform) != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetZone(): "
					 "failed to set zone");
	
		CloseAllDlgs();
		return ERROR_ERROR;
		}

	if(CloseAllDlgs() != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetZone(): "
					 "failed to close all dlgs");

		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetMachineName(LPCSTR machine_name 
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetMachineName(LPCSTR machine_name /* MACHINE_NAME_USER */,
								 PLATFORM_TYPE platform /* PLATFORM_USER */)

	{
	if(OpenSettingsDlg(platform, CONNECTION_APPLETALK) != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetMachineName(): "
					 "failed to open settings dlg");
	
		return ERROR_ERROR;
		}

	if(SetMachineNameCore(machine_name, platform) != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetMachineName(): "
					 "failed to set machine name");
	
		CloseAllDlgs();
		return ERROR_ERROR;
		}
	
	if(CloseAllDlgs() != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetMachineName(): "
					 "failed to close all dlgs");

		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetPassword(LPCSTR password /* PASSWORD_USER */,
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetPassword(LPCSTR password /* PASSWORD_USER */,
							  CONNECTION_TYPE connection /* CONNECTION_USER */,
							  PLATFORM_TYPE platform /* PLATFORM_USER */)

	{
	if(OpenSettingsDlg(platform, connection) != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetPassword(): "
					 "failed to open settings dlg");
	
		return ERROR_ERROR;
		}

	if(SetPasswordCore(password, connection, platform) != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetPassword(): "
					 "failed to set password");
	
		CloseAllDlgs();
		return ERROR_ERROR;
		}

	if(CloseAllDlgs() != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetPassword(): "
					 "failed to close all dlgs");

		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetConnector(CONNECTOR_TYPE connector /* CONNECTOR_USER */,
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetConnector(CONNECTOR_TYPE connector /* CONNECTOR_USER */,
							   PLATFORM_TYPE platform /* PLATFORM_USER */)

	{
	if(OpenSettingsDlg(platform, CONNECTION_SERIAL) != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetConnector(): "
					 "failed to open settings dlg");
	
		return ERROR_ERROR;
		}

	if(SetConnectorCore(connector, platform) != ERROR_SUCCESS) 

		{
		LOG->RecordInfo("ERROR in COConnection::SetConnector(): "
					 "failed to set connector");
	
		CloseAllDlgs();
		return ERROR_ERROR;
		}
	
	if(CloseAllDlgs() != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetConnector(): "
					 "failed to close all dlgs");

		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetBaudRate(BAUD_RATE_TYPE baud_rate /* BAUD_RATE_USER */,
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetBaudRate(BAUD_RATE_TYPE baud_rate /* BAUD_RATE_USER */,
							  PLATFORM_TYPE platform /* PLATFORM_USER */)

	{
	if(OpenSettingsDlg(platform, CONNECTION_SERIAL) != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetBaudRate(): "
					 "failed to open settings dlg");
	
		return ERROR_ERROR;
		}

	if(SetBaudRateCore(baud_rate, platform) != ERROR_SUCCESS) 

		{
		LOG->RecordInfo("ERROR in COConnection::SetBaudRate(): "
					 "failed to set baud rate");
	
		CloseAllDlgs();
		return ERROR_ERROR;
		}
	
	if(CloseAllDlgs() != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetBaudRate(): "
					 "failed to close all dlgs");

		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetDataBits(DATA_BITS_TYPE data_bits /* DATA_BITS_USER */,
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetDataBits(DATA_BITS_TYPE data_bits /* DATA_BITS_USER */,
							  PLATFORM_TYPE platform /* PLATFORM_USER */)

	{
	if(OpenSettingsDlg(platform, CONNECTION_SERIAL) != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetDataBits(): "
					 "failed to open settings dlg");
	
		return ERROR_ERROR;
		}

	if(SetDataBitsCore(data_bits, platform) != ERROR_SUCCESS) 

		{
		LOG->RecordInfo("ERROR in COConnection::SetDataBits(): "
					 "failed to set data bits");
	
		CloseAllDlgs();
		return ERROR_ERROR;
		}
	
	if(CloseAllDlgs() != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetDataBits(): "
					 "failed to close all dlgs");

		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetParity(PARITY_TYPE parity /* PARITY_USER */,
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetParity(PARITY_TYPE parity /* PARITY_USER */,
						PLATFORM_TYPE platform /* PLATFORM_USER */)

	{
	if(OpenSettingsDlg(platform, CONNECTION_SERIAL) != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetParity(): "
					 "failed to open settings dlg");
	
		return ERROR_ERROR;
		}

	if(SetParityCore(parity, platform) != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetParity(): "
					 "failed to set parity");
	
		CloseAllDlgs();
		return ERROR_ERROR;
		}

	if(CloseAllDlgs() != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetParity(): "
					 "failed to close all dlgs");

		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetStopBits(STOP_BITS_TYPE stop_bits /* STOP_BITS_USER */,
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetStopBits(STOP_BITS_TYPE stop_bits /* STOP_BITS_USER */,
							  PLATFORM_TYPE platform /* PLATFORM_USER */)

	{
	if(OpenSettingsDlg(platform, CONNECTION_SERIAL) != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetStopBits(): "
					 "failed to open settings dlg");
	
		return ERROR_ERROR;
		}

	if(SetStopBitsCore(stop_bits, platform) != ERROR_SUCCESS) 

		{
		LOG->RecordInfo("ERROR in COConnection::SetStopBits(): "
					 "failed to set stop bits");
	
		CloseAllDlgs();
		return ERROR_ERROR;
		}
	
	if(CloseAllDlgs() != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetStopBits(): "
					 "failed to close all dlgs");

		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetFlowControl(FLOW_CONTROL_TYPE flow_control /* FLOW_CONTROL_USER */,
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetFlowControl(FLOW_CONTROL_TYPE flow_control /* FLOW_CONTROL_USER */,
								 PLATFORM_TYPE platform /* PLATFORM_USER */)

	{
	if(OpenSettingsDlg(platform, CONNECTION_SERIAL) != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetFlowControl(): "
					 "failed to open settings dlg");
	
		return ERROR_ERROR;
		}

	if(SetFlowControlCore(flow_control, platform) != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetFlowControl(): "
					 "failed to set flow control");
	
		CloseAllDlgs();
		return ERROR_ERROR;
		}
	
	if(CloseAllDlgs() != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetFlowControl(): "
					 "failed to close all dlgs");

		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetIPAddress(LPCSTR ip_address /* IP_ADDRESS_USER */,
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetIPAddress(LPCSTR ip_address /* IP_ADDRESS_USER */,
							   PLATFORM_TYPE platform /* PLATFORM_USER */)

	{
	if(OpenSettingsDlg(platform, CONNECTION_TCP_IP) != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetIPAddress(): "
					 "failed to open settings dlg");
	
		return ERROR_ERROR;
		}

	if(SetIPAddressCore(ip_address, platform) != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetIPAddress(): "
					 "failed to set ip address");
	
		CloseAllDlgs();
		return ERROR_ERROR;
		}
	
	if(CloseAllDlgs() != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetIPAddress(): "
					 "failed to close all dlgs");

		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetAll(PLATFORM_TYPE platform /* PLATFORM_USER */,
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetAll(PLATFORM_TYPE platform /* PLATFORM_USER */,
						 CONNECTION_TYPE connection /* CONNECTION_USER */)

	{
	PLATFORM_TYPE true_platform = GetTruePlatform(platform);
	CONNECTION_TYPE true_connection = GetTrueConnection(connection, platform);

	if(((true_platform == PLATFORM_WIN32_X86)||(true_platform == PLATFORM_WIN32_MIPS)) && 
	   (true_connection == CONNECTION_LOCAL))
			
		{
		if(OpenConnectionDlg() != ERROR_SUCCESS)

			{
			LOG->RecordInfo("ERROR in COConnection::SetAll(): "
						 "failed to open connection dlg");

			return ERROR_ERROR;
			}

#ifndef _M_ALPHA
		if(SetPlatformCore(PLATFORM_WIN32_X86) != ERROR_SUCCESS)

			{
			LOG->RecordInfo("ERROR in COConnection::SetAll(): "
						 "failed to set platform to win32 x86");
	
			CloseAllDlgs();
			return ERROR_ERROR;
			}

					
		if(SetConnectionCore(CONNECTION_LOCAL, PLATFORM_CURRENT) 
		   != ERROR_SUCCESS)

			{
			LOG->RecordInfo("ERROR in COConnection::SetAll(): "
						 "failed to set connection to local");
	
			CloseAllDlgs();
			return ERROR_ERROR;
			}

#else
#pragma (message, "COConnect::SetAll is bogus on Alpha.")
// The code above should probably be modified to work 100% correctly on
// ALPHA instead of being commented out, but the fact that it errors due
// to the call to SetPlatformCore which cannot succeed when on Alpha
// stopped it from working.
#endif
		if(CloseAllDlgs() != ERROR_SUCCESS)

			{
			LOG->RecordInfo("ERROR in COConnection::SetAll(): "
						 "failed to close all dlgs");
	
			return ERROR_ERROR;
			}
		
		return ERROR_SUCCESS;
		}
		
	else if(((true_platform == PLATFORM_WIN32_X86) ||
			 (true_platform == PLATFORM_WIN32S_X86)) &&
			 (true_connection == CONNECTION_SERIAL))  
	
		{               
		if(SetAll(platform, CONNECTION_SERIAL, CONNECTOR_USER,
				  BAUD_RATE_USER, FLOW_CONTROL_USER))

			{
			LOG->RecordInfo("ERROR in COConnection::SetAll(): "
						 "failed to set all win32(s) x86 serial settings");
	
			return ERROR_ERROR;
			}

		return ERROR_SUCCESS;
		}


	else if(((true_platform == PLATFORM_MAC_68K) || 
			 (true_platform == PLATFORM_MAC_PPC)) &&
			 (true_connection == CONNECTION_APPLETALK))  
	
		{
		if(SetAll(platform, connection, 
				  (LPCSTR)ZONE_USER, (LPCSTR)MACHINE_NAME_USER, (LPCSTR)PASSWORD_USER))

			{
			LOG->RecordInfo("ERROR in COConnection::SetAll(): "
						 "failed to set all mac appletalk settings");
	
			return ERROR_ERROR;
			}

		return ERROR_SUCCESS;
		}
				
	else if((true_platform == PLATFORM_MAC_68K) && 
			(true_connection == CONNECTION_SERIAL))
				
		{
		if(SetAll(platform, CONNECTION_SERIAL, CONNECTOR_USER, BAUD_RATE_USER, 
				  DATA_BITS_USER, PARITY_USER, STOP_BITS_USER))

			{
			LOG->RecordInfo("ERROR in COConnection::SetAll(): "
						 "failed to set all mac 68k serial settings");
	
			return ERROR_ERROR;
			}

		return ERROR_SUCCESS;
		}

	else if((true_platform == PLATFORM_MAC_PPC) && 
			(true_connection == CONNECTION_SERIAL))

		{
		if(SetAll(platform, CONNECTION_SERIAL, CONNECTOR_USER))

			{
			LOG->RecordInfo("ERROR in COConnection::SetAll(): "
						 "failed to set all mac ppc serial settings");
	
			return ERROR_ERROR;
			}

		return ERROR_SUCCESS;
		}

	else if(true_connection == CONNECTION_TCP_IP)

		{
		if(SetAll(platform, connection, IP_ADDRESS_USER, PASSWORD_USER))

			{
			LOG->RecordInfo("ERROR in COConnection::SetAll(): "
						 "failed to set all tcp/ip settings");
	
			return ERROR_ERROR;
			}

		return ERROR_SUCCESS;
		}
		
	else
	
		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "invalid platform/connection combination");
					
		return ERROR_ERROR;
		}
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetAll(PLATFORM_TYPE platform, CONNECTION_TYPE connection,
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetAll(PLATFORM_TYPE platform, CONNECTION_TYPE connection,
						 CONNECTOR_TYPE connector, BAUD_RATE_TYPE baud_rate,
						 FLOW_CONTROL_TYPE flow_control)

	{
	PLATFORM_TYPE true_platform = GetTruePlatform(platform);

	if(((true_platform != PLATFORM_WIN32_X86) &&
		(true_platform != PLATFORM_WIN32S_X86)) ||
		(connection != CONNECTION_SERIAL))

		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "platform/connection must be win32(s)/serial");
		
		return ERROR_ERROR;
		}

	if(SetAllSerialCore(platform, connector) != ERROR_SUCCESS)
		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "failed to do serial core for win32(s)");
		
		return ERROR_ERROR;
		}
				
	if(SetBaudRateCore(baud_rate, platform) != ERROR_SUCCESS) 

		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "failed to set baud rate for win32(s)");
		
		CloseAllDlgs();
		return ERROR_ERROR;
		}

	if(SetFlowControlCore(flow_control, platform) != ERROR_SUCCESS) 

		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "failed to set flow control for win32(s)");
		
		CloseAllDlgs();
		return ERROR_ERROR;
		}

	if(CloseAllDlgs() != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "failed to close all dlgs for win32(s)/serial");
		
		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetAll(PLATFORM_TYPE platform, CONNECTION_TYPE connection,
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetAll(PLATFORM_TYPE platform, CONNECTION_TYPE connection,
						 LPCSTR zone, LPCSTR machine_name, LPCSTR password)

	{
	PLATFORM_TYPE true_platform = GetTruePlatform(platform);
	CONNECTION_TYPE true_connection = GetTrueConnection(connection, platform);

	if(((true_platform != PLATFORM_MAC_68K) && 
		(true_platform != PLATFORM_MAC_PPC)) ||
	   (true_connection != CONNECTION_APPLETALK)) 

		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "platform/connection must be mac/appletalk");
		
		return ERROR_ERROR;
		}

	if(OpenSettingsDlg(platform, connection) != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "failed to open settings dlg for mac/appletalk");
		
		return ERROR_ERROR;
		}

	if(SetZoneCore(zone, platform) != ERROR_SUCCESS) 

		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "failed to set zone for mac");
		
		CloseAllDlgs();
		return ERROR_ERROR;
		}

	if(SetMachineNameCore(machine_name, platform) != ERROR_SUCCESS) 

		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "failed to set machine name for mac");
		
		CloseAllDlgs();
		return ERROR_ERROR;
		}

	if(SetPasswordCore(password, connection, platform) != ERROR_SUCCESS) 

		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "failed to set password for mac/appletalk");
		
		CloseAllDlgs();
		return ERROR_ERROR;
		}

	if(CloseAllDlgs() != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "failed to close all dlgs for mac/appletalk");
		
		return ERROR_ERROR;
		}
			
	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetAll(PLATFORM_TYPE platform, CONNECTION_TYPE connection,
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetAll(PLATFORM_TYPE platform, CONNECTION_TYPE connection,
						 CONNECTOR_TYPE connector, BAUD_RATE_TYPE baud_rate, 
						 DATA_BITS_TYPE data_bits, PARITY_TYPE parity, 
						 STOP_BITS_TYPE stop_bits)

	{
	PLATFORM_TYPE true_platform = GetTruePlatform(platform);

	if((true_platform != PLATFORM_MAC_68K) || (connection != CONNECTION_SERIAL)) 

		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "platform/connection must be mac 68k/serial");
		
		return ERROR_ERROR;
		}

	if(SetAllSerialCore(platform, connector) != ERROR_SUCCESS)
		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "failed to do serial core for mac 68k");
		
		return ERROR_ERROR;
		}               

	if(SetBaudRateCore(baud_rate, platform) != ERROR_SUCCESS) 

		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "failed to set baud rate for mac 68k");
		
		CloseAllDlgs();
		return ERROR_ERROR;
		}

	if(SetDataBitsCore(data_bits, platform) != ERROR_SUCCESS) 

		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "failed to set data bits for mac 68k");
		
		CloseAllDlgs();
		return ERROR_ERROR;
		}

	if(SetParityCore(parity, platform) != ERROR_SUCCESS) 

		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "failed to set parity for mac 68k");
		
		CloseAllDlgs();
		return ERROR_ERROR;
		}

	if(SetStopBitsCore(stop_bits, platform) != ERROR_SUCCESS) 

		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "failed to set stop bits for mac 68k");
		
		CloseAllDlgs();
		return ERROR_ERROR;
		}

	if(CloseAllDlgs() != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "failed to close all dlgs for mac 68k/serial");
		
		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetAll(PLATFORM_TYPE platform, CONNECTION_TYPE connection,
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetAll(PLATFORM_TYPE platform, CONNECTION_TYPE connection,
						 CONNECTOR_TYPE connector)

	{
	PLATFORM_TYPE true_platform = GetTruePlatform(platform);

	if((true_platform != PLATFORM_MAC_PPC) || (connection != CONNECTION_SERIAL))

		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "platform/connection must be mac ppc/serial");
		
		return ERROR_ERROR;
		}

	if(SetAllSerialCore(platform, connector) != ERROR_SUCCESS)
		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "failed to do serial core for mac ppc");
		
		return ERROR_ERROR;
		}               

	if(CloseAllDlgs() != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "failed to close all dlgs for mac ppc/serial");
		
		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetAll(PLATFORM_TYPE platform, CONNECTION_TYPE connection,
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetAll(PLATFORM_TYPE platform, CONNECTION_TYPE connection,
						 LPCSTR ip_address, LPCSTR password)

	{
	CONNECTION_TYPE true_connection = GetTrueConnection(connection, platform);

	if(true_connection != CONNECTION_TCP_IP)

		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "connection must be tcp/ip");
		
		return ERROR_ERROR;
		}

	if(OpenSettingsDlg(platform, connection) != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "failed to open settings dlg for tcp/ip");
		
		return ERROR_ERROR;
		}

	if(SetIPAddressCore(ip_address, platform) != ERROR_SUCCESS)
		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "failed to set ip address");
		
		return ERROR_ERROR;
		}               

	if(SetPasswordCore(password, connection, platform) != ERROR_SUCCESS)
		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "failed to set ip password");
		
		return ERROR_ERROR;
		}               

	if(CloseAllDlgs() != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetAll(): "
					 "failed to close all dlgs for tcp/ip");
		
		return ERROR_ERROR;
		}
   
	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::SetAllSerialCore(PLATFORM_TYPE platform, 
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::SetAllSerialCore(PLATFORM_TYPE platform, 
								   CONNECTOR_TYPE connector)

	{
	if(OpenSettingsDlg(platform, CONNECTION_SERIAL) != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetAllSerialCore(): "
					 "failed to open settings dlg for serial");
		
		return ERROR_ERROR;
		}

	if(SetConnectorCore(connector, platform) != ERROR_SUCCESS)

		{
		LOG->RecordInfo("ERROR in COConnection::SetAllSerialCore(): "
					 "failed to set connector for serial");
		
		CloseAllDlgs();
		return ERROR_ERROR;
		}

	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: PLATFORM_TYPE COConnection::GetTruePlatform(PLATFORM_TYPE platform)
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
PLATFORM_TYPE COConnection::GetTruePlatform(PLATFORM_TYPE platform)
	{
	switch(platform)
		{
		case PLATFORM_USER:
			return (PLATFORM_TYPE)GetUserPlatforms();
		case PLATFORM_CURRENT:
			return GetPlatformCore();
		default:
			return platform;
		}
	}


// BEGIN_HELP_COMMENT
// Function: CONNECTION_TYPE COConnection::GetTrueConnection(CONNECTION_TYPE connection,
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
CONNECTION_TYPE COConnection::GetTrueConnection(CONNECTION_TYPE connection,
											    PLATFORM_TYPE platform)
	{
	switch(connection)
		{
		case CONNECTION_USER:
			return (CONNECTION_TYPE)GetUserConnections(platform);
		case CONNECTION_CURRENT:
			return GetConnectionCore();
		default:
			return connection;
		}
	}


// BEGIN_HELP_COMMENT
// Function: PLATFORM_TYPE COConnection::GetPlatformCore(void)
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
PLATFORM_TYPE COConnection::GetPlatformCore(void)

	{
	CString current_platform_str = m_uicon.GetPlatform();

	if(current_platform_str == GetLocString(platform_id[GetPowerOfTwo(PLATFORM_WIN32_X86)]))
		return PLATFORM_WIN32_X86;
	if(current_platform_str == GetLocString(platform_id[GetPowerOfTwo(PLATFORM_MAC_68K)]))
		return PLATFORM_MAC_68K;
	if(current_platform_str == GetLocString(platform_id[GetPowerOfTwo(PLATFORM_MAC_PPC)]))
		return PLATFORM_MAC_PPC;
	if(current_platform_str == GetLocString(platform_id[GetPowerOfTwo(PLATFORM_XBOX)]))
		return PLATFORM_XBOX;

	EXPECT(0);
	return (PLATFORM_TYPE)0;
	}


// BEGIN_HELP_COMMENT
// Function: CONNECTION_TYPE COConnection::GetConnectionCore(void)
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
CONNECTION_TYPE COConnection::GetConnectionCore(void)

	{
	CString current_connection_str = m_uicon.GetConnection();

	if(current_connection_str == 
		GetLocString(connection_id[GetPowerOfTwo(PLATFORM_WIN32_X86)]
					  [GetPowerOfTwo(CONNECTION_LOCAL)]))
		return CONNECTION_LOCAL;

	if(current_connection_str == 
	   GetLocString(connection_id[GetPowerOfTwo(PLATFORM_WIN32_X86)]
					 [GetPowerOfTwo(CONNECTION_SERIAL)]))
		return CONNECTION_SERIAL;

	if(current_connection_str == 
	   GetLocString(connection_id[GetPowerOfTwo(PLATFORM_MAC_68K)]
					 [GetPowerOfTwo(CONNECTION_APPLETALK)]))
		return CONNECTION_APPLETALK;

	if(current_connection_str == 
	   GetLocString(connection_id[GetPowerOfTwo(PLATFORM_MAC_PPC)]
					 [GetPowerOfTwo(CONNECTION_APPLETALK)]))
		return CONNECTION_APPLETALK;
	
	if(current_connection_str == 
	   GetLocString(connection_id[GetPowerOfTwo(PLATFORM_WIN32_X86)]
					 [GetPowerOfTwo(CONNECTION_TCP_IP)]))
		return CONNECTION_TCP_IP;
	
	if(current_connection_str == 
	   GetLocString(connection_id[GetPowerOfTwo(PLATFORM_MAC_68K)]
					 [GetPowerOfTwo(CONNECTION_TCP_IP)]))
		return CONNECTION_TCP_IP;
	
	if(current_connection_str == 
	   GetLocString(connection_id[GetPowerOfTwo(PLATFORM_MAC_PPC)]
					 [GetPowerOfTwo(CONNECTION_TCP_IP)]))
		return CONNECTION_TCP_IP;
	
	if(current_connection_str == 
	   GetLocString(connection_id[GetPowerOfTwo(PLATFORM_XBOX)]
					 [GetPowerOfTwo(CONNECTION_TCP_IP)]))
		return CONNECTION_TCP_IP;
	
	EXPECT(0);
	return (CONNECTION_TYPE)0;
	}


// BEGIN_HELP_COMMENT
// Function: PLATFORM_TYPE COConnection::GetPlatform(void)
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
PLATFORM_TYPE COConnection::GetPlatform(void)
	{
	EXPECT(OpenConnectionDlg() == ERROR_SUCCESS);
	PLATFORM_TYPE current_platform = GetPlatformCore();
	EXPECT(CloseAllDlgs() == ERROR_SUCCESS);
	return current_platform;
	}


// BEGIN_HELP_COMMENT
// Function: CONNECTION_TYPE COConnection::GetConnection(PLATFORM_TYPE platform /* PLATFORM_CURRENT */)
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
CONNECTION_TYPE COConnection::GetConnection(PLATFORM_TYPE platform /* PLATFORM_CURRENT */)

	{
	EXPECT(OpenConnectionDlg() == ERROR_SUCCESS);

	if(platform != PLATFORM_CURRENT)
		EXPECT(SetPlatformCore(platform) == ERROR_SUCCESS);

	CONNECTION_TYPE current_connection = GetConnectionCore();
	EXPECT(CloseAllDlgs() == ERROR_SUCCESS);
	return current_connection;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::GetUserPlatforms(void)
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::GetUserPlatforms(void)

	{
	return m_platform;
	}


// BEGIN_HELP_COMMENT
// Function: int COConnection::GetUserConnections(PLATFORM_TYPE platform /* PLATFORM_USER */)
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
int COConnection::GetUserConnections(PLATFORM_TYPE platform /* PLATFORM_USER */)
	{
	return m_connection;
	}


// BEGIN_HELP_COMMENT
// Function: CString COConnection::GetUserRemoteLocalPath(PLATFORM_TYPE platform 
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
CString COConnection::GetUserRemoteLocalPath(PLATFORM_TYPE platform /* PLATFORM_USER */)
	{
	return m_local_path;
	}


// BEGIN_HELP_COMMENT
// Function: CString COConnection::GetUserRemoteSharePath(PLATFORM_TYPE platform
// Description: The description for this function is not available. Please see the appropriate component owner for a description of this function.
// Return: The return value description for this function is not available.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
CString COConnection::GetUserRemoteSharePath(PLATFORM_TYPE platform /* PLATFORM_USER */)
	{
	return m_share_path;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\coconnec.h ===
///////////////////////////////////////////////////////////////////////////////
//  COCONNEC.H
//
//  Created by :            Date :
//      MichMa                  9/16/94
//
//  Description :
//      Declaration of the COConnection class
//

#ifndef __COCONNEC_H__
#define __COCONNEC_H__

#include "uioptdlg.h"
#include "uiconnec.h"
#include "uiconset.h"
#include <settings.h>
#include "shlxprt.h"

///////////////////////////////////////////////////////////////////////////////
//  COConnection class

#define ZONE_USER 		  NULL
#define MACHINE_NAME_USER NULL
#define PASSWORD_USER  	  NULL
#define IP_ADDRESS_USER	  NULL

typedef enum {CONNECTOR_COM1, CONNECTOR_COM2, CONNECTOR_COM3, 
			  CONNECTOR_COM4, CONNECTOR_USER, CONNECTOR_NON_USER} 
			  CONNECTOR_TYPE;

typedef enum {BAUD_RATE_300,   BAUD_RATE_600,   BAUD_RATE_1200, BAUD_RATE_1800,
			  BAUD_RATE_2400,  BAUD_RATE_4800,  BAUD_RATE_7200, BAUD_RATE_9600,
			  BAUD_RATE_14400, BAUD_RATE_19200, BAUD_RATE_38400, 
			  BAUD_RATE_57600, BAUD_RATE_USER,  BAUD_RATE_NON_USER} 
			  BAUD_RATE_TYPE;

typedef enum {DATA_BITS_5, DATA_BITS_6, DATA_BITS_7, DATA_BITS_8,
			  DATA_BITS_USER, DATA_BITS_NON_USER} DATA_BITS_TYPE;

#undef PARITY_NONE		// review: where the hell are these
#undef PARITY_ODD		// being previously defined?
#undef PARITY_EVEN 
#undef PARITY_USER

typedef enum {PARITY_NONE, PARITY_ODD, PARITY_EVEN, 
			  PARITY_USER, PARITY_NON_USER} PARITY_TYPE;

typedef enum {STOP_BITS_1, STOP_BITS_1_PT_5, STOP_BITS_2,
			  STOP_BITS_USER, STOP_BITS_NON_USER} STOP_BITS_TYPE;

typedef enum {FLOW_CONTROL_HARDWARE, FLOW_CONTROL_XONXOFF, 
			  FLOW_CONTROL_USER, FLOW_CONTROL_NON_USER} FLOW_CONTROL_TYPE;

typedef enum {CONNEC_TARGET_PLATFORMS, CONNEC_CONNECTIONS,
			  CONNEC_ZONE, CONNEC_MACHINE_NAME, CONNEC_PASSWORD,
			  CONNEC_CONNECTOR, CONNEC_BAUD_RATE, CONNEC_DATA_BITS,
			  CONNEC_PARITY, CONNEC_STOP_BITS, CONNEC_FLOW_CONTROL,
			  CONNEC_REMOTE_LOCAL_PATH, CONNEC_REMOTE_SHARE_PATH,
			  CONNEC_IP_ADDRESS} 
			  CONNEC_INFO_TYPE;

typedef enum {RETRIEVAL_METHOD_REGISTRY, RETRIEVAL_METHOD_CMD_LINE,
			  RETRIEVAL_METHOD_DEFAULT} RETRIEVAL_METHOD_TYPE;

// BEGIN_CLASS_HELP
// ClassName: COConnection
// BaseClass: none
// Category: Shell
// END_CLASS_HELP
class SHL_CLASS COConnection

	{
	public:
		COConnection(PLATFORM_TYPE platform, CSettings **psettings);
	// Data
	private:

		UIConnection m_uicon;
		UIConnectionSettings m_uiconset;
		CSettings *m_pConnecSettings;
		PLATFORM_TYPE m_platform;
		CONNECTION_TYPE m_connection;
		CString m_local_path, m_share_path;

	// Internal Opertaions:
	private:

		int OpenSettingsDlg(PLATFORM_TYPE platform,	
							CONNECTION_TYPE connection);

		int OpenConnectionDlg(void);
		int CloseAllDlgs(void);

		int SetAllSerialCore(PLATFORM_TYPE platform, CONNECTOR_TYPE connector);
		int SetPlatformCore(PLATFORM_TYPE platform);

		int SetConnectionCore(CONNECTION_TYPE connection, 
							  PLATFORM_TYPE platform);

		int SetZoneCore(LPCSTR zone, PLATFORM_TYPE platform);
		int SetMachineNameCore(LPCSTR machine_name, PLATFORM_TYPE platform);

		int SetPasswordCore(LPCSTR password, CONNECTION_TYPE connection,
						    PLATFORM_TYPE platform);

		int SetConnectorCore(CONNECTOR_TYPE connector, PLATFORM_TYPE platform);
		int SetBaudRateCore(BAUD_RATE_TYPE baud_rate, PLATFORM_TYPE platform);
		int SetDataBitsCore(DATA_BITS_TYPE data_bits, PLATFORM_TYPE platform);
		int SetParityCore(PARITY_TYPE parity, PLATFORM_TYPE platform);
		int SetStopBitsCore(STOP_BITS_TYPE stop_bits, PLATFORM_TYPE platform);
		
		int SetFlowControlCore(FLOW_CONTROL_TYPE flow_control, 
							   PLATFORM_TYPE platform);

		int SetIPAddressCore(LPCSTR ip_address, PLATFORM_TYPE platform);

		PLATFORM_TYPE GetTruePlatform(PLATFORM_TYPE platform);

		CONNECTION_TYPE GetTrueConnection(CONNECTION_TYPE connection, 
										  PLATFORM_TYPE platform);
		
		PLATFORM_TYPE GetPlatformCore(void);
		CONNECTION_TYPE GetConnectionCore(void);

	// Utilities
	public:

		int SetPlatform(PLATFORM_TYPE platform = PLATFORM_USER);

		int SetConnection(CONNECTION_TYPE connection = CONNECTION_USER,
						  PLATFORM_TYPE platform = PLATFORM_USER);

		int SetZone(LPCSTR zone = ZONE_USER,
					PLATFORM_TYPE platform = PLATFORM_USER);

		int SetMachineName(LPCSTR machine_name = MACHINE_NAME_USER,
						   PLATFORM_TYPE platform = PLATFORM_USER);

		int SetPassword(LPCSTR password = PASSWORD_USER,
						CONNECTION_TYPE connection = CONNECTION_USER,
						PLATFORM_TYPE platform = PLATFORM_USER);

		int SetConnector(CONNECTOR_TYPE connector = CONNECTOR_USER,
						 PLATFORM_TYPE platform = PLATFORM_USER);

		int SetBaudRate(BAUD_RATE_TYPE baud_rate = BAUD_RATE_USER,
						PLATFORM_TYPE platform = PLATFORM_USER);

		int SetDataBits(DATA_BITS_TYPE data_bits = DATA_BITS_USER,
						PLATFORM_TYPE platform = PLATFORM_USER);

		int SetParity(PARITY_TYPE parity = PARITY_USER,
					  PLATFORM_TYPE platform = PLATFORM_USER);

		int SetStopBits(STOP_BITS_TYPE stop_bits = STOP_BITS_USER,
						PLATFORM_TYPE platform = PLATFORM_USER);

		int SetFlowControl(FLOW_CONTROL_TYPE flow_control = FLOW_CONTROL_USER,
						   PLATFORM_TYPE platform = PLATFORM_USER);

		int SetIPAddress(LPCSTR	ip_address = IP_ADDRESS_USER,
						 PLATFORM_TYPE platform = PLATFORM_USER);

		int SetAll(PLATFORM_TYPE platform = PLATFORM_USER,
				  CONNECTION_TYPE connection = CONNECTION_USER);

		int SetAll(PLATFORM_TYPE platform, CONNECTION_TYPE connection,
				   LPCSTR zone, LPCSTR machine_name, LPCSTR password);

		int SetAll(PLATFORM_TYPE platform, CONNECTION_TYPE connection,
				   CONNECTOR_TYPE connector, BAUD_RATE_TYPE baud_rate, 
				   DATA_BITS_TYPE data_bits, PARITY_TYPE parity,
				   STOP_BITS_TYPE stop_bits);

		int SetAll(PLATFORM_TYPE platform, CONNECTION_TYPE connection,
				   CONNECTOR_TYPE connector);

		int SetAll(PLATFORM_TYPE platform, CONNECTION_TYPE connection,
				   CONNECTOR_TYPE connector, BAUD_RATE_TYPE baud_rate,
				   FLOW_CONTROL_TYPE flow_control);

		int SetAll(PLATFORM_TYPE platform, CONNECTION_TYPE connection,
				   LPCSTR ip_address, LPCSTR password);

		PLATFORM_TYPE GetPlatform(void);

		CONNECTION_TYPE GetConnection(PLATFORM_TYPE platform = 
									  PLATFORM_CURRENT);

		int GetUserPlatforms(void);
		int GetUserConnections(PLATFORM_TYPE platform = PLATFORM_USER);
		CString GetUserRemoteLocalPath(PLATFORM_TYPE platform = PLATFORM_USER);
		CString GetUserRemoteSharePath(PLATFORM_TYPE platform = PLATFORM_USER);
	};

extern SHL_DATA COConnection *gpConnec;

#endif // __COCONNEC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\coenv.h ===
///////////////////////////////////////////////////////////////////////////////
//  COENV.H
//
//  Created by :            Date :
//      MichMa                  11/17/95
//
//  Description :
//      Declaration of the COEnvironment class
//

#ifndef __COENV_H__
#define __COENV_H__

#include "uioptdlg.h"
#include "shlxprt.h"

///////////////////////////////////////////////////////////////////////////////
//  COEnvironment class

enum DIR_TYPE {DIR_TYPE_CURRENT, DIR_TYPE_EXE, DIR_TYPE_INC, DIR_TYPE_LIB};

// BEGIN_CLASS_HELP
// ClassName: COEnvironment
// BaseClass: none
// Category: Shell
// END_CLASS_HELP
class SHL_CLASS COEnvironment

	{
	// Data
	private:
		UIOptionsTabDlg m_optdlg;

	// Private Utilites:
	private:
		int DirectoryCore(DIR_TYPE dtDirType, int intPlatforms);

	// Public Utilities
	public:
		int PrependDirectory(LPCSTR szNewDir, DIR_TYPE dtDirType = DIR_TYPE_CURRENT, int intPlatforms = PLATFORM_CURRENT);
		int PrependDirectories(CStringArray &cstrArrayDirs, DIR_TYPE dtDirType = DIR_TYPE_CURRENT, int intPlatforms = PLATFORM_CURRENT); 
		int RemoveDirectory(LPCSTR szDir, DIR_TYPE dtDirType = DIR_TYPE_CURRENT, int intPlatforms = PLATFORM_CURRENT);
		int RemoveDirectory(int iIndexDir, DIR_TYPE dtDirType = DIR_TYPE_CURRENT, int intPlatforms = PLATFORM_CURRENT);
		int RemoveDirectories(CStringArray &cstrArrayDirs, DIR_TYPE dtDirType = DIR_TYPE_CURRENT, int intPlatforms = PLATFORM_CURRENT); 
	};

#endif // __COENV_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\coenv.cpp ===
//////////////////////////////////////////////////////////////////////////////
//  COENV.CPP
//
//  Created by :            Date :
//      MichMa                  11/17/95
//
//  Description :
//      Implementation of the COEnvironment class
//

#include "stdafx.h"
#include "coenv.h"
#include "testxcpt.h"
#include "..\..\testutil.h"
#include "guiv1.h"
#include "mstwrap.h"
#include "uiwbmsg.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


// BEGIN_HELP_COMMENT
// Function: int COEnvironment::PrependDirectory(LPCSTR szNewDir, DIR_TYPE dtDirType = DIR_TYPE_CURRENT, int intPlatforms = PLATFORM_CURRENT)
// Description: Prepend a directory to one of the environment variables editable on the Directories tab.
// Return: ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szNewDir A pointer to a string containing the directory to prepend.
// Param: dtDirType The environment variable to set: DIR_TYPE_EXE, DIR_TYPE_INC, or DIR_TYPE_LIB.
// Param: intPlatforms The platform(s) to set the environment variable for (one or more PLATFORM_TYPE values).
// END_HELP_COMMENT
int COEnvironment::PrependDirectory(LPCSTR szNewDir, DIR_TYPE dtDirType /* DIR_TYPE_CURRENT */, 
									int intPlatforms /* PLATFORM_CURRENT*/)

	{
	const char* const THIS_FUNCTION = "COEnvironment::PrependDirectory()";

	// make sure a directory name was specified.
	if((szNewDir == NULL) || (szNewDir[0] == 0))
		
		{
		LOG->RecordInfo("%s: no directory specified for platform %d in dir type %d (was NULL or empty).",
						THIS_FUNCTION, intPlatforms, dtDirType);

		return ERROR_ERROR;
		}

	// bring up options dlg, select directories page, and set platform and dir type if specified.
	if(DirectoryCore(dtDirType, intPlatforms) != ERROR_SUCCESS)
		return ERROR_ERROR;

	// since the directories listbox isn't really a listbox, we can't use the MST.WList routines. so we
	// must start from the top and manually count the items in the list. then we add the new item to the
	// end of the list and move it up to the top.
	int intDirCount = 0;
	CString cstrCurrentDir;
	UIWBMessageBox mbAlert;
	
	while(1)
		
		{
		// edit the current directory and get the text.
		MST.DoKeys("^c");
		MST.WEditText("", cstrCurrentDir);

		// if the current directory is empty, we've reached the end of the list.
		if(cstrCurrentDir == "")
			
			{
			// type in the new directory name and commit the edit.
			MST.DoKeys(szNewDir);
			MST.DoKeys("{ENTER}");

			// flag error if we get a msg box.
			if(mbAlert.WaitAttachActive(1000))
				
				{
				LOG->RecordInfo("%s: could not prepend dir %s for platform %d in dir type %d. Check if "
								"directory didn't exist or was a duplicate.", 
								THIS_FUNCTION, szNewDir, intPlatforms, dtDirType);
				
				// take default action (which results in no directory being added).
				MST.DoKeys("{ENTER}");
				// cancel the options dlg.
				m_optdlg.Cancel();
				return ERROR_ERROR;
				}

			break;
			}

		// get out of edit mode and advance to the next directory.
 		MST.DoKeys("{ESC}");
		MST.DoKeys("{DOWN}");
		// update the number of directories we have found in the list.
		intDirCount++;
		}

	// after commiting the new directory, the selection advances to the last (empty) item.
	// we need to select the item we just entered before moving it to the top.
	MST.DoKeys("{UP}");

	// move the new directory to the top of the list.
	for(int i = 0; i < intDirCount; i++)
		MST.DoKeys("%{UP}");

	// ok the options dlg.
	m_optdlg.OK();
	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COEnvironment::PrependDirectories(CStringArray &cstrArrayDirs, DIR_TYPE dtDirType = DIR_TYPE_CURRENT, int intPlatforms = PLATFORM_CURRENT)
// Description: Prepend multiple directories to one of the environment variables editable on the Directories tab.
// Return: ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: CStringArray &cstrArrayDirs A reference to a CStringArray containing the list of directories to prepend.
// Param: dtDirType The environment variable to set: DIR_TYPE_EXE, DIR_TYPE_INC, or DIR_TYPE_LIB.
// Param: intPlatforms The platform(s) to set the environment variable for (one or more PLATFORM_TYPE values).
// END_HELP_COMMENT
int COEnvironment::PrependDirectories(CStringArray &cstrArrayDirs, DIR_TYPE dtDirType /* DIR_TYPE_CURRENT */,
									 int intPlatforms /* PLATFORM_CURRENT*/)

	{
	const char* const THIS_FUNCTION = "COEnvironment::PrependDirectories()";

	// bring up options dlg, select directories page, and set platform and dir type if specified.
	if(DirectoryCore(dtDirType, intPlatforms) != ERROR_SUCCESS)
		return ERROR_ERROR;

	// make sure the user specified directories to remove.
	if(cstrArrayDirs.GetSize() == 0)
		
		{
		LOG->RecordInfo("%s: no dirs specified for platform %d in dir type %d.", 
						THIS_FUNCTION, intPlatforms, dtDirType);

		return ERROR_ERROR;
		}

	// since the directories listbox isn't really a listbox, we can't use the MST.WList routines. so we
	// must start from the top and manually count the items in the list. then we add the new item to the
	// end of the list and move it up to the top.
	int intDirCount = 0, i;
	CString cstrCurrentDir;
	UIWBMessageBox mbAlert;
	
	while(1)
		
		{
		// edit the current directory and get the text.
		MST.DoKeys("^c");
		MST.WEditText("", cstrCurrentDir);

		// if the current directory is empty, we've reached the end of the list.
		if(cstrCurrentDir == "")
			
			{
			// loop through each of the specified directories.
			for(i = 0; i < cstrArrayDirs.GetSize(); i++)

				{
				// type in the new directory name and commit the edit.
				MST.DoKeys(cstrArrayDirs[i]);
				MST.DoKeys("{ENTER}");

				// flag error if we get a msg box.
				if(mbAlert.WaitAttachActive(1000))
					
					{
					LOG->RecordInfo("%s: could not prepend dir %s for platform %d in dir type %d. Check if "
									"directory didn't exist or was a duplicate.", 
									THIS_FUNCTION, cstrArrayDirs[i], intPlatforms, dtDirType);
					
					// take default action (which results in no directory being added).
					MST.DoKeys("{ENTER}");
					// cancel the options dlg.
					m_optdlg.Cancel();
					return ERROR_ERROR;
					}
				}

			break;
			}

		// get out of edit mode and advance to the next directory.
 		MST.DoKeys("{ESC}");
		MST.DoKeys("{DOWN}");
		// update the number of directories we have found in the list.
		intDirCount++;
		}

	// starting with the last one entered, move each new directory to the top in the specified order.
	for(i = 0; i < cstrArrayDirs.GetSize(); i++)

		{
		// select the last dir in the list.
		MST.DoKeys("{END}{UP}");

		// move the directory to the top.
		for(int j = 0; j < (intDirCount + cstrArrayDirs.GetSize() - 1); j++) 
			MST.DoKeys("%{UP}");
		}

	// ok the options dlg.
	m_optdlg.OK();
	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COEnvironment::RemoveDirectory(LPCSTR szDir, DIR_TYPE dtDirType = DIR_TYPE_CURRENT, int intPlatforms = PLATFORM_CURRENT)
// Description: Remove a directory from one of the environment variables editable on the Directories tab.
// Return: ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szDir A pointer to a string containing the directory to remove.
// Param: dtDirType The environment variable to set: DIR_TYPE_EXE, DIR_TYPE_INC, or DIR_TYPE_LIB.
// Param: intPlatforms The platform(s) to set the environment variable for (one or more PLATFORM_TYPE values).
// END_HELP_COMMENT
int COEnvironment::RemoveDirectory(LPCSTR szDir, DIR_TYPE dtDirType /* DIR_TYPE_CURRENT */, 
								   int intPlatforms /* PLATFORM_CURRENT*/)

	{
	const char* const THIS_FUNCTION = "COEnvironment::RemoveDirectory(LPCSTR...)";

	// bring up options dlg, select directories page, and set platform and dir type if specified.
	if(DirectoryCore(dtDirType, intPlatforms) != ERROR_SUCCESS)
		return ERROR_ERROR;

	CString cstrCurrentDir, cstrDir = szDir;

	while(1)
	
		{
		// put the current directory item in edit mode, get the text, and get out of edit mode.
		MST.DoKeys("^c");
		MST.WEditText("", cstrCurrentDir);
		MST.DoKeys("{ESC}");

		// if the current directory is empty, we've reached the end of the list.
		if(cstrCurrentDir == "")
			
			{
			LOG->RecordInfo("%s: could not find dir %s for platform %d in dir type %d.", 
							THIS_FUNCTION, cstrDir, intPlatforms, dtDirType);
			
			// cancel the options dlg.
			m_optdlg.Cancel();
			return ERROR_ERROR;
			}

		// if the current directory matches the specified directory, delete it.
		if(cstrCurrentDir == cstrDir)
			{
			MST.DoKeys("{DEL}");
			break;
			}
		
		// advance to the next directory in the list.
		MST.DoKeys("{DOWN}");
		}

	// ok the options dlg.
	m_optdlg.OK();
	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COEnvironment::RemoveDirectories(CStringArray &cstrArrayDirs, DIR_TYPE dtDirType = DIR_TYPE_CURRENT, int intPlatforms = PLATFORM_CURRENT)
// Description: Remove multiple directories from one of the environment variables editable on the Directories tab.
// Return: ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: cstrArrayDirs A reference to a CStringArray containing the list of directories to remove.
// Param: dtDirType The environment variable to set: DIR_TYPE_EXE, DIR_TYPE_INC, or DIR_TYPE_LIB.
// Param: intPlatforms The platform(s) to set the environment variable for (one or more PLATFORM_TYPE values).
// END_HELP_COMMENT
int COEnvironment::RemoveDirectories(CStringArray &cstrArrayDirs, DIR_TYPE dtDirType /* DIR_TYPE_CURRENT */, 
									 int intPlatforms /* PLATFORM_CURRENT*/)

	{
	const char* const THIS_FUNCTION = "COEnvironment::RemoveDirectories()";

	// make sure the user specified directories to remove.
	if(cstrArrayDirs.GetSize() == 0)
		
		{
		LOG->RecordInfo("%s: no dirs specified for platform %d in dir type %d.", 
						THIS_FUNCTION, intPlatforms, dtDirType);

		return ERROR_ERROR;
		}

	// bring up options dlg, select directories page, and set platform and dir type if specified.
	if(DirectoryCore(dtDirType, intPlatforms) != ERROR_SUCCESS)
		return ERROR_ERROR;

	CString cstrCurrentDir;
	CStringArray cstrArrayDirsTmp;
	int i;
	BOOL bDirDeleted;

	// as we remove each specified directory from the actual list, we'll remove it from our temporary list.
	for(i = 0; i < cstrArrayDirs.GetSize(); i++)
		cstrArrayDirsTmp.Add(cstrArrayDirs[i]);

	// loop until all the specified directories have been removed.
	while(cstrArrayDirsTmp.GetSize() > 0)
	
		{
		// put the current directory item in edit mode, get the text, and get out of edit mode.
		MST.DoKeys("^c");
		MST.WEditText("", cstrCurrentDir);
		MST.DoKeys("{ESC}");

		// if the current directory is empty, we've reached the end of the list.
		if(cstrCurrentDir == "")
			
			{
			LOG->RecordInfo("%s: could not find all dirs for platform %d in dir type %d.", 
							THIS_FUNCTION, intPlatforms, dtDirType);
			
			// cancel the options dlg.
			m_optdlg.Cancel();
			return ERROR_ERROR;
			}

		// we haven't deleted the current dir yet.
		bDirDeleted = FALSE;

		// loop through the specified directories that haven't been deleted yet.
		for(i = 0; i < cstrArrayDirsTmp.GetSize(); i++)
			{
			// if the current dir matches a specified dir, delete it and stop searching.
			if(cstrCurrentDir == cstrArrayDirsTmp[i])
				{
				MST.DoKeys("{DEL}");
				cstrArrayDirsTmp.RemoveAt(i);
				bDirDeleted = TRUE;
				break;
				}
			}

		// if we didn't just delete the current dir, then we need to advance selection to the next dir.
		// otherwise the next dir is selected automatically.	
		if(!bDirDeleted)		
			MST.DoKeys("{DOWN}");
		}

	// ok the options dlg.
	m_optdlg.OK();
	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int COEnvironment::RemoveDirectory(int intIndexDir, DIR_TYPE dtDirType = DIR_TYPE_CURRENT, int intPlatforms = PLATFORM_CURRENT)
// Description: Remove a directory from one of the environment variables editable on the Directories tab.
// Return: ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: intIndexDir An 1-based int value specifiying the position of the directory to remove.
// Param: dtDirType The environment variable to set: DIR_TYPE_EXE, DIR_TYPE_INC, or DIR_TYPE_LIB.
// Param: intPlatforms The platform(s) to set the environment variable for (one or more PLATFORM_TYPE values).
// END_HELP_COMMENT
int COEnvironment::RemoveDirectory(int intIndexDir, DIR_TYPE dtDirType /* DIR_TYPE_CURRENT */, 
								   int intPlatforms /* PLATFORM_CURRENT*/)

	{
	const char* const THIS_FUNCTION = "COEnvironment::RemoveDirectory(int...)";
	
	// bring up options dlg, select directories page, and set platform and dir type if specified.
	if(DirectoryCore(dtDirType, intPlatforms) != ERROR_SUCCESS)
		return ERROR_ERROR;

	// cursor down to the specified directory.
	for(int i = 1; i < intIndexDir; i++)
		MST.DoKeys("{DOWN}");

	CString cstrCurrentDir;
	// edit the current directory, get the text, and get out of edit mode.
	MST.DoKeys("^c");
	MST.WEditText("", cstrCurrentDir);
	MST.DoKeys("{ESC}");

	// if the current directory is empty, we've reached the end of the list.
	if(cstrCurrentDir == "")
		
		{
		LOG->RecordInfo("%s: could not find dir %d for platform %d in dir type %d.", 
						THIS_FUNCTION, intIndexDir, intPlatforms, dtDirType);
		
		// canel the options dlg.
		m_optdlg.Cancel();
		return ERROR_ERROR;
		}

	// delete the directory and ok the options dlg.
 	MST.DoKeys("{DEL}");
	m_optdlg.OK();
	return ERROR_SUCCESS;
	}


// this array is accessed by the power-of-two of the specified platform (see wbutil.h for PLATFORM_TYPE).
int arrayPlatformIndex[] = {1, 1, 2, 3, 1, 1, 1};

int COEnvironment::DirectoryCore(DIR_TYPE dtDirType, int intPlatforms)

	{
	const char* const THIS_FUNCTION = "COEnvironment::DirectoryCore()";

	// display the options dlg.
	if(!m_optdlg.Display())
		{
		LOG->RecordInfo("%s: couldn't display options dlg.", THIS_FUNCTION);
		// just in case wrong dlg came up.
		MST.DoKeys("{ESC}");
		return ERROR_ERROR;
		}

	// select the directories page.
	if(!m_optdlg.ShowPage(TAB_DIRECTORIES, 8))
		{
		LOG->RecordInfo("%s: can't find Directories page of options dlg.", THIS_FUNCTION);
		// canel the options dlg.
		m_optdlg.Cancel();
		return ERROR_ERROR;
		}

	// set the platform if the current one isn't to be used.
	if(intPlatforms != PLATFORM_CURRENT)
		
		{
		// REVIEW (michma): we may want to support setting directories for multiple platforms someday.
		int intActualPlatform = intPlatforms;

		// see if the test wants to use the platform specified by the user.
		if(intPlatforms == PLATFORM_USER)
			intActualPlatform = GetUserTargetPlatforms();

		// get the appropriate index into the platform list.
		int intPlatformIndex = arrayPlatformIndex[GetPowerOfTwo(intActualPlatform)];

		// make sure the specified platform exists.
		if(MST.WComboCount("@1") < intPlatformIndex)
		
			{
			LOG->RecordInfo("%s: could not find platform %d.", THIS_FUNCTION, intPlatformIndex);
		
			// canel the options dlg.
			m_optdlg.Cancel();
			return ERROR_ERROR;
			}

		// set the platform.
		MST.WComboItemClk("@1", intPlatformIndex);	
		}

	// set the directory type if the current one isn't to be used.
	if(dtDirType != DIR_TYPE_CURRENT)
		
		{
		// make sure the specified directory type exists.
		if(MST.WComboCount("@2") < dtDirType)
		
			{
			LOG->RecordInfo("%s: could not find dtDirType %d.", THIS_FUNCTION, dtDirType);
		
			// canel the options dlg.
			m_optdlg.Cancel();
			return ERROR_ERROR;
			}

		// set the directory type.
		MST.WComboItemClk("@2", dtDirType);	
		}
		
	// give focus to the Directories list box (which really isn't a list box so we can't use
	// the MST.WList routines) and select the first item.
	//MST.WComboIteDoKeys("%d{HOME}");
	CString HK = "%" ;
	HK += ExtractHotKey(GetLocString(IDS_DIRECTORIES));
	MST.DoKeys(HK.GetBuffer(HK.GetLength()));
	MST.DoKeys("{HOME}") ;

	return ERROR_SUCCESS;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		BrianCr				09/06/94
//
//	Description :
//		source file that includes just the standard includes
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		BrianCr				09/06/94
//
//	Description :
//		Precompiled header for all of the core MFC files
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\cowrkspc.cpp ===
//////////////////////       CWRKSPCE.CPP
//
//  Created by :            Date :
//      EnriqueP                 1/10/94
//
//  Description :
//      Implementation of the COWorkSpace class
//
#include "stdafx.h"
#include "cowrkspc.h"
#include "..\sym\cmdids.h"
#include "testxcpt.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "uiwbmsg.h"
#include "utoolbar.h"
#include "guiv1.h"
#include "ucustdlg.h"
#include "uwbframe.h"
#include "..\sym\reg.h"
#include "..\sym\dockids.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// REVIEW(briancr): this object is declared as a global for backward compatibility
// REVIEW(briancr): this is just to make things work. Is there a better way to do this?
// instantiate a global COWorkspace
SHL_DATA COWorkSpace WS;

// BEGIN_HELP_COMMENT
// Function: void COWorkSpace::CloseAllWindows(void)
// Description: Close all open windows in the IDE.
// Return: none
// END_HELP_COMMENT
void COWorkSpace::CloseAllWindows(void)
{
UIWB.CloseAllWindows();
}

// BEGIN_HELP_COMMENT
// Function: BOOL COWorkSpace::IsToolbarVisible(UINT id)
// Description: Determine if the toolbar indicated by id is visible. (Use IsDockWindowVisible for dockable windows.)
// Return: TRUE if the toolbar is visible; FALSE if not.
// Param: id The id of the toolbar: IDTB_SUSHI_STANDARD, IDTB_SUSHI_EDIT, IDTB_VRES_RESOURCE, IDTB_VCPP_DEBUG, IDTB_VCPP_BROWSE, IDTB_VRES_DIALOG, IDDW_CONTROLS, IDDW_GRAPHICS, IDDW_COLORS, IDDW_TEXTTOOL, IDTB_VPROJ_BUILD.
// END_HELP_COMMENT
BOOL COWorkSpace::IsToolbarVisible(UINT id)
{
	long pkgId ;
	switch(id)
	{
		case IDTB_SUSHI_STANDARD:
			pkgId = PACKAGE_SUSHI;
			break;
		case IDTB_VCPP_DEBUG:
		case IDTB_VCPP_BROWSE:
			pkgId = PACKAGE_VCPP;
			break ;
		case IDTB_VPROJ_BUILD:
			pkgId = PACKAGE_VPROJ ;
			break ;
		case IDTB_VRES_RESOURCE:
		case IDTB_VRES_DIALOG: 
		case IDDW_CONTROLS:
		case IDDW_GRAPHICS:
		case IDDW_COLORS:
		case IDDW_TEXTTOOL:
			pkgId = PACKAGE_VRES ;
			break ;
		default:
			;
	}
	HWND  hTb = UIWB.GetToolbar(id,pkgId);
	return IsWindowVisible(hTb);
}


// BEGIN_HELP_COMMENT
// Function: BOOL COWorkSpace::IsDockWindowVisible(UINT id)
// Description: Determine if the dockable window indicated by id is visible. (Use IsToolbarVisible for toolbars.)
// Return: TRUE if the dockable window is visible; FALSE if not.
// Param: id The id of the dockable window: IDDW_VCPP_ERROR_WIN, IDDW_VCPP_WATCH_WIN, IDDW_VCPP_LOCALS_WIN, IDDW_VCPP_CPU_WIN, IDDW_VCPP_MEMORY_WIN, IDDW_VCPP_CALLS_WIN, IDDW_VCPP_DISASSY_WIN.
// END_HELP_COMMENT
BOOL COWorkSpace::IsDockWindowVisible(UINT id)
{
	HWND  hDW = UIWB.GetToolbar(id,PACKAGE_VCPP);
	return IsWindowVisible(hDW);
}

// BEGIN_HELP_COMMENT
// Function: int COWorkSpace::ShowToolbar(UINT id, BOOL bShow /*=TRUE*/)
// Description: Show or hide the toolbar indicated by id. (Use this function to show or hide dockable windows, also.)
// Return: TRUE if the toolbar is successfully shown (or hidden); FALSE otherwise.
// Param: id The id of the toolbar or dockable window: IDTB_SUSHI_STANDARD, IDTB_SUSHI_EDIT, IDTB_VRES_RESOURCE, IDTB_VCPP_DEBUG, IDTB_VCPP_BROWSE, IDTB_VRES_DIALOG, IDDW_CONTROLS, IDDW_GRAPHICS, IDDW_COLORS, IDDW_TEXTTOOL, IDTB_VPROJ_BUILD, IDDW_VCPP_ERROR_WIN, IDDW_VCPP_WATCH_WIN, IDDW_VCPP_LOCALS_WIN, IDDW_VCPP_CPU_WIN, IDDW_VCPP_MEMORY_WIN, IDDW_VCPP_CALLS_WIN, IDDW_VCPP_DISASSY_WIN.
// Param: bShow TRUE to show the toolbar or window; FALSE to hide it. (Default is TRUE.)
// END_HELP_COMMENT
int COWorkSpace::ShowToolbar(UINT id, BOOL bShow /*=TRUE*/)	  //	REVIEW(enriquep): Use enum for id
{
	UIToolbar uiTB;
	return uiTB.ShowTB(id, bShow);
}		

//int COWorkSpace::ShowDockWindow(UINT id, BOOL bShow /*=TRUE*/)
/*{
	UIDockWindow* pudw;
	switch( id )
	{
		case IDW_OUTPUT_WIN:
			pudw = new UIOutput;
			break;
		case IDW_WATCH_WIN:
			pudw = new UIWatch;
			break;
		case IDW_LOCALS_WIN:
			pudw = new UILocals;
			break;
		case IDW_CPU_WIN:
			pudw = new UIRegisters;
			break;
		case IDW_MEMORY_WIN:
			pudw = new UIMemory;
			break;
		case IDW_CALLS_WIN:
			pudw = new UICallStack;
			break;
		case IDW_DISASSY_WIN:
			pudw = new UIDisassembly;
			break;
		default:
			ASSERT(FALSE);		// never heard of that ID
			return NULL;
	}
	BOOL b = pudw->Activate();
	delete pudw;
	if( !b )					// attempt to show failed - who knows why
		return NULL;
	if( bShow )					// window was activated and has the focus
		return MST.WGetFocus();
	DoKeys("+{escape}");		// shift escape hides the active docking-window/toolbar
	return NULL;				// should we return newly active window?
}	  
*/

// BEGIN_HELP_COMMENT
// Function: BOOL COWorkSpace::IsWindowDocked(UINT id, int nLocation)
// Description: Determine if the dockable window indicated by id is docked. (Use IsToolbarDocked for toolbars.)
// Return: TRUE if the dockable window is docked; FALSE otherwise.
// Param: id The id of the dockable window: IDDW_VCPP_ERROR_WIN, IDDW_VCPP_WATCH_WIN, IDDW_VCPP_LOCALS_WIN, IDDW_VCPP_CPU_WIN, IDDW_VCPP_MEMORY_WIN, IDDW_VCPP_CALLS_WIN, IDDW_VCPP_DISASSY_WIN.
// Param: nLocation The location of the dockable window: DW_TOP, DW_BOTTOM, DW_LEFT, DW_RIGHT.
// END_HELP_COMMENT
BOOL COWorkSpace::IsWindowDocked(UINT id, int nLocation)   // (enriquep)	 REVIEW: Use enum for id
{
	HWND hWnd = UIWB.GetToolbar(id,PACKAGE_VCPP);
	UIToolbar uiDW;
	return uiDW.IsDocked(hWnd, nLocation); 	//REVIEW: (enriquep) we use the UIToolbar version for now
} 	

// BEGIN_HELP_COMMENT
// Function: BOOL COWorkSpace::IsToolbarDocked(UINT id, int nLocation)
// Description: Determine if the toolbar indicated by id is docked. (Use IsWindowDocked for dockable windows.)
// Return: TRUE if the toolbar is docked; FALSE otherwise.
// Param: id The id of the toolbar: IDTB_SUSHI_STANDARD, IDTB_SUSHI_EDIT, IDTB_VRES_RESOURCE, IDTB_VCPP_DEBUG, IDTB_VCPP_BROWSE, IDTB_VRES_DIALOG, IDDW_CONTROLS, IDDW_GRAPHICS, IDDW_COLORS, IDDW_TEXTTOOL, IDTB_VPROJ_BUILD.
// Param: nLocation The location of the toolbar: DW_TOP, DW_BOTTOM, DW_LEFT, DW_RIGHT.
// END_HELP_COMMENT
BOOL COWorkSpace::IsToolbarDocked(UINT id, int nLocation)   // (enriquep)	 REVIEW: Use enum for id
{
	long pkgId ;
	switch(id)
	{
		case IDTB_SUSHI_STANDARD:
			pkgId = PACKAGE_SUSHI;
			break;
		case IDTB_VCPP_DEBUG:
		case IDTB_VCPP_BROWSE:
			pkgId = PACKAGE_VCPP;
			break ;
		case IDTB_VPROJ_BUILD:
			pkgId = PACKAGE_VPROJ ;
			break ;
		case IDTB_VRES_RESOURCE:
		case IDTB_VRES_DIALOG: 
		case IDDW_CONTROLS:
		case IDDW_GRAPHICS:
		case IDDW_COLORS:
		case IDDW_TEXTTOOL:
			pkgId = PACKAGE_VRES ;
			break ;
		default: ;
	}

	HWND hWnd = UIWB.GetToolbar(id,pkgId);
	UIToolbar uiTB;
	return uiTB.IsDocked(hWnd, nLocation); 	
}    


// BEGIN_HELP_COMMENT
// Function: BOOL COWorkSpace::ShowPropPage(BOOL bShow)
// Description: Display or hide the property page for the currently active window.
// Return: TRUE if the property page is successfully shown (or hidden); FALSE otherwise.
// Param: bShow TRUE to show the property page; FALSE to hide it.
// END_HELP_COMMENT
BOOL COWorkSpace::ShowPropPage(BOOL bShow)
{
	if( !IsWindowActive("Properties") )
		DoKeys("%{ENTER}");		//Give Focus to PropPage REVIEW:Use SetFocus() when hook is available
	if( bShow == FALSE )
		DoKeys("+{ESC}");		// Hide it 	
	return TRUE;
}

/*CString COWorkSpace::GetProperty(int nProp)
{
	CString str = "Empty Property";
	ATOM atom = (ATOM)UIWB.PWnd()->SendMessage( m_msgGetProp, nProp);
	if (atom != 0)
	{
		UINT ret = GlobalGetAtomName( atom, str.GetBufferSetLength(MAX_ATOM_LENGTH), MAX_ATOM_LENGTH );
		ret = GlobalDeleteAtom(atom);	// this atom created by the Workbench
		str.ReleaseBuffer(-1);
	}
 	return str;
}	 */


/*HWND COWorkSpace::GetStatusBar(void)
{
    HWND hwnd = ::GetWindow(UIWB.HWnd(), GW_CHILD);
    char acClass[128];
    ::GetClassName(hwnd, acClass, 127);
    while( (hwnd != NULL) && strcmp(acClass, "AfxControlBar") ) // REVIEW(davidga): move to #define
    {
        hwnd = ::GetWindow(hwnd, GW_HWNDNEXT);
        ::GetClassName(hwnd, acClass, 127);
    }
    return hwnd;    // will be Statusbar or NULL
}							*/

// BEGIN_HELP_COMMENT
// Function: CString COWorkSpace::GetStatusText(void)
// Description: Get the text from the IDE's status bar.
// Return: A CString containing the text in the status bar.
// END_HELP_COMMENT
CString COWorkSpace::GetStatusText(void)
{
    HWND hwnd = UIWB.GetStatusBar();
    return ::GetText(hwnd);
}

// BEGIN_HELP_COMMENT
// Function: BOOL COWorkSpace::WaitForStatusText(LPCSTR sz, DWORD dwMilliSeconds, BOOL bExact /*=TRUE*/)
// Description: Wait for the given text (sz) to appear in the status bar. This function will wait until the text is displayed in the status bar or the number of milliseconds given in dwMilliSeconds have elapsed.
// Return: TRUE if the text is found in the status bar before dwMilliSeconds elapses; FALSE otherwise.
// Param: sz A pointer to a string containing the text to wait for in the status bar.
// Param: dwMilliSeconds The number of milliseconds to wait for the text to appear.
// Param: bExact TRUE if the text in status bar must match the text in sz exactly; FALSE for a partial patch.
// END_HELP_COMMENT
BOOL COWorkSpace::WaitForStatusText(LPCSTR sz, DWORD dwMilliSeconds, BOOL bExact /*=TRUE*/)
{
    DWORD dwDone = 0;
    while( dwDone <= dwMilliSeconds )
    {
        CString strStatus = GetStatusText();
        if( bExact )
        {
            if( strStatus == sz )
                return TRUE;
        }
        else
        {
            if( strStatus.Find(sz) == 0 )   // check first part of string
                return TRUE;
        }
        
        if( dwDone >= dwMilliSeconds )  // no more waiting
            return FALSE;       // just say we didn't find it

        DWORD dwSleep = dwMilliSeconds - dwDone >= 1000 ? 1000 : dwMilliSeconds - dwDone;
        Sleep(dwSleep);     // wait another second (or whatever's left)
        dwDone += dwSleep;  // and try at least one more time
    }
    return FALSE;       // should never get hit
}

// REVIEW: larryh - When this CAN work, it needs to be fixed TO work.

// BEGIN_HELP_COMMENT
// Function: BOOL COWorkSpace::VerifyCaretPosition( int nRow, int nCol, LPCSTR szErrTxt )
// Description: Verify the caret position in the active window.
// Return: TRUE if the caret position matches the given row and column; FALSE otherwise.
// Param: nRow The expected row for the caret.
// Param: nCol The expected column for the caret.
// Param: szErrTxt A pointer to a string containing the text to emit to log if the caret position doesn't match the given row and column.
// END_HELP_COMMENT
BOOL COWorkSpace::VerifyCaretPosition( int nRow, int nCol, LPCSTR szErrTxt )
{
    char szBuffer[80];

	EXPECT( nRow >= 0 && nCol >= 0 );
	wsprintf( szBuffer, "Ln %d,Col %d", nRow, nCol );
		
	if (UIWB.WaitForStatusText( szBuffer, (DWORD) 5000 /* 5 seconds */, TRUE ) )
		return TRUE;
	LOG->Comment( "VerifyCaretPosition: ",szErrTxt,": expected ",szBuffer," <> status bar column ",UIWB.GetStatusText() );
	return FALSE;
}

//BOOL COWorkSpace::AddTBButton(int nButtonType, HWND hwndToolbar /* = NULL */)
/*{
    EXPECT( IsWindowActive("Customize") );		//REVIEW: Verify Toolbars tab is set as well
    UIDialog uDlg;   // REVIEW(davidga): when UICustDlg is implemented, you can use ExpectValid instead
    uDlg.AttachActive();
        
    if ( hwndToolbar != NULL)                               // Put button in a toolbar else create new toolbar
    {                               
        EXPECT( IsWindowVisible(hwndToolbar) );

        DragMouse(VK_LBUTTON, uDlg, 155, 70, hwndToolbar, 2, 2);     //REVIEW: Button position is hardcoded
    }
    else
    {
        DragMouse(VK_LBUTTON, uDlg, 155, 70, UIWB.HWnd(), 2, 2);
    }

    return TRUE;
}		  */

// BEGIN_HELP_COMMENT
// Function: COWorkSpace::AddTool(CString strMenuText, CString strToolPath, CString strArguments, CString strInitDir, BOOL PromptArguments, BOOL RedirectOutput, BOOL CloseOnExit);
// Description: Add a Tool to the Tools menu.
// Return: TRUE if successful; FALSE otherwise.
// Param: strToolPath The complete drive, path, and executable file name
// Param: strArguments Any arguments to be passed to the tool on startup
// Param: strInitDir Initial Directory
// Param: strMenuText Name and shortcut to appear on tools menu
// Param: PromptArgument Check Prompt for Arguments box
// Param: RedirectOutput Check Redirect to Output Window
// Param: CloseOnExit Check Close Window on Exit
// END_HELP_COMMENT
BOOL COWorkSpace::AddTool(CString strMenuText,  
						  CString strToolPath, // full path for command name
	 					  CString strArguments,
	 					  CString strInitDir,
	 					  BOOL PromptArgument,
 						  BOOL RedirectOutput,
						  BOOL CloseOnExit)
{
	// To use ShowPage
	UICustomizeTabDlg CustomizeTools;
// WARNING: Due to a bug in MS Test, shortcut keys added with this function that
// conflict with Tools.Customize.Tools shortcuts will be sidetracked by going to
// the shortcuts for the menu. DO NOT add &C A N M I W P E O C R U D H 
	CustomizeTools.ShowPage(TAB_TOOLS,3);	// Tools.Customize.Tools
	MST.WButtonClick(GetLabel(VSHELL_ID_TOOLS_ADD));						// select Add
	MST.DoKeys(strToolPath);
	MST.DoKeys("{ENTER}");					// OK for path
	MST.WEditSetText(GetLabel(VSHELL_ID_TOOLS_ARGUMENTS),strArguments);			// select arguments
	MST.WEditSetText(GetLabel(VSHELL_ID_TOOLS_MENUTEXT),strMenuText);
	MST.WEditSetText(GetLabel(VSHELL_ID_TOOLS_STAT_INITDIR),strInitDir);
	if (RedirectOutput)	MST.WCheckCheck(GetLabel(VSHELL_ID_TOOLS_REDIRECT));					
	if (PromptArgument) MST.WCheckCheck(GetLabel(VSHELL_ID_TOOLS_ASKARGUMENTS));		
	if (CloseOnExit)	MST.WCheckCheck(GetLabel(VSHELL_ID_TOOLS_CLOSE));			
	MST.DoKeys("{ENTER}");					// OK for whole dialog

	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: COWorkSpace::DeleteTool(int Number)
// Description: Delete a number of Tools from the Tools menu
// Return: TRUE if successful; FALSE otherwise.
// Param: int Number Number of tools to delete
// END_HELP_COMMENT
BOOL COWorkSpace::DeleteTools(int Number)
{  // REVIEW GEORGECH this must be more robust - as when &Remove is not enabled
	int i;
	// To use ShowPage
	UICustomizeTabDlg CustomizeTools;

	CustomizeTools.ShowPage(TAB_TOOLS,3);		// Tools.Customize
	MST.WListItemClk(GetLabel(VSHELL_ID_TOOLS_MENUCONTENTS),1);				// Menu &Contents	
	for (i=0;i<Number;i++)
		MST.WButtonClick(GetLabel(VSHELL_ID_TOOLS_DELETE));			// &Remove	

	MST.DoKeys("{ENTER}");			// OK close menu	

	return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\newfldlg.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UITABDLG.CPP
//
//  Created by :            Date :
//      EnriqueP              1/27/94
//				  
//  Description :
//      Implementation of the UIOptionTabDialog class
//

#include "stdafx.h"
#include "mstwrap.h"
#include "guiv1.h"
#include "..\sym\cmdids.h"
#include "..\sym\vproj.h"
#include "uiwbmsg.h"
#include "..\sym\vshell.h"
#include "uwbframe.h"
#include "newfldlg.h"
#include "..\..\imewrap.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: HWND UINewFileDlg::Display() 
// Description: Bring up the New File tabbed dialog.
// Return: The HWND of the New File tabbed dialog.
// END_HELP_COMMENT
HWND UINewFileDlg::Display() 
{	
	AttachActive();		  // Check if is already up
	if (!IsValid())
	{
	 //MST.DoKeys("%fe") ;
	 UIWB.DoCommand(ID_FILE_NEW, DC_ACCEL);
//	 MST.WFndWnd("New",FW_CASE | FW_FOCUS | FW_HIDDENNOTOK);
	 WaitAttachActive(10000);
	}
	return WGetActWnd(0); 
}

// BEGIN_HELP_COMMENT
// Function: HWND UINewFileDlg::ChangeCompatility() 
// Description: Display the compatibility tab of the options dialog.
// Return: int
// END_HELP_COMMENT

int UINewFileDlg::SetName(CString Name, int DocType /* PROJECTS*/ )
{
	MST.WEditSetText(GetLabel(DocType),Name) ;
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: int UINewFileDlg::SetLocation(CString szLocation)
// Description: Sets the path for the new document/project being created.
// Return: ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szLocation a string containing the path
// END_HELP_COMMENT
			
int UINewFileDlg::SetLocation(CString szLocation, int DocType /* PROJECTS*/)
{
	switch (DocType)
	{
	case FILES:
		{
		 DocType = VSHELL_IDC_LOCATIONFORFILE;
		 break ;
		}

	case OTHER:
		{
		 DocType = VSHELL_IDC_LOCATIONFOROTHERFILE;
		 break ;
		}

	case PROJECTS:
		 {
		 DocType = VSHELL_IDC_LOCATIONFORPROJECT;
		 break ;
		 }

	case TEMPLATES:
		{
		 DocType = VSHELL_IDC_LOCATIONFORTEMPLATE;
		 break ;
		}

	case WORKSPACE:
	{
		 DocType = VSHELL_IDC_LOCATIONFORWORKSPACE;
		 break ;
	}
	
	default:
		LOG->RecordInfo("%d : Unknown document type passed to UINewFileDlg::SetLocation()", DocType);
	}
	MST.WEditSetText(GetLabel(DocType), szLocation) ;
	return ERROR_SUCCESS;

}

int UINewFileDlg::SelectFromList(CString ItemName)	 
{
//	MST.DoKeys("{DOWN}") ;
//	UINT ime_mode ;
//	if(IME.IsIMEInUse())					
//	{
//		ime_mode = IME.GetMode();
//		IME.SetMode();
//		IME.Open(FALSE);
//	}

	// we need the TRUE so that ItemName is interpreted literally.
	// this allows for correct selection of names with special
	// ms-test characters, like "MFC AppWizard (exe)", etc.
//	MST.DoKeys(ItemName, TRUE) ;
//	if(IME.IsIMEInUse())					
//	{
//		IME.Open();
//		IME.SetMode(ime_mode);
//	}
//
	MST.WViewSetFocus("@1");
	if(!MST.WViewItemExists("@1", ItemName))
		return FALSE;
	MST.WViewItemClk("@1", ItemName);

	return TRUE ;
}

int UINewFileDlg::SelectFromList(int Index)	 
{
	MST.DoKeys("{DOWN}") ;
//UINT ime_mode = IME.GetMode();
//IME.Open(FALSE);
	MST.WListItemClk("",Index) ;
//IME.Open();
//IME.SetMode(ime_mode);
	return TRUE ;
}


int UINewFileDlg::NewFileTab()
{
	ShowPage(FILES, 5) ;
	return ERROR_SUCCESS ;
}
int UINewFileDlg::NewProjectTab()
{
	ShowPage(PROJECTS, 5) ;
	return ERROR_SUCCESS ;
}

int UINewFileDlg::NewTemplateTab()
{
	ShowPage(TEMPLATES, 5) ;
	return ERROR_SUCCESS ;
}

int UINewFileDlg::NewWorkspaceTab(){
	ShowPage(WORKSPACE, 5) ;
	return ERROR_SUCCESS ;
}

int UINewFileDlg::NewOtherTab()
{
	ShowPage(OTHER, 5) ;
	return ERROR_SUCCESS ;
}

HWND UINewFileDlg::OK()
{
	MST.WButtonClick(GetLabel(IDOK));
	WaitUntilGone(1000);
	return MST.WGetActWnd(0);

}

void UINewFileDlg::SetProjPlatform(CString Platform)
{
	if(MST.WListItemExists(GetLabel(VSHELL_IDC_PLATFORMS ), GetLocString(IDSS_PLATFORM_WIN32)))
	{
		MST.WListItemClk(GetLabel(VSHELL_IDC_PLATFORMS ), GetLocString(IDSS_PLATFORM_WIN32));
		Sleep(500);
		MST.DoKeys(" ");
	}
}


int UINewFileDlg::AddToProject(BOOL bAdd)
{

	CString strAddToProjectCheckBox = GetLocString(IDSS_ADD_TO_PROJECT);
	
	if(!MST.WCheckEnabled(strAddToProjectCheckBox))
	{
		LOG->RecordInfo("ERROR! UINewFileDlg::AddToProject - "
						"Check box '%s' is not enabled", strAddToProjectCheckBox);
		return ERROR_ERROR;

	}

	if(bAdd)
		MST.WCheckCheck(strAddToProjectCheckBox);
	else
		MST.WCheckUnCheck(strAddToProjectCheckBox);

	return ERROR_SUCCESS;
}


int UINewFileDlg::SetProject(LPCSTR szProject)
{

	if(!MST.WComboEnabled("@1"))
	{
		LOG->RecordInfo("ERROR! UINewFileDlg::SetProject - The project combo box is not enabled");
		return ERROR_ERROR;
	}

	if(!MST.WComboItemExists("@1", szProject))
	{
		LOG->RecordInfo("ERROR! UINewFileDlg::SetProject - "
						"Cannot find project '%s' in the project combo box", szProject);
		return ERROR_ERROR;
	}

	MST.WComboItemClk("@1", szProject);
	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\cowrkspc.h ===
///////////////////////////////////////////////////////////////////////////////
//  CWRKSPCE.H
//
//  Created by :            Date :
//      EnriqueP                 1/7/94
//
//  Description :
//      Declaration of the COWorkSpace class
//

#ifndef __CWRKSPCE_H__
#define __CWRKSPCE_H__

#include "..\..\uwindow.h"

#include "shlxprt.h"

#ifndef __UIWINDOW_H__
    #error include 'uwindow.h' before including this file
#endif


///////////////////////////////////////////////////////////////////////////////
//  COWorkSpace class

// BEGIN_CLASS_HELP
// ClassName: COWorkSpace
// BaseClass: none
// Category: Shell
// END_CLASS_HELP
class SHL_CLASS COWorkSpace 
{
// Attributes

// Data
private:
    
// Generic Utilities
public:
    

//Utilities
public:
	void CloseAllWindows(void);
	BOOL IsToolbarVisible(UINT id);
	BOOL IsDockWindowVisible(UINT id);
//  int ShowDockWindow(UINT id, BOOL bShow = TRUE);
	int ShowToolbar(UINT id, BOOL bShow = TRUE);
	BOOL IsWindowDocked(UINT id, int nLocation = 0x000F /*DW_DONT_CARE*/); // REVIEW:(EnriqueP)Use enum value for ID
	BOOL IsToolbarDocked(UINT id, int nLocation = 0x000F /*DW_DONT_CARE*/);
	CString GetStatusText(void);
    BOOL WaitForStatusText(LPCSTR sz, DWORD dwMilliSeconds, BOOL bExact = TRUE);
	BOOL VerifyCaretPosition( int nRow, int nCol, LPCSTR szErrTxt );
	BOOL ShowPropPage(BOOL bShow);    //REVIEW: add param to push pin if this feature stays

// Added Feb 22,95 GeorgeCh
	BOOL AddTool(CString strMenuText,  
				 CString strToolPath, // full path for command name
				 CString strArguments,
				 CString strInitDir,
				 BOOL PromptArgument,
 				 BOOL RedirectOutput,
				 BOOL CloseOnExit);
	BOOL DeleteTools(int Number);
   
//  Not Yet Implemented
//	BOOL DockWindowAt(HWND hWnd, int nLocation = PREV, BOOL bDock = TRUE);
//  BOOL MoveWindow( HWND hWnd, POINT point);
//	BOOL MakeViewDockable(int nViewID, BOOL bDockable = TRUE);

//  CString GetProperty(int nProp);

};

// REVIEW(briancr): this object is declared as a global for backward compatibility
// REVIEW(briancr): this is just to make things work. Is there a better way to do this?
extern SHL_DATA COWorkSpace WS;

///////////////////////////////////////////////////////////////////////////////
// COWorkSpace #defines
// Position values used for IsWindowDocked() and DockWindowAt()
/*#define DW_TOP					0x0001
#define DW_BOTTOM				0x0002
#define DW_LEFT					0x0004
#define DW_RIGHT				0x0008
#define DW_DONT_CARE		   	0x000F */



 
#endif //__CWRKSPCE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\evnthdlr.cpp ===
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	evnthdlr.cpp

	Author: Sean Christofferson (t-seanc)

	24 July 1997 - Created

	CEventHandler implments a COM object that handles events from the Developer Studio
	IApplicationEvents connection point.  It currently does not handle the debugger 
	events.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Precompiled header
#include "StdAfx.h"

// Project includes
#define INITGUID
#include "evnthdlr.h"

// Global HRESULT
HRESULT hres;

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
CEventHandler::CEventHandler()
{
	// Initialize COM for multithreading
//	VERIFY_OK(CoInitializeEx(NULL, COINIT_MULTITHREADED));
	VERIFY_OK(CoInitialize(NULL)); //REVIEW(chriskoz): I don't believe we need free threaded model here
	// Reset the reference count to one since we are passing out a pointer
	m_cRef = 1;

	// Set up the events
	m_hevntBuildFinish		= CreateEvent(NULL, TRUE, FALSE, "Build Finish");
	m_hevntBuildStart		= CreateEvent(NULL, TRUE, FALSE, "Build Start");	
	m_hevntAppShutdown		= CreateEvent(NULL, TRUE, FALSE, "Application Shutdown");
	m_hevntDocOpen			= CreateEvent(NULL, TRUE, FALSE, "Document Open");
	m_hevntDocClose			= CreateEvent(NULL, TRUE, FALSE, "Document Close");
	m_hevntDocSave			= CreateEvent(NULL, TRUE, FALSE, "Document Save");
	m_hevntNewDoc			= CreateEvent(NULL, TRUE, FALSE, "New Document");
	m_hevntWndActivate		= CreateEvent(NULL, TRUE, FALSE, "Window Activate");
	m_hevntWndDeactivate	= CreateEvent(NULL, TRUE, FALSE, "Window Deactivate");
	m_hevntWorkspaceOpen	= CreateEvent(NULL, TRUE, FALSE, "Workspace Opened");
	m_hevntWorkspaceClose	= CreateEvent(NULL, TRUE, FALSE, "Workspace Closed");
	m_hevntNewWorkspace		= CreateEvent(NULL, TRUE, FALSE, "New Workspace");

	// Set the interfaces to NULL to indicate the event handler is disconnected
	m_pICP = NULL;
	m_pApp = NULL;
	m_pDbg = NULL;
	m_dwConnectionID=0;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
CEventHandler::~CEventHandler()
{
	// Uninitialize COM
	CoUninitialize();

	// Destroy the events
	CloseHandle(m_hevntBuildFinish);
	CloseHandle(m_hevntBuildStart);
	CloseHandle(m_hevntAppShutdown);
	CloseHandle(m_hevntDocOpen);
	CloseHandle(m_hevntDocClose);
	CloseHandle(m_hevntDocSave);
	CloseHandle(m_hevntNewDoc);
	CloseHandle(m_hevntWndActivate);
	CloseHandle(m_hevntWndDeactivate);
	CloseHandle(m_hevntWorkspaceOpen);
	CloseHandle(m_hevntWorkspaceClose);
	CloseHandle(m_hevntNewWorkspace);
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
#include "guiv1.h" //for god damn global CLog object, I don't have time to remove them here
void CEventHandler::Connect(BOOL isDebug)
{//TODO: better HRESULT handling (throwing excepctions?)
	IUnknown*					pIUnknown=NULL;
	IConnectionPointContainer*	pICPC=NULL;

	// Get the MsDev object if we can, otherwise, fail
	// emmang@xbox - at xbox, we dont have access to debug builds of msdev
	// hres=GetActiveObject(isDebug?CLSID_DebugApp:CLSID_Application, NULL, &pIUnknown);
	hres=GetActiveObject(CLSID_Application, NULL, &pIUnknown);
	VERIFY_OK(hres);
	if(FAILED(hres) || pIUnknown==NULL)//REVIEW(chriskoz): god damn globals, I don't have time to remove them here
	{
		gpLog->RecordInfo("WARNING: Error accessing object model: %08lx", hres);
		return;
	}
#if 0 //REVIEW(chriskoz) events should be on separate thread. Otherwise "server busy" dialog pops up when test thread is stopped
	// Get an IConnectionPointContainer interface
	hres = pIUnknown->QueryInterface(
		IID_IConnectionPointContainer, 
		(void**)&pICPC
		);
	VERIFY_OK(hres);

	// Find the connection point supporting the IApplicationEvents interface
	hres = pICPC->FindConnectionPoint(
		IID_IApplicationEvents,
		&m_pICP
		);
	VERIFY_OK(hres);

	// Connect to the connection point
	VERIFY_OK(m_pICP->Advise(this, &m_dwConnectionID));
	pICPC->Release();
#endif
	VERIFY_OK(pIUnknown->QueryInterface(IID_IApplication, (void**)&m_pApp));
	pIUnknown->Release();
	pIUnknown = NULL; // emmang@xbox

	if(FAILED(hres) || m_pApp==NULL)//REVIEW(chriskoz): god damn globals, I don't have time to remove them here
	{
		// REVIEW(michma - 3/24/99): for some reason this is failing but we don't want it to cause a failure
		// in the test results. so we'll just log an error for now.
		//gpLog->RecordFailure("Error accessing IApplication object: %08lx", hres);
		gpLog->RecordInfo("ERROR accessing IApplication object: %08lx", hres);
		return;
	}

	m_pDbg = NULL;

	// when debugging a test we need to disable use of the debugger's object model by cafe.
	// otherwise any stepping operations in the target debugger will hang up cafe in the host debugger.

	// xbox - IID_Debugger->get_State() is bad
	// if (!CMDLINE->GetBooleanValue("NoDbgObjectModel", FALSE))
	if (0)
	{
		VERIFY_OK(m_pApp->get_Debugger((IDispatch**)&pIUnknown));
		if(!FAILED(hres) && pIUnknown!=NULL)
			hres=pIUnknown->QueryInterface(IID_IDebugger, (void**)&m_pDbg);
		VERIFY_OK(hres);
		if(FAILED(hres) || m_pDbg==NULL)//REVIEW(chriskoz): god damn globals, I don't have time to remove them here
			gpLog->RecordFailure("Error accessing IDebugger from object model: %08lx", hres);
	}

	if(pIUnknown)
		pIUnknown->Release();
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void CEventHandler::Disconnect()
{
	// Disconnect and release all interfaces
	if(m_dwConnectionID!=0)
		VERIFY_OK(m_pICP->Unadvise(m_dwConnectionID));
	m_dwConnectionID=0;
	// Release the connection point & debugger
	if(m_pDbg){m_pDbg->Release();m_pDbg=NULL;}
	if(m_pApp){m_pApp->Release();m_pApp=NULL;}
	if(m_pICP){m_pICP->Release();m_pICP=NULL;}
	// DevStudio needs a little bit of time to become stable after disconnecting
	// If you start getting random AVs on the shutdown of MsDev, you might want
	// to try increasing this delay.
	Sleep(3000); //REVIEW(chriskoz): really such a problem? I disabled the events anyway in Connect().
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
HRESULT __stdcall CEventHandler::QueryInterface
	(
	const IID& iid, 
	void** ppv
	)

	{
	// Return the appropriate interface pointer
	if(iid == IID_IUnknown)
		{
		*ppv = static_cast<IApplicationEvents*>(this);
		}
	else if(iid == IID_IDispatch)
		{
		*ppv = static_cast<IDispatch*>(this);
		}
	else if(iid == IID_IApplicationEvents)
		{
		*ppv = static_cast<IApplicationEvents*>(this);
		}
	else
		{
		// Set the interface pointer to NULL and return an error
		*ppv = NULL;
		return E_NOINTERFACE;
		}

	static_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
ULONG __stdcall CEventHandler::AddRef()
	{
	// Increment the reference count
	InterlockedIncrement(&m_cRef);

	return m_cRef;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
ULONG __stdcall CEventHandler::Release()
	{
	// Decrement the reference count and die if it gets to zero
	if(InterlockedDecrement(&m_cRef) == 0)
		{
		delete this;
		return 0;
		}

	return m_cRef;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	IDispatch Implementation

	This implementation DOES NOT WORK.  It is just here because IApplicationEvents 
	inherits from it.
	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
HRESULT __stdcall CEventHandler::GetIDsOfNames(
	const IID&		iid,
	OLECHAR**		szNames, 
	unsigned int	cNames, 
	LCID			lcid, 
	DISPID*			rgDispId
	)

	{
	return E_FAIL;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
HRESULT  __stdcall CEventHandler::GetTypeInfo(
	unsigned int,
	LCID,
	ITypeInfo**
	)

	{
	return E_FAIL;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
HRESULT __stdcall CEventHandler::GetTypeInfoCount(
	unsigned int*
	)

	{
	return E_FAIL;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
HRESULT __stdcall CEventHandler::Invoke(
	DISPID,
	REFIID,
	LCID,
	WORD,
	DISPPARAMS*,
	VARIANT*,
	EXCEPINFO*,
	unsigned int*
	)

	{
	return E_FAIL;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Event handler functions

	I have used PulseEvent to signal the events by default which should work for
	most events.  If more complicated signaling logic is needed, SetEvent/ResetEvent
	pairs can be used, as they are in BuildFinish.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
HRESULT __stdcall CEventHandler::BeforeBuildStart()
	{
	// In case there was a lingering build finish event set
	ResetEvent(m_hevntBuildFinish);
		
	// Signal the start of a build
	SetEvent(m_hevntBuildStart);
	return S_OK;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
HRESULT __stdcall CEventHandler::BuildFinish(long nNumErrors, long nNumWarnings)
	{
	// Signal the end of a build
	SetEvent(m_hevntBuildFinish);

	return S_OK;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
HRESULT __stdcall CEventHandler::BeforeApplicationShutDown()
	{
	PulseEvent(m_hevntAppShutdown);
	return S_OK;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
HRESULT __stdcall CEventHandler::DocumentOpen(IDispatch* theDocument)
	{
	PulseEvent(m_hevntDocOpen);
	return S_OK;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
HRESULT __stdcall CEventHandler::BeforeDocumentClose(IDispatch* theDocument)
	{
	PulseEvent(m_hevntDocClose);
	return S_OK;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
HRESULT __stdcall CEventHandler::DocumentSave(IDispatch* theDocument)
	{
	PulseEvent(m_hevntDocSave);
	return S_OK;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
HRESULT __stdcall CEventHandler::NewDocument(IDispatch* theDocument)
	{
	PulseEvent(m_hevntNewDoc);
	return S_OK;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
HRESULT __stdcall CEventHandler::WindowActivate(IDispatch* theWindow)
	{
	PulseEvent(m_hevntWndActivate);
	return S_OK;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
HRESULT __stdcall CEventHandler::WindowDeactivate(IDispatch* theWindow)
	{
	PulseEvent(m_hevntWndDeactivate);
	return S_OK;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
HRESULT __stdcall CEventHandler::WorkspaceOpen()
	{
	PulseEvent(m_hevntWorkspaceOpen);
	return S_OK;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
HRESULT __stdcall CEventHandler::WorkspaceClose()
	{
	PulseEvent(m_hevntWorkspaceClose);
	return S_OK;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
HRESULT __stdcall CEventHandler::NewWorkspace()
	{
	PulseEvent(m_hevntNewWorkspace);
	return S_OK;
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Wait functions

	Adding extra delays in these functions is sometimes necessary in order to allow
	things to become stable.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void CEventHandler::WaitForBuildStart()
	{
	// Collect threads here until the Build Start event is set
	WaitForSingleObjectEx(m_hevntBuildStart, INFINITE, FALSE);
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
bool CEventHandler::WaitForBuildFinish(int TimeoutInMinutes)
	{
	// Collect threads here until the Build Finish event is set
	DWORD dwResult = WaitForSingleObjectEx(
		m_hevntBuildFinish, 
		TimeoutInMinutes * 60 * 1000,  // Convert the timeout interval to milliseconds
		FALSE
		);
	ResetEvent(m_hevntBuildFinish);
	
	// Wait for everything to become consistent
	Sleep(2000);
	
	// If there was a timeout, return an error
	if(dwResult == WAIT_FAILED && GetLastError() == WAIT_TIMEOUT)
		{
		return false;
		}
	else
		{
		return true;
		}
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void CEventHandler::WaitForApplicationShutDown()
	{
	// Collect threads here until the Application Shutdown event is set
	WaitForSingleObjectEx(m_hevntAppShutdown, INFINITE, FALSE);
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void CEventHandler::WaitForDocumentOpen()
	{
	// Collect threads here until the Open Document event is set
	WaitForSingleObjectEx(m_hevntDocOpen, INFINITE, FALSE);
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void CEventHandler::WaitForDocumentClose()
	{
	// Collect threads here until the Close Document event is set
	WaitForSingleObjectEx(m_hevntDocClose, INFINITE, FALSE);
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void CEventHandler::WaitForDocumentSave()
	{
	// Collect threads here until Save Document is set
	WaitForSingleObjectEx(m_hevntDocSave, INFINITE, FALSE);
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void CEventHandler::WaitForNewDocument()
	{
	// Collect threads here until New Document is set
	WaitForSingleObjectEx(m_hevntNewDoc, INFINITE, FALSE);
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void CEventHandler::WaitForWindowActivate()
	{
	// Collect threads here until Active Window is set
	WaitForSingleObjectEx(m_hevntWndActivate, INFINITE, FALSE);
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void CEventHandler::WaitForWindowDeactivate()
	{
	// Collect threads here until Deactivate Window is set
	WaitForSingleObjectEx(m_hevntWndDeactivate, INFINITE, FALSE);
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void CEventHandler::WaitForWorkspaceOpen()
	{
	// Collect threads here until Open Workspace is set
	WaitForSingleObjectEx(m_hevntWorkspaceOpen, INFINITE, FALSE);
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void CEventHandler::WaitForWorkspaceClose()
	{
	// Collect threads here until Close Workspace is set
	WaitForSingleObjectEx(m_hevntWorkspaceClose, INFINITE, FALSE);
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void CEventHandler::WaitForNewWorkspace()
	{
	// Collect threads here until New Workspace is set
	WaitForSingleObjectEx(m_hevntNewWorkspace, INFINITE, FALSE);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\shl.cpp ===
/////////////////////////////////////////////////////////////////////////////
// shl.cpp
//
// email	date		change
// briancr	01/11/95	created
//
// copyright 1994 Microsoft

#include "stdafx.h"
#include "afxdllx.h"

#define new DEBUG_NEW

///////////////////////////////////////////////////////////////////////////////
//	DLL support

static AFX_EXTENSION_MODULE extensionDLL = { NULL, NULL };

extern "C" __declspec(dllexport) int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("Shell DLL Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(extensionDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(extensionDLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("Shell DLL Terminating!\n");
		// Terminate the library before destructors are called
		AfxTermExtensionModule(extensionDLL);
	}
	return 1;   // ok

	UNREFERENCED_PARAMETER(lpReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\ucommdlg.h ===
///////////////////////////////////////////////////////////////////////////////
//	UCOMMDLG.H
//
//	Created by :			Date :
//		DavidGa					10/21/93
//
//	Description :
//		Declaration of the Common Dialog Utility classes
//

#ifndef __UICOMMDLG_H__
#define __UICOMMDLG_H__

#include "..\..\udialog.h"
#include "guiv1.h"
#include "wbutil.h"
#include "Strings.h"

#include "shlxprt.h"

#ifndef __UIDIALOG_H__
	#error include 'udialog.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//	control IDs, obtained from Spy++

#define IDC_FILE_FILENAME		0x480	// edt1
#define IDC_FILE_FILENAMELIST	0x460	// lst1
#define IDC_FILE_CURDIR			0x440	// stc1
#define IDC_FILE_DIRECTORIES		0x461	// lst2
#define IDC_FILE_FILETYPES		0x470	// cmb1
#define IDC_FILE_DRIVES			0x471	// cmb2
#define IDC_FILE_HELP			0xE145
#define IDC_FILE_NETWORK			0x40D	// btn13
#define IDC_FILE_READONLY		0x410	// chk1
#define IDC_FILE_OPENAS			0x5033
//#define IDC_FILE_OK		IDOK
//#define IDC_FILE_CANCEL	CANCEL
#define IDC_FONT_NAME			0x470	// cmb1
#define IDC_FONT_STYLE			0x471	// cmb2
#define IDC_FONT_SIZE			0x472	// cmb3

///////////////////////////////////////////////////////////////////////////////
//	UIFileDlg class

// BEGIN_CLASS_HELP
// ClassName: UIFileDlg
// BaseClass: UIDialog
// Category: Shell
// END_CLASS_HELP
class SHL_CLASS UIFileDlg : public UIDialog
{
	UIWND_COPY_CTOR(UIFileDlg, UIDialog);

// Utilities
public:
	void SetName(LPCSTR sz);
	CString GetName();
	void SetPath(LPCSTR sz);
	BOOL OK(BOOL bOverwrite);

	virtual HWND GetDlgItem(UINT id) const;
	virtual LPCSTR GetLabel(UINT id) const;

	// get the extension dialog for this common dialog, if it exists
	virtual HWND GetExtensionDialog(void) const;
};

///////////////////////////////////////////////////////////////////////////////
//	UIFileDlg class

// BEGIN_CLASS_HELP
// ClassName: UIFileSaveAsDlg
// BaseClass: UIFileDlg
// Category: Shell
// END_CLASS_HELP
class SHL_CLASS UIFileSaveAsDlg : public UIFileDlg
{
	UIWND_COPY_CTOR(UIFileSaveAsDlg, UIFileDlg);

// Utilities
public:
	virtual BOOL VerifyUnique(void) const;
	virtual CString ExpectedTitle(void) const
		{	return GetLocString(IDSS_FSA_TITLE); }
};

///////////////////////////////////////////////////////////////////////////////
//	UIFileOpenDlg class

enum EOpenAs { OA_AUTO, OA_TEXT, OA_BINARY, OA_MAKEFILE };

// BEGIN_CLASS_HELP
// ClassName: UIFileOpenDlg
// BaseClass: UIFileDlg
// Category: Shell
// END_CLASS_HELP
class SHL_CLASS UIFileOpenDlg : public UIFileDlg
{
	UIWND_COPY_CTOR(UIFileOpenDlg, UIFileDlg);

// Utilities
public:
	HWND Display();
	virtual BOOL VerifyUnique(void) const;
	virtual CString ExpectedTitle(void) const
		{	return GetLocString(IDSS_FO_TITLE); }
	void SetEditor(EOpenAs oa);
	void SetReadOnly(BOOL b);
};

///////////////////////////////////////////////////////////////////////////////
//	UIFontDlg class

enum { FONT_NORMAL = 1, FONT_ITALIC, FONT_BOLD, FONT_BOLDITALIC };

// BEGIN_CLASS_HELP
// ClassName: UIFontDlg
// BaseClass: UIDialog
// Category: Shell
// END_CLASS_HELP
class SHL_CLASS UIFontDlg : public UIDialog
{
	UIWND_COPY_CTOR(UIFontDlg, UIDialog);

// Utilities
public:
	virtual BOOL VerifyUnique(void) const;
	virtual CString ExpectedTitle(void) const
		{	return GetLocString(IDSS_FD_TITLE, GetSysLang()); }	// no template, so title depends on system
	void SetName(LPCSTR szName);
	void SetSize(int nSize);
	void SetStyle(int nStyle);
};

#endif //__UICOMMDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\newfldlg.h ===
///////////////////////////////////////////////////////////////////////////////
//  NEWFLDLG.H
//
//  Created by :            Date :
//      Ivanl              7/1/96
//
//  Description :
//      Declaration of the UINewFileDlg class
//

#include "uitabdlg.h"
#include "wbutil.h"

#ifndef __UITABDLG_H__
	#error include uitabdlg.h' before including this file
#endif

#ifndef __UINEWFILE__
#define __UINEWFILE__

#include "..\sym\vshell.h"
///////////////////////////////////////////////////////////////////////////////
//  UINewFileDlg class

typedef	enum {FILES =	  VSHELL_IDC_NAMEFORFILE,
			  OTHER =	  VSHELL_IDC_NAMEFOROTHERFILE,
			  PROJECTS =  VSHELL_IDC_NAMEFORPROJECT, 
			  TEMPLATES = VSHELL_IDC_NAMEFORTEMPLATE,
			  WORKSPACE = VSHELL_IDC_NAMEFORWORKSPACE } NewThingType ;

 
// BEGIN_CLASS_HELP
// ClassName: UINewFileDlg
// BaseClass: UITabbedDialog
// Category: Shell
// END_CLASS_HELP
class SHL_CLASS UINewFileDlg : public UITabbedDialog 
	{
	UIWND_COPY_CTOR (UINewFileDlg, UITabbedDialog) ; 

// General Utilities
	public:
		HWND Display(void) ;
			
			
 
	public:
		int SetName( CString Name, int DocType = PROJECTS );
		int SetLocation( CString  szLocation, int DocType = PROJECTS);
		int SelectFromList(CString ItemName) ;
		int SelectFromList(int Index) ;
		int NewFileTab();
		int NewProjectTab();
		int NewTemplateTab();
		int NewWorkspaceTab();
		int NewOtherTab();
		int AddToProject(BOOL bAdd);
		int SetProject(LPCSTR szProject);
		void SetProjPlatform(CString Platform);
		virtual HWND OK() ;
  } ;

#endif //__UINEWFILE__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\ucustdlg.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UCUSTDLG.CPP
//
//  Created by :            Date :
//      EnriqueP              2/7/94
//                                
//  Description :
//      Implementation of the UICustomizeTabDlg class    
//

#include "stdafx.h"
#include "w32repl.h"
#include "ucustdlg.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\cmdids.h"
#include "guiv1.h"
#include "guitarg.h"
#include "uwbframe.h"



#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: HWND UICustomizeTabDlg::Display() 
// Description: Bring up the Customize tabbed dialog.
// Return: The HWND of the Customize dialog.
// END_HELP_COMMENT
HWND UICustomizeTabDlg::Display() 
{       
	AttachActive();           // Check if is already up
	if (!IsValid())
	{
		UIWB.DoCommand(IDM_CUSTOMIZE, DC_MNEMONIC);
		AttachActive();
	}
	return WGetActWnd(0); 
}

// BEGIN_HELP_COMMENT
// Function: HWND UICustomizeTabDlg::Display() 
// Description: Bring up the Customize tabbed dialog.
// Return: The HWND of the Customize dialog.
// END_HELP_COMMENT
HWND UICustomizeTabDlg::DisplayBars() 
{       
	AttachActive();           // Check if is already up
	if (!IsValid())
	{
		UIWB.DoCommand(IDM_CUSTOMIZE, DC_MNEMONIC);
		AttachActive();
	}
    ShowPage(TAB_TOOLBARS,5);
	return WGetActWnd(0); 
}


// BEGIN_HELP_COMMENT
// Function: int UICustomizeTabDlg::AddTBButton(int nButtonType, HWND hwndToolbar /* = NULL */)
// Description: Add a toolbar button (nButtonType) to the toolbar indicated by hwndToolbar.
// Return: TRUE if successful; ERROR_ERROR otherwise.
// Param: nButtonType The button to add to the toolbar (this is NYI).
// Param: hwndToolbar The HWND of the toolbar to add the button to. NULL means create a new toolbar. (Default value is NULL.)
// END_HELP_COMMENT
int UICustomizeTabDlg::AddTBButton(int nButtonType, HWND hwndToolbar /* = NULL */)
{
    Display();          //REVIEW: Verify Toolbars tab is set as well
    ShowPage(TAB_COMMANDS,5);
	POINT ptButtonPos;
//      ptButtonPos = SelectButtonCategory(nButtonType);        Not Yet Implemented
	ptButtonPos.x = 10;
	ptButtonPos.y = 10;
	if ( hwndToolbar != NULL)                               // Put button in a toolbar else create new toolbar
    {
	if(!IsWindowVisible(hwndToolbar) )
		{
			LOG->RecordFailure("The toolbar was not visible so no button was added");
			return ERROR_ERROR;
		}
	DragMouse(VK_LBUTTON, GetCurrentMiniPage(), ptButtonPos.x, ptButtonPos.y, hwndToolbar, 2, 2);     //REVIEW: Button position is hardcoded
    }
    else
    {
	DragMouse(VK_LBUTTON, GetCurrentMiniPage(), ptButtonPos.x, ptButtonPos.y, HWnd(), -50, 100);
    }

    return TRUE;
}

HWND UICustomizeTabDlg::GetCurrentMiniPage()
{
	HWND hwnd = GetCurrentPage();   
	hwnd =  GetWindow(hwnd, GW_CHILD);        // Get First Page child
	char acClass[32];
	while (hwnd)                                                           // Search among siblings to find dialog page
	{
		::GetClassName(hwnd, acClass, 31);
		if( strncmp(acClass, "Afx:", 4) == 0 )
		{
			if ( ::GetWindowLong(hwnd, GWL_STYLE) & WS_VISIBLE)
				return hwnd;                                                    // Return the page that is visible
		}
		hwnd = GetWindow(hwnd, GW_HWNDNEXT);            
	}
								
	return NULL;                                                            // No Visible page was found  (who knows why)
}

HWND UICustomizeTabDlg::BrowseForMacroFiles()
{
	MST.WButtonClick(GetLabel(AUTO1_IDC_BROWSE)) ;
	WaitForInputIdle(g_hTargetProc, 6000);
	return MST.WGetActWnd(0); 
}

// BEGIN_HELP_COMMENT
// Function: HWND UICustomizeTabDlg::DisplayKeyboardTab() 
// Description: Bring up the Customize Keyboard tabbed dialog.
// Return: The HWND of the Customize dialog.
// END_HELP_COMMENT
HWND UICustomizeTabDlg::DisplayKeyboardTab() 
{       
	AttachActive();           // Check if is already up
	if (!IsValid())
	{
		UIWB.DoCommand(IDM_CUSTOMIZE, DC_MNEMONIC);
		AttachActive();
	}
    ShowPage(TAB_KEYBOARD,4);
	return WGetActWnd(0); 
}

// BEGIN_HELP_COMMENT
// Function: BOOL UICustomizeTabDlg::SelectKeyAssignment(CString strEditor,CString strCategory,CString strCommand) 
// Description: Assigns the shortcut ctrl+shift+1 to a command.  Assumes keyboard tab is activated.
// This function resets all assignments and is limited to making only one keyboard assignment.
// PARAM:strEditor-String indicating Editor combobox choice-Main, Dialog,Text, Image
// PARAM:strCategory-String indicating Category listbox choice-File, Edit, View, etc.
// PARAM:strCommand-String indicating Command listbox choice-FileClose, FileCloseWorkspace, etc.
// Return: TRUE if successfully assigned, otherwise FALSE.
// END_HELP_COMMENT
BOOL UICustomizeTabDlg::SelectKeyAssignment(CString strEditor,CString strCategory,CString strCommand) 
{  
	UITabbedDialog::SetOption(TAB_CURRENT,VSHELL_IDC_EDITOR_LIST, strEditor);
	LPCSTR pOption = UITabbedDialog::GetOptionStr(TAB_CURRENT,VSHELL_IDC_EDITOR_LIST);
	if(pOption==NULL || pOption!= strEditor)
	{
		LOG->RecordFailure("Editor called '%s' does not exist",strEditor);
		return FALSE;
	}
	else  //editor set correctly, so set catergory
	{
		//reset key assignments for editor
		MST.WButtonClick(GetLabel(VSHELL_IDC_RESET_ALL));
		MST.DoKeys("{ENTER}");

		UITabbedDialog::SetOption(TAB_CURRENT,VSHELL_IDC_CAT_LIST, strCategory);
		if (UITabbedDialog::GetOptionStr(TAB_CURRENT,VSHELL_IDC_CAT_LIST) != strCategory)
		{
			LOG->RecordFailure("Category called '%s' does not exist",strCategory);
			return FALSE;
		}
		else  //catergory set correctly, so set command
		{
			UITabbedDialog::SetOption(TAB_CURRENT,VSHELL_IDC_CMD_LIST, strCommand);
			if (UITabbedDialog::GetOptionStr(TAB_CURRENT,VSHELL_IDC_CMD_LIST) != strCommand)
			{
				LOG->RecordFailure("Command called '%s' does not exist",strCommand);
				return FALSE;
			}
			else
			{
				//this is the only way to get to edit box
				MST.DoKeys("{TAB 3}"); //need to change this if tab order changes
				//press control+shift+1
				CString Keys = "^(+(1))";
				MST.DoKeys(Keys);
				if (!(MST.WButtonEnabled(GetLabel(VSHELL_IDC_ASSIGN))))
				{
					LOG->RecordFailure("Assign button isn't enabled");
					return FALSE;
				}
				else
				{
					MST.WButtonClick(GetLabel(VSHELL_IDC_ASSIGN));
					//button should now be disabled
					if (MST.WButtonEnabled(GetLabel(VSHELL_IDC_ASSIGN)))
					{
						LOG->RecordFailure("didn't assign shortcut properly-assign button still enabled");
						return FALSE;
					}
					else
					{
						MST.WButtonClick(GetLocString(IDSS_CLOSE));
						if (MST.WFndWnd(GetLocString(IDSS_CUSTOMIZE_TITLE),FW_ACTIVE) != 0)
							LOG->RecordFailure("Customize dialog didn't close properly.");
					}
				}  //end else for assign button
			}  //end else for command
		}  //end else for category
	}  //end else for editor

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\ucommdlg.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	UCOMMDLG.CPP
//
//	Created by :			Date :
//		DavidGa					10/21/93
//
//	Description :
//		Implementation of the Common Dialog Utility classes
//

#include "stdafx.h"
#include "ucommdlg.h"
#include "testxcpt.h"
#include "..\..\testutil.h"
#include "mstwrap.h"
#include "uwbframe.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

///////////////////////////////////////////////////////////////////////////////
//	UIFileDlg class

// BEGIN_HELP_COMMENT
// Function: void UIFileDlg::SetName(LPCSTR sz)
// Description: Set the filename field in a file common dialog box.
// Return: none
// Param: sz A pointer to a string containing the filename to set.
// END_HELP_COMMENT
void UIFileDlg::SetName(LPCSTR sz)
{
	EXPECT( IsValid() );
	MST.WEditSetText(GetLabel(IDC_FILE_FILENAME), sz);
}

// BEGIN_HELP_COMMENT
// Function: CString UIFileDlg::GetName()
// Return: The filename specified in the filename field in a file common dialog box.
// END_HELP_COMMENT
CString UIFileDlg::GetName()
{
	CString strName;

	EXPECT( IsValid() );
	MST.WEditText(GetLabel(IDC_FILE_FILENAME), strName);

	return strName;
}

// BEGIN_HELP_COMMENT
// Function: void UIFileDlg::SetPath(LPCSTR sz)
// Description: Set the path in a file common dialog box.
// Return: none
// Param: sz A pointer to a string containing the path to set.
// END_HELP_COMMENT
void UIFileDlg::SetPath(LPCSTR sz)
{
	EXPECT( IsValid() );
	MST.WEditSetText(GetLabel(IDC_FILE_FILENAME), sz);
	MST.WButtonClick(GetLabel(IDOK));	// REVIEW: OK() will handle possible messages
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIFileDlg::OK(BOOL bOverwrite)
// Description: Click the OK button a file common dialog box.
// Return: TRUE if the button is clicked and the dialog is successfully dismissed; FALSE otherwise.
// Param: bOverwrite TRUE to overwrite the file if it already exists; FALSE to not overwrite the file.
// END_HELP_COMMENT
BOOL UIFileDlg::OK(BOOL bOverwrite)
{
	// TODO(davidga): handle possible error messages
	return UIDialog::OK() == NULL;
}

// BEGIN_HELP_COMMENT
// Function: HWND UIFileDlg::GetDlgItem(UINT id) const
// Description: Get the HWND of a particular item (referred to by ID) in the dialog.
// Return: The HWND of the dialog item specified by the id parameter.
// Param: id The id of the item in the dialog.
// END_HELP_COMMENT
HWND UIFileDlg::GetDlgItem(UINT id) const
// REVIEW(briancr): this function should move to the base class after all the common
// dialogs have been converted to use the new Win95 extension to common dialogs.
{
	HWND hItem;
	HWND hDlgExtension;
	// look for the dialog item as a child first
	hItem = ::GetDlgItem(HWnd(), id);

	// if the item's not a direct child, it may be part of the common dialog extension
	// extensions to common dialogs are implemented as child dialogs of the common dialog
	if (!hItem) {
		hDlgExtension = GetExtensionDialog();
		hItem = ::GetDlgItem(hDlgExtension, id);
	}

	return hItem;
}

// BEGIN_HELP_COMMENT
// Function: HWND UIOpenDlg::GetLabel(UINT id) const
// Description: Get the label associated with a control on the dialog (specified by id).
// Return: A pointer to the string of the control specified by id. The string returned is the string immediately preceeding the control in the dialog.
// Param: id The id of the item in the dialog.
// END_HELP_COMMENT
LPCSTR UIFileDlg::GetLabel(UINT id) const
{
// REVIEW(briancr): this function should move to the base class after all the common
// dialogs have been converted to use the new Win95 extension to common dialogs.
	// is the control an immediate child of this dialog?
	if (::GetDlgItem(HWnd(), id)) {
		return ::GetLabel(id, HWnd());
	}
	else {
		// the control must be on the extension dialog
		return ::GetLabel(id, GetExtensionDialog());
	}
}

// BEGIN_HELP_COMMENT
// Function: HWND UIFileDlg::GetExtensionDialog(void)
// Description: This function gets the HWND of the extension dialog associated with this common dialog. Extensions to common dialogs are implemented as child dialogs of the main dialog.
// Return: HWND of the extension dialog. NULL if it doesn't exist.
// END_HELP_COMMENT
HWND UIFileDlg::GetExtensionDialog(void) const
{
	HWND hControl;
	char acClass[32];

	// get the HWND of the first control in this dialog
	hControl = GetWindow(HWnd(), GW_CHILD);

	// interate through the controls in this dialog
	// until the extension dialog is found
	while (hControl) {
		GetClassName(hControl, acClass, 31);
		// if the control's class is the dialog class, it's the extension dialog
		// note that this assumes there's only one extension dialog...
		if (strncmp(acClass, "#32770", strlen("#32770")) == 0) {
			return hControl;
		}
		// get the next control
		hControl = GetNextWindow(hControl, GW_HWNDNEXT);
	}
	return NULL;
}

///////////////////////////////////////////////////////////////////////////////
//	UIFileSaveAsDlg class

// BEGIN_HELP_COMMENT
// Function: BOOL UIFileSaveAsDlg::VerifyUnique(void) const
// Description: Verify the currently active dialog is the Save As dialog.
// Return: TRUE if the currently active dialog is the Save As dialog; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIFileSaveAsDlg::VerifyUnique(void) const
{
	return	VerifyDlgItemClass(IDC_FILE_FILENAME, GL_EDIT);// &&
//			VerifyDlgItemClass(IDC_FILE_FILENAMELIST, GL_LISTBOX) &&
//			!IsWindowVisible(GetDlgItem(IDC_FILE_OPENAS));
}


///////////////////////////////////////////////////////////////////////////////
//	UIFileOpenDlg class

// BEGIN_HELP_COMMENT
// Function: HWND UIFileOpenDlg::Display(void)
// Description: Bring up the File Open dialog.
// Return: The HWND of the File Open dialog.
// END_HELP_COMMENT
HWND  UIFileOpenDlg::Display(void)
{
	AttachActive();		  // Check if is already up
	if (!IsValid())
	{
	 UIWB.DoCommand(ID_FILE_OPEN, DC_MNEMONIC);
	 WaitAttachActive(5000);
	}
	return WGetActWnd(0); 
}	

// BEGIN_HELP_COMMENT
// Function: BOOL UIFileOpenDlg::VerifyUnique(void) const
// Description: Verify the currently active dialog is the File Open dialog.
// Return: TRUE if the currently active dialog is the File Open dialog; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIFileOpenDlg::VerifyUnique(void) const
{
	return	VerifyDlgItemClass(IDC_FILE_FILENAME, GL_EDIT) &&
//			VerifyDlgItemClass(IDC_FILE_FILENAMELIST, GL_LISTBOX) &&
			VerifyDlgItemClass(IDC_FILE_OPENAS, GL_COMBOBOX);
}


// BEGIN_HELP_COMMENT
// Function: void UIFileOpenDlg::SetEditor(EOpenAs oa)
// Description: Specify the type of editor that should be used in the File Open dialog.
// Return: none
// Param: oa The type of editor to use; specified in the File Open dialog: OA_AUTO, OA_TEXT, OA_BINARY, OA_MAKEFILE.
// END_HELP_COMMENT
void UIFileOpenDlg::SetEditor(EOpenAs oa)
{
	ExpectValid();
	MST.WComboItemClk(GetLabel(IDC_FILE_OPENAS), oa+1);	// oa indexes from 0, MSTest indexes from 1
}

// BEGIN_HELP_COMMENT
// Function: void UIFileOpenDlg::SetReadOnly(BOOL b)
// Description: Check or uncheck the Open File as Read Only check box in the File Open dialog.
// Return: none
// Param: b TRUE to check the Open File as Read Only check box; FALSE to uncheck it.
// END_HELP_COMMENT
void UIFileOpenDlg::SetReadOnly(BOOL b)
{
	ExpectValid();
	if( b )
		MST.WCheckCheck(GetLabel(IDC_FILE_READONLY));
	else
		MST.WCheckUnCheck(GetLabel(IDC_FILE_READONLY));
}

///////////////////////////////////////////////////////////////////////////////
//	UIFontDlg class


// BEGIN_HELP_COMMENT
// Function: BOOL UIFontDlg::VerifyUnique(void) const
// Description: Determine whether the currently active dialog is the font dialog by verifying it contains a font name control, font style control, and font size control. This function is valid for the Font dialog used from the text tool in the image editors.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIFontDlg::VerifyUnique(void) const
{
	return	VerifyDlgItemClass(IDC_FONT_NAME, GL_COMBOBOX) &&
			VerifyDlgItemClass(IDC_FONT_STYLE, GL_COMBOBOX) &&
			VerifyDlgItemClass(IDC_FONT_SIZE, GL_COMBOBOX);
}

// BEGIN_HELP_COMMENT
// Function: void UIFontDlg::SetName(LPCSTR szName)
// Description: Set the font name in the Font dialog. This function is valid for the Font dialog used from the text tool in the image editors.
// Return: none
// Param: szName A pointer to a string containing the font name.
// END_HELP_COMMENT
void UIFontDlg::SetName(LPCSTR szName)
{
	MST.WComboItemClk(GetLabel(IDC_FONT_NAME), szName);
}

// BEGIN_HELP_COMMENT
// Function: void UIFontDlg::SetSize(int nSize)
// Description: Set the font size in the Font dialog. This function is valid for the Font dialog used from the text tool in the image editors.
// Return: none
// Param: nSize An integer containing the point size.
// END_HELP_COMMENT
void UIFontDlg::SetSize(int nSize)
{
	CString strSize;
	strSize.Format("%d", nSize);	// must pass string, or it thinks it's an index
	MST.WComboItemClk(GetLabel(IDC_FONT_SIZE), strSize);
}

// BEGIN_HELP_COMMENT
// Function: void UIFontDlg::SetStyle(int nStyle)
// Description: Set the font style in the Font dialog. This function is valid for the Font dialog used from the text tool in the image editors.
// Return: none
// Param: nStyle An integer containing a 1-based index into the list of styles for the selected font. This value is usually: 1 for regular style; 2 for italic style; 3 for bold style; and 4 for bold italic style.
// END_HELP_COMMENT
void UIFontDlg::SetStyle(int nStyle)
{
	MST.WComboItemClk(GetLabel(IDC_FONT_STYLE), nStyle);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\udockwnd.h ===
///////////////////////////////////////////////////////////////////////////////
//	UDOCKWND.H
//
//	Created by :			Date :
//		DavidGa					12/9/93
//
//	Description :
//		Declaration of the UIDockWindow class
//

#ifndef __UIDOCKWND_H__
#define __UIDOCKWND_H__

#include "..\..\uwindow.h"
#include "shlxprt.h"

#ifndef __UIWINDOW_H__
	#error include 'uwindow.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//	UIDockWindow

// BEGIN_CLASS_HELP
// ClassName: UIDockWindow
// BaseClass: UIWindow
// Category: Shell
// END_CLASS_HELP
class SHL_CLASS UIDockWindow : public UIWindow
{
	UIWND_COPY_CTOR(UIDockWindow, UIWindow);

	virtual BOOL AttachActive(void);
	virtual BOOL Find(void);

protected:
	virtual BOOL ActivatePane(LPCSTR);		// Don't want direct calls of this from outside.

// UIWindow overrides
public:
	virtual BOOL IsValid(void) const;
	virtual BOOL IsActive(void);

// Utilities
public:
	enum DockLocation 
	{
		DontCare,
		Top,
		Bottom,
		Left,
		Right
	};

	virtual BOOL IsDockable(void);
	virtual BOOL Close(void);
	virtual UINT GetID(void) const;
	virtual BOOL IsDocked(DockLocation loc = UIDockWindow::DontCare);
};

#endif //__UIDOCKWND_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\udockwnd.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UDOCKWND.CPP
//
//  Created by :            Date :
//      DavidGa                 12/10/93
//
//  Description :
//      Implementation of the UIDockWindow class
//

#include "stdafx.h"
#include "udockwnd.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\cmdids.h"
#include "uwbframe.h"
#include "..\sym\reg.h"
#include "..\sym\dockids.h"
#include "..\sym\qcqp.h"
#include "guiv1.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: BOOL UIDockWindow::AttachActive(void)
// Description: Initialize this object by attaching to the active dockable window.
// Return: TRUE if successfully attached to the active dockable window; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIDockWindow::AttachActive(void)
{
	int pkgId ;
	switch(GetID())
	{
	case 0:
		pkgId = 0 ;
		break ;
	case IDDW_PROJECT:
		pkgId = PACKAGE_VPROJ ;
		break;
	case IDW_LOCALS_WIN: 
		pkgId = PACKAGE_VCPP ;
		break ;
	default:
		break;
	}
    HWND hwndFocus = MST.WGetFocus();
    HWND hwndDock = UIWB.GetToolbar(GetID(),pkgId);
    if( (hwndFocus == hwndDock) || (::IsChild(hwndDock, hwndFocus)) )
        return Attach(hwndDock);
    else
        return Attach(hwndFocus);       // will return FALSE, but the HWnd() will still point to something.
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIDockWindow::Find(void)
// Description: Find the dockable window indicated by this object. This function is useful only when used on object of a class derived from UIDockWindow.
// Return: TRUE if the dockable window indicated by this object is found; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIDockWindow::Find(void)
{
	int pkgId ;
	switch(GetID())
	{
	case 0:
		pkgId = 0 ;
		break ;
	case IDDW_PROJECT:
		pkgId = PACKAGE_VPROJ ;
		break;
	case IDW_LOCALS_WIN: 
		pkgId = PACKAGE_VCPP ;
		break ;
	default:
		break;
	}
    return Attach(UIWB.GetToolbar(GetID(),pkgId));
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIDockWindow::IsValid(void) const
// Description: Determine if the dockable window indicated by this object is valid.
// Return: TRUE if the dockable window is valid; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIDockWindow::IsValid(void) const
{
	int pkgId ;
	switch(GetID())
	{
	case 0:
		pkgId = 0 ;
		break ;
	case IDDW_PROJECT:
		pkgId = PACKAGE_VPROJ ;
		break;
	case IDW_LOCALS_WIN: 
		pkgId = PACKAGE_VCPP ;
		break ;
	default:
		break;
	}
    return UIWindow::IsValid() && (HWnd() == UIWB.GetToolbar(GetID(),pkgId));
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIDockWindow::IsActive(void)
// Description: Determine if the dockable window indicated by this object is active.
// Return: TRUE if the dockable window is active; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIDockWindow::IsActive(void)
{
    HWND hwnd = MST.WGetFocus();
    return (hwnd == HWnd()) || IsChild(HWnd(), hwnd);
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIDockWindow::IsDockable(void)
// Description: Determine if the dockable window is dockable or MDI.
// Return: A Boolean value that indicates whether the dockable window is dockable (TRUE) or MDI.
// END_HELP_COMMENT
BOOL UIDockWindow::IsDockable(void)
{
	// Check extended style of window.  If it's MDI, then it's not dockable.
	return (GetWindowLong(HWnd(), GWL_EXSTYLE) & WS_EX_MDICHILD)? FALSE: TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIDockWindow::Close(void)
// Description: Close the dockable window.
// Return: TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIDockWindow::Close(void)

    {
    if(Activate())

        {
        if(IsDockable())
			{
			// REVIEW (michma): where is Window.Hide?
			// %wd now points to Window.Docking View.
            //UIWB.DoCommand(ID_WINDOW_HIDE, DC_MNEMONIC);
			}
		else
            UIWB.DoCommand(ID_FILE_CLOSE, DC_MNEMONIC);
        
        return TRUE;
        }
                    
    return FALSE;
    }

// BEGIN_HELP_COMMENT
// Function: UINT UIDockWindow::GetID(void) const
// Description: Get the id of the dockable window indicated by this object. This function is only valid when used on object of a class derived from UIDockWindow.
// Return: The id of the dockable window, 0 if not associated with any dockable window.
// END_HELP_COMMENT
UINT UIDockWindow::GetID(void) const
{
    return 0;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIDockWindow::ActivatePane(LPCSTR)
// Description: Activate a specified pane within this docked window.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIDockWindow::ActivatePane(LPCSTR szPaneName)

{
	const char* const THIS_FUNCTION = "UIDockWindow::ActivatePane";

    Activate();     // Activate this particular dockable window.
	CString strTarget(szPaneName);	// Store the target pane name.
	CString strCurrent;

	HWND hwndFirst = MST.WGetFocus();
	HWND hwndCurrent = hwndFirst;

    BOOL bFound = FALSE;    
    while(!bFound)

    {
		// This window's caption contains the name of the currently active pane.
		MST.WGetText(hwndCurrent, strCurrent);
		LOG->RecordInfo("%s: Current pane is '%s'.", THIS_FUNCTION, strCurrent);

        if (strCurrent == strTarget)    
            bFound = TRUE;              // Current panename matches target.
        else
        
		{   
            // Goto next pane.
            MST.DoKeys("^({PgUp})");
			hwndCurrent = MST.WGetFocus();
            
			if (hwndFirst == hwndCurrent)
			{
				LOG->RecordInfo("ERROR in %s: Could not find pane '%s'.", THIS_FUNCTION, szPaneName);
				break;                  // Been through them all.
			}
        }
    }

    return bFound;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIDockWindow::IsDocked(int nLocation = /* DW_DONT_CARE */)
// Description: Determine if this docking window is currently docked in the position given by nLocation.
// Return: TRUE if the toolbar is docked; FALSE otherwise.
// Param: loc The dock location of the toolbar: DW_DONT_CARE, DW_TOP, DW_BOTTOM, DW_RIGHT, DW_LEFT.
// END_HELP_COMMENT
BOOL UIDockWindow::IsDocked(DockLocation loc)
{
    // If it's not visible or dockable, then it's definitely not docked.
    if (!IsWindowVisible(HWnd()) || !IsDockable())
        return FALSE;

    // If it's style indicates that it's a popup window, then it's dockable, but not docked.
    if ( ::GetWindowLong(HWnd(), GWL_STYLE) & WS_POPUP)
        return FALSE;                           // Window is floating

    // We know it's docked, now check it's position by comparing it with the 
    // MDI client window position.
    RECT rcWBClient;

    ::GetClientRect( UIWB,  &rcWBClient);
    ::MapWindowPoints( UIWB, HWND_DESKTOP, (POINT*)&rcWBClient, 2); 
    
    RECT rcWBMDIClient;
    HWND hMDIClient = UIWB.GetClient();                 // Returns MDI Client
    ::GetWindowRect( hMDIClient, &rcWBMDIClient );
                
    
    RECT rcDockableWnd;

    ::GetWindowRect(HWnd(), &rcDockableWnd);              // Get dockable window dimensions
    
    int nXBorder = ::GetSystemMetrics(SM_CXBORDER);     // Width of a border (usually 1 pix)
    int nYBorder = ::GetSystemMetrics(SM_CYBORDER);     // Heigth of border (usually 1 pix) 
    
	switch(loc)
	{
	case DontCare:
		return TRUE;

	case Top:
		if( (rcWBClient.top  <= rcDockableWnd.top + nYBorder) && (rcWBMDIClient.top >= rcDockableWnd.bottom - nYBorder) )
			return TRUE;
		break;

	case Bottom:
		if( (rcWBClient.bottom >= rcDockableWnd.bottom - nYBorder) && (rcWBMDIClient.bottom <= rcDockableWnd.top + nYBorder) )
			return TRUE;
		break;

	case Left:
		if( (rcWBClient.left <= rcDockableWnd.left + nXBorder) && (rcWBMDIClient.left >= rcDockableWnd.right - nXBorder) )
			return TRUE;
		break;

	case Right:
		if( (rcWBClient.right >= rcDockableWnd.right - nXBorder) && (rcWBMDIClient.right <= rcDockableWnd.left + nXBorder ) )
			return TRUE;
		break;

	default:
		ASSERT(FALSE);	// Can't happen.
	}

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\ucustdlg.h ===
///////////////////////////////////////////////////////////////////////////////
//  UCUSTDLG.H
//
//  Created by :            Date :
//      EnriqueP              2/4/94
//
//  Description :
//      Declaration of the UICustomizeTabDlg class
//

#ifndef __UCUSTDLG_H__
#define __UCUSTDLG_H__

#include "uitabdlg.h"					
#include "wbutil.h"
#include "..\sym\vshell.h"
#include "Strings.h"
#include "..\sym\auto1.h"

#include "shlxprt.h"

#ifndef __UITABDLG_H__
	#error include 'uitabdlg.h' before including this file
#endif

#define ERROR_ERROR -1

///////////////////////////////////////////////////////////////////////////////
//  UICustomizeTabDlg class

//	Tools Options tabs	 (These are acually unique control id's found in each page) REVIEW: Use True tab id's
typedef enum { TAB_COMMANDS = VSHELL_IDC_CATEGORIES , 
			   TAB_TOOLBARS = VSHELL_IDC_TOOLTIPS , 
			   TAB_TOOLS = VSHELL_ID_TOOLS_MENUCONTENTS , 
			   TAB_KEYBOARD = VSHELL_IDC_CAT_LIST,
			   TAB_MACRO_ADDIN = AUTO1_IDC_LIST } CUST_DLG_TAB;



// Control ID's for Toolbars Page  ( original id's defined in vshell.h)

// Control ID's for Tools Page  ( original id's defined in vshell.h)

// Control ID's for Keboard Page  ( original id's defined in vshell.h)


///////////////////////////////////////////////////////////////////////////////
 
// BEGIN_CLASS_HELP
// ClassName: UICustomizeTabDlg
// BaseClass: UITabbedDialog
// Category: Shell
// END_CLASS_HELP
class SHL_CLASS UICustomizeTabDlg : public UITabbedDialog 
	{
    UIWND_COPY_CTOR (UICustomizeTabDlg, UITabbedDialog) ; 

// General Utilities
	public:
			inline CString ExpectedTitle(void) const
			{ return GetLocString(IDSS_CUSTOMIZE_TITLE); }		// Title: "Customize"

			HWND Display(void) ;
			
			
// Toolbars Tab
	public:
			int AddTBButton(int nButtonType, HWND hwndToolbar = NULL );
			HWND GetCurrentMiniPage(void); // REVIEW (EnriqueP) Is this a general utility for all tabs?
			HWND DisplayBars(void);
// Tools Tab

// Keyboard
			HWND DisplayKeyboardTab(void); 
			BOOL SelectKeyAssignment(CString strEditor,CString strCategory,CString strCommand);

// Macros and Add-Ins 
			int ShowAddIn_MacroPg() { ShowPage(TAB_MACRO_ADDIN,5) ; return ERROR_SUCCESS;} ;
			HWND BrowseForMacroFiles() ;


 
   } ;

#endif //__UCUSTDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\uiconnec.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UICONNEC.CPP
//
//  Created by :            Date :
//      MichMa                  8/24/94
//
//  Description :
//      Implementation of the UIConnection class
//

#include "stdafx.h"
#include "uiconnec.h"
#include "..\..\testutil.h"
#include "guiv1.h"
#include "mstwrap.h"
#include "..\sym\vcpp32.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


// BEGIN_HELP_COMMENT
// Function: HWND UIConnection::Settings(CString title) 
// Description: Open the Settings dialog from the Connection dialog by clicking the Settings button.
// Return: An HWND that specifies the Settings dialog.
// Param: title A CString that contains the expected title of the Settings dialog (this title changes based on the platform and connection type specified in the Connection dialog).
// END_HELP_COMMENT
HWND UIConnection::Settings(CString title) 
	
	{
	if(!MST.WButtonExists(GetLabel(VCPP32_IDC_SETUP))) 

		{
		LOG->RecordInfo("ERROR in UIConnection::Settings(): "
			  "%s button not enabled", GetLabel(VCPP32_IDC_SETUP));
			   
		return NULL;			
		}

	MST.WButtonClick(GetLabel(VCPP32_IDC_SETUP));
	return MST.WFndWndWait(title, FW_DEFAULT, 10);
	}


// BEGIN_HELP_COMMENT
// Function: int UIConnection::SetPlatform(LPCSTR platform)
// Description: Set the platform in the Connection dialog.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: platform A pointer to a string that contains the platform to select in the Connection dialog.
// END_HELP_COMMENT
int UIConnection::SetPlatform(LPCSTR platform)
	
	{
	if(MST.WComboItemExists(GetLabel(VCPP32_IDC_PLATFORM_LIST), platform) < 1)
		
		{
		LOG->RecordInfo("ERROR in UIConnection::SetPlatform(): "
			  "%s item of %s combo box doesn't exist", 
			  platform, GetLabel(VCPP32_IDC_PLATFORM_LIST));
			   
		return ERROR_ERROR;
		}							

	MST.WComboItemClk(GetLabel(VCPP32_IDC_PLATFORM_LIST), platform);
	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int UIConnection::SetConnection(LPCSTR connection)
// Description: Set the connection type in the Connection dialog.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: connection A pointer to a string that contains the connection to select in the Connection dialog.
// END_HELP_COMMENT
int UIConnection::SetConnection(LPCSTR connection)
	
	{
	if(MST.WListItemExists(GetLabel(VCPP32_IDC_TRANSPORT_LIST), connection) < 1)

		{
		LOG->RecordInfo("ERROR in UIConnection::SetConnection(): "
			  "%s item of %s combo box doesn't exist", 
			  connection, GetLabel(VCPP32_IDC_TRANSPORT_LIST));
			   
		return ERROR_ERROR;
		}							

	MST.WListItemClk(GetLabel(VCPP32_IDC_TRANSPORT_LIST), connection);
	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: CString UIConnection::GetPlatform(void)
// Description: Get the selected platform in the Connection dialog.
// Return: A CString that contains the selected platform in the Connection dialog.
// END_HELP_COMMENT
CString UIConnection::GetPlatform(void)
	{
	CString platform;
	MST.WComboText(GetLabel(VCPP32_IDC_PLATFORM_LIST), platform);
	return platform;
	}


// BEGIN_HELP_COMMENT
// Function: CString UIConnection::GetConnection(void)
// Description: Get the selected connection in the Connection dialog.
// Return: A CString that contains the selected connection in the Connection dialog.
// END_HELP_COMMENT
CString UIConnection::GetConnection(void)
	{
	CString connection;
	MST.WListText(GetLabel(VCPP32_IDC_TRANSPORT_LIST), connection);
	return connection;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\uiconset.h ===
///////////////////////////////////////////////////////////////////////////////
//  UICONSET.H
//
//  Created by :            Date :
//      MichMa                  8/25/94
//
//  Description :
//      Declaration of the UIConnectionSettings class
//

#ifndef __UICONSET_H__
#define __UICONSET_H__

#include "..\..\udialog.h"

#include "shlxprt.h"

#define ERROR_ERROR -1

///////////////////////////////////////////////////////////////////////////////
//  UIConnectionSettings class

typedef enum {CONNECTION_LOCAL	   = 0x00000001,
			  CONNECTION_SERIAL	   = 0x00000002,
			  CONNECTION_APPLETALK = 0x00000004,
			  CONNECTION_TCP_IP	   = 0x00000008,
			  // add any new connection types here
			  CONNECTION_CURRENT  = 0x20000000,
			  CONNECTION_USER	  = 0x40000000,
			  CONNECTION_NON_USER = 0x80000000} CONNECTION_TYPE;

// BEGIN_CLASS_HELP
// ClassName: UIConnectionSettings
// BaseClass: UIDialog
// Category: Shell
// END_CLASS_HELP
class SHL_CLASS UIConnectionSettings : public UIDialog

	{
	UIWND_COPY_CTOR(UIConnectionSettings, UIDialog);

	// Utilities
	public:
		
		int SetZone(LPCSTR zone);
		int SetMachineName(LPCSTR name);
   		int SetConnector(LPCSTR connector);
		int SetBaudRate(LPCSTR baud_rate);
		int SetDataBits(LPCSTR data_bits);
		int SetParity(LPCSTR parity);
		int SetStopBits(LPCSTR stop_bits);
		int SetFlowControl(LPCSTR flow_control);
  		int SetIPAddress(LPCSTR ip_address);
		int SetPassword(LPCSTR password, CONNECTION_TYPE connection);

		HWND Close(void);
	};

#endif // __UICONSET_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\uiconnec.h ===
///////////////////////////////////////////////////////////////////////////////
//  UICONNEC.H
//
//  Created by :            Date :
//      MichMa                  8/24/94
//
//  Description :
//      Declaration of the UIConnection class
//

#ifndef __UICONNEC_H__
#define __UICONNEC_H__

#include "..\..\udialog.h"
#include "Strings.h"
#include "wbutil.h"

#include "shlxprt.h"

#define ERROR_ERROR -1

///////////////////////////////////////////////////////////////////////////////
//  UIConnection class

// BEGIN_CLASS_HELP
// ClassName: UIConnection
// BaseClass: UIDialog
// Category: Shell
// END_CLASS_HELP
class SHL_CLASS UIConnection : public UIDialog

	{
	UIWND_COPY_CTOR(UIConnection, UIDialog);
	CString ExpectedTitle(void) const {return GetLocString(IDSS_CONNEC_DLG_TITLE);}
	
	// Utilities
	public:
		operator HWND() {return HWnd();} ;

		HWND Settings(CString title);
		
		int SetPlatform(LPCSTR platform);
		int SetConnection(LPCSTR connection);
		
		CString GetPlatform(void);
		CString GetConnection(void);
	};

#endif // __UICONNEC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\uioptdlg.h ===
///////////////////////////////////////////////////////////////////////////////
//  UITABDLG.H
//
//  Created by :            Date :
//      EnriqueP              1/27/94
//
//  Description :
//      Declaration of the UIOptionsTabDlg class
//

#ifndef __UIOPTDLG_H__
#define __UIOPTDLG_H__

#include "uitabdlg.h"
#include "wbutil.h"

#include "shlxprt.h"
#include "..\sym\vcpp32.h"
#include "..\sym\vproj.h"

#ifndef __UITABDLG_H__
	#error include 'uitabdlg.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//  UIOptionsTabDlg class

//  Tools Options tabs   (These are acually unique control id's found in each page) REVIEW: Use True tab id's
enum{   TAB_WORKSPACE =   20640,	// IDC_STATUSBAR
		TAB_DEBUG =       24100,    // IDC_DEBUG_CODEBYTES
		TAB_COLORS =      24035,    // ID_COLORS_SYNTAX
		TAB_FONTS =       24073,    // IDC_SHOWPROPORTIONAL
		TAB_DIRECTORIES = 16037,	 // IDC_DIRS_LIST
		TAB_COMPATIBILITY = VCPP32_IDC_EMULATION,  // Emulation 
		TABS_TAB = VCPP32_IDC_INDENT_CLOSEBRACE	// The Tabs tab
		} ;

typedef	enum { EMULATE_VC3, EMULATE_VC2, EMULATE_BRIEF, EMULATE_EPSILON, EMULATE_CUSTOM } EmulationType ;

typedef enum {NONE, DEFAULT, SMART, OPEN, CLOSING} Indentation ;
// Control ID's for Directories Page  ( original id's defined in vproj.h)
#define DIR_PLATFORM        VPROJ_IDC_DIRS_TOOLSETS
#define DIR_DIRTYPE         VPROJ_IDC_DIRS_OPTIONS
#define DIR_DIRS_LIST       VPROJ_IDC_DIRS_LIST
#define DIR_ADD             VPROJ_IDC_DIRS_ADD
#define DIR_REMOVE          VPROJ_IDC_DIRS_DELETE
#define DIR_MOVE_UP         VPROJ_IDC_DIRS_MOVEUP
#define DIR_MOVE_DOWN       VPROJ_IDC_DIRS_MOVEDOWN

#define ADD_DIR_NAME            VPROJ_IDC_DIRS_DIRNAME
#define ADD_DIR_BROWSE          16552 /*VPROJ_IDC_DIRS_BROWSE  */
#define ADD_DIR_BUTTON          IDOK

// Indexes for combo box options in Directories Page

#define DIR_PLATFORM_WIN32      1
#define DIR_PLATFORM_DUMMY      2
#define DIR_DIRTYPE_EXE         1
#define DIR_DIRTYPE_INC         2
#define DIR_DIRTYPE_LIB         3


///////////////////////////////////////////////////////////////////////////////
 
// BEGIN_CLASS_HELP
// ClassName: UIOptionsTabDlg
// BaseClass: UITabbedDialog
// Category: Shell
// END_CLASS_HELP
class SHL_CLASS UIOptionsTabDlg : public UITabbedDialog 
	{
	UIWND_COPY_CTOR (UIOptionsTabDlg, UITabbedDialog) ; 

// General Utilities
	public:
			inline CString ExpectedTitle(void) const
			{ return GetLocString(IDSS_OD_TITLE); }     // Options
			
			HWND Display(void) ;
			
			
// Directories 
	public:
			int AddDirectory( LPCSTR szNewDir, int iDirType = -1, int iPlatform = -1, int atTop = 0);
			int UIOptionsTabDlg::ShowDirectoryTab()	 ;

// Workspace
			int RestoreWnd( BOOL state = TRUE);
//
			int ShowTabsTab()
			{	Display() ;
				ShowPage(TABS_TAB,12) ;
				return TRUE ;
			}
// Editor
			int SetAutoIndentMode(int );
			int SetSmartIndentOption(int , int PrevLine = 0 );

// Compatibility
			int ChangeCompatility(int Scheme) ;
			int ActivateCompaTab() ;

// Debugger
			int ShowDebugTab()
			{	Display() ;
				ShowPage(0x5E2A,12) ;
				return TRUE ;
			}
 
// Colors

// Fonts
        int SetFont( int FontIndex, int Size = 1, CString Category = "") ;
		int SetFont(LPCSTR pszFontName = NULL, int iFontSize = 0, LPCSTR pszFontStyle = NULL, LPCSTR pszCategory = NULL);

		BOOL ToggleHexDisplay(BOOL bEnable);
		BOOL ToggleSourceAnnotation(BOOL bEnable);
   } ;



#endif //__UIOPTDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\uioutput.h ===
///////////////////////////////////////////////////////////////////////////////
//	UOUTPUT.H
//
//	Created by :			Date :
//		DavidGa					12/9/93
//
//	Description :
//		Declaration of the various UIDockWindow derived classes
//

#ifndef __UIOUTPUT_H__
#define __UIOUTPUT_H__

#include "udockwnd.h"
#include "..\sym\qcqp.h"

#include "shlxprt.h"

#ifndef __UIDOCKWND_H__
	#error include 'udockwnd.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//	UISymbolBrowser class

// BEGIN_CLASS_HELP
// ClassName: UIOutput
// BaseClass: UIDockWindow
// Category: Shell
// END_CLASS_HELP
class SHL_CLASS UIOutput : public UIDockWindow
{
	UIWND_COPY_CTOR(UIOutput, UIDockWindow);

	virtual BOOL Activate(void);
	virtual UINT GetID(void) const
		{	return IDW_OUTPUT_WIN; }
};

#endif //__UIOUTPUT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\uioutput.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	UOUTPUT.CPP
//
//	Created by :			Date :
//		DavidGa					12/10/93
//
//	Description :
//		Implementation of the various UIDockWindow derived classes
//

#include "stdafx.h"
#include "..\sym\cmdids.h"
#include "uioutput.h"
#include "uwbframe.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: BOOL UIOutput::Activate(void)
// Description: Display the Output window.
// Return: TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIOutput::Activate(void)
{
	UIWB.DoCommand(IDM_WINDOW_ERRORS, DC_MNEMONIC);
	return AttachActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\uiconset.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UICONSET.CPP
//
//  Created by :            Date :
//      MichMa                  8/25/94
//
//  Description :
//      Implementation of the UIConnectionSettings class
//

#include "stdafx.h"
#include "uiconset.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "guiv1.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: int UIConnectionSettings::SetZone(LPCSTR zone)	
// Description: Set the Appletalk zone in the Connection Settings dialog.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: zone A pointer to a string that contains the name of the Appletalk zone.
// END_HELP_COMMENT
int UIConnectionSettings::SetZone(LPCSTR zone)	
	
	{
	if(!MST.WEditEnabled("@2"))		//todo: use GetLabel() 
		
		{
		LOG->RecordInfo("ERROR in UIConnectionSettings::SetZone(): "
			  "@2 edit box not enabled");
			   
		return ERROR_ERROR;
		}
									
	MST.WEditSetText("@2", zone);					
	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int UIConnectionSettings::SetMachineName(LPCSTR machine_name)
// Description: Set the machine name in the Connection Settings dialog.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: machine_name A pointer to a string that contains the machine name.
// END_HELP_COMMENT
int UIConnectionSettings::SetMachineName(LPCSTR machine_name)
		
	{
	if(!MST.WEditEnabled("@1"))		//todo: use GetLabel() 
		
		{
		LOG->RecordInfo("ERROR in UIConnectionSettings::SetMachineName(): "
			  "@1 edit box not enabled");
			   
		return ERROR_ERROR;
		}
									
	MST.WEditSetText("@1", machine_name);					
	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int UIConnectionSettings::SetConnector(LPCSTR connector)
// Description: Set the connector type in the Connection Settings dialog.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: connector A pointer to a string that contains the connector name.
// END_HELP_COMMENT
int UIConnectionSettings::SetConnector(LPCSTR connector)
	
	{
	if(MST.WComboItemExists("@1", connector) < 1) 		//todo: use GetLabel()
		
		{
		LOG->RecordInfo("ERROR in UIConnectionSettings::SetConnector(): "
			  "%s item of @1 combo box doesn't exist", connector);
			   
		return ERROR_ERROR;
		}
									
	MST.WComboItemClk("@1", connector);									
	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int UIConnectionSettings::SetBaudRate(LPCSTR baud_rate)
// Description: Set the baud rate in the Connection Settings dialog.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: baud_rate A pointer to a string that contains the baud rate.
// END_HELP_COMMENT
int UIConnectionSettings::SetBaudRate(LPCSTR baud_rate)
	
	{
	if(MST.WComboItemExists("@2", baud_rate) < 1) 	   //todo: use GetLabel()
		
		{
		LOG->RecordInfo("ERROR in UIConnectionSettings::SetBaudRate): "
			  "%s item of @2 combo box doesn't exist", baud_rate);
			   
		return ERROR_ERROR;
		}
									
	MST.WComboItemClk("@2", baud_rate);							
	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int UIConnectionSettings::SetDataBits(LPCSTR data_bits)
// Description: Set the number of data bits in the Connection Settings dialog.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: data_bits A pointer to a string that contains the number of data bits.
// END_HELP_COMMENT
int UIConnectionSettings::SetDataBits(LPCSTR data_bits)

	{
	if(MST.WComboItemExists("@3", data_bits) < 1) 		//todo: use GetLabel()
		
		{
		LOG->RecordInfo("ERROR in UIConnectionSettings::SetDataBits(): "
			  "%s item of @3 combo box doesn't exist", data_bits);
			   
		return ERROR_ERROR;
		}
									
	MST.WComboItemClk("@3", data_bits);							
	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int UIConnectionSettings::SetParity(LPCSTR parity)
// Description: Set the parity in the Connection Settings dialog.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: parity A pointer to a string that contains the parity.
// END_HELP_COMMENT
int UIConnectionSettings::SetParity(LPCSTR parity)

	{
	if(MST.WComboItemExists("@4", parity) < 1) 	 //todo: use GetLabel()
		
		{
		LOG->RecordInfo("ERROR in UIConnectionSettings::SetParity(): "
			  "%s item of @4 combo box doesn't exist", parity);
			   
		return ERROR_ERROR;
		}
									
	MST.WComboItemClk("@4", parity);							
	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int UIConnectionSettings::SetStopBits(LPCSTR stop_bits)
// Description: Set the number of stop bits in the Connection Settings dialog.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: stop_bits A pointer to a string that contains the stop bits.
// END_HELP_COMMENT
int UIConnectionSettings::SetStopBits(LPCSTR stop_bits)
	
	{
	if(MST.WComboItemExists("@5", stop_bits) < 1) 	   //todo: use GetLabel()
		
		{
		LOG->RecordInfo("ERROR in UIConnectionSettings::SetStopBits(): "
			  "%s item of @5 combo box doesn't exist", stop_bits);
			   
		return ERROR_ERROR;
		}
									
	MST.WComboItemClk("@5", stop_bits);							
	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int UIConnectionSettings::SetFlowControl(LPCSTR flow_control)
// Description: Set the type of flow control in the Connection Settings dialog.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: flow_control A pointer to a string that contains the type of flow control.
// END_HELP_COMMENT
int UIConnectionSettings::SetFlowControl(LPCSTR flow_control)

	{
	if(!MST.WOptionEnabled(flow_control)) 	  //todo: use GetLabel()
		
		{
		LOG->RecordInfo("ERROR in UIConnectionSettings::SetFlowControl(): "
			  "%s option button not enabled", flow_control);
			   
		return ERROR_ERROR;
		}
									
	MST.WOptionSelect(flow_control);
	return ERROR_SUCCESS;
	}

	
// BEGIN_HELP_COMMENT
// Function: int UIConnectionSettings::SetIPAddress(LPCSTR ip_address)	
// Description: Set the IP address in the Connection Settings dialog.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: ip_address A pointer to a string that contains the IP address.
// END_HELP_COMMENT
int UIConnectionSettings::SetIPAddress(LPCSTR ip_address)	
	
	{
	if(!MST.WEditEnabled("@1"))		//todo: use GetLabel() 
		
		{
		LOG->RecordInfo("ERROR in UIConnectionSettings::SetIPAddress(): "
			  "@1 edit box not enabled");
			   
		return ERROR_ERROR;
		}
									
	MST.WEditSetText("@1", ip_address);					
	return ERROR_SUCCESS;
	}


// BEGIN_HELP_COMMENT
// Function: int UIConnectionSettings::SetPassword(LPCSTR password, CONNECTION_TYPE connection)
// Description: Set the password in the Connection Settings dialog.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: password A pointer to a string that contains the password.
// Param: connection A CONNECTION_TYPE value that specifies the type of connection: CONNECTION_APPLETALK, CONNECTION_TCP_IP.
// END_HELP_COMMENT
int UIConnectionSettings::SetPassword(LPCSTR password, 
									  CONNECTION_TYPE connection)

	{
	CString edit_ordinal;

	switch(connection)

		{
		case CONNECTION_APPLETALK:
			edit_ordinal = "@3";
			break;
		case CONNECTION_TCP_IP:
			edit_ordinal = "@2";
			break;
		
		default:
			
			LOG->RecordInfo("ERROR in UIConnectionSettings::SetPassword(): "
				  "invalid connection type");
			   
			return ERROR_ERROR;
		}
	
	
	if(!MST.WEditEnabled(edit_ordinal)) 	//todo: use GetLabel()
		
		{
		LOG->RecordInfo("ERROR in UIConnectionSettings::SetPassword(): "
			  "%s edit box not enabled", edit_ordinal);
			   
		return ERROR_ERROR;
		}
									
	MST.WEditSetText(edit_ordinal, password);				
	return ERROR_SUCCESS;
	}


// review: can't use UIDialog::Close() because it calls ExpectValid() which
// checks the ExpectedTitle(), which this window doesn't really have because
// it's dependent on the tl.  could override ExpectedTitle() to choose correct
// title, but since the dlg only knows it's title once it's up, that function
// would have limited use.  this works for now. michma

// BEGIN_HELP_COMMENT
// Function: HWND UIConnectionSettings::Close(void)								
// Description: Close the Connection Settings dialog.
// Return: NULL if successful; the HWND of any remaining message or dialog box otherwise.
// END_HELP_COMMENT
HWND UIConnectionSettings::Close(void)								
	
	{																
	if(!MST.WButtonEnabled(GetLabel(IDOK)))
			
		{
		LOG->RecordInfo("ERROR in UIConnectionSettings::Close(): "
			  "%s button not enabled", GetLabel(IDOK));
			   
		return MST.WGetActWnd(0);			
		}
									
	MST.WButtonClick(GetLabel(IDOK));							    

	if(WaitUntilGone(3000))		
		return NULL;				
	else
	
		{
		LOG->RecordInfo("ERROR in UIConnectionSettings::Close(): "
			  "settings dlg not gone after 3 seconds");
			   
		return MST.WGetActWnd(0);			
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\uioptdlg.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UITABDLG.CPP
//
//  Created by :            Date :
//      EnriqueP              1/27/94
//				  
//  Description :
//      Implementation of the UIOptionTabDialog class
//

#include "stdafx.h"
//#include "..\sym\vcpp32.h"
#include "uioptdlg.h"
#include "mstwrap.h"
#include "guiv1.h"
#include "..\sym\cmdids.h"
#include "..\sym\vproj.h"
#include "uiwbmsg.h"
#include "..\sym\vshell.h"
#include "uwbframe.h"
#include "..\..\testutil.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: HWND UIOptionsTabDlg::Display() 
// Description: Bring up the Options tabbed dialog.
// Return: The HWND of the Options tabbed dialog.
// END_HELP_COMMENT
HWND UIOptionsTabDlg::Display() 
{	
	AttachActive();		  // Check if is already up
	if (!IsValid())
	{
	 UIWB.DoCommand(IDM_OPTIONS, DC_MNEMONIC);
	 WaitAttachActive(10000);
	}
	return WGetActWnd(0); 
}

// BEGIN_HELP_COMMENT
// Function: HWND UIOptionsTabDlg::ChangeCompatility() 
// Description: Display the compatibility tab of the options dialog.
// Return: int
// END_HELP_COMMENT

int UIOptionsTabDlg::ChangeCompatility(int Scheme)
{
	// Add a 1 to the scheme because schemes are zero based, but MSTest demamds a 1 based.
	Scheme++ ;
	ActivateCompaTab() ;
	MST.WComboItemClk(GetLabel(VCPP32_IDC_EMULATION),Scheme) ;
	MST.DoKeys("{ENTER}") ;
	UIWBMessageBox mbAlert;
	while( mbAlert.WaitAttachActive(1000) )	// if any alerts come up
	{
		if (mbAlert.ButtonExists(mbAlert.m_idOKButton)) 
			MST.DoKeys("{ESC 2}");
		else
		MST.DoKeys("{ENTER}"); // click YES button
    }
	return TRUE ;
}

int UIOptionsTabDlg::ActivateCompaTab()
{

	Display() ;
	ShowPage(TAB_COMPATIBILITY, 8);
	return TRUE ;
}



// BEGIN_HELP_COMMENT
// Function: int UIOptionsTabDlg::AddDirectory( LPCSTR szNewDir, int iDirType, int iPlatform)
// Description: Add a directory to one of the environment variables editable on the Directories tab.
// Return: ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szNewDir A pointer to a string containing the directory to add.
// Param: iDirType The environment variable to set: DIR_DIRTYPE_EXE, DIR_DIRTYPE_INC, DIR_DIRTYPE_LIB.
// Param: iPlatform The platform to set the environment variable for: DIR_PLATFORM_WIN32, DIR_PLATFORM_DUMMY
// END_HELP_COMMENT
int UIOptionsTabDlg::AddDirectory( LPCSTR szNewDir, int iDirType, int iPlatform, int atTop)
{
	Display();
	 
	if (iPlatform != -1)
		SetOption( TAB_DIRECTORIES, DIR_PLATFORM, iPlatform );

	if (iDirType != -1)
		SetOption( TAB_DIRECTORIES, DIR_DIRTYPE, iDirType );

	ShowPage(TAB_DIRECTORIES, 8);

	if (atTop)
	{
		// give focus to the Directories list box (which really isn't a list box so we can't use
		// the MST.WList routines) and select the first item.
		//MST.WComboIteDoKeys("%d{HOME}");
		CString HK = "%" ;
		HK += ExtractHotKey(GetLocString(IDS_DIRECTORIES));
		MST.DoKeys(HK.GetBuffer(HK.GetLength()));
		MST.DoKeys("{HOME}") ;
	}
	else 
	{
		//set focus to empty directory list item & go to bottom.
		// give focus to the Directories list box (which really isn't a list box so we can't use
		// the MST.WList routines) and select the first item.
		//MST.WComboIteDoKeys("%d{END}");
		CString HK = "%" ;
		HK += ExtractHotKey(GetLocString(IDS_DIRECTORIES));
		MST.DoKeys(HK.GetBuffer(HK.GetLength()));
		MST.DoKeys("{END}") ;
	}
	MST.DoKeys(szNewDir); //enter new directory name
	MST.DoKeys("{ENTER}");
		//REVIEW (DorianG): kill the DoKeys crap and do this the right way

	UIWBMessageBox mbAlert;
	while( mbAlert.WaitAttachActive(1000) )	// if any alerts come up
	{
		if (mbAlert.ButtonExists(mbAlert.m_idOKButton)) 
			MST.DoKeys("{ESC 2}");
		else
		MST.DoKeys("{LEFT} "); // click YES button
	}
				   
	//UIWBMessageBox mbAlert;
	//while( mbAlert.WaitAttachActive(1000) )	// if any alerts come up
	//	mbAlert.ButtonClick();				// click default button
	
	// REVIEW(EnriqueP): Add Verification code and return values

	return ERROR_SUCCESS;

}

int UIOptionsTabDlg::ShowDirectoryTab()	 
{
	Display();
	ShowPage(TAB_DIRECTORIES, 8);
	return TRUE ;
}

// BEGIN_HELP_COMMENT
// Function: int UIOptionsTabDlg::RestoreWnd(BOOL state /* = TRUE */)
// Description: Set the state of the 'Restore Window Layout When Opening Projects' option in the Workspace tab.
// Return: ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: state A Boolean value that specifies the state of the option. TRUE to set it to restore the layout; FALSE to unset it. (Default value is TRUE.)
// END_HELP_COMMENT
int UIOptionsTabDlg::RestoreWnd( BOOL state /* = TRUE */)
{
	Display();
	ShowPage(TAB_WORKSPACE, 8);
	if (state)
		MST.WCheckCheck(GetLabel(VSHELL_IDC_AUTO_WORKSPACE)) ;
	else
		MST.WCheckUnCheck(GetLabel(VSHELL_IDC_AUTO_WORKSPACE)) ;

	MST.WButtonClick(GetLabel(IDOK)) ;

	return ERROR_SUCCESS;
}

// BEGIN_HELP_COMMENT
// Function: int UIOptionsTabDlg::SetFont(int FontIndex, int Size /* = 11 */, CString Category /* = NULL*/)
// Description: Set the font in the Font tab by index. (See UIOptionsTabDlg::SetFont(LPCSTR, int, LPCSTR, LPCSTR) to set the font by name.)
// Return: ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: FontIndex An integer that specifies the 1-based index into the list of fonts.
// Param: Size An integer that specifies the point size of the font. This parameter is NYI. (Default value is 11.)
// Param: Category A CString that specifies the category to set the font for. This parameter is NYI.
// END_HELP_COMMENT
int UIOptionsTabDlg::SetFont( int FontIndex, int Size /* = 11 */, CString Category /* = NULL*/)
{
	Display();
	ShowPage("Format");

	MST.WComboItemClk(GetLabel(VSHELL_IDC_COMBO_FONT_NAME),FontIndex) ;
	MST.WButtonClick(GetLabel(IDOK)) ;
	

	return ERROR_SUCCESS;
}

// BEGIN_HELP_COMMENT
// Function: int UIOptionsTabDlg::SetFont(LPCSTR pszFontName /*= NULL*/, int iFontSize /*= 0*/, LPCSTR pszFontStyle /*= NULL*/, LPCSTR pszCategory /*= NULL*/)
// Description: Set the font in the Font tab by name. (See UIOptionsTabDlg::SetFont(int, int, CString) to set the font by index.)
// Return: ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: pszFontName A pointer to a string that contains the name of the font. NULL means use the current font. (Default value is NULL.)
// Param: iFontSize An integer that specifies the point size of the font. 0 means use the current point size. (Default value is 0.)
// Param: pszFontStyle A pointer to a string that contains the name of the font style. NULL means use the current style. (Default value is NULL.)
// Param: pszCategory A pointer to a string that contains the name of the category to set the font for. NULL means use the current category. This parameter is NYI. (Default value is NULL.)
// END_HELP_COMMENT
int UIOptionsTabDlg::SetFont(LPCSTR pszFontName /*= NULL*/, int iFontSize /*= 0*/, LPCSTR pszFontStyle /*= NULL*/, LPCSTR pszCategory /*= NULL*/)
{
	int nResult = ERROR_SUCCESS;
	CString strVerify;
	const int ccBuf = 20;
	char acBuf[ccBuf];

	// display the options tabbed dialog
	Display();

	// go to the font page
	ShowPage("Fonts");

	// set the font category, if specified
	if (pszCategory) {
		// select the category
		MST.WListItemClk(GetLabel(VSHELL_IDC_LIST_WINDOWS), pszCategory);
		// get the category name that was et
		MST.WListText(GetLabel(VSHELL_IDC_LIST_WINDOWS), strVerify);
		// verify the category name was set
		if (strVerify != pszCategory) {
			LOG->RecordInfo("UIOptionsTabDlg::SetFont: unable to set the category to '%s'.", pszCategory);
			nResult = ERROR_ERROR;
		}
	}

	// set the font name, if specified
	if (pszFontName) {
		// select the font name
		MST.WComboItemClk(GetLabel(VSHELL_IDC_COMBO_FONT_NAME), pszFontName);
		// get the font name that was set
		MST.WComboText(GetLabel(VSHELL_IDC_COMBO_FONT_NAME), strVerify);
		// verify the font name was set
		if (strVerify != pszFontName) {
			LOG->RecordInfo("UIOptionsTabDlg::SetFont: unable to set the font name to '%s'.", pszFontName);
			nResult = ERROR_ERROR;
		}
	}

	// set the font size, if specified
	if (iFontSize) {
		// convert the font size to a string
		_itoa(iFontSize, acBuf, 10);
		// select the font size
		MST.WComboItemClk(GetLabel(VSHELL_IDC_COMBO_FONT_SIZE), acBuf);
		// get the font size that was set
		MST.WComboText(GetLabel(VSHELL_IDC_COMBO_FONT_SIZE), strVerify);
		// verify the font size was set
		if (strVerify != acBuf) {
			LOG->RecordInfo("UIOptionsTabDlg::SetFont: unable to set the font size to '%s'.", acBuf);
			nResult = ERROR_ERROR;
		}
	}

	// set the font style, if specified
	// there is not font style currently supported

	// close the dialog
	MST.WButtonClick(GetLabel(IDOK));

	return nResult;
}

int UIOptionsTabDlg::SetAutoIndentMode(int Type /* NONE =0, DEFAULT =1, SMART =3 */)
{
	switch(Type)
	{
	case NONE:
		{
			MST.WOptionClick(GetLabel(VCPP32_IDC_NO_AUTOINDENT));
			break ;
		}
	case DEFAULT:
		{
		 	MST.WOptionClick(GetLabel(VCPP32_IDC_STD_AUTOINDENT));
			break ;
		}
	case SMART:
		{
			MST.WOptionClick(GetLabel(VCPP32_IDC_SMART_AUTOINDENT));
			break ;
		}
	default:
		return ERROR_ERROR ;
	}

	return ERROR_SUCCESS ;
}

int UIOptionsTabDlg::SetSmartIndentOption(int Option, int PrevLine /*= 0 */ )
{
	switch(Option)
	{
	case OPEN:
		{
			MST.WCheckCheck(GetLabel(VCPP32_IDC_INDENT_OPENBRACE));
			break ;
		}
	case CLOSING:
		{
		 	
			MST.WCheckCheck(GetLabel(VCPP32_IDC_INDENT_CLOSEBRACE));
			break ;
		}
		default:
			return ERROR_ERROR ;
	}
	if (PrevLine)
	{
		char acBuf[5] ;
		// convert the font size to a string
		_itoa(PrevLine, acBuf, 10);
		// select the font size

		MST.WEditSetText(GetLabel(VCPP32_IDC_LINES_SCAN_BACK),acBuf );
	}
	return ERROR_SUCCESS;
}			


// BEGIN_HELP_COMMENT
// Function: BOOL UIOptionsTabDlg::ToggleHexDisplay(BOOL bEnable)
// Description: Toggles Hexadecimal display mode
// Param: bEnable If the parameter is TRUE, the Hexadecimal display mode is on. If FALSE - off.
// Return: A Boolean value that indicates whether the toggle operatin was sucessfull (TRUE) or not.
// END_HELP_COMMENT

BOOL UIOptionsTabDlg::ToggleHexDisplay(BOOL bEnable)

{
	// Open the Tools.Options dlg and select the Debug tab.
	if(!ShowDebugTab())
	{
		LOG->RecordInfo("UIOptionsTabDlg::ToggleHexDisplay: unable to display Debug Tab");
		return FALSE;
	}

	// Check the status of the "Hexadecimal display" check box
	int stat = MST.WCheckState("@1");

	if(( stat  && bEnable) || (!stat  && !bEnable))
	{
		OK();
		return TRUE;
	}

	// Check/Uncheck
	if(bEnable)
		MST.WCheckCheck("@1");
	else
		MST. WCheckUnCheck("@1");

	// Check that the "Hexadecimal display" check box was checked\unchecked properly
	stat = MST.WCheckState("@1");

	if(( stat  && bEnable) || (!stat  && !bEnable))
	{	
		OK();
		return TRUE;
	}
	else 
	{	
		Close();
		LOG->RecordInfo("UIOptionsTabDlg::ToggleHexDisplay: Hexadecimal display mode was not set correctly");
		return FALSE;
	}
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIOptionsTabDlg::ToggleSourceAnnotation(BOOL bEnable)
// Description: Toggles Source Annotation
// Param: bEnable If the parameter is TRUE, the Hexadecimal display mode is on. If FALSE - off.
// Return: A Boolean value that indicates whether the toggle operatin was sucessfull (TRUE) or not.
// END_HELP_COMMENT

BOOL UIOptionsTabDlg::ToggleSourceAnnotation(BOOL bEnable)

{
	// Open the Tools.Options dlg and select the Debug tab.
	if(!ShowDebugTab())
	{
		LOG->RecordInfo("UIOptionsTabDlg::ToggleHexDisplay: unable to display Debug Tab");
		return FALSE;
	}

	// Check the status of the "Hexadecimal display" check box
	int stat = MST.WCheckState("@2");

	if(( stat  && bEnable) || (!stat  && !bEnable))
	{
		OK();
		return TRUE;
	}

	// Check/Uncheck
	if(bEnable)
		MST.WCheckCheck("@2");
	else
		MST. WCheckUnCheck("@2");

	// Check that the "Hexadecimal display" check box was checked\unchecked properly
	stat = MST.WCheckState("@2");

	if(( stat  && bEnable) || (!stat  && !bEnable))
	{	
		OK();
		return TRUE;
	}
	else 
	{	
		Close();
		LOG->RecordInfo("UIOptionsTabDlg::ToggleHexDisplay: Hexadecimal display mode was not set correctly");
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\uitabdlg.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UITABDLG.CPP
//
//  Created by :            Date :
//      EnriqueP              2/7/94
//				  
//  Description :
//      Implementation of the UITabbedDialog class
//

#include "stdafx.h"
#include "uitabdlg.h"
#include "..\..\testutil.h"
#include "mstwrap.h"
#include "guiv1.h"
#include "..\sym\vproj.h"
#include "Strings.h"
#include "wbutil.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


//////////////////////////////////////////////////////////////////////////////////

/*
BOOL UITabbedDialog::IsValid(void) const
{
	return UIDialog::IsValid();
}
*/

// BEGIN_HELP_COMMENT
// Function: BOOL UITabbedDialog::VerifyClass(void) const
// Description: Verify that the window class of the tabbed dialog indicated by this object is correct.
// Return: TRUE if the window class is correct; FALSE otherwise.
// END_HELP_COMMENT
BOOL UITabbedDialog::VerifyClass(void) const
{
	char acClass[32];
	GetClassName(HWnd(), acClass, 31);
	return (strnicmp(acClass, "Afx:", 4) == 0) &&
			(GetCurrentPage() != NULL);
}

// BEGIN_HELP_COMMENT
// Function: INT UITabbedDialog::SetOption(INT iTab, UINT iCtrlId, UINT iNewValue) 
// Description: Set the control (iCtrlId) on tab (iTab) to the given value (iNewValue). This function is commonly called for objects of classes derived from UITabbedDialog.
// Return: ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: iTab The tab containing the control to set.
// Param: iCtrlId The ID of the control to set.
// Param: iNewValue The value to set the control to.
// END_HELP_COMMENT
INT UITabbedDialog::SetOption(INT iTab, UINT iCtrlId, UINT iNewValue) 
{
	Display();
	if (!ShowPage( iTab, 8 ) )
		return ERROR_ERROR ;	// if it wasn't found ;

	HWND hCtl = ::GetDlgItem( GetCurrentPage(), iCtrlId) ;

	if (hCtl == NULL)	// If not found in Page look inside visible category
		hCtl = ::GetDlgItem( GetCurrentMiniPage(), iCtrlId) ;

	if (hCtl == NULL)
	{
		LOG->RecordFailure("Control was not found in this dialog");
		return ERROR_ERROR;
	}

	CString szLabel ;
	
    szLabel = GetLabel(iCtrlId) ;	   // We need the label, to call MSTest APIs.
 
	switch (GetDlgControlClass(hCtl))
	{
		case(GL_CHECKBOX): 
		{
			if(iNewValue)
		 		MST.WCheckCheck(szLabel) ;	
			else 
				MST.WCheckUnCheck(szLabel) ;
		}
		break ;
		case(GL_RADIOBUTTON):
			if(iNewValue)
		 		MST.WOptionClick(szLabel) ;	
		break ;
		case (GL_BUTTON):
		 	if(iNewValue)
				MST.WButtonClick(szLabel) ;
		break ;
		case(GL_COMBOBOX):
			MST.WComboItemClk(szLabel, iNewValue );
		break ;
		case (GL_LISTBOX):
		 	MST.WListItemClk(szLabel, iNewValue );
		break ;
		case (GL_EDIT):
			MST.WEditClick(szLabel) ;	
		break ;

		default:
			LOG->RecordFailure("SetOption() can't set this type of control");
			return ERROR_ERROR ; 
	}

	return ERROR_SUCCESS ; 		   

}



// BEGIN_HELP_COMMENT
// Function: int UITabbedDialog::SetOption(INT iTab, UINT iCtrlId, LPCSTR szNewValue)
// Description: Set the control (iCtrlId) on tab (iTab) to the given value (szNewValue). This function is commonly called for objects of classes derived from UITabbedDialog.
// Return: ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: iTab The tab containing the control to set.
// Param: iCtrlId The ID of the control to set.
// Param: szNewValue A pointer to a string containing the value to set the control to.
// END_HELP_COMMENT
int UITabbedDialog::SetOption(INT iTab,UINT iCtrlId, LPCSTR szNewValue)
 {
	Display();
	if (!ShowPage(iTab,8) ) // if it wasn't found ;
		return ERROR_ERROR ;

	HWND hCtl = ::GetDlgItem( GetCurrentPage(), iCtrlId) ;

	if (hCtl == NULL)	// If not found in Page look inside visible category
		hCtl = ::GetDlgItem( GetCurrentMiniPage(), iCtrlId) ;

	if (hCtl == NULL)
	{
		LOG->RecordFailure("Control was not found in this dialog");
		return ERROR_ERROR;
	}

	CString szLabel, szNewText ;		  	
	int iCtrlClass ;
	szNewText = szNewValue ;
	
	szLabel = GetLabel(iCtrlId) ; 	 // We need the label, to call MSTest APIs.

	iCtrlClass = GetDlgControlClass(hCtl) ;
	// Determine the control class type
	switch (GetDlgControlClass(hCtl))
	{
		case(GL_COMBOBOX):
			MST.WComboItemDblClk(szLabel, szNewValue) ;	
		break ;
		case (GL_LISTBOX): 
			MST.WListItemDblClk(szLabel, szNewValue) ;	
		break ;
		case (GL_EDIT):
			MST.WEditSetText( szLabel, szNewText ) ;	
		break ;
  		default:
		return ERROR_ERROR ;
	}

	return ERROR_SUCCESS ; 
}


// BEGIN_HELP_COMMENT
// Function: int UITabbedDialog::GetOption(INT iTab, UINT iCtrlId)
// Description: Get the value of the control (iCtrlId) on tab (iTab). This function is commonly called for objects of classes derived from UITabbedDialog.
// Return: The value of the control, if successful; ERROR_ERROR otherwise.
// Param: iTab The tab containing the control to get.
// Param: iCtrlId The ID of the control to get.
// END_HELP_COMMENT
int UITabbedDialog::GetOption(INT iTab, UINT iCtrlId)
{
	Display();
	if (!ShowPage(iTab,8) ) // if tab wasn't found ;
		return ERROR_ERROR ;

	HWND hCtl = ::GetDlgItem( GetCurrentPage(), iCtrlId) ;

	if (hCtl == NULL)	// If not found in Page look inside visible category
		hCtl = ::GetDlgItem( GetCurrentMiniPage(), iCtrlId) ;

	if (hCtl == NULL)
	{
		LOG->RecordFailure("Control was not found in this dialog");
		return ERROR_ERROR;
	}

    CString szLabel ;
	szLabel = GetLabel(iCtrlId) ; 	   // We need the label, to call MSTest APIs.
	switch (GetDlgControlClass(hCtl))
	{
		case(GL_CHECKBOX): 
			 return MST.WCheckState(szLabel);  // -1 = doesn't exist, 0 = unchecked, 1 = checked, 2 = grayed
		
		case(GL_RADIOBUTTON):
			return MST.WOptionState(szLabel);  // -1 = doesn't exist, 0 = unselected, 1 = selected
		
		case(GL_COMBOBOX):
			return MST.WComboIndex(szLabel);  // returns selection index, returns 0 if there is no text selected in combo box

		case (GL_LISTBOX):
		 	return MST.WListIndex(szLabel);  // returns selection index, returns 0 if there is no text selected in combo box

		default:
			return ERROR_ERROR ; 
	}

}
	
// BEGIN_HELP_COMMENT
// Function: LPCSTR UITabbedDialog::GetOptionStr(INT iTab, UINT iCtrlId)
// Description: Get the value of the control (iCtrlId) on tab (iTab). This function is commonly called for objects of classes derived from UITabbedDialog.
// Return: A pointer to a string containing the value of the control, if successful; NULL otherwise.
// Param: iTab The tab containing the control to get.
// Param: iCtrlId The ID of the control to get.
// END_HELP_COMMENT
LPCSTR UITabbedDialog::GetOptionStr(INT iTab, UINT iCtrlId)
{
	Display();
	if (!ShowPage(iTab,8) ) // if tab wasn't found ;
		return NULL ;
	static char szContents[50];
	
	HWND hCtl = ::GetDlgItem( GetCurrentPage(), iCtrlId) ;

	if (hCtl == NULL)	// If not found in Page look inside visible category
		hCtl = ::GetDlgItem( GetCurrentMiniPage(), iCtrlId) ;

	if (hCtl == NULL)
	{
		LOG->RecordFailure("Control was not found in this dialog");
		return NULL;
	}

    CString szLabel, strContents;		
	szLabel = GetLabel(iCtrlId) ;			// We need the label, to call MSTest APIs.					 
	switch (GetDlgControlClass(hCtl))
	{
		case (GL_EDIT): 
			MST.WEditText(szLabel, strContents);
			break;
		case (GL_COMBOBOX):
			MST.WComboText(szLabel, strContents);
			break;
		case (GL_LISTBOX):
		 	MST.WListText(szLabel, strContents);
			break;		
		default:
			LOG->RecordInfo("GetOptionStr does not work with this type of control");
			return NULL;
	}

	lstrcpy(szContents, strContents.GetBuffer(50));
	strContents.ReleaseBuffer(-1);
	return szContents;
}
	
 
// BEGIN_HELP_COMMENT
// Function: HWND UITabbedDialog::ShowPage(int iCtrlID, int iTabCnt)
// Description: Activate the tab on a tabbed dialog that contains the control given by iCtrlID.
// Return: The HWND of the tab on the tabbed dialog, if successful; NULL otherwise.
// Param: iCtrlID The ID of a control on the desired tab.
// Param: iTabCnt The position number of the tab.
// END_HELP_COMMENT
HWND UITabbedDialog::ShowPage(int iCtrlID, int iTabCnt)
{
	Display();
	if (iCtrlID == TAB_CURRENT)
		return GetCurrentPage();			 

/*	HWND hActive = ControlOnPropPage(iCtrlID) ;
	if((hActive)&& (IsWindowVisible(hActive)))
	   		return GetCurrentPage() ;	 */

	if (IsControlInCurrentPage(iCtrlID))
			return GetCurrentPage();		 // Check if the page happens to be selected
		
	//Make sure that focus is not on some control inside the dialog. 
	//Always first activate the first page, then start the search.
	
	HWND hPage = GetCurrentPage();
	//RECT rcPage;
	//GetClientRect(hPage, &rcPage);
	// REVIEW (michma): need to click twice because as of 5095 clicking
	// only once leaves focus inside page and not on tabs so cursor-left/right
	// and ctrl-pgup/pgdn circulate through page controls and not tabs.
//	ClickMouse( VK_LBUTTON ,hPage, rcPage.left+50, rcPage.top - 15 );	  // Click on first Tab	(left most)
//	ClickMouse( VK_LBUTTON ,hPage, rcPage.left+50, rcPage.top - 15 );	  // Click on first Tab	(left most)
	
	hPage = GetCurrentPage();
	HWND hNextPage = NULL;
	while (	hPage != hNextPage)
	{
		if (IsControlInCurrentPage(iCtrlID))
			return GetCurrentPage();
		
		hNextPage = ActivateNextPage();
	}

	LOG->RecordInfo("UITabbedDialog::ShowPage(%d, %d) - The Page was not found", iCtrlID, iTabCnt);
	return NULL;
	
} 


// BEGIN_HELP_COMMENT
// Function: HWND UITabbedDialog::ShowPage(LPCSTR szTabCaption)
// Description: Activate the tab on a tabbed dialog that has the caption specified by szTabCaption.
// Return: The HWND of the tab on the tabbed dialog, if successful; NULL otherwise.
// Param: szTabCaption A pointer to a string that contains the caption of the tab.
// END_HELP_COMMENT
HWND UITabbedDialog::ShowPage(LPCSTR szTabCaption)
{
	Display();
	CString strCaption = szTabCaption;
	CString strCurCaption;
	if (strCaption.IsEmpty())
		return GetCurrentPage();
	
	HWND hStartPage = GetCurrentPage();
	HWND hPage = GetCurrentPage();
	HWND hNextPage = NULL;

	char szCaption[40];

	while (	hStartPage!= hNextPage)
	{
		hPage = GetCurrentPage();
		GetWindowText(hPage, szCaption, 40);
		strCurCaption = szCaption;
		if (strCurCaption == szTabCaption)
			return GetCurrentPage();
		hNextPage = ActivateNextPage();
	}

	LOG->RecordInfo("UITabbedDialog::ShowPage(\"%s\") - The Page was not found", szTabCaption);
	return NULL;
}

// BEGIN_HELP_COMMENT
// Function: HWND UITabbedDialog::GetCurrentPage() const
// Description: Get the currently displayed tab on a tabbed dialog.
// Return: The HWND of the current tab on the tabbed dialog, if successful; NULL otherwise.
// END_HELP_COMMENT
HWND UITabbedDialog::GetCurrentPage() const
{
	HWND hwnd = GetWindow(HWnd(), GW_CHILD);	// Get First window child
	char acClass[32];
	while (hwnd)								// Search among siblings to find dialog page
	{
		::GetClassName(hwnd, acClass, 31);
		if( strcmp(acClass, "#32770") == 0 )
		{
			if ( ::GetWindowLong(hwnd, GWL_STYLE) & WS_VISIBLE)
				return hwnd; 							// Return the page that is visible
		}
		hwnd = GetWindow(hwnd, GW_HWNDNEXT);		
	}
								
	return NULL;  								// No Visible page was found  (who knows why)
}

HWND UITabbedDialog::GetCurrentMiniPage() const
{
	HWND hwnd = GetCurrentPage();	// Get First window child
	hwnd = 	GetWindow(hwnd, GW_CHILD);
	char acClass[32];
	while (hwnd)								// Search among siblings to find dialog page
	{
		::GetClassName(hwnd, acClass, 31);
		if( strcmp(acClass, "#32770") == 0 )
		{
			if ( ::GetWindowLong(hwnd, GWL_STYLE) & WS_VISIBLE)
				return hwnd; 							// Return the page that is visible
		}
		hwnd = GetWindow(hwnd, GW_HWNDNEXT);		
	}
								
	return NULL;  								// No Visible page was found  (who knows why)
}


// BEGIN_HELP_COMMENT
// Function: BOOL UITabbedDialog::IsControlInCurrentPage(UINT iCtrlId) const
// Description: Determine if a control is on the currently displayed tab of a tabbed dialog.
// Return: TRUE if the control is on the current tab; FALSE otherwise.
// Param: iCtrlId The ID of the control to search for.
// END_HELP_COMMENT
BOOL UITabbedDialog::IsControlInCurrentPage(UINT iCtrlId) const
{
	HWND hCtrl = ::GetDlgItem(GetCurrentPage(), iCtrlId); // Look for control

	// REVIEW:  temporary hack!!!!! and with a little luck...
	// debug tab now has categories - like compiler/linker tab.
	// need to create a SetDebugOption()
	if ( (hCtrl == NULL) && (iCtrlId == VPROJ_IDC_REMOTE_TARGET) )
	{	// look inside visible category
		hCtrl = ::GetDlgItem(GetCurrentMiniPage(), iCtrlId);
	}

	if (hCtrl == NULL)
	{
		return FALSE;
	}
	if ( ::GetWindowLong(hCtrl, GWL_STYLE) & WS_VISIBLE)                                
		return TRUE; 							 
	else
	{
		//LOG->RecordInfo("The control is not visible but exists in the current Page");
		return FALSE;
	}		
}


// BEGIN_HELP_COMMENT
// Function: LPCSTR UITabbedDialog::GetLabel(UINT nCtrlId) const
// Description: Get the label for the control specified by nCtrlId. This function is overridden for tabbed dialogs because controls are often contained within subdialogs.
// Return: A pointer to a string containing the label of the control.
// Param: nCtrlId The ID of the control to retrieve the label for.
// END_HELP_COMMENT
LPCSTR UITabbedDialog::GetLabel(UINT nCtrlId) const
{
	HWND hwnd = GetCurrentPage();
	LPCSTR sz = NULL;
	if( hwnd != NULL )
		sz = ::GetLabel(nCtrlId, hwnd, TRUE );		// Find label for control in the current page
	
	if( sz != NULL )
		return sz;
	else
	{
		hwnd = GetCurrentMiniPage();
		if( hwnd != NULL )
			sz = ::GetLabel(nCtrlId, hwnd, TRUE );	// Find label for control in the current category
		if( sz != NULL )
			return sz;
		else
			return ::GetLabel(nCtrlId );		 	// Look in main dialog if it doesn't work
	}		
}


// BEGIN_HELP_COMMENT
// Function: HWND UITabbedDialog::ActivateNextPage( BOOL bRight /* TRUE */)
// Description: Activate the next or previous tab in a tabbed dialog.
// Return: The HWND of the tab on the tabbed dialog, if successful; NULL otherwise.
// Param: bRight TRUE to activate the tab to the right (next); FALSE to activate the tab to the left (previous). (Default is TRUE.)
// END_HELP_COMMENT
HWND UITabbedDialog::ActivateNextPage( BOOL bRight /* TRUE */)
{
	if ( !bRight )
		MST.DoKeys ("^{PGUP}") ;
	else
		MST.DoKeys("^{PGDN}");
	
	Sleep(50)  ;
	
	// if msdn isn't installed, then activating the help system page for the first time
	// brings up a vs help dlg that we need to dismiss.
	if(MST.WFndWndWait(GetLocString(IDSS_VS_HELP_TITLE), FW_DEFAULT, 1))
		MST.DoKeys("{ENTER}");

	return GetCurrentPage(); 
}	 


// BEGIN_HELP_COMMENT
// Function: HWND UITabbedDialog::ShowNextPage(int iCtrlID)
// Description: Display the next tab in a tabbed dialog that contains the control specified by iCtrlID.
// Return: The HWND of the tab on the tabbed dialog, if successful; NULL otherwise.
// Param: iCtrlID The ID of the control that identifies the tab.
// END_HELP_COMMENT
HWND UITabbedDialog::ShowNextPage(int iCtrlID)
{
	// We assume that the tab has the focus, otherwise the arrow key right won't do the right thing
	Display();
	if (iCtrlID == TAB_CURRENT)
		return GetCurrentPage();
			 
	ActivateNextPage();
		
	HWND hPage = GetCurrentPage();
	HWND hNextPage = NULL;
	while (	hPage != hNextPage)
	{
		if (IsControlInCurrentPage(iCtrlID))
			return GetCurrentPage();
		
		hNextPage = ActivateNextPage();
	}

	LOG->RecordInfo("UITabbedDialog::ShowPage(%d) - The Page was not found", iCtrlID);
	return NULL;
}    	  

// BEGIN_HELP_COMMENT
// Function: HWND UITabbedDialog::GetDlgItem(UINT id) const
// Description: Get the HWND of a window (control) on the currently active tab in a tabbed dialog. This function is overridden for tabbed dialogs because windows (controls) are often contained within subdialogs.
// Return: The HWND of the window (control).
// Param: id The ID of the window (control) to find.
// END_HELP_COMMENT
HWND UITabbedDialog::GetDlgItem(UINT id) const
{
	HWND hwnd = UIDialog::GetDlgItem(id);
	if( hwnd != NULL )
		return hwnd;
	else
		return ::GetDlgItem(GetCurrentPage(),id);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\uitabdlg.h ===
///////////////////////////////////////////////////////////////////////////////
//  UITABDLG.H
//
//  Created by :            Date :
//      EnriqueP              2/7/94
//
//  Description :
//      Declaration of the UITabbedDialog class
//

#ifndef __UITABDLG_H__
#define __UITABDLG_H__

#include "..\..\udialog.h"

#include "shlxprt.h"

#ifndef __UIDIALOG_H__
	#error include 'udialog.h' before including this file
#endif

#define ERROR_ERROR -1
#define TAB_CURRENT  		-1     // Used by ShowPage to leave the current tab visible

///////////////////////////////////////////////////////////////////////////////
//  UITabbedDialog class

// BEGIN_CLASS_HELP
// ClassName: UITabbedDialog
// BaseClass: UIDialog
// Category: Shell
// END_CLASS_HELP
class SHL_CLASS UITabbedDialog : public UIDialog
{
    UIWND_COPY_CTOR (UITabbedDialog, UIDialog) ; 

// Overrided Utilities
public:
	virtual BOOL VerifyClass(void) const;
	virtual LPCSTR GetLabel(UINT nCtrlId) const;
	virtual HWND GetDlgItem(UINT id) const;

// Utilities
// The utilites in the class assume that the tabbed dialog is already displayed and has focus.
public:
	HWND hActive ;

//		virtual BOOL IsValid(void) const;
	virtual HWND Display(void) {return NULL; }; // Should be implemented by all deriving classes	
	virtual int SetOption(INT iTab, UINT iCtrlId, UINT iNewValue) ;
	virtual int SetOption(INT iTab, UINT iCtrlId, LPCSTR szNewValue) ;
	virtual int GetOption(INT iTab, UINT iCtrlId);
	virtual LPCSTR GetOptionStr(INT iTab, UINT iCtrlId);
	virtual HWND ShowPage(int iCtrlID, int iTabCount) ;	// Used if Tab caption can't be read
	virtual HWND ShowPage(LPCSTR szTabCaption) ;   // Used fot Tabs that have a window caption.
	virtual HWND GetCurrentPage(void) const;
	virtual HWND GetCurrentMiniPage(void) const;
	virtual BOOL IsControlInCurrentPage(UINT iCtrlId) const;
	virtual HWND ShowNextPage(int iCtrlID);
		
//	protected:
	virtual HWND ActivateNextPage(BOOL bRight = TRUE) ;
   } ;

#endif //__UITABDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\uitipdlg.cpp ===
//////////////////////////////
//  UITIPDLG.CPP
//
//  Created by :            Date :
//      BrianCr				07/11/95
//
//  Description :
//      Implementation of the UITipDialog class
//

#include "stdafx.h"
#include "uitipdlg.h"
#include "..\sym\cmdids.h"
#include "mstwrap.h"
#include "uwbframe.h"
#include "guiv1.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: BOOL UITipDialog::Display(void)
// Description: Bring up the Tip of the Day dialog.
// Return: TRUE if the Tip of the Day dialog is displayed; FALSE otherwise.
// END_HELP_COMMENT
BOOL UITipDialog::Display(void)
{
	const char* const THIS_FUNCTION = "UITipDialog::Display";
	
	if ( MST.WFndWndWait(GetLocString(IDSS_TIP_TITLE), FW_PART, 1) != 0 )
		// the dialog's already up
		return TRUE;

	UIWB.DoCommand(IDM_HELP_TIPOFTHEDAY, DC_MNEMONIC);	
	
	if ( MST.WFndWndWait(GetLocString(IDSS_TIP_TITLE), FW_PART, 1) == 0)
	{
		LOG->RecordInfo("%s: Tip of the Day dialog was not displayed.", THIS_FUNCTION);
		return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\uiwbdlg.h ===
///////////////////////////////////////////////////////////////////////////////
//  UIWBDLG.H
//
//  Created by :            Date :
//      DavidGa                 9/20/93
//
//  Description :
//      Declaration of the UIWBDialog class
//

#ifndef __UIWBDLG_H__
#define __UIWBDLG_H__

#include "..\..\udialog.h"

#include "shlxprt.h"

#ifndef __UIDIALOG_H__
    #error include 'udialog.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
// UIWBDialog class

// BEGIN_CLASS_HELP
// ClassName: UIWBDialog
// BaseClass: UIDialog
// Category: Shell
// END_CLASS_HELP
class SHL_CLASS UIWBDialog : public UIDialog
{
	UIWBDialog(LPCSTR szTitle);
	UIWND_COPY_CTOR(UIWBDialog, UIDialog);

// Data
protected:

// Utilities
public:

// Standard buttons
    virtual HWND Close(void);
    virtual HWND Help(void);
};

#endif //__UIWBDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\uiwbmsg.h ===
///////////////////////////////////////////////////////////////////////////////
//   UIWBMSG.H
//
//  Created by :            Date :
//      DavidGa                 1/21/94
//
//  Description :
//      Declaration of the  UIWBMessageBox class
//

#ifndef __UIWBMSG_H__
#define __UIWBMSG_H__

#include "..\..\umsgbox.h"

#include "shlxprt.h"

#ifndef __UIMSGBOX_H__
    #error include 'umsgbox.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
//   UIWBMessageBox class

// BEGIN_CLASS_HELP
// ClassName: UIWBMessageBox
// BaseClass: UIMessageBox
// Category: Shell
// END_CLASS_HELP
class SHL_CLASS UIWBMessageBox : public  UIMessageBox
{
     UIWND_COPY_CTOR( UIWBMessageBox,  UIMessageBox);

// Utilities
public:
	virtual BOOL IsValid(void) const;
};

#endif //__UIWBMSG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\uiwbdlg.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UIWBDLG.CPP
//
//  Created by :            Date :
//      DavidGa                 9/20/93
//
//  Description :
//      Declaration of the UIWBDialog class
//

#include "stdafx.h"
#include "uiwbdlg.h"
#include "testxcpt.h"
#include "..\..\testutil.h"
#include "mstwrap.h"
#include "wbutil.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

UIWBDialog::UIWBDialog(LPCSTR szTitle)
: UIDialog(szTitle)
{
}

// BEGIN_HELP_COMMENT
// Function: HWND UIWBDialog::Close(void)
// Description: Close an IDE dialog.
// Return: NULL if the dialog closed successfully; the HWND of a message box otherwise.
// END_HELP_COMMENT
HWND UIWBDialog::Close(void)
{
	ExpectValid();

	if( MST.WButtonExists(GetLocString(IDSS_CLOSE)) )	
		MST.WButtonClick(GetLocString(IDSS_CLOSE));		// use the close button if there is one
	else if( MST.WButtonExists(GetLabel(IDOK) ))		// use the OK button if not 
		MST.WButtonClick(GetLabel(IDOK));				// makes sure changes are commited
		else
			PostMessage(HWnd(), WM_CLOSE, 0, 0);		// otherwise, close it however we must

	if( WaitUntilGone(3000) )		// REVIEW(davidga) 3000 is too arbitrary
		return NULL;				// NULL means all is well
	else
		return MST.WGetActWnd(0);	// an HWND presumes some alert came up
}

// BEGIN_HELP_COMMENT
// Function: HWND UIWBDialog::Help(void)
// Description: Bring up help from an IDE dialog. This function clicks the Help button on the dialog.
// Return: The HWND of the help window, if successful; NULL otherwise.
// END_HELP_COMMENT
HWND UIWBDialog::Help(void)
{
	ExpectValid();

	if( !MST.WButtonExists(GetLocString(IDSS_HELP)) )
		return NULL;
	MST.WButtonClick (GetLocString(IDSS_HELP));

	int n = 0;
	while( MST.WGetActWnd(0) == HWnd() )
	{
		if( n++ > 10 )		
			return NULL;	// no new window popped up within 10 seconds
		Sleep(1000);
	}
	return MST.WGetActWnd(0);	// return HWND of Help window
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\uiwbmsg.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UIWBMSG.CPP
//
//  Created by :            Date :
//      DavidGa                 1/21/94
//
//  Description :
//      Implementation of the UIWBMessageBox class
//

#include "stdafx.h"
#include "uiwbmsg.h"
#include "wbutil.h"
#include "uwbframe.h"
#include "Strings.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

///////////////////////////////////////////////////////////////////////////////
//  UIWBMessageBox class

/*	IsValid
 *		I'd like a better way to verify this, but at the moment this will have to do.
 *		A Valid MSVC messagebox is a popup window with the exact caption,
 *		"Microsoft Visual C++", and it isn't the IDE.
 */
// BEGIN_HELP_COMMENT
// Function: BOOL UIWBMessageBox::IsValid(void) const
// Description: Determine if the active message box is a valid IDE message box.
// Return: TRUE if the message box is valid; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWBMessageBox::IsValid(void) const
{
	if( !UIMessageBox::IsValid() )
		return FALSE;
	return (GetText() == GetLocString(IDSS_WORKBENCH_TITLEBAR)) && (HWnd() != UIWB.HWnd());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\uitipdlg.h ===
//////////////////////////////
//  UITIPDLG.H
//
//  Created by :            Date :
//      BrianCr				07/12/95
//
//  Description :
//      Declaration of the UITipDialog class
//

#ifndef __UITIPDLG_H__
#define __UITIPDLG_H__

#include "..\..\udialog.h"
#include "wbutil.h"

#include "shlxprt.h"

#ifndef __UIDIALOG_H__
   #error include 'udialog.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
// UITipDialog class declaration

// BEGIN_CLASS_HELP
// ClassName: UITipDialog
// BaseClass: UIDialog
// Category: Shell
// END_CLASS_HELP
class SHL_CLASS UITipDialog : public UIDialog
{
   	UIWND_COPY_CTOR (UITipDialog, UIDialog) ;

	virtual CString ExpectedTitle (void) const
		{	return GetLocString(IDSS_TIP_TITLE); }

// Utilities
public:
	BOOL Display(void);
		
};			

#endif //__UITIPDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\uopenwrk.h ===
//////////////////////////////
//  UOPENWRK.H
//
//  Created by :            Date :
//      BrianCr				07/12/95
//
//  Description :
//      Declaration of the UIOpenWorkspaceDlg class
//

#ifndef __UOPENWRK_H__
#define __UOPENWRK_H__

#include "ucommdlg.h"
#include "wbutil.h"

#include "shlxprt.h"

#ifndef __UICOMMDLG_H__
   #error include 'ucommdlg.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
// UIOpenWorkspaceDlg class declaration

// BEGIN_CLASS_HELP
// ClassName: UIOpenWorkspaceDlg
// BaseClass: UIFileDlg
// Category: Shell
// END_CLASS_HELP
class SHL_CLASS UIOpenWorkspaceDlg : public UIFileDlg
{
   	UIWND_COPY_CTOR(UIOpenWorkspaceDlg, UIFileDlg) ;

	virtual CString ExpectedTitle (void) const
		{	return GetLocString(IDSS_OPENWRKDLG_TITLE); }

// Utilities
public:
	BOOL Display(void);
};			

#endif //__UOPENWRK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\umainfrm.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	UMAINFRM.CPP
//
//	Created by :			Date :
//		DavidGa					9/20/93
//
//	Description :
//		Declaration of the UIWindow class
//

#include "stdafx.h"
#include "umainfrm.h"
#include "guiv1.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "wbutil.h"
#include "..\..\imewrap.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

void UIMainFrm::OnUpdate(void)
{
	m_pCmdTable = FALSE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIMainFrm::IsValid(void) const
// Description: Determine if the IDE's main frame window is a valid window.
// Return: TRUE if the main frame is valid; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIMainFrm::IsValid(void) const
{
	return UIWindow::IsValid();
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIMainFrm::DoCommand(UINT id, DC_METHOD method)
// Description: Perform a command in the IDE. Most of the commands handled by this function are menu commands, which can be performed either by sending a message, selecting the menu items, using the menu mnemonics, or using the keyboard accelerator.
// Return: TRUE if the command was performed; FALSE otherwise.
// Param: id The ID of the command to perform. See cmdarrray.cpp for the set of valid commands.
// Param: method The method by which to perform the action: DC_MESSAGE, DC_MENU, DC_MNEMONIC, DC_ACCEL.
// END_HELP_COMMENT
BOOL UIMainFrm::DoCommand( UINT id, DC_METHOD method)
{
	const char* const THIS_FUNCTION = "UIMainFrm::DoCommand";
	UINT ime_mode;

	// be sure the command table is valid
	ASSERT(m_pCmdTable != NULL);

	// search for the command in the command table
	for (int index = 0; m_pCmdTable[index].idCommand != 0; index++) {
		// is this the command?
		if (m_pCmdTable[index].idCommand == id) {
			CMD_STRUCT* pCmd = &(m_pCmdTable[index]);
			// perform the command using whatever method was specified
			switch (method) {
				// perform the command by sending a message
				case DC_MESSAGE: {
					WaitStepInstructions("PostMessage WM_COMMAND, wParam == 0x%X", id);
					return !PostMessage(HWnd(), WM_COMMAND, pCmd->idCommand, 0L);
					break;
				}
				// perform the command by selecting the menus
				case DC_MENU: {  // ERROR ERROR ERROR ERROR DC_MENU doesn't work it's converted to DC_MNEMONIC
					// be sure at least one menu string exists for this command
                                      ASSERT(pCmd->idMenu[0] != 0);

					// build a menu string for DoMenu (a series of null-separated menu names
					char szMenu[1024];
					char* pc = szMenu;
					for (int i = 0; i < 3; i++) {
						if (pCmd->idMenu[i] != 0) {
							CString str = GetLocString(pCmd->idMenu[i]);
							strcpy(pc, str);
							pc += str.GetLength() + 1;
						}
					}
					*pc = '\0';

					return !DoMenu(szMenu);
                                        break;
				}
				// perform the command by using the mnemonics
				case DC_MNEMONIC:{
					// in order to access the menu items in any other emulation modes other than VC,
					// we need to do Alt by itself and then the remaining keystrokes to access the menu item.
					// Doing Alt by itself doesn't work in all cases. Sometimes the Alt by itself is swallowed by
					// the IDE, so we'll do Alt+space+esc to activate the menu bar.
					// is the first character an Alt?

					if(IME.IsIMEInUse())					
					
					{
						// REVIEW (michma - 6/3/98)
						// sometimes calling the ime here de-activates the active window (for example, when using the
						// Edit.Goto dialog). so we preserve the active handle here for possible re-activation later.
						HWND hWndActiveBefore = MST.WGetActWnd(0);

						ime_mode = IME.GetMode();
						IME.SetMode();
						IME.Open(FALSE);

						HWND hWndActiveAfter = MST.WGetActWnd(0);

						if(hWndActiveAfter != hWndActiveBefore)
							MST.WSetActWnd(hWndActiveBefore);
					}

					if ((pCmd->szMnemonic[0] == '%')|| (pCmd->szMnemonic[0] == NULL)) {
					// build a menu string for DoMenu (a series of null-separated menu names
					char szMenu[1024];
					char* pc = szMenu;
					CString Menu ;
					for (int i = 0; i < 3; i++) {
						if (pCmd->idMenu[i] != 0) {
							CString str = GetLocString(pCmd->idMenu[i]);
							strcpy(pc, str);
							pc += str.GetLength() + 1;
							Menu += str ;
						}
					
					}
					*pc = '\0';
					//Find the mnemonics from the string and use them.
					//CString Menu = pc ;
					
					CString HotKeys, Alt = "%";
					HotKeys = Alt+ ExtractHotKey(Menu) ;
					Menu = szMenu ;
					// do the Alt
					CString FileMenu = GetLocString(IDS_FILEMENU) ;
					FileMenu = Alt+ ExtractHotKey(FileMenu) + "{esc}" ;

					MST.DoKeyshWnd(HWnd(), FileMenu.GetBuffer(FileMenu.GetLength())) ; // "%f{esc}");
					// Perform the desired command.
					MST.DoKeyshWnd(HWnd(), HotKeys.GetBuffer(HotKeys.GetLength()));
					}
					else {  // If the string contained an accelerator sequence instead.
						MST.DoKeyshWnd(HWnd(), pCmd->szMnemonic);	// REVIEW(davidga): could use DoKeyshWnd()
					}

					if(IME.IsIMEInUse())					
					
					{
						// REVIEW (michma - 6/3/98)
						// sometimes calling the ime here de-activates the active window (for example, when using the
						// Edit.Goto dialog). so we preserve the active handle here for possible re-activation later.
						HWND hWndActiveBefore = MST.WGetActWnd(0);
						
						IME.Open();
						IME.SetMode(ime_mode);

						HWND hWndActiveAfter = MST.WGetActWnd(0);

						if(hWndActiveAfter != hWndActiveBefore)
							MST.WSetActWnd(hWndActiveBefore);
					}

					return TRUE;
					}
					
				// perform the command by using the accelerator
				case DC_ACCEL: {
					// be sure an accelerator is defined for this command
					ASSERT(pCmd->szAccel != NULL);
					MST.DoKeys(pCmd->szAccel);
					return TRUE;
					break;


				}
				default: {
					ASSERT(FALSE);	// Did we forget to add a new case?
					return 0;
					break;
				}
			}
		}
	}
	LOG->RecordInfo("%s: command %d not found in the command table.", THIS_FUNCTION, id);
	return FALSE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIMainFrm::IsCommandEnabled(UINT id)
// Description: Determine if the specified command is enabled in the IDE.
// Return: TRUE if the command is enabled; FALSE otherwise.
// Param: id The ID of the command to check. See cmdarrray.cpp for the set of valid commands.
// END_HELP_COMMENT
BOOL UIMainFrm::IsCommandEnabled(UINT id)
{
	const char* const THIS_FUNCTION = "UIMainFrm::IsCommandEnabled";

	// be sure the command table is valid
	ASSERT(m_pCmdTable != NULL);

	// search for the command in the command table
	for (int index = 0; m_pCmdTable[index].idCommand != 0; index++) {
		// is this the command?
		if (m_pCmdTable[index].idCommand == id) {
			CMD_STRUCT* pCmd = &(m_pCmdTable[index]);
			// be sure at least one menu string exists for this command
			ASSERT(pCmd->idMenu[0] != 0);

			for (int i = 0; i < 3; i++) {
				if (pCmd->idMenu[i] != 0) {
					Sleep(400);
					// if the menu item's not enabled, close all menus and return fail
					BOOL bEnabled = MST.WMenuEnabled(GetLocString(pCmd->idMenu[i]));
					if (!bEnabled) {
						MST.WMenuEnd();
						return FALSE;
					}
					// if there are more menu items to check, select this one
					if (i < 2 && pCmd->idMenu[i+1]) {
						MST.WMenu(GetLocString(pCmd->idMenu[i]));
					}
					// otherwise the menu item's enabled
					else {
						MST.WMenuEnd();
						return TRUE;
					}
				}
			}
		}
	}

	LOG->RecordInfo("%s: command %d not found in command table.", THIS_FUNCTION, id);
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\uopenwrk.cpp ===
//////////////////////////////
//  UOPENWRK.CPP
//
//  Created by :            Date :
//      BrianCr				07/26/95
//
//  Description :
//      Implementation of the UIOpenWorkspaceDlg class
//

#include "stdafx.h"
#include "uopenwrk.h"
#include "..\sym\cmdids.h"
#include "mstwrap.h"
#include "uwbframe.h"
#include "guiv1.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: BOOL UIOpenWorkspaceDlg::Display(void)
// Description: Bring up the Open Workspace dialog.
// Return: TRUE if the Open Workspace dialog is displayed; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIOpenWorkspaceDlg::Display(void)
{
	const char* const THIS_FUNCTION = "UIOpenWorkspaceDlg::Display";
	
	// is the dialog already displayed?
	AttachActive();
	if (!IsValid()) {
		UIWB.DoCommand(IDM_OPEN_WORKSPACE, DC_MNEMONIC);
		WaitAttachActive(2000);
	}
	BOOL bDisplayed = IsValid();
	if (!bDisplayed) {
		LOG->RecordInfo("%s: Open Workspace dialog was not displayed.", THIS_FUNCTION);
	}
	return bDisplayed;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\umainfrm.h ===
///////////////////////////////////////////////////////////////////////////////
//	UMAINFRM.H
//
//	Created by :			Date :
//		DavidGa					9/20/93
//
//	Description :
//		Declaration of the UIMainFrm class
//
//		A Common subclass of UIWindow, UIMainFrm is designed as the basis of any
//		utility class associated with an application's main frame window
//		(i.e. the one with the menubar and possibly an MDI client area.
//

#ifndef __UIMAINFRM_H__
#define __UIMAINFRM_H__

#include "..\..\uwindow.h"

#include "shlxprt.h"

///////////////////////////////////////////////////////////////////////////////
//	DoCommand structure, enums and globals

// command access methods
enum DC_METHOD { DC_MESSAGE, DC_MENU, DC_MNEMONIC, DC_ACCEL };
	// REVIEW(davidga) additional method possibilities: MENUX, TOOLBAR

struct CMD_STRUCT									  
{	
	UINT idCommand;		// menu id
	UINT idMenu[3];		// string id for up to three menu items
	LPCSTR szMnemonic;	// string of keys that will access menu mnemonics
	LPCSTR szAccel;		// accelerator string
};


///////////////////////////////////////////////////////////////////////////////
//UIWindow class

// BEGIN_CLASS_HELP
// ClassName: UIMainFrm
// BaseClass: UIWindow
// Category: Shell
// END_CLASS_HELP
class SHL_CLASS UIMainFrm : public UIWindow
{
public:
	UIWND_COPY_CTOR( UIMainFrm, UIWindow);
	virtual void OnUpdate(void);

// Data
protected:
	CMD_STRUCT* m_pCmdTable;

// Attributes
public:
	virtual BOOL IsValid(void) const;

// Utilities
public:
	BOOL DoCommand(UINT id, DC_METHOD method);
	BOOL IsCommandEnabled(UINT id);
};

#endif //__UIMAINFRM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\utbardlg.cpp ===
//////////////////////////////
//  UTBARDLG.CPP
//
//  Created by :            Date :
//      EnriqueP              1/13/94
//
//  Description :
//      Implementation of the UITBarDialog class
//

#include "stdafx.h"
#include "utbardlg.h"
#include "..\sym\cmdids.h"
#include "mstwrap.h"
#include "uwbframe.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: int UITBarDialog::Display(void)
// Description: Bring up the Toolbars dialog.
// Return: TRUE if the Toolbars dialog is displayed; FALSE otherwise.
// END_HELP_COMMENT
int UITBarDialog::Display(void)
{
	if ( MST.WFndWndWait(GetLocString(IDSS_TB_TITLE), FW_PART, 1) != 0 )	 // Fix VerifyText function
		return TRUE; //UITB_NO_ERROR;						 // Dialog is already up

	UIWB.DoCommand(IDM_TOOLBAR_EDIT, DC_MNEMONIC);	
	
	if ( MST.WFndWndWait(GetLocString(IDSS_TB_TITLE), FW_PART, 1) == 0)		  // Fix VerifyText function
	{
		//LOG->Comment("WARNING: Toolbars Dialog was not displayed "); // Print isn't working
		return FALSE; //UITB_ERR_NOT_DISPLAYED;
	}

	return TRUE;   // UITB_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\utbardlg.h ===
//////////////////////////////
//  UTBARDLG.H
//
//  Created by :            Date :
//      EnriqueP              1/13/94
//
//  Description :
//      Declaration of the UIToolbar class
//

#ifndef __UTBARDLG_H__
#define __UTBARDLG_H__

#include "..\..\udialog.h"
#include "wbutil.h"

#include "shlxprt.h"

#ifndef __UIDIALOG_H__
   #error include 'udialog.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
// UITBarDialog Control ID's   as defined in vshell.h
/*
IDSS_TB_TITLE 		...... 	Dialog title:	"Toolbars" 	  defined in wb.rc
VSHELL_IDC_NEW     .......	New Button				
VSHELL_IDC_CUSTOM		....Customize Button					
VSHELL_IDC_DELETE		..  Reset and Delete Buttons				
VSHELL_IDC_TOOLBAR	....Toolbars Listbox				
VSHELL_IDC_NAME		....Toolbar Name Edit box


*/

enum {  UITB_NO_ERROR,				  //  Error return codes
		UITB_ERR_NOT_DISPLAYED,
		UITB_ERR_FAILED
	 };

///////////////////////////////////////////////////////////////////////////////
// UITBarDialog class declaration

// BEGIN_CLASS_HELP
// ClassName: UITBarDialog
// BaseClass: UIDialog
// Category: Shell
// END_CLASS_HELP
class SHL_CLASS UITBarDialog : public UIDialog
{
   	UIWND_COPY_CTOR (UITBarDialog, UIDialog) ;

	virtual CString ExpectedTitle (void) const
		{	return GetLocString(IDSS_TB_TITLE); }

// Utilities
public:
	int Display(void);
		
};			



#endif //__UTBARDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\upropwnd.h ===
///////////////////////////////////////////////////////////////////////////////
//  UPROPWND.H
//
//  Created by :            Date :
//      MichMa              12/01/93
//
//  Description :
//      Declaration of the UIProperties class
//

#ifndef __UIPROPWND_H__
#define __UIPROPWND_H__


#include "shlxprt.h"
#include "uitabdlg.h"


///////////////////////////////////////////////////////////////////////////////
//  UIProperties class


#define METHOD_EDIT 0
#define METHOD_LIST 1

// BEGIN_CLASS_HELP
// ClassName: UIControlProp
// BaseClass: UITabbedDialog
// Category: Shell
// END_CLASS_HELP
class SHL_CLASS UIControlProp : public UITabbedDialog
{
	UIWND_COPY_CTOR(UIControlProp, UITabbedDialog);

// Utilities
public:
	BOOL IsValid(void) const;

	CString GetID();
	BOOL SetID(CString newID);
	BOOL SetAllPage(void);
	CString getProperty(LPCSTR PropName);
	int putProperty(LPCSTR PropName,LPCSTR szValue,BOOL method=METHOD_EDIT);
    HWND Close(void); //udialog.h version does not work here

};



#endif //__UIPROPWND_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\upropwnd.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  UPROPWND.CPP
//
//  Created by :            Date :
//      DavidGa                 10/27/93
//
//  Description :
//      Implementation of the UIProperties class
//

#include "stdafx.h"

#include "upropwnd.h"
#include "testxcpt.h"
#include "mstwrap.h"
#include "wbutil.h"
#include "guitarg.h"
#include "uwbframe.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


// BEGIN_HELP_COMMENT
// Function: BOOL UIProperties::IsValid(void) const
// Description: Determine if the property page is valid by checking the window handle and the title of the property page.
// Return: TRUE if the property page is valid; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIControlProp::IsValid(void) const
{
	CString strTitle=GetText();
	CString strExpected=ExpectedTitle();
	if(UIWindow::IsValid()==FALSE)
		return FALSE;
	if(strTitle.Find(GetLocString(IDSS_PROP_TITLE)) < 0)
		return FALSE;
	if(!strExpected.IsEmpty() && strTitle.Find(strExpected) < 0)
		return FALSE;
	return TRUE;
}



// BEGIN_HELP_COMMENT
// Function: BOOL UIControlProp::GetID(void)
// Description: Gets the string from the property General page.
// Return: empty string if not success.
// END_HELP_COMMENT
CString UIControlProp::GetID(void)
{
static CString idName;
	idName.Empty();
	HWND hGenPage=ShowPage(/*"General"*/ 0xDE /*combobox*/,0);
	if(hGenPage==NULL)
		return idName;
	MST.WComboText(GetLabel(0xde), idName);
	::WaitForInputIdle(g_hTargetProc, 3000);
	return idName;
} //GetID


// BEGIN_HELP_COMMENT
// Function: BOOL UIControlProp::SetID(void)
// Description: Gets the string from the property General page.
// Return: FALSE if not success.
// END_HELP_COMMENT
BOOL UIControlProp::SetID(CString newID)
{
	HWND hGenPage=ShowPage(/*"General"*/ 0xDE /*combobox*/,0);
	if(hGenPage==NULL)
		return FALSE;
	MST.WComboSetText(GetLabel(0xDE), newID);
	MST.DoKeys("{TAB}");	// validate the field which was just set
	::WaitForInputIdle(g_hTargetProc, 3000);
	return TRUE;
} //SetID

#include "..\..\testutil.h"
// BEGIN_HELP_COMMENT
// Function: BOOL UIControlProp::SetAllPage(void)
// Description: Changes the current page to "All" page.
// Return: FALSE if not success.
// END_HELP_COMMENT
BOOL UIControlProp::SetAllPage(void)
{
//	if(SetPage("All")==FALSE)
//		return FALSE;
	
	HWND hGenPage=ShowPage(/*"All"*/ 0x52d5 /*listbox*/,0);
	if(hGenPage==NULL)
		return FALSE;
	::WaitForInputIdle(g_hTargetProc, 3000);

	RECT rcPage;
	GetClientRect(HWnd(), &rcPage);
	ClickMouse( VK_LBUTTON ,HWnd(), rcPage.left+150, rcPage.top + 150 );	  // Click into the control

	return TRUE;
} //SetAllPage

#include "guiv1.h" //for LOG macro

// BEGIN_HELP_COMMENT
// Function: BOOL UIControlProp::putProperty(LPCSTR PropName,LPCSTR szValue)
// Description: changes the property in "All" page. 
// Params: PropName - name of the property
//			szValue - value of the propery
//			method  - METHOD_EDIT: edit the field (by default), 
//						or select from the list
// Return: 0 if not success.
//         1 if success.
//        -1 if not propery not found in the list (METHOD_LIST only)
// END_HELP_COMMENT
int UIControlProp::putProperty(LPCSTR PropName,LPCSTR szValue,BOOL method /*=METHOD_EDIT*/)
{
	if(SetAllPage()==FALSE)
		return 0;
	int count=MST.WListCount(NULL);
	int nitem=MST.WListItemExists(NULL, PropName);
	if(nitem>0)
	{ //only this way of doing things, no way to validate what we are doing
		MST.WListItemClk(NULL,PropName);
		MST.DoKeys("{TAB}", FALSE, 1000); //move to the value part of the field
		if(method==METHOD_LIST)
		{
//			MST.WListItemClk(NULL,PropName,-10);
//			MST.WListText(NULL,strSlItem);
//			ASSERT(strSlItem==PropName);
//			if((nitem=MST.WListItemExists(NULL, szValue))>0)
//			{
//				MST.WListItemClk(NULL,szValue);
//			}
//			else
//				return FALSE;
			
//			COClipboard clip;clip.SetText("");
			SetClipText("");
			CString strSlItem,nextItem;
			int loopcount=0;
			char firstchar[4];
			firstchar[0]=szValue[0];
			firstchar[1]=0;
			do
			{
nextitem:
				loopcount++;
				if(szValue[0]==0) //empty string - clean the field
				{
					MST.DoKeys("+{END}{DEL}",FALSE,10000); //replace with the keystrokes
					MST.DoKeys("{UP}{DOWN}"); //wierd way to escape focus off value field
					goto handle_error;				
				}
				MST.DoKeys(firstchar); //typing the first char cycles through the list
				::WaitForInputIdle(g_hTargetProc, 10000);
				MST.DoKeys("+{END}");
				UIWB.DoCommand(ID_EDIT_COPY, DC_ACCEL);
//				nextItem=clip.GetText();
				GetClipText(nextItem);	// grab the clipboard
				if(nextItem==szValue)
				{ //found the item
					MST.DoKeys("{UP}{DOWN}"); //wierd way to escape focus off value field
					goto handle_error;				
				}
				if(strSlItem.IsEmpty())
				{ 
					if(nextItem.IsEmpty())
					{ //empty list
						MST.DoKeys("{UP}{DOWN}"); //wierd way to escape focus off value field
						LOG->RecordInfo("Empty list for th property (%s)",PropName);
						return -1;
					}
					strSlItem=nextItem;
					goto nextitem; //in case of first item don't compare it
				}
			}while(nextItem!=strSlItem && loopcount<100); //returned to the begin of loop?
			MST.DoKeys("{UP}{DOWN}");
			LOG->RecordFailure("Item (%s) of property (%s) not found",szValue,PropName);
			return 0; //not found
		}
		else
		{
			MST.DoKeys("+{END}");//select the old value
			if(szValue[0]==0) //empty string - clean the field
				MST.DoKeys("{DEL}",FALSE,10000); //replace with the keystrokes
			else
				MST.DoKeys(szValue,TRUE,10000); //replace with the keystrokes
			MST.DoKeys("{UP}{DOWN}"); //wierd way to escape focus off value field
		}
	}
	else 
		return 0;
handle_error:
	::WaitForInputIdle(g_hTargetProc, 10000);
	UIDialog uErrorDlg;
	if(uErrorDlg.WaitAttachActive(1000))
	{
		char acBuf[256];
		uErrorDlg.GetText(acBuf, 255); 
		LOG->RecordFailure("Unexpaected Dialog box: (%s) detected. Clicked default",acBuf);
		uErrorDlg.Close();
		return 0;
	}
	CString strprop;
	strprop=getProperty(PropName);
	BOOL equal=(strprop==szValue);
	LOG->RecordCompare(equal==TRUE, "Property set: (%s) == propery displayed: (%s)",szValue, strprop);
	return equal;
} //putProperty
//	char dokey[20];
//		MST.DoKeys("{HOME}");
//		sprintf(dokey,"{DOWN %d}",nitem-1);
//		MST.DoKeys(dokey); //move down to the correct field
		
//		MST.WListText(NULL,strSlItem);
//		ASSERT(strSlItem==PropName);
//		MST.DoKeys("{TAB}"); //move to the value part of the field
//		MST.DoKeys("+{END}");//select the old value
//		MST.DoKeys(szValue); //replace with the keystrokes


// BEGIN_HELP_COMMENT
// Function: CString& UIControlProp::getProperty(LPCSTR PropName)
// Description: gets the property in "All" page. 
// Focus problem: the focus must be on the ListBox control.
//Usually, it is when the PP is broght & All page found using keyboard only
// Return: Empty string if not success.
// END_HELP_COMMENT
CString UIControlProp::getProperty(LPCSTR PropName)
{
static CString idName;
	idName.Empty();

	if(SetAllPage()==FALSE)
		return idName;
	int count=MST.WListCount(NULL);
	int nitem=MST.WListItemExists(NULL, PropName);
//	COClipboard clip;clip.SetText("");
	SetClipText("");
	if(nitem>0)
	{ //only this way of doinf things, no way to validate what we are doing
//		MST.DoKeys("{HOME}");
//		sprintf(dokey,"{DOWN %d}",nitem-1);
//		MST.DoKeys(dokey); //move down to the correct field
		MST.WListItemClk(NULL,PropName);
		MST.DoKeys("{TAB}", FALSE, 1000); //move to the value part of the field
		MST.DoKeys("+{END}");//select the old value
		UIWB.DoCommand(ID_EDIT_COPY, DC_ACCEL);		// REVIEW: is there a better way?
		MST.DoKeys("{UP}{DOWN}"); //wierd way to escape focus off value field
//		return clip.GetText();	
		GetClipText(idName); // grab the clipboard
	}	
	return idName;
} //getProperty


// BEGIN_HELP_COMMENT
// Function: HWND UIControlProp::Close(void)
// Description: Closes an open property page frame. Gives the focus to the open PP frame, validates it & closes it
// Return: Handle of the frame found, NULL if not success.
// END_HELP_COMMENT
HWND UIControlProp::Close(void)
{	
	//set focus on properties frame
	HWND hprop=MST.WFndWndWait(GetLocString(IDSS_PROP_TITLE),FW_PART|FW_FOCUS,0);
	if(hprop!=NULL)
	{
		MST.DoKeys("{ENTER}");	// ENTER should validate the window
		while(MST.WFndWndWait(GetLocString(IDSS_PROP_TITLE),FW_PART|FW_FOCUS,0))
			MST.DoKeys("{ESC}"); //shld close the window (ENTER does not if it's pinned)
	}
	return hprop;
} //Close()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\utoolbar.h ===
//////////////////////////////
//  UTOOLBAR.H
//
//  Created by :            Date :
//      EnriqueP              1/13/94
//
//  Description :
//      Declaration of the UIToolbar class
//

#ifndef __UTOOLBAR_H__
#define __UTOOLBAR_H__

#include "..\..\uwindow.h"

#include "shlxprt.h"

#ifndef __UIWINDOW_H__
   #error include 'uwindow.h' before including this file
#endif

///////////////////////////////////////////////////////////////////////////////
// UITBarDialog #defines


///////////////////////////////////////////////////////////////////////////////
// UIToolbar class declaration

// BEGIN_CLASS_HELP
// ClassName: UIToolbar
// BaseClass: UIWindow
// Category: Shell
// END_CLASS_HELP
class SHL_CLASS UIToolbar : public UIWindow
{
   	UIWND_COPY_CTOR (UIToolbar, UIWindow) ;

// Utilities
public:
	int DisplayTBDlg(void);
	int ShowTB(int nTbId, BOOL bShow);
	CString GetTBText(int nTbId);
	BOOL IsDocked(HWND hWnd, int nLocation = 0x000F /*DW_DONT_CARE*/); 		
	
	//int Create(LPCSTR szTBName, int aTBButtons);
	//int Delete(LPCSTR szTBName);
	//int Rename(LPCSTR szOldName, LPCSTR szNewName);
	//int AddButtons(LPCSTR szTBName, int aTBButtons, int nPos);
};			



#endif //__UTOOLBAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\uwbframe.cpp ===
/////////////////////////////////////////////////////////////////////////////////
// UWBFRAME.CPP
//
//  Created by :            Date :
//      DavidGa                 9/23/93
//
//  Description :
//      Implementation of the UIWBFrame class
//
#include "stdafx.h"

#include "uwbframe.h"
#include "testxcpt.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\cmdids.h"
#include "..\sym\qcqp.h"
#include "..\sym\vcpp32.h"
#include "guiv1.h"
#include "..\..\udialog.h"
#include "ucommdlg.h"
#include "uiwbmsg.h"
#include "udockwnd.h"
#include "upropwnd.h"
#include "uioptdlg.h"
#include "uioutput.h"
#include "wbutil.h"
#include "guitarg.h"
#include "newfldlg.h"
#include "evnthdlr.h"

#pragma comment(lib, "version.lib")

// Obviously this could easily change.  Hopefully, it will last for a while.
#define STATUSBAR_CLASSNAME "Afx:400000:0:0:10:0"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// REVIEW(briancr): this object is declared as a global for backward compatibility
// REVIEW(briancr): this is just to make things work. Is there a better way to do this?
// instantiate a global pointer to UIWBFrame
// this pointer can be substituted if another instance of IDE must be driven
static UIWBFrame theUIWB;
SHL_DATA UIWBFrame *g_pUIWB=&theUIWB;

// I use this all the time when waiting using WFndWndWait to wait for a dialog
#define FW_MODAL_DIALOG     FW_DIALOG | FW_ACTIVE | FW_NOCASE | FW_NOFOCUS | FW_CHILDNOTOK | FW_HIDDENNOTOK

UINT UIWBFrame::m_msgGetProp = RegisterWindowMessage( "GetProp" );
UINT UIWBFrame::m_msgSetProp = RegisterWindowMessage( "SetProp" );
UINT UIWBFrame::m_msgGetToolbar = RegisterWindowMessage( "TestDockable" );
UINT UIWBFrame::m_msgGetItemProp = RegisterWindowMessage( "GetItemProp" );
UINT UIWBFrame::m_msgGetProjPath = RegisterWindowMessage( "GetProjPath" );
UINT UIWBFrame::m_msgSetItemProp = RegisterWindowMessage( "SetItemProp" );
UINT UIWBFrame::m_msgEditorCurPos = RegisterWindowMessage( "MSVCEditorCurPos" );

// Build states
UINT UIWBFrame::m_msgCanWeBuild = RegisterWindowMessage( "CanWeBuild" );
UINT UIWBFrame::m_msgGetErrorCount = RegisterWindowMessage( "GetErrCount" );
UINT UIWBFrame::m_msgGetWarningCount = RegisterWindowMessage( "GetWarnCount" );


void UIWBFrame::OnUpdate(void)
{
	const char* const THIS_FUNCTION = "UIWBFrame::OnUpdate";

	UIMainFrm::OnUpdate();

	// set up the command table
	m_pCmdTable = m_aCmdTable;

	if( !IsValid() )
		m_hwndClient = NULL;
	else
	{
		MST.WSetActWnd(HWnd());
		// wait for up to 2 seconds for the app to be active
		for (int nWait = 0; nWait < 20; nWait++) {
			if (IsActive()) {
				break;
			}
			Sleep(100);
		}
		// check that the app is active
		if (IsActive()) {
			m_hwndClient = MST.WFndWndC( "", "MDIClient", FW_ACTIVE | FW_FULL | FW_NOFOCUS );
		}
		else {
			char aBuf[1024];
			sprintf(aBuf, "%s: Target application (HWND = %lx) is not active. Unable to continue.", THIS_FUNCTION, HWnd());
			throw CTestException(aBuf, CTestException::causeOperationFail);
		}
	}
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::Find(void)
// Description: Find the IDE's frame window and attach to it, if found.
// Return: TRUE if the IDE's frame window is successfully found; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWBFrame::Find(void)
{
	// search top level windows for hwnd that passes Attach()'s IsValid()
	if( Attach(::GetWindow(MST.WGetActWnd(0), GW_HWNDFIRST)) )
		return TRUE;
	
	while( !Attach(::GetWindow(HWnd(), GW_HWNDNEXT)) )
	{
		CString str = GetText();
		if(HWnd() == NULL)		// if we go past the end of the list
			return FALSE;		// then it must not exist
	}

	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::IsValid(void) const
// Description: Determine if the IDE's frame window is valid by checking the window handle, the title of the window, and the window class.
// Return: TRUE if the frame window is valid; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWBFrame::IsValid(void) const
{
	if( !UIMainFrm::IsValid() )
		return FALSE;

    char acBuf[256];
    if(strstr(GetText(acBuf, 255), GetLocString(IDSS_WORKBENCH_TITLEBAR)) != acBuf)
        return FALSE;       // title is not correct

    VERIFY(::GetClassName(HWnd(), acBuf, 255));
    if(strstr(acBuf, GetLocString(IDSS_WORKBENCH_CLASSNAME)) != acBuf)
        return FALSE;       // then compare the classname, it might be Cuda

    return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::IsDebug(void)
// Description: Determine if the IDE is a debug build or retail build. (This function is NYI.)
// Return: TRUE if the IDE is a debug build; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWBFrame::IsDebug(void)
{
    return TRUE;        // STUB: Sushi is always built DEBUG these days
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::IsActive(void)
// Description: Determine whether the IDE is active.
// Return: TRUE if the IDE is active; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWBFrame::IsActive(void)
{
	for ( HWND hwndActive = MST.WGetActWnd(0); hwndActive; hwndActive = GetParent( hwndActive ) )
		if ( hwndActive == HWnd() )
			return TRUE;
	return FALSE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::IsAlert(void)
// Description: Determine if an alert box (message or dialog) is being displayed by the IDE. (This function is NYI.)
// Return: TRUE if an alert is displayed; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWBFrame::IsAlert(void)
{
    return FALSE;   // STUB
}

// BEGIN_HELP_COMMENT
// Function: HWND UIWBFrame::CreateNewFile(LPCSTR szFileType)
// Description: Create a new file in the IDE. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: The HWND of the window that contains the new file.
// Param: szFileType A pointer to a string containing the type of the new file to create. Valid file types are listed in the File New dialog in the IDE.
// END_HELP_COMMENT
HWND UIWBFrame::CreateNewFile(LPCSTR szFileType)
{
	ASSERT( (szFileType != NULL) && (*szFileType != '\0') );

	UINewFileDlg nwFlDlg ;
	
	nwFlDlg.Display() ;
	nwFlDlg.NewFileTab() ;
	nwFlDlg.SelectFromList(szFileType);
	nwFlDlg.AddToProject(FALSE);
	MST.WButtonClick(GetLabel(IDOK));
	nwFlDlg.WaitUntilGone(2000) ;
  	WaitForInputIdle(g_hTargetProc, 10000);
	CString Text = GetLocString(IDSS_NEW_SOURCE) ;
	if(Text == szFileType)
	{// change the file type to C/C++ (just a hack for now)

		MST.DoKeys("%{ENTER}") ;
		MST.DoKeys("C") ;
		MST.DoKeys("{ENTER}");
	}
	/*DoCommand(ID_FILE_NEW, DC_ACCEL);
	UIDialog nd(0x64,GL_LISTBOX);
	if( !nd.WaitAttachActive(1000) )
	{
		LOG->RecordInfo("Could not open File/New dialog");
		return NULL;
	}

	MST.WListItemClk("", szFileType);
	nd.OK();
	nd.WaitUntilGone(1000);
*/
	return GetActiveEditor();

/*	if (!WaitOnWndWithCtrl(AFX_IDC_LISTBOX,2000))	 // REVIEW(Ivanl) fix this.
	{
		 // Cancel out of the dialog and exit.
		 LOG->RecordInfo("Could not open the File/New dialog");
		 MST.DoKeys("{ESC 5}") ;
		 return NULL ;
	}
	
    MST.WListItemClk("", szFileType);
	MST.WButtonClick(GetLabel(IDOK)) ;
   	WaitOnWndWithCtrl(APPWZ_IDC_PROJ_DIR,2000) ;
    return GetActiveEditor() ;
*/
}

// BEGIN_HELP_COMMENT
// Function: HWND UIWBFrame::OpenFile(LPCSTR szFileName, LPCSTR szChDir /*=NULL*/)
// Description: Open a file in the IDE.  NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: The HWND of the window that contains the opened file.
// Param: szFileName A pointer to a string that contains the filename of the file to open.
// Param: szChDir A pointer to a string that contains the path the file. NULL means the path is given with the filename or use the current working directory. (Default is NULL.)
// END_HELP_COMMENT
HWND UIWBFrame::OpenFile(LPCSTR szFileName, LPCSTR szChDir /*=NULL*/)
{
//    UIEditor uedOld = GetActiveEditor();
	HWND uedOld = GetActiveEditor();

    UIFileOpenDlg ufod = FileOpenDlg();
	if( !ufod.IsValid() )
	{
		LOG->RecordInfo("Could not open File/Open dialog");
		return NULL;
	}

    if( szChDir != NULL )
        ufod.SetPath(szChDir);
    ufod.SetName(szFileName);
    EXPECT( ufod.OK(FALSE) );

    HWND hwndActive = MST.WGetActWnd(0);
    // (briancr) uedNew == uedOld is not always a valid check that file open
    // succeeded; the file may already be opened and be the top level MDI window
    // possibly a better check would be to check the child window's title for
    // the file name that's passed in...
//  while( (hwndActive == ufod) || ((hwndActive == HWnd()) && (uedNew == uedOld)) )
	ufod.WaitUntilGone(1500);	// the only files that take a while are RC, which causes the whole system to wait while it compiles

    if( !IsActive() )
        return hwndActive;  // return handle of any messagebox that comes up
    else
        return GetActiveEditor();  // or else return handle of new editor window
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::SaveFileAs(LPCSTR szFileName, BOOL bOverwrite /*=TRUE*/)
// Description: Save a file in the IDE with a new name.  NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: TRUE if successful; FALSE otherwise.
// Param: szFileName A pointer to a string that contains the filename.
// Param: bOverwrite TRUE to overwrite an existing file (if one exists); FALSE to not overwrite. (Default is TRUE.)
// END_HELP_COMMENT
BOOL UIWBFrame::SaveFileAs(LPCSTR szFileName, BOOL bOverwrite /*=TRUE*/)
{                                                 //REVIEW params and #define BNT_YES & BTN_NO
    UIFileSaveAsDlg ufsad = FileSaveAsDlg();
	if( !ufsad.IsValid() )
	{
		LOG->RecordInfo("Could not open File/Save As dialog");
		return FALSE;
	}

    ufsad.SetName(szFileName);
    ufsad.OK(bOverwrite);

	UIWBMessageBox mb;
	while( mb.WaitAttachActive(2000) || !ufsad.WaitUntilGone(0) )
    {
		if( !mb.IsValid() )
			continue;

        if( mb.ButtonExists(MSG_YES) )
        {
            if( !bOverwrite )
            {
                mb.ButtonClick(MSG_NO);
                return FALSE;           // File already exists and don't overwrite
            }
            mb.ButtonClick(MSG_YES);	//Overwrite file
        }
		else
			MST.DoKeys("~");	// on any other dialogs, take the default
    }

    return TRUE;                        //File was saved
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::SaveAll(int intWaitInMilliSecs /* 0 */)
// Description: selects the File.SaveAll menu item and waits for a specified number of milliseconds.
// Return: TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
// REVIEW (michma): how can we know when Save All is finished?
BOOL UIWBFrame::SaveAll(int intWaitInMilliSecs /* 0 */)
	{
	this->DoCommand(IDM_FILE_SAVE_ALL, DC_MNEMONIC);
	Sleep(intWaitInMilliSecs);
	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::CloseProject(void)
// Description: Close a project window in the IDE. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWBFrame::CloseProject(void)
{
	this->DoCommand(IDM_CLOSE_WORKSPACE, DC_MNEMONIC);

	UIWBMessageBox mb;
	while( mb.WaitAttachActive(3000) != NULL )
	{
		if( mb.ButtonExists(MSG_NO) )
			// this will handle "do you want to save" msg box
			mb.ButtonClick(MSG_NO);
		else
			// this will handle "access denied" msg box for read-only projects
			MST.DoKeys("~");
	}

	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: void UIWBFrame::CloseAllWindows(void)
// Description: Close all open editor windows in the IDE. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: none
// END_HELP_COMMENT
void UIWBFrame::CloseAllWindows(void)   // REVIEW (EnriqueP): Move to CWorkSpace?
{
	// REVIEW: Shouldn't this be IDM instead of ID?
    DoCommand(ID_WINDOW_CLOSE_ALL, DC_MNEMONIC);	

	// Click away any message boxes that come up on closing the windows.
	// Likely to be "File hasn't been saved..." type messages.
	UIWBMessageBox mb;
	while( mb.WaitAttachActive(2000) != NULL )
	{
		if( mb.ButtonExists(MSG_NO) )
			mb.ButtonClick(MSG_NO);
		else
			MST.DoKeys("~");
	}

	CloseProject();
}


// BEGIN_HELP_COMMENT
// Function: HWND UIWBFrame::GetActiveEditor(void)
// Description: Get the HWND of the active editor in the IDE. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: The HWND of the active editor, if successful; NULL otherwise.
// END_HELP_COMMENT
HWND UIWBFrame::GetActiveEditor(void)
{
  	WaitForInputIdle(g_hTargetProc, 10000);
	HWND hwnd = (HWND)SendMessage(GetClient(), WM_MDIGETACTIVE, 0, 0 );
	if (!hwnd)
		hwnd =	MST.WGetActWnd(0) ;

    if (!hwnd || IsIconic(hwnd))
        return 0L;

    return hwnd;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::SetActiveEditor(HWND hwndEditor)
// Description: Set the active editor in the IDE. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: TRUE if successful; FALSE otherwise.
// Param: hwndEditor The HWND of the window to make the active editor.
// END_HELP_COMMENT
BOOL UIWBFrame::SetActiveEditor(HWND hwndEditor)
{
	SendMessage( GetClient(), WM_MDIACTIVATE, (WPARAM)hwndEditor, 0 );	 //REVIEW: is this the correct UI method?
	return GetActiveEditor() == hwndEditor;
}

// BEGIN_HELP_COMMENT
// Function: HWND UIWBFrame::GetToolbar(int nTbId)
// Description: Get the HWND of the specified toolbar. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: The HWND of the toolbar, if successful; NULL otherwise.
// Param: nTbId The id of the toolbar: IDTB_SUSHI_STANDARD, IDTB_SUSHI_EDIT, IDTB_VRES_RESOURCE, IDTB_VCPP_DEBUG, IDTB_VCPP_BROWSE, IDTB_VRES_DIALOG, IDDW_CONTROLS, IDDW_GRAPHICS, IDDW_COLORS, IDDW_TEXTTOOL, IDTB_VPROJ_BUILD.
// END_HELP_COMMENT
HWND UIWBFrame::GetToolbar(int nTbId,int pkgId)
{
	long docId = MAKELONG(nTbId,pkgId) ;
	return (HWND)PWnd()->SendMessage(m_msgGetToolbar, docId);
}				

// BEGIN_HELP_COMMENT
// Function: HWND UIWBFrame::ShowDockWindow(UINT id, BOOL bShow /*=TRUE*/) // REVIEW (EnriqueP): Move to CWorkSpace
// Description: Display or hide the specified dockable window. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: The HWND of the dockable window, if successful; NULL otherwise.
// Param: id The id of the dockable window: IDW_OUTPUT_WIN
// Param: bShow TRUE to show the window; FALSE to hide it. (Default is TRUE.)
// END_HELP_COMMENT
HWND UIWBFrame::ShowDockWindow(UINT id, BOOL bShow /*=TRUE*/) // REVIEW (EnriqueP): Move to CWorkSpace
{
	UIDockWindow* pudw;
	switch( id )
	{
		case IDW_OUTPUT_WIN:
			pudw = new UIOutput;
			break;
		case IDW_WATCH_WIN:
			LOG->RecordInfo("UIWBFrame::ShowDockWindow does not open the watch window. Use UIDebug::ShowDockWindow.");
			return NULL;
//			pudw = new UIWatch;
			break;
		case IDW_LOCALS_WIN:
			LOG->RecordInfo("UIWBFrame::ShowDockWindow does not open the locals window. Use UIDebug::ShowDockWindow.");
			return NULL;
//			pudw = new UILocals;
			break;
		case IDW_CPU_WIN:
			LOG->RecordInfo("UIWBFrame::ShowDockWindow does not open the registers window. Use UIDebug::ShowDockWindow.");
			return NULL;
//			pudw = new UIRegisters;
			break;
		case IDW_MEMORY_WIN:
			LOG->RecordInfo("UIWBFrame::ShowDockWindow does not open the memory window. Use UIDebug::ShowDockWindow.");
			return NULL;
//			pudw = new UIMemory;
			break;
		case IDW_CALLS_WIN:
			LOG->RecordInfo("UIWBFrame::ShowDockWindow does not open the call stack window. Use UIDebug::ShowDockWindow.");
			return NULL;
//			pudw = new UIStack;
			break;
		case IDW_DISASSY_WIN:
			LOG->RecordInfo("UIWBFrame::ShowDockWindow does not open the DAM window. Use UIDebug::ShowDockWindow.");
			return NULL;
//			pudw = new UIDAM;
			break;
		default:
			ASSERT(FALSE);		// never heard of that ID
			return NULL;
	}
	BOOL b = pudw->Activate();
	delete pudw;
	if( !b )					// attempt to show failed - who knows why
		return NULL;
	if( bShow )					// window was activated and has the focus
		return MST.WGetFocus();
	MST.DoKeys("+{escape}");		// shift escape hides the active docking-window/toolbar
	return NULL;				// should we return newly active window?
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::IsWindowDocked(HWND hWnd, int nLocation)
// Description: Determine if a dockable window is docked. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: TRUE if the window is docked; FALSE otherwise.
// Param: hWnd The HWND of the dockable window.
// Param: nLocation The location of the dockable window: DW_TOP, DW_BOTTOM, DW_LEFT, DW_RIGHT, DW_DONT_CARE.
// END_HELP_COMMENT
BOOL UIWBFrame::IsWindowDocked(HWND hWnd, int nLocation)   // (enriquep)
{
	EXPECT(IsWindowVisible(hWnd));
	//REVIEW (enriquep): Do we need to verify this is a dockable window?
	
	HWND  hParent = GetParent(hWnd);
	EXPECT(hParent != NULL);
	if ( ::GetWindowLong(hParent, GWL_STYLE) & WS_POPUP)
		return FALSE; 							// Window is floating

	// We know is docked , now check position.
	RECT rcWBClient;

	::GetClientRect( HWnd(), &rcWBClient);
	::MapWindowPoints( HWnd(), HWND_DESKTOP, (POINT*)&rcWBClient, 2);		  	// Client area RECT to screen coord.
	
	RECT rcWBMDIClient;
	HWND hMDIClient = GetClient();					// Returns MDI Client
	::GetWindowRect( hMDIClient, &rcWBMDIClient );
				
	
	RECT rcDockableWnd;

	::GetWindowRect(hWnd, &rcDockableWnd);			   // Get dockable window dimensions
	
	int nXBorder = ::GetSystemMetrics(SM_CXBORDER);	// Width of a border (usually 1 pix)
	int nYBorder = ::GetSystemMetrics(SM_CYBORDER);   	// Heigth of border (usually 1 pix)	
	
	if( (nLocation & DW_TOP) )
	{
		if( (rcWBClient.top  <= rcDockableWnd.top + nYBorder) && (rcWBMDIClient.top >= rcDockableWnd.bottom - nYBorder) )
			return TRUE;
	}

	if( (nLocation & DW_BOTTOM) )
	{
		if( (rcWBClient.bottom >= rcDockableWnd.bottom - nYBorder) && (rcWBMDIClient.bottom <= rcDockableWnd.top + nYBorder) )
			return TRUE;
	}

	if( (nLocation & DW_LEFT) )
	{
		if( (rcWBClient.left <= rcDockableWnd.left + nXBorder) && (rcWBMDIClient.left >= rcDockableWnd.right - nXBorder) )
			return TRUE;
	}

	if( (nLocation & DW_RIGHT) )
	{
		if( (rcWBClient.right >= rcDockableWnd.right - nXBorder) && (rcWBMDIClient.right <= rcDockableWnd.left + nXBorder ) )
			return TRUE;
	}

	return FALSE;
}


// BEGIN_HELP_COMMENT
// Function: int UIWBFrame::GetEditorCurPos( EGECP x, HWND hwndEditor /*=NULL*/ )
// Description: Get the line or column position of the caret in the editor (depending on x). NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: The line or column position of the caret in the window.
// Param: x Value indicating whether to get the line position or column position: GECP_LINE, GECP_COLUMN.
// Param: hwndEditor The HWND of the window to get line or column position for. NULL specifies the active editor window. (Default is NULL.)
// END_HELP_COMMENT
int UIWBFrame::GetEditorCurPos( EGECP x, HWND hwndEditor /*=NULL*/ )
{
//	EXPECT( (x == GECP_LINE) || (x == GECP_COLUMN) );
	HWND hwnd = hwndEditor == NULL ? GetActiveEditor() : hwndEditor;
	hwnd = GetWindow(hwnd, GW_CHILD);		// MDIFrameWnd
	hwnd = GetWindow(hwnd, GW_CHILD);		// view or a scrollbar
	hwnd = GetWindow(hwnd, GW_HWNDLAST);	// view for sure
	return (int)SendMessage(hwnd, m_msgEditorCurPos, x, 0);
}

// BEGIN_HELP_COMMENT
// Function: void UIWBFrame::ExportResource(LPCSTR szFileName, BOOL bOverwrite /*=FALSE*/)
// Description: Export a resource from the IDE> NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: none
// Param: szFileName A pointer to a string that contains the filename to save the exported resource under.
// Param: bOverwrite A value that indicates whether to overwrite an existing file or not. TRUE to overwrite; FALSE to not. (Default is FALSE.)
// END_HELP_COMMENT
void UIWBFrame::ExportResource(LPCSTR szFileName, BOOL bOverwrite /*=FALSE*/)
{
    DoCommand(IDM_RESOURCE_EXPORT, DC_MNEMONIC);

	UIDialog erd(GetLocString(IDSS_ER_TITLE));		// "Export Resource"
	if( !erd.WaitAttachActive(1000) )
	{
		LOG->RecordInfo("Could not open Resource/Export dialog");
		return;
	}
	
    MST.DoKeys(szFileName);
	erd.OK();
	
	UIWBMessageBox mb;
	while( mb.WaitAttachActive(1000) )
	{
		if( mb.ButtonExists(MSG_YES) && bOverwrite )
			mb.ButtonClick(MSG_YES);
		else
			mb.ButtonClick();			
	}
	erd.WaitUntilGone(1000);
	WaitForStatusText(GetLocString(IDSS_READY), 1000);

//  MST.WMenuEnd();     // BUG?: status bar text doesn't revert to 'Ready'
}

// BEGIN_HELP_COMMENT
// Function: HWND UIWBFrame::ShowPropPage(BOOL bShow)
// Description: Display or hide the property page for the active window. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: The HWND of the property page for the active window.
// Param: bShow A Boolean value that indicates whether to show or hide the property page. TRUE to show it; FALSE to hide it.
// END_HELP_COMMENT
HWND UIWBFrame::ShowPropPage(BOOL bShow)
{
	UIControlProp upp;
	if( !upp.AttachActive() )
	{
		DoCommand(IDM_WINDOW_SHOWPROPERTIES, DC_ACCEL);
//		MST.DoKeys("%{ENTER}");		//Give Focus to PropPage
		upp.WaitAttachActive(1000);
	}
	if( bShow == FALSE )
	{
		upp.Close();
//		MST.DoKeys("+{ESC}");		// Hide it 	
		return NULL;			// no HWND of prop page
	}
	else
		return upp;		// HWND of prop page
}

// BEGIN_HELP_COMMENT
// Function: CString UIWBFrame::GetProperty(int nProp)
// Description: Get the property of the item specified by nProp. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A CString containing the property of the item.
// Param: nProp The id of the item.
// END_HELP_COMMENT
CString UIWBFrame::GetProperty(int nProp)   // REVIEW (EnriqueP): Move to CWorkSpace?
{
	CString str = "Empty Property";
	ATOM atom = (ATOM)PWnd()->SendMessage( m_msgGetProp, nProp);
	if (atom != 0)
	{
		UINT ret = GlobalGetAtomName( atom, str.GetBufferSetLength(MAX_ATOM_LENGTH), MAX_ATOM_LENGTH );
		ret = GlobalDeleteAtom(atom);	// this atom created by the Workbench
		str.ReleaseBuffer(-1);
	}
 	return str;
}	

int UIWBFrame::SetProperty(int nProp,LPCSTR propValue)
{
	int ret;
	ATOM atom = GlobalAddAtom(propValue);
	TRACE1("Added Global Atom: %u\n", atom);
	ret=PWnd()->SendMessage( m_msgSetProp, nProp, (LPARAM)atom);
	GlobalDeleteAtom(atom);	// this atom created by the Workbench
	return ret;
}						

// BEGIN_HELP_COMMENT
// Function: CString UIWBFrame::GetProjPath(void)
// Description: Get the current project's path. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A CString containing the path the current project.
// END_HELP_COMMENT
CString UIWBFrame::GetProjPath(void)   // REVIEW (EnriqueP): Move to CWorkSpace?
{	int nProp = 0 ;
	CString str = "Empty Property";
	ATOM atom = (ATOM)PWnd()->SendMessage( m_msgGetProjPath, nProp);
	if (atom != 0)
	{
		UINT ret = GlobalGetAtomName( atom, str.GetBufferSetLength(MAX_ATOM_LENGTH), MAX_ATOM_LENGTH );
		ret = GlobalDeleteAtom(atom);	// this atom created by the Workbench
		str.ReleaseBuffer(-1);
	}
 	return str;
}							

// BEGIN_HELP_COMMENT
// Function: void UIWBFrame::SelectProjItem(int item, LPCSTR szName)
// Description: Select the item specified. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: none
// Param: item The item to select.
// Param: szName The name of the item to select.
// END_HELP_COMMENT
void UIWBFrame::SelectProjItem(int item, LPCSTR szName)
{	
	HWND hProjOptDlg = MST.WGetActWnd(0) ;
	SendMessage(hProjOptDlg,WM_USER +0, (WPARAM) item, (LPARAM)GlobalAddAtom(szName));
}
				
// BEGIN_HELP_COMMENT
// Function: CString UIWBFrame::GetItemProperty(int nProp)
// Description: Get the property of any item. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A CString containing the property.
// Param: nProp The id of the property.
// END_HELP_COMMENT
CString UIWBFrame::GetItemProperty(int nProp)
{
	CString str = "Empty Property";
	ATOM atom = (ATOM)PWnd()->SendMessage( m_msgGetItemProp, nProp);
	if (atom != 0)
	{
		UINT ret = GlobalGetAtomName( atom, str.GetBufferSetLength(512), 512 );
		ret = GlobalDeleteAtom(atom);	// this atom created by the Workbench
		str.ReleaseBuffer(-1);
	}
 	return str;
}

   // Build state
// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::CanWeBuild(void )
// Description: Determine whether the IDE is able to build a project or not. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates whether the IDE is able to build or not. TRUE if the IDE can build; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWBFrame::CanWeBuild(void )
{
  	int nProp = 0, iCan  ;
	iCan  = PWnd()->SendMessage( m_msgCanWeBuild, nProp);
	return iCan ;
}

// BEGIN_HELP_COMMENT
// Function: int UIWBFrame::GetErrorCount(void)
// Description: Get the number of errors from the last build. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A count of the number of errors from the last build.
// END_HELP_COMMENT
int UIWBFrame::GetErrorCount(void)
{
  	int nProp = 0, iCnt = -1 ;
	iCnt = PWnd()->SendMessage(m_msgGetErrorCount, nProp);
	return iCnt ;
}

// BEGIN_HELP_COMMENT
// Function: int UIWBFrame::GetWarningCount(void)
// Description: Get the number of warnings from the last build. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A count of the number of warnings from the last build.
// END_HELP_COMMENT
int UIWBFrame::GetWarningCount(void)
{
   	int nProp = 0, iCnt = -1 ;	
	iCnt = PWnd()->SendMessage(m_msgGetWarningCount, nProp);
	return iCnt ;
}

// BEGIN_HELP_COMMENT
// Function: HWND UIWBFrame::ClassWizard(void)
// Description: Display the ClassWizard dialog. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: The HWND of the ClassWizard dialog.
// END_HELP_COMMENT
HWND UIWBFrame::ClassWizard(void)
{
	WaitForInputIdle(g_hTargetProc, 6000);		// In case IDE is busy
    if( !DoCommand(IDMY_CLASSWIZARD, DC_MENU) )
        return NULL;    // Class Wizard wasn't on menu - must not be available
	Sleep(1000);
  	return MST.WGetActWnd(0);	//Attach to the ClassWizard dialog.
}                                                                                          ;

// BEGIN_HELP_COMMENT
// Function: HWND UIWBFrame::ProjectProperties(void)
// Description: Display the project properties. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: NULL
// END_HELP_COMMENT
HWND UIWBFrame::ProjectProperties(void)
{
// REVIEW(Ivan) This has been changed, we nolonger have the Settings menuitem on project.
//	DoCommand (IDM_PROJECT_CONFIGURE, DC_MNEMONIC);
//	WFndWndWaitC("Project Properties", "Static", FW_PART, 10);	// LOCALIZE
	return NULL ; // MST.WGetActWnd(0);
}

// BEGIN_HELP_COMMENT
// Function: HWND UIWBFrame::Options(void)
// Description: Display the Options dialog in the IDE. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: The HWND of the Options dialog.
// END_HELP_COMMENT
HWND UIWBFrame::Options(void)
{
	DoCommand(IDM_OPTIONS, DC_MNEMONIC);
	UIOptionsTabDlg uiopt;		
	return uiopt.WaitAttachActive(10000);
}


// BEGIN_HELP_COMMENT
// Function: HWND UIWBFrame::GetStatusBar(void)
// Description: Get the HWND of the IDE's status bar. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: The HWND of the status bar, if successful; NULL otherwise.
// END_HELP_COMMENT
HWND UIWBFrame::GetStatusBar(void)
{
	HWND hwndStatusBar = FindFirstChild(HWnd(), ID_STATUS_BAR);
	return hwndStatusBar;
}

// BEGIN_HELP_COMMENT
// Function: CString UIWBFrame::GetStatusText(void)
// Description: Get the text from the IDE's status bar. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A CString containing the text in the status bar.
// END_HELP_COMMENT
CString UIWBFrame::GetStatusText(void)		  // REVIEW (EnriqueP): Move to CWorkSpace
{
    HWND hwnd = GetStatusBar();
    return ::GetText(hwnd);
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::WaitForStatusText(LPCSTR sz, DWORD dwMilliSeconds, BOOL bExact /*=TRUE*/)
// Description: Wait for the given text (sz) to appear in the status bar. This function will wait until the text is displayed in the status bar or the number of milliseconds given in dwMilliSeconds have elapsed. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: TRUE if the text is found in the status bar before dwMilliSeconds elapses; FALSE otherwise.
// Param: sz A pointer to a string containing the text to wait for in the status bar.
// Param: dwMilliSeconds The number of milliseconds to wait for the text to appear.
// Param: bExact TRUE if the text in status bar must match the text in sz exactly; FALSE for a partial patch.
// END_HELP_COMMENT
BOOL UIWBFrame::WaitForStatusText(LPCSTR sz, DWORD dwMilliSeconds, BOOL bExact /*=TRUE*/)
{
    DWORD dwDone = 0;
    while( dwDone <= dwMilliSeconds )
    {
        CString strStatus = GetStatusText();
        if( bExact )
        {
            if( strStatus == sz )
                return TRUE;
        }
        else
        {
            if( strStatus.Find(sz) == 0 )   // check first part of string
                return TRUE;
        }

        if( dwDone >= dwMilliSeconds )  // no more waiting
            return FALSE;       // just say we didn't find it

        DWORD dwSleep = dwMilliSeconds - dwDone >= 1000 ? 1000 : dwMilliSeconds - dwDone;
        Sleep(dwSleep);     // wait another second (or whatever's left)
        dwDone += dwSleep;  // and try at least one more time
    }
    return FALSE;       // should never get hit
}

// REVIEW: larryh - When this CAN work, it needs to be fixed TO work.
// REVIEW(davidga): this will never work.  Use GetEditorCurPos or COSource::GetCurrentLine/Column


// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::VerifyFile(LPCSTR szfile)
// Description: Determine whether the active editor has the given filename in its title. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates whether the active editor has the given filename. TRUE if it does; FALSE otherwise.
// Param: szfile A pointer to a string containing the filename expected in the active editor.
// END_HELP_COMMENT
BOOL UIWBFrame::VerifyFile(LPCSTR szfile)
{
   CString caption;
   HWND hwnd = GetActiveEditor();
   MST.WGetText(hwnd, caption);
   return (((CString) caption).Find((CString)szfile) != (-1));
};


// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::VerifyCaretPosition( int nRow, int nCol, LPCSTR szErrTxt )
// Description: Verify the caret position in the active window. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: TRUE if the caret position matches the given row and column; FALSE otherwise.
// Param: nRow The expected row for the caret.
// Param: nCol The expected column for the caret.
// Param: szErrTxt A pointer to a string containing the text to emit to log if the caret position doesn't match the given row and column.
// END_HELP_COMMENT
BOOL UIWBFrame::VerifyCaretPosition( int nRow, int nCol, LPCSTR szErrTxt )
{
    char szBuffer[80];

	EXPECT( nRow >= 0 && nCol >= 0 );
	wsprintf( szBuffer, "Ln %d,Col %d", nRow, nCol );
		
	if (WaitForStatusText( szBuffer, (DWORD) 5000 /* 5 seconds */, TRUE ) )
		return TRUE;
	LOG->Comment( "VerifyCaretPosition: ",szErrTxt,": expected ",szBuffer," <> status bar column ",GetStatusText() );
	return FALSE;
}			

/*************************
**	FVerifyClipboardText
**		-larryh
**	just check the clipboard for the match string.
**
**	Clipboard is unaffected.
**/
// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::FVerifyClipboardText( CString stMatch )
// Description: Determine whether the text in the clipboard matches the given string. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates whether the text in the clipboard matches the given string. TRUE if it does; FALSE otherwise.
// Param: stMatch A CString that contains the text expected in the clipboard.
// END_HELP_COMMENT
BOOL UIWBFrame::FVerifyClipboardText( CString stMatch )
{
	CString	stClip;

	GetClipText( stClip );
	return (stClip == stMatch);
}
/*************************
**	FVerifySelection
**		-larryh
**	after a copy, stTest is compared to the clipboard.
**
**	Clipboard is toasted.
**/
// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::FVerifySelection( CString stTest )
// Description: Determine whether the selection in the active editor matches the given string. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates whether the selection in the active editor matches the given string. TRUE if it does; FALSE otherwise.
// Param: stTest A CString that contains the text expected in the selection.
// END_HELP_COMMENT
BOOL UIWBFrame::FVerifySelection( CString stTest )
{
	CString	stClip;

	// REVIEW larryh: How do we bail if no selection? Should we?
	// REVIEW larryh: allow different windows, defaulting to current
	DoCommand( ID_EDIT_COPY, DC_MNEMONIC );

	GetClipText( stClip );
	return (stClip == stTest);
}

/*************************
**	FVerifyLine
**		-larryh
**	the line at the cursor is selected, and verified
**
**	Clipboard is toasted.
**/

// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::FVerifyLine( CString stTest )
// Description: Determine whether the current line in the active editor matches the given string. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates whether the current line in the active editor matches the given string. TRUE if it does; FALSE otherwise.
// Param: stTest A CString that contains the text expected in the current line.
// END_HELP_COMMENT
BOOL UIWBFrame::FVerifyLine( CString stTest )
{
	MST.DoKeyshWnd(HWnd(), KEY_Home  );
	MST.DoKeyshWnd(HWnd(), "+{end}" );
	return FVerifySelection( stTest );
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::AddTBButton(int nButtonType, HWND hwndToolbar /* = NULL */)
// Description: Add a toolbar button (nButtonType) to the toolbar indicated by hwndToolbar. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: TRUE if successful; ERROR_ERROR otherwise.
// Param: nButtonType The button to add to the toolbar (this is NYI).
// Param: hwndToolbar The HWND of the toolbar to add the button to. NULL means create a new toolbar. (Default value is NULL.)
// END_HELP_COMMENT
BOOL UIWBFrame::AddTBButton(int nButtonType, HWND hwndToolbar /* = NULL */)
{
    EXPECT( IsWindowActive("Customize") );		//REVIEW: Verify Toolbars tab is set as well
    UIDialog uDlg;   // REVIEW(davidga): when UICustDlg is implemented, you can use ExpectValid instead
    uDlg.AttachActive();

    if ( hwndToolbar != NULL)                               // Put button in a toolbar else create new toolbar
    {
        EXPECT( IsWindowVisible(hwndToolbar) );

        DragMouse(VK_LBUTTON, uDlg, 155, 70, hwndToolbar, 2, 2);     //REVIEW: Button position is hardcoded
    }
    else
    {
        DragMouse(VK_LBUTTON, uDlg, 155, 70, HWnd(), 2, 2);
    }

    return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::SetToolbarCombo(LPCSTR str /*NULL*/)
// Description: Set the text in the standard toolbar's combo box. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: str A pointer to a string that contains the text to put in the toolbar's combo box.
// END_HELP_COMMENT
BOOL UIWBFrame::SetToolbarCombo(LPCSTR str /*NULL*/)
{
    MST.DoKeyshWnd(HWnd(),"%(a)");       // review WAYNEBR internationalize this line
    
	int iSec = 0;
	
	while(!MST.WComboExists(""))
	
	{
		if(iSec == 3)
		{
			LOG->RecordInfo("ERROR in UIWBFrame::SetToolbarCombo - toolbar combo didn't get focus within 3 seconds."); 
			return FALSE;
		}

		Sleep(1000);
		iSec++;
	}

	::WaitForInputIdle(g_hTargetProc,2000);

	if (str!=NULL)
        MST.DoKeyshWnd(HWnd(),str,TRUE);
    
	return TRUE;        // then user can do what he/she wishes
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::Break(int WAIT)
// Description: Select Break mode while debugging in the IDE. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: WAIT An integer indicating the amount of time to wait for Break state in the IDE.
// END_HELP_COMMENT
BOOL UIWBFrame::Break(int WAIT)

{
	// in case the debuggee is a GUI app, activate the ide and wait up to 10 seconds for it to come to the foreground.
	// TODO(michma - 2/25/98): why doesn't the code below work? Activate is failing for some reason.
	/*
	int iSec;

	if(!IsActive())
	
	{
		Activate();

		for(iSec = 0; iSec < 10; iSec++)
		
		{
			Sleep(1000);
		
			if(IsActive())
				break;
		}
	}

	if(iSec == 10)
	{
		LOG->RecordInfo("ERROR in UIWBFrame::Break() - could not activate IDE to issue command.");
		return FALSE;
	}
	*/

	if(!MST.WFndWndWait(GetLocString(IDSS_WORKBENCH_TITLEBAR), FW_PART | FW_FOCUS, 10))
	{
		LOG->RecordInfo("ERROR in UIWBFrame::Break() - could not activate IDE to issue command.");
		return FALSE;
	}

	// TODO(michma): for some reason the debugger gets hung when breaking into a GUI app if we choose the menu command 
	// via ms-test's functions like DoKeys (which DoCommand does). so we are working around this by sending the keys
	// more directly.
	// DoCommand(IDM_RUN_BREAK, DC_MNEMONIC);
	CString strDebugBreakHotKeys = ExtractHotKey(GetLocString(IDS_DEBUGMENU) + GetLocString(IDS_BREAK));
	WaitStepInstructions("Sending keys '%%%c%c'", strDebugBreakHotKeys[0], strDebugBreakHotKeys[1]);
	keybd_event(VK_MENU, 0,0,0);
	keybd_event(LOBYTE(VkKeyScan(strDebugBreakHotKeys[0])), 0,0,0);
	keybd_event(LOBYTE(VkKeyScan(strDebugBreakHotKeys[0])), 0,KEYEVENTF_KEYUP,0);
	keybd_event(VK_MENU, 0,KEYEVENTF_KEYUP,0);
	keybd_event(LOBYTE(VkKeyScan(strDebugBreakHotKeys[1])), 0,0,0);
	keybd_event(LOBYTE(VkKeyScan(strDebugBreakHotKeys[1])), 0,KEYEVENTF_KEYUP,0);
	
	return Wait(WAIT);
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::Go(int WAIT)
// Description: Start debugging the current project or run from a breakpoint. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: WAIT An integer indicating the amount of time to wait for Run state in the IDE.
// END_HELP_COMMENT
BOOL UIWBFrame::Go(int WAIT)
{
	BOOL nodebugee;
	if(m_pEventHandler!=NULL && m_pEventHandler->m_pDbg!=NULL)
	{
		DsExecutionState currentState;
		m_pEventHandler->m_pDbg->get_State(&currentState);
		nodebugee=(currentState==dsNoDebugee);
	}
	else
	{ //this is when Dbg object model does not work in which case we assign IDebugger* to NULL & revert to polling the title
		nodebugee=(GetIDEState() & ST_NODEBUG);
	}
	if(nodebugee)
	{
		DoCommand(IDM_RUN_GO, DC_ACCEL);
		::WaitForInputIdle(g_hTargetProc,2000);
		// this is to handle possible "does not contain debug info" dlg when starting debugging
		// of a retail exe in order to hit breakpoints in a dll (like controls in internet explorer).
		HWND hmsg;
		if(hmsg=MST.WFndWndWaitC(GetLocString(IDSS_DOES_NOT_CONTAIN_DEBUG_INFO), "Static", FW_PART, 2))
			MST.DoKeyshWnd(hmsg,"{ENTER}");
	}
	else
		DoCommand(IDM_RUN_GO, DC_ACCEL);

	// shouldn't wait for break or termination until we know that [run]
	// has been displayed. 
	if((WAIT != NOWAIT) && (WAIT != WAIT_FOR_RUN))
		WaitForRun();

	return Wait(WAIT,FALSE);    // Focus bug: do not check the debuggee's window
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::Restart(int WAIT)
// Description: Restart the current debugging session in the IDE. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: WAIT An integer indicating the amount of time to wait for Break state after restarting.
// END_HELP_COMMENT
BOOL UIWBFrame::Restart(int WAIT)

{
	LOG->RecordInfo("starting debugging, checking for find symbols dlg");
	// REVIEW(michma - 3/5/99): DoCommand uses DoKeys and that has severe problems on nt4 sp5. sometimes not all the
	// keystrokes get sent due to apparent journaling hook imcompatibilites with ms-test on that platform.
	//DoCommand(IDM_RUN_RESTART, DC_ACCEL);
	WaitStepInstructions("Sending keys '+({F5})'");
	keybd_event(VK_SHIFT, 0,0,0);
	keybd_event(VK_F5, 0,0,0);
	keybd_event(VK_F5, 0,KEYEVENTF_KEYUP,0);
	keybd_event(VK_SHIFT, 0,KEYEVENTF_KEYUP,0);

	// shouldn't wait for break or termination until we know that [run]
	// has been displayed. 
	if((WAIT != NOWAIT) && (WAIT != WAIT_FOR_RUN))
		WaitForRun();

	return Wait(WAIT);
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::StopDebugging(int WAIT)
// Description: Stop the current debugging session in the IDE. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: WAIT An integer indicating the amount of time to wait for the debugging session to end.
// END_HELP_COMMENT
BOOL UIWBFrame::StopDebugging(int WAIT)
{
	DoCommand(IDM_RUN_STOPDEBUGGING, DC_MNEMONIC);
	return Wait(WAIT);
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::StepInto(int WAIT)
// Description: Perform a step into in the current debugging session (or start debugging the current project, if not already). NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: WAIT An integer indicating the amount of time to wait for Break state in the IDE.
// END_HELP_COMMENT
BOOL UIWBFrame::StepInto(int WAIT)
{
	BOOL nodebugee;
	if(m_pEventHandler!=NULL && m_pEventHandler->m_pDbg!=NULL)
	{
		DsExecutionState currentState;
		m_pEventHandler->m_pDbg->get_State(&currentState);
		nodebugee=(currentState==dsNoDebugee);
	}
	else
	{	//this is when Dbg object model does not work in which case we assign IDebugger* to NULL & revert to polling the title
		nodebugee=(GetIDEState() & ST_NODEBUG);
	}
	DoCommand(IDM_RUN_TRACEINTO, DC_ACCEL);
	
	// shouldn't wait for break or termination until we know that [run]
	// has been displayed. 
	if((WAIT != NOWAIT) && (WAIT != WAIT_FOR_RUN))
	{	
		LOG->Comment("UIWBFrame::StepInto - about to call WaitForRun");
		WaitForRun();
	}

	LOG->Comment("UIWBFrame::StepInto - about to call Wait(%d)", WAIT);
	return Wait(WAIT);
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::StepOver(int WAIT)
// Description: Perform a step over in the current debugging session (or start debugging the current project, if not already). NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: WAIT An integer indicating the amount of time to wait for Break state in the IDE.
// END_HELP_COMMENT
BOOL UIWBFrame::StepOver(int WAIT)
{
	BOOL nodebugee;
	if(m_pEventHandler!=NULL && m_pEventHandler->m_pDbg!=NULL)
	{
		DsExecutionState currentState;
		m_pEventHandler->m_pDbg->get_State(&currentState);
		nodebugee=(currentState==dsNoDebugee);
	}
	else
	{	//this is when Dbg object model does not work in which case we assign IDebugger* to NULL & revert to polling the title
		nodebugee=(GetIDEState() & ST_NODEBUG);
	}
	DoCommand(IDM_RUN_STEPOVER, DC_ACCEL);

	// shouldn't wait for break or termination until we know that [run]
	// has been displayed. 
	if((WAIT != NOWAIT) && (WAIT != WAIT_FOR_RUN))
		WaitForRun();

	return Wait(WAIT);
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::StepOut(int WAIT)
// Description: Perform a step out in the current debugging session. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: WAIT An integer indicating the amount of time to wait for Break state in the IDE.
// END_HELP_COMMENT
BOOL UIWBFrame::StepOut(int WAIT)
{
	DoCommand(IDM_RUN_STOPAFTERRETURN, DC_MNEMONIC);

	// shouldn't wait for break or termination until we know that [run]
	// has been displayed. 
	if((WAIT != NOWAIT) && (WAIT != WAIT_FOR_RUN))
		WaitForRun();

	return Wait(WAIT,FALSE);    // Focus bug: do not check the debuggee's window
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::StepToCursor(int WAIT)
// Description: Perform a step to cursor in the current debugging session (or start debugging the current project, if not already). NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: WAIT An integer indicating the amount of time to wait for Break state in the IDE.
// END_HELP_COMMENT
BOOL UIWBFrame::StepToCursor(int WAIT)
{
	// REVIEW (michma): timing problem in ide (not cafe), won't fix.
	Sleep(1000);
	BOOL nodebugee;
	if(m_pEventHandler!=NULL && m_pEventHandler->m_pDbg!=NULL)
	{
		DsExecutionState currentState;
		m_pEventHandler->m_pDbg->get_State(&currentState);
		nodebugee=(currentState==dsNoDebugee);
	}
	else
	{	//this is when Dbg object model does not work in which case we assign IDebugger* to NULL & revert to polling the title
		nodebugee=(GetIDEState() & ST_NODEBUG);
	}
	DoCommand(IDM_RUN_TOCURSOR, DC_ACCEL);

	WaitForInputIdle(g_hTargetProc, 10000);

	// The following is a workaround to bypass a strange occurrence that sometimes happens.  Basically
	// every once in a while when the a breakpoint is hit (doesn't matter if it's a RunToCursor, or
	// a SetBreakpoint/Go/SetBreakpoint combination, the debuggee will break, but not become cleared
	// from the display, this seems to cause problems for the sniffs that use this function.
	MST.DoKeys("{Right}{Left}");

	// shouldn't wait for break or termination until we know that [run]
	// has been displayed. 
	if((WAIT != NOWAIT) && (WAIT != WAIT_FOR_RUN))
		WaitForRun();

	BOOL bSuccess = Wait(WAIT, FALSE);
	return bSuccess;    // Focus bug: do not check the debuggee's window
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::ToggleBreakpoint(void)
// Description: Toggle a breakpoint at the current line in the active editor. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWBFrame::ToggleBreakpoint(void)             //REVIEW: Add extra functionality to make worthwhile.
{
	MST.DoKeys(KEY_TOGGLE_BREAKPOINT);		   //REVIEW: changed to DoCommand when available.
	return TRUE;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::SetNextStatement(void)
// Description: Set the next statement to be executed in the debugger to the current line in the current editor. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWBFrame::SetNextStatement(void)
	{
	EXPECT(IsActive());
	//REVIEW: this command has no menu/accel access, only hotkey. michma
	//DoCommand(IDM_RUN_SETNEXTSTMT, DC_ACCEL);
	MST.DoKeys("^(+({f7}))");
	return TRUE;
	}


// REVIEW(briancr): this needs to be code reviewed
// return the current state of the IDE
// this includes: exists, active, minimized, maximized, restored,
// not debugging, debugging at a breakpoint, debugging running debuggee
// TODO: add support for other state indicators
// (davidga): we need to review the list of useful states
// BEGIN_HELP_COMMENT
// Function: UINT UIWBFrame::GetIDEState(void)
// Description: Get the state of the IDE. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: An bitfield representing the state of the IDE: ST_EXISTS | ST_ACTIVE | ST_MIN | ST_MAX | ST_RES | ST_NODEBUG | ST_DEBUGBREAK | ST_DEBUGRUN | ST_BUILDING.
// END_HELP_COMMENT
UINT UIWBFrame::GetIDEState(void)
{
//	REVIEW(michma - 10/22/97): why are we doing this? it seems to screw up the focus of the
//	ide, and it wasn't like this too long ago. we need to be able to check the ide's
//	title bar without messing with the focus.
//	MST.WSetActWnd(HWnd());
//	XSAFETY;

	UINT state = 0;

#if 1
	//
	//	Check title string to determine debug state.  IsCommandEnabled() has proved to
	//	be unreliable on fast build machines.
	//
	CString szTitleBreak;
	CString szTitleRun;
	szTitleBreak  = "[";
	szTitleBreak += GetLocString(IDSS_DBG_BREAK);
	szTitleBreak += "]";
	szTitleRun  = "[";
	szTitleRun += GetLocString(IDSS_DBG_RUN);
	szTitleRun += "]";

	CString szTitle;
	MST.WGetText(HWnd(), szTitle);

	if( szTitle.Find(szTitleBreak) >= 0 ) {
		state |= ST_DEBUGBREAK;
	}
	else if( szTitle.Find(szTitleRun) >= 0 ) {
		state |= ST_DEBUGRUN;
	}
	else {
		state |= ST_NODEBUG;
	}

#else
	BOOL bStop = IsCommandEnabled(IDM_RUN_STOPDEBUGGING);
	BOOL bBreak = IsCommandEnabled(IDM_RUN_BREAK);
	if( !bStop )
		state |= ST_NODEBUG;
	if( bStop && !bBreak )
		state |= ST_DEBUGBREAK;
	if( bStop && bBreak )
		state |= ST_DEBUGRUN;
#endif

	if( !IsCommandEnabled(IDM_PROJECT_STOP_BUILD) )
		state |= ST_BUILDING;

	return state;
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::Wait(int option, BOOL bCheckDebuggeeWindow /*TRUE*/)
// Description: Wait for the IDE debugger to be in a known state. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: option An integer that indicates the type of wait: 0 (no wait), WAIT_FOR_RUN, WAIT_FOR_BREAK, WAIT_FOR_TERMINATION, ASSUME_NORMAL_TERMINATION, WAIT_FOR_EXCEPTION.
// Param: BOOL bLeaveFindSource A Boolean value indicated whether or not to leave the Find Source dlg up at the break.
// END_HELP_COMMENT
BOOL UIWBFrame::Wait(int option, BOOL bCheckDebuggeeWindow /*TRUE*/, BOOL bLeaveFindSource /* FALSE */)  		//TODO: needs to be more robust (time-limits, FALSE returns, etc.)
{
	BOOL Success=FALSE;
	
	switch(option)
	{
		case 0:      /* NOWAIT */
			{
			Success = TRUE;
			break;			
			}
		case WAIT_FOR_RUN:
			{
			Success = WaitForRun();
			break;			
			}
		case WAIT_FOR_BREAK:
			{
			Success = WaitForBreak(bLeaveFindSource);
			break;			
			}
		case WAIT_FOR_TERMINATION:
		case ASSUME_NORMAL_TERMINATION:
			{
			Success = WaitForTermination(); // msgbox removed so needn't dismiss msgbox anymore
			break;
			}
		case WAIT_FOR_EXCEPTION:
			{
			Success = WaitForException();
			break;
			}
		case WAIT_FOR_CODED_BREAK:
			{
			Success = WaitForCodedBreak();
			break;
			}
	}
	
	return Success;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::WaitForBreak(BOOL bLeaveFindSource /* FALSE */)
// Description: Wait for the IDE to be in Break state. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: BOOL bLeaveFindSource A Boolean value indicated whether or not to leave the Find Source dlg up at the break.
// END_HELP_COMMENT
BOOL UIWBFrame::WaitForBreak(BOOL bLeaveFindSource /* FALSE */)
{
	UIWBMessageBox mb;
	UIDialog db(GetLocString(IDSS_FS_TITLE));		// ExpectedTitle
	CString strBreak	= GetLocString(IDSS_DBG_BREAK);
	CString strBreakAt	= GetLocString(IDSS_DBG_BREAK_AT);
	CString strTitleBreak = "[";
	strTitleBreak += strBreak + "]";

	if(m_pEventHandler!=NULL && m_pEventHandler->m_pDbg!=NULL)
	{
		CString strTitleEnc ="[" + GetLocString(IDSS_EC_TITLE) + "]";
		DsExecutionState currentState = dsRunning; //assume it's called when debugee is running
		for (int i=0; i<2*5*60; i++)
		{
			m_pEventHandler->m_pDbg->get_State(&currentState);
			if(currentState==dsBreak)
			{
				if(GetText().Find(strTitleEnc)>0)  
				{	//REVIEW(chriskoz): dbg reports state==dsBreak during EnC build, which is bogus.
					//But it won't change soon; we need to workaround by polling the UIWB window title against [Edit and Continue]
					if(i % 10 ==0)
						LOG->RecordInfo("WaitForBreak: Reached break but Edit & continue state displayed. Waiting for Enc to complete...");
				}
				else
				{
					LOG->RecordInfo("WaitForBreak: Reached break state!");
					break;
				}
			}
			if(i % 10 ==0)
				LOG->Comment("WaitForBreak: didn't reach break state: Waiting additional 5 sec...");
			Sleep(500);
		}
		if(currentState!=dsBreak)
		{
			LOG->RecordFailure("Break state not reached within 5 minutes...");
			return FALSE;
		}
//REVIEW(chriskoz) these are the message boxes I don't want to handle asyncronously in CTarget class
//CTarget handles FindSymbols & FindSource dialogs

		// Handle the case of a dialog (data breakpoint)
		// If "Break at" is in the dialog then it's an expected dialog, otherwise
		// something unexpected has happened, return FALSE.
		// REVIEW(BruceKu): Should we handle the FALSE case better with an EXPECT(FALSE)?
		if( mb.AttachActive() )
		{
			BOOL b = mb.GetMessageText().Find(strBreakAt) >= 0;
			mb.ButtonClick();
			return b;
		}

		//
		//	Handle case where [break] is in title and Edit and Continue dialog is displayed
		//
		UIDialog dbEC(GetLocString(IDSS_EC_TITLE));		// ExpectedTitle
		if(dbEC.AttachActive())
		{
			// Check for Edit and Continue dialog, dismiss it.
			if(dbEC.VerifyTitle())
				return TRUE;
		}

		if( !HasFocus() )
		{  //TODO: unfortunately, we return from break when Find Source or Find Symbol Dialog is still there. Try to get rid of any dialog
			UIDialog db;
			db.AttachActive();
			if(bLeaveFindSource && db.GetText()==GetLocString(IDSS_FS_TITLE))
				return TRUE; //special case for Find Source dialog, which is expected here
			LOG->RecordInfo( "Debugger in break state. But unexpected dialog '%s' has stolen the focus. Hitting ESC & forcing focus to IDE", db.GetText());
			MST.DoKeys("{ESC}");
			this->Activate();
		}
		return TRUE;
	}
	//	While [break] does not appear in the caption 3 times then loop
	//  60 sec     maxTimeOut value so we do not starve.
	int ct = 0;
	int nTSec = 0;
	int nSecMaxWaitForBreak = 60 * 5;	// Wait max of 5 minutes
	while(ct <= 3)
	{
		if( GetText().Find(strTitleBreak) < 0 )
		{
			//
			//	Check dialog( for compatibility of break at dialog up before
			//	break is signalled in title.  Can remove this code when IDE
			//	change is fully implemented across platforms.
			//
			if( db.AttachActive() )
			{
				// Check for FindSource dialog, dismiss it.
				if( db.VerifyTitle() )
					db.Cancel();
				else
				{
					CString msg = "Unexpected dialog box:  ";
					msg += db.GetText();
					msg += " Dismissing.";

					LOG->RecordInfo( msg.GetBuffer(256) );
					MST.DoKeys("{enter}");					// Dismiss Unexpected msgbox
					return FALSE; 							// FAIL due to Unexpected msgbox
				}
			}
			else if( mb.AttachActive() )		// No need to wait since db waited 1 sec.
			{
				BOOL b = mb.GetMessageText().Find(strBreakAt) >= 0;
				mb.ButtonClick();
				if( !b ) {
					return b;
				}
				//
				//	Once dialog is handled, [break] should appear in title and be
				//	handled properly by 'while(ct <= 3)' loop.
				//
			}
	

			// No break yet, in [run] state
			if( nTSec >= nSecMaxWaitForBreak )
			{
				LOG->RecordFailure( "Break state not reached within %d minute(s) %d seconds.  Exitting test..", nSecMaxWaitForBreak/60, nSecMaxWaitForBreak%60);
				EXPECT( FALSE );
			}
			Sleep(1000);		// increment a second - Let target run...
			nTSec++;
		}
		else // Break state
		{	//REVIEW (chriskoz) I have no clue what this idiot "ct" variable is doing here
			//but it shld log "success" message only once
			if(++ct>3)
			LOG->RecordInfo("Found %s in IDE title, don't wait anymore.", strTitleBreak);
		}
	}
	::WaitForInputIdle(g_hTargetProc,3000);
	Sleep(2000);	// Give time for full IDE reactivation.

	//
	//	Handle case where [break] is in title and Find Source dialog is displayed
	//
	if( db.AttachActive() )
	{
		// Check for FindSource dialog, dismiss it.
		if( db.VerifyTitle() )
		{
			if(bLeaveFindSource)
				return TRUE;
			else
				db.Cancel();
		}
		else
		{
			CString msg = "Unexpected dialog box:  ";
			msg += db.GetText();
			msg += " Dismissing.";

			LOG->RecordInfo( msg.GetBuffer(256) );
			MST.DoKeys("{enter}");					// Dismiss Unexpected msgbox
			return FALSE; 							// FAIL due to Unexpected msgbox
		}
	}


	//
	//	Handle case where [break] is in title and Edit and Continue dialog is displayed
	//
	UIDialog dbEC(GetLocString(IDSS_EC_TITLE));		// ExpectedTitle
	if(dbEC.AttachActive())
	{
		// Check for Edit and Continue dialog, dismiss it.
		if(dbEC.VerifyTitle())
			return TRUE;
	}

	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::WaitForTermination(void)
// Description: Wait for the IDE to terminate the current debugger session. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWBFrame::WaitForTermination(void)
{
	CString szTitleBreak, szTitleRun, text;
	szTitleBreak  = "[";
	szTitleBreak += GetLocString(IDSS_DBG_BREAK);
	szTitleBreak += "]";
	szTitleRun  = "[";
	szTitleRun += GetLocString(IDSS_DBG_RUN);
	szTitleRun += "]";

	MST.WGetText(HWnd(), text);

	if(m_pEventHandler!=NULL && m_pEventHandler->m_pDbg!=NULL)
	{
		DsExecutionState currentState = dsRunning; //assume it's called when debugee is running
		for (int i=0; i<120; i++)
		{
			m_pEventHandler->m_pDbg->get_State(&currentState);
			if(currentState==dsNoDebugee)
			{
				LOG->RecordInfo("Reached break state: don't wait anymore.");
				break;
			}
			Sleep(500);
		}
		if(currentState!=dsNoDebugee)
		{
			LOG->RecordFailure("Timed out waiting for termination to occur.");
			return FALSE;
		}
		return TRUE;
	}

	int i;
	for(i = 0; i < 10; i++)
	{
		if(text.Find(szTitleRun) == -1 && text.Find(szTitleBreak) == -1)
			break; //neither "break" nor "run"
		LOG->RecordInfo("UIWBFrame::WaitForTermination(): ide title is %s", text);
		MST.WGetText(HWnd(), text);			

		// REVIEW: Waynebr  this should handle hitting an unexpected msgbox
		if (MST.WFndWndWaitC(GetLocString(IDSS_WORKBENCH_TITLEBAR), "#32770", FW_NOCASE | FW_PART,1))
		{
			MST.DoKeys("{enter}");						// Dismiss Unexpected msgbox
			return FALSE; 								// FAIL due to Unexpected msgbox
		}
	}

	if (i == 10)
	{
		LOG->RecordFailure("UIWBFrame::WaitForTermination(): Timed out waiting for termination to occur.");
		return FALSE;				// Timed out waiting for IDE to comeback.
	}

	WaitForInputIdle(g_hTargetProc, 60000);		// WinslowF - Wait for deebugee to close. UI update delays.
	this->Activate();	// WinslowF - If focus problems make sure the DE has the focus.

	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::WaitForRun(void)
// Description: Wait for the IDE to be in Run state. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWBFrame::WaitForRun(void)
{
	CString szTitleRun, text;
	szTitleRun  = "[";
	szTitleRun += GetLocString(IDSS_DBG_RUN);
	szTitleRun +="]";

#if 0 /* pre-xbox code */
	if(m_pEventHandler!=NULL && m_pEventHandler->m_pDbg!=NULL)
	{
		DsExecutionState state;
		Sleep(200); //TODO adjust the sleep here

		m_pEventHandler->m_pDbg->get_State(&state);
		if(state==dsRunning)
			return TRUE;
		LOG->RecordInfo("WARNING: WaitForRun(): didn't reach run state within 0.2 sec");
		return FALSE;
	}
#else
	LOG->RecordInfo("WaitForRun(): waiting for dsState to become dsRunning");
	if(m_pEventHandler!=NULL && m_pEventHandler->m_pDbg!=NULL)
	{
		int sleepTotal = 0;
		DsExecutionState state;

		while (sleepTotal < 60000)
		{
			Sleep(200); //TODO adjust the sleep here
			sleepTotal += 200;

			m_pEventHandler->m_pDbg->get_State(&state);
			if(state==dsRunning)
			{
				LOG->RecordInfo("WaitForRun(): dsExecutionState toggled to dsRunning at %d ms", sleepTotal);
				return TRUE;
			}
		}
		LOG->RecordInfo("WARNING: WaitForRun(): didn't reach run state within 6000 ms");
		return FALSE;
	}
#endif

	int i = 0;

	// only wait 1 seconds for debugee to start running
	while(i < 2)
		{
		MST.WGetText(HWnd(), text);
		
		if(text.Find(szTitleRun) != -1)
			break;
				
		Sleep(500);
		if(++i==2)
			LOG->RecordInfo("UIWBFrame::WaitForRun(): ide title is %s", text);
		}

	if(i == 2)
	{
		LOG->RecordInfo("WARNING: UIWBFrame::WaitForRun(): could not find %s "
						"in ide title bar within 1 seconds", szTitleRun);
		return FALSE;
	}
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::WaitForException(void)
// Description: Wait for the IDE to catch an exception while debugging. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWBFrame::WaitForException(void)		// exception must be hit within five minutes
																		
	{																	
	if(MST.WFndWndWaitC("Exception", "Static", FW_DEFAULT | FW_PART, 300))
		{
		MST.WButtonClick(GetLabel(MSG_OK));				// Dismiss Exception hit msgbox
		return TRUE;
		}
	
	return FALSE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::WaitForCodedBreak(void)
// Description: This function waits for (up to 1 minute) and ok's a coded break notification msg box (ie. _int 3 for x86, Debugger() for mac)
// Return: returns TRUE if the msg box comes up within 1 minute, FALSE if not.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
BOOL UIWBFrame::WaitForCodedBreak(void)		
																		
	{																	
	if(MST.WFndWndWaitC("User breakpoint called from code at 0x", "Static", FW_PART, 60))
		{
		MST.WButtonClick(GetLabel(MSG_OK));				// Dismiss Exception hit msgbox
		return TRUE;
		}
	
	LOG->RecordInfo("WARNING in UIWBFrame::WaitForCodedBreak(): coded break not detected within 1 minute.");
	return FALSE;
	}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::BuildProject(void)
// Description: Build the current project. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWBFrame::BuildProject(void)

{
	EXPECT(IsValid() & IsActive());
	DoCommand(IDM_PROJITEM_BUILD, DC_MNEMONIC);
	while(GetIDEState() & ST_BUILDING);
	return TRUE;
}

// TODO:this function is out of date.  needs to handle platform-specific project directories
// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::DeleteProject(LPCSTR szProjName, LPCSTR szDir)
// Description: Delete the project with the name szProjName. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: szProjName A pointer to a string containing the name of the project to delete.
// Param: szDir A pointer to a string containing the project's directory. NULL means use the current directory.
// END_HELP_COMMENT
BOOL UIWBFrame::DeleteProject(LPCSTR szProjName, LPCSTR szDir)

	{
	WIN32_FIND_DATA wfd;							//TODO: move this to DeleteProject function in wbutil
	HANDLE h;										//		class when its created.
	CString cstrDir = (szDir != NULL) ? szDir : ".";

	if((h = FindFirstFile(cstrDir + "\\" + szProjName + ".*", &wfd)) != INVALID_HANDLE_VALUE)
	
		{
		DeleteFile(cstrDir + "\\" + wfd.cFileName);

		while(FindNextFile(h, &wfd))
			DeleteFile(cstrDir + "\\" + wfd.cFileName);

		FindClose(h);
		}

	return TRUE;
	}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::VerifyProjectRan(LPCSTR szProject)
// Description: Determine if the current project ran by checking the active message box for the string "exit code 0." NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: szProject A pointer to a string containing the name of the project.
// END_HELP_COMMENT
BOOL UIWBFrame::VerifyProjectRan(LPCSTR szProject)
{
	UIWBMessageBox uiwbmb;
	uiwbmb.WaitAttachActive(1000);
	CString str = uiwbmb.GetMessageText();
	if( str.Find("exit code 0") < 0 )
		return FALSE;

	uiwbmb.ButtonClick(MSG_OK);
	return TRUE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::VerifySubstringAtLine( LPCSTR stSubstring, BOOL nCase /* FALSE */)
// Description: Determine if the given string (stSubString) is contained within the current line in the current editor. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: stSubString A pointer to a string that contains the substring to search for.
// END_HELP_COMMENT
BOOL UIWBFrame::VerifySubstringAtLine(LPCSTR stSubstring, BOOL nCase /* FALSE */)

	{
	// Select the current line
	MST.DoKeys("{home}");
	MST.DoKeys("+{end}");

	// if source line in question displays same string
	// over 500 ms, we'll assume it is done painting.
	// we'll only wait 5 seconds though.
	CString last;
	CString current;
	DoCommand(ID_EDIT_COPY, DC_ACCEL);
	GetClipText(last);					// WinslowF remove EXPECT( )

	for(int i = 0; i < 10; i++)
		
		{
		Sleep(500);
		DoCommand(ID_EDIT_COPY, DC_ACCEL);
		GetClipText(current);					// WinslowF remove EXPECT( )

		if((current == last) && (current != ""))
			break;
		
		last = current;
		}


	LOG->RecordInfo("UIWBFrame::VerifySubstringAtLine(): current line = \"%s\".", current);

	if (nCase)							// WinslowF - added for case insensitive surch.
		{
		current.MakeLower();
		CString szTemp = stSubstring;
		szTemp.MakeLower();
		if(current.Find(szTemp) < 0)
			return FALSE;
		else
			return TRUE;
		}
	else
		{
		if(current.Find(stSubstring) < 0)
			return FALSE;
		else
			return TRUE;
		}
	}


// BEGIN_HELP_COMMENT
// Function: int UIWBFrame::GetMemoryWidth(void)
// Description: Get the width of the memory window. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: An integer containing the width of the memory window.
// END_HELP_COMMENT
int UIWBFrame::GetMemoryWidth(void)			//must only set width with SetMemoryWidth!			
{
	return m_MemWidth;
}


// BEGIN_HELP_COMMENT
// Function: MEM_FORMAT UIWBFrame::GetMemoryFormat(void)
// Description: Get the format of the memory window. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A MEM_FORMAT value containing the format of the memory window: MEM_FORMAT_ASCII, MEM_FORMAT_WCHAR, MEM_FORMAT_BYTE, MEM_FORMAT_SHORT, MEM_FORMAT_SHORT_HEX, MEM_FORMAT_SHORT_UNSIGNED, MEM_FORMAT_LONG, MEM_FORMAT_LONG_HEX, MEM_FORMAT_LONG_UNSIGNED, MEM_FORMAT_REAL, MEM_FORMAT_REAL_LONG.
// Param: Param The parameter description(s) for this function are not available.
// END_HELP_COMMENT
MEM_FORMAT UIWBFrame::GetMemoryFormat(void)		//must only set format with SetMemoryFormat!
	{
	return m_MemFormat;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::SetMemoryWidth(int width)
// Description: Set the width of the memory window. This function is NYI. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: width An integer containing the width to set the memory window to.
// END_HELP_COMMENT
BOOL UIWBFrame::SetMemoryWidth(int width)	// sets fixed width
	{
	//TODO
	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::SetMemoryFormat(MEM_FORMAT format)	
// Description: Set the format of the memory window. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates success. TRUE if successful; FALSE otherwise.
// Param: format A MEM_FORMAT value specifying the format of the memory window: MEM_FORMAT_ASCII, MEM_FORMAT_WCHAR, MEM_FORMAT_BYTE, MEM_FORMAT_SHORT, MEM_FORMAT_SHORT_HEX, MEM_FORMAT_SHORT_UNSIGNED, MEM_FORMAT_LONG, MEM_FORMAT_LONG_HEX, MEM_FORMAT_LONG_UNSIGNED, MEM_FORMAT_REAL, MEM_FORMAT_REAL_LONG.
// END_HELP_COMMENT
BOOL UIWBFrame::SetMemoryFormat(MEM_FORMAT format)	
	{
	UIOptionsTabDlg uiopt;
	uiopt.Display();
	uiopt.ShowPage(TAB_DEBUG, 6);
	MST.WComboItemClk(uiopt.GetLabel(VCPP32_IDC_DEBUG_FORMAT), format + 1);
	uiopt.OK();
	m_MemFormat = format;
	return TRUE;
	}


// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::WaitOnWndWithCtrl(INT ID, DWORD dwMillSec )
// Description: Wait for a window that has a control with the given ID on it. This function will wait up to dwMillSec milliseconds. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value that indicates success. TRUE if the window was found within the specified time; FALSE otherwise.
// Param: ID The id of the control to wait for.
// Param: dwMillSec The number of milliseconds to wait for the window with the control.
// END_HELP_COMMENT
BOOL UIWBFrame::WaitOnWndWithCtrl(INT ID, DWORD dwMillSec )
{
	//REVIEW(chriskoz) obsolete & stupid wrapper but let's keep it for now (it's called throughout support)
	//would be useful if it returned HWND & restricted the search to the windows owned by the target process
	return (WaitForWndWithCtrl(ID, dwMillSec)!=NULL); // Defined in ..\cafe\src\testutil.cpp
}

// BEGIN_HELP_COMMENT
// Function: HWND UIWBFrame::FileOpenDlg(void)
// Description: Open the File Open dialog. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: The HWND of the File Open dialog, if successful; NULL otherwise.
// END_HELP_COMMENT
HWND UIWBFrame::FileOpenDlg(void)
{
	DoCommand(ID_FILE_OPEN, DC_MNEMONIC);
	UIFileOpenDlg ufod;
	ufod.WaitAttachActive(15000);
	return ufod.HWnd();
}

// BEGIN_HELP_COMMENT
// Function: HWND UIWBFrame::FileSaveAsDlg(void)
// Description: Open the File Save As dialog. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: The HWND of the File Save As dialog, if successful; NULL otherwise.
// END_HELP_COMMENT
HWND UIWBFrame::FileSaveAsDlg(void)
{
	DoCommand(ID_FILE_SAVE_AS, DC_MNEMONIC);
	UIFileSaveAsDlg ufsad;
	ufsad.WaitAttachActive(5000);
	return ufsad.HWnd();
}

// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::GetPcodeSwitch(void)
// Description: Get the value of the CAFE PCode switch. NOTE: This function is obsolete; use an applicable function from the CO class that represents the editor you wish to use.
// Return: A Boolean value: TRUE if the switch is set; FALSE otherwise.
// END_HELP_COMMENT
BOOL UIWBFrame::GetPcodeSwitch(void)
{
	CString	cstrSwitch;

//	cstrSwitch = CMDLINE->GetTextValue("pcode");
	cstrSwitch = CMDLINE->GetTextValue("pcode");

	if(cstrSwitch == "yes") 
		return TRUE;
	else
		return FALSE;
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIWBFrame::CheckForFindLocalModuleDlgs(void)
// Description: this function cancels any Find Local Module dlgs that come up after starting debugging (used only for win32s).
// Return: void
// END_HELP_COMMENT
void UIWBFrame::HandleFindLocalModuleDlgs(void)
	{
	// if we don't see a dlg within 5 seconds, we're likely not gonna see any.
	//REVIEW(chriskoz) obsolete - MSTEST4.0 handles the timeout
	//for(int i = 0; i < 5; i++)
	//	{
	//	Sleep(1000);
		if(MST.WFndWnd(GetLocString(IDSS_FIND_LOCAL_MODULE_DLG_TITLE), FW_DEFAULT))
			
			{
			// we saw a dlg withtin 5 seconds, so we're likely to get more over the next 20 seconds.
			for(int j = 0; j < 20; j++)
				{
				if(MST.WFndWndWait(GetLocString(IDSS_FIND_LOCAL_MODULE_DLG_TITLE), FW_DEFAULT,1))
					MST.WButtonClick(GetLocString(IDSS_CANCEL));
				}

//			break;
			}
//		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\wbutil.h ===
///////////////////////////////////////////////////////////////////////////////
//  WBUTIL.H
//
//  Created by :            Date :
//      DavidGa                 12/2/93
//
//  Description :
//      Declaration of workbench-specific global utility functions
//

#ifndef __WBUTIL_H__
#define __WBUTIL_H__

#include "Strings.h"

#include "shlxprt.h"

///////////////////////////////////////////////////////////////////////////////
//  Global utility functions

SHL_API CString GetLocString(UINT id, int nLang = -1);

extern CString target_platform_str[];

typedef enum {PLATFORM_WIN32_X86 	= 0x00000001,
			  PLATFORM_WIN32S_X86 	= 0x00000002,
			  PLATFORM_MAC_68K   	= 0x00000004,
			  PLATFORM_MAC_PPC		= 0x00000008, 
			  PLATFORM_WIN32_MIPS	= 0x00000010,
			  PLATFORM_WIN32_ALPHA	= 0x00000020,
			  PLATFORM_WIN32_PPC	= 0x00000040,
			  // xbox-specific
			  PLATFORM_XBOX			= 0x00000080,
			  // add new platforms above this line
			  PLATFORM_CURRENT		= 0x20000000,
			  PLATFORM_USER			= 0x40000000,
			  PLATFORM_NON_USER		= 0x80000000} PLATFORM_TYPE;

SHL_API int GetUserTargetPlatforms(void);

#endif //__WBUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\uwbframe.h ===
///////////////////////////////////////////////////////////////////////////////
//  UWBFRAME.H
//
//  Created by :            Date :
//      DavidGa                 9/23/93
//
//  Description :
//      Declaration of the UIWBFrame class
//

#ifndef __UIWBFRAME_H__
#define __UIWBFRAME_H__

#include "..\..\uwindow.h"
#include "umainfrm.h"
#include "target.h" //TODO it shoud be moved to some more basic class (like UIWindow)
#include "shlxprt.h"

#ifndef __UIWINDOW_H__
    #error include 'uwindow.h' before including this file
#endif

#define MAKEDOCID(pkgId,wdId) {MAKELONG(pkgId,wdId)}

// forward declaration
class CEventHandler;
enum EGECP { GECP_LINE = 0, GECP_COLUMN = 1 };


// Debug Wait States
enum {  NOWAIT,  
		WAIT_FOR_RUN,
        WAIT_FOR_BREAK,
        WAIT_FOR_TERMINATION,
        ASSUME_NORMAL_TERMINATION,
        WAIT_FOR_EXCEPTION,
		WAIT_FOR_CODED_BREAK};

// memory format options

typedef enum {	MEM_FORMAT_ASCII = 0,
				MEM_FORMAT_WCHAR,
				MEM_FORMAT_BYTE,
				MEM_FORMAT_SHORT,
				MEM_FORMAT_SHORT_HEX,
				MEM_FORMAT_SHORT_UNSIGNED,
				MEM_FORMAT_LONG,
				MEM_FORMAT_LONG_HEX,
				MEM_FORMAT_LONG_UNSIGNED,
				MEM_FORMAT_REAL,
				MEM_FORMAT_REAL_LONG,
				MEM_FORMAT_INT64,
				MEM_FORMAT_INT64_HEX,
				MEM_FORMAT_INT64_UNSIGNED
			} MEM_FORMAT;
			
			
///////////////////////////////////////////////////////////////////////////////
//  UIWBFrame class

// BEGIN_CLASS_HELP
// ClassName: UIWBFrame
// BaseClass: UIMainFrm
// Category: Shell
// END_CLASS_HELP
class SHL_CLASS UIWBFrame : public UIMainFrm
{
    UIWND_COPY_CTOR(UIWBFrame, UIMainFrm);
	operator BOOL ( ) {return (BOOL) HWnd();} ;
	operator HWND ( ) {return HWnd();} ;

    virtual void OnUpdate(void);
	virtual BOOL Find(void);

// Attributes
public:
    virtual BOOL IsValid(void) const;
    inline HWND GetClient(void) const
        {   return m_hwndClient; }

// Data
private:
    HWND m_hwndClient;
    static CMD_STRUCT m_aCmdTable[];    // filled out in CMDARRAY.CPP
//    static CMD_STRUCT m_aCmdTableJ[];    // filled out in CMDARRYJ.CPP
    static UINT m_msgGetProp;
    static UINT m_msgSetProp;
    static UINT m_msgGetItemProp;
    static UINT m_msgSetItemProp;
	static UINT m_msgGetProjPath;
    static UINT m_msgGetToolbar;
    static UINT m_msgEditorCurPos;
	
	// Build state
	static UINT m_msgCanWeBuild;
	static UINT m_msgGetErrorCount;
	static UINT m_msgGetWarningCount;

	// stores format currently used by Memory window. 
	// used by UIMemory and COMemory utility classes.
	// use UIWBFrame::SetMemoryFormat() to set it, and
	// UIWBFrame::GetMemoryFormat() to get it.

	MEM_FORMAT m_MemFormat;

	// width of memory window in format units
	int m_MemWidth;

// Generic Utilities
public:
    BOOL IsDebug(void);
	BOOL IsActive(void);
    CString GetVersion(void);
    BOOL IsAlert(void);
	UINT GetIDEState(void);
	BOOL WaitOnWndWithCtrl(INT ID, DWORD dwMillSec ) ;

// File Utilities
public:
    HWND CreateNewFile(LPCSTR szFileType);
    HWND OpenFile(LPCSTR szFileName, LPCSTR szChDir = NULL);
    BOOL SaveFileAs(LPCSTR szFileName, BOOL bOverwrite = TRUE);
// REVIEW(briancr): not shell general
    void CloseAllWindows(void);
	BOOL SaveAll(int intWaitInMilliSecs = 0);

// Project Utilities
public:

	BOOL BuildProject(void);
	BOOL CloseProject(void);
	BOOL DeleteProject(LPCSTR szProjName, LPCSTR szDir = NULL);
	BOOL GetPcodeSwitch(void);

// MDI Utilities
public:
    HWND GetActiveEditor(void);
    BOOL SetActiveEditor(HWND hwndEditor);
    HWND GetToolbar(int nTbId,int pkgId);
    HWND GetStatusBar(void);
    CString GetStatusText(void);
    BOOL WaitForStatusText(LPCSTR sz, DWORD dwMilliSeconds, BOOL bExact = TRUE);
	HWND ShowDockWindow(UINT id, BOOL bShow = TRUE);
	BOOL IsWindowDocked(HWND hWnd, int nLocation = 0x000F);	
	int GetEditorCurPos( EGECP x, HWND hwndEditor = NULL );

	BOOL VerifyFile(LPCSTR szfile);
	BOOL VerifyCaretPosition(int nRow, int nCol, LPCSTR szErrMsg );
	BOOL FVerifyClipboardText( CString stMatch );
	BOOL FVerifySelection( CString stMatch );
	BOOL FVerifyLine( CString stMatch );
	BOOL VerifySubstringAtLine( LPCSTR stSubstring, BOOL nCase = FALSE);
		

// Resource Utilities
public:
    void ExportResource(LPCSTR szFileName, BOOL bOverwrite = FALSE);
    HWND ShowPropPage(BOOL bShow);    //REVIEW: add param to push pin if this feature stays
    CString GetProperty(int nProp);
	int SetProperty(int nProp,LPCSTR propValue);

	// Project Window utilities
	CString GetProjPath(void ) ;
	CString GetItemProperty(int nProp);
	void SelectProjItem(int item, LPCSTR szName);

   // Build state
   BOOL CanWeBuild(void );
   int GetErrorCount(void);
   int GetWarningCount(void);
// Dialogs
public:
    HWND ClassWizard(void);
    HWND ProjectProperties(void);
	HWND BreakpointsDlg(void);
	HWND Options(void);
	HWND FileOpenDlg(void);
	HWND FileSaveAsDlg(void);

// UI Utility Fuctions
public:
    BOOL AddTBButton(int nButtonType, HWND hwndToolbar = NULL);
    BOOL SetToolbarCombo(LPCSTR str = NULL);

// Debugger Utilities
public:
	BOOL Go(int WAIT);
	BOOL Restart(int WAIT=0);
	BOOL StopDebugging(int WAIT=0);
	BOOL Break(int WAIT= WAIT_FOR_BREAK);
	BOOL StepInto(int WAIT);
	BOOL StepOver(int WAIT);
	BOOL StepOut(int  WAIT);
	BOOL StepToCursor(int WAIT);
	BOOL ToggleBreakpoint(void);
	void HandleFindLocalModuleDlgs(void);
	BOOL Wait(int WAIT,BOOL bCheckDebuggeeWindow = TRUE, BOOL bLeaveFindSource = FALSE);
	BOOL WaitForBreak(BOOL bLeaveFindSource = FALSE);
	BOOL WaitForTermination(void);
	BOOL WaitForRun(void);
	BOOL WaitForException(void);
	BOOL WaitForCodedBreak(void);
	BOOL VerifyProjectRan(LPCSTR szProject);
	BOOL SetNextStatement(void);
	BOOL SetMemoryWidth(int width);
	BOOL SetMemoryFormat(MEM_FORMAT format);
	MEM_FORMAT GetMemoryFormat(void);
	int GetMemoryWidth(void);

	CEventHandler	*m_pEventHandler; //implements the connection point to IApplicationEvent
	CTarget			*m_pTarget; //implements pointer to IDebugger interface (to fire DebugState polling)
};

// REVIEW(briancr): this object is declared as a global for backward compatibility
// REVIEW(briancr): this is just to make things work. Is there a better way to do this?
// REVIEW(chriskoz): global pointer to the UIWBFrame is a little better (you can substitute it)
// REVIEW(chriskoz): there is no way to insert it to CTarget class (where it logically belongs)
#define UIWB (*g_pUIWB)
extern SHL_DATA UIWBFrame *g_pUIWB;

///////////////////////////////////////////////////////////////////////////////
// UIWBFrame #defines

//#define WORKBENCH_CLASSNAME "Afx:"      // Afx generated name starts like this
//#define WORKBENCH_TITLEBAR  "Microsoft Visual C++"


#define KEY_TOGGLE_BREAKPOINT "{F9}"

#define KEY_Insert		"{insert}"
#define KEY_Ctrl		"{ctrl}"
#define KEY_Home		"{home}"
#define KEY_Shift		"{shift}"
#define KEY_End			"{end}"
#define KEY_Delete		"{delete}"
#define KEY_Enter		"{enter}"
#define KEY_Tab			"{tab}"

// File adding options for CreateNewProject()

#define CNP_ADD_ALL_SOURCE		0x00000001
#define CNP_ADD_ALL_HEADERS		0x00000002
#define CNP_ADD_ALL_RES_SCRIPTS	0x00000004
#define CNP_ADD_ALL_DEF_FILES	0x00000008
#define CNP_ADD_ALL_ODL_FILES	0x00000010
#define CNP_ADD_ALL_LIBS		0x00000020
#define CNP_ADD_ALL_OBJ_FILES	0x00000040
#define CNP_ADD_ALL_FILES		0x00000080
#define CNP_ADD_FILE			0x00000100
#define CNP_ADD_FILES_MYSELF    0x00000200

//Mnemonics for Set Includes dialog


//  Resource type keys for New Resource listbox and Editor Title bar strings


// state values for GetIDEState
#define ST_EXISTS       0x0001
#define ST_ACTIVE       0x0002
#define ST_MIN          0x0004
#define ST_MAX          0x0008
#define ST_RES          0x0010
#define ST_NODEBUG      0x0020
#define ST_DEBUGBREAK	0x0040
#define ST_DEBUGRUN		0x0080
#define ST_BUILDING		0x0100

// Position values used for IsWindowDocked() and DockWindowAt()
#define DW_TOP					0x0001
#define DW_BOTTOM				0x0002
#define DW_LEFT					0x0004
#define DW_RIGHT				0x0008
#define DW_DONT_CARE		   	0x000F				

// Popup menu IDs
#define MENU_FILE		1	// REVIEW: These should be safe menu IDs
#define MENU_EDIT		2
#define MENU_SEARCH		3
#define MENU_PROJECT	4
#define MENU_RESOURCE	5
#define MENU_DEBUG		6
#define MENU_TOOLS		7
#define MENU_WINDOW		8
#define MENU_HELP		9
#define MENU_IMAGE		10
#define MENU_LAYOUT		11
#define	MENU_INSERT		12
#define MENU_BUILD		13
#define MENU_VIEW		14

#define IDM_BUILD_DEBUG_GO			0xfffe
#define IDM_BUILD_DEBUG_TRACEINTO	0xfffd
#define IDM_BUILD_DEBUG_TOCURSOR	0xfffc
#define IDM_BUILD_DEBUG_ATTACH		0xfffb


#define IDM_VIEW_WATCH	    0xfffa
#define IDM_VIEW_VARS	    0xfff9
#define IDM_VIEW_REGS	    0xfff8
#define IDM_VIEW_MEM	    0xfff7
#define IDM_VIEW_STACK	    0xfff6
#define IDM_VIEW_ASM	    0xfff5

#define IDM_CONNECTION	    0xfff4
#define IDM_VIEW_WORKSPACE  0xfff3
#define IDM_VIEW_GLOBALWORKSPACE  0xfff2

#define ID_STATUS_BAR		0xe801

#endif //__UIWBFRAME_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\utoolbar.cpp ===
//////////////////////////////
//  UTOOLBAR.CPP
//
//  Created by :            Date :
//      EnriqueP              1/13/94
//
//  Description :
//      Implementation of the UIToolbar class
//

#include "stdafx.h"

#include "utoolbar.h"
#include "testxcpt.h"
#include "mstwrap.h"
#include "..\sym\dockids.h"
#include "ucustdlg.h"
#include "uwbframe.h"
#include "Strings.h"
#include "..\sym\reg.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

// BEGIN_HELP_COMMENT
// Function: int UIToolbar::DisplayTBDlg(void)
// Description: Bring up the Toolbars dialog.
// Return: TRUE if the Toolbars dialog is displayed; FALSE otherwise.
// END_HELP_COMMENT
int UIToolbar::DisplayTBDlg(void)
{
	UICustomizeTabDlg uiTBD;
	return uiTBD.DisplayBars()!=NULL;
}


// BEGIN_HELP_COMMENT
// Function: int UIToolbar::ShowTB(int nTbId, BOOL bShow)
// Description: Display or hide the toolbar specified by nTbId.
// Return: TRUE if successful; FALSE otherwise.
// Param: nTbId The id of the toolbar: IDTB_SUSHI_STANDARD, IDTB_SUSHI_EDIT, IDTB_VRES_RESOURCE, IDTB_VCPP_DEBUG, IDTB_VCPP_BROWSE, IDTB_VRES_DIALOG, IDDW_CONTROLS, IDDW_GRAPHICS, IDDW_COLORS, IDDW_TEXTTOOL, IDTB_VPROJ_BUILD.
// Param: bShow TRUE to show the toolbar; FALSE to hide it.
// END_HELP_COMMENT
int UIToolbar::ShowTB(int nTbId, BOOL bShow)
{
	long pkgId ;
	switch(nTbId)
	{
		case IDTB_SUSHI_STANDARD:
			pkgId = PACKAGE_SUSHI;
			break;
		case IDTB_VCPP_DEBUG:
			pkgId = PACKAGE_DEBUG;
			break ;
		case IDTB_VCPP_BROWSE:
			pkgId = PACKAGE_VCPP;
			break ;
		case IDTB_VPROJ_BUILD:
			pkgId = PACKAGE_VPROJ ;
			break ;
		case IDTB_CLASSVIEW_WIZBARU:
			pkgId = PACKAGE_CLASSVIEW;
			break ;
		case IDTB_VRES_RESOURCE:
		case IDTB_VRES_DIALOG: 
		case IDDW_CONTROLS:
		case IDDW_GRAPHICS:
		case IDDW_COLORS:
		case IDDW_TEXTTOOL:
			pkgId = PACKAGE_VRES ;
			break ;
		default: ;
	}
	HWND hTb = UIWB.GetToolbar(nTbId,pkgId);

	if ( bShow == IsWindowVisible(hTb) )		
		return TRUE; //UITB_NO_ERROR;
	if (!DisplayTBDlg())
		return FALSE;  //UITB_ERR_NOT_DISPLAYED;
	
	char  szTBName[21];
	
	if (IsDocked(hTb) ||  !IsWindowVisible(hTb) )
	{
		 strcpy(szTBName, GetTBText(nTbId) );
	}
	else
	{
		HWND  hParent = GetParent(hTb);	   // Get Title on the fly if is not docked
		EXPECT(hParent != NULL);
		SendMessage(hParent, WM_GETTEXT, (WPARAM)20, (LPARAM)szTBName );
	}

	CString id;
	id.Format("Toolbars:",VSHELL_IDC_TOOLBAR);
	MST.WListItemClk(NULL, szTBName, 5);	// Click on toolbar to show it
	hTb = UIWB.GetToolbar(nTbId,pkgId);
	
	if (bShow != IsWindowVisible(hTb) )
	{
		//LOG->Comment("WARNING: Toolbar: Show / Hide failed");
		return FALSE; //UITB_ERR_FAILED;
	}

	return TRUE; // UITB_NO_ERROR;		
}



// BEGIN_HELP_COMMENT
// Function: CString UIToolbar::GetTBText(int nTbId)
// Description: Get the title of the toolbar.
// Return: A CString that contains the title of the toolbar.
// Param: nTbId The id of the toolbar: IDTB_SUSHI_STANDARD, IDTB_SUSHI_EDIT, IDTB_VRES_RESOURCE, IDTB_VCPP_DEBUG, IDTB_VCPP_BROWSE, IDTB_VRES_DIALOG, IDDW_CONTROLS, IDDW_GRAPHICS, IDDW_COLORS, IDDW_TEXTTOOL, IDTB_VPROJ_BUILD.
// END_HELP_COMMENT
CString UIToolbar::GetTBText(int nTbId)
{
	switch (nTbId)
	{
		case  IDTB_SUSHI_STANDARD:  
				return GetLocString(IDSS_TB_STANDARD);
		case  IDTB_SUSHI_EDIT:  
				return GetLocString(IDSS_TB_EDIT);
		case  IDTB_VRES_RESOURCE:  
				return GetLocString(IDSS_TB_RESOURCE);
		case  IDTB_VCPP_DEBUG:  
				return GetLocString(IDSS_TB_DEBUG);
		case  IDTB_VCPP_BROWSE:  
				return GetLocString(IDSS_TB_BROWSE);
		case  IDTB_VPROJ_BUILD:  
				return GetLocString(IDSS_TB_BUILD);
		case  IDDW_CONTROLS:  
				return GetLocString(IDSS_TB_CONTROLS);
		case  IDTB_VRES_DIALOG:  
				return GetLocString(IDSS_TB_DIALOG);
		case  IDDW_COLORS:  
				return GetLocString(IDSS_TB_COLORS);
		case  IDDW_GRAPHICS:  
				return GetLocString(IDSS_TB_GRAPHICS);
		case  IDDW_TEXTTOOL:  
				return GetLocString(IDSS_TB_TEXT_TOOL);
		case  IDTB_CLASSVIEW_WIZBARU:  
				return GetLocString(IDSS_TB_WIZBAR);
		default:
				return GetLocString(IDSS_TB_BAD_PARAM); //"Bad Param was passed"
	}
}


// BEGIN_HELP_COMMENT
// Function: BOOL UIToolbar::IsDocked(HWND hWnd, int nLocation)
// Description: Determine if the toolbar specified by the HWND is docked in the position given by nLocation.
// Return: TRUE if the toolbar is docked; FALSE otherwise.
// Param: hWnd The handle of the toolbar.
// Param: nLocation The dock location of the toolbar: DW_TOP, DW_BOTTOM, DW_RIGHT, DW_LEFT.
// END_HELP_COMMENT
BOOL UIToolbar::IsDocked(HWND hWnd, int nLocation)   // (EnriqueP)
{
	if (!IsWindowVisible(hWnd))
		return FALSE;
	//REVIEW (enriquep): Do we need to verify this is a dockable window?
	
	HWND  hParent = GetParent(hWnd);
	EXPECT(hParent != NULL);
	if ( ::GetWindowLong(hParent, GWL_STYLE) & WS_POPUP)
		return FALSE; 							// Window is floating

	// We know is docked , now check position.
	RECT rcWBClient;

	::GetClientRect( UIWB.HWnd(), &rcWBClient);
	::MapWindowPoints( UIWB.HWnd(), HWND_DESKTOP, (POINT*)&rcWBClient, 2);		  	// Client area RECT to screen coord.
	
	RECT rcWBMDIClient;
	HWND hMDIClient = UIWB.GetClient();					// Returns MDI Client
	::GetWindowRect( hMDIClient, &rcWBMDIClient );
				
	
	RECT rcDockableWnd;

	::GetWindowRect(hWnd, &rcDockableWnd);			   // Get dockable window dimensions
	
	int nXBorder = ::GetSystemMetrics(SM_CXBORDER);	// Width of a border (usually 1 pix)
	int nYBorder = ::GetSystemMetrics(SM_CYBORDER);   	// Heigth of border (usually 1 pix)	
	
	if( (nLocation & DW_TOP) )
	{
		if( (rcWBClient.top  <= rcDockableWnd.top + nYBorder) && (rcWBMDIClient.top >= rcDockableWnd.bottom - nYBorder) )
			return TRUE;
	}

	if( (nLocation & DW_BOTTOM) )
	{
		if( (rcWBClient.bottom >= rcDockableWnd.bottom - nYBorder) && (rcWBMDIClient.bottom <= rcDockableWnd.top + nYBorder) )
			return TRUE;
	}

	if( (nLocation & DW_LEFT) )
	{
		if( (rcWBClient.left <= rcDockableWnd.left + nXBorder) && (rcWBMDIClient.left >= rcDockableWnd.right - nXBorder) )
			return TRUE;
	}

	if( (nLocation & DW_RIGHT) )
	{
		if( (rcWBClient.right >= rcDockableWnd.right - nXBorder) && (rcWBMDIClient.right <= rcDockableWnd.left + nXBorder ) )
			return TRUE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\wbutil.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	WBUTIL.CPP
//
//	Created by :			Date :
//		DavidGa					12/2/93
//
//	Description :
//		Implementation of workbench-specific global utility functions
//

#include "stdafx.h"
#include "wbutil.h"
#include "..\..\testutil.h"
#include "guiv1.h"
#include "coconnec.h"
#include "uwbframe.h"
#include "Strings.h"

#define new DEBUG_NEW

#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

///////////////////////////////////////////////////////////////////////////////
//	Global utility functions
 
/*	GetLocString
 *		Global version of the WBDriver function - so anyone can call it.
 */
// BEGIN_HELP_COMMENT
// Function: CString GetLocString(UINT id, int nLang /*=-1*/)
// Description: Get a pointer to a localized string with the given id and language.
// Return: A CString that contains the localized string.
// Param: id An integer that contains the id of the string to retrieve. The list of valid ids is in wbus.rc.
// Param: nLang An integer that contains the language of the string. -1 for the current language; CAFE_LANG_ENGLISH for English; CAFE_LANG_JAPANESE for Japanese. (The default value is -1.)
// END_HELP_COMMENT
SHL_API CString GetLocString(UINT id, int nLang /*=-1*/)
{
	CString cstrLocalized;
	LoadString(GetLangDllHandle(), id, cstrLocalized.GetBufferSetLength(1024), 1024);
	cstrLocalized.ReleaseBuffer();
	return cstrLocalized;
}

// emmang 11/20/2000 - added xbox target platform
// looks like this is just for the cafe driver ui
CString target_platform_str[] = {"win32_x86", "win32s_x86",	//todo: localize
								 "mac_68k", "mac_ppc",
								 "win32_mips", "win32_alpha", "win32_ppc",
								 "xbox"};	


// BEGIN_HELP_COMMENT
// Function: int GetUserTargetPlatforms(void)	
// Description: Get the current platform.
// Return: An value indicating the current platform: PLATFORM_WIN32_X86, PLATFORM_WIN32S_X86, PLATFORM_MAC_68K, PLATFORM_MAC_PPC, PLATFORM_WIN32_MIPS, PLATFORM_WIN32_ALPHA, PLATFORM_WIN32_PPC.
// END_HELP_COMMENT
SHL_API int GetUserTargetPlatforms(void)	
	
	{
	gplatformStr.MakeLower();

	if(gplatformStr == "win32_x86")
		return PLATFORM_WIN32_X86;
	if(gplatformStr == "win32s_x86")
		return PLATFORM_WIN32S_X86;
	if(gplatformStr == "mac_68k")
		return PLATFORM_MAC_68K;
	if(gplatformStr == "mac_ppc")
		return PLATFORM_MAC_PPC;
	if(gplatformStr == "win32_mips")
		return PLATFORM_WIN32_MIPS;
	if(gplatformStr == "win32_alpha")
		return PLATFORM_WIN32_ALPHA;
	if(gplatformStr == "win32_ppc")
		return PLATFORM_WIN32_PPC;
	if(gplatformStr == "xbox")
		return PLATFORM_XBOX;

	//TODO: need some error message here (EXPECT isn't supported anymore).
	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\src\stdafx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.CPP
//
//	Created by :			Date :
//		BrianCr				09/06/94
//
//	Description :
//		source file that includes just the standard includes
//
//		stdafx.pch will be the pre-compiled header
//		stdafx.obj will contain the pre-compiled type information
//

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\shl\wb_props.h ===
//wb_props.h  Defines all properties in the dolphin workbench

#include "..\sym\props.h"   //Brought from sushi project

#define P_ID	3  // Defined in Slob.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\src\stdafx.h ===
///////////////////////////////////////////////////////////////////////////////
//	STDAFX.H
//
//	Created by :			Date :
//		BrianCr				09/06/94
//
//	Description :
//		Precompiled header for all of the core MFC files
//

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>			// MFC core and standard components
#include <winperf.h>		// skipped in windows.h due to WIN32_LEAN_AND_MEAN
#include <afxext.h> 		// MFC extensions
#include <afxtempl.h>

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\src\dllmain.cpp ===
/////////////////////////////////////////////////////////////////////////////
// dllmain.cpp
//
// email	date		change
// michma	06/17/97	created
//
// copyright 1997 Microsoft

#include "stdafx.h"
#include "afxdllx.h"

#define new DEBUG_NEW

///////////////////////////////////////////////////////////////////////////////
//	DLL support

static AFX_EXTENSION_MODULE extensionDLL = { NULL, NULL };

extern "C" __declspec(dllexport) int APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("Src DLL Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(extensionDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(extensionDLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("Src DLL Terminating!\n");
		// Terminate the library before destructors are called
		AfxTermExtensionModule(extensionDLL);
	}
	return 1;   // ok

	UNREFERENCED_PARAMETER(lpReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\src\cohtml.h ===
///////////////////////////////////////////////////////////////////////////////
//	COHTML.H
//
//	Created by :			Date :
//		MichMa					5/28/97
//
//	Description :
//		Declaration of the COHTML component object class
//

#ifndef __COHTML_H__
#define __COHTML_H__

#include "cosource.h"
#include "uinsctrl.h"

#include "export.h"

///////////////////////////////////////////////////////////////////////////////
// COHTML class

// BEGIN_CLASS_HELP
// ClassName: COHTML
// BaseClass: COSource
// Category: Editors
// END_CLASS_HELP
class SRC_CLASS COHTML : public COSource
{
public:
	COHTML();
// Utilities
	int Create(LPCSTR szSaveAs = NULL, LPCSTR szProject = NULL);
	int InsertActiveXControl(LPCSTR szCtrl);
// Data
private:
	UIInsertCtrlDlg m_uiInsCtrlDlg;
};

#endif //__COHTML_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\src\cohtml.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	COHTML.CPP
//
//	Created by :			Date :
//		MichMa					5/28/97
//
//	Description :
//		Implementation of the COHTML component object class
//

#include "stdafx.h"
#include "mstwrap.h"
#include "cohtml.h"
#include "guiv1.h"
#include "..\shl\uwbframe.h"

#define new DEBUG_NEW

#undef THIS_FILE

static char BASED_CODE THIS_FILE[] = __FILE__;


COHTML::COHTML()
{
}

// BEGIN_HELP_COMMENT
// Function: int COHTML::Create(LPCSTR szSaveAs /*=NULL*/, LPCSTR szProject /* NULL */)
// Description: Create a new html window and file in the IDE.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szSaveAs A pointer to a string that contains the name to save the new file with. NULL indicates don't save (no name specified). (The default value is NULL.)
// Param: szProject A pointer to a string that contains the name of the project to add the file to. NULL indicates don't add it to project. (The default value is NULL.)
// END_HELP_COMMENT
int COHTML::Create(LPCSTR szSaveAs /*=NULL*/, LPCSTR szProject /* NULL */)
{
	return COFile::Create(FILE_HTML_PAGE, szSaveAs, szProject);
}


// BEGIN_HELP_COMMENT
// Function: int COHTML::InsertActiveXControl(LPCSTR szCtrl)
// Description: Insert a registered ActiveX Control into the current html page at the current cursor location.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szCtrl A pointer to a string that contains the name of the control to insert.
// END_HELP_COMMENT
int COHTML::InsertActiveXControl(LPCSTR szCtrl)

{
	// activate the "Insert ActiveX Control" dlg.
	if(!m_uiInsCtrlDlg.Activate())
	{
		LOG->RecordInfo("ERROR! COHTML::InsertActiveXControl - could not activate %s dlg.", m_uiInsCtrlDlg.ExpectedTitle());
	 	return ERROR_ERROR;
	}

	// select the control from the list.
	if(!m_uiInsCtrlDlg.SetControl(szCtrl))
	{
		LOG->RecordInfo("ERROR! COHTML::InsertActiveXControl - could set control to %s.", szCtrl);
	 	return ERROR_ERROR;
	}

	// OK the dlg.
	if(m_uiInsCtrlDlg.OK() != NULL)
	{
		LOG->RecordInfo("ERROR! COHTML::InsertActiveXControl - could not close %s dlg.", m_uiInsCtrlDlg.ExpectedTitle());
	 	return ERROR_ERROR;
	}

	// wait up to 10 seconds for the control to come up in the ide.	we do this by scanning for a static
	// text field that contains the name of the control. this field will be in a properties window for the
	// control that is displayed after the insert is complete.
	// TODO(michma): some sort of control editor ui class should take over from here.
	if(!MST.WFndWndWaitC(szCtrl, "Static", FW_PART, 10))
	{
		LOG->RecordInfo("ERROR! COHTML::InsertActiveXControl - could not detect control '%s' within ide.", szCtrl);
	 	return ERROR_ERROR;
	}

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktest\cafe6\Src\Support\GuiTools\IDE\src\cosource.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	COSOURCE.CPP
//
//	Created by :			Date :
//		DavidGa					1/13/94
//
//	Description :
//		Implementation of the COSource component object class
//

#include "stdafx.h"
#include "cosource.h"
#include "mstwrap.h"
#include "..\..\testutil.h"
#include "..\sym\cmdids.h"
#include "..\sym\vshell.h"
#include "guiv1.h"
#include "..\..\coclip.h"
#include "..\shl\uwbframe.h"
#include "Strings.h"
#include "ufindrep.h"
#include "..\shl\uioutput.h"
#include "..\shl\ucustdlg.h"
#include "..\..\UMSGBOX.H"  // GAC added for MSG_OK

#define new DEBUG_NEW

#undef THIS_FILE

static char BASED_CODE THIS_FILE[] = __FILE__;

#define MUST_BE_ACTIVE_V() \
	if( !m_editor.IsActive() && !m_editor.Activate() ) \
	{ \
		LOG->RecordInfo("Cannot activate %s editor", GetFileName()); \
		return; \
	}

#define MUST_BE_ACTIVE_B() \
	if( !m_editor.IsActive() && !m_editor.Activate() ) \
	{ \
		LOG->RecordInfo("Cannot activate %s editor", GetFileName()); \
		return FALSE; \
	}

COSource::COSource()
{
}

// BEGIN_HELP_COMMENT
// Function: int COSource::Create(LPCSTR szSaveAs /*=NULL*/)
// Description: Create a new editor window and file in the IDE.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szSaveAs A pointer to a string that contains the name to save the new file with. NULL indicates don't save (no name specified). (The default value is NULL.)
// END_HELP_COMMENT
int COSource::Create(LPCSTR szSaveAs /*=NULL*/)
{
	return COFile::Create(IDSS_NEW_SOURCE, szSaveAs);
}

// BEGIN_HELP_COMMENT
// Function: int COSource::Open(LPCSTR szFileName, LPCSTR szChDir /*=NULL*/, EOpenAs oa /*=OA_AUTO*/)
// Description: Open a text file in the IDE.
// Return: An integer that indicates success. ERROR_SUCCESS if successful; ERROR_ERROR otherwise.
// Param: szFileName A pointer to a string that contains the name of the file to open.
// Param: szChDir A pointer to a string that contains the path to the file. NULL if szFileName includes a path or szFileName is in the current directory). (The default value is NULL.)
// Param: oa A value that indicates the editor to use when opening the file: OA_AUTO, OA_TEXT, OA_BINARY, OA_MAKEFILE. (The default value is OA_AUTO.)
// END_HELP_COMMENT
int COSource::Open(LPCSTR szFileName, LPCSTR szChDir /*=NULL*/, EOpenAs oa /*=OA_AUTO*/)
{
	return COFile::Open(szFileName, szChDir, oa);
}

// BEGIN_HELP_COMMENT
// Function: BOOL COSource::GetReadOnly(void)
// Description: Determine the read only state of this file.
// Return: A Boolean value that indicates the read only state: TRUE if read only; FALSE otherwise.
// END_HELP_COMMENT
BOOL COSource::GetReadOnly(void)
{
	return FALSE;		// STUB: GetProperty?
}

// BEGIN_HELP_COMMENT
// Function: int COSource::GetCurrentLine(void)
// Description: Get the current line in the text editor.
// Return: An integer containing the current line.
// END_HELP_COMMENT
int COSource::GetCurrentLine(void)
{
	return UIWB.GetEditorCurPos(GECP_LINE, m_editor);
}

// BEGIN_HELP_COMMENT
// Function: int COSource::GetCurrentColumn(void)
// Description: Get the current column in the text editor.
// Return: An integer containing the current column.
// END_HELP_COMMENT
int COSource::GetCurrentColumn(void)
{
	return UIWB.GetEditorCurPos(GECP_COLUMN, m_editor);
}

// BEGIN_HELP_COMMENT
// Function: CString COSource::GetSelectedText(void)
// Description: Get the selected text in the editor.
// Return: A CString containing the selected text.
// END_HELP_COMMENT
CString COSource::GetSelectedText(void)
{
	if( !m_editor.IsActive() && !m_editor.Activate() )
	{
		LOG->RecordInfo("Cannot activate %s editor", GetFileName());
		return CString("");
	}

	UIWB.DoCommand(ID_EDIT_COPY, DC_ACCEL);		// REVIEW: is there a better way?
	COClipboard clip;
	return clip.GetText();
}

// BEGIN_HELP_COMMENT
// Function: void COSource::SelectText(int line1, int column1, int line2, int column2, BOOL bColumnSelect /*=SELECT_NORMAL*/)
// Description: Select text in the source editor.
// Return: none
// Param: line1 An integer that contains the starting line for the selection.
// Param: column1 An integer that contains the starting column for the selection.
// Param: line2 An integer that contains the ending line for the selection.
// Param: column2 An integer that contains the ending column for the selection.
// Param: bColumnSelect A integer that indicates the type of selection to perform: SELECT_NORMAL, SELECT_COLUMN, SELECT_BRIEF_COLUMN. (The default value is SELECT_NORMAL.)
// END_HELP_COMMENT
void COSource::SelectText(int line1, int column1, int line2, int column2, BOOL bColumnSelect /*=SELECT_NORMAL*/)
{
	int ThisLine = 0;
	MUST_BE_ACTIVE_V();

	SetCursor(line1, column1);		// goto line1, column1

	char acBuf[16];
	if( line2 <= 0 )		// <0 means last line of the file
		strcpy(acBuf, "^+{end}");
	else if( line2 > line1 )				// select to line2
		wsprintf(acBuf, "+{down %d}", line2 - line1);
	else if( line2 < line1 )
		wsprintf(acBuf, "+{up %d}", line1 - line2);

	// Enter column mode?
	if (bColumnSelect == SELECT_COLUMN)
		MST.DoKeys("^+{F8}"); 
	else if (bColumnSelect == SELECT_BRIEF_COLUMN)
		MST.DoKeys("%C");
		 
	if( line2 != line1 )
		MST.DoKeys( acBuf );

	if