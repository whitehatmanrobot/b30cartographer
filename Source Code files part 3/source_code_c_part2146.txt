his);
        
        HRESULT ( STDMETHODCALLTYPE *OnUIActivate )( 
            IOleInPlaceSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindowContext )( 
            IOleInPlaceSite * This,
            /* [out] */ __RPC__deref_out_opt IOleInPlaceFrame **ppFrame,
            /* [out] */ __RPC__deref_out_opt IOleInPlaceUIWindow **ppDoc,
            /* [out] */ __RPC__out LPRECT lprcPosRect,
            /* [out] */ __RPC__out LPRECT lprcClipRect,
            /* [out][in] */ __RPC__inout LPOLEINPLACEFRAMEINFO lpFrameInfo);
        
        HRESULT ( STDMETHODCALLTYPE *Scroll )( 
            IOleInPlaceSite * This,
            /* [in] */ SIZE scrollExtant);
        
        HRESULT ( STDMETHODCALLTYPE *OnUIDeactivate )( 
            IOleInPlaceSite * This,
            /* [in] */ BOOL fUndoable);
        
        HRESULT ( STDMETHODCALLTYPE *OnInPlaceDeactivate )( 
            IOleInPlaceSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *DiscardUndoState )( 
            IOleInPlaceSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *DeactivateAndUndo )( 
            IOleInPlaceSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnPosRectChange )( 
            IOleInPlaceSite * This,
            /* [in] */ __RPC__in LPCRECT lprcPosRect);
        
        END_INTERFACE
    } IOleInPlaceSiteVtbl;

    interface IOleInPlaceSite
    {
        CONST_VTBL struct IOleInPlaceSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleInPlaceSite_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IOleInPlaceSite_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IOleInPlaceSite_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IOleInPlaceSite_GetWindow(This,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,phwnd) ) 

#define IOleInPlaceSite_ContextSensitiveHelp(This,fEnterMode)	\
    ( (This)->lpVtbl -> ContextSensitiveHelp(This,fEnterMode) ) 


#define IOleInPlaceSite_CanInPlaceActivate(This)	\
    ( (This)->lpVtbl -> CanInPlaceActivate(This) ) 

#define IOleInPlaceSite_OnInPlaceActivate(This)	\
    ( (This)->lpVtbl -> OnInPlaceActivate(This) ) 

#define IOleInPlaceSite_OnUIActivate(This)	\
    ( (This)->lpVtbl -> OnUIActivate(This) ) 

#define IOleInPlaceSite_GetWindowContext(This,ppFrame,ppDoc,lprcPosRect,lprcClipRect,lpFrameInfo)	\
    ( (This)->lpVtbl -> GetWindowContext(This,ppFrame,ppDoc,lprcPosRect,lprcClipRect,lpFrameInfo) ) 

#define IOleInPlaceSite_Scroll(This,scrollExtant)	\
    ( (This)->lpVtbl -> Scroll(This,scrollExtant) ) 

#define IOleInPlaceSite_OnUIDeactivate(This,fUndoable)	\
    ( (This)->lpVtbl -> OnUIDeactivate(This,fUndoable) ) 

#define IOleInPlaceSite_OnInPlaceDeactivate(This)	\
    ( (This)->lpVtbl -> OnInPlaceDeactivate(This) ) 

#define IOleInPlaceSite_DiscardUndoState(This)	\
    ( (This)->lpVtbl -> DiscardUndoState(This) ) 

#define IOleInPlaceSite_DeactivateAndUndo(This)	\
    ( (This)->lpVtbl -> DeactivateAndUndo(This) ) 

#define IOleInPlaceSite_OnPosRectChange(This,lprcPosRect)	\
    ( (This)->lpVtbl -> OnPosRectChange(This,lprcPosRect) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IOleInPlaceSite_INTERFACE_DEFINED__ */


#ifndef __IContinue_INTERFACE_DEFINED__
#define __IContinue_INTERFACE_DEFINED__

/* interface IContinue */
/* [uuid][object] */ 


EXTERN_C const IID IID_IContinue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0000012a-0000-0000-C000-000000000046")
    IContinue : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FContinue( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContinueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IContinue * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IContinue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IContinue * This);
        
        HRESULT ( STDMETHODCALLTYPE *FContinue )( 
            IContinue * This);
        
        END_INTERFACE
    } IContinueVtbl;

    interface IContinue
    {
        CONST_VTBL struct IContinueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContinue_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IContinue_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IContinue_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IContinue_FContinue(This)	\
    ( (This)->lpVtbl -> FContinue(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IContinue_INTERFACE_DEFINED__ */


#ifndef __IViewObject_INTERFACE_DEFINED__
#define __IViewObject_INTERFACE_DEFINED__

/* interface IViewObject */
/* [uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IViewObject *LPVIEWOBJECT;


EXTERN_C const IID IID_IViewObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0000010d-0000-0000-C000-000000000046")
    IViewObject : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Draw( 
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void *pvAspect,
            /* [unique][in] */ DVTARGETDEVICE *ptd,
            /* [in] */ HDC hdcTargetDev,
            /* [in] */ HDC hdcDraw,
            /* [in] */ LPCRECTL lprcBounds,
            /* [unique][in] */ LPCRECTL lprcWBounds,
            /* [in] */ BOOL ( STDMETHODCALLTYPE *pfnContinue )( 
                ULONG_PTR dwContinue),
            /* [in] */ ULONG_PTR dwContinue) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetColorSet( 
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void *pvAspect,
            /* [unique][in] */ DVTARGETDEVICE *ptd,
            /* [in] */ HDC hicTargetDev,
            /* [out] */ LOGPALETTE **ppColorSet) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Freeze( 
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void *pvAspect,
            /* [out] */ DWORD *pdwFreeze) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unfreeze( 
            /* [in] */ DWORD dwFreeze) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAdvise( 
            /* [in] */ DWORD aspects,
            /* [in] */ DWORD advf,
            /* [unique][in] */ __RPC__in_opt IAdviseSink *pAdvSink) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetAdvise( 
            /* [unique][out] */ DWORD *pAspects,
            /* [unique][out] */ DWORD *pAdvf,
            /* [out] */ IAdviseSink **ppAdvSink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IViewObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IViewObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IViewObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IViewObject * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Draw )( 
            IViewObject * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void *pvAspect,
            /* [unique][in] */ DVTARGETDEVICE *ptd,
            /* [in] */ HDC hdcTargetDev,
            /* [in] */ HDC hdcDraw,
            /* [in] */ LPCRECTL lprcBounds,
            /* [unique][in] */ LPCRECTL lprcWBounds,
            /* [in] */ BOOL ( STDMETHODCALLTYPE *pfnContinue )( 
                ULONG_PTR dwContinue),
            /* [in] */ ULONG_PTR dwContinue);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetColorSet )( 
            IViewObject * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void *pvAspect,
            /* [unique][in] */ DVTARGETDEVICE *ptd,
            /* [in] */ HDC hicTargetDev,
            /* [out] */ LOGPALETTE **ppColorSet);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Freeze )( 
            IViewObject * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void *pvAspect,
            /* [out] */ DWORD *pdwFreeze);
        
        HRESULT ( STDMETHODCALLTYPE *Unfreeze )( 
            IViewObject * This,
            /* [in] */ DWORD dwFreeze);
        
        HRESULT ( STDMETHODCALLTYPE *SetAdvise )( 
            IViewObject * This,
            /* [in] */ DWORD aspects,
            /* [in] */ DWORD advf,
            /* [unique][in] */ __RPC__in_opt IAdviseSink *pAdvSink);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetAdvise )( 
            IViewObject * This,
            /* [unique][out] */ DWORD *pAspects,
            /* [unique][out] */ DWORD *pAdvf,
            /* [out] */ IAdviseSink **ppAdvSink);
        
        END_INTERFACE
    } IViewObjectVtbl;

    interface IViewObject
    {
        CONST_VTBL struct IViewObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IViewObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IViewObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IViewObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IViewObject_Draw(This,dwDrawAspect,lindex,pvAspect,ptd,hdcTargetDev,hdcDraw,lprcBounds,lprcWBounds,pfnContinue,dwContinue)	\
    ( (This)->lpVtbl -> Draw(This,dwDrawAspect,lindex,pvAspect,ptd,hdcTargetDev,hdcDraw,lprcBounds,lprcWBounds,pfnContinue,dwContinue) ) 

#define IViewObject_GetColorSet(This,dwDrawAspect,lindex,pvAspect,ptd,hicTargetDev,ppColorSet)	\
    ( (This)->lpVtbl -> GetColorSet(This,dwDrawAspect,lindex,pvAspect,ptd,hicTargetDev,ppColorSet) ) 

#define IViewObject_Freeze(This,dwDrawAspect,lindex,pvAspect,pdwFreeze)	\
    ( (This)->lpVtbl -> Freeze(This,dwDrawAspect,lindex,pvAspect,pdwFreeze) ) 

#define IViewObject_Unfreeze(This,dwFreeze)	\
    ( (This)->lpVtbl -> Unfreeze(This,dwFreeze) ) 

#define IViewObject_SetAdvise(This,aspects,advf,pAdvSink)	\
    ( (This)->lpVtbl -> SetAdvise(This,aspects,advf,pAdvSink) ) 

#define IViewObject_GetAdvise(This,pAspects,pAdvf,ppAdvSink)	\
    ( (This)->lpVtbl -> GetAdvise(This,pAspects,pAdvf,ppAdvSink) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IViewObject_RemoteDraw_Proxy( 
    IViewObject * This,
    /* [in] */ DWORD dwDrawAspect,
    /* [in] */ LONG lindex,
    /* [in] */ ULONG_PTR pvAspect,
    /* [unique][in] */ __RPC__in_opt DVTARGETDEVICE *ptd,
    /* [in] */ __RPC__in HDC hdcTargetDev,
    /* [in] */ __RPC__in HDC hdcDraw,
    /* [unique][in] */ __RPC__in_opt LPCRECTL lprcBounds,
    /* [unique][in] */ __RPC__in_opt LPCRECTL lprcWBounds,
    /* [in] */ __RPC__in_opt IContinue *pContinue);


void __RPC_STUB IViewObject_RemoteDraw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IViewObject_RemoteGetColorSet_Proxy( 
    IViewObject * This,
    /* [in] */ DWORD dwDrawAspect,
    /* [in] */ LONG lindex,
    /* [in] */ ULONG_PTR pvAspect,
    /* [unique][in] */ __RPC__in_opt DVTARGETDEVICE *ptd,
    /* [in] */ ULONG_PTR hicTargetDev,
    /* [out] */ __RPC__deref_out_opt LOGPALETTE **ppColorSet);


void __RPC_STUB IViewObject_RemoteGetColorSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IViewObject_RemoteFreeze_Proxy( 
    IViewObject * This,
    /* [in] */ DWORD dwDrawAspect,
    /* [in] */ LONG lindex,
    /* [in] */ ULONG_PTR pvAspect,
    /* [out] */ __RPC__out DWORD *pdwFreeze);


void __RPC_STUB IViewObject_RemoteFreeze_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IViewObject_RemoteGetAdvise_Proxy( 
    IViewObject * This,
    /* [out] */ __RPC__out DWORD *pAspects,
    /* [out] */ __RPC__out DWORD *pAdvf,
    /* [out] */ __RPC__deref_out_opt IAdviseSink **ppAdvSink);


void __RPC_STUB IViewObject_RemoteGetAdvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IViewObject_INTERFACE_DEFINED__ */


#ifndef __IViewObject2_INTERFACE_DEFINED__
#define __IViewObject2_INTERFACE_DEFINED__

/* interface IViewObject2 */
/* [uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IViewObject2 *LPVIEWOBJECT2;


EXTERN_C const IID IID_IViewObject2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000127-0000-0000-C000-000000000046")
    IViewObject2 : public IViewObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetExtent( 
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ __RPC__in_opt DVTARGETDEVICE *ptd,
            /* [out] */ __RPC__out LPSIZEL lpsizel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IViewObject2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IViewObject2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IViewObject2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IViewObject2 * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Draw )( 
            IViewObject2 * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void *pvAspect,
            /* [unique][in] */ DVTARGETDEVICE *ptd,
            /* [in] */ HDC hdcTargetDev,
            /* [in] */ HDC hdcDraw,
            /* [in] */ LPCRECTL lprcBounds,
            /* [unique][in] */ LPCRECTL lprcWBounds,
            /* [in] */ BOOL ( STDMETHODCALLTYPE *pfnContinue )( 
                ULONG_PTR dwContinue),
            /* [in] */ ULONG_PTR dwContinue);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetColorSet )( 
            IViewObject2 * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void *pvAspect,
            /* [unique][in] */ DVTARGETDEVICE *ptd,
            /* [in] */ HDC hicTargetDev,
            /* [out] */ LOGPALETTE **ppColorSet);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Freeze )( 
            IViewObject2 * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ void *pvAspect,
            /* [out] */ DWORD *pdwFreeze);
        
        HRESULT ( STDMETHODCALLTYPE *Unfreeze )( 
            IViewObject2 * This,
            /* [in] */ DWORD dwFreeze);
        
        HRESULT ( STDMETHODCALLTYPE *SetAdvise )( 
            IViewObject2 * This,
            /* [in] */ DWORD aspects,
            /* [in] */ DWORD advf,
            /* [unique][in] */ __RPC__in_opt IAdviseSink *pAdvSink);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetAdvise )( 
            IViewObject2 * This,
            /* [unique][out] */ DWORD *pAspects,
            /* [unique][out] */ DWORD *pAdvf,
            /* [out] */ IAdviseSink **ppAdvSink);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtent )( 
            IViewObject2 * This,
            /* [in] */ DWORD dwDrawAspect,
            /* [in] */ LONG lindex,
            /* [unique][in] */ __RPC__in_opt DVTARGETDEVICE *ptd,
            /* [out] */ __RPC__out LPSIZEL lpsizel);
        
        END_INTERFACE
    } IViewObject2Vtbl;

    interface IViewObject2
    {
        CONST_VTBL struct IViewObject2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IViewObject2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IViewObject2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IViewObject2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IViewObject2_Draw(This,dwDrawAspect,lindex,pvAspect,ptd,hdcTargetDev,hdcDraw,lprcBounds,lprcWBounds,pfnContinue,dwContinue)	\
    ( (This)->lpVtbl -> Draw(This,dwDrawAspect,lindex,pvAspect,ptd,hdcTargetDev,hdcDraw,lprcBounds,lprcWBounds,pfnContinue,dwContinue) ) 

#define IViewObject2_GetColorSet(This,dwDrawAspect,lindex,pvAspect,ptd,hicTargetDev,ppColorSet)	\
    ( (This)->lpVtbl -> GetColorSet(This,dwDrawAspect,lindex,pvAspect,ptd,hicTargetDev,ppColorSet) ) 

#define IViewObject2_Freeze(This,dwDrawAspect,lindex,pvAspect,pdwFreeze)	\
    ( (This)->lpVtbl -> Freeze(This,dwDrawAspect,lindex,pvAspect,pdwFreeze) ) 

#define IViewObject2_Unfreeze(This,dwFreeze)	\
    ( (This)->lpVtbl -> Unfreeze(This,dwFreeze) ) 

#define IViewObject2_SetAdvise(This,aspects,advf,pAdvSink)	\
    ( (This)->lpVtbl -> SetAdvise(This,aspects,advf,pAdvSink) ) 

#define IViewObject2_GetAdvise(This,pAspects,pAdvf,ppAdvSink)	\
    ( (This)->lpVtbl -> GetAdvise(This,pAspects,pAdvf,ppAdvSink) ) 


#define IViewObject2_GetExtent(This,dwDrawAspect,lindex,ptd,lpsizel)	\
    ( (This)->lpVtbl -> GetExtent(This,dwDrawAspect,lindex,ptd,lpsizel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IViewObject2_INTERFACE_DEFINED__ */


#ifndef __IDropSource_INTERFACE_DEFINED__
#define __IDropSource_INTERFACE_DEFINED__

/* interface IDropSource */
/* [uuid][object][local] */ 

typedef /* [unique] */ IDropSource *LPDROPSOURCE;


EXTERN_C const IID IID_IDropSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000121-0000-0000-C000-000000000046")
    IDropSource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryContinueDrag( 
            /* [in] */ BOOL fEscapePressed,
            /* [in] */ DWORD grfKeyState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GiveFeedback( 
            /* [in] */ DWORD dwEffect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDropSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDropSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDropSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDropSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryContinueDrag )( 
            IDropSource * This,
            /* [in] */ BOOL fEscapePressed,
            /* [in] */ DWORD grfKeyState);
        
        HRESULT ( STDMETHODCALLTYPE *GiveFeedback )( 
            IDropSource * This,
            /* [in] */ DWORD dwEffect);
        
        END_INTERFACE
    } IDropSourceVtbl;

    interface IDropSource
    {
        CONST_VTBL struct IDropSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDropSource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDropSource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDropSource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDropSource_QueryContinueDrag(This,fEscapePressed,grfKeyState)	\
    ( (This)->lpVtbl -> QueryContinueDrag(This,fEscapePressed,grfKeyState) ) 

#define IDropSource_GiveFeedback(This,dwEffect)	\
    ( (This)->lpVtbl -> GiveFeedback(This,dwEffect) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDropSource_INTERFACE_DEFINED__ */


#ifndef __IDropTarget_INTERFACE_DEFINED__
#define __IDropTarget_INTERFACE_DEFINED__

/* interface IDropTarget */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IDropTarget *LPDROPTARGET;

#define	MK_ALT	( 0x20 )

#define	DROPEFFECT_NONE	( 0 )

#define	DROPEFFECT_COPY	( 1 )

#define	DROPEFFECT_MOVE	( 2 )

#define	DROPEFFECT_LINK	( 4 )

#define	DROPEFFECT_SCROLL	( 0x80000000 )

// default inset-width of the hot zone, in pixels
//   typical use: GetProfileInt("windows","DragScrollInset",DD_DEFSCROLLINSET)
#define	DD_DEFSCROLLINSET	( 11 )

// default delay before scrolling, in milliseconds
//   typical use: GetProfileInt("windows","DragScrollDelay",DD_DEFSCROLLDELAY)
#define	DD_DEFSCROLLDELAY	( 50 )

// default scroll interval, in milliseconds
//   typical use: GetProfileInt("windows","DragScrollInterval", DD_DEFSCROLLINTERVAL)
#define	DD_DEFSCROLLINTERVAL	( 50 )

// default delay before dragging should start, in milliseconds
//   typical use: GetProfileInt("windows", "DragDelay", DD_DEFDRAGDELAY)
#define	DD_DEFDRAGDELAY	( 200 )

// default minimum distance (radius) before dragging should start, in pixels
//   typical use: GetProfileInt("windows", "DragMinDist", DD_DEFDRAGMINDIST)
#define	DD_DEFDRAGMINDIST	( 2 )


EXTERN_C const IID IID_IDropTarget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000122-0000-0000-C000-000000000046")
    IDropTarget : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DragEnter( 
            /* [unique][in] */ __RPC__in_opt IDataObject *pDataObj,
            /* [in] */ DWORD grfKeyState,
            /* [in] */ POINTL pt,
            /* [out][in] */ __RPC__inout DWORD *pdwEffect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DragOver( 
            /* [in] */ DWORD grfKeyState,
            /* [in] */ POINTL pt,
            /* [out][in] */ __RPC__inout DWORD *pdwEffect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DragLeave( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Drop( 
            /* [unique][in] */ __RPC__in_opt IDataObject *pDataObj,
            /* [in] */ DWORD grfKeyState,
            /* [in] */ POINTL pt,
            /* [out][in] */ __RPC__inout DWORD *pdwEffect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDropTargetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDropTarget * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDropTarget * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDropTarget * This);
        
        HRESULT ( STDMETHODCALLTYPE *DragEnter )( 
            IDropTarget * This,
            /* [unique][in] */ __RPC__in_opt IDataObject *pDataObj,
            /* [in] */ DWORD grfKeyState,
            /* [in] */ POINTL pt,
            /* [out][in] */ __RPC__inout DWORD *pdwEffect);
        
        HRESULT ( STDMETHODCALLTYPE *DragOver )( 
            IDropTarget * This,
            /* [in] */ DWORD grfKeyState,
            /* [in] */ POINTL pt,
            /* [out][in] */ __RPC__inout DWORD *pdwEffect);
        
        HRESULT ( STDMETHODCALLTYPE *DragLeave )( 
            IDropTarget * This);
        
        HRESULT ( STDMETHODCALLTYPE *Drop )( 
            IDropTarget * This,
            /* [unique][in] */ __RPC__in_opt IDataObject *pDataObj,
            /* [in] */ DWORD grfKeyState,
            /* [in] */ POINTL pt,
            /* [out][in] */ __RPC__inout DWORD *pdwEffect);
        
        END_INTERFACE
    } IDropTargetVtbl;

    interface IDropTarget
    {
        CONST_VTBL struct IDropTargetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDropTarget_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDropTarget_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDropTarget_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDropTarget_DragEnter(This,pDataObj,grfKeyState,pt,pdwEffect)	\
    ( (This)->lpVtbl -> DragEnter(This,pDataObj,grfKeyState,pt,pdwEffect) ) 

#define IDropTarget_DragOver(This,grfKeyState,pt,pdwEffect)	\
    ( (This)->lpVtbl -> DragOver(This,grfKeyState,pt,pdwEffect) ) 

#define IDropTarget_DragLeave(This)	\
    ( (This)->lpVtbl -> DragLeave(This) ) 

#define IDropTarget_Drop(This,pDataObj,grfKeyState,pt,pdwEffect)	\
    ( (This)->lpVtbl -> Drop(This,pDataObj,grfKeyState,pt,pdwEffect) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDropTarget_INTERFACE_DEFINED__ */


#ifndef __IDropSourceNotify_INTERFACE_DEFINED__
#define __IDropSourceNotify_INTERFACE_DEFINED__

/* interface IDropSourceNotify */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDropSourceNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0000012B-0000-0000-C000-000000000046")
    IDropSourceNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DragEnterTarget( 
            /* [in] */ HWND hwndTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DragLeaveTarget( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDropSourceNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDropSourceNotify * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDropSourceNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDropSourceNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *DragEnterTarget )( 
            IDropSourceNotify * This,
            /* [in] */ HWND hwndTarget);
        
        HRESULT ( STDMETHODCALLTYPE *DragLeaveTarget )( 
            IDropSourceNotify * This);
        
        END_INTERFACE
    } IDropSourceNotifyVtbl;

    interface IDropSourceNotify
    {
        CONST_VTBL struct IDropSourceNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDropSourceNotify_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDropSourceNotify_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDropSourceNotify_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDropSourceNotify_DragEnterTarget(This,hwndTarget)	\
    ( (This)->lpVtbl -> DragEnterTarget(This,hwndTarget) ) 

#define IDropSourceNotify_DragLeaveTarget(This)	\
    ( (This)->lpVtbl -> DragLeaveTarget(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDropSourceNotify_INTERFACE_DEFINED__ */


#ifndef __IEnumOLEVERB_INTERFACE_DEFINED__
#define __IEnumOLEVERB_INTERFACE_DEFINED__

/* interface IEnumOLEVERB */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IEnumOLEVERB *LPENUMOLEVERB;

typedef struct tagOLEVERB
    {
    LONG lVerb;
    LPOLESTR lpszVerbName;
    DWORD fuFlags;
    DWORD grfAttribs;
    } 	OLEVERB;

typedef struct tagOLEVERB *LPOLEVERB;

typedef /* [v1_enum] */ 
enum tagOLEVERBATTRIB
    {	OLEVERBATTRIB_NEVERDIRTIES	= 1,
	OLEVERBATTRIB_ONCONTAINERMENU	= 2
    } 	OLEVERBATTRIB;


EXTERN_C const IID IID_IEnumOLEVERB;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000104-0000-0000-C000-000000000046")
    IEnumOLEVERB : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ LPOLEVERB rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumOLEVERB **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumOLEVERBVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumOLEVERB * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumOLEVERB * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumOLEVERB * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumOLEVERB * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ LPOLEVERB rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumOLEVERB * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumOLEVERB * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumOLEVERB * This,
            /* [out] */ __RPC__deref_out_opt IEnumOLEVERB **ppenum);
        
        END_INTERFACE
    } IEnumOLEVERBVtbl;

    interface IEnumOLEVERB
    {
        CONST_VTBL struct IEnumOLEVERBVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumOLEVERB_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumOLEVERB_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumOLEVERB_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumOLEVERB_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumOLEVERB_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumOLEVERB_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumOLEVERB_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumOLEVERB_RemoteNext_Proxy( 
    IEnumOLEVERB * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) LPOLEVERB rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);


void __RPC_STUB IEnumOLEVERB_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumOLEVERB_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  CLIPFORMAT_UserSize(     unsigned long *, unsigned long            , CLIPFORMAT * ); 
unsigned char * __RPC_USER  CLIPFORMAT_UserMarshal(  unsigned long *, unsigned char *, CLIPFORMAT * ); 
unsigned char * __RPC_USER  CLIPFORMAT_UserUnmarshal(unsigned long *, unsigned char *, CLIPFORMAT * ); 
void                      __RPC_USER  CLIPFORMAT_UserFree(     unsigned long *, CLIPFORMAT * ); 

unsigned long             __RPC_USER  HACCEL_UserSize(     unsigned long *, unsigned long            , HACCEL * ); 
unsigned char * __RPC_USER  HACCEL_UserMarshal(  unsigned long *, unsigned char *, HACCEL * ); 
unsigned char * __RPC_USER  HACCEL_UserUnmarshal(unsigned long *, unsigned char *, HACCEL * ); 
void                      __RPC_USER  HACCEL_UserFree(     unsigned long *, HACCEL * ); 

unsigned long             __RPC_USER  HDC_UserSize(     unsigned long *, unsigned long            , HDC * ); 
unsigned char * __RPC_USER  HDC_UserMarshal(  unsigned long *, unsigned char *, HDC * ); 
unsigned char * __RPC_USER  HDC_UserUnmarshal(unsigned long *, unsigned char *, HDC * ); 
void                      __RPC_USER  HDC_UserFree(     unsigned long *, HDC * ); 

unsigned long             __RPC_USER  HGLOBAL_UserSize(     unsigned long *, unsigned long            , HGLOBAL * ); 
unsigned char * __RPC_USER  HGLOBAL_UserMarshal(  unsigned long *, unsigned char *, HGLOBAL * ); 
unsigned char * __RPC_USER  HGLOBAL_UserUnmarshal(unsigned long *, unsigned char *, HGLOBAL * ); 
void                      __RPC_USER  HGLOBAL_UserFree(     unsigned long *, HGLOBAL * ); 

unsigned long             __RPC_USER  HMENU_UserSize(     unsigned long *, unsigned long            , HMENU * ); 
unsigned char * __RPC_USER  HMENU_UserMarshal(  unsigned long *, unsigned char *, HMENU * ); 
unsigned char * __RPC_USER  HMENU_UserUnmarshal(unsigned long *, unsigned char *, HMENU * ); 
void                      __RPC_USER  HMENU_UserFree(     unsigned long *, HMENU * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  STGMEDIUM_UserSize(     unsigned long *, unsigned long            , STGMEDIUM * ); 
unsigned char * __RPC_USER  STGMEDIUM_UserMarshal(  unsigned long *, unsigned char *, STGMEDIUM * ); 
unsigned char * __RPC_USER  STGMEDIUM_UserUnmarshal(unsigned long *, unsigned char *, STGMEDIUM * ); 
void                      __RPC_USER  STGMEDIUM_UserFree(     unsigned long *, STGMEDIUM * ); 

unsigned long             __RPC_USER  CLIPFORMAT_UserSize64(     unsigned long *, unsigned long            , CLIPFORMAT * ); 
unsigned char * __RPC_USER  CLIPFORMAT_UserMarshal64(  unsigned long *, unsigned char *, CLIPFORMAT * ); 
unsigned char * __RPC_USER  CLIPFORMAT_UserUnmarshal64(unsigned long *, unsigned char *, CLIPFORMAT * ); 
void                      __RPC_USER  CLIPFORMAT_UserFree64(     unsigned long *, CLIPFORMAT * ); 

unsigned long             __RPC_USER  HACCEL_UserSize64(     unsigned long *, unsigned long            , HACCEL * ); 
unsigned char * __RPC_USER  HACCEL_UserMarshal64(  unsigned long *, unsigned char *, HACCEL * ); 
unsigned char * __RPC_USER  HACCEL_UserUnmarshal64(unsigned long *, unsigned char *, HACCEL * ); 
void                      __RPC_USER  HACCEL_UserFree64(     unsigned long *, HACCEL * ); 

unsigned long             __RPC_USER  HDC_UserSize64(     unsigned long *, unsigned long            , HDC * ); 
unsigned char * __RPC_USER  HDC_UserMarshal64(  unsigned long *, unsigned char *, HDC * ); 
unsigned char * __RPC_USER  HDC_UserUnmarshal64(unsigned long *, unsigned char *, HDC * ); 
void                      __RPC_USER  HDC_UserFree64(     unsigned long *, HDC * ); 

unsigned long             __RPC_USER  HGLOBAL_UserSize64(     unsigned long *, unsigned long            , HGLOBAL * ); 
unsigned char * __RPC_USER  HGLOBAL_UserMarshal64(  unsigned long *, unsigned char *, HGLOBAL * ); 
unsigned char * __RPC_USER  HGLOBAL_UserUnmarshal64(unsigned long *, unsigned char *, HGLOBAL * ); 
void                      __RPC_USER  HGLOBAL_UserFree64(     unsigned long *, HGLOBAL * ); 

unsigned long             __RPC_USER  HMENU_UserSize64(     unsigned long *, unsigned long            , HMENU * ); 
unsigned char * __RPC_USER  HMENU_UserMarshal64(  unsigned long *, unsigned char *, HMENU * ); 
unsigned char * __RPC_USER  HMENU_UserUnmarshal64(unsigned long *, unsigned char *, HMENU * ); 
void                      __RPC_USER  HMENU_UserFree64(     unsigned long *, HMENU * ); 

unsigned long             __RPC_USER  HWND_UserSize64(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal64(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal64(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree64(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  STGMEDIUM_UserSize64(     unsigned long *, unsigned long            , STGMEDIUM * ); 
unsigned char * __RPC_USER  STGMEDIUM_UserMarshal64(  unsigned long *, unsigned char *, STGMEDIUM * ); 
unsigned char * __RPC_USER  STGMEDIUM_UserUnmarshal64(unsigned long *, unsigned char *, STGMEDIUM * ); 
void                      __RPC_USER  STGMEDIUM_UserFree64(     unsigned long *, STGMEDIUM * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IOleCache2_UpdateCache_Proxy( 
    IOleCache2 * This,
    /* [in] */ LPDATAOBJECT pDataObject,
    /* [in] */ DWORD grfUpdf,
    /* [in] */ LPVOID pReserved);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IOleCache2_UpdateCache_Stub( 
    IOleCache2 * This,
    /* [in] */ __RPC__in_opt LPDATAOBJECT pDataObject,
    /* [in] */ DWORD grfUpdf,
    /* [in] */ LONG_PTR pReserved);

/* [local] */ HRESULT STDMETHODCALLTYPE IOleInPlaceActiveObject_TranslateAccelerator_Proxy( 
    IOleInPlaceActiveObject * This,
    /* [in] */ LPMSG lpmsg);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IOleInPlaceActiveObject_TranslateAccelerator_Stub( 
    IOleInPlaceActiveObject * This);

/* [local] */ HRESULT STDMETHODCALLTYPE IOleInPlaceActiveObject_ResizeBorder_Proxy( 
    IOleInPlaceActiveObject * This,
    /* [in] */ LPCRECT prcBorder,
    /* [unique][in] */ IOleInPlaceUIWindow *pUIWindow,
    /* [in] */ BOOL fFrameWindow);


/* [input_sync][call_as] */ HRESULT STDMETHODCALLTYPE IOleInPlaceActiveObject_ResizeBorder_Stub( 
    IOleInPlaceActiveObject * This,
    /* [in] */ __RPC__in LPCRECT prcBorder,
    /* [in] */ __RPC__in REFIID riid,
    /* [iid_is][unique][in] */ __RPC__in_opt IOleInPlaceUIWindow *pUIWindow,
    /* [in] */ BOOL fFrameWindow);

/* [local] */ HRESULT STDMETHODCALLTYPE IViewObject_Draw_Proxy( 
    IViewObject * This,
    /* [in] */ DWORD dwDrawAspect,
    /* [in] */ LONG lindex,
    /* [unique][in] */ void *pvAspect,
    /* [unique][in] */ DVTARGETDEVICE *ptd,
    /* [in] */ HDC hdcTargetDev,
    /* [in] */ HDC hdcDraw,
    /* [in] */ LPCRECTL lprcBounds,
    /* [unique][in] */ LPCRECTL lprcWBounds,
    /* [in] */ BOOL ( STDMETHODCALLTYPE *pfnContinue )( 
        ULONG_PTR dwContinue),
    /* [in] */ ULONG_PTR dwContinue);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IViewObject_Draw_Stub( 
    IViewObject * This,
    /* [in] */ DWORD dwDrawAspect,
    /* [in] */ LONG lindex,
    /* [in] */ ULONG_PTR pvAspect,
    /* [unique][in] */ __RPC__in_opt DVTARGETDEVICE *ptd,
    /* [in] */ __RPC__in HDC hdcTargetDev,
    /* [in] */ __RPC__in HDC hdcDraw,
    /* [unique][in] */ __RPC__in_opt LPCRECTL lprcBounds,
    /* [unique][in] */ __RPC__in_opt LPCRECTL lprcWBounds,
    /* [in] */ __RPC__in_opt IContinue *pContinue);

/* [local] */ HRESULT STDMETHODCALLTYPE IViewObject_GetColorSet_Proxy( 
    IViewObject * This,
    /* [in] */ DWORD dwDrawAspect,
    /* [in] */ LONG lindex,
    /* [unique][in] */ void *pvAspect,
    /* [unique][in] */ DVTARGETDEVICE *ptd,
    /* [in] */ HDC hicTargetDev,
    /* [out] */ LOGPALETTE **ppColorSet);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IViewObject_GetColorSet_Stub( 
    IViewObject * This,
    /* [in] */ DWORD dwDrawAspect,
    /* [in] */ LONG lindex,
    /* [in] */ ULONG_PTR pvAspect,
    /* [unique][in] */ __RPC__in_opt DVTARGETDEVICE *ptd,
    /* [in] */ ULONG_PTR hicTargetDev,
    /* [out] */ __RPC__deref_out_opt LOGPALETTE **ppColorSet);

/* [local] */ HRESULT STDMETHODCALLTYPE IViewObject_Freeze_Proxy( 
    IViewObject * This,
    /* [in] */ DWORD dwDrawAspect,
    /* [in] */ LONG lindex,
    /* [unique][in] */ void *pvAspect,
    /* [out] */ DWORD *pdwFreeze);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IViewObject_Freeze_Stub( 
    IViewObject * This,
    /* [in] */ DWORD dwDrawAspect,
    /* [in] */ LONG lindex,
    /* [in] */ ULONG_PTR pvAspect,
    /* [out] */ __RPC__out DWORD *pdwFreeze);

/* [local] */ HRESULT STDMETHODCALLTYPE IViewObject_GetAdvise_Proxy( 
    IViewObject * This,
    /* [unique][out] */ DWORD *pAspects,
    /* [unique][out] */ DWORD *pAdvf,
    /* [out] */ IAdviseSink **ppAdvSink);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IViewObject_GetAdvise_Stub( 
    IViewObject * This,
    /* [out] */ __RPC__out DWORD *pAspects,
    /* [out] */ __RPC__out DWORD *pAdvf,
    /* [out] */ __RPC__deref_out_opt IAdviseSink **ppAdvSink);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumOLEVERB_Next_Proxy( 
    IEnumOLEVERB * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ LPOLEVERB rgelt,
    /* [out] */ ULONG *pceltFetched);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumOLEVERB_Next_Stub( 
    IEnumOLEVERB * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) LPOLEVERB rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\packon.h ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    packon.h

Abstract:

    This file turns packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    The file packoff.h is the complement to this file.

Author:

    Chuck Lenzmeier (chuckl) 4-Mar-1990

Revision History:

    15-Apr-1991 JohnRo
        Created lint-able variant.
--*/

#if ! (defined(lint) || defined(_lint))
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4103)
#endif
#pragma pack(1)                 // x86, MS compiler; MIPS, MIPS compiler
#endif // ! (defined(lint) || defined(_lint))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\p2p.h ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// File:     p2p.h
//
// Contents: Win32 APIs and structures for the Microsoft Peer To Peer infrastructure.
//
// Questions or feedback:
//
// Email:     peerfb@microsoft.com
// Website:   http://www.microsoft.com/p2p
// Newsgroup: microsoft.public.win32.programmer.networks
//
//----------------------------------------------------------------------------
//
//  If defined, the following flags inhibit definition of the indicated items.
//
//  NO_P2P_GROUP    - no Peer-to-Peer Grouping
//  NO_P2P_GRAPH    - no Peer-to-Peer Graphing
//  NO_P2P_IDENTITY - no Peer-to-Peer Identity manager
//  NO_P2P_PNRP     - no Peer-to-Peer Peer Name Resolution Protocol
//  NO_P2P_COLLABORATION - no Peer-to-Peer Collaboration Infrastructure
//
//----------------------------------------------------------------------------

#ifndef _P2P_H_
#define _P2P_H_

#ifndef MIDL_PASS
#include <specstrings.h>
#include <winsock2.h>
#include <pnrpns.h>
#include <ws2tcpip.h>  // for sockaddrin_6
#endif

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

//////////////////////////////////////////////////////////////////////////////
// Constants

typedef enum peer_record_change_type_tag {
    PEER_RECORD_ADDED                           = 1,
    PEER_RECORD_UPDATED                         = 2,
    PEER_RECORD_DELETED                         = 3,
    PEER_RECORD_EXPIRED                         = 4,
} PEER_RECORD_CHANGE_TYPE;

typedef enum peer_connection_status_tag {
    PEER_CONNECTED                              = 1,
    PEER_DISCONNECTED                           = 2,
    PEER_CONNECTION_FAILED                      = 3,
} PEER_CONNECTION_STATUS;

typedef enum peer_connection_flags_tag {
    PEER_CONNECTION_NEIGHBOR                    = 0x0001,
    PEER_CONNECTION_DIRECT                      = 0x0002,
} PEER_CONNECTION_FLAGS;

typedef enum peer_record_flags_tag {
    PEER_RECORD_FLAG_AUTOREFRESH                = 0x0001,
    PEER_RECORD_FLAG_DELETED                    = 0x0002,
} PEER_RECORD_FLAGS;

////////////////////////////////////////////////////////////////////////////////////
// Types

typedef
#ifdef MIDL_PASS
    [context_handle]
#endif
void *HPEEREVENT;
typedef HPEEREVENT * PHPEEREVENT;

typedef
#ifdef MIDL_PASS
    [context_handle]
#endif
void *HPEERENUM;
typedef HPEERENUM * PHPEERENUM;

typedef struct peer_version_data_tag {
    WORD        wVersion;
    WORD        wHighestVersion;
} PEER_VERSION_DATA, *PPEER_VERSION_DATA;

typedef struct peer_data_tag {
    ULONG cbData;
#ifdef MIDL_PASS
    [size_is(cbData)]
#endif
    PBYTE pbData;
} PEER_DATA, * PPEER_DATA;
typedef const PEER_DATA * PCPEER_DATA;

typedef struct peer_record_tag {
    DWORD       dwSize;
    GUID        type;
    GUID        id;
    DWORD       dwVersion;
    DWORD       dwFlags;
    PWSTR       pwzCreatorId;
    PWSTR       pwzModifiedById;
    PWSTR       pwzAttributes;
    FILETIME    ftCreation;
    FILETIME    ftExpiration;
    FILETIME    ftLastModified;
    PEER_DATA   securityData;
    PEER_DATA   data;
} PEER_RECORD, *PPEER_RECORD;

typedef struct peer_address_tag {
    DWORD                   dwSize;
    SOCKADDR_IN6            sin6;
} PEER_ADDRESS, *PPEER_ADDRESS;
typedef const PEER_ADDRESS * PCPEER_ADDRESS;


typedef struct peer_connection_info_tag {
    DWORD              dwSize;
    DWORD              dwFlags;
    ULONGLONG          ullConnectionId;
    ULONGLONG          ullNodeId;
    PWSTR              pwzPeerId;
    PEER_ADDRESS       address;
} PEER_CONNECTION_INFO;

typedef struct peer_event_incoming_data_tag {
    DWORD                   dwSize;
    ULONGLONG               ullConnectionId;
    GUID                    type;
    PEER_DATA               data;
} PEER_EVENT_INCOMING_DATA, *PPEER_EVENT_INCOMING_DATA;

typedef struct peer_event_record_change_data_tag {
    DWORD                       dwSize;
    PEER_RECORD_CHANGE_TYPE     changeType;
    GUID                        recordId;
    GUID                        recordType;
} PEER_EVENT_RECORD_CHANGE_DATA, * PPEER_EVENT_RECORD_CHANGE_DATA;

typedef struct peer_event_connection_change_data_tag {
    DWORD                   dwSize;
    PEER_CONNECTION_STATUS  status;
    ULONGLONG               ullConnectionId;
    ULONGLONG               ullNodeId;
#if NTDDI_VERSION >= NTDDI_LONGHORN
    ULONGLONG               ullNextConnectionId;
    HRESULT                 hrConnectionFailedReason;
#endif
} PEER_EVENT_CONNECTION_CHANGE_DATA, * PPEER_EVENT_CONNECTION_CHANGE_DATA;

typedef struct peer_event_synchronized_data_tag {
    DWORD                   dwSize;
    GUID                    recordType;
} PEER_EVENT_SYNCHRONIZED_DATA, * PPEER_EVENT_SYNCHRONIZED_DATA;

#ifndef MIDL_PASS
#ifndef   NO_P2P_GRAPH

/////////////////////////////////////////////////////////////////////////////
//
//  G R A P H I N G
//
/////////////////////////////////////////////////////////////////////////////

typedef PVOID HGRAPH, *PHGRAPH;

/////////////////////////////////////////////////////////////////////////////
// Constants

#define PEER_GRAPH_VERSION MAKEWORD(1,0)

typedef enum peer_graph_event_type_tag {
    PEER_GRAPH_EVENT_STATUS_CHANGED             = 1,
    PEER_GRAPH_EVENT_PROPERTY_CHANGED           = 2,
    PEER_GRAPH_EVENT_RECORD_CHANGED             = 3,
    PEER_GRAPH_EVENT_DIRECT_CONNECTION          = 4,
    PEER_GRAPH_EVENT_NEIGHBOR_CONNECTION        = 5,
    PEER_GRAPH_EVENT_INCOMING_DATA              = 6,
    PEER_GRAPH_EVENT_CONNECTION_REQUIRED        = 7,
    PEER_GRAPH_EVENT_NODE_CHANGED               = 8,
    PEER_GRAPH_EVENT_SYNCHRONIZED               = 9,
} PEER_GRAPH_EVENT_TYPE;

typedef enum peer_node_change_type_tag {
    PEER_NODE_CHANGE_CONNECTED              = 1,
    PEER_NODE_CHANGE_DISCONNECTED           = 2,
    PEER_NODE_CHANGE_UPDATED                = 3,
} PEER_NODE_CHANGE_TYPE;

typedef enum peer_graph_status_flags_tag {
    PEER_GRAPH_STATUS_LISTENING            = 0x0001,
    PEER_GRAPH_STATUS_HAS_CONNECTIONS      = 0x0002,
    PEER_GRAPH_STATUS_SYNCHRONIZED         = 0x0004,
} PEER_GRAPH_STATUS_FLAGS;

typedef enum peer_graph_property_flags_tag {
    PEER_GRAPH_PROPERTY_HEARTBEATS         = 0x0001,
    PEER_GRAPH_PROPERTY_DEFER_EXPIRATION   = 0x0002,
} PEER_GRAPH_PROPERTY_FLAGS;

typedef enum peer_graph_scope_tag {
    PEER_GRAPH_SCOPE_ANY                     = 0,
    PEER_GRAPH_SCOPE_GLOBAL                  = 1,
    PEER_GRAPH_SCOPE_SITELOCAL               = 2,
    PEER_GRAPH_SCOPE_LINKLOCAL               = 3,
    PEER_GRAPH_SCOPE_LOOPBACK                = 4
} PEER_GRAPH_SCOPE;


/////////////////////////////////////////////////////////////////////////////
// Structures

typedef struct peer_graph_properties_tag {
    DWORD              dwSize;
    DWORD              dwFlags;          // PEER_GRAPH_PROPERTY_FLAGS
    DWORD              dwScope;
    DWORD              dwMaxRecordSize;
    PWSTR              pwzGraphId;
    PWSTR              pwzCreatorId;
    PWSTR              pwzFriendlyName;
    PWSTR              pwzComment;
    ULONG              ulPresenceLifetime;
    ULONG              cPresenceMax;
} PEER_GRAPH_PROPERTIES, *PPEER_GRAPH_PROPERTIES;

typedef struct peer_node_info_tag {
    DWORD              dwSize;
    ULONGLONG          ullNodeId;
    PWSTR              pwzPeerId;
    ULONG              cAddresses;
    PPEER_ADDRESS      pAddresses;
    PWSTR              pwzAttributes;
} PEER_NODE_INFO, *PPEER_NODE_INFO;

typedef struct peer_event_node_change_data_tag {
    DWORD                       dwSize;
    PEER_NODE_CHANGE_TYPE       changeType;
    ULONGLONG                   ullNodeId;
    PWSTR                       pwzPeerId;
} PEER_EVENT_NODE_CHANGE_DATA, *PPEER_EVENT_NODE_CHANGE_DATA;

typedef struct peer_graph_event_registration_tag {
    PEER_GRAPH_EVENT_TYPE eventType;
    GUID *                pType;
} PEER_GRAPH_EVENT_REGISTRATION, *PPEER_GRAPH_EVENT_REGISTRATION;

typedef struct peer_graph_event_data_tag {
    PEER_GRAPH_EVENT_TYPE eventType;
    union {
       PEER_GRAPH_STATUS_FLAGS                  dwStatus;
       PEER_EVENT_INCOMING_DATA                 incomingData;
       PEER_EVENT_RECORD_CHANGE_DATA            recordChangeData;
       PEER_EVENT_CONNECTION_CHANGE_DATA        connectionChangeData;
       PEER_EVENT_NODE_CHANGE_DATA              nodeChangeData;
       PEER_EVENT_SYNCHRONIZED_DATA             synchronizedData;
    };
} PEER_GRAPH_EVENT_DATA, *PPEER_GRAPH_EVENT_DATA;


typedef HRESULT (CALLBACK * PFNPEER_VALIDATE_RECORD)(
                __in    HGRAPH                  hGraph,
                __in_opt PVOID                  pvContext,
                __in PPEER_RECORD               pRecord,
                __in PEER_RECORD_CHANGE_TYPE    changeType);

typedef HRESULT (CALLBACK * PFNPEER_SECURE_RECORD)(
                __in HGRAPH                         hGraph,
                __in_opt PVOID                      pvContext,
                __in PPEER_RECORD                   pRecord,
                __in PEER_RECORD_CHANGE_TYPE        changeType,
                __deref_out PPEER_DATA              * ppSecurityData);

typedef HRESULT (CALLBACK * PFNPEER_FREE_SECURITY_DATA)(
                __in HGRAPH             hGraph,
                __in_opt PVOID          pvContext,
                __in PPEER_DATA         pSecurityData);

typedef struct peer_security_interface_tag {
    DWORD                       dwSize;
    PWSTR                       pwzSspFilename;
    PWSTR                       pwzPackageName;
    ULONG                       cbSecurityInfo;
    PBYTE                       pbSecurityInfo;
    PVOID                       pvContext;
    PFNPEER_VALIDATE_RECORD     pfnValidateRecord;
    PFNPEER_SECURE_RECORD       pfnSecureRecord;
    PFNPEER_FREE_SECURITY_DATA  pfnFreeSecurityData;
}PEER_SECURITY_INTERFACE, * PPEER_SECURITY_INTERFACE;


/////////////////////////////////////////////////////////////////////////////
// API Definitions

HRESULT WINAPI PeerGraphStartup(
                __in  WORD                  wVersionRequested,
                __out PPEER_VERSION_DATA    pVersionData);

HRESULT WINAPI PeerGraphShutdown();

VOID WINAPI PeerGraphFreeData(
                __in  PVOID       pvData);

HRESULT WINAPI PeerGraphGetItemCount(
                __in    HPEERENUM   hPeerEnum,
                __out   ULONG       * pCount);

HRESULT WINAPI PeerGraphGetNextItem(
                __in  HPEERENUM     hPeerEnum,
                __inout ULONG       * pCount,
                __deref_out_ecount(*pCount) PVOID ** pppvItems);

HRESULT WINAPI PeerGraphEndEnumeration(
                __in  HPEERENUM   hPeerEnum);

HRESULT WINAPI PeerGraphCreate(
                __in    PPEER_GRAPH_PROPERTIES          pGraphProperties,
                __in    PCWSTR                          pwzDatabaseName,
                __in_opt PPEER_SECURITY_INTERFACE       pSecurityInterface,
                __out   HGRAPH                          * phGraph);

HRESULT WINAPI PeerGraphOpen(
                __in  PCWSTR                                    pwzGraphId,
                __in  PCWSTR                                    pwzPeerId,
                __in  PCWSTR                                    pwzDatabaseName,
                __in_opt PPEER_SECURITY_INTERFACE               pSecurityInterface,
                __in  ULONG                                     cRecordTypeSyncPrecedence,
                __in_ecount_opt(cRecordTypeSyncPrecedence) GUID * pRecordTypeSyncPrecedence,
                __out HGRAPH                                    * phGraph);

HRESULT WINAPI PeerGraphListen(
                __in  HGRAPH        hGraph,
                __in_opt DWORD      dwScope,
                __in_opt  DWORD     dwScopeId,
                __in_opt  WORD      wPort);

HRESULT WINAPI PeerGraphConnect(
                __in  HGRAPH            hGraph,
                __in_opt  PCWSTR        pwzPeerId,
                __in  PPEER_ADDRESS     pAddress,
                __out ULONGLONG         * pullConnectionId);

HRESULT WINAPI PeerGraphClose(
                __in  HGRAPH      hGraph);

HRESULT WINAPI PeerGraphDelete(
                __in  PCWSTR      pwzGraphId,
                __in  PCWSTR      pwzPeerId,
                __in  PCWSTR      pwzDatabaseName);

HRESULT WINAPI PeerGraphGetStatus(
                __in  HGRAPH       hGraph,
                __out   DWORD      * pdwStatus);

HRESULT WINAPI PeerGraphGetProperties(
                __in  HGRAPH                        hGraph,
                __deref_out PPEER_GRAPH_PROPERTIES  * ppGraphProperties);

HRESULT WINAPI PeerGraphSetProperties(
                __in  HGRAPH                    hGraph,
                __in  PPEER_GRAPH_PROPERTIES    pGraphProperties);

// Eventing interfaces

HRESULT WINAPI PeerGraphRegisterEvent(
                __in  HGRAPH                    hGraph,
                __in  HANDLE                    hEvent,
                __in  ULONG                     cEventRegistrations,
                __in_ecount(cEventRegistrations) PEER_GRAPH_EVENT_REGISTRATION  * pEventRegistrations,
                __out HPEEREVENT                * phPeerEvent);

HRESULT WINAPI PeerGraphUnregisterEvent(
                __in  HPEEREVENT   hPeerEvent);

HRESULT WINAPI PeerGraphGetEventData(
                __in  HPEEREVENT                    hPeerEvent,
                __deref_out PPEER_GRAPH_EVENT_DATA  * ppEventData);


// Data Storage

HRESULT WINAPI PeerGraphGetRecord(
                __in  HGRAPH            hGraph,
                __in  GUID              * pRecordId,
                __deref_out PPEER_RECORD * ppRecord);

HRESULT WINAPI PeerGraphAddRecord(
                __in  HGRAPH        hGraph,
                __in  PPEER_RECORD pRecord,
                __out GUID          * pRecordId);

HRESULT WINAPI PeerGraphUpdateRecord(
                __in  HGRAPH            hGraph,
                __in  PPEER_RECORD      pRecord);

HRESULT WINAPI PeerGraphDeleteRecord(
                __in  HGRAPH       hGraph,
                __in  GUID *       pRecordId,
                __in  BOOL         fLocal);

HRESULT WINAPI PeerGraphEnumRecords(
                __in  HGRAPH       hGraph,
                __in_opt  GUID *   pRecordType,
                __in_opt  PCWSTR   pwzPeerId,
                __out HPEERENUM *  phPeerEnum);

HRESULT WINAPI PeerGraphSearchRecords(
                __in  HGRAPH        hGraph,
                __in  PCWSTR        pwzCriteria,
                __out HPEERENUM     * phPeerEnum);

HRESULT WINAPI PeerGraphExportDatabase(
                __in  HGRAPH       hGraph,
                __in  PCWSTR       pwzFilePath);

HRESULT WINAPI PeerGraphImportDatabase(
                __in  HGRAPH       hGraph,
                __in  PCWSTR       pwzFilePath);

HRESULT WINAPI PeerGraphValidateDeferredRecords(
                __in  HGRAPH                    hGraph,
                __in  ULONG                     cRecordIds,
                __in_ecount(cRecordIds) GUID    * pRecordIds);


// Node/Connection interfaces

HRESULT WINAPI PeerGraphOpenDirectConnection(
                __in  HGRAPH            hGraph,
                __in  PCWSTR            pwzPeerId,
                __in  PPEER_ADDRESS     pAddress,
                __out ULONGLONG         * pullConnectionId);

HRESULT WINAPI PeerGraphSendData(
                __in  HGRAPH                hGraph,
                __in  ULONGLONG             ullConnectionId,
                __in  GUID *                pType,
                __in  ULONG                 cbData,
                __in_bcount(cbData) PVOID   pvData);

HRESULT WINAPI PeerGraphCloseDirectConnection(
                __in  HGRAPH       hGraph,
                __in  ULONGLONG    ullConnectionId);

HRESULT WINAPI PeerGraphEnumConnections(
                __in  HGRAPH        hGraph,
                __in  DWORD         dwFlags,         // PEER_CONNECTION_FLAGS
                __out HPEERENUM     * phPeerEnum);

HRESULT WINAPI PeerGraphEnumNodes(
                __in  HGRAPH        hGraph,
                __in_opt PCWSTR     pwzPeerId,
                __out HPEERENUM     * phPeerEnum);

HRESULT WINAPI PeerGraphSetPresence(
                __in  HGRAPH       hGraph,
                __in  BOOL         fPresent);

HRESULT WINAPI PeerGraphGetNodeInfo(
                __in  HGRAPH                hGraph,
                __in  ULONGLONG             ullNodeId,
                __deref_out PPEER_NODE_INFO * ppNodeInfo);

HRESULT WINAPI PeerGraphSetNodeAttributes(
                __in  HGRAPH       hGraph,
                __in  PCWSTR       pwzAttributes);

HRESULT WINAPI PeerGraphPeerTimeToUniversalTime(
                __in  HGRAPH       hGraph,
                __in  FILETIME *   pftPeerTime,
                __out FILETIME *   pftUniversalTime);

HRESULT WINAPI PeerGraphUniversalTimeToPeerTime(
                __in  HGRAPH       hGraph,
                __in  FILETIME *   pftUniversalTime,
                __out FILETIME *   pftPeerTime);

#endif // NO_P2P_GRAPH


#if (!(defined (NO_P2P_GROUP)) || (!defined (NO_P2P_IDENTITY)))
//////////////////////////////////////////////////////////////////////////////
//
//  Common APIs used by Grouping and the Identity Manager
//
//////////////////////////////////////////////////////////////////////////////

#include <wincrypt.h>

VOID    WINAPI PeerFreeData(
                __in_opt    LPCVOID     pvData);

HRESULT WINAPI PeerGetItemCount(
                __in    HPEERENUM       hPeerEnum,
                __out   ULONG           * pCount);

HRESULT WINAPI PeerGetNextItem(
                __in  HPEERENUM                     hPeerEnum,
                __inout ULONG                       * pCount,
                __deref_out_ecount(*pCount) PVOID   ** pppvItems);

HRESULT WINAPI PeerEndEnumeration(
                __in  HPEERENUM    hPeerEnum);

#endif

#ifndef NO_P2P_GROUP
/////////////////////////////////////////////////////////////////////////////
//
//  G R O U P I N G
//
/////////////////////////////////////////////////////////////////////////////

typedef PVOID HGROUP, *PHGROUP;

typedef GUID  PEER_ROLE_ID;

/////////////////////////////////////////////////////////////////////////////
// Constants

#if NTDDI_VERSION >= NTDDI_LONGHORN
    #define PEER_GROUP_VERSION MAKEWORD(1,1)
#else
    #define PEER_GROUP_VERSION MAKEWORD(1,0)
#endif

typedef enum peer_group_event_type_tag {
    PEER_GROUP_EVENT_STATUS_CHANGED             = 1,
    PEER_GROUP_EVENT_PROPERTY_CHANGED           = 2,
    PEER_GROUP_EVENT_RECORD_CHANGED             = 3,
    PEER_GROUP_EVENT_DIRECT_CONNECTION          = 4,
    PEER_GROUP_EVENT_NEIGHBOR_CONNECTION        = 5,
    PEER_GROUP_EVENT_INCOMING_DATA              = 6,
    PEER_GROUP_EVENT_MEMBER_CHANGED             = 8,
    PEER_GROUP_EVENT_CONNECTION_FAILED          = 10
} PEER_GROUP_EVENT_TYPE;

typedef enum peer_group_status_tag {
    PEER_GROUP_STATUS_LISTENING            = 0x0001,
    PEER_GROUP_STATUS_HAS_CONNECTIONS      = 0x0002,
} PEER_GROUP_STATUS;

typedef enum peer_group_property_flags_tag {
    PEER_MEMBER_DATA_OPTIONAL              = 0x0001,
    PEER_DISABLE_PRESENCE                  = 0x0002,
    PEER_DEFER_EXPIRATION                  = 0x0004,
} PEER_GROUP_PROPERTY_FLAGS;


#if NTDDI_VERSION >= NTDDI_LONGHORN
typedef enum peer_group_authentication_scheme_tag {
    PEER_GROUP_GMC_AUTHENTICATION          = 0x00000001,
    PEER_GROUP_PASSWORD_AUTHENTICATION     = 0x00000002,
} PEER_GROUP_AUTHENTICATION_SCHEME;
#endif

typedef enum peer_member_flags_tag {
    PEER_MEMBER_PRESENT                    = 0x0001,
} PEER_MEMBER_FLAGS;

typedef enum peer_member_change_type_tag {
    PEER_MEMBER_CONNECTED                  = 1,
    PEER_MEMBER_DISCONNECTED               = 2,
    PEER_MEMBER_UPDATED                    = 3,
    PEER_MEMBER_JOINED                     = 4,
    PEER_MEMBER_LEFT                       = 5,
} PEER_MEMBER_CHANGE_TYPE;

typedef enum peer_issue_credential_flags_tag {
    PEER_GROUP_STORE_CREDENTIALS      = 0x0001,
} PEER_GROUP_ISSUE_CREDENTIAL_FLAGS;


/////////////////////////////////////////////////////////////////////////////
// Structures

typedef struct peer_credential_info_tag
{
    DWORD                   dwSize;
    DWORD                   dwFlags;
    PWSTR                   pwzFriendlyName;
    CERT_PUBLIC_KEY_INFO  * pPublicKey;
    PWSTR                   pwzIssuerPeerName;
    PWSTR                   pwzIssuerFriendlyName;
    FILETIME                ftValidityStart;
    FILETIME                ftValidityEnd;
    ULONG                   cRoles;
    __field_ecount(cRoles) PEER_ROLE_ID          * pRoles;
} PEER_CREDENTIAL_INFO, * PPEER_CREDENTIAL_INFO;

typedef struct peer_member_tag {
    DWORD                   dwSize;
    DWORD                   dwFlags;     // PEER_MEMBER_FLAGS
    PWSTR                   pwzIdentity;
    PWSTR                   pwzAttributes;
    ULONGLONG               ullNodeId;
    ULONG                   cAddresses;
    __field_ecount(cAddresses) PEER_ADDRESS          * pAddresses;
    PEER_CREDENTIAL_INFO  * pCredentialInfo;
} PEER_MEMBER, *PPEER_MEMBER;

typedef struct peer_group_properties_tag {
    DWORD            dwSize;
    DWORD            dwFlags;            // PEER_GROUP_PROPERTY_FLAGS
    PWSTR            pwzCloud;
    PWSTR            pwzClassifier;
    PWSTR            pwzGroupPeerName;
    PWSTR            pwzCreatorPeerName;
    PWSTR            pwzFriendlyName;
    PWSTR            pwzComment;
    ULONG            ulMemberDataLifetime;
    ULONG            ulPresenceLifetime;
#if NTDDI_VERSION >= NTDDI_LONGHORN
    DWORD            dwAuthenticationSchemes; // PEER_GROUP_AUTHENTICATION_SCHEME
    // group password authentication data
    PWSTR            pwzGroupPassword;
    PEER_ROLE_ID     groupPasswordRole;
#endif
} PEER_GROUP_PROPERTIES, *PPEER_GROUP_PROPERTIES;

typedef struct peer_invitation_info_tag {
    DWORD            dwSize;
    DWORD            dwFlags;
    PWSTR            pwzCloudName;
    DWORD            dwScope;
    DWORD            dwCloudFlags;
    PWSTR            pwzGroupPeerName;
    PWSTR            pwzIssuerPeerName;
    PWSTR            pwzSubjectPeerName;
    PWSTR            pwzGroupFriendlyName;
    PWSTR            pwzIssuerFriendlyName;
    PWSTR            pwzSubjectFriendlyName;
    FILETIME         ftValidityStart;
    FILETIME         ftValidityEnd;
    ULONG            cRoles;
    PEER_ROLE_ID   * pRoles;
    ULONG            cClassifiers;
    PWSTR*           ppwzClassifiers;
    CERT_PUBLIC_KEY_INFO * pSubjectPublicKey;
#if NTDDI_VERSION >= NTDDI_LONGHORN
    PEER_GROUP_AUTHENTICATION_SCHEME authScheme;
#endif
} PEER_INVITATION_INFO, *PPEER_INVITATION_INFO;

typedef struct peer_event_member_change_data_tag {
    DWORD                   dwSize;
    PEER_MEMBER_CHANGE_TYPE changeType;
    PWSTR                   pwzIdentity;
} PEER_EVENT_MEMBER_CHANGE_DATA, * PPEER_EVENT_MEMBER_CHANGE_DATA;

typedef struct peer_group_event_registration_tag {
    PEER_GROUP_EVENT_TYPE eventType;
    GUID *                pType;
} PEER_GROUP_EVENT_REGISTRATION, *PPEER_GROUP_EVENT_REGISTRATION;

typedef struct peer_group_event_data_tag {
    PEER_GROUP_EVENT_TYPE eventType;
    union {
       PEER_GROUP_STATUS                 dwStatus;
       PEER_EVENT_INCOMING_DATA          incomingData;
       PEER_EVENT_RECORD_CHANGE_DATA     recordChangeData;
       PEER_EVENT_CONNECTION_CHANGE_DATA connectionChangeData;
       PEER_EVENT_MEMBER_CHANGE_DATA     memberChangeData;
       HRESULT                           hrConnectionFailedReason;
    };
} PEER_GROUP_EVENT_DATA, *PPEER_GROUP_EVENT_DATA;

typedef struct peer_name_pair_tag {
    DWORD           dwSize;
    PWSTR           pwzPeerName;
    PWSTR           pwzFriendlyName;
} PEER_NAME_PAIR, * PPEER_NAME_PAIR;


/////////////////////////////////////////////////////////////////////////////
// API Definitions

HRESULT WINAPI PeerGroupStartup(
                __in  WORD                  wVersionRequested,
                __out PPEER_VERSION_DATA    pVersionData);

HRESULT WINAPI PeerGroupShutdown();

HRESULT WINAPI PeerGroupCreate(
                __in  PPEER_GROUP_PROPERTIES    pProperties,
                __out HGROUP                    * phGroup);

HRESULT WINAPI PeerGroupOpen(
                __in  PCWSTR       pwzIdentity,
                __in  PCWSTR       pwzGroupPeerName,
                __in_opt  PCWSTR   pwzCloud,
                __out HGROUP       * phGroup);

HRESULT WINAPI PeerGroupJoin(
                __in  PCWSTR        pwzIdentity,
                __in  PCWSTR        pwzInvitation,
                __in_opt  PCWSTR    pwzCloud,
                __out HGROUP        * phGroup);

#if NTDDI_VERSION >= NTDDI_LONGHORN
HRESULT WINAPI PeerGroupPasswordJoin(
                __in  PCWSTR        pwzIdentity,
                __in  PCWSTR        pwzInvitation,
                __in  PCWSTR        pwzPassword,
                __in_opt  PCWSTR    pwzCloud,
                __out HGROUP        * phGroup);
#endif

HRESULT WINAPI PeerGroupConnect(
                __in  HGROUP       hGroup);

#if NTDDI_VERSION >= NTDDI_LONGHORN
HRESULT WINAPI PeerGroupConnectByAddress(
                __in  HGROUP                            hGroup,
                      ULONG                             cAddresses,
                __in_ecount(cAddresses) PPEER_ADDRESS   pAddresses);
#endif

HRESULT WINAPI PeerGroupClose(
                __in  HGROUP       hGroup);

HRESULT WINAPI PeerGroupDelete(
                __in  PCWSTR       pwzIdentity,
                __in  PCWSTR       pwzGroupPeerName);

HRESULT WINAPI PeerGroupCreateInvitation(
                __in  HGROUP                    hGroup,
                __in  PCWSTR                    pwzIdentityInfo,
                __in_opt  FILETIME              * pftExpiration,
                __in  ULONG                     cRoles,
                __in_ecount_opt(cRoles) GUID    * pRoles,
                __deref_out PWSTR               * ppwzInvitation);

#if NTDDI_VERSION >= NTDDI_LONGHORN
HRESULT WINAPI PeerGroupCreatePasswordInvitation(
                __in  HGROUP        hGroup,
                __deref_out PWSTR   * ppwzInvitation);
#endif

HRESULT WINAPI PeerGroupParseInvitation(
                __in  PCWSTR                        pwzInvitation,
                __deref_out PPEER_INVITATION_INFO   * ppInvitationInfo);

HRESULT WINAPI PeerGroupGetStatus(
                __in  HGROUP        hGroup,
                __out DWORD         * pdwStatus);

HRESULT WINAPI PeerGroupGetProperties(
                __in  HGROUP                        hGroup,
                __deref_out PPEER_GROUP_PROPERTIES  * ppProperties);

HRESULT WINAPI PeerGroupSetProperties(
                __in  HGROUP                    hGroup,
                __in  PPEER_GROUP_PROPERTIES    pProperties);

HRESULT WINAPI PeerGroupEnumMembers(
                __in  HGROUP        hGroup,
                __in  DWORD         dwFlags,      // PEER_MEMBER_FLAGS
                __in_opt PCWSTR     pwzIdentity,
                __out HPEERENUM     * phPeerEnum);

HRESULT WINAPI PeerGroupOpenDirectConnection(
                __in  HGROUP            hGroup,
                __in  PCWSTR            pwzIdentity,
                __in  PPEER_ADDRESS     pAddress,
                __out ULONGLONG         * pullConnectionId);

HRESULT WINAPI PeerGroupCloseDirectConnection(
                __in  HGROUP       hGroup,
                __in  ULONGLONG    ullConnectionId);

HRESULT WINAPI PeerGroupEnumConnections(
                __in  HGROUP        hGroup,
                __in  DWORD         dwFlags,         // PEER_CONNECTION_FLAGS
                __out HPEERENUM     * phPeerEnum);

HRESULT WINAPI PeerGroupSendData(
                __in  HGROUP                hGroup,
                __in  ULONGLONG             ullConnectionId,
                __in  GUID *                pType,
                __in  ULONG                 cbData,
                __in_bcount(cbData) PVOID   pvData);


// Eventing interfaces

HRESULT WINAPI PeerGroupRegisterEvent(
                __in  HGROUP                hGroup,
                __in  HANDLE                hEvent,
                __in  DWORD                 cEventRegistration,
                __in_ecount(cEventRegistration) PEER_GROUP_EVENT_REGISTRATION   * pEventRegistrations,
                __out HPEEREVENT            * phPeerEvent);

HRESULT WINAPI PeerGroupUnregisterEvent(
                __in  HPEEREVENT   hPeerEvent);

HRESULT WINAPI PeerGroupGetEventData(
                __in  HPEEREVENT                    hPeerEvent,
                __deref_out PPEER_GROUP_EVENT_DATA  * ppEventData);


// Data Storage

HRESULT WINAPI PeerGroupGetRecord(
                __in  HGROUP            hGroup,
                __in  GUID              * pRecordId,
                __deref_out PPEER_RECORD * ppRecord);

HRESULT WINAPI PeerGroupAddRecord(
                __in  HGROUP        hGroup,
                __in  PPEER_RECORD pRecord,
                __out GUID          * pRecordId);

HRESULT WINAPI PeerGroupUpdateRecord(
                __in  HGROUP        hGroup,
                __in  PPEER_RECORD pRecord);

HRESULT WINAPI PeerGroupDeleteRecord(
                __in  HGROUP       hGroup,
                __in  GUID *       pRecordId);

HRESULT WINAPI PeerGroupEnumRecords(
                __in  HGROUP        hGroup,
                __in_opt GUID       * pRecordType,
                __out HPEERENUM     * phPeerEnum);

HRESULT WINAPI PeerGroupSearchRecords(
                __in  HGROUP        hGroup,
                __in  PCWSTR        pwzCriteria,
                __out HPEERENUM     * phPeerEnum);

HRESULT WINAPI PeerGroupExportDatabase(
                __in  HGROUP       hGroup,
                __in  PCWSTR       pwzFilePath);

HRESULT WINAPI PeerGroupImportDatabase(
                __in  HGROUP       hGroup,
                __in  PCWSTR       pwzFilePath);

HRESULT WINAPI PeerGroupIssueCredentials(
                __in HGROUP                     hGroup,
                __in PCWSTR                     pwzSubjectIdentity,
                __in_opt PEER_CREDENTIAL_INFO   * pCredentialInfo,
                __in DWORD                      dwFlags,
                __deref_opt_out PWSTR           * ppwzInvitation);

HRESULT WINAPI PeerGroupExportConfig(
                __in  HGROUP        hGroup,
                __in  PCWSTR        pwzPassword,
                __deref_out PWSTR   * ppwzXML);

HRESULT WINAPI PeerGroupImportConfig(
                __in PCWSTR         pwzXML,
                __in PCWSTR         pwzPassword,
                __in BOOL           fOverwrite,
                __deref_out PWSTR   * ppwzIdentity,
                __deref_out PWSTR   * ppwzGroup);

HRESULT WINAPI PeerGroupPeerTimeToUniversalTime(
                __in  HGROUP       hGroup,
                __in  FILETIME *   pftPeerTime,
                __out FILETIME *   pftUniversalTime);

HRESULT WINAPI PeerGroupUniversalTimeToPeerTime(
                __in  HGROUP       hGroup,
                __in  FILETIME *   pftUniversalTime,
                __out FILETIME *   pftPeerTime);

#endif // NO_P2P_GROUP


#ifndef   NO_P2P_IDENTITY

/////////////////////////////////////////////////////////////////////////////
//
//  I D E N T I T Y
//
/////////////////////////////////////////////////////////////////////////////

// API Definitions

HRESULT WINAPI PeerIdentityCreate(
                __in_opt  PCWSTR        pwzClassifier,
                __in_opt  PCWSTR        pwzFriendlyName,
                __in_opt  HCRYPTPROV    hCryptProv,
                __deref_out PWSTR       * ppwzIdentity);

HRESULT WINAPI  PeerIdentityGetFriendlyName(
                __in_opt  PCWSTR    pwzIdentity,
                __deref_out PWSTR   * ppwzFriendlyName);

HRESULT WINAPI  PeerIdentitySetFriendlyName(
                __in_opt  PCWSTR    pwzIdentity,
                __in  PCWSTR       pwzFriendlyName);

HRESULT WINAPI  PeerIdentityGetCryptKey(
                __in_opt  PCWSTR    pwzIdentity,
                __out HCRYPTPROV    * phCryptProv);

HRESULT WINAPI  PeerIdentityDelete(
                __in  PCWSTR       pwzIdentity);

HRESULT WINAPI  PeerEnumIdentities(
                __out HPEERENUM  * phPeerEnum);

HRESULT WINAPI  PeerEnumGroups(
                __in  PCWSTR        pwzIdentity,
                __out HPEERENUM     * phPeerEnum);

HRESULT WINAPI  PeerCreatePeerName(
                __in_opt PCWSTR     pwzIdentity,
                __in_opt PCWSTR     pwzClassifier,
                __deref_out PWSTR   * ppwzPeerName);

HRESULT WINAPI PeerIdentityGetXML(
                __in_opt  PCWSTR    pwzIdentity,
                __deref_out PWSTR   * ppwzIdentityXML);

HRESULT WINAPI PeerIdentityExport(
                __in_opt  PCWSTR    pwzIdentity,
                __in  PCWSTR        pwzPassword,
                __deref_out PWSTR   * ppwzExportXML);

HRESULT WINAPI PeerIdentityImport(
                __in  PCWSTR        pwzImportXML,
                __in  PCWSTR        pwzPassword,
                __deref_out PWSTR   * ppwzIdentity);

HRESULT WINAPI PeerIdentityGetDefault(
                __deref_out PWSTR   * ppwzPeerName);

#endif // NO_P2P_IDENTITY
#endif // MIDL_PASS

#ifndef NO_P2P_COLLABORATION

/////////////////////////////////////////////////////////////////////////////
//
//  C O L L A B O R A T I O N
//
/////////////////////////////////////////////////////////////////////////////

#define PEER_COLLAB_VERSION MAKEWORD(1,0)

//////////////////////////////////////////////////////////////////////////////
//
//  Common used by AppInvite, Contact API's and Serverless Presence
//
//////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Constants

typedef enum peer_signin_flags_tag {
    PEER_SIGNIN_NONE         = 0x0,
    PEER_SIGNIN_NEAR_ME      = 0x1,
    PEER_SIGNIN_INTERNET     = 0x2,
    PEER_SIGNIN_ALL          = PEER_SIGNIN_INTERNET | PEER_SIGNIN_NEAR_ME
} PEER_SIGNIN_FLAGS;

typedef enum peer_watch_permission_tag {
    PEER_WATCH_BLOCKED          = 0,
    PEER_WATCH_ALLOWED          = 1
} PEER_WATCH_PERMISSION;

typedef enum peer_publication_scope_tag {
    PEER_PUBLICATION_SCOPE_NONE         = 0x0,
    PEER_PUBLICATION_SCOPE_NEAR_ME      = 0x1,
    PEER_PUBLICATION_SCOPE_INTERNET     = 0x2,
    PEER_PUBLICATION_SCOPE_ALL          = PEER_PUBLICATION_SCOPE_NEAR_ME | PEER_PUBLICATION_SCOPE_INTERNET
} PEER_PUBLICATION_SCOPE;

/////////////////////////////////////////////////////////////////////////////
// Structures

typedef struct peer_application_tag {
    GUID            id;
    PEER_DATA       data;
    PWSTR           pwzDescription;
} PEER_APPLICATION, *PPEER_APPLICATION;
typedef const PEER_APPLICATION * PCPEER_APPLICATION;

typedef struct peer_object_tag {
    GUID            id;
    PEER_DATA       data;
    DWORD           dwPublicationScope;
} PEER_OBJECT, * PPEER_OBJECT;
typedef const PEER_OBJECT   * PCPEER_OBJECT;

typedef struct peer_contact_tag
{
    PWSTR                               pwzPeerName;
    PWSTR                               pwzNickName;
    PWSTR                               pwzDisplayName;
    PWSTR                               pwzEmailAddress;
    BOOL                                fWatch;
    PEER_WATCH_PERMISSION               WatcherPermissions;
    PEER_DATA                           credentials;
} PEER_CONTACT, *PPEER_CONTACT;
typedef const PEER_CONTACT * PCPEER_CONTACT;

typedef struct peer_endpoint_tag {
    PEER_ADDRESS                address;
    PWSTR                       pwzEndpointName;
} PEER_ENDPOINT, *PPEER_ENDPOINT;
typedef const PEER_ENDPOINT * PCPEER_ENDPOINT;

typedef struct peer_people_near_me_tag {
    PWSTR                       pwzNickName;
    PEER_ENDPOINT               endpoint;
    GUID                        id;
} PEER_PEOPLE_NEAR_ME, *PPEER_PEOPLE_NEAR_ME;
typedef const PEER_PEOPLE_NEAR_ME *PCPEER_PEOPLE_NEAR_ME;
typedef PPEER_PEOPLE_NEAR_ME *PPPEER_PEOPLE_NEAR_ME;

#ifndef MIDL_PASS
/////////////////////////////////////////////////////////////////////////////
// APIs

HRESULT WINAPI PeerCollabStartup(
                __in  WORD      wVersionRequested);

HRESULT WINAPI PeerCollabShutdown();

HRESULT WINAPI PeerCollabSignin(
                __in_opt    HWND      hwndParent,
                __in        DWORD     dwSigninOptions);

HRESULT WINAPI PeerCollabSignout(
                __in  DWORD     dwSigninOptions);

HRESULT WINAPI PeerCollabGetSigninOptions(
                __out  DWORD    * pdwSigninOptions);

#endif //MIDL_PASS
/////////////////////////////////////////////////////////////////////////////
//
//  A P P I N V I T E
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// constants

typedef enum peer_invitation_response_type_tag {
    PEER_INVITATION_RESPONSE_DECLINED       = 0,
    PEER_INVITATION_RESPONSE_ACCEPTED       = 1,
    PEER_INVITATION_RESPONSE_EXPIRED        = 2,
    PEER_INVITATION_RESPONSE_ERROR          = 3
} PEER_INVITATION_RESPONSE_TYPE;

typedef enum peer_application_registration_type_tag {
    PEER_APPLICATION_CURRENT_USER   = 0,
    PEER_APPLICATION_ALL_USERS      = 1
} PEER_APPLICATION_REGISTRATION_TYPE;

/////////////////////////////////////////////////////////////////////////////
// Structures

typedef struct peer_invitation_tag {
    GUID                applicationId;
    PEER_DATA           applicationData;
    PWSTR               pwzMessage;
} PEER_INVITATION, * PPEER_INVITATION;
typedef const PEER_INVITATION   * PCPEER_INVITATION;

typedef struct peer_invitation_response_tag {
    PEER_INVITATION_RESPONSE_TYPE   action;
    PWSTR                           pwzMessage;
    HRESULT                         hrExtendedInfo;
} PEER_INVITATION_RESPONSE, * PPEER_INVITATION_RESPONSE;
typedef const PEER_INVITATION_RESPONSE * PCPEER_INVITATION_RESPONSE;

typedef struct peer_app_launch_info_tag {
    PPEER_CONTACT               pContact;
    PPEER_ENDPOINT              pEndpoint;
    PPEER_INVITATION            pInvitation;
} PEER_APP_LAUNCH_INFO, * PPEER_APP_LAUNCH_INFO;
typedef const PEER_APP_LAUNCH_INFO * PCPEER_APP_LAUNCH_INFO;

typedef struct peer_application_registration_info_tag {
    PEER_APPLICATION            application;
    PWSTR                       pwzApplicationToLaunch;
    PWSTR                       pwzApplicationArguments;
    DWORD                       dwPublicationScope;
} PEER_APPLICATION_REGISTRATION_INFO, *PPEER_APPLICATION_REGISTRATION_INFO;
typedef const PEER_APPLICATION_REGISTRATION_INFO * PCPEER_APPLICATION_REGISTRATION_INFO;

#ifndef MIDL_PASS
/////////////////////////////////////////////////////////////////////////////
// API's

// AppInvite sender side API's
HRESULT WINAPI PeerCollabAsyncInviteContact(
                    __in_opt PCPEER_CONTACT             pcContact,
                    __in  PCPEER_ENDPOINT               pcEndpoint,
                    __in  PCPEER_INVITATION             pcInvitation,
                    __in_opt  HANDLE                    hEvent,
                    __out_opt HANDLE                    * phInvitation);

HRESULT WINAPI PeerCollabGetInvitationResponse(
                    __in  HANDLE                            hInvitation,
                    __deref_out PPEER_INVITATION_RESPONSE   * ppInvitationResponse);

HRESULT WINAPI PeerCollabCancelInvitation(
                    __in  HANDLE        hInvitation);

HRESULT WINAPI PeerCollabCloseHandle(
                    __in  HANDLE        hInvitation);

HRESULT WINAPI  PeerCollabInviteContact(
                    __in_opt     PCPEER_CONTACT             pcContact,
                    __in  PCPEER_ENDPOINT                   pcEndpoint,
                    __in  PCPEER_INVITATION                 pcInvitation,
                    __deref_out PPEER_INVITATION_RESPONSE   * ppResponse);

HRESULT WINAPI PeerCollabAsyncInviteEndpoint(
                    __in  PCPEER_ENDPOINT               pcEndpoint,
                    __in  PCPEER_INVITATION             pcInvitation,
                    __in_opt  HANDLE                    hEvent,
                    __out_opt HANDLE                    * phInvitation);

HRESULT WINAPI PeerCollabInviteEndpoint(
                    __in  PCPEER_ENDPOINT                   pcEndpoint,
                    __in  PCPEER_INVITATION                 pcInvitation,
                    __deref_out PPEER_INVITATION_RESPONSE   * ppResponse);

// AppInvite receiver side API's
HRESULT WINAPI PeerCollabGetAppLaunchInfo(
                    __deref_out PPEER_APP_LAUNCH_INFO       * ppLaunchInfo);

// Applications registration API's
HRESULT WINAPI  PeerCollabRegisterApplication(
                    __in PCPEER_APPLICATION_REGISTRATION_INFO   pcApplication,
                    __in PEER_APPLICATION_REGISTRATION_TYPE     registrationType);

HRESULT WINAPI PeerCollabUnregisterApplication(
                    __in GUID                                   * pApplicationId,
                    __in PEER_APPLICATION_REGISTRATION_TYPE     registrationType);

HRESULT WINAPI PeerCollabGetApplicationRegistrationInfo(
                    __in GUID                                           * pApplicationId,
                    __in PEER_APPLICATION_REGISTRATION_TYPE             registrationType,
                    __deref_out PPEER_APPLICATION_REGISTRATION_INFO     * ppApplication);

HRESULT WINAPI PeerCollabEnumApplicationRegistrationInfo(
                    __in  PEER_APPLICATION_REGISTRATION_TYPE      registrationType,
                    __out HPEERENUM                               * phPeerEnum);
#endif // MIDL_PASS

/////////////////////////////////////////////////////////////////////////////
//
//  S E R V E R L E S S    P R E S E N C E
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// constants

typedef enum peer_presence_status_tag {
    PEER_PRESENCE_OFFLINE               = 0,
    PEER_PRESENCE_OUT_TO_LUNCH          = 1,
    PEER_PRESENCE_AWAY                  = 2,
    PEER_PRESENCE_BE_RIGHT_BACK         = 3,
    PEER_PRESENCE_IDLE                  = 4,
    PEER_PRESENCE_BUSY                  = 5,
    PEER_PRESENCE_ON_THE_PHONE          = 6,
    PEER_PRESENCE_ONLINE                = 7
} PEER_PRESENCE_STATUS;

/////////////////////////////////////////////////////////////////////////////
// Structures

typedef struct peer_presence_info_tag {
    PEER_PRESENCE_STATUS            status;
    PWSTR                           pwzDescriptiveText;
} PEER_PRESENCE_INFO, *PPEER_PRESENCE_INFO;
typedef const PEER_PRESENCE_INFO * PCPEER_PRESENCE_INFO;

#ifndef MIDL_PASS
//////////////////////////////////////////////////////////////////////////////
// API's

// Subscriber
HRESULT WINAPI PeerCollabGetPresenceInfo(
                __in_opt  PCPEER_ENDPOINT           pcEndpoint,
                __deref_out PPEER_PRESENCE_INFO     *ppPresenceInfo);

HRESULT WINAPI PeerCollabEnumApplications(
                __in_opt  PCPEER_ENDPOINT           pcEndpoint,
                __in_opt  GUID                      * pApplicationId,
                __out HPEERENUM                     * phPeerEnum);

HRESULT WINAPI PeerCollabEnumObjects(
                __in_opt PCPEER_ENDPOINT            pcEndpoint,
                __in_opt GUID                       * pObjectId,
                __out HPEERENUM                     * phPeerEnum);

HRESULT WINAPI PeerCollabEnumEndpoints(
                __in_opt    PCPEER_CONTACT          pcContact,
                __out HPEERENUM                     * phPeerEnum);

HRESULT WINAPI PeerCollabRefreshEndpointData(
                __in PCPEER_ENDPOINT                pcEndpoint);

HRESULT WINAPI PeerCollabDeleteEndpointData(
                __in PCPEER_ENDPOINT                pcEndpoint);

HRESULT WINAPI PeerCollabQueryContactData(
                __in_opt PCPEER_ENDPOINT            pcEndpoint,
                __deref_out PWSTR                   * ppwzContactData);

HRESULT WINAPI PeerCollabSubscribeEndpointData(
                __in const PCPEER_ENDPOINT        pcEndpoint);

HRESULT WINAPI PeerCollabUnsubscribeEndpointData(
                __in const PCPEER_ENDPOINT        pcEndpoint);

// Publisher

HRESULT WINAPI PeerCollabSetPresenceInfo(
                __in PCPEER_PRESENCE_INFO    pcPresenceInfo);

HRESULT WINAPI PeerCollabGetEndpointName(
                __deref_out PWSTR            * ppwzEndpointName);

HRESULT WINAPI PeerCollabSetEndpointName(
                __in PCWSTR                  pwzEndpointName);

HRESULT WINAPI PeerCollabSetObject(
                __in PCPEER_OBJECT           pcObject);

HRESULT WINAPI PeerCollabDeleteObject(
                __in GUID                    * pObjectId);

#endif

/////////////////////////////////////////////////////////////////////////////
//
//  R E G I S T R A T I O N
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// constants

typedef enum peer_change_type_tag {
    PEER_CHANGE_ADDED           = 0,
    PEER_CHANGE_DELETED         = 1,
    PEER_CHANGE_UPDATED         = 2
} PEER_CHANGE_TYPE;

typedef enum peer_collab_event_type_tag {
    PEER_EVENT_WATCHLIST_CHANGED                = 1,
    PEER_EVENT_ENDPOINT_CHANGED                 = 2,
    PEER_EVENT_ENDPOINT_PRESENCE_CHANGED        = 3,
    PEER_EVENT_ENDPOINT_APPLICATION_CHANGED     = 4,
    PEER_EVENT_ENDPOINT_OBJECT_CHANGED          = 5,
    PEER_EVENT_MY_ENDPOINT_CHANGED              = 6,
    PEER_EVENT_MY_PRESENCE_CHANGED              = 7,
    PEER_EVENT_MY_APPLICATION_CHANGED           = 8,
    PEER_EVENT_MY_OBJECT_CHANGED                = 9,
    PEER_EVENT_PEOPLE_NEAR_ME_CHANGED           = 10,
    PEER_EVENT_REQUEST_STATUS_CHANGED           = 11
} PEER_COLLAB_EVENT_TYPE;

/////////////////////////////////////////////////////////////////////////////
// Structures

typedef struct peer_collab_event_registration_tag {
    PEER_COLLAB_EVENT_TYPE     eventType;
    #ifdef MIDL_PASS
    [unique]
    #endif
    GUID                        * pInstance;
} PEER_COLLAB_EVENT_REGISTRATION, *PPEER_COLLAB_EVENT_REGISTRATION;

typedef struct peer_event_watchlist_changed_data_tag {
    PPEER_CONTACT           pContact;
    PEER_CHANGE_TYPE        changeType;
} PEER_EVENT_WATCHLIST_CHANGED_DATA, *PPEER_EVENT_WATCHLIST_CHANGED_DATA;

typedef struct peer_event_presence_changed_data_tag {
    PPEER_CONTACT           pContact;
    PPEER_ENDPOINT          pEndpoint;
    PEER_CHANGE_TYPE        changeType;
    PPEER_PRESENCE_INFO     pPresenceInfo;
} PEER_EVENT_PRESENCE_CHANGED_DATA, *PPEER_EVENT_PRESENCE_CHANGED_DATA;

typedef struct peer_event_application_changed_data_tag {
    PPEER_CONTACT           pContact;
    PPEER_ENDPOINT          pEndpoint;
    PEER_CHANGE_TYPE        changeType;
    PPEER_APPLICATION       pApplication;
} PEER_EVENT_APPLICATION_CHANGED_DATA, *PPEER_EVENT_APPLICATION_CHANGED_DATA;

typedef struct peer_event_object_changed_data_tag {
    PPEER_CONTACT           pContact;
    PPEER_ENDPOINT          pEndpoint;
    PEER_CHANGE_TYPE        changeType;
    PPEER_OBJECT            pObject;
} PEER_EVENT_OBJECT_CHANGED_DATA, *PPEER_EVENT_OBJECT_CHANGED_DATA;

typedef struct peer_event_endpoint_changed_data_tag {
    PPEER_CONTACT           pContact;
    PPEER_ENDPOINT          pEndpoint;
} PEER_EVENT_ENDPOINT_CHANGED_DATA, *PPEER_EVENT_ENDPOINT_CHANGED_DATA;

typedef struct peer_event_people_near_me_changed_data_tag {
    PEER_CHANGE_TYPE        changeType;
    PPEER_PEOPLE_NEAR_ME    pPeopleNearMe;
} PEER_EVENT_PEOPLE_NEAR_ME_CHANGED_DATA, *PPEER_EVENT_PEOPLE_NEAR_ME_CHANGED_DATA;

typedef struct peer_event_request_status_changed_data_tag {
    PPEER_ENDPOINT          pEndpoint;
    HRESULT                 hrChange;
} PEER_EVENT_REQUEST_STATUS_CHANGED_DATA, *PPEER_EVENT_REQUEST_STATUS_CHANGED_DATA;

#ifdef MIDL_PASS
    typedef struct peer_collab_event_data_tag {
        PEER_COLLAB_EVENT_TYPE                     eventType;
        [switch_is(eventType)]
        union {
            [case(PEER_EVENT_WATCHLIST_CHANGED)]
            PEER_EVENT_WATCHLIST_CHANGED_DATA               watchListChangedData;

            [case(PEER_EVENT_ENDPOINT_PRESENCE_CHANGED, PEER_EVENT_MY_PRESENCE_CHANGED)]
            PEER_EVENT_PRESENCE_CHANGED_DATA                presenceChangedData;

            [case(PEER_EVENT_ENDPOINT_APPLICATION_CHANGED, PEER_EVENT_MY_APPLICATION_CHANGED)]
            PEER_EVENT_APPLICATION_CHANGED_DATA              applicationChangedData;

            [case(PEER_EVENT_ENDPOINT_OBJECT_CHANGED, PEER_EVENT_MY_OBJECT_CHANGED)]
            PEER_EVENT_OBJECT_CHANGED_DATA                  objectChangedData;

            [case(PEER_EVENT_ENDPOINT_CHANGED, PEER_EVENT_MY_ENDPOINT_CHANGED)]
            PEER_EVENT_ENDPOINT_CHANGED_DATA                endpointChangedData;

            [case(PEER_EVENT_PEOPLE_NEAR_ME_CHANGED)]
            PEER_EVENT_PEOPLE_NEAR_ME_CHANGED_DATA          peopleNearMeChangedData;

            [case(PEER_EVENT_REQUEST_STATUS_CHANGED)]
            PEER_EVENT_REQUEST_STATUS_CHANGED_DATA          requestStatusChangedData;

            [default]
                ;
        };
    } PEER_COLLAB_EVENT_DATA, *PPEER_COLLAB_EVENT_DATA;
#else
    typedef struct peer_collab_event_data_tag {
        PEER_COLLAB_EVENT_TYPE                     eventType;
        union {
            PEER_EVENT_WATCHLIST_CHANGED_DATA                   watchListChangedData;
            PEER_EVENT_PRESENCE_CHANGED_DATA                    presenceChangedData;
            PEER_EVENT_APPLICATION_CHANGED_DATA                 applicationChangedData;
            PEER_EVENT_OBJECT_CHANGED_DATA                      objectChangedData;
            PEER_EVENT_ENDPOINT_CHANGED_DATA                    endpointChangedData;
            PEER_EVENT_PEOPLE_NEAR_ME_CHANGED_DATA              peopleNearMeChangedData;
            PEER_EVENT_REQUEST_STATUS_CHANGED_DATA              requestStatusChangedData;
        };
    } PEER_COLLAB_EVENT_DATA, *PPEER_COLLAB_EVENT_DATA;
#endif


#ifndef MIDL_PASS
/////////////////////////////////////////////////////////////////////////////
// API's

HRESULT WINAPI PeerCollabRegisterEvent(
                __in HANDLE                       hEvent,
                __in DWORD                        cEventRegistration,
                __in_ecount(cEventRegistration) PEER_COLLAB_EVENT_REGISTRATION * pEventRegistrations,
                __out HPEEREVENT                  *phPeerEvent);

HRESULT WINAPI PeerCollabGetEventData(
                __in  HPEEREVENT                        hPeerEvent,
                __deref_out PPEER_COLLAB_EVENT_DATA     * ppEventData);

HRESULT WINAPI PeerCollabUnregisterEvent(
                __in HPEEREVENT                         hPeerEvent);

//////////////////////////////////////////////////////////////////////////////
//
//  P N M
//
//////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// API's

HRESULT WINAPI PeerCollabEnumPeopleNearMe(
                __out HPEERENUM                 *phPeerEnum);

//////////////////////////////////////////////////////////////////////////////
//
//  C O N T A C T
//
//////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// API's

HRESULT WINAPI PeerCollabAddContact(
                __in           PCWSTR           pwzContactData,
                __deref_opt_out PPEER_CONTACT   * ppContact);

HRESULT WINAPI PeerCollabDeleteContact(
                __in           PCWSTR           pwzPeerName);

HRESULT WINAPI PeerCollabGetContact(
                __in_opt PCWSTR                 pwzPeerName,
                __deref_out PPEER_CONTACT       * ppContact);

HRESULT WINAPI PeerCollabUpdateContact(
                __in    PCPEER_CONTACT          pContact);

HRESULT WINAPI PeerCollabEnumContacts(
                __out HPEERENUM                 * phPeerEnum);

HRESULT WINAPI PeerCollabExportContact(
                __in_opt  PCWSTR                pwzPeerName,
                __deref_out PWSTR               * ppwzContactData);

HRESULT WINAPI PeerCollabParseContact(
                __in        PCWSTR              pwzContactData,
                __deref_out PPEER_CONTACT       * ppContact);

#endif // MIDL_PASS
#endif // NO_P2P_COLLABORATION


/////////////////////////////////////////////////////////////////////////////
//
//  PNRP APIs
//
/////////////////////////////////////////////////////////////////////////////

#ifndef   MIDL_PASS
#ifndef   NO_P2P_PNRP

#define PNRP_VERSION     MAKEWORD(2,0)

#define PEER_PNRP_ALL_LINK_CLOUDS   L"PEER_PNRP_ALL_LINKS"
#define PEER_PNRP_AUTO_ADDRESSES    ((ULONG)(-1))

/////////////////////////////////////////////////////////////////////////////
// Structures

typedef PVOID HRESOLUTION, HREGISTRATION;

typedef struct peer_pnrp_endpoint_info_tag
{
    PWSTR       pwzPeerName;
    ULONG       cAddresses;
    __field_ecount(cAddresses) SOCKADDR  **ppAddresses;
    PWSTR       pwzComment;
    PEER_DATA   payload;
} PEER_PNRP_ENDPOINT_INFO, *PPEER_PNRP_ENDPOINT_INFO;

typedef struct peer_pnrp_cloud_info_tag
{
    PWSTR       pwzCloudName;
    PNRP_SCOPE  dwScope;
    DWORD       dwScopeId;
} PEER_PNRP_CLOUD_INFO, *PPEER_PNRP_CLOUD_INFO;

typedef struct peer_pnrp_registration_info_tag {
    PWSTR           pwzCloudName;
    PWSTR           pwzPublishingIdentity;
    ULONG           cAddresses;
    __field_ecount(cAddresses) SOCKADDR        **ppAddresses;
    WORD            wPort;
    PWSTR           pwzComment;
    PEER_DATA       payload;
} PEER_PNRP_REGISTRATION_INFO, *PPEER_PNRP_REGISTRATION_INFO;

/////////////////////////////////////////////////////////////////////////////
// API's

HRESULT WINAPI PeerNameToPeerHostName(
                __in    PCWSTR      pwzPeerName,
                __deref_out PWSTR   *ppwzHostName);

HRESULT WINAPI PeerHostNameToPeerName(
                __in  PCWSTR        pwzHostName,
                __deref_out PWSTR   *ppwzPeerName);

HRESULT WINAPI PeerPnrpStartup(
                __in WORD           wVersionRequested);

HRESULT WINAPI PeerPnrpShutdown();

HRESULT WINAPI PeerPnrpRegister(
                  __in  PCWSTR                            pcwzPeerName,
                  __in_opt  PPEER_PNRP_REGISTRATION_INFO  pRegistrationInfo,
                  __out HREGISTRATION                    *phRegistration);

HRESULT WINAPI PeerPnrpUpdateRegistration(
                  __in HREGISTRATION                 hRegistration,
                  __in PPEER_PNRP_REGISTRATION_INFO  pRegistrationInfo);

HRESULT WINAPI PeerPnrpUnregister(
                __in HREGISTRATION   hRegistration);

HRESULT WINAPI PeerPnrpResolve(
                  __in PCWSTR                           pcwzPeerName,
                  __in_opt PCWSTR                       pcwzCloudName,
                  __inout ULONG                         *pcEndpoints,
                  __deref_out_ecount(*pcEndpoints) PPEER_PNRP_ENDPOINT_INFO  *ppEndpoints);

HRESULT WINAPI PeerPnrpStartResolve(
                  __in  PCWSTR          pcwzPeerName,
                  __in_opt  PCWSTR      pcwzCloudName,
                  __in_opt  ULONG       cMaxEndpoints,
                  __in  HANDLE          hEvent,
                  __out HRESOLUTION    *phResolve);

HRESULT WINAPI PeerPnrpGetCloudInfo(
                  __out ULONG                                               *pcNumClouds,
                  __deref_out_ecount(*pcNumClouds) PPEER_PNRP_CLOUD_INFO    *ppCloudInfo);

HRESULT WINAPI PeerPnrpGetEndpoint(
                  __in  HRESOLUTION                       hResolve,
                  __deref_out PPEER_PNRP_ENDPOINT_INFO   *ppEndpoint);

HRESULT WINAPI PeerPnrpEndResolve(
                  __in HRESOLUTION   hResolve);

#endif // NO_P2P_PNRP
#endif // MIDL_PASS

#ifdef __cplusplus
}
#endif /* __cplusplus */


/////////////////////////////////////////////////////////////////////////////
//
// Error codes
//
/////////////////////////////////////////////////////////////////////////////

#ifndef FACILITY_P2P
#define FACILITY_P2P  99
#endif

#define PEER_E_IPV6_NOT_INSTALLED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0001)
#define PEER_E_NOT_INITIALIZED               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0002)
#define PEER_E_CANNOT_START_SERVICE          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0003)
#define PEER_E_NOT_LICENSED                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0004)
#define PEER_E_INVALID_GRAPH                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0010)
#define PEER_E_DBNAME_CHANGED                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0011)
#define PEER_E_DUPLICATE_GRAPH               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0012)
#define PEER_E_GRAPH_NOT_READY               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0013)
#define PEER_E_GRAPH_SHUTTING_DOWN           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0014)
#define PEER_E_GRAPH_IN_USE                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0015)
#define PEER_E_INVALID_DATABASE              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0016)
#define PEER_E_TOO_MANY_ATTRIBUTES           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0017)

#define PEER_E_CONNECTION_NOT_FOUND          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0103)
#define PEER_E_CONNECT_SELF                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0106)
#define PEER_E_ALREADY_LISTENING             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0107)
#define PEER_E_NODE_NOT_FOUND                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0108)
#define PEER_E_CONNECTION_FAILED             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0109)
#define PEER_E_CONNECTION_NOT_AUTHENTICATED  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x010A)
#define PEER_E_CONNECTION_REFUSED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x010B)

#define PEER_E_CLASSIFIER_TOO_LONG           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0201)
#define PEER_E_TOO_MANY_IDENTITIES           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0202)
#define PEER_E_NO_KEY_ACCESS                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0203)
#define PEER_E_GROUPS_EXIST                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0204)

// record error codes
#define PEER_E_RECORD_NOT_FOUND              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0301)
#define PEER_E_DATABASE_ACCESSDENIED         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0302)
#define PEER_E_DBINITIALIZATION_FAILED       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0303)
#define PEER_E_MAX_RECORD_SIZE_EXCEEDED      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0304)
#define PEER_E_DATABASE_ALREADY_PRESENT      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0305)
#define PEER_E_DATABASE_NOT_PRESENT          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0306)

#define PEER_E_IDENTITY_NOT_FOUND            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0401)

// eventing error
#define PEER_E_EVENT_HANDLE_NOT_FOUND        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0501)

// searching error
#define PEER_E_INVALID_SEARCH                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0601)
#define PEER_E_INVALID_ATTRIBUTES            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0602)

// certificate verification error codes
#define PEER_E_INVITATION_NOT_TRUSTED        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0701)
#define PEER_E_CHAIN_TOO_LONG                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0703)
#define PEER_E_INVALID_TIME_PERIOD           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0705)
#define PEER_E_CIRCULAR_CHAIN_DETECTED       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0706)

#define PEER_E_CERT_STORE_CORRUPTED          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x0801)

#define PEER_E_NO_CLOUD                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x1001)
#define PEER_E_CLOUD_NAME_AMBIGUOUS          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x1005)

#define PEER_E_INVALID_RECORD                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x2010)
#define PEER_E_NOT_AUTHORIZED                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x2020)
#define PEER_E_PASSWORD_DOES_NOT_MEET_POLICY MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x2021)
#define PEER_E_DEFERRED_VALIDATION           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x2030)
#define PEER_E_INVALID_GROUP_PROPERTIES      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x2040)
#define PEER_E_INVALID_PEER_NAME             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x2050)
#define PEER_E_INVALID_CLASSIFIER            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x2060)
#define PEER_E_INVALID_FRIENDLY_NAME         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x2070)
#define PEER_E_INVALID_ROLE_PROPERTY         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x2071)
#define PEER_E_INVALID_CLASSIFIER_PROPERTY   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x2072)
#define PEER_E_INVALID_RECORD_EXPIRATION     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x2080)
#define PEER_E_INVALID_CREDENTIAL_INFO       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x2081)
#define PEER_E_INVALID_CREDENTIAL            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x2082)
#define PEER_E_INVALID_RECORD_SIZE           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x2083)
#define PEER_E_UNSUPPORTED_VERSION           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x2090)
#define PEER_E_GROUP_NOT_READY               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x2091)
#define PEER_E_GROUP_IN_USE                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x2092)
#define PEER_E_INVALID_GROUP                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x2093)
#define PEER_E_NO_MEMBERS_FOUND              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x2094)
#define PEER_E_NO_MEMBER_CONNECTIONS         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x2095)
#define PEER_E_UNABLE_TO_LISTEN              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x2096)
#define PEER_E_IDENTITY_DELETED              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x20A0)
#define PEER_E_SERVICE_NOT_AVAILABLE         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x20A1)

// Contacts APIs error code
#define PEER_E_CONTACT_NOT_FOUND             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x6001)

// Special success codes
#define PEER_S_GRAPH_DATA_CREATED            MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_P2P, 0x0001)
#define PEER_S_NO_EVENT_DATA                 MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_P2P, 0x0002)
#define PEER_S_ALREADY_CONNECTED             MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_P2P, 0x2000)
#define PEER_S_SUBSCRIPTION_EXISTS           MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_P2P, 0x6000)
#define PEER_S_NO_CONNECTIVITY               MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_P2P, 0x0005)
#define PEER_S_ALREADY_A_MEMBER              MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_P2P, 0x0006)

// Pnrp helpers errors
#define PEER_E_CANNOT_CONVERT_PEER_NAME      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x4001)
#define PEER_E_INVALID_PEER_HOST_NAME        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x4002)
#define PEER_E_NO_MORE                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x4003)
#define PEER_E_PNRP_DUPLICATE_PEER_NAME      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x4005)

// AppInvite APIs error code
#define PEER_E_INVITE_CANCELLED                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x7000)
#define PEER_E_INVITE_RESPONSE_NOT_AVAILABLE    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x7001)

// Serverless presence error codes
#define PEER_E_NOT_SIGNED_IN                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x7003)
#define PEER_E_PRIVACY_DECLINED                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x7004)
#define PEER_E_TIMEOUT                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0x7005)
#define PEER_E_INVALID_ADDRESS                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0X7007)
#define PEER_E_FW_EXCEPTION_DISABLED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0X7008)
#define PEER_E_FW_BLOCKED_BY_POLICY             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0X7009)
#define PEER_E_FW_BLOCKED_BY_SHIELDS_UP         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_P2P, 0X700A)

//
// WSA_PNRP_* error codes returned by the NSP
//

// These errors are only used by PNRP NSP and applications using the NSP.
// Any usage from other system/apps not related to PNRP (for example PNRP based getaddrinfo
// implementations) would require these errors be moved to winerror.h

#define WSA_PNRP_ERROR_BASE                  11500
#define WSA_PNRP_CLOUD_NOT_FOUND             (WSA_PNRP_ERROR_BASE +  1)
#define WSA_PNRP_CLOUD_DISABLED              (WSA_PNRP_ERROR_BASE +  2)
#define WSA_PNRP_INVALID_IDENTITY            (WSA_PNRP_ERROR_BASE +  3)
#define WSA_PNRP_TOO_MUCH_LOAD               (WSA_PNRP_ERROR_BASE +  4)
#define WSA_PNRP_CLOUD_IS_SEARCH_ONLY        (WSA_PNRP_ERROR_BASE +  5)
#define WSA_PNRP_CLIENT_INVALID_COMPARTMENT_ID (WSA_PNRP_ERROR_BASE +  6)
#define WSA_PNRP_DUPLICATE_PEER_NAME           (WSA_PNRP_ERROR_BASE +  8)

//
// these are the error codes that are not defined by winerror.h, so we define them as our own
//
#define PEER_E_NOT_FOUND                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_NOT_FOUND)
#define PEER_E_DISK_FULL                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_DISK_FULL)
#define PEER_E_ALREADY_EXISTS                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_ALREADY_EXISTS)

#endif  // _P2P_H_


/////////////////////////////////////////////////////////////////////////////
//
// These GUIDs are outside conditional includes so you can
//   #include <p2p.h>   in precompiled header
// then
//   #include <initguid.h>  in a single source file
//   #include <p2p.h>   in that source file a second time to instantiate the GUIDs

#ifdef DEFINE_GUID

#ifndef NO_P2P_GROUP

DEFINE_GUID(PEER_GROUP_ROLE_ADMIN, /* 04387127-aa56-450a-8ce5-4f565c6790f4 */
    0x04387127, 0xaa56, 0x450a, 0x8c, 0xe5, 0x4f, 0x56, 0x5c, 0x67, 0x90, 0xf4);

DEFINE_GUID(PEER_GROUP_ROLE_MEMBER, /* f12dc4c7-0857-4ca0-93fc-b1bb19a3d8c2 */
    0xf12dc4c7, 0x0857, 0x4ca0, 0x93, 0xfc, 0xb1, 0xbb, 0x19, 0xa3, 0xd8, 0xc2);

#if NTDDI_VERSION >= NTDDI_LONGHORN
DEFINE_GUID(PEER_GROUP_ROLE_INVITING_MEMBER, /* 4370fd89-dc18-4cfb-8dbf-9853a8a9f905 */
    0x4370fd89, 0xdc18, 0x4cfb, 0x8d, 0xbf, 0x98, 0x53, 0xa8, 0xa9, 0xf9, 0x05);
#endif

#endif // NO_P2P_GROUP

#ifndef NO_P2P_COLLABORATION
DEFINE_GUID(PEER_COLLAB_OBJECTID_USER_PICTURE, /* dd15f41f-fc4e-4922-b035-4c06a754d01d */
    0xdd15f41f, 0xfc4e, 0x4922, 0xb0, 0x35, 0x4c, 0x06, 0xa7, 0x54, 0xd0, 0x1d);
#endif

#endif // DEFINE_GUID
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\oleTx2xa.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for oletx2xa.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __oletx2xa_h__
#define __oletx2xa_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDtcToXaMapper_FWD_DEFINED__
#define __IDtcToXaMapper_FWD_DEFINED__
typedef interface IDtcToXaMapper IDtcToXaMapper;
#endif 	/* __IDtcToXaMapper_FWD_DEFINED__ */


#ifndef __IDtcToXaHelperFactory_FWD_DEFINED__
#define __IDtcToXaHelperFactory_FWD_DEFINED__
typedef interface IDtcToXaHelperFactory IDtcToXaHelperFactory;
#endif 	/* __IDtcToXaHelperFactory_FWD_DEFINED__ */


#ifndef __IDtcToXaHelper_FWD_DEFINED__
#define __IDtcToXaHelper_FWD_DEFINED__
typedef interface IDtcToXaHelper IDtcToXaHelper;
#endif 	/* __IDtcToXaHelper_FWD_DEFINED__ */


#ifndef __IDtcToXaHelperSinglePipe_FWD_DEFINED__
#define __IDtcToXaHelperSinglePipe_FWD_DEFINED__
typedef interface IDtcToXaHelperSinglePipe IDtcToXaHelperSinglePipe;
#endif 	/* __IDtcToXaHelperSinglePipe_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "transact.h"
#include "txcoord.h"
#include "xa.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_oletx2xa_0000_0000 */
/* [local] */ 

//-------------------------------------------------------------------------
//
//  Microsoft Distributed Transaction Coordinator
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
//  File: xamapper.h (generated from xamapper.idl)
//
//  Contents: Interfaces and types to map OleTx transaction
//            to XA transaction
//
//--------------------------------------------------------------------------






extern RPC_IF_HANDLE __MIDL_itf_oletx2xa_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oletx2xa_0000_0000_v0_0_s_ifspec;

#ifndef __XaMapperTypes_INTERFACE_DEFINED__
#define __XaMapperTypes_INTERFACE_DEFINED__

/* interface XaMapperTypes */
/* [unique][local] */ 

// Typedefs
typedef DWORD XA_SWITCH_FLAGS;

// Defines
#define XA_SWITCH_F_DTC      0x00000001
#define XA_FMTID_DTC         0x00445443
#define XA_FMTID_DTC_VER1    0x01445443
// Constants
const XID XID_NULL = {-1,0,0,'\0'};


extern RPC_IF_HANDLE XaMapperTypes_v0_0_c_ifspec;
extern RPC_IF_HANDLE XaMapperTypes_v0_0_s_ifspec;
#endif /* __XaMapperTypes_INTERFACE_DEFINED__ */

#ifndef __XaMapperAPIs_INTERFACE_DEFINED__
#define __XaMapperAPIs_INTERFACE_DEFINED__

/* interface XaMapperAPIs */
/* [unique][local] */ 

HRESULT __cdecl GetXaSwitch( 
    /* [in] */ XA_SWITCH_FLAGS XaSwitchFlags,
    /* [out] */ xa_switch_t **ppXaSwitch);



extern RPC_IF_HANDLE XaMapperAPIs_v0_0_c_ifspec;
extern RPC_IF_HANDLE XaMapperAPIs_v0_0_s_ifspec;
#endif /* __XaMapperAPIs_INTERFACE_DEFINED__ */

#ifndef __IDtcToXaMapper_INTERFACE_DEFINED__
#define __IDtcToXaMapper_INTERFACE_DEFINED__

/* interface IDtcToXaMapper */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDtcToXaMapper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("64FFABE0-7CE9-11d0-8CE6-00C04FDC877E")
    IDtcToXaMapper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RequestNewResourceManager( 
            /* [in] */ __RPC__in char *pszDSN,
            /* [in] */ __RPC__in char *pszClientDllName,
            /* [out][in] */ __RPC__inout DWORD *pdwRMCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateTridToXid( 
            /* [in] */ __RPC__in DWORD *pdwITransaction,
            /* [in] */ DWORD dwRMCookie,
            /* [out][in] */ __RPC__inout XID *pXid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnlistResourceManager( 
            /* [in] */ DWORD dwRMCookie,
            /* [in] */ __RPC__in DWORD *pdwITransaction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseResourceManager( 
            /* [in] */ DWORD dwRMCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcToXaMapperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcToXaMapper * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcToXaMapper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcToXaMapper * This);
        
        HRESULT ( STDMETHODCALLTYPE *RequestNewResourceManager )( 
            IDtcToXaMapper * This,
            /* [in] */ __RPC__in char *pszDSN,
            /* [in] */ __RPC__in char *pszClientDllName,
            /* [out][in] */ __RPC__inout DWORD *pdwRMCookie);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateTridToXid )( 
            IDtcToXaMapper * This,
            /* [in] */ __RPC__in DWORD *pdwITransaction,
            /* [in] */ DWORD dwRMCookie,
            /* [out][in] */ __RPC__inout XID *pXid);
        
        HRESULT ( STDMETHODCALLTYPE *EnlistResourceManager )( 
            IDtcToXaMapper * This,
            /* [in] */ DWORD dwRMCookie,
            /* [in] */ __RPC__in DWORD *pdwITransaction);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseResourceManager )( 
            IDtcToXaMapper * This,
            /* [in] */ DWORD dwRMCookie);
        
        END_INTERFACE
    } IDtcToXaMapperVtbl;

    interface IDtcToXaMapper
    {
        CONST_VTBL struct IDtcToXaMapperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcToXaMapper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcToXaMapper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcToXaMapper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcToXaMapper_RequestNewResourceManager(This,pszDSN,pszClientDllName,pdwRMCookie)	\
    ( (This)->lpVtbl -> RequestNewResourceManager(This,pszDSN,pszClientDllName,pdwRMCookie) ) 

#define IDtcToXaMapper_TranslateTridToXid(This,pdwITransaction,dwRMCookie,pXid)	\
    ( (This)->lpVtbl -> TranslateTridToXid(This,pdwITransaction,dwRMCookie,pXid) ) 

#define IDtcToXaMapper_EnlistResourceManager(This,dwRMCookie,pdwITransaction)	\
    ( (This)->lpVtbl -> EnlistResourceManager(This,dwRMCookie,pdwITransaction) ) 

#define IDtcToXaMapper_ReleaseResourceManager(This,dwRMCookie)	\
    ( (This)->lpVtbl -> ReleaseResourceManager(This,dwRMCookie) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcToXaMapper_INTERFACE_DEFINED__ */


#ifndef __IDtcToXaHelperFactory_INTERFACE_DEFINED__
#define __IDtcToXaHelperFactory_INTERFACE_DEFINED__

/* interface IDtcToXaHelperFactory */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDtcToXaHelperFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A9861610-304A-11d1-9813-00A0C905416E")
    IDtcToXaHelperFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ __RPC__in char *pszDSN,
            /* [in] */ __RPC__in char *pszClientDllName,
            /* [out] */ __RPC__out GUID *pguidRm,
            /* [out] */ __RPC__deref_out_opt IDtcToXaHelper **ppXaHelper) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcToXaHelperFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcToXaHelperFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcToXaHelperFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcToXaHelperFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            IDtcToXaHelperFactory * This,
            /* [in] */ __RPC__in char *pszDSN,
            /* [in] */ __RPC__in char *pszClientDllName,
            /* [out] */ __RPC__out GUID *pguidRm,
            /* [out] */ __RPC__deref_out_opt IDtcToXaHelper **ppXaHelper);
        
        END_INTERFACE
    } IDtcToXaHelperFactoryVtbl;

    interface IDtcToXaHelperFactory
    {
        CONST_VTBL struct IDtcToXaHelperFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcToXaHelperFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcToXaHelperFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcToXaHelperFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcToXaHelperFactory_Create(This,pszDSN,pszClientDllName,pguidRm,ppXaHelper)	\
    ( (This)->lpVtbl -> Create(This,pszDSN,pszClientDllName,pguidRm,ppXaHelper) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcToXaHelperFactory_INTERFACE_DEFINED__ */


#ifndef __IDtcToXaHelper_INTERFACE_DEFINED__
#define __IDtcToXaHelper_INTERFACE_DEFINED__

/* interface IDtcToXaHelper */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDtcToXaHelper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A9861611-304A-11d1-9813-00A0C905416E")
    IDtcToXaHelper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Close( 
            /* [in] */ BOOL i_fDoRecovery) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateTridToXid( 
            /* [in] */ __RPC__in_opt ITransaction *pITransaction,
            /* [in] */ __RPC__in GUID *pguidBqual,
            /* [out] */ __RPC__out XID *pXid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcToXaHelperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcToXaHelper * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcToXaHelper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcToXaHelper * This);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IDtcToXaHelper * This,
            /* [in] */ BOOL i_fDoRecovery);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateTridToXid )( 
            IDtcToXaHelper * This,
            /* [in] */ __RPC__in_opt ITransaction *pITransaction,
            /* [in] */ __RPC__in GUID *pguidBqual,
            /* [out] */ __RPC__out XID *pXid);
        
        END_INTERFACE
    } IDtcToXaHelperVtbl;

    interface IDtcToXaHelper
    {
        CONST_VTBL struct IDtcToXaHelperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcToXaHelper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcToXaHelper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcToXaHelper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcToXaHelper_Close(This,i_fDoRecovery)	\
    ( (This)->lpVtbl -> Close(This,i_fDoRecovery) ) 

#define IDtcToXaHelper_TranslateTridToXid(This,pITransaction,pguidBqual,pXid)	\
    ( (This)->lpVtbl -> TranslateTridToXid(This,pITransaction,pguidBqual,pXid) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcToXaHelper_INTERFACE_DEFINED__ */


#ifndef __IDtcToXaHelperSinglePipe_INTERFACE_DEFINED__
#define __IDtcToXaHelperSinglePipe_INTERFACE_DEFINED__

/* interface IDtcToXaHelperSinglePipe */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IDtcToXaHelperSinglePipe;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47ED4971-53B3-11d1-BBB9-00C04FD658F6")
    IDtcToXaHelperSinglePipe : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE XARMCreate( 
            /* [string][in] */ 
            __nullterminated  char *pszDSN,
            /* [string][in] */ 
            __nullterminated  char *pszClientDll,
            /* [out][in] */ DWORD *pdwRMCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertTridToXID( 
            /* [in] */ DWORD *pdwITrans,
            /* [in] */ DWORD dwRMCookie,
            /* [out][in] */ XID *pxid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnlistWithRM( 
            /* [in] */ DWORD dwRMCookie,
            /* [in] */ ITransaction *i_pITransaction,
            /* [in] */ ITransactionResourceAsync *i_pITransRes,
            /* [out] */ ITransactionEnlistmentAsync **o_ppITransEnslitment) = 0;
        
        virtual void STDMETHODCALLTYPE ReleaseRMCookie( 
            /* [in] */ DWORD i_dwRMCookie,
            /* [in] */ BOOL i_fNormal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcToXaHelperSinglePipeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcToXaHelperSinglePipe * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcToXaHelperSinglePipe * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcToXaHelperSinglePipe * This);
        
        HRESULT ( STDMETHODCALLTYPE *XARMCreate )( 
            IDtcToXaHelperSinglePipe * This,
            /* [string][in] */ 
            __nullterminated  char *pszDSN,
            /* [string][in] */ 
            __nullterminated  char *pszClientDll,
            /* [out][in] */ DWORD *pdwRMCookie);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertTridToXID )( 
            IDtcToXaHelperSinglePipe * This,
            /* [in] */ DWORD *pdwITrans,
            /* [in] */ DWORD dwRMCookie,
            /* [out][in] */ XID *pxid);
        
        HRESULT ( STDMETHODCALLTYPE *EnlistWithRM )( 
            IDtcToXaHelperSinglePipe * This,
            /* [in] */ DWORD dwRMCookie,
            /* [in] */ ITransaction *i_pITransaction,
            /* [in] */ ITransactionResourceAsync *i_pITransRes,
            /* [out] */ ITransactionEnlistmentAsync **o_ppITransEnslitment);
        
        void ( STDMETHODCALLTYPE *ReleaseRMCookie )( 
            IDtcToXaHelperSinglePipe * This,
            /* [in] */ DWORD i_dwRMCookie,
            /* [in] */ BOOL i_fNormal);
        
        END_INTERFACE
    } IDtcToXaHelperSinglePipeVtbl;

    interface IDtcToXaHelperSinglePipe
    {
        CONST_VTBL struct IDtcToXaHelperSinglePipeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcToXaHelperSinglePipe_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcToXaHelperSinglePipe_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcToXaHelperSinglePipe_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcToXaHelperSinglePipe_XARMCreate(This,pszDSN,pszClientDll,pdwRMCookie)	\
    ( (This)->lpVtbl -> XARMCreate(This,pszDSN,pszClientDll,pdwRMCookie) ) 

#define IDtcToXaHelperSinglePipe_ConvertTridToXID(This,pdwITrans,dwRMCookie,pxid)	\
    ( (This)->lpVtbl -> ConvertTridToXID(This,pdwITrans,dwRMCookie,pxid) ) 

#define IDtcToXaHelperSinglePipe_EnlistWithRM(This,dwRMCookie,i_pITransaction,i_pITransRes,o_ppITransEnslitment)	\
    ( (This)->lpVtbl -> EnlistWithRM(This,dwRMCookie,i_pITransaction,i_pITransRes,o_ppITransEnslitment) ) 

#define IDtcToXaHelperSinglePipe_ReleaseRMCookie(This,i_dwRMCookie,i_fNormal)	\
    ( (This)->lpVtbl -> ReleaseRMCookie(This,i_dwRMCookie,i_fNormal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcToXaHelperSinglePipe_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_oletx2xa_0000_0006 */
/* [local] */ 



#if _MSC_VER < 1100 || !defined(__cplusplus)

DEFINE_GUID(IID_IDtcToXaMapper, 0x64FFABE0, 0x7CE9, 0x11d0, 0x8C, 0xE6, 0x00, 0xC0, 0x4F, 0xDC, 0x87, 0x7E);
DEFINE_GUID(IID_IDtcToXaHelperFactory, 0xadefc46a, 0xcb1d, 0x11d0, 0xb1, 0x35, 0x00, 0xc0, 0x4f, 0xc2, 0xf3, 0xef);
DEFINE_GUID(IID_IDtcToXaHelper, 0xadefc46b, 0xcb1d, 0x11d0, 0xb1, 0x35, 0x00, 0xc0, 0x4f, 0xc2, 0xf3, 0xef);
DEFINE_GUID(IID_IDtcToXaHelperSinglePipe,        0x47ED4971, 0x53B3, 0x11d1, 0xBB, 0xB9, 0x00, 0xC0, 0x4F, 0xD6, 0x58, 0xF6);

#else

#define  IID_IDtcToXaMapper                          __uuidof(IDtcToXaMapper)
#define  IID_IDtcToXaHelperFactory                   __uuidof(IDtcToXaHelperFactory)
#define  IID_IDtcToXaHelper                          __uuidof(IDtcToXaHelper)
#define  IID_IDtcToXaHelperSinglePipe                __uuidof(IDtcToXaHelperSinglePipe)

#endif


extern RPC_IF_HANDLE __MIDL_itf_oletx2xa_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oletx2xa_0000_0006_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\Pcrt32.h ===
/*
 * porting macros for c runtimes - use these to let 16 bit crt calls work
 * properly on 32 bit code.
 */

#if _MSC_VER > 1000
#pragma once
#endif

#define _ffree free
#define _fmalloc malloc
#define _fmemccpy memccpy
#define _fmemchr memchr
#define _fmemcmp memcmp
#define _fmemcpy memcpy
#define _fmemicmp _memicmp
#define _fmemmove memmove
#define _fmemset memset
#define _frealloc realloc
#define _fstrcat strcat
#define _fstrchr strchr
#define _fstrcmp strcmp
#define _fstrcpy strcpy
#define _fstrcspn strcspn
#define _fstrdup _strdup
#define _fstricmp _stricmp
#define _fstrlen strlen
#define _fstrlwr _strlwr
#define _fstrncat strncat
#define _fstrncmp strncmp
#define _fstrncpy strncpy
#define _fstrnicmp _strnicmp
#define _fstrnset strnset
#define _fstrpbrk strpbrk
#define _fstrrchr strrchr
#define _fstrrev strrev
#define _fstrset strset
#define _fstrspn strspn
#define _fstrstr strstr
#define _fstrtok strtok
#define _fstrupr _strupr
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\PatchWiz.h ===
//----------------------------------------------------------------------------------------
//
//  Microsoft Windows - Windows Installer (MSI)
//
//  Copyright (C) Microsoft Corporation. All rights reserved.
//
//  PatchWiz
//
//  file: patchwiz.h
//----------------------------------------------------------------------------------------
#ifndef __PATCHWIZ_H__
#define __PATCHWIZ_H__

#include <windows.h>
#include <ole2.h>
#include <strsafe.h>
#include <stdio.h>
#include <stdlib.h>
//#include <_assert.h>

#define  Assert(x)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function:  UiCreatePatchPackage
//
// Synopsis:    Main entry point to PatchWiz.  This method is used for backwards compatibility with the previous 
//				version of PatchWiz.  Its purpose is to create a valid patch.  This method calls the updated version
//				of UiCreatePatchPackageEx.
//
// Arguments: 
//			[in]	szPcpPath - full absolute path to Windows Installer database
//					(PCP file) that contains appropriate tables of input-data for
//					Patch creation process such as Properties and TargetImages.
//			[in]	szPatchPath - optional, full absolute path to Patching Package
//					file (MSP file) to create and stuff with output.  If this
//					NULL or an empty string, the api will try to use
//					Properties.Value where Properties.Name = PatchOutputPath
//					from the PCP file.
//			[in]	szLogPath - path to store the log file.
//			[in]	hwndStatus - optional, handle to a window that displays text.
//			[in]	szTempFolder - optional location to use for temp files.
//					Default is %TEMP%\~pcw_tmp.tmp\, if specified, directory must exist.
//			[in]	fRemoveTempFolderIfPresent - remove temp folder (and all its
//					contents) if present.  If FALSE and folder is present, api
//					will fail.
// Returns:   
//			See UiCreatePatchPackageEx below.
//
// Notes:   Used for backwards compatibility.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function:  UiCreatePatchPackageEx
//
// Synopsis:    Updated main entry point to PatchWiz.  This method provides a few new parameter requirements as
//				listed below.  This method calls each of the five phases in order to create a valid patch as output.
//
// Arguments: 
//			[in]	szPcpPath - full absolute path to Windows Installer database
//					(PCP file) that contains appropriate tables of input-data for
//					Patch creation process such as Properties and TargetImages.
//			[in]	szPatchPath - optional, full absolute path to Patching Package
//					file (MSP file) to create and stuff with output.  If this
//					NULL or an empty string, the api will try to use
//					Properties.Value where Properties.Name = PatchOutputPath
//					from the PCP file.
//			[in]	szLogPath - path to store the log file.
//			[in]	hwndStatus - optional, handle to a window that displays text.
//			[in]	szTempFolder - optional location to use for temp files.
//					Default is %TEMP%\~pcw_tmp.tmp\, if specified, directory must exist.
//			[in]	fRemoveTempFolderIfPresent - remove temp folder (and all its
//					contents) if present.  If FALSE and folder is present, api
//					will fail.
//			*NEW PARAMETERS*
//			[in]	uiLogLevel - Determines what entries are written to the log file.
//							- 0x00000000 - No logging.
//							- 0x00000001 - INFO
//							- 0x00000002 - WARNING
//							- 0x00000004 - ERROR
//			[in]	UILevel - If 0, no UI is shown, else if set to 1 then UI can occur.
//			[in]	szSummaryOutputPath - optional, path to store any summary output of the patch
//					functionality and description.  If null, no output is written.
//
// Returns:   
//			ERROR_SUCCESS, plus ERROR_PCW_* that are listed in constants.h.
//
// Notes:     
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef _cplusplus
extern "C" {
#endif

UINT WINAPI UiCreatePatchPackageA(LPCSTR szPcpPath, LPCSTR szPatchPath, LPCSTR szLogPath, HWND hwndStatus, LPCSTR szTempFolder, BOOL fRemoveTempFolderIfPresent);
UINT WINAPI UiCreatePatchPackageW(LPCWSTR szPcpPath, LPCWSTR szPatchPath, LPCWSTR szLogPath, HWND hwndStatus, LPCWSTR szTempFolder, BOOL fRemoveTempFolderIfPresent);

#ifdef UNICODE
#define UiCreatePatchPackage UiCreatePatchPackageW
#else  // !UNICODE
#define UiCreatePatchPackage UiCreatePatchPackageA
#endif // UNICODE

UINT WINAPI UiCreatePatchPackageExA(LPCSTR szPcpPath, LPCSTR szPatchPath, LPCSTR szLogPath, HWND hwndStatus, LPCSTR szTempFolder, BOOL fRemoveTempFolderIfPresent, IN DWORD dwFlags, IN DWORD dwReserved);
UINT WINAPI UiCreatePatchPackageExW(LPCWSTR szPcpPath, LPCWSTR szPatchPath, LPCWSTR szLogPath, HWND hwndStatus, LPCWSTR szTempFolder, BOOL fRemoveTempFolderIfPresent, IN DWORD dwFlags, IN DWORD dwReserved);

#ifdef UNICODE
#define UiCreatePatchPackageEx UiCreatePatchPackageExW
#else  // !UNICODE
#define UiCreatePatchPackageEx UiCreatePatchPackageExA
#endif // UNICODE

#ifdef _cplusplus
}
#endif

const int cchMaxInteger    = 12;
const UINT LOGNONE = 0x00000000; // No logging
const UINT LOGINFO = 0x00000001; // Log INFO: entries
const UINT LOGWARN = 0x00000002; // Log WARNING: entries
const UINT LOGERR = 0x00000004;// Log ERROR: entries
const UINT LOGPERFMESSAGES = 0x00000008;
const UINT LOGALL = LOGINFO | LOGWARN | LOGERR | LOGPERFMESSAGES;
const UINT UINONE = 0x00000000; // Show NO user interface
const UINT UILOGBITS = 15;
const UINT UIALL = 1 << UILOGBITS; // Show ALL user interface
const UINT DEFAULT_MINIMUM_REQUIRED_MSI_VERSION = 100;
const UINT DEFAULT_FILE_SEQUENCE_START = 2; // Default sequence start for adding files to cab.
const UINT DEFAULT_DISK_ID = 2; // Default disk id to use

// Return values
#define ERROR_PCW_BASE                                 0xC00E5101

#define ERROR_PCW_PCP_DOESNT_EXIST                    (ERROR_PCW_BASE + 0x00)
#define ERROR_PCW_PCP_BAD_FORMAT                      (ERROR_PCW_BASE + 0x01)
#define ERROR_PCW_CANT_CREATE_TEMP_FOLDER             (ERROR_PCW_BASE + 0x02)
#define ERROR_PCW_MISSING_PATCH_PATH                  (ERROR_PCW_BASE + 0x03)
#define ERROR_PCW_CANT_OVERWRITE_PATCH                (ERROR_PCW_BASE + 0x04)
#define ERROR_PCW_CANT_CREATE_PATCH_FILE              (ERROR_PCW_BASE + 0x05)
#define ERROR_PCW_MISSING_PATCH_GUID                  (ERROR_PCW_BASE + 0x06)
#define ERROR_PCW_BAD_PATCH_GUID                      (ERROR_PCW_BASE + 0x07)
#define ERROR_PCW_BAD_GUIDS_TO_REPLACE                (ERROR_PCW_BASE + 0x08)
#define ERROR_PCW_BAD_TARGET_PRODUCT_CODE_LIST        (ERROR_PCW_BASE + 0x09)
#define ERROR_PCW_NO_UPGRADED_IMAGES_TO_PATCH         (ERROR_PCW_BASE + 0x0a)
//#define ERROR_PCW_BAD_API_PATCHING_OPTION_FLAGS       (ERROR_PCW_BASE + 0x0b) -- obsolete
#define ERROR_PCW_BAD_API_PATCHING_SYMBOL_FLAGS       (ERROR_PCW_BASE + 0x0c)
#define ERROR_PCW_OODS_COPYING_MSI                    (ERROR_PCW_BASE + 0x0d)
#define ERROR_PCW_UPGRADED_IMAGE_NAME_TOO_LONG        (ERROR_PCW_BASE + 0x0e)
#define ERROR_PCW_BAD_UPGRADED_IMAGE_NAME             (ERROR_PCW_BASE + 0x0f)

#define ERROR_PCW_DUP_UPGRADED_IMAGE_NAME             (ERROR_PCW_BASE + 0x10)
#define ERROR_PCW_UPGRADED_IMAGE_PATH_TOO_LONG        (ERROR_PCW_BASE + 0x11)
#define ERROR_PCW_UPGRADED_IMAGE_PATH_EMPTY           (ERROR_PCW_BASE + 0x12)
#define ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_EXIST       (ERROR_PCW_BASE + 0x13)
#define ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_MSI         (ERROR_PCW_BASE + 0x14)
#define ERROR_PCW_UPGRADED_IMAGE_COMPRESSED           (ERROR_PCW_BASE + 0x15)
#define ERROR_PCW_TARGET_IMAGE_NAME_TOO_LONG          (ERROR_PCW_BASE + 0x16)
#define ERROR_PCW_BAD_TARGET_IMAGE_NAME               (ERROR_PCW_BASE + 0x17)
#define ERROR_PCW_DUP_TARGET_IMAGE_NAME               (ERROR_PCW_BASE + 0x18)
#define ERROR_PCW_TARGET_IMAGE_PATH_TOO_LONG          (ERROR_PCW_BASE + 0x19)
#define ERROR_PCW_TARGET_IMAGE_PATH_EMPTY             (ERROR_PCW_BASE + 0x1a)
#define ERROR_PCW_TARGET_IMAGE_PATH_NOT_EXIST         (ERROR_PCW_BASE + 0x1b)
#define ERROR_PCW_TARGET_IMAGE_PATH_NOT_MSI           (ERROR_PCW_BASE + 0x1c)
#define ERROR_PCW_TARGET_IMAGE_COMPRESSED             (ERROR_PCW_BASE + 0x1d)
#define ERROR_PCW_TARGET_BAD_PROD_VALIDATE            (ERROR_PCW_BASE + 0x1e)
#define ERROR_PCW_TARGET_BAD_PROD_CODE_VAL            (ERROR_PCW_BASE + 0x1f)

#define ERROR_PCW_UPGRADED_MISSING_SRC_FILES          (ERROR_PCW_BASE + 0x20)
#define ERROR_PCW_TARGET_MISSING_SRC_FILES            (ERROR_PCW_BASE + 0x21)
#define ERROR_PCW_IMAGE_FAMILY_NAME_TOO_LONG          (ERROR_PCW_BASE + 0x22)
#define ERROR_PCW_BAD_IMAGE_FAMILY_NAME               (ERROR_PCW_BASE + 0x23)
#define ERROR_PCW_DUP_IMAGE_FAMILY_NAME               (ERROR_PCW_BASE + 0x24)
#define ERROR_PCW_BAD_IMAGE_FAMILY_SRC_PROP           (ERROR_PCW_BASE + 0x25)
#define ERROR_PCW_UFILEDATA_LONG_FILE_TABLE_KEY       (ERROR_PCW_BASE + 0x26)
#define ERROR_PCW_UFILEDATA_BLANK_FILE_TABLE_KEY      (ERROR_PCW_BASE + 0x27)
#define ERROR_PCW_UFILEDATA_MISSING_FILE_TABLE_KEY    (ERROR_PCW_BASE + 0x28)
#define ERROR_PCW_EXTFILE_LONG_FILE_TABLE_KEY         (ERROR_PCW_BASE + 0x29)
#define ERROR_PCW_EXTFILE_BLANK_FILE_TABLE_KEY        (ERROR_PCW_BASE + 0x2a)
#define ERROR_PCW_EXTFILE_BAD_FAMILY_FIELD            (ERROR_PCW_BASE + 0x2b)
#define ERROR_PCW_EXTFILE_LONG_PATH_TO_FILE           (ERROR_PCW_BASE + 0x2c)
#define ERROR_PCW_EXTFILE_BLANK_PATH_TO_FILE          (ERROR_PCW_BASE + 0x2d)
#define ERROR_PCW_EXTFILE_MISSING_FILE                (ERROR_PCW_BASE + 0x2e)
//#define ERROR_PCW_FILERANGE_LONG_FILE_TABLE_KEY       (ERROR_PCW_BASE + 0x2f) -- obsolete

//#define ERROR_PCW_FILERANGE_BLANK_FILE_TABLE_KEY      (ERROR_PCW_BASE + 0x30) -- obsolete
//#define ERROR_PCW_FILERANGE_MISSING_FILE_TABLE_KEY    (ERROR_PCW_BASE + 0x31) -- obsolete
//#define ERROR_PCW_FILERANGE_LONG_PATH_TO_FILE         (ERROR_PCW_BASE + 0x32) -- obsolete
//#define ERROR_PCW_FILERANGE_MISSING_FILE              (ERROR_PCW_BASE + 0x33) -- obsolete
//#define ERROR_PCW_FILERANGE_INVALID_OFFSET            (ERROR_PCW_BASE + 0x34) -- obsolete
//#define ERROR_PCW_FILERANGE_INVALID_SIZE              (ERROR_PCW_BASE + 0x35) -- obsolete
//#define ERROR_PCW_FILERANGE_INVALID_RETAIN            (ERROR_PCW_BASE + 0x36) -- obsolete
//#define ERROR_PCW_BAD_MEDIA_SRC_PROP_NAME             (ERROR_PCW_BASE + 0x37) -- obsolete
//#define ERROR_PCW_BAD_MEDIA_DISK_ID                   (ERROR_PCW_BASE + 0x38) -- obsolete
#define ERROR_PCW_BAD_FILE_SEQUENCE_START             (ERROR_PCW_BASE + 0x39)
#define ERROR_PCW_CANT_COPY_FILE_TO_TEMP_FOLDER       (ERROR_PCW_BASE + 0x3a)
#define ERROR_PCW_CANT_CREATE_ONE_PATCH_FILE          (ERROR_PCW_BASE + 0x3b)
#define ERROR_PCW_BAD_IMAGE_FAMILY_DISKID             (ERROR_PCW_BASE + 0x3c)
#define ERROR_PCW_BAD_IMAGE_FAMILY_FILESEQSTART       (ERROR_PCW_BASE + 0x3d)
#define ERROR_PCW_BAD_UPGRADED_IMAGE_FAMILY           (ERROR_PCW_BASE + 0x3e)
#define ERROR_PCW_BAD_TARGET_IMAGE_UPGRADED           (ERROR_PCW_BASE + 0x3f)

#define ERROR_PCW_DUP_TARGET_IMAGE_PACKCODE           (ERROR_PCW_BASE + 0x40)
#define ERROR_PCW_UFILEDATA_BAD_UPGRADED_FIELD        (ERROR_PCW_BASE + 0x41)
#define ERROR_PCW_MISMATCHED_PRODUCT_CODES            (ERROR_PCW_BASE + 0x42)
#define ERROR_PCW_MISMATCHED_PRODUCT_VERSIONS         (ERROR_PCW_BASE + 0x43)
#define ERROR_PCW_CANNOT_WRITE_DDF                    (ERROR_PCW_BASE + 0x44)
#define ERROR_PCW_CANNOT_RUN_MAKECAB                  (ERROR_PCW_BASE + 0x45)
//#define ERROR_PCW_CANNOT_CREATE_STORAGE               (ERROR_PCW_BASE + 0x46) -- obsolete
//#define ERROR_PCW_CANNOT_CREATE_STREAM                (ERROR_PCW_BASE + 0x47) -- obsolete
//#define ERROR_PCW_CANNOT_WRITE_STREAM                 (ERROR_PCW_BASE + 0x48) -- obsolete
//#define ERROR_PCW_CANNOT_READ_CABINET                 (ERROR_PCW_BASE + 0x49) -- obsolete
#define ERROR_PCW_WRITE_SUMMARY_PROPERTIES            (ERROR_PCW_BASE + 0x4a)
#define ERROR_PCW_TFILEDATA_LONG_FILE_TABLE_KEY       (ERROR_PCW_BASE + 0x4b)
#define ERROR_PCW_TFILEDATA_BLANK_FILE_TABLE_KEY      (ERROR_PCW_BASE + 0x4c)
#define ERROR_PCW_TFILEDATA_MISSING_FILE_TABLE_KEY    (ERROR_PCW_BASE + 0x4d)
#define ERROR_PCW_TFILEDATA_BAD_TARGET_FIELD          (ERROR_PCW_BASE + 0x4e)
#define ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_TOO_LONG  (ERROR_PCW_BASE + 0x4f)

#define ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_NOT_EXIST (ERROR_PCW_BASE + 0x50)
#define ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_NOT_MSI   (ERROR_PCW_BASE + 0x51)
#define ERROR_PCW_DUP_UPGRADED_IMAGE_PACKCODE         (ERROR_PCW_BASE + 0x52)
#define ERROR_PCW_UFILEIGNORE_BAD_UPGRADED_FIELD      (ERROR_PCW_BASE + 0x53)
#define ERROR_PCW_UFILEIGNORE_LONG_FILE_TABLE_KEY     (ERROR_PCW_BASE + 0x54)
#define ERROR_PCW_UFILEIGNORE_BLANK_FILE_TABLE_KEY    (ERROR_PCW_BASE + 0x55)
#define ERROR_PCW_UFILEIGNORE_BAD_FILE_TABLE_KEY      (ERROR_PCW_BASE + 0x56)
#define ERROR_PCW_FAMILY_RANGE_NAME_TOO_LONG          (ERROR_PCW_BASE + 0x57)
#define ERROR_PCW_BAD_FAMILY_RANGE_NAME               (ERROR_PCW_BASE + 0x58)
#define ERROR_PCW_FAMILY_RANGE_LONG_FILE_TABLE_KEY    (ERROR_PCW_BASE + 0x59)
#define ERROR_PCW_FAMILY_RANGE_BLANK_FILE_TABLE_KEY   (ERROR_PCW_BASE + 0x5a)
#define ERROR_PCW_FAMILY_RANGE_LONG_RETAIN_OFFSETS    (ERROR_PCW_BASE + 0x5b)
#define ERROR_PCW_FAMILY_RANGE_BLANK_RETAIN_OFFSETS   (ERROR_PCW_BASE + 0x5c)
#define ERROR_PCW_FAMILY_RANGE_BAD_RETAIN_OFFSETS     (ERROR_PCW_BASE + 0x5d)
#define ERROR_PCW_FAMILY_RANGE_LONG_RETAIN_LENGTHS    (ERROR_PCW_BASE + 0x5e)
#define ERROR_PCW_FAMILY_RANGE_BLANK_RETAIN_LENGTHS   (ERROR_PCW_BASE + 0x5f)

#define ERROR_PCW_FAMILY_RANGE_BAD_RETAIN_LENGTHS     (ERROR_PCW_BASE + 0x60)
#define ERROR_PCW_FAMILY_RANGE_COUNT_MISMATCH         (ERROR_PCW_BASE + 0x61)
#define ERROR_PCW_EXTFILE_LONG_IGNORE_OFFSETS         (ERROR_PCW_BASE + 0x62)
#define ERROR_PCW_EXTFILE_BAD_IGNORE_OFFSETS          (ERROR_PCW_BASE + 0x63)
#define ERROR_PCW_EXTFILE_LONG_IGNORE_LENGTHS         (ERROR_PCW_BASE + 0x64)
#define ERROR_PCW_EXTFILE_BAD_IGNORE_LENGTHS          (ERROR_PCW_BASE + 0x65)
#define ERROR_PCW_EXTFILE_IGNORE_COUNT_MISMATCH       (ERROR_PCW_BASE + 0x66)
#define ERROR_PCW_EXTFILE_LONG_RETAIN_OFFSETS         (ERROR_PCW_BASE + 0x67)
#define ERROR_PCW_EXTFILE_BAD_RETAIN_OFFSETS          (ERROR_PCW_BASE + 0x68)
//#define ERROR_PCW_EXTFILE_RETAIN_COUNT_MISMATCH       (ERROR_PCW_BASE + 0x69) -- obsolete
#define ERROR_PCW_TFILEDATA_LONG_IGNORE_OFFSETS       (ERROR_PCW_BASE + 0x6a)
#define ERROR_PCW_TFILEDATA_BAD_IGNORE_OFFSETS        (ERROR_PCW_BASE + 0x6b)
#define ERROR_PCW_TFILEDATA_LONG_IGNORE_LENGTHS       (ERROR_PCW_BASE + 0x6c)
#define ERROR_PCW_TFILEDATA_BAD_IGNORE_LENGTHS        (ERROR_PCW_BASE + 0x6d)
#define ERROR_PCW_TFILEDATA_IGNORE_COUNT_MISMATCH     (ERROR_PCW_BASE + 0x6e)
#define ERROR_PCW_TFILEDATA_LONG_RETAIN_OFFSETS       (ERROR_PCW_BASE + 0x6f)

#define ERROR_PCW_TFILEDATA_BAD_RETAIN_OFFSETS        (ERROR_PCW_BASE + 0x70)
//#define ERROR_PCW_TFILEDATA_RETAIN_COUNT_MISMATCH     (ERROR_PCW_BASE + 0x71) -- obsolete
#define ERROR_PCW_CANT_GENERATE_TRANSFORM             (ERROR_PCW_BASE + 0x72)
#define ERROR_PCW_CANT_CREATE_SUMMARY_INFO            (ERROR_PCW_BASE + 0x73)
#define ERROR_PCW_CANT_GENERATE_TRANSFORM_POUND       (ERROR_PCW_BASE + 0x74)
#define ERROR_PCW_CANT_CREATE_SUMMARY_INFO_POUND      (ERROR_PCW_BASE + 0x75)
#define ERROR_PCW_BAD_UPGRADED_IMAGE_PRODUCT_CODE     (ERROR_PCW_BASE + 0x76)
#define ERROR_PCW_BAD_UPGRADED_IMAGE_PRODUCT_VERSION  (ERROR_PCW_BASE + 0x77)
#define ERROR_PCW_BAD_UPGRADED_IMAGE_UPGRADE_CODE     (ERROR_PCW_BASE + 0x78)
#define ERROR_PCW_BAD_TARGET_IMAGE_PRODUCT_CODE       (ERROR_PCW_BASE + 0x79)
#define ERROR_PCW_BAD_TARGET_IMAGE_PRODUCT_VERSION    (ERROR_PCW_BASE + 0x7a)
#define ERROR_PCW_BAD_TARGET_IMAGE_UPGRADE_CODE       (ERROR_PCW_BASE + 0x7b)
#define ERROR_PCW_MATCHED_PRODUCT_VERSIONS            (ERROR_PCW_BASE + 0x7c)
#define ERROR_PCW_OBSOLETION_WITH_SEQUENCE_DATA       (ERROR_PCW_BASE + 0x7d)
#define ERROR_PCW_OBSOLETION_WITH_MSI30               (ERROR_PCW_BASE + 0x7e)
#define ERROR_PCW_OBSOLETION_WITH_PATCHSEQUENCE       (ERROR_PCW_BASE + 0x7f)
#define ERROR_PCW_CANNOT_CREATE_TABLE                 (ERROR_PCW_BASE + 0x80)
#define ERROR_PCW_CANT_GENERATE_SEQUENCEINFO_MAJORUPGD (ERROR_PCW_BASE + 0x81)
#define ERROR_PCW_MAJOR_UPGD_WITHOUT_SEQUENCING       (ERROR_PCW_BASE + 0x82)
#define ERROR_PCW_BAD_PRODUCTVERSION_VALIDATION       (ERROR_PCW_BASE + 0x83)
#define ERROR_PCW_BAD_TRANSFORMSET                    (ERROR_PCW_BASE + 0x84)
#define ERROR_PCW_BAD_TGT_UPD_IMAGES                  (ERROR_PCW_BASE + 0x85)
#define ERROR_PCW_BAD_SUPERCEDENCE                    (ERROR_PCW_BASE + 0x86)
#define ERROR_PCW_BAD_SEQUENCE                        (ERROR_PCW_BASE + 0x87)
#define ERROR_PCW_BAD_TARGET                          (ERROR_PCW_BASE + 0x88)
#define ERROR_PCW_NULL_PATCHFAMILY                    (ERROR_PCW_BASE + 0x89)
#define ERROR_PCW_NULL_SEQUENCE_NUMBER                (ERROR_PCW_BASE + 0x8a)
#define ERROR_PCW_BAD_VERSION_STRING                  (ERROR_PCW_BASE + 0x8b)
#define ERROR_PCW_BAD_MAJOR_VERSION                   (ERROR_PCW_BASE + 0x8c)
#define ERROR_PCW_SEQUENCING_BAD_TARGET               (ERROR_PCW_BASE + 0x8d)
#define ERROR_PCW_PATCHMETADATA_PROP_NOT_SET          (ERROR_PCW_BASE + 0x8e)
#define ERROR_PCW_INVALID_PATCHMETADATA_PROP          (ERROR_PCW_BASE + 0x8f)
#define ERROR_PCW_INVALID_SUPERCEDENCE                (ERROR_PCW_BASE + 0x90)
#define ERROR_PCW_DUPLICATE_SEQUENCE_RECORD           (ERROR_PCW_BASE + 0x91)
#define ERROR_PCW_WRONG_PATCHMETADATA_STRD_PROP       (ERROR_PCW_BASE + 0x92)

/*  NEW in PatchWizEx */
#define ERROR_PCW_INVALID_PARAMETER                   (ERROR_PCW_BASE + 0x93)
#define ERROR_PCW_CREATEFILE_LOG_FAILED               (ERROR_PCW_BASE + 0x94)
#define ERROR_PCW_INVALID_LOG_LEVEL                   (ERROR_PCW_BASE + 0x95)
#define ERROR_PCW_INVALID_UI_LEVEL                    (ERROR_PCW_BASE + 0x96)
#define ERROR_PCW_ERROR_WRITING_TO_LOG                (ERROR_PCW_BASE + 0x97)
#define ERROR_PCW_OUT_OF_MEMORY                       (ERROR_PCW_BASE + 0x98)
#define ERROR_PCW_UNKNOWN_ERROR                       (ERROR_PCW_BASE + 0x99)
#define ERROR_PCW_UNKNOWN_INFO                        (ERROR_PCW_BASE + 0x9a)
#define ERROR_PCW_UNKNOWN_WARN                        (ERROR_PCW_BASE + 0x9b)
#define ERROR_PCW_OPEN_VIEW                           (ERROR_PCW_BASE + 0x9c)
#define ERROR_PCW_EXECUTE_VIEW                        (ERROR_PCW_BASE + 0x9d)
#define ERROR_PCW_VIEW_FETCH                          (ERROR_PCW_BASE + 0x9e)

#define ERROR_PCW_FAILED_EXPAND_PATH                  (ERROR_PCW_BASE + 0x9f)
#define ERROR_PCW_INTERNAL_ERROR                      (ERROR_PCW_BASE + 0x100)
#define ERROR_PCW_INVALID_PCP_PROPERTY                (ERROR_PCW_BASE + 0x101)
#define ERROR_PCW_INVALID_PCP_TARGETIMAGES            (ERROR_PCW_BASE + 0x102)
#define ERROR_PCW_LAX_VALIDATION_FLAGS                (ERROR_PCW_BASE + 0x103)
#define ERROR_PCW_FAILED_CREATE_TRANSFORM             (ERROR_PCW_BASE + 0x104)
#define ERROR_PCW_CANT_DELETE_TEMP_FOLDER             (ERROR_PCW_BASE + 0x105)
#define ERROR_PCW_MISSING_DIRECTORY_TABLE             (ERROR_PCW_BASE + 0x106)
#define ERROR_PCW_INVALID_SUPERSEDENCE_VALUE          (ERROR_PCW_BASE + 0x107)
#define ERROR_PCW_INVALID_PATCH_TYPE_SEQUENCING       (ERROR_PCW_BASE + 0x108)
#define ERROR_PCW_CANT_READ_FILE                      (ERROR_PCW_BASE + 0x109)
#define ERROR_PCW_TARGET_WRONG_PRODUCT_VERSION_COMP   (ERROR_PCW_BASE + 0x10a)
#define ERROR_PCW_INVALID_PCP_UPGRADEDFILESTOIGNORE   (ERROR_PCW_BASE + 0x10b)
#define ERROR_PCW_INVALID_PCP_UPGRADEDIMAGES          (ERROR_PCW_BASE + 0x10c)
#define ERROR_PCW_INVALID_PCP_EXTERNALFILES           (ERROR_PCW_BASE + 0x10d)
#define ERROR_PCW_INVALID_PCP_IMAGEFAMILIES           (ERROR_PCW_BASE + 0x10e)
#define ERROR_PCW_INVALID_PCP_PATCHSEQUENCE           (ERROR_PCW_BASE + 0x10f)
#define ERROR_PCW_INVALID_PCP_TARGETFILES_OPTIONALDATA (ERROR_PCW_BASE + 0x110)
#define ERROR_PCW_INVALID_PCP_UPGRADEDFILES_OPTIONALDATA (ERROR_PCW_BASE + 0x111)
#define ERROR_PCW_MISSING_PATCHMETADATA               (ERROR_PCW_BASE + 0x112)
#define ERROR_PCW_IMAGE_PATH_NOT_EXIST                (ERROR_PCW_BASE + 0x113)
#define ERROR_PCW_INVALID_RANGE_ELEMENT               (ERROR_PCW_BASE + 0x114)
#define ERROR_PCW_INVALID_MAJOR_VERSION               (ERROR_PCW_BASE + 0x115)

#define INFO_BASE									  0xc00f5101 
#define INFO_PASSED_MAIN_CONTROL					  (INFO_BASE + 0x00)
#define INFO_ENTERING_PHASE_I_VALIDATION              (INFO_BASE + 0x01)
#define INFO_ENTERING_PHASE_I                         (INFO_BASE + 0x02)
#define INFO_PCP_PATH                                 (INFO_BASE + 0x03)
#define INFO_TEMP_DIR                                 (INFO_BASE + 0x04)
#define INFO_SET_OPTIONS                              (INFO_BASE + 0x05)
#define INFO_PROPERTY                                 (INFO_BASE + 0x06)
#define INFO_ENTERING_PHASE_II						  (INFO_BASE + 0x07)
#define INFO_ENTERING_PHASE_III						  (INFO_BASE + 0x08)
#define INFO_ENTERING_PHASE_IV						  (INFO_BASE + 0x09)
#define INFO_ENTERING_PHASE_V						  (INFO_BASE + 0x0a)
#define INFO_GENERATING_METADATA					  (INFO_BASE + 0x10)
#define INFO_TEMP_DIR_CLEANUP                         (INFO_BASE + 0x11)
#define INFO_PATCHCACHE_FILEINFO_FAILURE              (INFO_BASE + 0x12)
#define INFO_PATCHCACHE_PCI_READFAILURE               (INFO_BASE + 0x13)
#define INFO_PATCHCACHE_PCI_WRITEFAILURE              (INFO_BASE + 0x14)

#define WARN_BASE									  0xc0105101 
#define WARN_MAJOR_UPGRADE_PATCH					  (WARN_BASE + 0x00)
#define WARN_SEQUENCE_DATA_GENERATION_DISABLED		  (WARN_BASE + 0x01)
#define WARN_SEQUENCE_DATA_SUPERSEDENCE_IGNORED		  (WARN_BASE + 0x02)
#define WARN_IMPROPER_TRANSFORM_VALIDATION            (WARN_BASE + 0x03)
#define WARN_PCW_MISMATCHED_PRODUCT_CODES             (WARN_BASE + 0x04)
#define WARN_PCW_MISMATCHED_PRODUCT_VERSIONS          (WARN_BASE + 0x05)
#define WARN_INVALID_TRANSFORM_VALIDATION             (WARN_BASE + 0x06)
#define WARN_BAD_MAJOR_VERSION                        (WARN_BASE + 0x07)
#define WARN_FILE_VERSION_DOWNREV                     (WARN_BASE + 0x08)
#define WARN_EQUAL_FILE_VERSION                       (WARN_BASE + 0x09)
#define WARN_PATCHPROPERTYNOTSET                      (WARN_BASE + 0x0A)

#endif // __PATCHWIZ_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\Pbt.h ===
/*++ BUILD Version: 0000     Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    pbt.h

Abstract:

    Definitions for the Virtual Power Management Device.

Revision History:

    DATE        REV DESCRIPTION
    ----------- --- ----------------------------------------
    15 Jan 1994 TCS Original implementation.

--*/

#ifndef _INC_PBT
#define _INC_PBT


#define WM_POWERBROADCAST               0x0218

#ifndef _WIN32_WCE
#define PBT_APMQUERYSUSPEND             0x0000
#define PBT_APMQUERYSTANDBY             0x0001

#define PBT_APMQUERYSUSPENDFAILED       0x0002
#define PBT_APMQUERYSTANDBYFAILED       0x0003

#define PBT_APMSUSPEND                  0x0004
#define PBT_APMSTANDBY                  0x0005

#define PBT_APMRESUMECRITICAL           0x0006
#define PBT_APMRESUMESUSPEND            0x0007
#define PBT_APMRESUMESTANDBY            0x0008

#define PBTF_APMRESUMEFROMFAILURE       0x00000001

#define PBT_APMBATTERYLOW               0x0009
#define PBT_APMPOWERSTATUSCHANGE        0x000A

#define PBT_APMOEMEVENT                 0x000B
#define PBT_APMRESUMEAUTOMATIC          0x0012
#endif
#endif // _INC_PBT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\pciprop.h ===
/*++

Copyright (c) 2005 Microsoft Corporation

Module Name:

    pciprop.h

Abstract:

    This file contains custom property definitions for a PCI root bus and a PCI
    device.

--*/

#ifndef _PCIPROP_
#define _PCIPROP_

//
// The GUID {D817FC28-793E-4b9e-9970-469D8BE63073} is a seed for all properties
// defined for a root bus.
//

#define DEFINE_PCI_ROOT_BUS_DEVPKEY(_DevPkeyName, _Pid) \
    DEFINE_DEVPROPKEY((_DevPkeyName), 0xd817fc28, 0x793e, 0x4b9e, 0x99, 0x70, 0x46, 0x9d, 0x8b, 0xe6, 0x30, 0x73, (_Pid))

//
// This property describes the secondary side characteristics of a root bus.
// The values for this property field are interpreted as below:
//

#define DevProp_PciRootBus_SecondaryInterface_PciConventional       0
#define DevProp_PciRootBus_SecondaryInterface_PciXMode1             1
#define DevProp_PciRootBus_SecondaryInterface_PciXMode2             2
#define DevProp_PciRootBus_SecondaryInterface_PciExpress            3

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_SecondaryInterface, 1); //DEVPROP_TYPE_UINT32

//
// This field is valid for conventional PCI and PCI-X host bridges.
// The values for this property field are interpreted as below:
//

#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_Conventional_33Mhz           0
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_Conventional_66Mhz           1
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_X_Mode1_66Mhz                2
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_X_Mode1_100Mhz               3
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_X_Mode1_133Mhz               4
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_X_Mode1_ECC_66Mhz            5
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_X_Mode1_ECC_100Mhz           6
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_X_Mode1_ECC_133Mhz           7
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_X_266_Mode2_66Mhz            8
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_X_266_Mode2_100Mhz           9
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_X_266_Mode2_133Mhz          10
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_X_533_Mode2_66Mhz           11
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_X_533_Mode2_100Mhz          12
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_X_533_Mode2_133Mhz          13

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_CurrentSpeedAndMode, 2); //DEVPROP_TYPE_UINT32

//
// This field is valid for conventional PCI and PCI-X host bridges.
// The values for this property field are interpreted as below:
//

#define DevProp_PciRootBus_SupportedSpeedsAndModes_Pci_Conventional_33Mhz       1
#define DevProp_PciRootBus_SupportedSpeedsAndModes_Pci_Conventional_66Mhz       2
#define DevProp_PciRootBus_SupportedSpeedsAndModes_Pci_X_66Mhz                  4
#define DevProp_PciRootBus_SupportedSpeedsAndModes_Pci_X_133Mhz                 8
#define DevProp_PciRootBus_SupportedSpeedsAndModes_Pci_X_266Mhz                16
#define DevProp_PciRootBus_SupportedSpeedsAndModes_Pci_X_533Mhz                32

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_SupportedSpeedsAndModes, 3); //DEVPROP_TYPE_UINT32

//
// This is boolean indicating if the host bridge is capable of forwarding
// Device ID Message transactions.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_DeviceIDMessagingCapable, 4); // DEVPROP_TYPE_BOOLEAN

//
// Provides the width of a root bus interface.
//

#define DevProp_PciRootBus_BusWidth_32Bits      0
#define DevProp_PciRootBus_BusWidth_64Bits      1

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_SecondaryBusWidth, 5); //DEVPROP_TYPE_UINT32

//
// This is a boolean indicating that an extended config space is available
// on the secondary side of the root bus.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_ExtendedConfigAvailable, 6); // DEVPROP_TYPE_BOOLEAN

//
// This is a boolean indicating an operating system support for an extended
// PCI config op region.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_ExtendedPCIConfigOpRegionSupport, 7); // DEVPROP_TYPE_BOOLEAN

//
// This is a boolean indicating an operating system support for ASPM.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_ASPMSupport, 8); // DEVPROP_TYPE_BOOLEAN

//
// This is a boolean indicating an operating system support for clock power
// management.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_ClockPowerManagementSupport, 9); // DEVPROP_TYPE_BOOLEAN

//
// This is a boolean indicating an operating system support for PCI Segments.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_PCISegmentGroupsSupport, 10); // DEVPROP_TYPE_BOOLEAN

//
// This is a boolean indicating an operating system support for Message
// Signaled Interrupts.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_MSISupport, 11); // DEVPROP_TYPE_BOOLEAN

//
// This is a boolean indicating that the firmware has granted control of native
// hot plug interrupts to the operating system.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_PCIExpressNativeHotPlugControl, 12);  // DEVPROP_TYPE_BOOLEAN

//
// This is a boolean indicating that the firmware has granted control of native
// SHPC to the operating system.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_SHPCNativeHotPlugControl, 13);   // DEVPROP_TYPE_BOOLEAN

//
// This is a boolean indicating that the firmware has granted control over
// native PME interrupts to the operating system.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_PCIExpressNativePMEControl, 14); // DEVPROP_TYPE_BOOLEAN

//
// This is a boolean indicating that the firmware has granted control over
// AER to the operating system.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_PCIExpressAERControl, 15); // DEVPROP_TYPE_BOOLEAN

//
// This is a boolean indicating that the firmware has granted control over the
// PCI Express capability to the operating system.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_PCIExpressCapabilityControl, 16); // DEVPROP_TYPE_BOOLEAN

//
// This is a boolean indicating that the operating system is controlling PCI
// Express features natively.  Generally this will be a reflection of the
// individual feature controls granted by the firmware and exposed by properties
// above, but the operating system might override the firmware.  The final
// control disposition is reflected here.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_NativePciExpressControl, 17); // DEVPROP_TYPE_BOOLEAN

//
// This is a boolean indicating that the system is configured to support MSI.
// If this is FALSE no message-signaled interrupts will be allocated to devices
// on this system, even if the operating system supports MSI.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_SystemMsiSupport, 18); // DEVPROP_TYPE_BOOLEAN


//
// The GUID {3AB22E31-8264-4b4e-9AF5-A8D2D8E33E62} is a seed for all properties
// defined for a PCI device.
//

#define DEFINE_PCI_DEVICE_DEVPKEY(_DevPkeyName, _Pid) \
   DEFINE_DEVPROPKEY((_DevPkeyName), 0x3ab22e31, 0x8264, 0x4b4e, 0x9a, 0xf5, 0xa8, 0xd2, 0xd8, 0xe3, 0x3e, 0x62, (_Pid))

//
// This property is defined to display the type of PCI device. The possible
// values are shown below.
//

#define DevProp_PciDevice_DeviceType_PciConventional                            0
#define DevProp_PciDevice_DeviceType_PciX                                       1
#define DevProp_PciDevice_DeviceType_PciExpressEndpoint                         2
#define DevProp_PciDevice_DeviceType_PciExpressLegacyEndpoint                   3
#define DevProp_PciDevice_DeviceType_PciExpressRootComplexIntegratedEndpoint    4
#define DevProp_PciDevice_DeviceType_PciExpressTreatedAsPci                     5

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_DeviceType, 1);

//
// This property is valid for conventional PCI or PCI-X devices.
// For conventional PCI devices, the speed/mode is described by the following
// fields.
//

#define DevProp_PciDevice_CurrentSpeedAndMode_Pci_Conventional_33MHz        0
#define DevProp_PciDevice_CurrentSpeedAndMode_Pci_Conventional_66MHz        1

//
// For PCI-X devices, the speed/mode is encoded in the following fashion.
//

#define DevProp_PciDevice_CurrentSpeedAndMode_PciX_Mode_Conventional_Pci  0x0
#define DevProp_PciDevice_CurrentSpeedAndMode_PciX_Mode1_66Mhz            0x1
#define DevProp_PciDevice_CurrentSpeedAndMode_PciX_Mode1_100Mhz           0x2
#define DevProp_PciDevice_CurrentSpeedAndMode_PciX_Mode1_133MHZ           0x3
#define DevProp_PciDevice_CurrentSpeedAndMode_PciX_Mode2_266_66MHz        0x9
#define DevProp_PciDevice_CurrentSpeedAndMode_PciX_Mode2_266_100MHz       0xA
#define DevProp_PciDevice_CurrentSpeedAndMode_PciX_Mode2_266_133MHz       0xB
#define DevProp_PciDevice_CurrentSpeedAndMode_PciX_Mode2_533_66MHz        0xD
#define DevProp_PciDevice_CurrentSpeedAndMode_PciX_Mode2_533_100MHz       0xE
#define DevProp_PciDevice_CurrentSpeedAndMode_PciX_Mode2_533_133MHz       0xF

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_CurrentSpeedAndMode, 2);

//
// The BaseClass, SubClass and ProgIf fields are valid for all PCI devices.
//

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_BaseClass, 3);

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_SubClass, 4);

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_ProgIf, 5);

//
// This property describes the current payload size in the transaction layer
// for a PCI Express device. The encodings for this field are described below.
//

#define DevProp_PciExpressDevice_PayloadOrRequestSize_128Bytes          0
#define DevProp_PciExpressDevice_PayloadOrRequestSize_256Bytes          1
#define DevProp_PciExpressDevice_PayloadOrRequestSize_512Bytes          2
#define DevProp_PciExpressDevice_PayloadOrRequestSize_1024Bytes         3
#define DevProp_PciExpressDevice_PayloadOrRequestSize_2048Bytes         4
#define DevProp_PciExpressDevice_PayloadOrRequestSize_4096Bytes         5

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_CurrentPayloadSize, 6);

//
// This property describes the maximum payload size supported by an express
// device/function. The encodings are described above.
//

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_MaxPayloadSize, 7);

//
// This property describes the maximum read request size for an express device.
// The encoding for this field are given above.
//

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_MaxReadRequestSize, 8);

//
// This property is applicable to an express device with an express link. It
// describes the current link speed for the device. The encodings are defined
// as follows.
//

#define DevProp_PciExpressDevice_LinkSpeed_TwoAndHalf_Gbps      1

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_CurrentLinkSpeed, 9);

//
// This property is applicable to an express device with an express link. It
// describes the current link width whose encoding is as follows.
//

#define DevProp_PciExpressDevice_LinkWidth_By_1             1
#define DevProp_PciExpressDevice_LinkWidth_By_2             2
#define DevProp_PciExpressDevice_LinkWidth_By_4             4
#define DevProp_PciExpressDevice_LinkWidth_By_8             8
#define DevProp_PciExpressDevice_LinkWidth_By_12           12
#define DevProp_PciExpressDevice_LinkWidth_By_16           16
#define DevProp_PciExpressDevice_LinkWidth_By_32           32

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_CurrentLinkWidth, 10);

//
// This property describes the maximum link speed of an express link for an
// express device. The encodings for this field are:
//

#define DevProp_PciExpressDevice_LinkSpeed_TwoAndHalf_Gbps      1

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_MaxLinkSpeed, 11);

//
// This property describes the maximum link width implemented by an express
// link for an express devce. The encodings are same as described above.
//

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_MaxLinkWidth, 12);

//
// This property describes the specification version to which an express device
// was built.  The encodings for this field are:
//

#define DevProp_PciExpressDevice_Spec_Version_10        1
#define DevProp_PciExpressDevice_Spec_Version_11        2

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_ExpressSpecVersion, 13);

//
// This property describes the hardware support for interrupts on the device.
// It is a bitmask of supported interrupt types, with the following values:
//

#define DevProp_PciDevice_InterruptType_LineBased       1
#define DevProp_PciDevice_InterruptType_Msi             2
#define DevProp_PciDevice_InterruptType_MsiX            4

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_InterruptSupport, 14);

//
// This property describes the number of message interrupts a device supports
// in hardware.  This property is only valid if the device supports message
// interrupts.
//

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_InterruptMessageMaximum, 15);

//
// This property describes the number of Base Address Registers of various types
// supported by the device hardware.  The property data is a 32 bit value
// interpreted by the following macros:
//

#define DevProp_PciDevice_IoBarCount(_PropertyData)                             ((_PropertyData) & 0xFF)
#define DevProp_PciDevice_NonPrefetchable_MemoryBarCount(_PropertyData)         (((_PropertyData) >> 8) & 0xFF)
#define DevProp_PciDevice_32BitPrefetchable_MemoryBarCount(_PropertyData)       (((_PropertyData) >> 16) & 0xFF)
#define DevProp_PciDevice_64BitPrefetchable_MemoryBarCount(_PropertyData)       (((_PropertyData) >> 24) & 0xFF)

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_BarTypes, 16);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\PChannel.h ===
/****************************************************************************/
/* Header:    pchannel.h                                                    */
/*                                                                          */
/* Purpose:   Virtual Channel protocol header - VC stuff common to Client & */
/*            Server                                                        */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1999                                  */
/*                                                                          */
/****************************************************************************/

#ifndef _H_PCHANNEL
#define _H_PCHANNEL

/****************************************************************************/
/* Maximum amount of data that is sent in one operation.  Data larger than  */
/* this is segmented into chunks of this size and sent as multiple          */
/* operations.                                                              */
/****************************************************************************/
#define CHANNEL_CHUNK_LENGTH    1600

#define CHANNEL_PDU_LENGTH (CHANNEL_CHUNK_LENGTH + sizeof(CHANNEL_PDU_HEADER))

/****************************************************************************/
/* Header flags (also passed to VirtualChannelOpenEventFn)                  */
/****************************************************************************/
#define CHANNEL_FLAG_FIRST      0x01
#define CHANNEL_FLAG_LAST       0x02
#define CHANNEL_FLAG_ONLY       (CHANNEL_FLAG_FIRST | CHANNEL_FLAG_LAST)
#define CHANNEL_FLAG_MIDDLE     0

#define CHANNEL_FLAG_FAIL       0x100

/****************************************************************************/
/* Header flags (internal protocol use only)                                */
/****************************************************************************/
#define CHANNEL_FLAG_SHOW_PROTOCOL 0x10
#define CHANNEL_FLAG_SUSPEND       0x20
#define CHANNEL_FLAG_RESUME        0x40

/****************************************************************************/
/* Virtual Channel options, passed by Client on VirtualChannelOpen          */
/****************************************************************************/

/****************************************************************************/
/* Application is initialized.  If this flag is not set, a virtual channel  */
/* is not established for this application                                  */
/****************************************************************************/
#define CHANNEL_OPTION_INITIALIZED  0x80000000

/****************************************************************************/
/* Encrypt according to RDP data encryption (ie if RDP data is encrypted,   */
/* do so for this virtual channel too)                                      */
/****************************************************************************/
#define CHANNEL_OPTION_ENCRYPT_RDP  0x40000000

/****************************************************************************/
/* Encrypt Server to Client data (ignored if CHANNEL_OPTION_ENCRYPT_RDP is  */
/* set)                                                                     */
/****************************************************************************/
#define CHANNEL_OPTION_ENCRYPT_SC   0x20000000

/****************************************************************************/
/* Encrypt Client to Server data (ignored if CHANNEL_OPTION_ENCRYPT_RDP is  */
/* set)                                                                     */
/****************************************************************************/
#define CHANNEL_OPTION_ENCRYPT_CS   0x10000000

/****************************************************************************/
/* Send data at high priority (not recommended, as this may impact RDP      */
/* performance)                                                             */
/****************************************************************************/
#define CHANNEL_OPTION_PRI_HIGH     0x08000000

/****************************************************************************/
/* Send data at medium priority                                             */
/****************************************************************************/
#define CHANNEL_OPTION_PRI_MED      0x04000000

/****************************************************************************/
/* Send data at low priority                                                */
/****************************************************************************/
#define CHANNEL_OPTION_PRI_LOW      0x02000000

/****************************************************************************/
/* Compress data in this virtual channel if RDP data compression is         */
/* configured for this connection                                           */
/****************************************************************************/
#define CHANNEL_OPTION_COMPRESS_RDP 0x00800000

/****************************************************************************/
/* Compress data in this virtual channel, irrespective of RDP data          */
/* compression (ignored if CHANNEL_OPTION_COMPRESS_RDP is set)              */
/****************************************************************************/
#define CHANNEL_OPTION_COMPRESS     0x00400000

/****************************************************************************/
/* Show Server addins the full Virtual Channel protocol.  This option       */
/* affects how data passed to VirtualChannelWrite is presented to Server    */
/* addins.                                                                  */
/*                                                                          */
/* - If this option is set, Server addins see the full Virtual Channel      */
/* protocol, including CHANNEL_PDU_HEADER (below).                          */
/*                                                                          */
/* -If this option is not set, Server addins see just the data passed to    */
/* VirtualChannelWrite                                                      */
/****************************************************************************/
#define CHANNEL_OPTION_SHOW_PROTOCOL 0x00200000

/****************************************************************************/
/* Maximum number and size of channel names                                 */
/****************************************************************************/
#define CHANNEL_MAX_COUNT           30
#define CHANNEL_NAME_LEN             7

/****************************************************************************/
/* Structure: CHANNEL_DEF                                                   */
/*                                                                          */
/* Description: Client to Server virtual channel information                */
/* - name       channel name                                                */
/* - options    channel options (a combination of the CHANNEL_OPTION        */
/*              constants above)                                            */
/****************************************************************************/
typedef struct tagCHANNEL_DEF
{
    char            name[CHANNEL_NAME_LEN + 1];
    ULONG           options;
} CHANNEL_DEF, FAR * PCHANNEL_DEF, FAR * FAR * PPCHANNEL_DEF;

/****************************************************************************/
/* Header of Virtual Channel PDUs                                           */
/****************************************************************************/
/****************************************************************************/
/* Structure: CHANNEL_PDU_HEADER                                            */
/*                                                                          */
/* Description: Header sent on Virtual Channel PDUs                         */
/****************************************************************************/
typedef struct tagCHANNEL_PDU_HEADER
{
    UINT32    length;                 /* Length of data including header    */
    UINT32    flags;                  /* CHANNEL_FLAG_xxx flags             */
} CHANNEL_PDU_HEADER, FAR * PCHANNEL_PDU_HEADER;
/****************************************************************************/

#endif /* _H_PCHANNEL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\parser.h ===
//**************************************************************************************************
//
//  Purpose: Defines classes to support parsing tokens from a xml file

#ifndef _PARSER_H
#define _PARSER_H

#include <stdio.h>

#undef CLASS_IMPORT_EXPORT
#if defined(HHCTRL) || defined(_M_CEE_PURE) // define this only when building the HHCtrl DLL
  #define CLASS_IMPORT_EXPORT /**/
#else
 #ifdef HHSETUP // define this only when building the HHSetup DLL
  #define CLASS_IMPORT_EXPORT __declspec( dllexport )
 #else
  #define CLASS_IMPORT_EXPORT __declspec( dllimport )
 #endif
#endif

#ifdef _M_CEE_PURE
#define PARSER_API_INLINE __clrcall
#else
#define PARSER_API_INLINE
#endif

#define MAX_LINE_LEN 1024

#define F_OK 0
#define F_NOFILE 1
#define F_READ 2
#define F_WRITE 3
#define F_MEMORY 4
#define F_EOF 5
#define F_END 6
#define F_TAGMISSMATCH 7
#define F_MISSINGENDTAG 8
#define F_NOTFOUND 9
#define F_NOPARENT 10
#define F_NULL 11
#define F_NOTITLE 12
#define F_LOCATION 13
#define F_REFERENCED 14
#define F_DUPLICATE 15
#define F_DELETE 16
#define F_CLOSE 17
#define F_EXISTCHECK 19

class CParseXML {
private: // data

	CHAR m_cCurToken[MAX_LINE_LEN];
	CHAR m_cCurWord[MAX_LINE_LEN];
	CHAR m_cCurBuffer[MAX_LINE_LEN];
	FILE *m_fh;
	CHAR * m_pCurrentIndex;
	DWORD m_dwError;

private: // functions
	DWORD Read();
	DWORD SetError(DWORD dw) { m_dwError = dw; return m_dwError; }
public:

	CParseXML() {
		m_fh = NULL;
		m_cCurBuffer[0] = '\0';
		m_pCurrentIndex = NULL;
		m_dwError = F_OK;
	}

	~CParseXML() {
		End();
	}

	CHAR * GetFirstWord(CHAR *);
	CHAR * GetValue(CHAR *);

	DWORD Start(const CHAR *szFile);
	void End();
	CHAR *GetToken();
	DWORD GetError() { return m_dwError; }
};

// class to support a FIFO queue of strings
typedef struct  fifo {
	CHAR *string;
	fifo *prev;
} FIFO;

class CLASS_IMPORT_EXPORT  CFIFOString {
private:

	FIFO *m_fifoTail;

public:

	CFIFOString() { m_fifoTail = NULL; }
	~CFIFOString();
	void RemoveAll();

	DWORD AddTail(CHAR *sz);
	DWORD GetTail(__deref_out PZPSTR sz);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\PatchApi.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  patchapi.h
//
//  Interface for creating and applying patches to files.
//
//  Copyright (C) Microsoft, 1997-2001.
//

#ifndef _PATCHAPI_H_
#define _PATCHAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

//
//  The following constants can be combined and used as the OptionFlags
//  parameter in the patch creation apis.
//

#define PATCH_OPTION_USE_BEST           0x00000000  // auto choose best (slower)

#define PATCH_OPTION_USE_LZX_BEST       0x00000003  // auto choose best of LZX A/B (but not large)
#define PATCH_OPTION_USE_LZX_A          0x00000001  // normal
#define PATCH_OPTION_USE_LZX_B          0x00000002  // better on some x86 binaries
#define PATCH_OPTION_USE_LZX_LARGE      0x00000004  // better support for large files (requires 5.1 or higher applyer)

#define PATCH_OPTION_NO_BINDFIX         0x00010000  // PE bound imports
#define PATCH_OPTION_NO_LOCKFIX         0x00020000  // PE smashed locks
#define PATCH_OPTION_NO_REBASE          0x00040000  // PE rebased image
#define PATCH_OPTION_FAIL_IF_SAME_FILE  0x00080000  // don't create if same
#define PATCH_OPTION_FAIL_IF_BIGGER     0x00100000  // fail if patch is larger than simply compressing new file (slower)
#define PATCH_OPTION_NO_CHECKSUM        0x00200000  // PE checksum zero
#define PATCH_OPTION_NO_RESTIMEFIX      0x00400000  // PE resource timestamps
#define PATCH_OPTION_NO_TIMESTAMP       0x00800000  // don't store new file timestamp in patch
#define PATCH_OPTION_SIGNATURE_MD5      0x01000000  // use MD5 instead of CRC (reserved for future support)
#define PATCH_OPTION_INTERLEAVE_FILES   0x40000000  // better support for large files (requires 5.2 or higher applyer)
#define PATCH_OPTION_RESERVED1          0x80000000  // (used internally)

#define PATCH_OPTION_VALID_FLAGS        0xC0FF0007

//
//  The following flags are used with PATCH_OPTION_DATA SymbolOptionFlags:
//

#define PATCH_SYMBOL_NO_IMAGEHLP        0x00000001  // don't use imagehlp.dll
#define PATCH_SYMBOL_NO_FAILURES        0x00000002  // don't fail patch due to imagehlp failures
#define PATCH_SYMBOL_UNDECORATED_TOO    0x00000004  // after matching decorated symbols, try to match remaining by undecorated names
#define PATCH_SYMBOL_RESERVED1          0x80000000  // (used internally)

//
//  The following flags are used with PATCH_OPTION_DATA ExtendedOptionFlags:
//

#define PATCH_TRANSFORM_PE_RESOURCE_2   0x00000100  // better handling of PE resources (requires 5.2 or higher applyer)
#define PATCH_TRANSFORM_PE_IRELOC_2     0x00000200  // better handling of PE stripped relocs (requires 5.2 or higher applyer)


//
//  The following constants can be combined and used as the ApplyOptionFlags
//  parameter in the patch apply and test apis.
//

#define APPLY_OPTION_FAIL_IF_EXACT      0x00000001  // don't copy new file
#define APPLY_OPTION_FAIL_IF_CLOSE      0x00000002  // differ by rebase, bind
#define APPLY_OPTION_TEST_ONLY          0x00000004  // don't create new file
#define APPLY_OPTION_VALID_FLAGS        0x00000007

//
//  In addition to standard Win32 error codes, the following error codes may
//  be returned via GetLastError() when one of the patch APIs fails.
//

#define ERROR_PATCH_ENCODE_FAILURE          0xC00E3101  // create
#define ERROR_PATCH_INVALID_OPTIONS         0xC00E3102  // create
#define ERROR_PATCH_SAME_FILE               0xC00E3103  // create
#define ERROR_PATCH_RETAIN_RANGES_DIFFER    0xC00E3104  // create
#define ERROR_PATCH_BIGGER_THAN_COMPRESSED  0xC00E3105  // create
#define ERROR_PATCH_IMAGEHLP_FAILURE        0xC00E3106  // create

#define ERROR_PATCH_DECODE_FAILURE          0xC00E4101  // apply
#define ERROR_PATCH_CORRUPT                 0xC00E4102  // apply
#define ERROR_PATCH_NEWER_FORMAT            0xC00E4103  // apply
#define ERROR_PATCH_WRONG_FILE              0xC00E4104  // apply
#define ERROR_PATCH_NOT_NECESSARY           0xC00E4105  // apply
#define ERROR_PATCH_NOT_AVAILABLE           0xC00E4106  // apply

typedef BOOL (CALLBACK PATCH_PROGRESS_CALLBACK)(
    PVOID CallbackContext,
    ULONG CurrentPosition,
    ULONG MaximumPosition
    );

typedef PATCH_PROGRESS_CALLBACK *PPATCH_PROGRESS_CALLBACK;

typedef BOOL (CALLBACK PATCH_SYMLOAD_CALLBACK)(
    IN ULONG  WhichFile,          // 0 for new file, 1 for first old file, etc
    IN LPCSTR SymbolFileName,
    IN ULONG  SymType,            // see SYM_TYPE in imagehlp.h
    IN ULONG  SymbolFileCheckSum,
    IN ULONG  SymbolFileTimeDate,
    IN ULONG  ImageFileCheckSum,
    IN ULONG  ImageFileTimeDate,
    IN PVOID  CallbackContext
    );

typedef PATCH_SYMLOAD_CALLBACK *PPATCH_SYMLOAD_CALLBACK;

typedef struct _PATCH_IGNORE_RANGE {
    ULONG OffsetInOldFile;
    ULONG LengthInBytes;
    } PATCH_IGNORE_RANGE, *PPATCH_IGNORE_RANGE;

typedef struct _PATCH_RETAIN_RANGE {
    ULONG OffsetInOldFile;
    ULONG LengthInBytes;
    ULONG OffsetInNewFile;
    } PATCH_RETAIN_RANGE, *PPATCH_RETAIN_RANGE;

typedef struct _PATCH_OLD_FILE_INFO_A {
    ULONG               SizeOfThisStruct;
    LPCSTR              OldFileName;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_A, *PPATCH_OLD_FILE_INFO_A;

typedef struct _PATCH_OLD_FILE_INFO_W {
    ULONG               SizeOfThisStruct;
    LPCWSTR             OldFileName;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_W, *PPATCH_OLD_FILE_INFO_W;

typedef struct _PATCH_OLD_FILE_INFO_H {
    ULONG               SizeOfThisStruct;
    HANDLE              OldFileHandle;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_H, *PPATCH_OLD_FILE_INFO_H;

typedef struct _PATCH_OLD_FILE_INFO {
    ULONG               SizeOfThisStruct;
    union {
        LPCSTR          OldFileNameA;
        LPCWSTR         OldFileNameW;
        HANDLE          OldFileHandle;
        };
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO, *PPATCH_OLD_FILE_INFO;

typedef struct _PATCH_INTERLEAVE_MAP {
    ULONG CountRanges;
    struct {
        ULONG OldOffset;
        ULONG OldLength;
        ULONG NewLength;    // NewOffset implied by sum of previous NewLengths
        } Range[ 1 ];       // Variable length (CountRanges)
    } PATCH_INTERLEAVE_MAP, *PPATCH_INTERLEAVE_MAP;

typedef struct _PATCH_OPTION_DATA {
    ULONG                   SizeOfThisStruct;
    ULONG                   SymbolOptionFlags;      // PATCH_SYMBOL_xxx flags
    LPCSTR                  NewFileSymbolPath;      // always ANSI, never Unicode
    LPCSTR                 *OldFileSymbolPathArray; // array[ OldFileCount ]
    ULONG                   ExtendedOptionFlags;
    PPATCH_SYMLOAD_CALLBACK SymLoadCallback;
    PVOID                   SymLoadContext;
    PPATCH_INTERLEAVE_MAP*  InterleaveMapArray;     // array[ OldFileCount ] (requires 5.2 or higher applyer)
    ULONG                   MaxLzxWindowSize;       // limit memory requirements (requires 5.2 or higher applyer)
    } PATCH_OPTION_DATA, *PPATCH_OPTION_DATA;

//
//  Note that PATCH_OPTION_DATA contains LPCSTR paths, and no LPCWSTR (Unicode)
//  path argument is available, even when used with one of the Unicode APIs
//  such as CreatePatchFileW.  This is because the underlying system services
//  for symbol file handling (IMAGEHLP.DLL) only support ANSI file/path names.
//

//
//  A note about PATCH_RETAIN_RANGE specifiers with multiple old files:
//
//  Each old version file must have the same RetainRangeCount, and the same
//  retain range LengthInBytes and OffsetInNewFile values in the same order.
//  Only the OffsetInOldFile values can differ between old files for retain
//  ranges.
//

#ifdef IMPORTING_PATCHAPI_DLL
#define PATCHAPI WINAPI __declspec( dllimport )
#else
#define PATCHAPI WINAPI
#endif


//
//  The following prototypes are interface for creating patches from files.
//

BOOL
PATCHAPI
CreatePatchFileA(
    __in_opt LPCSTR OldFileName,            // input file  (optional)
    __in     LPCSTR NewFileName,            // input file  (required)
    __in     LPCSTR PatchFileName,          // output file (required)
    __in     ULONG  OptionFlags,
    __in_opt PPATCH_OPTION_DATA OptionData
    );

BOOL
PATCHAPI
CreatePatchFileW(
    __in_opt LPCWSTR OldFileName,           // input file  (optional)
    __in     LPCWSTR NewFileName,           // input file  (required)
    __in     LPCWSTR PatchFileName,         // output file (required)
    __in     ULONG   OptionFlags,
    __in_opt PPATCH_OPTION_DATA OptionData
    );

BOOL
PATCHAPI
CreatePatchFileByHandles(
    __in_opt HANDLE OldFileHandle,          // input file  (optional)
    __in     HANDLE NewFileHandle,          // input file  (required)
    __in     HANDLE PatchFileHandle,        // output file (required)
    __in     ULONG  OptionFlags,
    __in_opt PPATCH_OPTION_DATA OptionData
    );

BOOL
PATCHAPI
CreatePatchFileExA(
    __in     ULONG                    OldFileCount,     // maximum 255
    __in_ecount( OldFileCount ) PPATCH_OLD_FILE_INFO_A OldFileInfoArray,
    __in     LPCSTR                   NewFileName,      // input file
    __in     LPCSTR                   PatchFileName,    // output file
    __in     ULONG                    OptionFlags,
    __in_opt PPATCH_OPTION_DATA       OptionData,
    __in_opt PPATCH_PROGRESS_CALLBACK ProgressCallback,
    __in_opt PVOID                    CallbackContext
    );

BOOL
PATCHAPI
CreatePatchFileExW(
    __in     ULONG                    OldFileCount,     // maximum 255
    __in_ecount( OldFileCount ) PPATCH_OLD_FILE_INFO_W OldFileInfoArray,
    __in     LPCWSTR                  NewFileName,      // input file
    __in     LPCWSTR                  PatchFileName,    // output file
    __in     ULONG                    OptionFlags,
    __in_opt PPATCH_OPTION_DATA       OptionData,
    __in_opt PPATCH_PROGRESS_CALLBACK ProgressCallback,
    __in_opt PVOID                    CallbackContext
    );

BOOL
PATCHAPI
CreatePatchFileByHandlesEx(
    __in     ULONG                    OldFileCount,     // maximum 255
    __in_ecount( OldFileCount ) PPATCH_OLD_FILE_INFO_H OldFileInfoArray,
    __in     HANDLE                   NewFileHandle,    // input file
    __in     HANDLE                   PatchFileHandle,  // output file
    __in     ULONG                    OptionFlags,
    __in_opt PPATCH_OPTION_DATA       OptionData,
    __in_opt PPATCH_PROGRESS_CALLBACK ProgressCallback,
    __in_opt PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileA(
    __in LPCSTR PatchFileName,          // input file
    __in LPCSTR PatchHeaderFileName     // output file
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileW(
    __in LPCWSTR PatchFileName,         // input file
    __in LPCWSTR PatchHeaderFileName    // output file
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileByHandles(
    __in HANDLE PatchFileHandle,        // input file
    __in HANDLE PatchHeaderFileHandle   // output file
    );

//
//  The following prototypes are interface for creating new file from old file
//  and patch file.  Note that it is possible for the TestApply API to succeed
//  but the actual Apply to fail since the TestApply only verifies that the
//  old file has the correct CRC without actually applying the patch.  The
//  TestApply API only requires the patch header portion of the patch file,
//  but its CRC must be corrected.
//

BOOL
PATCHAPI
TestApplyPatchToFileA(
    __in LPCSTR PatchFileName,
    __in LPCSTR OldFileName,
    __in ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
TestApplyPatchToFileW(
    __in LPCWSTR PatchFileName,
    __in LPCWSTR OldFileName,
    __in ULONG   ApplyOptionFlags
    );

BOOL
PATCHAPI
TestApplyPatchToFileByHandles(
    __in HANDLE PatchFileHandle,      // requires GENERIC_READ access
    __in HANDLE OldFileHandle,        // requires GENERIC_READ access
    __in ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
TestApplyPatchToFileByBuffers(
    __in_bcount( PatchFileSize )   PBYTE  PatchFileBuffer,     // not modified
    __in                           ULONG  PatchFileSize,
    __in_bcount_opt( OldFileSize ) PBYTE  OldFileBuffer,       // not modified
    __in                           ULONG  OldFileSize,
    __out_opt                      ULONG* NewFileSize,         // optional
    __in                           ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileA(
    __in     LPCSTR PatchFileName,      // input file (required)
    __in_opt LPCSTR OldFileName,        // input file (optional)
    __in     LPCSTR NewFileName,        // output file (required)
    __in     ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileW(
    __in     LPCWSTR PatchFileName,     // input file (required)
    __in_opt LPCWSTR OldFileName,       // input file (optional)
    __in     LPCWSTR NewFileName,       // output file (required)
    __in     ULONG   ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileByHandles(
    __in     HANDLE PatchFileHandle,    // input file (required)  GENERIC_READ
    __in_opt HANDLE OldFileHandle,      // input file (optional)  GENERIC_READ
    __in     HANDLE NewFileHandle,      // output file (required) GENERIC_WRITE
    __in     ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileExA(
    __in     LPCSTR                   PatchFileName,    // input file (required)
    __in_opt LPCSTR                   OldFileName,      // input file (optional)
    __in     LPCSTR                   NewFileName,      // output file (required)
    __in     ULONG                    ApplyOptionFlags,
    __in_opt PPATCH_PROGRESS_CALLBACK ProgressCallback,
    __in_opt PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ApplyPatchToFileExW(
    __in     LPCWSTR                  PatchFileName,    // input file (required)
    __in_opt LPCWSTR                  OldFileName,      // input file (optional)
    __in     LPCWSTR                  NewFileName,      // output file (required)
    __in     ULONG                    ApplyOptionFlags,
    __in_opt PPATCH_PROGRESS_CALLBACK ProgressCallback,
    __in_opt PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ApplyPatchToFileByHandlesEx(
    __in     HANDLE                   PatchFileHandle,  // input file (required)
    __in_opt HANDLE                   OldFileHandle,    // input file (optional)
    __in     HANDLE                   NewFileHandle,    // output file (required)
    __in     ULONG                    ApplyOptionFlags,
    __in_opt PPATCH_PROGRESS_CALLBACK ProgressCallback,
    __in_opt PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ApplyPatchToFileByBuffers(
    __in_bcount( PatchFileSize )   PBYTE  PatchFileMapped,     // not modified
    __in                           ULONG  PatchFileSize,
    __in_bcount_opt( OldFileSize ) PBYTE  OldFileMapped,       // not modified
    __in                           ULONG  OldFileSize,
    __deref_opt_inout_bcount_part_opt( NewFileBufferSize, *NewFileActualSize )
                                   PBYTE* NewFileBuffer,       // caller-supplied or returned buffer
    __in                           ULONG  NewFileBufferSize,   // caller-supplied buffer size
    __out_opt                      ULONG* NewFileActualSize,   // actual or required size
    __out_opt                      FILETIME* NewFileTime,      // optional
    __in                           ULONG  ApplyOptionFlags,
    __in_opt                       PPATCH_PROGRESS_CALLBACK ProgressCallback,
    __in_opt                       PVOID  CallbackContext
    );

//
//  If *NewFileBuffer is NULL, and APPLY_OPTION_TEST_ONLY is not specified,
//  and the function succeeds (returns TRUE), and size of new file is non-zero,
//  *NewFileBuffer will be set to a VirtualAlloc buffer of the required size,
//  and it will be the caller's responsibility to VirtualFree this buffer.
//  NewFileBufferSize is ignored when *NewFileBuffer is NULL.
//
//  If *NewFileBuffer is non-NULL, and APPLY_OPTION_TEST_ONLY is not specified,
//  NewFileBufferSize specifies the size of caller-supplied *NewFileBuffer
//  buffer.  If required size exceeds NewFileBufferSize, function will fail
//  (return FALSE), *NewFileActualSize will be set to required size, and
//  GetLastError will return ERROR_INSUFFICIENT_BUFFER.
//
//  If ApplyOptionFlags APPLY_OPTION_TEST_ONLY is specified, NewFileBuffer
//  and NewFileBufferSize are ignored, and *NewFileActualSize will be set to
//  required buffer size.  If APPLY_OPTION_TEST_ONLY is not specified, then
//  NewFileBuffer must be non-NULL (*NewFileBuffer may be NULL).
//
//  NewFileTime is optional.  If non-NULL, the value returned will either be
//  non-zero to indicate the new file time as specified in the patch, or zero
//  to indicate that file time was not stored inside the patch.
//


//
//  The following prototypes provide a unique patch "signature" for a given
//  file.  Consider the case where you have a new foo.dll and the machines
//  to be updated with the new foo.dll may have one of three different old
//  foo.dll files.  Rather than creating a single large patch file that can
//  update any of the three older foo.dll files, three separate smaller patch
//  files can be created and identified according to the patch signature of the
//  old file.  Then the patch applyer application can determine at runtime
//  which of the three foo.dll patch files is necessary given the specific
//  foo.dll to be updated.  If patch files are being downloaded over a slow
//  network connection (internet over a modem), this signature scheme provides
//  a mechanism for choosing the correct single patch file to download at
//  application time thus decreasing total bytes necessary to download.
//

BOOL
PATCHAPI
GetFilePatchSignatureA(
    __in                                  LPCSTR FileName,
    __in                                  ULONG  OptionFlags,
    __in_opt                              PVOID  OptionData,
    __in                                  ULONG  IgnoreRangeCount,
    __in_ecount_opt( IgnoreRangeCount )   PPATCH_IGNORE_RANGE IgnoreRangeArray,
    __in                                  ULONG  RetainRangeCount,
    __in_ecount_opt( RetainRangeCount )   PPATCH_RETAIN_RANGE RetainRangeArray,
    __in                                  ULONG  SignatureBufferSize,
    __inout_bcount( SignatureBufferSize ) LPSTR  SignatureBuffer
    );

BOOL
PATCHAPI
GetFilePatchSignatureW(
    __in                                  LPCWSTR FileName,
    __in                                  ULONG   OptionFlags,
    __in_opt                              PVOID   OptionData,
    __in                                  ULONG   IgnoreRangeCount,
    __in_ecount_opt( IgnoreRangeCount )   PPATCH_IGNORE_RANGE IgnoreRangeArray,
    __in                                  ULONG   RetainRangeCount,
    __in_ecount_opt( RetainRangeCount )   PPATCH_RETAIN_RANGE RetainRangeArray,
    __in                                  ULONG   SignatureBufferSize,
    __inout_bcount( SignatureBufferSize ) LPWSTR  SignatureBuffer
    );

BOOL
PATCHAPI
GetFilePatchSignatureByHandle(
    __in                                  HANDLE  FileHandle,
    __in                                  ULONG   OptionFlags,
    __in_opt                              PVOID   OptionData,
    __in                                  ULONG   IgnoreRangeCount,
    __in_ecount_opt( IgnoreRangeCount )   PPATCH_IGNORE_RANGE IgnoreRangeArray,
    __in                                  ULONG   RetainRangeCount,
    __in_ecount_opt( RetainRangeCount )   PPATCH_RETAIN_RANGE RetainRangeArray,
    __in                                  ULONG   SignatureBufferSize,
    __inout_bcount( SignatureBufferSize ) LPSTR   SignatureBuffer
    );

BOOL
PATCHAPI
GetFilePatchSignatureByBuffer(
    __inout_bcount( FileSize )            PBYTE   FileBufferWritable,   // modified!
    __in                                  ULONG   FileSize,
    __in                                  ULONG   OptionFlags,
    __in_opt                              PVOID   OptionData,
    __in                                  ULONG   IgnoreRangeCount,
    __in_ecount_opt( IgnoreRangeCount )   PPATCH_IGNORE_RANGE IgnoreRangeArray,
    __in                                  ULONG   RetainRangeCount,
    __in_ecount_opt( RetainRangeCount )   PPATCH_RETAIN_RANGE RetainRangeArray,
    __in                                  ULONG   SignatureBufferSize,
    __inout_bcount( SignatureBufferSize ) LPSTR   SignatureBuffer
    );

//
//  As an alternative to requesting the signature, some applications might use
//  NormalizeFileForPatchSignature to render a stream that can be hashed
//  by other means than CRC or MD5 provided by the signature APIs.  This API
//  returns 0 for failure (GetLastError returns additional info), 1 to indicate
//  the buffer did not require any modifications for normalization, or 2 to
//  indicate that the buffer was modified in the process of normalization.
//

INT
WINAPI
NormalizeFileForPatchSignature(
    __inout_bcount( FileSize )          PVOID FileBuffer,       // modified!
    __in                                ULONG FileSize,
    __in                                ULONG OptionFlags,
    __in_opt                            PATCH_OPTION_DATA* OptionData,
    __in                                ULONG NewFileCoffBase,
    __in                                ULONG NewFileCoffTime,
    __in                                ULONG IgnoreRangeCount,
    __in_ecount_opt( IgnoreRangeCount ) PPATCH_IGNORE_RANGE IgnoreRangeArray,
    __in                                ULONG RetainRangeCount,
    __in_ecount_opt( RetainRangeCount ) PPATCH_RETAIN_RANGE RetainRangeArray
    );


//
//  Depending on whether UNICODE is defined, map the generic API names to the
//  appropriate Unicode or Ansi APIs.
//

#ifdef UNICODE

    #define CreatePatchFile          CreatePatchFileW
    #define CreatePatchFileEx        CreatePatchFileExW
    #define TestApplyPatchToFile     TestApplyPatchToFileW
    #define ApplyPatchToFile         ApplyPatchToFileW
    #define ApplyPatchToFileEx       ApplyPatchToFileExW
    #define ExtractPatchHeaderToFile ExtractPatchHeaderToFileW
    #define GetFilePatchSignature    GetFilePatchSignatureW

#else

    #define CreatePatchFile          CreatePatchFileA
    #define CreatePatchFileEx        CreatePatchFileExA
    #define TestApplyPatchToFile     TestApplyPatchToFileA
    #define ApplyPatchToFile         ApplyPatchToFileA
    #define ApplyPatchToFileEx       ApplyPatchToFileExA
    #define ExtractPatchHeaderToFile ExtractPatchHeaderToFileA
    #define GetFilePatchSignature    GetFilePatchSignatureA

#endif // UNICODE

#ifdef __cplusplus
}
#endif

#endif // _PATCHAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\PerHist.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for perhist.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __perhist_h__
#define __perhist_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPersistHistory_FWD_DEFINED__
#define __IPersistHistory_FWD_DEFINED__
typedef interface IPersistHistory IPersistHistory;
#endif 	/* __IPersistHistory_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_perhist_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// perhist.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// IPersistHistory Interface.


#ifndef _LPPERSISTHISTORY_DEFINED
#define _LPPERSISTHISTORY_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_perhist_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_perhist_0000_0000_v0_0_s_ifspec;

#ifndef __IPersistHistory_INTERFACE_DEFINED__
#define __IPersistHistory_INTERFACE_DEFINED__

/* interface IPersistHistory */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IPersistHistory *LPPERSISTHISTORY;


EXTERN_C const IID IID_IPersistHistory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("91A565C1-E38F-11d0-94BF-00A0C9055CBF")
    IPersistHistory : public IPersist
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LoadHistory( 
            /* [in] */ __RPC__in_opt IStream *pStream,
            /* [in] */ __RPC__in_opt IBindCtx *pbc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveHistory( 
            /* [in] */ __RPC__in_opt IStream *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPositionCookie( 
            /* [in] */ DWORD dwPositioncookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPositionCookie( 
            /* [out] */ __RPC__out DWORD *pdwPositioncookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistHistoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPersistHistory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPersistHistory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPersistHistory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IPersistHistory * This,
            /* [out] */ __RPC__out CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *LoadHistory )( 
            IPersistHistory * This,
            /* [in] */ __RPC__in_opt IStream *pStream,
            /* [in] */ __RPC__in_opt IBindCtx *pbc);
        
        HRESULT ( STDMETHODCALLTYPE *SaveHistory )( 
            IPersistHistory * This,
            /* [in] */ __RPC__in_opt IStream *pStream);
        
        HRESULT ( STDMETHODCALLTYPE *SetPositionCookie )( 
            IPersistHistory * This,
            /* [in] */ DWORD dwPositioncookie);
        
        HRESULT ( STDMETHODCALLTYPE *GetPositionCookie )( 
            IPersistHistory * This,
            /* [out] */ __RPC__out DWORD *pdwPositioncookie);
        
        END_INTERFACE
    } IPersistHistoryVtbl;

    interface IPersistHistory
    {
        CONST_VTBL struct IPersistHistoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistHistory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPersistHistory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPersistHistory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPersistHistory_GetClassID(This,pClassID)	\
    ( (This)->lpVtbl -> GetClassID(This,pClassID) ) 


#define IPersistHistory_LoadHistory(This,pStream,pbc)	\
    ( (This)->lpVtbl -> LoadHistory(This,pStream,pbc) ) 

#define IPersistHistory_SaveHistory(This,pStream)	\
    ( (This)->lpVtbl -> SaveHistory(This,pStream) ) 

#define IPersistHistory_SetPositionCookie(This,dwPositioncookie)	\
    ( (This)->lpVtbl -> SetPositionCookie(This,dwPositioncookie) ) 

#define IPersistHistory_GetPositionCookie(This,pdwPositioncookie)	\
    ( (This)->lpVtbl -> GetPositionCookie(This,pdwPositioncookie) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPersistHistory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_perhist_0000_0001 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_perhist_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_perhist_0000_0001_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\Pdh.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    PDH.H

Abstract:

    Header file for the Performance Data Helper (PDH) DLL functions.

--*/
#ifndef _PDH_H_
#define _PDH_H_

#if _MSC_VER > 1000
#pragma once
#endif

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning ( disable : 4201)

// system include files required for datatype and constant definitions
#include <windows.h>    // necessary for data types used in this file
#include <winperf.h>    // necessary for the Detail Level definitions

#ifdef __cplusplus
extern "C" {
#endif

typedef LONG            PDH_STATUS;

#define PDH_FUNCTION    PDH_STATUS __stdcall

// version info
#define PDH_CVERSION_WIN40  ((DWORD)(0x0400))
#define PDH_CVERSION_WIN50  ((DWORD)(0x0500))
// v1.1 revision of PDH -- basic log functions
// v1.2 of the PDH -- adds variable instance counters
// v1.3 of the PDH -- adds log service control & stubs for NT5/PDH v2 fn's
// v2.0 of the PDH -- is the NT v 5.0 B2 version
#define PDH_VERSION         ((DWORD)((PDH_CVERSION_WIN50) + 0x0003))

// define severity masks
#define IsSuccessSeverity(ErrorCode)       ((((DWORD)(ErrorCode) & (0xC0000000L)) == 0x00000000L) ? TRUE : FALSE)
#define IsInformationalSeverity(ErrorCode) ((((DWORD)(ErrorCode) & (0xC0000000L)) == 0x40000000L) ? TRUE : FALSE)
#define IsWarningSeverity(ErrorCode)       ((((DWORD)(ErrorCode) & (0xC0000000L)) == 0x80000000L) ? TRUE : FALSE)
#define IsErrorSeverity(ErrorCode)         ((((DWORD)(ErrorCode) & (0xC0000000L)) == 0xC0000000L) ? TRUE : FALSE)

#if (_WIN32_WINDOWS >= 0x0501 || _WIN32_WINNT >= 0x0501 || (defined(NTDDI_VERSION) && NTDDI_VERSION >= NTDDI_WINXP))
#define MAX_COUNTER_PATH       256  // Maximum counter path length. This is an obsolute constance.

#if (_WIN32_WINDOWS >= 0x0502 || _WIN32_WINNT >= 0x0502 || (defined(NTDDI_VERSION) && NTDDI_VERSION >= NTDDI_WIN2003))
#define PDH_MAX_COUNTER_NAME    1024  // Maximum counter name length.
#define PDH_MAX_INSTANCE_NAME   1024  // Maximum counter instance name length.
#define PDH_MAX_COUNTER_PATH    2048  // Maximum full counter path length.
#define PDH_MAX_DATASOURCE_PATH 1024  // MAximum full counter log name length.
#endif

#define PDH_OBJECT_HAS_INSTANCES    ((DWORD) 0x00000001)
#endif

// data type definitions

typedef HANDLE       PDH_HCOUNTER;
typedef HANDLE       PDH_HQUERY;
typedef HANDLE       PDH_HLOG;

typedef PDH_HCOUNTER HCOUNTER;
typedef PDH_HQUERY   HQUERY;
#ifndef _LMHLOGDEFINED_
typedef PDH_HLOG     HLOG;
#endif

#ifdef INVALID_HANDLE_VALUE
#undef INVALID_HANDLE_VALUE
#define INVALID_HANDLE_VALUE  ((HANDLE)((LONG_PTR)-1))
#endif

#define H_REALTIME_DATASOURCE NULL
#define H_WBEM_DATASOURCE     INVALID_HANDLE_VALUE

typedef struct _PDH_RAW_COUNTER {
    volatile DWORD CStatus;
    FILETIME    TimeStamp;
    LONGLONG    FirstValue;
    LONGLONG    SecondValue;
    DWORD       MultiCount;
} PDH_RAW_COUNTER, * PPDH_RAW_COUNTER;

typedef struct _PDH_RAW_COUNTER_ITEM_A {
    LPSTR           szName;
    PDH_RAW_COUNTER RawValue;
} PDH_RAW_COUNTER_ITEM_A, * PPDH_RAW_COUNTER_ITEM_A;

typedef struct _PDH_RAW_COUNTER_ITEM_W {
    LPWSTR          szName;
    PDH_RAW_COUNTER RawValue;
} PDH_RAW_COUNTER_ITEM_W, * PPDH_RAW_COUNTER_ITEM_W;

typedef struct _PDH_FMT_COUNTERVALUE {
    DWORD    CStatus;
    union {
        LONG        longValue;
        double      doubleValue;
        LONGLONG    largeValue;
        LPCSTR      AnsiStringValue;
        LPCWSTR     WideStringValue;
    };
} PDH_FMT_COUNTERVALUE, * PPDH_FMT_COUNTERVALUE;

typedef struct _PDH_FMT_COUNTERVALUE_ITEM_A {
    LPSTR                   szName;
    PDH_FMT_COUNTERVALUE    FmtValue;
} PDH_FMT_COUNTERVALUE_ITEM_A, * PPDH_FMT_COUNTERVALUE_ITEM_A;

typedef struct _PDH_FMT_COUNTERVALUE_ITEM_W {
    LPWSTR                  szName;
    PDH_FMT_COUNTERVALUE    FmtValue;
} PDH_FMT_COUNTERVALUE_ITEM_W, * PPDH_FMT_COUNTERVALUE_ITEM_W;

typedef struct _PDH_STATISTICS {
    DWORD                   dwFormat;
    DWORD                   count;
    PDH_FMT_COUNTERVALUE    min;
    PDH_FMT_COUNTERVALUE    max;
    PDH_FMT_COUNTERVALUE    mean;
} PDH_STATISTICS, * PPDH_STATISTICS;

typedef struct _PDH_COUNTER_PATH_ELEMENTS_A {
    LPSTR   szMachineName;
    LPSTR   szObjectName;
    LPSTR   szInstanceName;
    LPSTR   szParentInstance;
    DWORD   dwInstanceIndex;
    LPSTR   szCounterName;
} PDH_COUNTER_PATH_ELEMENTS_A, * PPDH_COUNTER_PATH_ELEMENTS_A;

typedef struct _PDH_COUNTER_PATH_ELEMENTS_W {
    LPWSTR  szMachineName;
    LPWSTR  szObjectName;
    LPWSTR  szInstanceName;
    LPWSTR  szParentInstance;
    DWORD   dwInstanceIndex;
    LPWSTR  szCounterName;
} PDH_COUNTER_PATH_ELEMENTS_W, * PPDH_COUNTER_PATH_ELEMENTS_W;

typedef struct _PDH_DATA_ITEM_PATH_ELEMENTS_A {
    LPSTR   szMachineName;
    GUID    ObjectGUID;
    DWORD   dwItemId;
    LPSTR   szInstanceName;
} PDH_DATA_ITEM_PATH_ELEMENTS_A, * PPDH_DATA_ITEM_PATH_ELEMENTS_A;

typedef struct _PDH_DATA_ITEM_PATH_ELEMENTS_W {
    LPWSTR  szMachineName;
    GUID    ObjectGUID;
    DWORD   dwItemId;
    LPWSTR  szInstanceName;
} PDH_DATA_ITEM_PATH_ELEMENTS_W, * PPDH_DATA_ITEM_PATH_ELEMENTS_W;

typedef struct _PDH_COUNTER_INFO_A {
    DWORD   dwLength;
    DWORD   dwType;
    DWORD   CVersion;
    DWORD   CStatus;
    LONG    lScale;
    LONG    lDefaultScale;
    DWORD_PTR   dwUserData;
    DWORD_PTR   dwQueryUserData;
    LPSTR   szFullPath;
    union   {
        PDH_DATA_ITEM_PATH_ELEMENTS_A DataItemPath;
        PDH_COUNTER_PATH_ELEMENTS_A CounterPath;
        struct {
            LPSTR   szMachineName;
            LPSTR   szObjectName;
            LPSTR   szInstanceName;
            LPSTR   szParentInstance;
            DWORD   dwInstanceIndex;
            LPSTR   szCounterName;
        };
    };
    LPSTR   szExplainText;
    DWORD   DataBuffer[1];
} PDH_COUNTER_INFO_A, * PPDH_COUNTER_INFO_A;

typedef struct _PDH_COUNTER_INFO_W {
    DWORD   dwLength;
    DWORD   dwType;
    DWORD   CVersion;
    DWORD   CStatus;
    LONG    lScale;
    LONG    lDefaultScale;
    DWORD_PTR   dwUserData;
    DWORD_PTR   dwQueryUserData;
    LPWSTR  szFullPath;
    union   {
        PDH_DATA_ITEM_PATH_ELEMENTS_W DataItemPath;
        PDH_COUNTER_PATH_ELEMENTS_W CounterPath;
        struct {
            LPWSTR   szMachineName;
            LPWSTR   szObjectName;
            LPWSTR   szInstanceName;
            LPWSTR   szParentInstance;
            DWORD    dwInstanceIndex;
            LPWSTR   szCounterName;
        };
    };
    LPWSTR  szExplainText;
    DWORD   DataBuffer[1];
} PDH_COUNTER_INFO_W, * PPDH_COUNTER_INFO_W;

typedef struct _PDH_TIME_INFO {
    LONGLONG    StartTime;
    LONGLONG    EndTime;
    DWORD       SampleCount;
} PDH_TIME_INFO, * PPDH_TIME_INFO;

typedef struct _PDH_RAW_LOG_RECORD {
    DWORD       dwStructureSize;
    DWORD       dwRecordType;
    DWORD       dwItems;
    UCHAR       RawBytes[1];
} PDH_RAW_LOG_RECORD, * PPDH_RAW_LOG_RECORD;

typedef struct _PDH_LOG_SERVICE_QUERY_INFO_A {
    DWORD   dwSize;
    DWORD   dwFlags;
    DWORD   dwLogQuota;
    LPSTR   szLogFileCaption;
    LPSTR   szDefaultDir;
    LPSTR   szBaseFileName;
    DWORD   dwFileType;
    DWORD   dwReserved;
    union {
        struct {
            DWORD   PdlAutoNameInterval;
            DWORD   PdlAutoNameUnits;
            LPSTR   PdlCommandFilename;
            LPSTR   PdlCounterList;
            DWORD   PdlAutoNameFormat;
            DWORD   PdlSampleInterval;
            FILETIME    PdlLogStartTime;
            FILETIME    PdlLogEndTime;
        };
        struct {
            DWORD   TlNumberOfBuffers;
            DWORD   TlMinimumBuffers;
            DWORD   TlMaximumBuffers;
            DWORD   TlFreeBuffers;
            DWORD   TlBufferSize;
            DWORD   TlEventsLost;
            DWORD   TlLoggerThreadId;
            DWORD   TlBuffersWritten;
            DWORD   TlLogHandle;
            LPSTR   TlLogFileName;
        };
    };
} PDH_LOG_SERVICE_QUERY_INFO_A, * PPDH_LOG_SERVICE_QUERY_INFO_A;

typedef struct _PDH_LOG_SERVICE_QUERY_INFO_W {
    DWORD   dwSize;
    DWORD   dwFlags;
    DWORD   dwLogQuota;
    LPWSTR  szLogFileCaption;
    LPWSTR  szDefaultDir;
    LPWSTR  szBaseFileName;
    DWORD   dwFileType;
    DWORD   dwReserved;
    union {
        struct {
            DWORD   PdlAutoNameInterval;
            DWORD   PdlAutoNameUnits;
            LPWSTR  PdlCommandFilename;
            LPWSTR  PdlCounterList;
            DWORD   PdlAutoNameFormat;
            DWORD   PdlSampleInterval;
            FILETIME    PdlLogStartTime;
            FILETIME    PdlLogEndTime;
        };
        struct {
            DWORD   TlNumberOfBuffers;
            DWORD   TlMinimumBuffers;
            DWORD   TlMaximumBuffers;
            DWORD   TlFreeBuffers;
            DWORD   TlBufferSize;
            DWORD   TlEventsLost;
            DWORD   TlLoggerThreadId;
            DWORD   TlBuffersWritten;
            DWORD   TlLogHandle;
            LPWSTR  TlLogFileName;
        };
    };
} PDH_LOG_SERVICE_QUERY_INFO_W, * PPDH_LOG_SERVICE_QUERY_INFO_W;

//
//  Time value constants
//
#define MAX_TIME_VALUE ((LONGLONG) 0x7FFFFFFFFFFFFFFF)
#define MIN_TIME_VALUE ((LONGLONG) 0)

// function definitions

PDH_FUNCTION
PdhGetDllVersion(
    __out_opt LPDWORD lpdwVersion
);

//
//  Query Functions
//

PDH_FUNCTION
PdhOpenQueryW(
    __in_opt LPCWSTR      szDataSource,
    __in     DWORD_PTR    dwUserData,
    __out    PDH_HQUERY * phQuery
);

PDH_FUNCTION
PdhOpenQueryA(
    __in_opt LPCSTR       szDataSource,
    __in     DWORD_PTR    dwUserData,
    __out    PDH_HQUERY * phQuery
);

PDH_FUNCTION
PdhAddCounterW(
    __in  PDH_HQUERY     hQuery,
    __in  LPCWSTR        szFullCounterPath,
    __in  DWORD_PTR      dwUserData,
    __out PDH_HCOUNTER * phCounter
);

PDH_FUNCTION
PdhAddCounterA(
    __in  PDH_HQUERY     hQuery,
    __in  LPCSTR         szFullCounterPath,
    __in  DWORD_PTR      dwUserData,
    __out PDH_HCOUNTER * phCounter
);

#if (_WIN32_WINDOWS >= 0x0600 || _WIN32_WINNT >= 0x0600 || (defined(NTDDI_VERSION) && NTDDI_VERSION >= NTDDI_LONGHORN))
PDH_FUNCTION
PdhAddEnglishCounterW(
    __in  PDH_HQUERY     hQuery,
    __in  LPCWSTR        szFullCounterPath,
    __in  DWORD_PTR      dwUserData,
    __out PDH_HCOUNTER * phCounter
);

PDH_FUNCTION
PdhAddEnglishCounterA(
    __in  PDH_HQUERY     hQuery,
    __in  LPCSTR         szFullCounterPath,
    __in  DWORD_PTR      dwUserData,
    __out PDH_HCOUNTER * phCounter
);

PDH_FUNCTION
PdhCollectQueryDataWithTime(
    __inout PDH_HQUERY   hQuery,
    __out   LONGLONG   * pllTimeStamp
);

PDH_FUNCTION
PdhValidatePathExW(
    __in_opt PDH_HLOG hDataSource,
    __in     LPCWSTR  szFullPathBuffer
);

PDH_FUNCTION
PdhValidatePathExA(
    __in_opt PDH_HLOG hDataSource,
    __in     LPCSTR   szFullPathBuffer
);
#endif

PDH_FUNCTION
PdhRemoveCounter(
    __in PDH_HCOUNTER hCounter
);

PDH_FUNCTION
PdhCollectQueryData(
    __inout PDH_HQUERY hQuery
);

PDH_FUNCTION
PdhCloseQuery(
    __inout PDH_HQUERY hQuery
);

//
//  Counter Functions
//

PDH_FUNCTION
PdhGetFormattedCounterValue(
    __in      PDH_HCOUNTER          hCounter,
    __in      DWORD                 dwFormat,
    __out_opt LPDWORD               lpdwType,
    __out     PPDH_FMT_COUNTERVALUE pValue
);

__success(return == ERROR_SUCCESS)
PDH_FUNCTION
PdhGetFormattedCounterArrayA(
    __in    PDH_HCOUNTER hCounter,
    __in    DWORD        dwFormat,
    __inout LPDWORD      lpdwBufferSize,
    __out   LPDWORD      lpdwItemCount,
    __out_bcount_opt(* lpdwBufferSize) PPDH_FMT_COUNTERVALUE_ITEM_A ItemBuffer
);

__success(return == ERROR_SUCCESS)
PDH_FUNCTION
PdhGetFormattedCounterArrayW(
    __in    PDH_HCOUNTER hCounter,
    __in    DWORD        dwFormat,
    __inout LPDWORD      lpdwBufferSize,
    __out   LPDWORD      lpdwItemCount,
    __out_bcount_opt(* lpdwBufferSize) PPDH_FMT_COUNTERVALUE_ITEM_W ItemBuffer
);

// dwFormat flag values
//
#define PDH_FMT_RAW          ((DWORD) 0x00000010)
#define PDH_FMT_ANSI         ((DWORD) 0x00000020)
#define PDH_FMT_UNICODE      ((DWORD) 0x00000040)
#define PDH_FMT_LONG         ((DWORD) 0x00000100)
#define PDH_FMT_DOUBLE       ((DWORD) 0x00000200)
#define PDH_FMT_LARGE        ((DWORD) 0x00000400)
#define PDH_FMT_NOSCALE      ((DWORD) 0x00001000)
#define PDH_FMT_1000         ((DWORD) 0x00002000)
#define PDH_FMT_NODATA       ((DWORD) 0x00004000)
#define PDH_FMT_NOCAP100     ((DWORD) 0x00008000)
#define PERF_DETAIL_COSTLY   ((DWORD) 0x00010000)
#define PERF_DETAIL_STANDARD ((DWORD) 0x0000FFFF)

PDH_FUNCTION
PdhGetRawCounterValue(
    __in      PDH_HCOUNTER      hCounter,
    __out_opt LPDWORD           lpdwType,
    __out     PPDH_RAW_COUNTER  pValue
);

__success(return == ERROR_SUCCESS)
PDH_FUNCTION
PdhGetRawCounterArrayA(
    __in    PDH_HCOUNTER  hCounter,
    __inout LPDWORD       lpdwBufferSize,
    __out   LPDWORD       lpdwItemCount,
    __out_bcount_opt(* lpdwBufferSize) PPDH_RAW_COUNTER_ITEM_A ItemBuffer
);

__success(return == ERROR_SUCCESS)
PDH_FUNCTION
PdhGetRawCounterArrayW(
    __in    PDH_HCOUNTER  hCounter,
    __inout LPDWORD       lpdwBufferSize,
    __out   LPDWORD       lpdwItemCount,
    __out_bcount_opt(* lpdwBufferSize) PPDH_RAW_COUNTER_ITEM_W ItemBuffer
);

PDH_FUNCTION
PdhCalculateCounterFromRawValue(
    __in  PDH_HCOUNTER          hCounter,
    __in  DWORD                 dwFormat,
    __in  PPDH_RAW_COUNTER      rawValue1,
    __in  PPDH_RAW_COUNTER      rawValue2,
    __out PPDH_FMT_COUNTERVALUE fmtValue
);

PDH_FUNCTION
PdhComputeCounterStatistics(
    __in  PDH_HCOUNTER     hCounter,
    __in  DWORD            dwFormat,
    __in  DWORD            dwFirstEntry,
    __in  DWORD            dwNumEntries,
    __in  PPDH_RAW_COUNTER lpRawValueArray,
    __out PPDH_STATISTICS  data
);

__success(return == ERROR_SUCCESS)
PDH_FUNCTION
PdhGetCounterInfoW(
    __in    PDH_HCOUNTER hCounter,
    __in    BOOLEAN      bRetrieveExplainText,
    __inout LPDWORD      pdwBufferSize,
    __out_bcount_opt(* pdwBufferSize) PPDH_COUNTER_INFO_W lpBuffer
);

__success(return == ERROR_SUCCESS)
PDH_FUNCTION
PdhGetCounterInfoA(
    __in    PDH_HCOUNTER hCounter,
    __in    BOOLEAN      bRetrieveExplainText,
    __inout LPDWORD      pdwBufferSize,
    __out_bcount_opt(* pdwBufferSize) PPDH_COUNTER_INFO_A lpBuffer
);

#define PDH_MAX_SCALE  (7L)
#define PDH_MIN_SCALE (-7L)

PDH_FUNCTION
PdhSetCounterScaleFactor(
    __inout PDH_HCOUNTER hCounter,
    __in    LONG         lFactor
);
//
//   Browsing and enumeration functions
//
PDH_FUNCTION
PdhConnectMachineW(
    __in_opt LPCWSTR szMachineName
);

PDH_FUNCTION
PdhConnectMachineA(
    __in_opt LPCSTR szMachineName
);

PDH_FUNCTION
PdhEnumMachinesW(
    __in_opt LPCWSTR szDataSource,
    __out_ecount_opt(* pcchBufferSize)__nullnullterminated LPWSTR mszMachineList,
    __inout LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhEnumMachinesA(
    __in_opt LPCSTR  szDataSource,
    __out_ecount_opt(* pcchBufferSize)__nullnullterminated LPSTR mszMachineList,
    __inout LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhEnumObjectsW(
    __in_opt LPCWSTR szDataSource,
    __in_opt LPCWSTR szMachineName,
    __out_ecount_opt(* pcchBufferSize)__nullnullterminated LPWSTR  mszObjectList,
    __inout  LPDWORD pcchBufferSize,
    __in     DWORD   dwDetailLevel,
    __in     BOOL    bRefresh
);

PDH_FUNCTION
PdhEnumObjectsA(
    __in_opt LPCSTR  szDataSource,
    __in_opt LPCSTR  szMachineName,
    __out_ecount_opt(* pcchBufferSize)__nullnullterminated LPSTR   mszObjectList,
    __inout  LPDWORD pcchBufferSize,
    __in     DWORD   dwDetailLevel,
    __in     BOOL    bRefresh
);

PDH_FUNCTION
PdhEnumObjectItemsW(
    __in_opt LPCWSTR szDataSource,
    __in_opt LPCWSTR szMachineName,
    __in     LPCWSTR szObjectName,
    __out_ecount_opt(* pcchCounterListLength)__nullnullterminated  LPWSTR  mszCounterList,
    __inout  LPDWORD pcchCounterListLength,
    __out_ecount_opt(* pcchInstanceListLength)__nullnullterminated LPWSTR  mszInstanceList,
    __inout  LPDWORD pcchInstanceListLength,
    __in     DWORD   dwDetailLevel,
    __in     DWORD   dwFlags
);

PDH_FUNCTION
PdhEnumObjectItemsA(
    __in_opt LPCSTR  szDataSource,
    __in_opt LPCSTR  szMachineName,
    __in     LPCSTR  szObjectName,
    __out_ecount_opt(* pcchCounterListLength)__nullnullterminated  LPSTR   mszCounterList,
    __inout  LPDWORD pcchCounterListLength,
    __out_ecount_opt(* pcchInstanceListLength)__nullnullterminated LPSTR   mszInstanceList,
    __inout  LPDWORD pcchInstanceListLength,
    __in     DWORD   dwDetailLevel,
    __in     DWORD   dwFlags
);

PDH_FUNCTION
PdhMakeCounterPathW(
    __in    PPDH_COUNTER_PATH_ELEMENTS_W pCounterPathElements,
    __out_ecount_opt(* pcchBufferSize)   LPWSTR szFullPathBuffer,
    __inout LPDWORD                      pcchBufferSize,
    __in    DWORD                        dwFlags
);

PDH_FUNCTION
PdhMakeCounterPathA(
    __in    PPDH_COUNTER_PATH_ELEMENTS_A pCounterPathElements,
    __out_ecount_opt(* pcchBufferSize)   LPSTR szFullPathBuffer,
    __inout LPDWORD                      pcchBufferSize,
    __in    DWORD                        dwFlags
);

__success(return == ERROR_SUCCESS)
PDH_FUNCTION
PdhParseCounterPathW(
    __in    LPCWSTR                   szFullPathBuffer,
    __out_bcount_opt(* pdwBufferSize) PPDH_COUNTER_PATH_ELEMENTS_W pCounterPathElements,
    __inout LPDWORD                   pdwBufferSize,
    __in    DWORD                     dwFlags
);

__success(return == ERROR_SUCCESS)
PDH_FUNCTION
PdhParseCounterPathA(
    __in    LPCSTR                    szFullPathBuffer,
    __out_bcount_opt(* pdwBufferSize) PPDH_COUNTER_PATH_ELEMENTS_A pCounterPathElements,
    __inout LPDWORD                   pdwBufferSize,
    __in    DWORD                     dwFlags
);

#define PDH_PATH_WBEM_RESULT ((DWORD) 0x00000001)
#define PDH_PATH_WBEM_INPUT  ((DWORD) 0x00000002)

#define PDH_PATH_LANG_FLAGS(LangId, Flags)  ((DWORD)(((LangId & 0x0000FFFF) << 16) | (Flags & 0x0000FFFF)))

PDH_FUNCTION
PdhParseInstanceNameW(
    __in    LPCWSTR szInstanceString,
    __out_ecount_opt(* pcchInstanceNameLength) LPWSTR  szInstanceName,
    __inout LPDWORD pcchInstanceNameLength,
    __out_ecount_opt(* pcchParentNameLength)   LPWSTR  szParentName,
    __inout LPDWORD pcchParentNameLength,
    __out   LPDWORD lpIndex
);

PDH_FUNCTION
PdhParseInstanceNameA(
    __in    LPCSTR  szInstanceString,
    __out_ecount_opt(* pcchInstanceNameLength) LPSTR   szInstanceName,
    __inout LPDWORD pcchInstanceNameLength,
    __out_ecount_opt(* pcchParentNameLength)   LPSTR   szParentName,
    __inout LPDWORD pcchParentNameLength,
    __out   LPDWORD lpIndex
);

PDH_FUNCTION
PdhValidatePathW(
    __in LPCWSTR szFullPathBuffer
);

PDH_FUNCTION
PdhValidatePathA(
    __in LPCSTR szFullPathBuffer
);

PDH_FUNCTION
PdhGetDefaultPerfObjectW(
    __in_opt LPCWSTR szDataSource,
    __in_opt LPCWSTR szMachineName,
    __out_ecount_opt(* pcchBufferSize) LPWSTR  szDefaultObjectName,
    __inout  LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfObjectA(
    __in_opt LPCSTR  szDataSource,
    __in_opt LPCSTR  szMachineName,
    __out_ecount_opt(* pcchBufferSize) LPSTR   szDefaultObjectName,
    __inout  LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfCounterW(
    __in_opt LPCWSTR szDataSource,
    __in_opt LPCWSTR szMachineName,
    __in     LPCWSTR szObjectName,
    __out_ecount_opt(* pcchBufferSize) LPWSTR  szDefaultCounterName,
    __inout  LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfCounterA(
    __in_opt LPCSTR  szDataSource,
    __in_opt LPCSTR  szMachineName,
    __in     LPCSTR  szObjectName,
    __out_ecount_opt(* pcchBufferSize) LPSTR   szDefaultCounterName,
    __inout  LPDWORD pcchBufferSize
);

typedef PDH_STATUS (__stdcall * CounterPathCallBack)(DWORD_PTR);

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning ( disable : 4214 )  // Disable warning messages

#if (_WIN32_WINDOWS >= 0x0501 || _WIN32_WINNT >= 0x0501 || (defined(NTDDI_VERSION) && NTDDI_VERSION >= NTDDI_WINXP))
typedef struct _BrowseDlgConfig_HW {
    // Configuration flags
    DWORD   bIncludeInstanceIndex:1,
            bSingleCounterPerAdd:1,
            bSingleCounterPerDialog:1,
            bLocalCountersOnly:1,
            bWildCardInstances:1,
            bHideDetailBox:1,
            bInitializePath:1,
            bDisableMachineSelection:1,
            bIncludeCostlyObjects:1,
            bShowObjectBrowser:1,
            bReserved:22;

    HWND                hWndOwner;
    PDH_HLOG            hDataSource;
    LPWSTR              szReturnPathBuffer;
    DWORD               cchReturnPathLength;
    CounterPathCallBack pCallBack;
    DWORD_PTR           dwCallBackArg;
    PDH_STATUS          CallBackStatus;
    DWORD               dwDefaultDetailLevel;
    LPWSTR              szDialogBoxCaption;
} PDH_BROWSE_DLG_CONFIG_HW, * PPDH_BROWSE_DLG_CONFIG_HW;

typedef struct _BrowseDlgConfig_HA {
    // Configuration flags
    DWORD   bIncludeInstanceIndex:1,
            bSingleCounterPerAdd:1,
            bSingleCounterPerDialog:1,
            bLocalCountersOnly:1,
            bWildCardInstances:1,
            bHideDetailBox:1,
            bInitializePath:1,
            bDisableMachineSelection:1,
            bIncludeCostlyObjects:1,
            bShowObjectBrowser:1,
            bReserved:22;

    HWND                hWndOwner;
    PDH_HLOG            hDataSource;
    LPSTR               szReturnPathBuffer;
    DWORD               cchReturnPathLength;
    CounterPathCallBack pCallBack;
    DWORD_PTR           dwCallBackArg;
    PDH_STATUS          CallBackStatus;
    DWORD               dwDefaultDetailLevel;
    LPSTR               szDialogBoxCaption;
} PDH_BROWSE_DLG_CONFIG_HA, * PPDH_BROWSE_DLG_CONFIG_HA;

typedef struct _BrowseDlgConfig_W {
    // Configuration flags
    DWORD   bIncludeInstanceIndex:1,
            bSingleCounterPerAdd:1,
            bSingleCounterPerDialog:1,
            bLocalCountersOnly:1,
            bWildCardInstances:1,
            bHideDetailBox:1,
            bInitializePath:1,
            bDisableMachineSelection:1,
            bIncludeCostlyObjects:1,
            bShowObjectBrowser:1,
            bReserved:22;

    HWND                hWndOwner;
    LPWSTR              szDataSource;
    LPWSTR              szReturnPathBuffer;
    DWORD               cchReturnPathLength;
    CounterPathCallBack pCallBack;
    DWORD_PTR           dwCallBackArg;
    PDH_STATUS          CallBackStatus;
    DWORD               dwDefaultDetailLevel;
    LPWSTR              szDialogBoxCaption;
} PDH_BROWSE_DLG_CONFIG_W, * PPDH_BROWSE_DLG_CONFIG_W;

typedef struct _BrowseDlgConfig_A {
    // Configuration flags
    DWORD   bIncludeInstanceIndex:1,
            bSingleCounterPerAdd:1,
            bSingleCounterPerDialog:1,
            bLocalCountersOnly:1,
            bWildCardInstances:1,
            bHideDetailBox:1,
            bInitializePath:1,
            bDisableMachineSelection:1,
            bIncludeCostlyObjects:1,
            bShowObjectBrowser:1,
            bReserved:22;

    HWND                hWndOwner;
    LPSTR               szDataSource;
    __field_ecount(cchReturnPathLength) LPSTR               szReturnPathBuffer;
    DWORD               cchReturnPathLength;
    CounterPathCallBack pCallBack;
    DWORD_PTR           dwCallBackArg;
    PDH_STATUS          CallBackStatus;
    DWORD               dwDefaultDetailLevel;
    LPSTR               szDialogBoxCaption;
} PDH_BROWSE_DLG_CONFIG_A, * PPDH_BROWSE_DLG_CONFIG_A;
#else

typedef struct _BrowseDlgConfig_W {
    // Configuration flags
    DWORD   bIncludeInstanceIndex:1,
            bSingleCounterPerAdd:1,
            bSingleCounterPerDialog:1,
            bLocalCountersOnly:1,
            bWildCardInstances:1,
            bHideDetailBox:1,
            bInitializePath:1,
            bDisableMachineSelection:1,
            bIncludeCostlyObjects:1,
            bReserved:23;

    HWND                hWndOwner;
    LPWSTR              szDataSource;
    LPWSTR              szReturnPathBuffer;
    DWORD               cchReturnPathLength;
    CounterPathCallBack pCallBack;
    DWORD_PTR           dwCallBackArg;
    PDH_STATUS          CallBackStatus;
    DWORD               dwDefaultDetailLevel;
    LPWSTR              szDialogBoxCaption;
} PDH_BROWSE_DLG_CONFIG_W, * PPDH_BROWSE_DLG_CONFIG_W;

typedef struct _BrowseDlgConfig_A {
    // Configuration flags
    DWORD   bIncludeInstanceIndex:1,
            bSingleCounterPerAdd:1,
            bSingleCounterPerDialog:1,
            bLocalCountersOnly:1,
            bWildCardInstances:1,
            bHideDetailBox:1,
            bInitializePath:1,
            bDisableMachineSelection:1,
            bIncludeCostlyObjects:1,
            bReserved:23;

    HWND                hWndOwner;
    LPSTR               szDataSource;
    LPSTR               szReturnPathBuffer;
    DWORD               cchReturnPathLength;
    CounterPathCallBack pCallBack;
    DWORD_PTR           dwCallBackArg;
    PDH_STATUS          CallBackStatus;
    DWORD               dwDefaultDetailLevel;
    LPSTR               szDialogBoxCaption;
} PDH_BROWSE_DLG_CONFIG_A, * PPDH_BROWSE_DLG_CONFIG_A;
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning ( default : 4214 )
#endif

PDH_FUNCTION
PdhBrowseCountersW(
    __in PPDH_BROWSE_DLG_CONFIG_W pBrowseDlgData
);

PDH_FUNCTION
PdhBrowseCountersA(
    __in PPDH_BROWSE_DLG_CONFIG_A pBrowseDlgData
);

PDH_FUNCTION
PdhExpandCounterPathW(
    __in    LPCWSTR szWildCardPath,
    __out_ecount_opt(* pcchPathListLength)__nullnullterminated LPWSTR  mszExpandedPathList,
    __inout LPDWORD pcchPathListLength
);

PDH_FUNCTION
PdhExpandCounterPathA(
    __in    LPCSTR  szWildCardPath,
    __out_ecount_opt(* pcchPathListLength)__nullnullterminated LPSTR   mszExpandedPathList,
    __inout LPDWORD pcchPathListLength
);

//
//  v2.0 functions
//
PDH_FUNCTION
PdhLookupPerfNameByIndexW(
    __in_opt LPCWSTR szMachineName,
    __in     DWORD   dwNameIndex,
    __out_ecount_opt(* pcchNameBufferSize) LPWSTR  szNameBuffer,
    __inout  LPDWORD pcchNameBufferSize
);

PDH_FUNCTION
PdhLookupPerfNameByIndexA(
    __in_opt LPCSTR  szMachineName,
    __in     DWORD   dwNameIndex,
    __out_ecount_opt(* pcchNameBufferSize) LPSTR   szNameBuffer,
    __inout  LPDWORD pcchNameBufferSize
);

PDH_FUNCTION
PdhLookupPerfIndexByNameW(
    __in_opt LPCWSTR szMachineName,
    __in     LPCWSTR szNameBuffer,
    __out    LPDWORD pdwIndex
);

PDH_FUNCTION
PdhLookupPerfIndexByNameA(
    __in_opt LPCSTR  szMachineName,
    __in     LPCSTR  szNameBuffer,
    __out    LPDWORD pdwIndex
);

#define PDH_NOEXPANDCOUNTERS    1
#define PDH_NOEXPANDINSTANCES   2
#if (_WIN32_WINDOWS >= 0x0502 || _WIN32_WINNT >= 0x0502 || (defined(NTDDI_VERSION) && NTDDI_VERSION >= NTDDI_WIN2003))
#define PDH_REFRESHCOUNTERS     4
#endif

PDH_FUNCTION
PdhExpandWildCardPathA(
    __in_opt LPCSTR  szDataSource,
    __in     LPCSTR  szWildCardPath,
    __out_ecount_opt(* pcchPathListLength)__nullnullterminated LPSTR   mszExpandedPathList,
    __inout  LPDWORD pcchPathListLength,
    __in     DWORD   dwFlags
);

PDH_FUNCTION
PdhExpandWildCardPathW(
    __in_opt LPCWSTR szDataSource,
    __in     LPCWSTR szWildCardPath,
    __out_ecount_opt(* pcchPathListLength)__nullnullterminated LPWSTR  mszExpandedPathList,
    __inout  LPDWORD pcchPathListLength,
    __in     DWORD   dwFlags
);

//
//   Logging Functions
//

#define PDH_LOG_READ_ACCESS      ((DWORD) 0x00010000)
#define PDH_LOG_WRITE_ACCESS     ((DWORD) 0x00020000)
#define PDH_LOG_UPDATE_ACCESS    ((DWORD) 0x00040000)
#define PDH_LOG_ACCESS_MASK      ((DWORD) 0x000F0000)

#define PDH_LOG_CREATE_NEW       ((DWORD) 0x00000001)
#define PDH_LOG_CREATE_ALWAYS    ((DWORD) 0x00000002)
#define PDH_LOG_OPEN_ALWAYS      ((DWORD) 0x00000003)
#define PDH_LOG_OPEN_EXISTING    ((DWORD) 0x00000004)
#define PDH_LOG_CREATE_MASK      ((DWORD) 0x0000000F)

#define PDH_LOG_OPT_USER_STRING  ((DWORD) 0x01000000)
#define PDH_LOG_OPT_CIRCULAR     ((DWORD) 0x02000000)
#define PDH_LOG_OPT_MAX_IS_BYTES ((DWORD) 0x04000000)
#if (_WIN32_WINDOWS >= 0x0501 || _WIN32_WINNT >= 0x0501 || (defined(NTDDI_VERSION) && NTDDI_VERSION >= NTDDI_WINXP))
#define PDH_LOG_OPT_APPEND       ((DWORD) 0x08000000)
#endif
#define PDH_LOG_OPT_MASK         ((DWORD) 0x0F000000)

#define PDH_LOG_TYPE_UNDEFINED      0
#define PDH_LOG_TYPE_CSV            1
#define PDH_LOG_TYPE_TSV            2
#define PDH_LOG_TYPE_TRACE_KERNEL   4
#define PDH_LOG_TYPE_TRACE_GENERIC  5
#define PDH_LOG_TYPE_PERFMON        6
#if (_WIN32_WINDOWS >= 0x0501 || _WIN32_WINNT >= 0x0501 || (defined(NTDDI_VERSION) && NTDDI_VERSION >= NTDDI_WINXP))
//#define PDH_LOG_TYPE_BINARY         3 // this is the retired binary format
#define PDH_LOG_TYPE_SQL            7
#define PDH_LOG_TYPE_BINARY         8
#else
#define PDH_LOG_TYPE_BINARY         3
#endif

PDH_FUNCTION
PdhOpenLogW(
    __in     LPCWSTR     szLogFileName,
    __in     DWORD       dwAccessFlags,
    __inout  LPDWORD     lpdwLogType,
    __in_opt PDH_HQUERY  hQuery,
    __in     DWORD       dwMaxSize,
    __in_opt LPCWSTR     szUserCaption,
    __out    PDH_HLOG  * phLog
);

PDH_FUNCTION
PdhOpenLogA(
    __in     LPCSTR       szLogFileName,
    __in     DWORD        dwAccessFlags,
    __inout  LPDWORD      lpdwLogType,
    __in_opt PDH_HQUERY   hQuery,
    __in     DWORD        dwMaxSize,
    __in_opt LPCSTR       szUserCaption,
    __out    PDH_HLOG   * phLog
);

PDH_FUNCTION
PdhUpdateLogW(
    __in     PDH_HLOG hLog,
    __in_opt LPCWSTR  szUserString
);

PDH_FUNCTION
PdhUpdateLogA(
    __in     PDH_HLOG hLog,
    __in_opt LPCSTR   szUserString
);

PDH_FUNCTION
PdhUpdateLogFileCatalog(
    __in PDH_HLOG hLog
);

PDH_FUNCTION
PdhGetLogFileSize(
    __in  PDH_HLOG   hLog,
    __out LONGLONG * llSize
);

PDH_FUNCTION
PdhCloseLog(
    __in PDH_HLOG hLog,
    __in DWORD    dwFlags
);

#define PDH_FLAGS_CLOSE_QUERY   ((DWORD) 0x00000001)
//
//  Data source selection dialog
//
#define PDH_FLAGS_FILE_BROWSER_ONLY ((DWORD) 0x00000001)

PDH_FUNCTION
PdhSelectDataSourceW(
    __in    HWND    hWndOwner,
    __in    DWORD   dwFlags,
    __inout_ecount(* pcchBufferLength) LPWSTR  szDataSource,
    __inout LPDWORD pcchBufferLength
);

PDH_FUNCTION
PdhSelectDataSourceA(
    __in    HWND    hWndOwner,
    __in    DWORD   dwFlags,
    __inout_ecount(* pcchBufferLength) LPSTR   szDataSource,
    __inout LPDWORD pcchBufferLength
);

BOOL
PdhIsRealTimeQuery(
    __in PDH_HQUERY hQuery
);

PDH_FUNCTION
PdhSetQueryTimeRange(
    __in PDH_HQUERY     hQuery,
    __in PPDH_TIME_INFO pInfo
);

__success(return == ERROR_SUCCESS)
PDH_FUNCTION
PdhGetDataSourceTimeRangeW(
    __in_opt LPCWSTR  szDataSource,
    __out    LPDWORD  pdwNumEntries,
    __out_bcount(* pdwBufferSize)    PPDH_TIME_INFO pInfo,
    __inout  LPDWORD  pdwBufferSize
);

__success(return == ERROR_SUCCESS)
PDH_FUNCTION
PdhGetDataSourceTimeRangeA(
    __in_opt LPCSTR   szDataSource,
    __out    LPDWORD  pdwNumEntries,
    __out_bcount(* pdwBufferSize) PPDH_TIME_INFO pInfo,
    __inout  LPDWORD  pdwBufferSize
);

PDH_FUNCTION
PdhCollectQueryDataEx(
    __in PDH_HQUERY hQuery,
    __in DWORD      dwIntervalTime,
    __in HANDLE     hNewDataEvent
);

PDH_FUNCTION
PdhFormatFromRawValue(
    __in  DWORD                   dwCounterType,
    __in  DWORD                   dwFormat,
    __in  LONGLONG              * pTimeBase,
    __in  PPDH_RAW_COUNTER        pRawValue1,
    __in  PPDH_RAW_COUNTER        pRawValue2,
    __out PPDH_FMT_COUNTERVALUE   pFmtValue
);

PDH_FUNCTION
PdhGetCounterTimeBase(
    __in  PDH_HCOUNTER   hCounter,
    __out LONGLONG     * pTimeBase
);

__success(return == ERROR_SUCCESS)
PDH_FUNCTION
PdhReadRawLogRecord(
    __in    PDH_HLOG  hLog,
    __in    FILETIME  ftRecord,
    __out_bcount_opt(* pdwBufferLength) PPDH_RAW_LOG_RECORD pRawLogRecord,
    __inout LPDWORD   pdwBufferLength
);


#define DATA_SOURCE_REGISTRY ((DWORD) 0x00000001)
#define DATA_SOURCE_LOGFILE  ((DWORD) 0x00000002)
#define DATA_SOURCE_WBEM     ((DWORD) 0x00000004)

PDH_FUNCTION
PdhSetDefaultRealTimeDataSource(
    __in DWORD dwDataSourceId
);

#if (_WIN32_WINDOWS >= 0x0501 || _WIN32_WINNT >= 0x0501 || (defined(NTDDI_VERSION) && NTDDI_VERSION >= NTDDI_WINXP))
// Extended API for WMI event trace logfile format
//
PDH_FUNCTION
PdhBindInputDataSourceW(
    __out    PDH_HLOG * phDataSource,
    __in_opt LPCWSTR    LogFileNameList
);

PDH_FUNCTION
PdhBindInputDataSourceA(
    __out    PDH_HLOG * phDataSource,
    __in_opt LPCSTR     LogFileNameList
);

PDH_FUNCTION
PdhOpenQueryH(
    __in_opt  PDH_HLOG     hDataSource,
    __in      DWORD_PTR    dwUserData,
    __out     PDH_HQUERY * phQuery
);

PDH_FUNCTION
PdhEnumMachinesHW(
    __in_opt PDH_HLOG hDataSource,
    __out_ecount_opt(* pcchBufferSize)__nullnullterminated LPWSTR   mszMachineList,
    __inout  LPDWORD  pcchBufferSize
);

PDH_FUNCTION
PdhEnumMachinesHA(
    __in_opt PDH_HLOG hDataSource,
    __out_ecount_opt(* pcchBufferSize)__nullnullterminated LPSTR    mszMachineList,
    __inout  LPDWORD  pcchBufferSize
);

PDH_FUNCTION
PdhEnumObjectsHW(
    __in_opt PDH_HLOG hDataSource,
    __in_opt LPCWSTR  szMachineName,
    __out_ecount_opt(* pcchBufferSize)__nullnullterminated LPWSTR   mszObjectList,
    __inout  LPDWORD  pcchBufferSize,
    __in     DWORD    dwDetailLevel,
    __in     BOOL     bRefresh
) ;

PDH_FUNCTION
PdhEnumObjectsHA(
    __in_opt PDH_HLOG hDataSource,
    __in_opt LPCSTR   szMachineName,
    __out_ecount_opt(* pcchBufferSize)__nullnullterminated LPSTR    mszObjectList,
    __inout  LPDWORD  pcchBufferSize,
    __in     DWORD    dwDetailLevel,
    __in     BOOL     bRefresh
);

PDH_FUNCTION
PdhEnumObjectItemsHW(
    __in_opt PDH_HLOG hDataSource,
    __in_opt LPCWSTR  szMachineName,
    __in     LPCWSTR  szObjectName,
    __out_ecount_opt(* pcchCounterListLength)__nullnullterminated LPWSTR   mszCounterList,
    __inout  LPDWORD  pcchCounterListLength,
    __out_ecount_opt(* pcchInstanceListLength)__nullnullterminated LPWSTR   mszInstanceList,
    __inout  LPDWORD  pcchInstanceListLength,
    __in     DWORD    dwDetailLevel,
    __in     DWORD    dwFlags
);

PDH_FUNCTION
PdhEnumObjectItemsHA(
    __in_opt PDH_HLOG hDataSource,
    __in_opt LPCSTR   szMachineName,
    __in     LPCSTR   szObjectName,
    __out_ecount_opt(* pcchCounterListLength)__nullnullterminated LPSTR    mszCounterList,
    __inout  LPDWORD  pcchCounterListLength,
    __out_ecount_opt(* pcchInstanceListLength)__nullnullterminated LPSTR    mszInstanceList,
    __inout  LPDWORD  pcchInstanceListLength,
    __in     DWORD    dwDetailLevel,
    __in     DWORD    dwFlags
);

PDH_FUNCTION
PdhExpandWildCardPathHW(
    __in_opt PDH_HLOG hDataSource,
    __in     LPCWSTR  szWildCardPath,
    __out_ecount_opt(* pcchPathListLength)__nullnullterminated LPWSTR   mszExpandedPathList,
    __inout  LPDWORD  pcchPathListLength,
    __in    DWORD    dwFlags
);

PDH_FUNCTION
PdhExpandWildCardPathHA(
    __in_opt PDH_HLOG hDataSource,
    __in     LPCSTR   szWildCardPath,
    __out_ecount_opt(* pcchPathListLength)__nullnullterminated LPSTR    mszExpandedPathList,
    __inout  LPDWORD  pcchPathListLength,
    __in    DWORD    dwFlags
);

__success(return == ERROR_SUCCESS)
PDH_FUNCTION
PdhGetDataSourceTimeRangeH(
    __inout_opt PDH_HLOG hDataSource,
    __out       LPDWORD  pdwNumEntries,
    __out_bcount(* pdwBufferSize) PPDH_TIME_INFO pInfo,
    __inout  LPDWORD  pdwBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfObjectHW(
    __in_opt PDH_HLOG hDataSource,
    __in_opt LPCWSTR  szMachineName,
    __out_ecount_opt(* pcchBufferSize) LPWSTR   szDefaultObjectName,
    __inout  LPDWORD  pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfObjectHA(
    __in_opt PDH_HLOG hDataSource,
    __in_opt LPCSTR   szMachineName,
    __out_ecount_opt(* pcchBufferSize) LPSTR    szDefaultObjectName,
    __inout  LPDWORD  pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfCounterHW(
    __in_opt PDH_HLOG hDataSource,
    __in_opt LPCWSTR  szMachineName,
    __in     LPCWSTR  szObjectName,
    __out_ecount_opt(* pcchBufferSize) LPWSTR   szDefaultCounterName,
    __inout  LPDWORD  pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfCounterHA(
    __in_opt PDH_HLOG hDataSource,
    __in_opt LPCSTR   szMachineName,
    __in     LPCSTR   szObjectName,
    __out_ecount_opt(* pcchBufferSize) LPSTR    szDefaultCounterName,
    __inout  LPDWORD  pcchBufferSize
);

PDH_FUNCTION
PdhBrowseCountersHW(
    __in PPDH_BROWSE_DLG_CONFIG_HW pBrowseDlgData
);

PDH_FUNCTION
PdhBrowseCountersHA(
    __in PPDH_BROWSE_DLG_CONFIG_HA pBrowseDlgData
);

//Check that a DSN points to a database that contains the correct Perfmon tables.
PDH_FUNCTION
PdhVerifySQLDBW(
    __in LPCWSTR szDataSource
);

PDH_FUNCTION
PdhVerifySQLDBA(
    __in LPCSTR szDataSource
);


//Create the correct perfmon tables in the database pointed to by a DSN.
PDH_FUNCTION
PdhCreateSQLTablesW(
    __in LPCWSTR szDataSource
);  

PDH_FUNCTION
PdhCreateSQLTablesA(
    __in LPCSTR szDataSource
);     

//Return the list of Log set names in the database pointed to by the DSN.
PDH_FUNCTION
PdhEnumLogSetNamesW(
    __in    LPCWSTR szDataSource,
    __out_ecount_opt(* pcchBufferLength)__nullnullterminated LPWSTR  mszDataSetNameList,
    __inout LPDWORD pcchBufferLength
);

PDH_FUNCTION
PdhEnumLogSetNamesA(
    __in    LPCSTR  szDataSource,
    __out_ecount_opt(* pcchBufferLength)__nullnullterminated LPSTR   mszDataSetNameList,
    __inout LPDWORD pcchBufferLength
);

//Retrieve the GUID for an open Log Set
PDH_FUNCTION
PdhGetLogSetGUID(
    __in      PDH_HLOG   hLog,             
    __out_opt GUID     * pGuid,
    __out_opt int      * pRunId
);

//Set the RunID for an open Log Set
PDH_FUNCTION
PdhSetLogSetRunID(
    __inout PDH_HLOG hLog,             
    __in    int      RunId
);
#endif

//
//   Unicode/ANSI compatibility section
//
#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE
#endif
#endif

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE
#endif
#endif

#ifdef UNICODE
// start of UNICODE definitions
#define PdhOpenQuery                PdhOpenQueryW
#define PdhAddCounter               PdhAddCounterW
#if (_WIN32_WINDOWS >= 0x0600 || _WIN32_WINNT >= 0x0600 || (defined(NTDDI_VERSION) && NTDDI_VERSION >= NTDDI_LONGHORN))
#define PdhAddEnglishCounter        PdhAddEnglishCounterW
#define PdhValidatePathEx           PdhValidatePathExW
#endif
#define PdhGetCounterInfo           PdhGetCounterInfoW
#define PDH_COUNTER_INFO            PDH_COUNTER_INFO_W
#define PPDH_COUNTER_INFO           PPDH_COUNTER_INFO_W
#define PdhConnectMachine           PdhConnectMachineW
#define PdhEnumMachines             PdhEnumMachinesW
#define PdhEnumObjects              PdhEnumObjectsW
#define PdhEnumObjectItems          PdhEnumObjectItemsW
#define PdhMakeCounterPath          PdhMakeCounterPathW
#define PDH_COUNTER_PATH_ELEMENTS   PDH_COUNTER_PATH_ELEMENTS_W
#define PPDH_COUNTER_PATH_ELEMENTS  PPDH_COUNTER_PATH_ELEMENTS_W
#define PdhParseCounterPath         PdhParseCounterPathW
#define PdhParseInstanceName        PdhParseInstanceNameW
#define PdhValidatePath             PdhValidatePathW
#define PdhGetDefaultPerfObject     PdhGetDefaultPerfObjectW
#define PdhGetDefaultPerfCounter    PdhGetDefaultPerfCounterW
#define PdhBrowseCounters           PdhBrowseCountersW
#define PDH_BROWSE_DLG_CONFIG       PDH_BROWSE_DLG_CONFIG_W
#define PPDH_BROWSE_DLG_CONFIG      PPDH_BROWSE_DLG_CONFIG_W
#define PdhExpandCounterPath        PdhExpandCounterPathW
// v2.0 functions
#define PDH_FMT_COUNTERVALUE_ITEM   PDH_FMT_COUNTERVALUE_ITEM_W
#define PPDH_FMT_COUNTERVALUE_ITEM  PPDH_FMT_COUNTERVALUE_ITEM_W
#define PDH_RAW_COUNTER_ITEM        PDH_RAW_COUNTER_ITEM_W
#define PPDH_RAW_COUNTER_ITEM       PPDH_RAW_COUNTER_ITEM_W
#define PdhGetFormattedCounterArray PdhGetFormattedCounterArrayW
#define PdhGetRawCounterArray       PdhGetRawCounterArrayW
#define PdhLookupPerfNameByIndex    PdhLookupPerfNameByIndexW
#define PdhOpenLog                  PdhOpenLogW
#define PdhUpdateLog                PdhUpdateLogW
#define PdhSelectDataSource         PdhSelectDataSourceW
#define PdhGetDataSourceTimeRange   PdhGetDataSourceTimeRangeW
#define PDH_LOG_SERVICE_QUERY_INFO  PDH_LOG_SERVICE_QUERY_INFO_W
#define PPDH_LOG_SERVICE_QUERY_INFO PPDH_LOG_SERVICE_QUERY_INFO_W
#define PdhLogServiceControl        PdhLogServiceControlW
#define PdhLogServiceQuery          PdhLogServiceQueryW
#define PdhExpandWildCardPath       PdhExpandWildCardPathW

#if (_WIN32_WINDOWS >= 0x0501 || _WIN32_WINNT >= 0x0501 || (defined(NTDDI_VERSION) && NTDDI_VERSION >= NTDDI_WINXP))
#define PdhBindInputDataSource      PdhBindInputDataSourceW
#define PdhBrowseCountersH          PdhBrowseCountersHW
#define PDH_BROWSE_DLG_CONFIG_H     PDH_BROWSE_DLG_CONFIG_HW
#define PPDH_BROWSE_DLG_CONFIG_H    PPDH_BROWSE_DLG_CONFIG_HW
#define PdhEnumMachinesH            PdhEnumMachinesHW
#define PdhEnumObjectsH             PdhEnumObjectsHW
#define PdhEnumObjectItemsH         PdhEnumObjectItemsHW
#define PdhExpandWildCardPathH      PdhExpandWildCardPathHW
#define PdhGetDefaultPerfObjectH    PdhGetDefaultPerfObjectHW
#define PdhGetDefaultPerfCounterH   PdhGetDefaultPerfCounterHW
#define PdhEnumLogSetNames          PdhEnumLogSetNamesW
#define PdhCreateSQLTables          PdhCreateSQLTablesW
#define PdhVerifySQLDB              PdhVerifySQLDBW
#define PdhLookupPerfIndexByName    PdhLookupPerfIndexByNameW
#endif

// end of UNICODE definitions
#else
// start of ANSI definitions
#define PdhOpenQuery                PdhOpenQueryA
#define PdhAddCounter               PdhAddCounterA
#if (_WIN32_WINDOWS >= 0x0600 || _WINNT_WINNT >= 0x0600 || (defined(NTDDI_VERSION) && NTDDI_VERSION >= NTDDI_LONGHORN))
#define PdhAddEnglishCounter        PdhAddEnglishCounterA
#define PdhValidatePathEx           PdhValidatePathExA
#endif
#define PdhGetCounterInfo           PdhGetCounterInfoA
#define PDH_COUNTER_INFO            PDH_COUNTER_INFO_A
#define PPDH_COUNTER_INFO           PPDH_COUNTER_INFO_A
#define PdhConnectMachine           PdhConnectMachineA
#define PdhEnumMachines             PdhEnumMachinesA
#define PdhEnumObjects              PdhEnumObjectsA
#define PdhEnumObjectItems          PdhEnumObjectItemsA
#define PdhMakeCounterPath          PdhMakeCounterPathA
#define PDH_COUNTER_PATH_ELEMENTS   PDH_COUNTER_PATH_ELEMENTS_A
#define PPDH_COUNTER_PATH_ELEMENTS  PPDH_COUNTER_PATH_ELEMENTS_A
#define PdhParseCounterPath         PdhParseCounterPathA
#define PdhParseInstanceName        PdhParseInstanceNameA
#define PdhValidatePath             PdhValidatePathA
#define PdhGetDefaultPerfObject     PdhGetDefaultPerfObjectA
#define PdhGetDefaultPerfCounter    PdhGetDefaultPerfCounterA
#define PdhBrowseCounters           PdhBrowseCountersA
#define PDH_BROWSE_DLG_CONFIG       PDH_BROWSE_DLG_CONFIG_A
#define PPDH_BROWSE_DLG_CONFIG      PPDH_BROWSE_DLG_CONFIG_A
#define PdhExpandCounterPath        PdhExpandCounterPathA
// v2.0 functions
#define PDH_FMT_COUNTERVALUE_ITEM   PDH_FMT_COUNTERVALUE_ITEM_A
#define PPDH_FMT_COUNTERVALUE_ITEM  PPDH_FMT_COUNTERVALUE_ITEM_A
#define PDH_RAW_COUNTER_ITEM        PDH_RAW_COUNTER_ITEM_A
#define PPDH_RAW_COUNTER_ITEM       PPDH_RAW_COUNTER_ITEM_A
#define PdhGetFormattedCounterArray PdhGetFormattedCounterArrayA
#define PdhGetRawCounterArray       PdhGetRawCounterArrayA
#define PdhLookupPerfNameByIndex    PdhLookupPerfNameByIndexA
#define PdhOpenLog                  PdhOpenLogA
#define PdhUpdateLog                PdhUpdateLogA
#define PdhSelectDataSource         PdhSelectDataSourceA
#define PdhGetDataSourceTimeRange   PdhGetDataSourceTimeRangeA
#define PDH_LOG_SERVICE_QUERY_INFO  PDH_LOG_SERVICE_QUERY_INFO_A
#define PPDH_LOG_SERVICE_QUERY_INFO PPDH_LOG_SERVICE_QUERY_INFO_A
#define PdhLogServiceControl        PdhLogServiceControlA
#define PdhLogServiceQuery          PdhLogServiceQueryA
#define PdhExpandWildCardPath       PdhExpandWildCardPathA

#if (_WIN32_WINDOWS >= 0x0501 || _WIN32_WINNT >= 0x0501 || (defined(NTDDI_VERSION) && NTDDI_VERSION >= NTDDI_WINXP))
#define PdhBindInputDataSource      PdhBindInputDataSourceA
#define PDH_BROWSE_DLG_CONFIG_H     PDH_BROWSE_DLG_CONFIG_HA
#define PPDH_BROWSE_DLG_CONFIG_H    PPDH_BROWSE_DLG_CONFIG_HA
#define PdhBrowseCountersH          PdhBrowseCountersHA
#define PdhEnumMachinesH            PdhEnumMachinesHA
#define PdhEnumObjectsH             PdhEnumObjectsHA
#define PdhEnumObjectItemsH         PdhEnumObjectItemsHA
#define PdhExpandWildCardPathH      PdhExpandWildCardPathHA
#define PdhGetDefaultPerfObjectH    PdhGetDefaultPerfObjectHA
#define PdhGetDefaultPerfCounterH   PdhGetDefaultPerfCounterHA
#define PdhEnumLogSetNames          PdhEnumLogSetNamesA
#define PdhCreateSQLTables          PdhCreateSQLTablesA
#define PdhVerifySQLDB              PdhVerifySQLDBA
#define PdhLookupPerfIndexByName    PdhLookupPerfIndexByNameA
#endif

// end of ANSI definitions
#endif  // UNICODE

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning ( default : 4201 )
#endif


#ifdef __cplusplus
}
#endif

#endif //_PDH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\PdhMsg.h ===
#pragma once
EXTERN_C __declspec(selectany) const GUID S_PDH = {0x04d66358, 0xc4a1, 0x419b, {0x80, 0x23,0x23,0xb7,0x39,0x02,0xde,0x2c}};
#define S_PDH_CHANNEL_Application 0x9
#define MSG_Publisher_Name               0x90000001L

#define PDH_CSTATUS_VALID_DATA           0x00000000L

#define PDH_CSTATUS_NEW_DATA             0x00000001L

#define PDH_CSTATUS_NO_MACHINE           0x800007D0L

#define PDH_CSTATUS_NO_INSTANCE          0x800007D1L

#define PDH_MORE_DATA                    0x800007D2L

#define PDH_CSTATUS_ITEM_NOT_VALIDATED   0x800007D3L

#define PDH_RETRY                        0x800007D4L

#define PDH_NO_DATA                      0x800007D5L

#define PDH_CALC_NEGATIVE_DENOMINATOR    0x800007D6L

#define PDH_CALC_NEGATIVE_TIMEBASE       0x800007D7L

#define PDH_CALC_NEGATIVE_VALUE          0x800007D8L

#define PDH_DIALOG_CANCELLED             0x800007D9L

#define PDH_END_OF_LOG_FILE              0x800007DAL

#define PDH_ASYNC_QUERY_TIMEOUT          0x800007DBL

#define PDH_CANNOT_SET_DEFAULT_REALTIME_DATASOURCE 0x800007DCL

#define PDH_UNABLE_MAP_NAME_FILES        0x80000BD5L

#define PDH_PLA_VALIDATION_WARNING       0x80000BF3L

#define PDH_CSTATUS_NO_OBJECT            0xC0000BB8L

#define PDH_CSTATUS_NO_COUNTER           0xC0000BB9L

#define PDH_CSTATUS_INVALID_DATA         0xC0000BBAL

#define PDH_MEMORY_ALLOCATION_FAILURE    0xC0000BBBL

#define PDH_INVALID_HANDLE               0xC0000BBCL

#define PDH_INVALID_ARGUMENT             0xC0000BBDL

#define PDH_FUNCTION_NOT_FOUND           0xC0000BBEL

#define PDH_CSTATUS_NO_COUNTERNAME       0xC0000BBFL

#define PDH_CSTATUS_BAD_COUNTERNAME      0xC0000BC0L

#define PDH_INVALID_BUFFER               0xC0000BC1L

#define PDH_INSUFFICIENT_BUFFER          0xC0000BC2L

#define PDH_CANNOT_CONNECT_MACHINE       0xC0000BC3L

#define PDH_INVALID_PATH                 0xC0000BC4L

#define PDH_INVALID_INSTANCE             0xC0000BC5L

#define PDH_INVALID_DATA                 0xC0000BC6L

#define PDH_NO_DIALOG_DATA               0xC0000BC7L

#define PDH_CANNOT_READ_NAME_STRINGS     0xC0000BC8L

#define PDH_LOG_FILE_CREATE_ERROR        0xC0000BC9L

#define PDH_LOG_FILE_OPEN_ERROR          0xC0000BCAL

#define PDH_LOG_TYPE_NOT_FOUND           0xC0000BCBL

#define PDH_NO_MORE_DATA                 0xC0000BCCL

#define PDH_ENTRY_NOT_IN_LOG_FILE        0xC0000BCDL

#define PDH_DATA_SOURCE_IS_LOG_FILE      0xC0000BCEL

#define PDH_DATA_SOURCE_IS_REAL_TIME     0xC0000BCFL

#define PDH_UNABLE_READ_LOG_HEADER       0xC0000BD0L

#define PDH_FILE_NOT_FOUND               0xC0000BD1L

#define PDH_FILE_ALREADY_EXISTS          0xC0000BD2L

#define PDH_NOT_IMPLEMENTED              0xC0000BD3L

#define PDH_STRING_NOT_FOUND             0xC0000BD4L

#define PDH_UNKNOWN_LOG_FORMAT           0xC0000BD6L

#define PDH_UNKNOWN_LOGSVC_COMMAND       0xC0000BD7L

#define PDH_LOGSVC_QUERY_NOT_FOUND       0xC0000BD8L

#define PDH_LOGSVC_NOT_OPENED            0xC0000BD9L

#define PDH_WBEM_ERROR                   0xC0000BDAL

#define PDH_ACCESS_DENIED                0xC0000BDBL

#define PDH_LOG_FILE_TOO_SMALL           0xC0000BDCL

#define PDH_INVALID_DATASOURCE           0xC0000BDDL

#define PDH_INVALID_SQLDB                0xC0000BDEL

#define PDH_NO_COUNTERS                  0xC0000BDFL

#define PDH_SQL_ALLOC_FAILED             0xC0000BE0L

#define PDH_SQL_ALLOCCON_FAILED          0xC0000BE1L

#define PDH_SQL_EXEC_DIRECT_FAILED       0xC0000BE2L

#define PDH_SQL_FETCH_FAILED             0xC0000BE3L

#define PDH_SQL_ROWCOUNT_FAILED          0xC0000BE4L

#define PDH_SQL_MORE_RESULTS_FAILED      0xC0000BE5L

#define PDH_SQL_CONNECT_FAILED           0xC0000BE6L

#define PDH_SQL_BIND_FAILED              0xC0000BE7L

#define PDH_CANNOT_CONNECT_WMI_SERVER    0xC0000BE8L

#define PDH_PLA_COLLECTION_ALREADY_RUNNING 0xC0000BE9L

#define PDH_PLA_ERROR_SCHEDULE_OVERLAP   0xC0000BEAL

#define PDH_PLA_COLLECTION_NOT_FOUND     0xC0000BEBL

#define PDH_PLA_ERROR_SCHEDULE_ELAPSED   0xC0000BECL

#define PDH_PLA_ERROR_NOSTART            0xC0000BEDL

#define PDH_PLA_ERROR_ALREADY_EXISTS     0xC0000BEEL

#define PDH_PLA_ERROR_TYPE_MISMATCH      0xC0000BEFL

#define PDH_PLA_ERROR_FILEPATH           0xC0000BF0L

#define PDH_PLA_SERVICE_ERROR            0xC0000BF1L

#define PDH_PLA_VALIDATION_ERROR         0xC0000BF2L

#define PDH_PLA_ERROR_NAME_TOO_LONG      0xC0000BF4L

#define PDH_INVALID_SQL_LOG_FORMAT       0xC0000BF5L

#define PDH_COUNTER_ALREADY_IN_QUERY     0xC0000BF6L

#define PDH_BINARY_LOG_CORRUPT           0xC0000BF7L

#define PDH_LOG_SAMPLE_TOO_SMALL         0xC0000BF8L

#define PDH_OS_LATER_VERSION             0xC0000BF9L

#define PDH_OS_EARLIER_VERSION           0xC0000BFAL

#define PDH_INCORRECT_APPEND_TIME        0xC0000BFBL

#define PDH_UNMATCHED_APPEND_COUNTER     0xC0000BFCL

#define PDH_SQL_ALTER_DETAIL_FAILED      0xC0000BFDL

#define PDH_QUERY_PERF_DATA_TIMEOUT      0xC0000BFEL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\peninputpanel.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for peninputpanel.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __peninputpanel_h__
#define __peninputpanel_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPenInputPanel_FWD_DEFINED__
#define __IPenInputPanel_FWD_DEFINED__
typedef interface IPenInputPanel IPenInputPanel;
#endif 	/* __IPenInputPanel_FWD_DEFINED__ */


#ifndef ___IPenInputPanelEvents_FWD_DEFINED__
#define ___IPenInputPanelEvents_FWD_DEFINED__
typedef interface _IPenInputPanelEvents _IPenInputPanelEvents;
#endif 	/* ___IPenInputPanelEvents_FWD_DEFINED__ */


#ifndef __IHandwrittenTextInsertion_FWD_DEFINED__
#define __IHandwrittenTextInsertion_FWD_DEFINED__
typedef interface IHandwrittenTextInsertion IHandwrittenTextInsertion;
#endif 	/* __IHandwrittenTextInsertion_FWD_DEFINED__ */


#ifndef __HandwrittenTextInsertion_FWD_DEFINED__
#define __HandwrittenTextInsertion_FWD_DEFINED__

#ifdef __cplusplus
typedef class HandwrittenTextInsertion HandwrittenTextInsertion;
#else
typedef struct HandwrittenTextInsertion HandwrittenTextInsertion;
#endif /* __cplusplus */

#endif 	/* __HandwrittenTextInsertion_FWD_DEFINED__ */


#ifndef __PenInputPanel_FWD_DEFINED__
#define __PenInputPanel_FWD_DEFINED__

#ifdef __cplusplus
typedef class PenInputPanel PenInputPanel;
#else
typedef struct PenInputPanel PenInputPanel;
#endif /* __cplusplus */

#endif 	/* __PenInputPanel_FWD_DEFINED__ */


#ifndef __ITextInputPanelEventSink_FWD_DEFINED__
#define __ITextInputPanelEventSink_FWD_DEFINED__
typedef interface ITextInputPanelEventSink ITextInputPanelEventSink;
#endif 	/* __ITextInputPanelEventSink_FWD_DEFINED__ */


#ifndef __ITextInputPanel_FWD_DEFINED__
#define __ITextInputPanel_FWD_DEFINED__
typedef interface ITextInputPanel ITextInputPanel;
#endif 	/* __ITextInputPanel_FWD_DEFINED__ */


#ifndef __IInputPanelWindowHandle_FWD_DEFINED__
#define __IInputPanelWindowHandle_FWD_DEFINED__
typedef interface IInputPanelWindowHandle IInputPanelWindowHandle;
#endif 	/* __IInputPanelWindowHandle_FWD_DEFINED__ */


#ifndef __ITextInputPanelRunInfo_FWD_DEFINED__
#define __ITextInputPanelRunInfo_FWD_DEFINED__
typedef interface ITextInputPanelRunInfo ITextInputPanelRunInfo;
#endif 	/* __ITextInputPanelRunInfo_FWD_DEFINED__ */


#ifndef __TextInputPanel_FWD_DEFINED__
#define __TextInputPanel_FWD_DEFINED__

#ifdef __cplusplus
typedef class TextInputPanel TextInputPanel;
#else
typedef struct TextInputPanel TextInputPanel;
#endif /* __cplusplus */

#endif 	/* __TextInputPanel_FWD_DEFINED__ */


#ifndef __PenInputPanel_Internal_FWD_DEFINED__
#define __PenInputPanel_Internal_FWD_DEFINED__

#ifdef __cplusplus
typedef class PenInputPanel_Internal PenInputPanel_Internal;
#else
typedef struct PenInputPanel_Internal PenInputPanel_Internal;
#endif /* __cplusplus */

#endif 	/* __PenInputPanel_Internal_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "msinkaut.h"

#ifdef __cplusplus
extern "C"{
#endif 



#ifndef __PenInputPanelLib_LIBRARY_DEFINED__
#define __PenInputPanelLib_LIBRARY_DEFINED__

/* library PenInputPanelLib */
/* [helpcontext][helpstring][helpfile][version][uuid] */ 

#define MICROSOFT_PENINPUT_PANEL_PROPERTY_T	L"Microsoft PenInputPanel 1.5"
typedef /* [hidden] */ 
enum DISPID_PenInputPanel
    {	DISPID_PIPAttachedEditWindow	= DISPID_VALUE,
	DISPID_PIPFactoid	= ( DISPID_PIPAttachedEditWindow + 1 ) ,
	DISPID_PIPCurrentPanel	= ( DISPID_PIPFactoid + 1 ) ,
	DISPID_PIPDefaultPanel	= ( DISPID_PIPCurrentPanel + 1 ) ,
	DISPID_PIPVisible	= ( DISPID_PIPDefaultPanel + 1 ) ,
	DISPID_PIPTop	= ( DISPID_PIPVisible + 1 ) ,
	DISPID_PIPLeft	= ( DISPID_PIPTop + 1 ) ,
	DISPID_PIPWidth	= ( DISPID_PIPLeft + 1 ) ,
	DISPID_PIPHeight	= ( DISPID_PIPWidth + 1 ) ,
	DISPID_PIPMoveTo	= ( DISPID_PIPHeight + 1 ) ,
	DISPID_PIPCommitPendingInput	= ( DISPID_PIPMoveTo + 1 ) ,
	DISPID_PIPRefresh	= ( DISPID_PIPCommitPendingInput + 1 ) ,
	DISPID_PIPBusy	= ( DISPID_PIPRefresh + 1 ) ,
	DISPID_PIPVerticalOffset	= ( DISPID_PIPBusy + 1 ) ,
	DISPID_PIPHorizontalOffset	= ( DISPID_PIPVerticalOffset + 1 ) ,
	DISPID_PIPEnableTsf	= ( DISPID_PIPHorizontalOffset + 1 ) ,
	DISPID_PIPAutoShow	= ( DISPID_PIPEnableTsf + 1 ) 
    } 	DISPID_PenInputPanel;

typedef /* [hidden] */ 
enum DISPID_PenInputPanelEvents
    {	DISPID_PIPEVisibleChanged	= 0,
	DISPID_PIPEPanelChanged	= ( DISPID_PIPEVisibleChanged + 1 ) ,
	DISPID_PIPEInputFailed	= ( DISPID_PIPEPanelChanged + 1 ) ,
	DISPID_PIPEPanelMoving	= ( DISPID_PIPEInputFailed + 1 ) 
    } 	DISPID_PenInputPanelEvents;

typedef /* [uuid] */  DECLSPEC_UUID("7fd1134a-b2ba-4673-8d64-e28be4168e5d") 
enum VisualState
    {	InPlace	= 0,
	Floating	= 1,
	DockedTop	= 2,
	DockedBottom	= 3,
	Closed	= 4
    } 	VisualState;

typedef /* [public][public][uuid] */  DECLSPEC_UUID("500f9c5a-6739-449b-9cfa-5fc2f2e9ddce") 
enum __MIDL___MIDL_itf_peninputpanel_0000_0000_0001
    {	InteractionMode_InPlace	= 0,
	InteractionMode_Floating	= 1,
	InteractionMode_DockedTop	= 2,
	InteractionMode_DockedBottom	= 3
    } 	InteractionMode;

typedef /* [public][public][public][public][public][public][public][public][uuid] */  DECLSPEC_UUID("aa9bda6b-fc6a-49a3-9d7c-26b233690583") 
enum __MIDL___MIDL_itf_peninputpanel_0000_0000_0002
    {	InPlaceState_Auto	= 0,
	InPlaceState_HoverTarget	= 1,
	InPlaceState_Expanded	= 2
    } 	InPlaceState;

typedef /* [public][public][public][public][public][public][public][public][uuid] */  DECLSPEC_UUID("8b4f78bf-4253-4467-a006-670419caa993") 
enum __MIDL___MIDL_itf_peninputpanel_0000_0000_0003
    {	PanelInputArea_Auto	= 0,
	PanelInputArea_Keyboard	= 1,
	PanelInputArea_WritingPad	= 2,
	PanelInputArea_CharacterPad	= 3
    } 	PanelInputArea;

typedef /* [public][public][public][public][public][public][uuid] */  DECLSPEC_UUID("d708f745-981e-4e9b-afa0-98082aadb421") 
enum __MIDL___MIDL_itf_peninputpanel_0000_0000_0004
    {	CorrectionMode_NotVisible	= 0,
	CorrectionMode_PreInsertion	= 1,
	CorrectionMode_PostInsertionCollapsed	= 2,
	CorrectionMode_PostInsertionExpanded	= 3
    } 	CorrectionMode;

typedef /* [public][public][uuid] */  DECLSPEC_UUID("84ccefd0-9212-44e4-94e6-91562a94016e") 
enum __MIDL___MIDL_itf_peninputpanel_0000_0000_0005
    {	CorrectionPosition_Auto	= 0,
	CorrectionPosition_Bottom	= 1,
	CorrectionPosition_Top	= 2
    } 	CorrectionPosition;

typedef /* [public][public][public][uuid] */  DECLSPEC_UUID("619eab37-412f-44ca-996f-0f415fb8bc12") 
enum __MIDL___MIDL_itf_peninputpanel_0000_0000_0006
    {	InPlaceDirection_Auto	= 0,
	InPlaceDirection_Bottom	= 1,
	InPlaceDirection_Top	= 2
    } 	InPlaceDirection;

typedef /* [public][uuid] */  DECLSPEC_UUID("1ad3e1f7-4dd0-48c3-a89b-dfccba13d6f7") 
enum __MIDL___MIDL_itf_peninputpanel_0000_0000_0007
    {	EventMask_InPlaceStateChanging	= 1,
	EventMask_InPlaceStateChanged	= 2,
	EventMask_InPlaceSizeChanging	= 4,
	EventMask_InPlaceSizeChanged	= 8,
	EventMask_InputAreaChanging	= 16,
	EventMask_InputAreaChanged	= 32,
	EventMask_CorrectionModeChanging	= 64,
	EventMask_CorrectionModeChanged	= 128,
	EventMask_InPlaceVisibilityChanging	= 256,
	EventMask_InPlaceVisibilityChanged	= 512,
	EventMask_TextInserting	= 1024,
	EventMask_TextInserted	= 2048,
	EventMask_All	= ( ( ( ( ( ( ( ( ( ( ( EventMask_InPlaceStateChanging + EventMask_InPlaceStateChanged )  + EventMask_InPlaceSizeChanging )  + EventMask_InPlaceSizeChanged )  + EventMask_InputAreaChanging )  + EventMask_InputAreaChanged )  + EventMask_CorrectionModeChanging )  + EventMask_CorrectionModeChanged )  + EventMask_InPlaceVisibilityChanging )  + EventMask_InPlaceVisibilityChanged )  + EventMask_TextInserting )  + EventMask_TextInserted ) 
    } 	EventMask;


EXTERN_C const IID LIBID_PenInputPanelLib;

#ifndef __IPenInputPanel_INTERFACE_DEFINED__
#define __IPenInputPanel_INTERFACE_DEFINED__

/* interface IPenInputPanel */
/* [helpcontext][helpstring][unique][dual][uuid][object] */ 

typedef /* [helpcontext][helpstring] */ 
enum PanelType
    {	PT_Default	= 0,
	PT_Inactive	= ( PT_Default + 1 ) ,
	PT_Handwriting	= ( PT_Inactive + 1 ) ,
	PT_Keyboard	= ( PT_Handwriting + 1 ) 
    } 	PanelType;


EXTERN_C const IID IID_IPenInputPanel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fa7a4083-5747-4040-a182-0b0e9fd4fac7")
    IPenInputPanel : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Busy( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *Busy) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Factoid( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Factoid) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Factoid( 
            /* [in] */ __RPC__in BSTR Factoid) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AttachedEditWindow( 
            /* [retval][out] */ __RPC__out LONG32 *AttachedEditWindow) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_AttachedEditWindow( 
            /* [in] */ LONG32 AttachedEditWindow) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CurrentPanel( 
            /* [retval][out] */ __RPC__out PanelType *CurrentPanel) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_CurrentPanel( 
            /* [in] */ PanelType CurrentPanel) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DefaultPanel( 
            /* [retval][out] */ __RPC__out PanelType *pDefaultPanel) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DefaultPanel( 
            /* [in] */ PanelType DefaultPanel) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Visible( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *Visible) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Visible( 
            /* [in] */ VARIANT_BOOL Visible) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Top( 
            /* [retval][out] */ __RPC__out long *Top) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Left( 
            /* [retval][out] */ __RPC__out long *Left) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ __RPC__out long *Width) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ __RPC__out long *Height) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_VerticalOffset( 
            /* [retval][out] */ __RPC__out long *VerticalOffset) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_VerticalOffset( 
            /* [in] */ long VerticalOffset) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HorizontalOffset( 
            /* [retval][out] */ __RPC__out long *HorizontalOffset) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_HorizontalOffset( 
            /* [in] */ long HorizontalOffset) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AutoShow( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pAutoShow) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_AutoShow( 
            /* [in] */ VARIANT_BOOL AutoShow) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveTo( 
            /* [in] */ long Left,
            /* [in] */ long Top) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE CommitPendingInput( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE EnableTsf( 
            /* [in] */ VARIANT_BOOL Enable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPenInputPanelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPenInputPanel * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPenInputPanel * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPenInputPanel * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPenInputPanel * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPenInputPanel * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPenInputPanel * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPenInputPanel * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Busy )( 
            IPenInputPanel * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *Busy);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Factoid )( 
            IPenInputPanel * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Factoid);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Factoid )( 
            IPenInputPanel * This,
            /* [in] */ __RPC__in BSTR Factoid);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AttachedEditWindow )( 
            IPenInputPanel * This,
            /* [retval][out] */ __RPC__out LONG32 *AttachedEditWindow);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AttachedEditWindow )( 
            IPenInputPanel * This,
            /* [in] */ LONG32 AttachedEditWindow);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPanel )( 
            IPenInputPanel * This,
            /* [retval][out] */ __RPC__out PanelType *CurrentPanel);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentPanel )( 
            IPenInputPanel * This,
            /* [in] */ PanelType CurrentPanel);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultPanel )( 
            IPenInputPanel * This,
            /* [retval][out] */ __RPC__out PanelType *pDefaultPanel);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultPanel )( 
            IPenInputPanel * This,
            /* [in] */ PanelType DefaultPanel);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Visible )( 
            IPenInputPanel * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *Visible);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Visible )( 
            IPenInputPanel * This,
            /* [in] */ VARIANT_BOOL Visible);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Top )( 
            IPenInputPanel * This,
            /* [retval][out] */ __RPC__out long *Top);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Left )( 
            IPenInputPanel * This,
            /* [retval][out] */ __RPC__out long *Left);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Width )( 
            IPenInputPanel * This,
            /* [retval][out] */ __RPC__out long *Width);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Height )( 
            IPenInputPanel * This,
            /* [retval][out] */ __RPC__out long *Height);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_VerticalOffset )( 
            IPenInputPanel * This,
            /* [retval][out] */ __RPC__out long *VerticalOffset);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_VerticalOffset )( 
            IPenInputPanel * This,
            /* [in] */ long VerticalOffset);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HorizontalOffset )( 
            IPenInputPanel * This,
            /* [retval][out] */ __RPC__out long *HorizontalOffset);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_HorizontalOffset )( 
            IPenInputPanel * This,
            /* [in] */ long HorizontalOffset);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoShow )( 
            IPenInputPanel * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pAutoShow);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AutoShow )( 
            IPenInputPanel * This,
            /* [in] */ VARIANT_BOOL AutoShow);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *MoveTo )( 
            IPenInputPanel * This,
            /* [in] */ long Left,
            /* [in] */ long Top);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CommitPendingInput )( 
            IPenInputPanel * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IPenInputPanel * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnableTsf )( 
            IPenInputPanel * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        END_INTERFACE
    } IPenInputPanelVtbl;

    interface IPenInputPanel
    {
        CONST_VTBL struct IPenInputPanelVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPenInputPanel_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPenInputPanel_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPenInputPanel_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPenInputPanel_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IPenInputPanel_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IPenInputPanel_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IPenInputPanel_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IPenInputPanel_get_Busy(This,Busy)	\
    ( (This)->lpVtbl -> get_Busy(This,Busy) ) 

#define IPenInputPanel_get_Factoid(This,Factoid)	\
    ( (This)->lpVtbl -> get_Factoid(This,Factoid) ) 

#define IPenInputPanel_put_Factoid(This,Factoid)	\
    ( (This)->lpVtbl -> put_Factoid(This,Factoid) ) 

#define IPenInputPanel_get_AttachedEditWindow(This,AttachedEditWindow)	\
    ( (This)->lpVtbl -> get_AttachedEditWindow(This,AttachedEditWindow) ) 

#define IPenInputPanel_put_AttachedEditWindow(This,AttachedEditWindow)	\
    ( (This)->lpVtbl -> put_AttachedEditWindow(This,AttachedEditWindow) ) 

#define IPenInputPanel_get_CurrentPanel(This,CurrentPanel)	\
    ( (This)->lpVtbl -> get_CurrentPanel(This,CurrentPanel) ) 

#define IPenInputPanel_put_CurrentPanel(This,CurrentPanel)	\
    ( (This)->lpVtbl -> put_CurrentPanel(This,CurrentPanel) ) 

#define IPenInputPanel_get_DefaultPanel(This,pDefaultPanel)	\
    ( (This)->lpVtbl -> get_DefaultPanel(This,pDefaultPanel) ) 

#define IPenInputPanel_put_DefaultPanel(This,DefaultPanel)	\
    ( (This)->lpVtbl -> put_DefaultPanel(This,DefaultPanel) ) 

#define IPenInputPanel_get_Visible(This,Visible)	\
    ( (This)->lpVtbl -> get_Visible(This,Visible) ) 

#define IPenInputPanel_put_Visible(This,Visible)	\
    ( (This)->lpVtbl -> put_Visible(This,Visible) ) 

#define IPenInputPanel_get_Top(This,Top)	\
    ( (This)->lpVtbl -> get_Top(This,Top) ) 

#define IPenInputPanel_get_Left(This,Left)	\
    ( (This)->lpVtbl -> get_Left(This,Left) ) 

#define IPenInputPanel_get_Width(This,Width)	\
    ( (This)->lpVtbl -> get_Width(This,Width) ) 

#define IPenInputPanel_get_Height(This,Height)	\
    ( (This)->lpVtbl -> get_Height(This,Height) ) 

#define IPenInputPanel_get_VerticalOffset(This,VerticalOffset)	\
    ( (This)->lpVtbl -> get_VerticalOffset(This,VerticalOffset) ) 

#define IPenInputPanel_put_VerticalOffset(This,VerticalOffset)	\
    ( (This)->lpVtbl -> put_VerticalOffset(This,VerticalOffset) ) 

#define IPenInputPanel_get_HorizontalOffset(This,HorizontalOffset)	\
    ( (This)->lpVtbl -> get_HorizontalOffset(This,HorizontalOffset) ) 

#define IPenInputPanel_put_HorizontalOffset(This,HorizontalOffset)	\
    ( (This)->lpVtbl -> put_HorizontalOffset(This,HorizontalOffset) ) 

#define IPenInputPanel_get_AutoShow(This,pAutoShow)	\
    ( (This)->lpVtbl -> get_AutoShow(This,pAutoShow) ) 

#define IPenInputPanel_put_AutoShow(This,AutoShow)	\
    ( (This)->lpVtbl -> put_AutoShow(This,AutoShow) ) 

#define IPenInputPanel_MoveTo(This,Left,Top)	\
    ( (This)->lpVtbl -> MoveTo(This,Left,Top) ) 

#define IPenInputPanel_CommitPendingInput(This)	\
    ( (This)->lpVtbl -> CommitPendingInput(This) ) 

#define IPenInputPanel_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#define IPenInputPanel_EnableTsf(This,Enable)	\
    ( (This)->lpVtbl -> EnableTsf(This,Enable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPenInputPanel_INTERFACE_DEFINED__ */


#ifndef ___IPenInputPanelEvents_DISPINTERFACE_DEFINED__
#define ___IPenInputPanelEvents_DISPINTERFACE_DEFINED__

/* dispinterface _IPenInputPanelEvents */
/* [helpcontext][helpstring][uuid] */ 


EXTERN_C const IID DIID__IPenInputPanelEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("b7e489da-3719-439f-848f-e7acbd820f17")
    _IPenInputPanelEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _IPenInputPanelEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            _IPenInputPanelEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            _IPenInputPanelEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            _IPenInputPanelEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            _IPenInputPanelEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            _IPenInputPanelEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            _IPenInputPanelEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            _IPenInputPanelEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } _IPenInputPanelEventsVtbl;

    interface _IPenInputPanelEvents
    {
        CONST_VTBL struct _IPenInputPanelEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _IPenInputPanelEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define _IPenInputPanelEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define _IPenInputPanelEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define _IPenInputPanelEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define _IPenInputPanelEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define _IPenInputPanelEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define _IPenInputPanelEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___IPenInputPanelEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IHandwrittenTextInsertion_INTERFACE_DEFINED__
#define __IHandwrittenTextInsertion_INTERFACE_DEFINED__

/* interface IHandwrittenTextInsertion */
/* [helpstring][unique][uuid][object] */ 


EXTERN_C const IID IID_IHandwrittenTextInsertion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56FDEA97-ECD6-43e7-AA3A-816BE7785860")
    IHandwrittenTextInsertion : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InsertRecognitionResultsArray( 
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * psaAlternates,
            /* [in] */ LCID locale,
            /* [in] */ BOOL fAlternateContainsAutoSpacingInformation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertInkRecognitionResult( 
            /* [in] */ __RPC__in_opt IInkRecognitionResult *pIInkRecoResult,
            /* [in] */ LCID locale,
            /* [in] */ BOOL fAlternateContainsAutoSpacingInformation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHandwrittenTextInsertionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHandwrittenTextInsertion * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHandwrittenTextInsertion * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHandwrittenTextInsertion * This);
        
        HRESULT ( STDMETHODCALLTYPE *InsertRecognitionResultsArray )( 
            IHandwrittenTextInsertion * This,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * psaAlternates,
            /* [in] */ LCID locale,
            /* [in] */ BOOL fAlternateContainsAutoSpacingInformation);
        
        HRESULT ( STDMETHODCALLTYPE *InsertInkRecognitionResult )( 
            IHandwrittenTextInsertion * This,
            /* [in] */ __RPC__in_opt IInkRecognitionResult *pIInkRecoResult,
            /* [in] */ LCID locale,
            /* [in] */ BOOL fAlternateContainsAutoSpacingInformation);
        
        END_INTERFACE
    } IHandwrittenTextInsertionVtbl;

    interface IHandwrittenTextInsertion
    {
        CONST_VTBL struct IHandwrittenTextInsertionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHandwrittenTextInsertion_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHandwrittenTextInsertion_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHandwrittenTextInsertion_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHandwrittenTextInsertion_InsertRecognitionResultsArray(This,psaAlternates,locale,fAlternateContainsAutoSpacingInformation)	\
    ( (This)->lpVtbl -> InsertRecognitionResultsArray(This,psaAlternates,locale,fAlternateContainsAutoSpacingInformation) ) 

#define IHandwrittenTextInsertion_InsertInkRecognitionResult(This,pIInkRecoResult,locale,fAlternateContainsAutoSpacingInformation)	\
    ( (This)->lpVtbl -> InsertInkRecognitionResult(This,pIInkRecoResult,locale,fAlternateContainsAutoSpacingInformation) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHandwrittenTextInsertion_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_HandwrittenTextInsertion;

#ifdef __cplusplus

class DECLSPEC_UUID("9F074EE2-E6E9-4d8a-A047-EB5B5C3C55DA")
HandwrittenTextInsertion;
#endif

EXTERN_C const CLSID CLSID_PenInputPanel;

#ifdef __cplusplus

class DECLSPEC_UUID("f744e496-1b5a-489e-81dc-fbd7ac6298a8")
PenInputPanel;
#endif

#ifndef __ITextInputPanelEventSink_INTERFACE_DEFINED__
#define __ITextInputPanelEventSink_INTERFACE_DEFINED__

/* interface ITextInputPanelEventSink */
/* [oleautomation][unique][uuid][object] */ 


EXTERN_C const IID IID_ITextInputPanelEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27560408-8e64-4fe1-804e-421201584b31")
    ITextInputPanelEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InPlaceStateChanging( 
            /* [in] */ InPlaceState oldInPlaceState,
            /* [in] */ InPlaceState newInPlaceState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InPlaceStateChanged( 
            /* [in] */ InPlaceState oldInPlaceState,
            /* [in] */ InPlaceState newInPlaceState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InPlaceSizeChanging( 
            /* [in] */ RECT oldBoundingRectangle,
            /* [in] */ RECT newBoundingRectangle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InPlaceSizeChanged( 
            /* [in] */ RECT oldBoundingRectangle,
            /* [in] */ RECT newBoundingRectangle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InputAreaChanging( 
            /* [in] */ PanelInputArea oldInputArea,
            /* [in] */ PanelInputArea newInputArea) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InputAreaChanged( 
            /* [in] */ PanelInputArea oldInputArea,
            /* [in] */ PanelInputArea newInputArea) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CorrectionModeChanging( 
            /* [in] */ CorrectionMode oldCorrectionMode,
            /* [in] */ CorrectionMode newCorrectionMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CorrectionModeChanged( 
            /* [in] */ CorrectionMode oldCorrectionMode,
            /* [in] */ CorrectionMode newCorrectionMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InPlaceVisibilityChanging( 
            /* [in] */ BOOL oldVisible,
            /* [in] */ BOOL newVisible) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InPlaceVisibilityChanged( 
            /* [in] */ BOOL oldVisible,
            /* [in] */ BOOL newVisible) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TextInserting( 
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * Ink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TextInserted( 
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * Ink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextInputPanelEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITextInputPanelEventSink * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITextInputPanelEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITextInputPanelEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *InPlaceStateChanging )( 
            ITextInputPanelEventSink * This,
            /* [in] */ InPlaceState oldInPlaceState,
            /* [in] */ InPlaceState newInPlaceState);
        
        HRESULT ( STDMETHODCALLTYPE *InPlaceStateChanged )( 
            ITextInputPanelEventSink * This,
            /* [in] */ InPlaceState oldInPlaceState,
            /* [in] */ InPlaceState newInPlaceState);
        
        HRESULT ( STDMETHODCALLTYPE *InPlaceSizeChanging )( 
            ITextInputPanelEventSink * This,
            /* [in] */ RECT oldBoundingRectangle,
            /* [in] */ RECT newBoundingRectangle);
        
        HRESULT ( STDMETHODCALLTYPE *InPlaceSizeChanged )( 
            ITextInputPanelEventSink * This,
            /* [in] */ RECT oldBoundingRectangle,
            /* [in] */ RECT newBoundingRectangle);
        
        HRESULT ( STDMETHODCALLTYPE *InputAreaChanging )( 
            ITextInputPanelEventSink * This,
            /* [in] */ PanelInputArea oldInputArea,
            /* [in] */ PanelInputArea newInputArea);
        
        HRESULT ( STDMETHODCALLTYPE *InputAreaChanged )( 
            ITextInputPanelEventSink * This,
            /* [in] */ PanelInputArea oldInputArea,
            /* [in] */ PanelInputArea newInputArea);
        
        HRESULT ( STDMETHODCALLTYPE *CorrectionModeChanging )( 
            ITextInputPanelEventSink * This,
            /* [in] */ CorrectionMode oldCorrectionMode,
            /* [in] */ CorrectionMode newCorrectionMode);
        
        HRESULT ( STDMETHODCALLTYPE *CorrectionModeChanged )( 
            ITextInputPanelEventSink * This,
            /* [in] */ CorrectionMode oldCorrectionMode,
            /* [in] */ CorrectionMode newCorrectionMode);
        
        HRESULT ( STDMETHODCALLTYPE *InPlaceVisibilityChanging )( 
            ITextInputPanelEventSink * This,
            /* [in] */ BOOL oldVisible,
            /* [in] */ BOOL newVisible);
        
        HRESULT ( STDMETHODCALLTYPE *InPlaceVisibilityChanged )( 
            ITextInputPanelEventSink * This,
            /* [in] */ BOOL oldVisible,
            /* [in] */ BOOL newVisible);
        
        HRESULT ( STDMETHODCALLTYPE *TextInserting )( 
            ITextInputPanelEventSink * This,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * Ink);
        
        HRESULT ( STDMETHODCALLTYPE *TextInserted )( 
            ITextInputPanelEventSink * This,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * Ink);
        
        END_INTERFACE
    } ITextInputPanelEventSinkVtbl;

    interface ITextInputPanelEventSink
    {
        CONST_VTBL struct ITextInputPanelEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextInputPanelEventSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITextInputPanelEventSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITextInputPanelEventSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITextInputPanelEventSink_InPlaceStateChanging(This,oldInPlaceState,newInPlaceState)	\
    ( (This)->lpVtbl -> InPlaceStateChanging(This,oldInPlaceState,newInPlaceState) ) 

#define ITextInputPanelEventSink_InPlaceStateChanged(This,oldInPlaceState,newInPlaceState)	\
    ( (This)->lpVtbl -> InPlaceStateChanged(This,oldInPlaceState,newInPlaceState) ) 

#define ITextInputPanelEventSink_InPlaceSizeChanging(This,oldBoundingRectangle,newBoundingRectangle)	\
    ( (This)->lpVtbl -> InPlaceSizeChanging(This,oldBoundingRectangle,newBoundingRectangle) ) 

#define ITextInputPanelEventSink_InPlaceSizeChanged(This,oldBoundingRectangle,newBoundingRectangle)	\
    ( (This)->lpVtbl -> InPlaceSizeChanged(This,oldBoundingRectangle,newBoundingRectangle) ) 

#define ITextInputPanelEventSink_InputAreaChanging(This,oldInputArea,newInputArea)	\
    ( (This)->lpVtbl -> InputAreaChanging(This,oldInputArea,newInputArea) ) 

#define ITextInputPanelEventSink_InputAreaChanged(This,oldInputArea,newInputArea)	\
    ( (This)->lpVtbl -> InputAreaChanged(This,oldInputArea,newInputArea) ) 

#define ITextInputPanelEventSink_CorrectionModeChanging(This,oldCorrectionMode,newCorrectionMode)	\
    ( (This)->lpVtbl -> CorrectionModeChanging(This,oldCorrectionMode,newCorrectionMode) ) 

#define ITextInputPanelEventSink_CorrectionModeChanged(This,oldCorrectionMode,newCorrectionMode)	\
    ( (This)->lpVtbl -> CorrectionModeChanged(This,oldCorrectionMode,newCorrectionMode) ) 

#define ITextInputPanelEventSink_InPlaceVisibilityChanging(This,oldVisible,newVisible)	\
    ( (This)->lpVtbl -> InPlaceVisibilityChanging(This,oldVisible,newVisible) ) 

#define ITextInputPanelEventSink_InPlaceVisibilityChanged(This,oldVisible,newVisible)	\
    ( (This)->lpVtbl -> InPlaceVisibilityChanged(This,oldVisible,newVisible) ) 

#define ITextInputPanelEventSink_TextInserting(This,Ink)	\
    ( (This)->lpVtbl -> TextInserting(This,Ink) ) 

#define ITextInputPanelEventSink_TextInserted(This,Ink)	\
    ( (This)->lpVtbl -> TextInserted(This,Ink) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITextInputPanelEventSink_INTERFACE_DEFINED__ */


#ifndef __ITextInputPanel_INTERFACE_DEFINED__
#define __ITextInputPanel_INTERFACE_DEFINED__

/* interface ITextInputPanel */
/* [oleautomation][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ITextInputPanel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6b6a65a5-6af3-46c2-b6ea-56cd1f80df71")
    ITextInputPanel : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_AttachedEditWindow( 
            /* [retval][out] */ __RPC__deref_out_opt HWND *AttachedEditWindow) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_AttachedEditWindow( 
            /* [in] */ __RPC__in HWND AttachedEditWindow) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentInteractionMode( 
            /* [retval][out] */ __RPC__out InteractionMode *CurrentInteractionMode) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DefaultInPlaceState( 
            /* [retval][out] */ __RPC__out InPlaceState *State) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DefaultInPlaceState( 
            /* [in] */ InPlaceState State) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentInPlaceState( 
            /* [retval][out] */ __RPC__out InPlaceState *State) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DefaultInputArea( 
            /* [retval][out] */ __RPC__out PanelInputArea *Area) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DefaultInputArea( 
            /* [in] */ PanelInputArea Area) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentInputArea( 
            /* [retval][out] */ __RPC__out PanelInputArea *Area) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentCorrectionMode( 
            /* [retval][out] */ __RPC__out CorrectionMode *Mode) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PreferredInPlaceDirection( 
            /* [retval][out] */ __RPC__out InPlaceDirection *Direction) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PreferredInPlaceDirection( 
            /* [in] */ InPlaceDirection Direction) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ExpandPostInsertionCorrection( 
            /* [retval][out] */ __RPC__out BOOL *Expand) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ExpandPostInsertionCorrection( 
            /* [in] */ BOOL Expand) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_InPlaceVisibleOnFocus( 
            /* [retval][out] */ __RPC__out BOOL *Visible) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_InPlaceVisibleOnFocus( 
            /* [in] */ BOOL Visible) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_InPlaceBoundingRectangle( 
            /* [retval][out] */ __RPC__out RECT *BoundingRectangle) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PopUpCorrectionHeight( 
            /* [retval][out] */ __RPC__out int *Height) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PopDownCorrectionHeight( 
            /* [retval][out] */ __RPC__out int *Height) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitPendingInput( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInPlaceVisibility( 
            BOOL Visible) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInPlacePosition( 
            int xPosition,
            int yPosition,
            CorrectionPosition position) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInPlaceHoverTargetPosition( 
            int xPosition,
            int yPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            __RPC__in_opt ITextInputPanelEventSink *EventSink,
            DWORD EventMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            __RPC__in_opt ITextInputPanelEventSink *EventSink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextInputPanelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITextInputPanel * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITextInputPanel * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITextInputPanel * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AttachedEditWindow )( 
            ITextInputPanel * This,
            /* [retval][out] */ __RPC__deref_out_opt HWND *AttachedEditWindow);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_AttachedEditWindow )( 
            ITextInputPanel * This,
            /* [in] */ __RPC__in HWND AttachedEditWindow);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentInteractionMode )( 
            ITextInputPanel * This,
            /* [retval][out] */ __RPC__out InteractionMode *CurrentInteractionMode);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultInPlaceState )( 
            ITextInputPanel * This,
            /* [retval][out] */ __RPC__out InPlaceState *State);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultInPlaceState )( 
            ITextInputPanel * This,
            /* [in] */ InPlaceState State);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentInPlaceState )( 
            ITextInputPanel * This,
            /* [retval][out] */ __RPC__out InPlaceState *State);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultInputArea )( 
            ITextInputPanel * This,
            /* [retval][out] */ __RPC__out PanelInputArea *Area);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultInputArea )( 
            ITextInputPanel * This,
            /* [in] */ PanelInputArea Area);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentInputArea )( 
            ITextInputPanel * This,
            /* [retval][out] */ __RPC__out PanelInputArea *Area);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentCorrectionMode )( 
            ITextInputPanel * This,
            /* [retval][out] */ __RPC__out CorrectionMode *Mode);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PreferredInPlaceDirection )( 
            ITextInputPanel * This,
            /* [retval][out] */ __RPC__out InPlaceDirection *Direction);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PreferredInPlaceDirection )( 
            ITextInputPanel * This,
            /* [in] */ InPlaceDirection Direction);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExpandPostInsertionCorrection )( 
            ITextInputPanel * This,
            /* [retval][out] */ __RPC__out BOOL *Expand);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ExpandPostInsertionCorrection )( 
            ITextInputPanel * This,
            /* [in] */ BOOL Expand);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_InPlaceVisibleOnFocus )( 
            ITextInputPanel * This,
            /* [retval][out] */ __RPC__out BOOL *Visible);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_InPlaceVisibleOnFocus )( 
            ITextInputPanel * This,
            /* [in] */ BOOL Visible);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_InPlaceBoundingRectangle )( 
            ITextInputPanel * This,
            /* [retval][out] */ __RPC__out RECT *BoundingRectangle);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PopUpCorrectionHeight )( 
            ITextInputPanel * This,
            /* [retval][out] */ __RPC__out int *Height);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PopDownCorrectionHeight )( 
            ITextInputPanel * This,
            /* [retval][out] */ __RPC__out int *Height);
        
        HRESULT ( STDMETHODCALLTYPE *CommitPendingInput )( 
            ITextInputPanel * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetInPlaceVisibility )( 
            ITextInputPanel * This,
            BOOL Visible);
        
        HRESULT ( STDMETHODCALLTYPE *SetInPlacePosition )( 
            ITextInputPanel * This,
            int xPosition,
            int yPosition,
            CorrectionPosition position);
        
        HRESULT ( STDMETHODCALLTYPE *SetInPlaceHoverTargetPosition )( 
            ITextInputPanel * This,
            int xPosition,
            int yPosition);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            ITextInputPanel * This,
            __RPC__in_opt ITextInputPanelEventSink *EventSink,
            DWORD EventMask);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            ITextInputPanel * This,
            __RPC__in_opt ITextInputPanelEventSink *EventSink);
        
        END_INTERFACE
    } ITextInputPanelVtbl;

    interface ITextInputPanel
    {
        CONST_VTBL struct ITextInputPanelVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextInputPanel_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITextInputPanel_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITextInputPanel_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITextInputPanel_get_AttachedEditWindow(This,AttachedEditWindow)	\
    ( (This)->lpVtbl -> get_AttachedEditWindow(This,AttachedEditWindow) ) 

#define ITextInputPanel_put_AttachedEditWindow(This,AttachedEditWindow)	\
    ( (This)->lpVtbl -> put_AttachedEditWindow(This,AttachedEditWindow) ) 

#define ITextInputPanel_get_CurrentInteractionMode(This,CurrentInteractionMode)	\
    ( (This)->lpVtbl -> get_CurrentInteractionMode(This,CurrentInteractionMode) ) 

#define ITextInputPanel_get_DefaultInPlaceState(This,State)	\
    ( (This)->lpVtbl -> get_DefaultInPlaceState(This,State) ) 

#define ITextInputPanel_put_DefaultInPlaceState(This,State)	\
    ( (This)->lpVtbl -> put_DefaultInPlaceState(This,State) ) 

#define ITextInputPanel_get_CurrentInPlaceState(This,State)	\
    ( (This)->lpVtbl -> get_CurrentInPlaceState(This,State) ) 

#define ITextInputPanel_get_DefaultInputArea(This,Area)	\
    ( (This)->lpVtbl -> get_DefaultInputArea(This,Area) ) 

#define ITextInputPanel_put_DefaultInputArea(This,Area)	\
    ( (This)->lpVtbl -> put_DefaultInputArea(This,Area) ) 

#define ITextInputPanel_get_CurrentInputArea(This,Area)	\
    ( (This)->lpVtbl -> get_CurrentInputArea(This,Area) ) 

#define ITextInputPanel_get_CurrentCorrectionMode(This,Mode)	\
    ( (This)->lpVtbl -> get_CurrentCorrectionMode(This,Mode) ) 

#define ITextInputPanel_get_PreferredInPlaceDirection(This,Direction)	\
    ( (This)->lpVtbl -> get_PreferredInPlaceDirection(This,Direction) ) 

#define ITextInputPanel_put_PreferredInPlaceDirection(This,Direction)	\
    ( (This)->lpVtbl -> put_PreferredInPlaceDirection(This,Direction) ) 

#define ITextInputPanel_get_ExpandPostInsertionCorrection(This,Expand)	\
    ( (This)->lpVtbl -> get_ExpandPostInsertionCorrection(This,Expand) ) 

#define ITextInputPanel_put_ExpandPostInsertionCorrection(This,Expand)	\
    ( (This)->lpVtbl -> put_ExpandPostInsertionCorrection(This,Expand) ) 

#define ITextInputPanel_get_InPlaceVisibleOnFocus(This,Visible)	\
    ( (This)->lpVtbl -> get_InPlaceVisibleOnFocus(This,Visible) ) 

#define ITextInputPanel_put_InPlaceVisibleOnFocus(This,Visible)	\
    ( (This)->lpVtbl -> put_InPlaceVisibleOnFocus(This,Visible) ) 

#define ITextInputPanel_get_InPlaceBoundingRectangle(This,BoundingRectangle)	\
    ( (This)->lpVtbl -> get_InPlaceBoundingRectangle(This,BoundingRectangle) ) 

#define ITextInputPanel_get_PopUpCorrectionHeight(This,Height)	\
    ( (This)->lpVtbl -> get_PopUpCorrectionHeight(This,Height) ) 

#define ITextInputPanel_get_PopDownCorrectionHeight(This,Height)	\
    ( (This)->lpVtbl -> get_PopDownCorrectionHeight(This,Height) ) 

#define ITextInputPanel_CommitPendingInput(This)	\
    ( (This)->lpVtbl -> CommitPendingInput(This) ) 

#define ITextInputPanel_SetInPlaceVisibility(This,Visible)	\
    ( (This)->lpVtbl -> SetInPlaceVisibility(This,Visible) ) 

#define ITextInputPanel_SetInPlacePosition(This,xPosition,yPosition,position)	\
    ( (This)->lpVtbl -> SetInPlacePosition(This,xPosition,yPosition,position) ) 

#define ITextInputPanel_SetInPlaceHoverTargetPosition(This,xPosition,yPosition)	\
    ( (This)->lpVtbl -> SetInPlaceHoverTargetPosition(This,xPosition,yPosition) ) 

#define ITextInputPanel_Advise(This,EventSink,EventMask)	\
    ( (This)->lpVtbl -> Advise(This,EventSink,EventMask) ) 

#define ITextInputPanel_Unadvise(This,EventSink)	\
    ( (This)->lpVtbl -> Unadvise(This,EventSink) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITextInputPanel_INTERFACE_DEFINED__ */


#ifndef __IInputPanelWindowHandle_INTERFACE_DEFINED__
#define __IInputPanelWindowHandle_INTERFACE_DEFINED__

/* interface IInputPanelWindowHandle */
/* [oleautomation][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IInputPanelWindowHandle;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4AF81847-FDC4-4fc3-AD0B-422479C1B935")
    IInputPanelWindowHandle : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_AttachedEditWindow32( 
            /* [retval][out] */ __RPC__out LONG32 *AttachedEditWindow) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_AttachedEditWindow32( 
            /* [in] */ LONG32 AttachedEditWindow) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_AttachedEditWindow64( 
            /* [retval][out] */ __RPC__out LONG64 *AttachedEditWindow) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_AttachedEditWindow64( 
            /* [in] */ LONG64 AttachedEditWindow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInputPanelWindowHandleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInputPanelWindowHandle * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInputPanelWindowHandle * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInputPanelWindowHandle * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AttachedEditWindow32 )( 
            IInputPanelWindowHandle * This,
            /* [retval][out] */ __RPC__out LONG32 *AttachedEditWindow);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_AttachedEditWindow32 )( 
            IInputPanelWindowHandle * This,
            /* [in] */ LONG32 AttachedEditWindow);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AttachedEditWindow64 )( 
            IInputPanelWindowHandle * This,
            /* [retval][out] */ __RPC__out LONG64 *AttachedEditWindow);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_AttachedEditWindow64 )( 
            IInputPanelWindowHandle * This,
            /* [in] */ LONG64 AttachedEditWindow);
        
        END_INTERFACE
    } IInputPanelWindowHandleVtbl;

    interface IInputPanelWindowHandle
    {
        CONST_VTBL struct IInputPanelWindowHandleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInputPanelWindowHandle_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInputPanelWindowHandle_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInputPanelWindowHandle_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInputPanelWindowHandle_get_AttachedEditWindow32(This,AttachedEditWindow)	\
    ( (This)->lpVtbl -> get_AttachedEditWindow32(This,AttachedEditWindow) ) 

#define IInputPanelWindowHandle_put_AttachedEditWindow32(This,AttachedEditWindow)	\
    ( (This)->lpVtbl -> put_AttachedEditWindow32(This,AttachedEditWindow) ) 

#define IInputPanelWindowHandle_get_AttachedEditWindow64(This,AttachedEditWindow)	\
    ( (This)->lpVtbl -> get_AttachedEditWindow64(This,AttachedEditWindow) ) 

#define IInputPanelWindowHandle_put_AttachedEditWindow64(This,AttachedEditWindow)	\
    ( (This)->lpVtbl -> put_AttachedEditWindow64(This,AttachedEditWindow) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInputPanelWindowHandle_INTERFACE_DEFINED__ */


#ifndef __ITextInputPanelRunInfo_INTERFACE_DEFINED__
#define __ITextInputPanelRunInfo_INTERFACE_DEFINED__

/* interface ITextInputPanelRunInfo */
/* [oleautomation][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ITextInputPanelRunInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9F424568-1920-48cc-9811-A993CBF5ADBA")
    ITextInputPanelRunInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsTipRunning( 
            /* [out] */ __RPC__out BOOL *pfRunning) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextInputPanelRunInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITextInputPanelRunInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITextInputPanelRunInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITextInputPanelRunInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsTipRunning )( 
            ITextInputPanelRunInfo * This,
            /* [out] */ __RPC__out BOOL *pfRunning);
        
        END_INTERFACE
    } ITextInputPanelRunInfoVtbl;

    interface ITextInputPanelRunInfo
    {
        CONST_VTBL struct ITextInputPanelRunInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextInputPanelRunInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITextInputPanelRunInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITextInputPanelRunInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITextInputPanelRunInfo_IsTipRunning(This,pfRunning)	\
    ( (This)->lpVtbl -> IsTipRunning(This,pfRunning) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITextInputPanelRunInfo_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_TextInputPanel;

#ifdef __cplusplus

class DECLSPEC_UUID("f9b189d7-228b-4f2b-8650-b97f59e02c8c")
TextInputPanel;
#endif

EXTERN_C const CLSID CLSID_PenInputPanel_Internal;

#ifdef __cplusplus

class DECLSPEC_UUID("802B1FB9-056B-4720-B0CC-80D23B71171E")
PenInputPanel_Internal;
#endif
#endif /* __PenInputPanelLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\peninputpanel_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for peninputpanel.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_PenInputPanelLib,0xd7ca032c,0xb7d0,0x429e,0x9f,0xd7,0x82,0x24,0x1c,0x35,0x6b,0x4a);


MIDL_DEFINE_GUID(IID, IID_IPenInputPanel,0xfa7a4083,0x5747,0x4040,0xa1,0x82,0x0b,0x0e,0x9f,0xd4,0xfa,0xc7);


MIDL_DEFINE_GUID(IID, DIID__IPenInputPanelEvents,0xb7e489da,0x3719,0x439f,0x84,0x8f,0xe7,0xac,0xbd,0x82,0x0f,0x17);


MIDL_DEFINE_GUID(IID, IID_IHandwrittenTextInsertion,0x56FDEA97,0xECD6,0x43e7,0xAA,0x3A,0x81,0x6B,0xE7,0x78,0x58,0x60);


MIDL_DEFINE_GUID(CLSID, CLSID_HandwrittenTextInsertion,0x9F074EE2,0xE6E9,0x4d8a,0xA0,0x47,0xEB,0x5B,0x5C,0x3C,0x55,0xDA);


MIDL_DEFINE_GUID(CLSID, CLSID_PenInputPanel,0xf744e496,0x1b5a,0x489e,0x81,0xdc,0xfb,0xd7,0xac,0x62,0x98,0xa8);


MIDL_DEFINE_GUID(IID, IID_ITextInputPanelEventSink,0x27560408,0x8e64,0x4fe1,0x80,0x4e,0x42,0x12,0x01,0x58,0x4b,0x31);


MIDL_DEFINE_GUID(IID, IID_ITextInputPanel,0x6b6a65a5,0x6af3,0x46c2,0xb6,0xea,0x56,0xcd,0x1f,0x80,0xdf,0x71);


MIDL_DEFINE_GUID(IID, IID_IInputPanelWindowHandle,0x4AF81847,0xFDC4,0x4fc3,0xAD,0x0B,0x42,0x24,0x79,0xC1,0xB9,0x35);


MIDL_DEFINE_GUID(IID, IID_ITextInputPanelRunInfo,0x9F424568,0x1920,0x48cc,0x98,0x11,0xA9,0x93,0xCB,0xF5,0xAD,0xBA);


MIDL_DEFINE_GUID(CLSID, CLSID_TextInputPanel,0xf9b189d7,0x228b,0x4f2b,0x86,0x50,0xb9,0x7f,0x59,0xe0,0x2c,0x8c);


MIDL_DEFINE_GUID(CLSID, CLSID_PenInputPanel_Internal,0x802B1FB9,0x056B,0x4720,0xB0,0xCC,0x80,0xD2,0x3B,0x71,0x17,0x1E);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\persist.h ===
//-----------------------------------------------------------------------------
//
// File:        persist.h
//
// Copyright:   Copyright (c) Microsoft Corporation
//
// Contents:    MSPersist external constants GUIDS and other things users need
//
// Comments:
//
//-----------------------------------------------------------------------------

#ifndef PERSIST_H
#define PERSIST_H

#undef PERSISTDECLSPEC
#if _MSC_VER >= 1100 && (!defined(SHx) || (defined(SHx) && _MSC_VER >= 1200))
#define PERSISTDECLSPEC __declspec(selectany)
#else
#define PERSISTDECLSPEC 
#endif //_MSC_VER

// Persist Properties
#define DBPROPFLAGS_PERSIST 0x2000

#define DBPROPVAL_PERSIST_ADTG 0
#define DBPROPVAL_PERSIST_XML 1
#define DBPROP_PersistFormat 2
#define DBPROP_PersistSchema 3
#define DBPROP_HCHAPTER 4
#define DBPROP_MAINTAINPROPS 5

// XML writing only properties
#define DBPROP_Unicode  6

// internal property (read-only)
#define DBPROP_INTERLEAVEDROWS 8

extern const PERSISTDECLSPEC CLSID CLSID_MSPersist
 = { 0x7c07e0d0, 0x4418, 0x11d2, { 0x92, 0x12, 0x0, 0xc0, 0x4f, 0xbb, 0xbf, 0xb3 } };

// {4D7839A0-5B8E-11d1-A6B3-00A0C9138C66}
extern const PERSISTDECLSPEC GUID   DBPROPSET_PERSIST
 = { 0x4d7839a0, 0x5b8e, 0x11d1, { 0xa6, 0xb3, 0x0, 0xa0, 0xc9, 0x13, 0x8c, 0x66 } };

#define MS_PERSIST_PROGID "MSPersist"

extern const PERSISTDECLSPEC char *PROGID_MSPersist = MS_PERSIST_PROGID;

extern const PERSISTDECLSPEC unsigned short *PROGID_MSPersist_W = L"MSPersist";

extern const PERSISTDECLSPEC char *PROGID_MSPersist_Version = MS_PERSIST_PROGID ".1";

extern const PERSISTDECLSPEC unsigned short *PROGID_MSPersist_Version_W = L"MSPersist.1";

#endif // PERSIST_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\PhotoAcquire.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for photoacquire.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __photoacquire_h__
#define __photoacquire_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPhotoAcquireItem_FWD_DEFINED__
#define __IPhotoAcquireItem_FWD_DEFINED__
typedef interface IPhotoAcquireItem IPhotoAcquireItem;
#endif 	/* __IPhotoAcquireItem_FWD_DEFINED__ */


#ifndef __IUserInputString_FWD_DEFINED__
#define __IUserInputString_FWD_DEFINED__
typedef interface IUserInputString IUserInputString;
#endif 	/* __IUserInputString_FWD_DEFINED__ */


#ifndef __IPhotoAcquireProgressCB_FWD_DEFINED__
#define __IPhotoAcquireProgressCB_FWD_DEFINED__
typedef interface IPhotoAcquireProgressCB IPhotoAcquireProgressCB;
#endif 	/* __IPhotoAcquireProgressCB_FWD_DEFINED__ */


#ifndef __IPhotoProgressActionCB_FWD_DEFINED__
#define __IPhotoProgressActionCB_FWD_DEFINED__
typedef interface IPhotoProgressActionCB IPhotoProgressActionCB;
#endif 	/* __IPhotoProgressActionCB_FWD_DEFINED__ */


#ifndef __IPhotoProgressDialog_FWD_DEFINED__
#define __IPhotoProgressDialog_FWD_DEFINED__
typedef interface IPhotoProgressDialog IPhotoProgressDialog;
#endif 	/* __IPhotoProgressDialog_FWD_DEFINED__ */


#ifndef __IPhotoAcquireSource_FWD_DEFINED__
#define __IPhotoAcquireSource_FWD_DEFINED__
typedef interface IPhotoAcquireSource IPhotoAcquireSource;
#endif 	/* __IPhotoAcquireSource_FWD_DEFINED__ */


#ifndef __IPhotoAcquire_FWD_DEFINED__
#define __IPhotoAcquire_FWD_DEFINED__
typedef interface IPhotoAcquire IPhotoAcquire;
#endif 	/* __IPhotoAcquire_FWD_DEFINED__ */


#ifndef __IPhotoAcquireSettings_FWD_DEFINED__
#define __IPhotoAcquireSettings_FWD_DEFINED__
typedef interface IPhotoAcquireSettings IPhotoAcquireSettings;
#endif 	/* __IPhotoAcquireSettings_FWD_DEFINED__ */


#ifndef __IPhotoAcquireOptionsDialog_FWD_DEFINED__
#define __IPhotoAcquireOptionsDialog_FWD_DEFINED__
typedef interface IPhotoAcquireOptionsDialog IPhotoAcquireOptionsDialog;
#endif 	/* __IPhotoAcquireOptionsDialog_FWD_DEFINED__ */


#ifndef __IPhotoAcquireDeviceSelectionDialog_FWD_DEFINED__
#define __IPhotoAcquireDeviceSelectionDialog_FWD_DEFINED__
typedef interface IPhotoAcquireDeviceSelectionDialog IPhotoAcquireDeviceSelectionDialog;
#endif 	/* __IPhotoAcquireDeviceSelectionDialog_FWD_DEFINED__ */


#ifndef __IPhotoAcquirePlugin_FWD_DEFINED__
#define __IPhotoAcquirePlugin_FWD_DEFINED__
typedef interface IPhotoAcquirePlugin IPhotoAcquirePlugin;
#endif 	/* __IPhotoAcquirePlugin_FWD_DEFINED__ */


#ifndef __PhotoAcquire_FWD_DEFINED__
#define __PhotoAcquire_FWD_DEFINED__

#ifdef __cplusplus
typedef class PhotoAcquire PhotoAcquire;
#else
typedef struct PhotoAcquire PhotoAcquire;
#endif /* __cplusplus */

#endif 	/* __PhotoAcquire_FWD_DEFINED__ */


#ifndef __PhotoAcquireAutoPlayDropTarget_FWD_DEFINED__
#define __PhotoAcquireAutoPlayDropTarget_FWD_DEFINED__

#ifdef __cplusplus
typedef class PhotoAcquireAutoPlayDropTarget PhotoAcquireAutoPlayDropTarget;
#else
typedef struct PhotoAcquireAutoPlayDropTarget PhotoAcquireAutoPlayDropTarget;
#endif /* __cplusplus */

#endif 	/* __PhotoAcquireAutoPlayDropTarget_FWD_DEFINED__ */


#ifndef __PhotoAcquireAutoPlayHWEventHandler_FWD_DEFINED__
#define __PhotoAcquireAutoPlayHWEventHandler_FWD_DEFINED__

#ifdef __cplusplus
typedef class PhotoAcquireAutoPlayHWEventHandler PhotoAcquireAutoPlayHWEventHandler;
#else
typedef struct PhotoAcquireAutoPlayHWEventHandler PhotoAcquireAutoPlayHWEventHandler;
#endif /* __cplusplus */

#endif 	/* __PhotoAcquireAutoPlayHWEventHandler_FWD_DEFINED__ */


#ifndef __PhotoAcquireOptionsDialog_FWD_DEFINED__
#define __PhotoAcquireOptionsDialog_FWD_DEFINED__

#ifdef __cplusplus
typedef class PhotoAcquireOptionsDialog PhotoAcquireOptionsDialog;
#else
typedef struct PhotoAcquireOptionsDialog PhotoAcquireOptionsDialog;
#endif /* __cplusplus */

#endif 	/* __PhotoAcquireOptionsDialog_FWD_DEFINED__ */


#ifndef __PhotoProgressDialog_FWD_DEFINED__
#define __PhotoProgressDialog_FWD_DEFINED__

#ifdef __cplusplus
typedef class PhotoProgressDialog PhotoProgressDialog;
#else
typedef struct PhotoProgressDialog PhotoProgressDialog;
#endif /* __cplusplus */

#endif 	/* __PhotoProgressDialog_FWD_DEFINED__ */


#ifndef __PhotoAcquireDeviceSelectionDialog_FWD_DEFINED__
#define __PhotoAcquireDeviceSelectionDialog_FWD_DEFINED__

#ifdef __cplusplus
typedef class PhotoAcquireDeviceSelectionDialog PhotoAcquireDeviceSelectionDialog;
#else
typedef struct PhotoAcquireDeviceSelectionDialog PhotoAcquireDeviceSelectionDialog;
#endif /* __cplusplus */

#endif 	/* __PhotoAcquireDeviceSelectionDialog_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "propidl.h"
#include "shobjidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_photoacquire_0000_0000 */
/* [local] */ 



#include <PhotoAcquireProperties.h>


extern RPC_IF_HANDLE __MIDL_itf_photoacquire_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_photoacquire_0000_0000_v0_0_s_ifspec;

#ifndef __IPhotoAcquireItem_INTERFACE_DEFINED__
#define __IPhotoAcquireItem_INTERFACE_DEFINED__

/* interface IPhotoAcquireItem */
/* [unique][uuid][object][helpstring] */ 


EXTERN_C const IID IID_IPhotoAcquireItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00f21c97-28bf-4c02-b842-5e4e90139a30")
    IPhotoAcquireItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetItemName( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrItemName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThumbnail( 
            /* [in] */ SIZE sizeThumbnail,
            /* [out] */ __RPC__deref_out_opt HBITMAP *phbmpThumbnail) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *pv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in const PROPVARIANT *pv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [out] */ __RPC__deref_out_opt IStream **ppStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanDelete( 
            /* [out] */ __RPC__out BOOL *pfCanDelete) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubItemCount( 
            /* [out] */ __RPC__out UINT *pnCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubItemAt( 
            /* [in] */ UINT nItemIndex,
            /* [out] */ __RPC__deref_out_opt IPhotoAcquireItem **ppPhotoAcquireItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPhotoAcquireItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPhotoAcquireItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPhotoAcquireItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPhotoAcquireItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemName )( 
            IPhotoAcquireItem * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrItemName);
        
        HRESULT ( STDMETHODCALLTYPE *GetThumbnail )( 
            IPhotoAcquireItem * This,
            /* [in] */ SIZE sizeThumbnail,
            /* [out] */ __RPC__deref_out_opt HBITMAP *phbmpThumbnail);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IPhotoAcquireItem * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *pv);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IPhotoAcquireItem * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in const PROPVARIANT *pv);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            IPhotoAcquireItem * This,
            /* [out] */ __RPC__deref_out_opt IStream **ppStream);
        
        HRESULT ( STDMETHODCALLTYPE *CanDelete )( 
            IPhotoAcquireItem * This,
            /* [out] */ __RPC__out BOOL *pfCanDelete);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IPhotoAcquireItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubItemCount )( 
            IPhotoAcquireItem * This,
            /* [out] */ __RPC__out UINT *pnCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubItemAt )( 
            IPhotoAcquireItem * This,
            /* [in] */ UINT nItemIndex,
            /* [out] */ __RPC__deref_out_opt IPhotoAcquireItem **ppPhotoAcquireItem);
        
        END_INTERFACE
    } IPhotoAcquireItemVtbl;

    interface IPhotoAcquireItem
    {
        CONST_VTBL struct IPhotoAcquireItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPhotoAcquireItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPhotoAcquireItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPhotoAcquireItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPhotoAcquireItem_GetItemName(This,pbstrItemName)	\
    ( (This)->lpVtbl -> GetItemName(This,pbstrItemName) ) 

#define IPhotoAcquireItem_GetThumbnail(This,sizeThumbnail,phbmpThumbnail)	\
    ( (This)->lpVtbl -> GetThumbnail(This,sizeThumbnail,phbmpThumbnail) ) 

#define IPhotoAcquireItem_GetProperty(This,key,pv)	\
    ( (This)->lpVtbl -> GetProperty(This,key,pv) ) 

#define IPhotoAcquireItem_SetProperty(This,key,pv)	\
    ( (This)->lpVtbl -> SetProperty(This,key,pv) ) 

#define IPhotoAcquireItem_GetStream(This,ppStream)	\
    ( (This)->lpVtbl -> GetStream(This,ppStream) ) 

#define IPhotoAcquireItem_CanDelete(This,pfCanDelete)	\
    ( (This)->lpVtbl -> CanDelete(This,pfCanDelete) ) 

#define IPhotoAcquireItem_Delete(This)	\
    ( (This)->lpVtbl -> Delete(This) ) 

#define IPhotoAcquireItem_GetSubItemCount(This,pnCount)	\
    ( (This)->lpVtbl -> GetSubItemCount(This,pnCount) ) 

#define IPhotoAcquireItem_GetSubItemAt(This,nItemIndex,ppPhotoAcquireItem)	\
    ( (This)->lpVtbl -> GetSubItemAt(This,nItemIndex,ppPhotoAcquireItem) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPhotoAcquireItem_INTERFACE_DEFINED__ */


#ifndef __IUserInputString_INTERFACE_DEFINED__
#define __IUserInputString_INTERFACE_DEFINED__

/* interface IUserInputString */
/* [unique][uuid][object][helpstring] */ 

typedef /* [v1_enum] */ 
enum tagUSER_INPUT_STRING_TYPE
    {	USER_INPUT_DEFAULT	= 0,
	USER_INPUT_PATH_ELEMENT	= 0x1
    } 	USER_INPUT_STRING_TYPE;


EXTERN_C const IID IID_IUserInputString;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00f243a1-205b-45ba-ae26-abbc53aa7a6f")
    IUserInputString : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSubmitButtonText( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrSubmitButtonText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrompt( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPromptTitle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStringId( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrStringId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStringType( 
            /* [out] */ __RPC__out USER_INPUT_STRING_TYPE *pnStringType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTooltipText( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrTooltipText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxLength( 
            /* [out] */ __RPC__out UINT *pcchMaxLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefault( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrDefault) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMruCount( 
            /* [out] */ __RPC__out UINT *pnMruCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMruEntryAt( 
            /* [in] */ UINT nIndex,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrMruEntry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImage( 
            /* [in] */ UINT nSize,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt HBITMAP *phBitmap,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt HICON *phIcon) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUserInputStringVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUserInputString * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUserInputString * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUserInputString * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubmitButtonText )( 
            IUserInputString * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrSubmitButtonText);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrompt )( 
            IUserInputString * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPromptTitle);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringId )( 
            IUserInputString * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrStringId);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringType )( 
            IUserInputString * This,
            /* [out] */ __RPC__out USER_INPUT_STRING_TYPE *pnStringType);
        
        HRESULT ( STDMETHODCALLTYPE *GetTooltipText )( 
            IUserInputString * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrTooltipText);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxLength )( 
            IUserInputString * This,
            /* [out] */ __RPC__out UINT *pcchMaxLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefault )( 
            IUserInputString * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrDefault);
        
        HRESULT ( STDMETHODCALLTYPE *GetMruCount )( 
            IUserInputString * This,
            /* [out] */ __RPC__out UINT *pnMruCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetMruEntryAt )( 
            IUserInputString * This,
            /* [in] */ UINT nIndex,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrMruEntry);
        
        HRESULT ( STDMETHODCALLTYPE *GetImage )( 
            IUserInputString * This,
            /* [in] */ UINT nSize,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt HBITMAP *phBitmap,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt HICON *phIcon);
        
        END_INTERFACE
    } IUserInputStringVtbl;

    interface IUserInputString
    {
        CONST_VTBL struct IUserInputStringVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUserInputString_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUserInputString_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUserInputString_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUserInputString_GetSubmitButtonText(This,pbstrSubmitButtonText)	\
    ( (This)->lpVtbl -> GetSubmitButtonText(This,pbstrSubmitButtonText) ) 

#define IUserInputString_GetPrompt(This,pbstrPromptTitle)	\
    ( (This)->lpVtbl -> GetPrompt(This,pbstrPromptTitle) ) 

#define IUserInputString_GetStringId(This,pbstrStringId)	\
    ( (This)->lpVtbl -> GetStringId(This,pbstrStringId) ) 

#define IUserInputString_GetStringType(This,pnStringType)	\
    ( (This)->lpVtbl -> GetStringType(This,pnStringType) ) 

#define IUserInputString_GetTooltipText(This,pbstrTooltipText)	\
    ( (This)->lpVtbl -> GetTooltipText(This,pbstrTooltipText) ) 

#define IUserInputString_GetMaxLength(This,pcchMaxLength)	\
    ( (This)->lpVtbl -> GetMaxLength(This,pcchMaxLength) ) 

#define IUserInputString_GetDefault(This,pbstrDefault)	\
    ( (This)->lpVtbl -> GetDefault(This,pbstrDefault) ) 

#define IUserInputString_GetMruCount(This,pnMruCount)	\
    ( (This)->lpVtbl -> GetMruCount(This,pnMruCount) ) 

#define IUserInputString_GetMruEntryAt(This,nIndex,pbstrMruEntry)	\
    ( (This)->lpVtbl -> GetMruEntryAt(This,nIndex,pbstrMruEntry) ) 

#define IUserInputString_GetImage(This,nSize,phBitmap,phIcon)	\
    ( (This)->lpVtbl -> GetImage(This,nSize,phBitmap,phIcon) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUserInputString_INTERFACE_DEFINED__ */


#ifndef __IPhotoAcquireProgressCB_INTERFACE_DEFINED__
#define __IPhotoAcquireProgressCB_INTERFACE_DEFINED__

/* interface IPhotoAcquireProgressCB */
/* [unique][uuid][object][helpstring] */ 

typedef /* [v1_enum] */ 
enum tagERROR_ADVISE_MESSAGE_TYPE
    {	PHOTOACQUIRE_ERROR_SKIPRETRYCANCEL	= 0,
	PHOTOACQUIRE_ERROR_RETRYCANCEL	= 1,
	PHOTOACQUIRE_ERROR_YESNO	= 2,
	PHOTOACQUIRE_ERROR_OK	= 3
    } 	ERROR_ADVISE_MESSAGE_TYPE;

typedef /* [v1_enum] */ 
enum tagERROR_ADVISE_RESULT
    {	PHOTOACQUIRE_RESULT_YES	= 0,
	PHOTOACQUIRE_RESULT_NO	= 1,
	PHOTOACQUIRE_RESULT_OK	= 2,
	PHOTOACQUIRE_RESULT_SKIP	= 3,
	PHOTOACQUIRE_RESULT_SKIP_ALL	= 4,
	PHOTOACQUIRE_RESULT_RETRY	= 5,
	PHOTOACQUIRE_RESULT_ABORT	= 6
    } 	ERROR_ADVISE_RESULT;


EXTERN_C const IID IID_IPhotoAcquireProgressCB;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00f2ce1e-935e-4248-892c-130f32c45cb4")
    IPhotoAcquireProgressCB : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Cancelled( 
            /* [out] */ __RPC__out BOOL *pfCancelled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartEnumeration( 
            /* [in] */ __RPC__in_opt IPhotoAcquireSource *pPhotoAcquireSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FoundItem( 
            /* [in] */ __RPC__in_opt IPhotoAcquireItem *pPhotoAcquireItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndEnumeration( 
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartTransfer( 
            /* [in] */ __RPC__in_opt IPhotoAcquireSource *pPhotoAcquireSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartItemTransfer( 
            /* [in] */ UINT nItemIndex,
            /* [in] */ __RPC__in_opt IPhotoAcquireItem *pPhotoAcquireItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DirectoryCreated( 
            /* [in] */ __RPC__in LPCWSTR pszDirectory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateTransferPercent( 
            /* [in] */ BOOL fOverall,
            /* [in] */ UINT nPercent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndItemTransfer( 
            /* [in] */ UINT nItemIndex,
            /* [in] */ __RPC__in_opt IPhotoAcquireItem *pPhotoAcquireItem,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndTransfer( 
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartDelete( 
            /* [in] */ __RPC__in_opt IPhotoAcquireSource *pPhotoAcquireSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartItemDelete( 
            /* [in] */ UINT nItemIndex,
            /* [in] */ __RPC__in_opt IPhotoAcquireItem *pPhotoAcquireItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateDeletePercent( 
            /* [in] */ UINT nPercent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndItemDelete( 
            /* [in] */ UINT nItemIndex,
            /* [in] */ __RPC__in_opt IPhotoAcquireItem *pPhotoAcquireItem,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndDelete( 
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndSession( 
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeleteAfterAcquire( 
            /* [out] */ __RPC__out BOOL *pfDeleteAfterAcquire) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ErrorAdvise( 
            /* [in] */ HRESULT hr,
            /* [in] */ __RPC__in LPCWSTR pszErrorMessage,
            /* [in] */ ERROR_ADVISE_MESSAGE_TYPE nMessageType,
            /* [out] */ __RPC__out ERROR_ADVISE_RESULT *pnErrorAdviseResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserInput( 
            /* [in] */ __RPC__in REFIID riidType,
            /* [in] */ __RPC__in_opt IUnknown *pUnknown,
            /* [out] */ __RPC__out PROPVARIANT *pPropVarResult,
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *pPropVarDefault) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPhotoAcquireProgressCBVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPhotoAcquireProgressCB * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPhotoAcquireProgressCB * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPhotoAcquireProgressCB * This);
        
        HRESULT ( STDMETHODCALLTYPE *Cancelled )( 
            IPhotoAcquireProgressCB * This,
            /* [out] */ __RPC__out BOOL *pfCancelled);
        
        HRESULT ( STDMETHODCALLTYPE *StartEnumeration )( 
            IPhotoAcquireProgressCB * This,
            /* [in] */ __RPC__in_opt IPhotoAcquireSource *pPhotoAcquireSource);
        
        HRESULT ( STDMETHODCALLTYPE *FoundItem )( 
            IPhotoAcquireProgressCB * This,
            /* [in] */ __RPC__in_opt IPhotoAcquireItem *pPhotoAcquireItem);
        
        HRESULT ( STDMETHODCALLTYPE *EndEnumeration )( 
            IPhotoAcquireProgressCB * This,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE *StartTransfer )( 
            IPhotoAcquireProgressCB * This,
            /* [in] */ __RPC__in_opt IPhotoAcquireSource *pPhotoAcquireSource);
        
        HRESULT ( STDMETHODCALLTYPE *StartItemTransfer )( 
            IPhotoAcquireProgressCB * This,
            /* [in] */ UINT nItemIndex,
            /* [in] */ __RPC__in_opt IPhotoAcquireItem *pPhotoAcquireItem);
        
        HRESULT ( STDMETHODCALLTYPE *DirectoryCreated )( 
            IPhotoAcquireProgressCB * This,
            /* [in] */ __RPC__in LPCWSTR pszDirectory);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateTransferPercent )( 
            IPhotoAcquireProgressCB * This,
            /* [in] */ BOOL fOverall,
            /* [in] */ UINT nPercent);
        
        HRESULT ( STDMETHODCALLTYPE *EndItemTransfer )( 
            IPhotoAcquireProgressCB * This,
            /* [in] */ UINT nItemIndex,
            /* [in] */ __RPC__in_opt IPhotoAcquireItem *pPhotoAcquireItem,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE *EndTransfer )( 
            IPhotoAcquireProgressCB * This,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE *StartDelete )( 
            IPhotoAcquireProgressCB * This,
            /* [in] */ __RPC__in_opt IPhotoAcquireSource *pPhotoAcquireSource);
        
        HRESULT ( STDMETHODCALLTYPE *StartItemDelete )( 
            IPhotoAcquireProgressCB * This,
            /* [in] */ UINT nItemIndex,
            /* [in] */ __RPC__in_opt IPhotoAcquireItem *pPhotoAcquireItem);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateDeletePercent )( 
            IPhotoAcquireProgressCB * This,
            /* [in] */ UINT nPercent);
        
        HRESULT ( STDMETHODCALLTYPE *EndItemDelete )( 
            IPhotoAcquireProgressCB * This,
            /* [in] */ UINT nItemIndex,
            /* [in] */ __RPC__in_opt IPhotoAcquireItem *pPhotoAcquireItem,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE *EndDelete )( 
            IPhotoAcquireProgressCB * This,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE *EndSession )( 
            IPhotoAcquireProgressCB * This,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeleteAfterAcquire )( 
            IPhotoAcquireProgressCB * This,
            /* [out] */ __RPC__out BOOL *pfDeleteAfterAcquire);
        
        HRESULT ( STDMETHODCALLTYPE *ErrorAdvise )( 
            IPhotoAcquireProgressCB * This,
            /* [in] */ HRESULT hr,
            /* [in] */ __RPC__in LPCWSTR pszErrorMessage,
            /* [in] */ ERROR_ADVISE_MESSAGE_TYPE nMessageType,
            /* [out] */ __RPC__out ERROR_ADVISE_RESULT *pnErrorAdviseResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserInput )( 
            IPhotoAcquireProgressCB * This,
            /* [in] */ __RPC__in REFIID riidType,
            /* [in] */ __RPC__in_opt IUnknown *pUnknown,
            /* [out] */ __RPC__out PROPVARIANT *pPropVarResult,
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *pPropVarDefault);
        
        END_INTERFACE
    } IPhotoAcquireProgressCBVtbl;

    interface IPhotoAcquireProgressCB
    {
        CONST_VTBL struct IPhotoAcquireProgressCBVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPhotoAcquireProgressCB_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPhotoAcquireProgressCB_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPhotoAcquireProgressCB_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPhotoAcquireProgressCB_Cancelled(This,pfCancelled)	\
    ( (This)->lpVtbl -> Cancelled(This,pfCancelled) ) 

#define IPhotoAcquireProgressCB_StartEnumeration(This,pPhotoAcquireSource)	\
    ( (This)->lpVtbl -> StartEnumeration(This,pPhotoAcquireSource) ) 

#define IPhotoAcquireProgressCB_FoundItem(This,pPhotoAcquireItem)	\
    ( (This)->lpVtbl -> FoundItem(This,pPhotoAcquireItem) ) 

#define IPhotoAcquireProgressCB_EndEnumeration(This,hr)	\
    ( (This)->lpVtbl -> EndEnumeration(This,hr) ) 

#define IPhotoAcquireProgressCB_StartTransfer(This,pPhotoAcquireSource)	\
    ( (This)->lpVtbl -> StartTransfer(This,pPhotoAcquireSource) ) 

#define IPhotoAcquireProgressCB_StartItemTransfer(This,nItemIndex,pPhotoAcquireItem)	\
    ( (This)->lpVtbl -> StartItemTransfer(This,nItemIndex,pPhotoAcquireItem) ) 

#define IPhotoAcquireProgressCB_DirectoryCreated(This,pszDirectory)	\
    ( (This)->lpVtbl -> DirectoryCreated(This,pszDirectory) ) 

#define IPhotoAcquireProgressCB_UpdateTransferPercent(This,fOverall,nPercent)	\
    ( (This)->lpVtbl -> UpdateTransferPercent(This,fOverall,nPercent) ) 

#define IPhotoAcquireProgressCB_EndItemTransfer(This,nItemIndex,pPhotoAcquireItem,hr)	\
    ( (This)->lpVtbl -> EndItemTransfer(This,nItemIndex,pPhotoAcquireItem,hr) ) 

#define IPhotoAcquireProgressCB_EndTransfer(This,hr)	\
    ( (This)->lpVtbl -> EndTransfer(This,hr) ) 

#define IPhotoAcquireProgressCB_StartDelete(This,pPhotoAcquireSource)	\
    ( (This)->lpVtbl -> StartDelete(This,pPhotoAcquireSource) ) 

#define IPhotoAcquireProgressCB_StartItemDelete(This,nItemIndex,pPhotoAcquireItem)	\
    ( (This)->lpVtbl -> StartItemDelete(This,nItemIndex,pPhotoAcquireItem) ) 

#define IPhotoAcquireProgressCB_UpdateDeletePercent(This,nPercent)	\
    ( (This)->lpVtbl -> UpdateDeletePercent(This,nPercent) ) 

#define IPhotoAcquireProgressCB_EndItemDelete(This,nItemIndex,pPhotoAcquireItem,hr)	\
    ( (This)->lpVtbl -> EndItemDelete(This,nItemIndex,pPhotoAcquireItem,hr) ) 

#define IPhotoAcquireProgressCB_EndDelete(This,hr)	\
    ( (This)->lpVtbl -> EndDelete(This,hr) ) 

#define IPhotoAcquireProgressCB_EndSession(This,hr)	\
    ( (This)->lpVtbl -> EndSession(This,hr) ) 

#define IPhotoAcquireProgressCB_GetDeleteAfterAcquire(This,pfDeleteAfterAcquire)	\
    ( (This)->lpVtbl -> GetDeleteAfterAcquire(This,pfDeleteAfterAcquire) ) 

#define IPhotoAcquireProgressCB_ErrorAdvise(This,hr,pszErrorMessage,nMessageType,pnErrorAdviseResult)	\
    ( (This)->lpVtbl -> ErrorAdvise(This,hr,pszErrorMessage,nMessageType,pnErrorAdviseResult) ) 

#define IPhotoAcquireProgressCB_GetUserInput(This,riidType,pUnknown,pPropVarResult,pPropVarDefault)	\
    ( (This)->lpVtbl -> GetUserInput(This,riidType,pUnknown,pPropVarResult,pPropVarDefault) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPhotoAcquireProgressCB_INTERFACE_DEFINED__ */


#ifndef __IPhotoProgressActionCB_INTERFACE_DEFINED__
#define __IPhotoProgressActionCB_INTERFACE_DEFINED__

/* interface IPhotoProgressActionCB */
/* [unique][uuid][object][helpstring] */ 


EXTERN_C const IID IID_IPhotoProgressActionCB;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00f242d0-b206-4e7d-b4c1-4755bcbb9c9f")
    IPhotoProgressActionCB : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DoAction( 
            __RPC__in HWND hWndParent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPhotoProgressActionCBVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPhotoProgressActionCB * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPhotoProgressActionCB * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPhotoProgressActionCB * This);
        
        HRESULT ( STDMETHODCALLTYPE *DoAction )( 
            IPhotoProgressActionCB * This,
            __RPC__in HWND hWndParent);
        
        END_INTERFACE
    } IPhotoProgressActionCBVtbl;

    interface IPhotoProgressActionCB
    {
        CONST_VTBL struct IPhotoProgressActionCBVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPhotoProgressActionCB_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPhotoProgressActionCB_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPhotoProgressActionCB_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPhotoProgressActionCB_DoAction(This,hWndParent)	\
    ( (This)->lpVtbl -> DoAction(This,hWndParent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPhotoProgressActionCB_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_photoacquire_0000_0004 */
/* [local] */ 

#define PROGRESS_INDETERMINATE (-1)


extern RPC_IF_HANDLE __MIDL_itf_photoacquire_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_photoacquire_0000_0004_v0_0_s_ifspec;

#ifndef __IPhotoProgressDialog_INTERFACE_DEFINED__
#define __IPhotoProgressDialog_INTERFACE_DEFINED__

/* interface IPhotoProgressDialog */
/* [unique][uuid][object][helpstring] */ 

typedef /* [v1_enum] */ 
enum tagPROGRESS_DIALOG_IMAGE_TYPE
    {	PROGRESS_DIALOG_ICON_SMALL	= 0,
	PROGRESS_DIALOG_ICON_LARGE	= 0x1,
	PROGRESS_DIALOG_ICON_THUMBNAIL	= 0x2,
	PROGRESS_DIALOG_BITMAP_THUMBNAIL	= 0x3
    } 	PROGRESS_DIALOG_IMAGE_TYPE;

typedef /* [v1_enum] */ 
enum tagPROGRESS_DIALOG_CHECKBOX_ID
    {	PROGRESS_DIALOG_CHECKBOX_ID_DEFAULT	= 0
    } 	PROGRESS_DIALOG_CHECKBOX_ID;


EXTERN_C const IID IID_IPhotoProgressDialog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00f246f9-0750-4f08-9381-2cd8e906a4ae")
    IPhotoProgressDialog : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ __RPC__in HWND hwndParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWindow( 
            /* [out] */ __RPC__deref_out_opt HWND *phwndProgressDialog) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Destroy( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTitle( 
            /* [string][in] */ __RPC__in LPCWSTR pszTitle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowCheckbox( 
            /* [in] */ PROGRESS_DIALOG_CHECKBOX_ID nCheckboxId,
            /* [in] */ BOOL fShow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCheckboxText( 
            /* [in] */ PROGRESS_DIALOG_CHECKBOX_ID nCheckboxId,
            /* [string][in] */ __RPC__in LPCWSTR pszCheckboxText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCheckboxCheck( 
            /* [in] */ PROGRESS_DIALOG_CHECKBOX_ID nCheckboxId,
            /* [in] */ BOOL fChecked) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCheckboxTooltip( 
            /* [in] */ PROGRESS_DIALOG_CHECKBOX_ID nCheckboxId,
            /* [string][in] */ __RPC__in LPCWSTR pszCheckboxTooltipText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsCheckboxChecked( 
            /* [in] */ PROGRESS_DIALOG_CHECKBOX_ID nCheckboxId,
            /* [out] */ __RPC__out BOOL *pfChecked) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCaption( 
            /* [string][in] */ __RPC__in LPCWSTR pszTitle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetImage( 
            /* [in] */ PROGRESS_DIALOG_IMAGE_TYPE nImageType,
            /* [unique][in] */ __RPC__in_opt HICON hIcon,
            /* [unique][in] */ __RPC__in_opt HBITMAP hBitmap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPercentComplete( 
            /* [in] */ int nPercent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProgressText( 
            /* [string][in] */ __RPC__in LPCWSTR pszProgressText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActionLinkCallback( 
            /* [in] */ __RPC__in_opt IPhotoProgressActionCB *pPhotoProgressActionCB) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActionLinkText( 
            /* [in] */ __RPC__in LPCWSTR pszCaption) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowActionLink( 
            /* [in] */ BOOL fShow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsCancelled( 
            /* [out] */ __RPC__out BOOL *pfCancelled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserInput( 
            /* [in] */ __RPC__in REFIID riidType,
            /* [in] */ __RPC__in_opt IUnknown *pUnknown,
            /* [out] */ __RPC__out PROPVARIANT *pPropVarResult,
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *pPropVarDefault) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPhotoProgressDialogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPhotoProgressDialog * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPhotoProgressDialog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPhotoProgressDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            IPhotoProgressDialog * This,
            /* [in] */ __RPC__in HWND hwndParent);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IPhotoProgressDialog * This,
            /* [out] */ __RPC__deref_out_opt HWND *phwndProgressDialog);
        
        HRESULT ( STDMETHODCALLTYPE *Destroy )( 
            IPhotoProgressDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetTitle )( 
            IPhotoProgressDialog * This,
            /* [string][in] */ __RPC__in LPCWSTR pszTitle);
        
        HRESULT ( STDMETHODCALLTYPE *ShowCheckbox )( 
            IPhotoProgressDialog * This,
            /* [in] */ PROGRESS_DIALOG_CHECKBOX_ID nCheckboxId,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *SetCheckboxText )( 
            IPhotoProgressDialog * This,
            /* [in] */ PROGRESS_DIALOG_CHECKBOX_ID nCheckboxId,
            /* [string][in] */ __RPC__in LPCWSTR pszCheckboxText);
        
        HRESULT ( STDMETHODCALLTYPE *SetCheckboxCheck )( 
            IPhotoProgressDialog * This,
            /* [in] */ PROGRESS_DIALOG_CHECKBOX_ID nCheckboxId,
            /* [in] */ BOOL fChecked);
        
        HRESULT ( STDMETHODCALLTYPE *SetCheckboxTooltip )( 
            IPhotoProgressDialog * This,
            /* [in] */ PROGRESS_DIALOG_CHECKBOX_ID nCheckboxId,
            /* [string][in] */ __RPC__in LPCWSTR pszCheckboxTooltipText);
        
        HRESULT ( STDMETHODCALLTYPE *IsCheckboxChecked )( 
            IPhotoProgressDialog * This,
            /* [in] */ PROGRESS_DIALOG_CHECKBOX_ID nCheckboxId,
            /* [out] */ __RPC__out BOOL *pfChecked);
        
        HRESULT ( STDMETHODCALLTYPE *SetCaption )( 
            IPhotoProgressDialog * This,
            /* [string][in] */ __RPC__in LPCWSTR pszTitle);
        
        HRESULT ( STDMETHODCALLTYPE *SetImage )( 
            IPhotoProgressDialog * This,
            /* [in] */ PROGRESS_DIALOG_IMAGE_TYPE nImageType,
            /* [unique][in] */ __RPC__in_opt HICON hIcon,
            /* [unique][in] */ __RPC__in_opt HBITMAP hBitmap);
        
        HRESULT ( STDMETHODCALLTYPE *SetPercentComplete )( 
            IPhotoProgressDialog * This,
            /* [in] */ int nPercent);
        
        HRESULT ( STDMETHODCALLTYPE *SetProgressText )( 
            IPhotoProgressDialog * This,
            /* [string][in] */ __RPC__in LPCWSTR pszProgressText);
        
        HRESULT ( STDMETHODCALLTYPE *SetActionLinkCallback )( 
            IPhotoProgressDialog * This,
            /* [in] */ __RPC__in_opt IPhotoProgressActionCB *pPhotoProgressActionCB);
        
        HRESULT ( STDMETHODCALLTYPE *SetActionLinkText )( 
            IPhotoProgressDialog * This,
            /* [in] */ __RPC__in LPCWSTR pszCaption);
        
        HRESULT ( STDMETHODCALLTYPE *ShowActionLink )( 
            IPhotoProgressDialog * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *IsCancelled )( 
            IPhotoProgressDialog * This,
            /* [out] */ __RPC__out BOOL *pfCancelled);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserInput )( 
            IPhotoProgressDialog * This,
            /* [in] */ __RPC__in REFIID riidType,
            /* [in] */ __RPC__in_opt IUnknown *pUnknown,
            /* [out] */ __RPC__out PROPVARIANT *pPropVarResult,
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *pPropVarDefault);
        
        END_INTERFACE
    } IPhotoProgressDialogVtbl;

    interface IPhotoProgressDialog
    {
        CONST_VTBL struct IPhotoProgressDialogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPhotoProgressDialog_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPhotoProgressDialog_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPhotoProgressDialog_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPhotoProgressDialog_Create(This,hwndParent)	\
    ( (This)->lpVtbl -> Create(This,hwndParent) ) 

#define IPhotoProgressDialog_GetWindow(This,phwndProgressDialog)	\
    ( (This)->lpVtbl -> GetWindow(This,phwndProgressDialog) ) 

#define IPhotoProgressDialog_Destroy(This)	\
    ( (This)->lpVtbl -> Destroy(This) ) 

#define IPhotoProgressDialog_SetTitle(This,pszTitle)	\
    ( (This)->lpVtbl -> SetTitle(This,pszTitle) ) 

#define IPhotoProgressDialog_ShowCheckbox(This,nCheckboxId,fShow)	\
    ( (This)->lpVtbl -> ShowCheckbox(This,nCheckboxId,fShow) ) 

#define IPhotoProgressDialog_SetCheckboxText(This,nCheckboxId,pszCheckboxText)	\
    ( (This)->lpVtbl -> SetCheckboxText(This,nCheckboxId,pszCheckboxText) ) 

#define IPhotoProgressDialog_SetCheckboxCheck(This,nCheckboxId,fChecked)	\
    ( (This)->lpVtbl -> SetCheckboxCheck(This,nCheckboxId,fChecked) ) 

#define IPhotoProgressDialog_SetCheckboxTooltip(This,nCheckboxId,pszCheckboxTooltipText)	\
    ( (This)->lpVtbl -> SetCheckboxTooltip(This,nCheckboxId,pszCheckboxTooltipText) ) 

#define IPhotoProgressDialog_IsCheckboxChecked(This,nCheckboxId,pfChecked)	\
    ( (This)->lpVtbl -> IsCheckboxChecked(This,nCheckboxId,pfChecked) ) 

#define IPhotoProgressDialog_SetCaption(This,pszTitle)	\
    ( (This)->lpVtbl -> SetCaption(This,pszTitle) ) 

#define IPhotoProgressDialog_SetImage(This,nImageType,hIcon,hBitmap)	\
    ( (This)->lpVtbl -> SetImage(This,nImageType,hIcon,hBitmap) ) 

#define IPhotoProgressDialog_SetPercentComplete(This,nPercent)	\
    ( (This)->lpVtbl -> SetPercentComplete(This,nPercent) ) 

#define IPhotoProgressDialog_SetProgressText(This,pszProgressText)	\
    ( (This)->lpVtbl -> SetProgressText(This,pszProgressText) ) 

#define IPhotoProgressDialog_SetActionLinkCallback(This,pPhotoProgressActionCB)	\
    ( (This)->lpVtbl -> SetActionLinkCallback(This,pPhotoProgressActionCB) ) 

#define IPhotoProgressDialog_SetActionLinkText(This,pszCaption)	\
    ( (This)->lpVtbl -> SetActionLinkText(This,pszCaption) ) 

#define IPhotoProgressDialog_ShowActionLink(This,fShow)	\
    ( (This)->lpVtbl -> ShowActionLink(This,fShow) ) 

#define IPhotoProgressDialog_IsCancelled(This,pfCancelled)	\
    ( (This)->lpVtbl -> IsCancelled(This,pfCancelled) ) 

#define IPhotoProgressDialog_GetUserInput(This,riidType,pUnknown,pPropVarResult,pPropVarDefault)	\
    ( (This)->lpVtbl -> GetUserInput(This,riidType,pUnknown,pPropVarResult,pPropVarDefault) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPhotoProgressDialog_INTERFACE_DEFINED__ */


#ifndef __IPhotoAcquireSource_INTERFACE_DEFINED__
#define __IPhotoAcquireSource_INTERFACE_DEFINED__

/* interface IPhotoAcquireSource */
/* [unique][uuid][object][helpstring] */ 


EXTERN_C const IID IID_IPhotoAcquireSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00f2c703-8613-4282-a53b-6ec59c5883ac")
    IPhotoAcquireSource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFriendlyName( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrFriendlyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceIcons( 
            /* [in] */ UINT nSize,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt HICON *phLargeIcon,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt HICON *phSmallIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeItemList( 
            /* [in] */ BOOL fForceEnumeration,
            /* [unique][in] */ __RPC__in_opt IPhotoAcquireProgressCB *pPhotoAcquireProgressCB,
            /* [unique][out][in] */ __RPC__inout_opt UINT *pnItemCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemCount( 
            /* [out] */ __RPC__out UINT *pnItemCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemAt( 
            /* [in] */ UINT nIndex,
            /* [out] */ __RPC__deref_out_opt IPhotoAcquireItem **ppPhotoAcquireItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPhotoAcquireSettings( 
            /* [out] */ __RPC__deref_out_opt IPhotoAcquireSettings **ppPhotoAcquireSettings) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceId( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrDeviceId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToObject( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPhotoAcquireSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPhotoAcquireSource * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPhotoAcquireSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPhotoAcquireSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFriendlyName )( 
            IPhotoAcquireSource * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrFriendlyName);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceIcons )( 
            IPhotoAcquireSource * This,
            /* [in] */ UINT nSize,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt HICON *phLargeIcon,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt HICON *phSmallIcon);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeItemList )( 
            IPhotoAcquireSource * This,
            /* [in] */ BOOL fForceEnumeration,
            /* [unique][in] */ __RPC__in_opt IPhotoAcquireProgressCB *pPhotoAcquireProgressCB,
            /* [unique][out][in] */ __RPC__inout_opt UINT *pnItemCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemCount )( 
            IPhotoAcquireSource * This,
            /* [out] */ __RPC__out UINT *pnItemCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemAt )( 
            IPhotoAcquireSource * This,
            /* [in] */ UINT nIndex,
            /* [out] */ __RPC__deref_out_opt IPhotoAcquireItem **ppPhotoAcquireItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetPhotoAcquireSettings )( 
            IPhotoAcquireSource * This,
            /* [out] */ __RPC__deref_out_opt IPhotoAcquireSettings **ppPhotoAcquireSettings);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceId )( 
            IPhotoAcquireSource * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrDeviceId);
        
        HRESULT ( STDMETHODCALLTYPE *BindToObject )( 
            IPhotoAcquireSource * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IPhotoAcquireSourceVtbl;

    interface IPhotoAcquireSource
    {
        CONST_VTBL struct IPhotoAcquireSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPhotoAcquireSource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPhotoAcquireSource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPhotoAcquireSource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPhotoAcquireSource_GetFriendlyName(This,pbstrFriendlyName)	\
    ( (This)->lpVtbl -> GetFriendlyName(This,pbstrFriendlyName) ) 

#define IPhotoAcquireSource_GetDeviceIcons(This,nSize,phLargeIcon,phSmallIcon)	\
    ( (This)->lpVtbl -> GetDeviceIcons(This,nSize,phLargeIcon,phSmallIcon) ) 

#define IPhotoAcquireSource_InitializeItemList(This,fForceEnumeration,pPhotoAcquireProgressCB,pnItemCount)	\
    ( (This)->lpVtbl -> InitializeItemList(This,fForceEnumeration,pPhotoAcquireProgressCB,pnItemCount) ) 

#define IPhotoAcquireSource_GetItemCount(This,pnItemCount)	\
    ( (This)->lpVtbl -> GetItemCount(This,pnItemCount) ) 

#define IPhotoAcquireSource_GetItemAt(This,nIndex,ppPhotoAcquireItem)	\
    ( (This)->lpVtbl -> GetItemAt(This,nIndex,ppPhotoAcquireItem) ) 

#define IPhotoAcquireSource_GetPhotoAcquireSettings(This,ppPhotoAcquireSettings)	\
    ( (This)->lpVtbl -> GetPhotoAcquireSettings(This,ppPhotoAcquireSettings) ) 

#define IPhotoAcquireSource_GetDeviceId(This,pbstrDeviceId)	\
    ( (This)->lpVtbl -> GetDeviceId(This,pbstrDeviceId) ) 

#define IPhotoAcquireSource_BindToObject(This,riid,ppv)	\
    ( (This)->lpVtbl -> BindToObject(This,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPhotoAcquireSource_INTERFACE_DEFINED__ */


#ifndef __IPhotoAcquire_INTERFACE_DEFINED__
#define __IPhotoAcquire_INTERFACE_DEFINED__

/* interface IPhotoAcquire */
/* [unique][uuid][object][helpstring] */ 


EXTERN_C const IID IID_IPhotoAcquire;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00f23353-e31b-4955-a8ad-ca5ebf31e2ce")
    IPhotoAcquire : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreatePhotoSource( 
            /* [string][in] */ __RPC__in LPCWSTR pszDevice,
            /* [out] */ __RPC__deref_out_opt IPhotoAcquireSource **ppPhotoAcquireSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Acquire( 
            /* [in] */ __RPC__in_opt IPhotoAcquireSource *pPhotoAcquireSource,
            /* [in] */ BOOL fShowProgress,
            /* [unique][in] */ __RPC__in_opt HWND hWndParent,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszApplicationName,
            /* [unique][in] */ __RPC__in_opt IPhotoAcquireProgressCB *pPhotoAcquireProgressCB) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumResults( 
            /* [out] */ __RPC__deref_out_opt IEnumString **ppEnumFilePaths) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPhotoAcquireVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPhotoAcquire * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPhotoAcquire * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPhotoAcquire * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePhotoSource )( 
            IPhotoAcquire * This,
            /* [string][in] */ __RPC__in LPCWSTR pszDevice,
            /* [out] */ __RPC__deref_out_opt IPhotoAcquireSource **ppPhotoAcquireSource);
        
        HRESULT ( STDMETHODCALLTYPE *Acquire )( 
            IPhotoAcquire * This,
            /* [in] */ __RPC__in_opt IPhotoAcquireSource *pPhotoAcquireSource,
            /* [in] */ BOOL fShowProgress,
            /* [unique][in] */ __RPC__in_opt HWND hWndParent,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszApplicationName,
            /* [unique][in] */ __RPC__in_opt IPhotoAcquireProgressCB *pPhotoAcquireProgressCB);
        
        HRESULT ( STDMETHODCALLTYPE *EnumResults )( 
            IPhotoAcquire * This,
            /* [out] */ __RPC__deref_out_opt IEnumString **ppEnumFilePaths);
        
        END_INTERFACE
    } IPhotoAcquireVtbl;

    interface IPhotoAcquire
    {
        CONST_VTBL struct IPhotoAcquireVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPhotoAcquire_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPhotoAcquire_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPhotoAcquire_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPhotoAcquire_CreatePhotoSource(This,pszDevice,ppPhotoAcquireSource)	\
    ( (This)->lpVtbl -> CreatePhotoSource(This,pszDevice,ppPhotoAcquireSource) ) 

#define IPhotoAcquire_Acquire(This,pPhotoAcquireSource,fShowProgress,hWndParent,pszApplicationName,pPhotoAcquireProgressCB)	\
    ( (This)->lpVtbl -> Acquire(This,pPhotoAcquireSource,fShowProgress,hWndParent,pszApplicationName,pPhotoAcquireProgressCB) ) 

#define IPhotoAcquire_EnumResults(This,ppEnumFilePaths)	\
    ( (This)->lpVtbl -> EnumResults(This,ppEnumFilePaths) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPhotoAcquire_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_photoacquire_0000_0007 */
/* [local] */ 

// IPhotoAcquire::Acquire will return this value if a user operation requires a restart.
// If you receive this, you should discard all interfaces and restart completely.
// You can only receive this if you specify the PHOTOACQ_ABORT_ON_SETTINGS_UPDATE flag.
#define PHOTOACQ_ERROR_RESTART_REQUIRED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA001)
#define PHOTOACQ_RUN_DEFAULT                      0x00000000
#define PHOTOACQ_NO_GALLERY_LAUNCH                0x00000001
#define PHOTOACQ_DISABLE_AUTO_ROTATE              0x00000002
#define PHOTOACQ_DISABLE_PLUGINS                  0x00000004
#define PHOTOACQ_DISABLE_GROUP_TAG_PROMPT         0x00000008
#define PHOTOACQ_DISABLE_DB_INTEGRATION           0x00000010
#define PHOTOACQ_DELETE_AFTER_ACQUIRE             0x00000020
#define PHOTOACQ_DISABLE_DUPLICATE_DETECTION      0x00000040
#define PHOTOACQ_ENABLE_THUMBNAIL_CACHING         0x00000080
#define PHOTOACQ_DISABLE_METADATA_WRITE           0x00000100
#define PHOTOACQ_DISABLE_THUMBNAIL_PROGRESS       0x00000200
#define PHOTOACQ_DISABLE_SETTINGS_LINK            0x00000400
#define PHOTOACQ_ABORT_ON_SETTINGS_UPDATE         0x00000800


extern RPC_IF_HANDLE __MIDL_itf_photoacquire_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_photoacquire_0000_0007_v0_0_s_ifspec;

#ifndef __IPhotoAcquireSettings_INTERFACE_DEFINED__
#define __IPhotoAcquireSettings_INTERFACE_DEFINED__

/* interface IPhotoAcquireSettings */
/* [unique][uuid][object][helpstring] */ 


EXTERN_C const IID IID_IPhotoAcquireSettings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00f2b868-dd67-487c-9553-049240767e91")
    IPhotoAcquireSettings : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeFromRegistry( 
            /* [in] */ __RPC__in LPCWSTR pszRegistryKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ DWORD dwPhotoAcquireFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputFilenameTemplate( 
            /* [string][in] */ __RPC__in LPCWSTR pszTemplate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSequencePaddingWidth( 
            /* [in] */ DWORD dwWidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSequenceZeroPadding( 
            /* [in] */ BOOL fZeroPad) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGroupTag( 
            /* [string][in] */ __RPC__in LPCWSTR pszGroupTag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAcquisitionTime( 
            /* [in] */ __RPC__in const FILETIME *pftAcquisitionTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [out] */ __RPC__out DWORD *pdwPhotoAcquireFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputFilenameTemplate( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrTemplate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSequencePaddingWidth( 
            /* [out] */ __RPC__out DWORD *pdwWidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSequenceZeroPadding( 
            /* [out] */ __RPC__out BOOL *pfZeroPad) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupTag( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrGroupTag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAcquisitionTime( 
            /* [out] */ __RPC__out FILETIME *pftAcquisitionTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPhotoAcquireSettingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPhotoAcquireSettings * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPhotoAcquireSettings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPhotoAcquireSettings * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromRegistry )( 
            IPhotoAcquireSettings * This,
            /* [in] */ __RPC__in LPCWSTR pszRegistryKey);
        
        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            IPhotoAcquireSettings * This,
            /* [in] */ DWORD dwPhotoAcquireFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputFilenameTemplate )( 
            IPhotoAcquireSettings * This,
            /* [string][in] */ __RPC__in LPCWSTR pszTemplate);
        
        HRESULT ( STDMETHODCALLTYPE *SetSequencePaddingWidth )( 
            IPhotoAcquireSettings * This,
            /* [in] */ DWORD dwWidth);
        
        HRESULT ( STDMETHODCALLTYPE *SetSequenceZeroPadding )( 
            IPhotoAcquireSettings * This,
            /* [in] */ BOOL fZeroPad);
        
        HRESULT ( STDMETHODCALLTYPE *SetGroupTag )( 
            IPhotoAcquireSettings * This,
            /* [string][in] */ __RPC__in LPCWSTR pszGroupTag);
        
        HRESULT ( STDMETHODCALLTYPE *SetAcquisitionTime )( 
            IPhotoAcquireSettings * This,
            /* [in] */ __RPC__in const FILETIME *pftAcquisitionTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            IPhotoAcquireSettings * This,
            /* [out] */ __RPC__out DWORD *pdwPhotoAcquireFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputFilenameTemplate )( 
            IPhotoAcquireSettings * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrTemplate);
        
        HRESULT ( STDMETHODCALLTYPE *GetSequencePaddingWidth )( 
            IPhotoAcquireSettings * This,
            /* [out] */ __RPC__out DWORD *pdwWidth);
        
        HRESULT ( STDMETHODCALLTYPE *GetSequenceZeroPadding )( 
            IPhotoAcquireSettings * This,
            /* [out] */ __RPC__out BOOL *pfZeroPad);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupTag )( 
            IPhotoAcquireSettings * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrGroupTag);
        
        HRESULT ( STDMETHODCALLTYPE *GetAcquisitionTime )( 
            IPhotoAcquireSettings * This,
            /* [out] */ __RPC__out FILETIME *pftAcquisitionTime);
        
        END_INTERFACE
    } IPhotoAcquireSettingsVtbl;

    interface IPhotoAcquireSettings
    {
        CONST_VTBL struct IPhotoAcquireSettingsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPhotoAcquireSettings_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPhotoAcquireSettings_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPhotoAcquireSettings_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPhotoAcquireSettings_InitializeFromRegistry(This,pszRegistryKey)	\
    ( (This)->lpVtbl -> InitializeFromRegistry(This,pszRegistryKey) ) 

#define IPhotoAcquireSettings_SetFlags(This,dwPhotoAcquireFlags)	\
    ( (This)->lpVtbl -> SetFlags(This,dwPhotoAcquireFlags) ) 

#define IPhotoAcquireSettings_SetOutputFilenameTemplate(This,pszTemplate)	\
    ( (This)->lpVtbl -> SetOutputFilenameTemplate(This,pszTemplate) ) 

#define IPhotoAcquireSettings_SetSequencePaddingWidth(This,dwWidth)	\
    ( (This)->lpVtbl -> SetSequencePaddingWidth(This,dwWidth) ) 

#define IPhotoAcquireSettings_SetSequenceZeroPadding(This,fZeroPad)	\
    ( (This)->lpVtbl -> SetSequenceZeroPadding(This,fZeroPad) ) 

#define IPhotoAcquireSettings_SetGroupTag(This,pszGroupTag)	\
    ( (This)->lpVtbl -> SetGroupTag(This,pszGroupTag) ) 

#define IPhotoAcquireSettings_SetAcquisitionTime(This,pftAcquisitionTime)	\
    ( (This)->lpVtbl -> SetAcquisitionTime(This,pftAcquisitionTime) ) 

#define IPhotoAcquireSettings_GetFlags(This,pdwPhotoAcquireFlags)	\
    ( (This)->lpVtbl -> GetFlags(This,pdwPhotoAcquireFlags) ) 

#define IPhotoAcquireSettings_GetOutputFilenameTemplate(This,pbstrTemplate)	\
    ( (This)->lpVtbl -> GetOutputFilenameTemplate(This,pbstrTemplate) ) 

#define IPhotoAcquireSettings_GetSequencePaddingWidth(This,pdwWidth)	\
    ( (This)->lpVtbl -> GetSequencePaddingWidth(This,pdwWidth) ) 

#define IPhotoAcquireSettings_GetSequenceZeroPadding(This,pfZeroPad)	\
    ( (This)->lpVtbl -> GetSequenceZeroPadding(This,pfZeroPad) ) 

#define IPhotoAcquireSettings_GetGroupTag(This,pbstrGroupTag)	\
    ( (This)->lpVtbl -> GetGroupTag(This,pbstrGroupTag) ) 

#define IPhotoAcquireSettings_GetAcquisitionTime(This,pftAcquisitionTime)	\
    ( (This)->lpVtbl -> GetAcquisitionTime(This,pftAcquisitionTime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPhotoAcquireSettings_INTERFACE_DEFINED__ */


#ifndef __IPhotoAcquireOptionsDialog_INTERFACE_DEFINED__
#define __IPhotoAcquireOptionsDialog_INTERFACE_DEFINED__

/* interface IPhotoAcquireOptionsDialog */
/* [unique][uuid][object][helpstring] */ 


EXTERN_C const IID IID_IPhotoAcquireOptionsDialog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00f2b3ee-bf64-47ee-89f4-4dedd79643f2")
    IPhotoAcquireOptionsDialog : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszRegistryRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ __RPC__in HWND hWndParent,
            /* [out] */ __RPC__deref_out_opt HWND *phWndDialog) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Destroy( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoModal( 
            /* [in] */ __RPC__in HWND hWndParent,
            /* [unique][out][in] */ __RPC__inout_opt INT_PTR *ppnReturnCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveData( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPhotoAcquireOptionsDialogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPhotoAcquireOptionsDialog * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPhotoAcquireOptionsDialog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPhotoAcquireOptionsDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IPhotoAcquireOptionsDialog * This,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszRegistryRoot);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            IPhotoAcquireOptionsDialog * This,
            /* [in] */ __RPC__in HWND hWndParent,
            /* [out] */ __RPC__deref_out_opt HWND *phWndDialog);
        
        HRESULT ( STDMETHODCALLTYPE *Destroy )( 
            IPhotoAcquireOptionsDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *DoModal )( 
            IPhotoAcquireOptionsDialog * This,
            /* [in] */ __RPC__in HWND hWndParent,
            /* [unique][out][in] */ __RPC__inout_opt INT_PTR *ppnReturnCode);
        
        HRESULT ( STDMETHODCALLTYPE *SaveData )( 
            IPhotoAcquireOptionsDialog * This);
        
        END_INTERFACE
    } IPhotoAcquireOptionsDialogVtbl;

    interface IPhotoAcquireOptionsDialog
    {
        CONST_VTBL struct IPhotoAcquireOptionsDialogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPhotoAcquireOptionsDialog_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPhotoAcquireOptionsDialog_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPhotoAcquireOptionsDialog_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPhotoAcquireOptionsDialog_Initialize(This,pszRegistryRoot)	\
    ( (This)->lpVtbl -> Initialize(This,pszRegistryRoot) ) 

#define IPhotoAcquireOptionsDialog_Create(This,hWndParent,phWndDialog)	\
    ( (This)->lpVtbl -> Create(This,hWndParent,phWndDialog) ) 

#define IPhotoAcquireOptionsDialog_Destroy(This)	\
    ( (This)->lpVtbl -> Destroy(This) ) 

#define IPhotoAcquireOptionsDialog_DoModal(This,hWndParent,ppnReturnCode)	\
    ( (This)->lpVtbl -> DoModal(This,hWndParent,ppnReturnCode) ) 

#define IPhotoAcquireOptionsDialog_SaveData(This)	\
    ( (This)->lpVtbl -> SaveData(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPhotoAcquireOptionsDialog_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_photoacquire_0000_0009 */
/* [local] */ 

#define DSF_WPD_DEVICES    0x00000001
#define DSF_WIA_CAMERAS    0x00000002
#define DSF_WIA_SCANNERS   0x00000004
#define DSF_STI_DEVICES    0x00000008
#define DSF_TWAIN_DEVICES  0x00000010
#define DSF_FS_DEVICES     0x00000020
#define DSF_DV_DEVICES     0x00000040
#define DSF_ALL_DEVICES    0x0000FFFF
#define DSF_CPL_MODE       0x00010000
#define DSF_SHOW_OFFLINE   0x00020000


extern RPC_IF_HANDLE __MIDL_itf_photoacquire_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_photoacquire_0000_0009_v0_0_s_ifspec;

#ifndef __IPhotoAcquireDeviceSelectionDialog_INTERFACE_DEFINED__
#define __IPhotoAcquireDeviceSelectionDialog_INTERFACE_DEFINED__

/* interface IPhotoAcquireDeviceSelectionDialog */
/* [unique][uuid][object][helpstring] */ 

typedef /* [v1_enum] */ 
enum tagDEVICE_SELECTION_DEVICE_TYPE
    {	DST_UNKNOWN_DEVICE	= 0,
	DST_WPD_DEVICE	= 0x1,
	DST_WIA_DEVICE	= 0x2,
	DST_STI_DEVICE	= 0x3,
	DSF_TWAIN_DEVICE	= 0x4,
	DST_FS_DEVICE	= 0x5,
	DST_DV_DEVICE	= 0x6
    } 	DEVICE_SELECTION_DEVICE_TYPE;


EXTERN_C const IID IID_IPhotoAcquireDeviceSelectionDialog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00f28837-55dd-4f37-aaf5-6855a9640467")
    IPhotoAcquireDeviceSelectionDialog : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetTitle( 
            /* [string][in] */ __RPC__in LPCWSTR pszTitle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSubmitButtonText( 
            /* [string][in] */ __RPC__in LPCWSTR pszSubmitButtonText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoModal( 
            /* [in] */ __RPC__in HWND hWndParent,
            /* [in] */ DWORD dwDeviceFlags,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt BSTR *pbstrDeviceId,
            /* [unique][out][in] */ __RPC__inout_opt DEVICE_SELECTION_DEVICE_TYPE *pnDeviceType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPhotoAcquireDeviceSelectionDialogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPhotoAcquireDeviceSelectionDialog * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPhotoAcquireDeviceSelectionDialog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPhotoAcquireDeviceSelectionDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetTitle )( 
            IPhotoAcquireDeviceSelectionDialog * This,
            /* [string][in] */ __RPC__in LPCWSTR pszTitle);
        
        HRESULT ( STDMETHODCALLTYPE *SetSubmitButtonText )( 
            IPhotoAcquireDeviceSelectionDialog * This,
            /* [string][in] */ __RPC__in LPCWSTR pszSubmitButtonText);
        
        HRESULT ( STDMETHODCALLTYPE *DoModal )( 
            IPhotoAcquireDeviceSelectionDialog * This,
            /* [in] */ __RPC__in HWND hWndParent,
            /* [in] */ DWORD dwDeviceFlags,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt BSTR *pbstrDeviceId,
            /* [unique][out][in] */ __RPC__inout_opt DEVICE_SELECTION_DEVICE_TYPE *pnDeviceType);
        
        END_INTERFACE
    } IPhotoAcquireDeviceSelectionDialogVtbl;

    interface IPhotoAcquireDeviceSelectionDialog
    {
        CONST_VTBL struct IPhotoAcquireDeviceSelectionDialogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPhotoAcquireDeviceSelectionDialog_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPhotoAcquireDeviceSelectionDialog_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPhotoAcquireDeviceSelectionDialog_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPhotoAcquireDeviceSelectionDialog_SetTitle(This,pszTitle)	\
    ( (This)->lpVtbl -> SetTitle(This,pszTitle) ) 

#define IPhotoAcquireDeviceSelectionDialog_SetSubmitButtonText(This,pszSubmitButtonText)	\
    ( (This)->lpVtbl -> SetSubmitButtonText(This,pszSubmitButtonText) ) 

#define IPhotoAcquireDeviceSelectionDialog_DoModal(This,hWndParent,dwDeviceFlags,pbstrDeviceId,pnDeviceType)	\
    ( (This)->lpVtbl -> DoModal(This,hWndParent,dwDeviceFlags,pbstrDeviceId,pnDeviceType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPhotoAcquireDeviceSelectionDialog_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_photoacquire_0000_0010 */
/* [local] */ 

#define PAPS_PRESAVE   0x00000000
#define PAPS_POSTSAVE  0x00000001
#define PAPS_CLEANUP   0x00000002


extern RPC_IF_HANDLE __MIDL_itf_photoacquire_0000_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_photoacquire_0000_0010_v0_0_s_ifspec;

#ifndef __IPhotoAcquirePlugin_INTERFACE_DEFINED__
#define __IPhotoAcquirePlugin_INTERFACE_DEFINED__

/* interface IPhotoAcquirePlugin */
/* [unique][uuid][object][helpstring] */ 


EXTERN_C const IID IID_IPhotoAcquirePlugin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00f2dceb-ecb8-4f77-8e47-e7a987c83dd0")
    IPhotoAcquirePlugin : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt IPhotoAcquireSource *pPhotoAcquireSource,
            /* [in] */ __RPC__in_opt IPhotoAcquireProgressCB *pPhotoAcquireProgressCB) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessItem( 
            /* [in] */ DWORD dwAcquireStage,
            /* [in] */ __RPC__in_opt IPhotoAcquireItem *pPhotoAcquireItem,
            /* [in] */ __RPC__in_opt IStream *pOriginalItemStream,
            /* [in] */ __RPC__in LPCWSTR pszFinalFilename,
            /* [in] */ __RPC__in_opt IPropertyStore *pPropertyStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TransferComplete( 
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisplayConfigureDialog( 
            __RPC__in HWND hWndParent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPhotoAcquirePluginVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPhotoAcquirePlugin * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPhotoAcquirePlugin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPhotoAcquirePlugin * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IPhotoAcquirePlugin * This,
            /* [in] */ __RPC__in_opt IPhotoAcquireSource *pPhotoAcquireSource,
            /* [in] */ __RPC__in_opt IPhotoAcquireProgressCB *pPhotoAcquireProgressCB);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessItem )( 
            IPhotoAcquirePlugin * This,
            /* [in] */ DWORD dwAcquireStage,
            /* [in] */ __RPC__in_opt IPhotoAcquireItem *pPhotoAcquireItem,
            /* [in] */ __RPC__in_opt IStream *pOriginalItemStream,
            /* [in] */ __RPC__in LPCWSTR pszFinalFilename,
            /* [in] */ __RPC__in_opt IPropertyStore *pPropertyStore);
        
        HRESULT ( STDMETHODCALLTYPE *TransferComplete )( 
            IPhotoAcquirePlugin * This,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE *DisplayConfigureDialog )( 
            IPhotoAcquirePlugin * This,
            __RPC__in HWND hWndParent);
        
        END_INTERFACE
    } IPhotoAcquirePluginVtbl;

    interface IPhotoAcquirePlugin
    {
        CONST_VTBL struct IPhotoAcquirePluginVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPhotoAcquirePlugin_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPhotoAcquirePlugin_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPhotoAcquirePlugin_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPhotoAcquirePlugin_Initialize(This,pPhotoAcquireSource,pPhotoAcquireProgressCB)	\
    ( (This)->lpVtbl -> Initialize(This,pPhotoAcquireSource,pPhotoAcquireProgressCB) ) 

#define IPhotoAcquirePlugin_ProcessItem(This,dwAcquireStage,pPhotoAcquireItem,pOriginalItemStream,pszFinalFilename,pPropertyStore)	\
    ( (This)->lpVtbl -> ProcessItem(This,dwAcquireStage,pPhotoAcquireItem,pOriginalItemStream,pszFinalFilename,pPropertyStore) ) 

#define IPhotoAcquirePlugin_TransferComplete(This,hr)	\
    ( (This)->lpVtbl -> TransferComplete(This,hr) ) 

#define IPhotoAcquirePlugin_DisplayConfigureDialog(This,hWndParent)	\
    ( (This)->lpVtbl -> DisplayConfigureDialog(This,hWndParent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPhotoAcquirePlugin_INTERFACE_DEFINED__ */



#ifndef __PhotoAcquireObjects_LIBRARY_DEFINED__
#define __PhotoAcquireObjects_LIBRARY_DEFINED__

/* library PhotoAcquireObjects */
/* [version][uuid] */ 


EXTERN_C const IID LIBID_PhotoAcquireObjects;

EXTERN_C const CLSID CLSID_PhotoAcquire;

#ifdef __cplusplus

class DECLSPEC_UUID("00f26e02-e9f2-4a9f-9fdd-5a962fb26a98")
PhotoAcquire;
#endif

EXTERN_C const CLSID CLSID_PhotoAcquireAutoPlayDropTarget;

#ifdef __cplusplus

class DECLSPEC_UUID("00f20eb5-8fd6-4d9d-b75e-36801766c8f1")
PhotoAcquireAutoPlayDropTarget;
#endif

EXTERN_C const CLSID CLSID_PhotoAcquireAutoPlayHWEventHandler;

#ifdef __cplusplus

class DECLSPEC_UUID("00f2b433-44e4-4d88-b2b0-2698a0a91dba")
PhotoAcquireAutoPlayHWEventHandler;
#endif

EXTERN_C const CLSID CLSID_PhotoAcquireOptionsDialog;

#ifdef __cplusplus

class DECLSPEC_UUID("00f210a1-62f0-438b-9f7e-9618d72a1831")
PhotoAcquireOptionsDialog;
#endif

EXTERN_C const CLSID CLSID_PhotoProgressDialog;

#ifdef __cplusplus

class DECLSPEC_UUID("00f24ca0-748f-4e8a-894f-0e0357c6799f")
PhotoProgressDialog;
#endif

EXTERN_C const CLSID CLSID_PhotoAcquireDeviceSelectionDialog;

#ifdef __cplusplus

class DECLSPEC_UUID("00f29a34-b8a1-482c-bcf8-3ac7b0fe8f62")
PhotoAcquireDeviceSelectionDialog;
#endif
#endif /* __PhotoAcquireObjects_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HBITMAP_UserSize(     unsigned long *, unsigned long            , HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserMarshal(  unsigned long *, unsigned char *, HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserUnmarshal(unsigned long *, unsigned char *, HBITMAP * ); 
void                      __RPC_USER  HBITMAP_UserFree(     unsigned long *, HBITMAP * ); 

unsigned long             __RPC_USER  HICON_UserSize(     unsigned long *, unsigned long            , HICON * ); 
unsigned char * __RPC_USER  HICON_UserMarshal(  unsigned long *, unsigned char *, HICON * ); 
unsigned char * __RPC_USER  HICON_UserUnmarshal(unsigned long *, unsigned char *, HICON * ); 
void                      __RPC_USER  HICON_UserFree(     unsigned long *, HICON * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HBITMAP_UserSize64(     unsigned long *, unsigned long            , HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserMarshal64(  unsigned long *, unsigned char *, HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserUnmarshal64(unsigned long *, unsigned char *, HBITMAP * ); 
void                      __RPC_USER  HBITMAP_UserFree64(     unsigned long *, HBITMAP * ); 

unsigned long             __RPC_USER  HICON_UserSize64(     unsigned long *, unsigned long            , HICON * ); 
unsigned char * __RPC_USER  HICON_UserMarshal64(  unsigned long *, unsigned char *, HICON * ); 
unsigned char * __RPC_USER  HICON_UserUnmarshal64(unsigned long *, unsigned char *, HICON * ); 
void                      __RPC_USER  HICON_UserFree64(     unsigned long *, HICON * ); 

unsigned long             __RPC_USER  HWND_UserSize64(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal64(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal64(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree64(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\perflib.h ===
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    perflib.h

Abstract:

    Public headers for PERFLIB provider APIs,
--*/

#ifndef _PERFLIB_H_
#define _PERFLIB_H_

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

// PERFLIB V2 provider side published literals, data structures and APIs.
//

// This is used in generated PERF_COUNTERSET_INFO structure to declare provider type.
// Kernel provider is reserved for Microsoft internal use.
// Driver provider and user-mode provider literals will be published.
//
#define PERF_PROVIDER_USER_MODE   0
#define PERF_PROVIDER_KERNEL_MODE 1
#define PERF_PROVIDER_DRIVER      2

// These are used for PERF_COUNTERSET_INFO::InstanceType value. That is, whether the CounterSet
// allows multiple instances (for example, Process, PhysicalDisk, etc) or only single default instance
// (for example, Memory, TCP, etc).
//
#define PERF_COUNTERSET_FLAG_MULTIPLE             2  // 0010
#define PERF_COUNTERSET_FLAG_AGGREGATE            4  // 0100
#define PERF_COUNTERSET_FLAG_HISTORY              8  // 1000
#define PERF_COUNTERSET_FLAG_INSTANCE            16  // 00010000

#define PERF_COUNTERSET_SINGLE_INSTANCE          0
#define PERF_COUNTERSET_MULTI_INSTANCES          (PERF_COUNTERSET_FLAG_MULTIPLE)
#define PERF_COUNTERSET_SINGLE_AGGREGATE         (PERF_COUNTERSET_FLAG_AGGREGATE)
#define PERF_COUNTERSET_MULTI_AGGREGATE          (PERF_COUNTERSET_FLAG_AGGREGATE | PERF_COUNTERSET_FLAG_MULTIPLE)
#define PERF_COUNTERSET_SINGLE_AGGREGATE_HISTORY (PERF_COUNTERSET_FLAG_HISTORY | PERF_COUNTERSET_SINGLE_AGGREGATE)
#define PERF_COUNTERSET_INSTANCE_AGGREGATE       (PERF_COUNTERSET_MULTI_AGGREGATE | PERF_COUNTERSET_FLAG_INSTANCE)

// Pre-defined aggregation function for CounterSets that need counter data aggregation. This is only useful
// for CounterSet with instanceType PERF_COUNTERSET_SINGLE_AGGREGATE, PERF_COUNTERSET_MULTI_AGGREGATE, and
// PERF_COUNTERSET_SINGLE_AGGREGATE_HISTORY. For other CounterSet instanceTypes, this is no effect.
//
#define PERF_AGGREGATE_UNDEFINED  0
#define PERF_AGGREGATE_TOTAL      1
#define PERF_AGGREGATE_AVG        2
#define PERF_AGGREGATE_MIN        3
#define PERF_AGGREGATE_MAX        4

// These are possible attributes used in generated PERF_COUNTER_INFO::Attrib value.
//
#define PERF_ATTRIB_BY_REFERENCE       0x0000000000000001
#define PERF_ATTRIB_NO_DISPLAYABLE     0x0000000000000002
#define PERF_ATTRIB_NO_GROUP_SEPARATOR 0x0000000000000004
#define PERF_ATTRIB_DISPLAY_AS_REAL    0x0000000000000008
#define PERF_ATTRIB_DISPLAY_AS_HEX     0x0000000000000010

// Provider counterset is defined as a leading PERF_COUNTERSET_INFO structure followed by a sequence
// of PERF_COUNTER_INFO structures. Note that the structure block will be automatically generated
// by schema generation/parsing tool.
//
typedef struct _PERF_COUNTERSET_INFO {
    GUID   CounterSetGuid;
    GUID   ProviderGuid;
    ULONG  NumCounters;
    ULONG  InstanceType;
} PERF_COUNTERSET_INFO, * PPERF_COUNTERSET_INFO;

typedef struct _PERF_COUNTER_INFO {
    ULONG      CounterId;     // max of 64K counters per GUID instance
    ULONG      Type;
    ULONGLONG  Attrib;
    ULONG      Size;
    ULONG      DetailLevel;
    LONG       Scale;
    ULONG      Offset;         // overlays to give the actual counter
} PERF_COUNTER_INFO, * PPERF_COUNTER_INFO;

// PERF_COUNTERSET_INSTANCE block is returned from PerfCreateInstance() API call to identify specific
// instance of a counterset. The returned block is formed by PERF_COUNTERSET_INSTANCE structure followed
// by counter data block (layout defined by provider counterset template) and instance name string (if exists).
//
typedef struct _PERF_COUNTERSET_INSTANCE {
    GUID   CounterSetGuid;
    ULONG  dwSize;
    ULONG  InstanceId;
    ULONG  InstanceNameOffset;
    ULONG  InstanceNameSize;
} PERF_COUNTERSET_INSTANCE, * PPERF_COUNTERSET_INSTANCE;

// PERF_COUNTER_IDENTITY structure is used in customized notification callback. Wheneven PERFLIB V2
// invokes customized notification callback, it passes wnode datablock (which contains WNODE_HEADER
// structure followed by other binary data) that contains the information providers can use.
//
// For PERF_ADD_COUNTER and PERF_REMOVE_COUNTER request, PERFLIB will pass PERF_COUNTER_IDENTITY block
// so that providers know which counter is added/removed. For other requests, currently only machine name 
// is passed (so that providers can determine whether the request is for physical node or virtual node).
//
typedef struct _PERF_COUNTER_IDENTITY {
    GUID   CounterSetGuid;
    ULONG  BufferSize;
    ULONG  CounterId;
    ULONG  InstanceId;
    ULONG  MachineOffset;
    ULONG  NameOffset;
    ULONG  Reserved;
} PERF_COUNTER_IDENTITY, * PPERF_COUNTER_IDENTITY;

#define PERF_WILDCARD_COUNTER   0xFFFFFFFF
#define PERF_WILDCARD_INSTANCE  L"*"
#define PERF_AGGREGATE_INSTANCE L"_Total"
#define PERF_MAX_INSTANCE_NAME  1024

#define PERF_ADD_COUNTER            1
#define PERF_REMOVE_COUNTER         2
#define PERF_ENUM_INSTANCES         3
#define PERF_COLLECT_START          5
#define PERF_COLLECT_END            6
#define PERF_FILTER                 9

// Prototype for service request callback. Data providers register with PERFLIB V2 by passing a service
// request callback function that is called for all PERFLIB requests.
//
typedef ULONG (
#ifndef MIDL_PASS
WINAPI
#endif
* PERFLIBREQUEST)(
    IN ULONG  RequestCode,
    IN PVOID  Buffer,
    IN ULONG  BufferSize
);

// Usually PerfSetCounterSetInfo() calls is automatically generated PerfAutoStartUp() function (generated
// by schema generation/parsing tool) to inform PERFLIB the layout of specific counterset.
//
ULONG __stdcall
PerfStartProvider(
    __in     LPGUID          ProviderGuid,
    __in_opt PERFLIBREQUEST  ControlCallback,
    __out    HANDLE        * phProvider
);

// Start PERFLIB V2 provider with customized memory allocation/free routines.
//
typedef LPVOID (* PERF_MEM_ALLOC)(IN SIZE_T AllocSize, IN LPVOID pContext);
typedef void (* PERF_MEM_FREE)(IN LPVOID pBuffer, IN LPVOID pContext);

typedef struct _PROVIDER_CONTEXT {
    DWORD          ContextSize; // should be sizeof(PERF_PROVIDER_CONTEXT)
    DWORD          Reserved;
    PERFLIBREQUEST ControlCallback;
    PERF_MEM_ALLOC MemAllocRoutine;
    PERF_MEM_FREE  MemFreeRoutine;
    LPVOID         pMemContext;
} PERF_PROVIDER_CONTEXT, * PPERF_PROVIDER_CONTEXT;

ULONG __stdcall
PerfStartProviderEx(
    __in     LPGUID                 ProviderGuid,
    __in_opt PPERF_PROVIDER_CONTEXT ProviderContext,
    __out    HANDLE               * phProvider
);

ULONG __stdcall
PerfStopProvider(
    __in HANDLE hProvider
);

__success(return == ERROR_SUCCESS)
ULONG __stdcall
PerfSetCounterSetInfo(
    __in     HANDLE                hProvider,
    __inout_bcount(dwTemplateSize) PPERF_COUNTERSET_INFO pTemplate,
    __in     ULONG                 dwTemplateSize
);

PPERF_COUNTERSET_INSTANCE __stdcall
PerfCreateInstance(
    __in HANDLE  hProvider,
    __in LPCGUID CounterSetGuid,
    __in LPCWSTR szInstanceName,
    __in ULONG   dwInstance
);

ULONG __stdcall
PerfDeleteInstance(
    __in HANDLE                    hProvider,
    __in PPERF_COUNTERSET_INSTANCE InstanceBlock
);

PPERF_COUNTERSET_INSTANCE __stdcall
PerfQueryInstance(
    __in HANDLE  hProvider,
    __in LPCGUID CounterSetGuid,
    __in LPCWSTR szInstance,
    __in ULONG   dwInstance
);

ULONG __stdcall
PerfSetULongCounterValue(
    __in HANDLE                    hProvider,
    __in PPERF_COUNTERSET_INSTANCE pInstance,
    __in ULONG                     CounterId,
    __in ULONG                     lValue
);

ULONG __stdcall
PerfSetULongLongCounterValue(
    __in HANDLE                    hProvider,
    __in PPERF_COUNTERSET_INSTANCE pInstance,
    __in ULONG                     CounterId,
    __in ULONGLONG                 llValue
);

ULONG __stdcall
PerfIncrementULongCounterValue(
    __in HANDLE                    hProvider,
    __in PPERF_COUNTERSET_INSTANCE pInstance,
    __in ULONG                     CounterId,
    __in ULONG                     lValue
);

ULONG __stdcall
PerfIncrementULongLongCounterValue(
    __in HANDLE                    hProvider,
    __in PPERF_COUNTERSET_INSTANCE pInstance,
    __in ULONG                     CounterId,
    __in ULONGLONG                 llValue
);

ULONG __stdcall
PerfDecrementULongCounterValue(
    __in HANDLE                    hProvider,
    __in PPERF_COUNTERSET_INSTANCE pInstance,
    __in ULONG                     CounterId,
    __in ULONG                     lValue
);

ULONG __stdcall
PerfDecrementULongLongCounterValue(
    __in HANDLE                    hProvider,
    __in PPERF_COUNTERSET_INSTANCE pInstance,
    __in ULONG                     CounterId,
    __in ULONGLONG                 llValue
);

ULONG __stdcall
PerfSetCounterRefValue(
    __in HANDLE                    hProvider,
    __in PPERF_COUNTERSET_INSTANCE pInstance,
    __in ULONG                     CounterId,
    __in LPVOID                    lpAddr
);

#ifdef __cplusplus
}       // extern "C"
#endif

#endif /* _PERFLIB_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\PhotoAcquireProperties.h ===
/*
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.
 *
 * PROPERTYKEYs used internally by the Photo Acquisition engine
 *
 */

#pragma once

DEFINE_PROPERTYKEY(PKEY_PhotoAcquire_RelativePathname, 0x00f23377, 0x7ac6, 0x4b7a, 0x84, 0x43, 0x34, 0x5e, 0x73, 0x1f, 0xa5, 0x7a, 2); // VT_LPWSTR
DEFINE_PROPERTYKEY(PKEY_PhotoAcquire_FinalFilename, 0x00f23377, 0x7ac6, 0x4b7a, 0x84, 0x43, 0x34, 0x5e, 0x73, 0x1f, 0xa5, 0x7a, 3);    // VT_LPWSTR
DEFINE_PROPERTYKEY(PKEY_PhotoAcquire_GroupTag, 0x00f23377, 0x7ac6, 0x4b7a, 0x84, 0x43, 0x34, 0x5e, 0x73, 0x1f, 0xa5, 0x7a, 4);    // VT_LPWSTR
DEFINE_PROPERTYKEY(PKEY_PhotoAcquire_TransferResult, 0x00f23377, 0x7ac6, 0x4b7a, 0x84, 0x43, 0x34, 0x5e, 0x73, 0x1f, 0xa5, 0x7a, 5);    // VT_SCODE
DEFINE_PROPERTYKEY(PKEY_PhotoAcquire_OriginalFilename, 0x00f23377, 0x7ac6, 0x4b7a, 0x84, 0x43, 0x34, 0x5e, 0x73, 0x1f, 0xa5, 0x7a, 6);    // VT_LPWSTR
DEFINE_PROPERTYKEY(PKEY_PhotoAcquire_CameraSequenceNumber, 0x00f23377, 0x7ac6, 0x4b7a, 0x84, 0x43, 0x34, 0x5e, 0x73, 0x1f, 0xa5, 0x7a, 7);    // VT_LPWSTR
DEFINE_PROPERTYKEY(PKEY_PhotoAcquire_IntermediateFile, 0x00f23377, 0x7ac6, 0x4b7a, 0x84, 0x43, 0x34, 0x5e, 0x73, 0x1f, 0xa5, 0x7a, 8);    // VT_LPWSTR
DEFINE_PROPERTYKEY(PKEY_PhotoAcquire_SkipImport, 0x00f23377, 0x7ac6, 0x4b7a, 0x84, 0x43, 0x34, 0x5e, 0x73, 0x1f, 0xa5, 0x7a, 9);    // VT_BOOL
DEFINE_PROPERTYKEY(PKEY_PhotoAcquire_DuplicateDetectionID, 0x00f23377, 0x7ac6, 0x4b7a, 0x84, 0x43, 0x34, 0x5e, 0x73, 0x1f, 0xa5, 0x7a, 10);    // VT_I4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\physicalmonitorenumerationapi.h ===
#ifndef PhysicalMonitorEnumerationAPI_h
#define PhysicalMonitorEnumerationAPI_h

#include <d3d9.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus 

#pragma pack( push, 1  )    

/******************************************************************************
    Physical Monitor Type Definitions
******************************************************************************/

typedef __success(return == TRUE) BOOL _BOOL;

/******************************************************************************
    Physical Monitor Constants
******************************************************************************/

// A physical monitor description is always an array of 128 characters.  Some
// of the characters may not be used.
#define PHYSICAL_MONITOR_DESCRIPTION_SIZE                   128

/******************************************************************************
    Physical Monitor Structures 
******************************************************************************/
typedef struct _PHYSICAL_MONITOR
{
    HANDLE hPhysicalMonitor;
    WCHAR szPhysicalMonitorDescription[PHYSICAL_MONITOR_DESCRIPTION_SIZE];
} PHYSICAL_MONITOR, *LPPHYSICAL_MONITOR;

/******************************************************************************
    Physical Monitor Enumeration Functions
******************************************************************************/
_BOOL WINAPI GetNumberOfPhysicalMonitorsFromHMONITOR
    ( 
    HMONITOR hMonitor, 
    __out LPDWORD pdwNumberOfPhysicalMonitors
    );
HRESULT WINAPI GetNumberOfPhysicalMonitorsFromIDirect3DDevice9
    (
    __in IDirect3DDevice9* pDirect3DDevice9,
    __out LPDWORD pdwNumberOfPhysicalMonitors
    );

_BOOL WINAPI GetPhysicalMonitorsFromHMONITOR
    ( 
    __in HMONITOR hMonitor,
    __in DWORD dwPhysicalMonitorArraySize,
    __out_ecount(dwPhysicalMonitorArraySize) LPPHYSICAL_MONITOR pPhysicalMonitorArray
    );
HRESULT WINAPI GetPhysicalMonitorsFromIDirect3DDevice9
    ( 
    __in IDirect3DDevice9* pDirect3DDevice9,
    __in DWORD dwPhysicalMonitorArraySize,
    __out_ecount(dwPhysicalMonitorArraySize) LPPHYSICAL_MONITOR pPhysicalMonitorArray
    );

_BOOL WINAPI DestroyPhysicalMonitor( __in HANDLE hMonitor );
_BOOL WINAPI DestroyPhysicalMonitors
    ( 
    __in DWORD dwPhysicalMonitorArraySize,
    __in_ecount(dwPhysicalMonitorArraySize) LPPHYSICAL_MONITOR pPhysicalMonitorArray
    );

#pragma pack( pop )

#ifdef __cplusplus
}
#endif // __cplusplus 

#endif // PhysicalMonitorEnumerationAPI_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\pnrpdef.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnrpdef.h

Abstract:

    Common PNRP related types

--*/

#pragma once

//
// Versioning macros
//

#if defined(PNRP_USE_V1_API) && defined(PNRP_USE_V2_API)
#error Conflicting versioning macros are defined
#endif

#if(_WIN32_WINNT >= 0x0600)

#if !defined(PNRP_USE_V1_API)
#if !defined(PNRP_USE_V2_API)
#define PNRP_USE_V2_API
#endif
#endif

#else

#if !defined(PNRP_USE_V2_API)
#if !defined(PNRP_USE_V1_API)
#define PNRP_USE_V1_API
#endif
#endif

#endif /* _WIN32_WINNT >= 0x0600 */


#define PNRP_MAX_ENDPOINT_ADDRESSES   (10)

//
// Scope
//
#define     WSZ_SCOPE_GLOBAL            L"GLOBAL"
#define     WSZ_SCOPE_SITELOCAL         L"SITELOCAL"
#define     WSZ_SCOPE_LINKLOCAL         L"LINKLOCAL"

typedef enum _PNRP_SCOPE 
{
    PNRP_SCOPE_ANY                  = 0,    //  Any
    PNRP_GLOBAL_SCOPE               = 1,    //  global
    PNRP_SITE_LOCAL_SCOPE           = 2,    //  site local
    PNRP_LINK_LOCAL_SCOPE           = 3     //  link local
} PNRP_SCOPE, *PPNRP_SCOPE;


//
// Cloud state
//

typedef enum _PNRP_CLOUD_STATE 
{
    PNRP_CLOUD_STATE_VIRTUAL       = 0,    //  Not initialized
    PNRP_CLOUD_STATE_SYNCHRONISING = 1,    //  The cache is initializing
    PNRP_CLOUD_STATE_ACTIVE        = 2,    //  Cloud is active
    PNRP_CLOUD_STATE_DEAD          = 3,    //  Initialized but has had a problem
    PNRP_CLOUD_STATE_DISABLED      = 4,    //  Cloud is not disbaled in registery
    PNRP_CLOUD_STATE_NO_NET        = 5,    //  Was active, but now has lost access to net
    PNRP_CLOUD_STATE_ALONE         = 6     //  Cloud is in standalone mode
} PNRP_CLOUD_STATE;

//
// Cloud Flags values
//  These should be powers of 2 so they can be ORed together
//

typedef enum _PNRP_CLOUD_FLAGS
{
    PNRP_CLOUD_NO_FLAGS            = 0,    //  
    PNRP_CLOUD_NAME_LOCAL          = 1,    //  Name not valid on other computers
    PNRP_CLOUD_RESOLVE_ONLY        = 2,
    PNRP_CLOUD_FULL_PARTICIPANT    = 4

} PNRP_CLOUD_FLAGS;

//
// Registered name state
//

typedef enum _PNRP_REGISTERED_ID_STATE
{
    PNRP_REGISTERED_ID_STATE_OK      = 1,    //  Id is active in cloud
    PNRP_REGISTERED_ID_STATE_PROBLEM = 2     //  Id is no longer registered in cloud

} PNRP_REGISTERED_ID_STATE;

//
// Resolve criteria
//

typedef enum _PNRP_RESOLVE_CRITERIA
{
    PNRP_RESOLVE_CRITERIA_DEFAULT           = 0,            // Default = PNRP_RESOLVE_CRITERIA_NON_CURRENT_PROCESS_PEER_NAME

    PNRP_RESOLVE_CRITERIA_REMOTE_PEER_NAME  = 1,            // match first 128 bits (remote node)

    PNRP_RESOLVE_CRITERIA_NEAREST_REMOTE_PEER_NAME = 2,     // match first 128 bits, and close to top 64 bits
                                                            // of the second 128 bits (remote node)

    PNRP_RESOLVE_CRITERIA_NON_CURRENT_PROCESS_PEER_NAME = 3,//  match first 128 bits (not in the current process) 

    PNRP_RESOLVE_CRITERIA_NEAREST_NON_CURRENT_PROCESS_PEER_NAME = 4, // match first 128 bits, and close to top 64 bits
                                                            // of the second 128 bits (not in the current process)   

    PNRP_RESOLVE_CRITERIA_ANY_PEER_NAME     = 5,            // match first 128 bits (any node)

    PNRP_RESOLVE_CRITERIA_NEAREST_PEER_NAME = 6             // match first 128 bits, and close to top 64 bits
                                                            // of the second 128 bits (any node)   


} PNRP_RESOLVE_CRITERIA;

//
// PNRP Cloud identification
//

typedef struct _PNRP_CLOUD_ID 
{
    INT         AddressFamily;          // should be AF_INET6
    PNRP_SCOPE  Scope;                  // Global, site, or link
    ULONG       ScopeId;                // specifies interface
} PNRP_CLOUD_ID, *PPNRP_CLOUD_ID;




//
// Extended payload type
//

typedef enum _PNRP_EXTENDED_PAYLOAD_TYPE
{
    PNRP_EXTENDED_PAYLOAD_TYPE_NONE = 0,
    PNRP_EXTENDED_PAYLOAD_TYPE_BINARY,
    PNRP_EXTENDED_PAYLOAD_TYPE_STRING,
	
} PNRP_EXTENDED_PAYLOAD_TYPE, *PPNRP_EXTENDED_PAYLOAD_TYPE;

#define PNRP_MAX_EXTENDED_PAYLOAD_BYTES      (0x1000)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\Polarity.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    POLARITY.H

Abstract:

    properly map __declspec( dllexport ) or import

History:

--*/

#if _MSC_VER > 1000
#pragma once
#endif

// If we are building the DLL then define the 
// class as exported otherwise as imported
// ============================================
#ifndef POLARITY_HEADERFILE_IS_INCLUDED
#define POLARITY_HEADERFILE_IS_INCLUDED
//#pragma message( "Including Polarity.h..." )

 #ifdef USE_POLARITY
  #ifdef BUILDING_DLL
//   #pragma message( "Building static library or DLL..." )
   #define POLARITY __declspec( dllexport )
  #else 
//   #pragma message( "Building Provider..." )
   #define POLARITY __declspec( dllimport )
  #endif
 #else
  #define POLARITY
//  #pragma message( "NO Polarity...")
 #endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\PortableDeviceTypes.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for PortableDeviceTypes.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __PortableDeviceTypes_h__
#define __PortableDeviceTypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWpdSerializer_FWD_DEFINED__
#define __IWpdSerializer_FWD_DEFINED__
typedef interface IWpdSerializer IWpdSerializer;
#endif 	/* __IWpdSerializer_FWD_DEFINED__ */


#ifndef __IPortableDeviceValues_FWD_DEFINED__
#define __IPortableDeviceValues_FWD_DEFINED__
typedef interface IPortableDeviceValues IPortableDeviceValues;
#endif 	/* __IPortableDeviceValues_FWD_DEFINED__ */


#ifndef __IPortableDeviceKeyCollection_FWD_DEFINED__
#define __IPortableDeviceKeyCollection_FWD_DEFINED__
typedef interface IPortableDeviceKeyCollection IPortableDeviceKeyCollection;
#endif 	/* __IPortableDeviceKeyCollection_FWD_DEFINED__ */


#ifndef __IPortableDevicePropVariantCollection_FWD_DEFINED__
#define __IPortableDevicePropVariantCollection_FWD_DEFINED__
typedef interface IPortableDevicePropVariantCollection IPortableDevicePropVariantCollection;
#endif 	/* __IPortableDevicePropVariantCollection_FWD_DEFINED__ */


#ifndef __IPortableDeviceValuesCollection_FWD_DEFINED__
#define __IPortableDeviceValuesCollection_FWD_DEFINED__
typedef interface IPortableDeviceValuesCollection IPortableDeviceValuesCollection;
#endif 	/* __IPortableDeviceValuesCollection_FWD_DEFINED__ */


#ifndef __WpdSerializer_FWD_DEFINED__
#define __WpdSerializer_FWD_DEFINED__

#ifdef __cplusplus
typedef class WpdSerializer WpdSerializer;
#else
typedef struct WpdSerializer WpdSerializer;
#endif /* __cplusplus */

#endif 	/* __WpdSerializer_FWD_DEFINED__ */


#ifndef __PortableDeviceValues_FWD_DEFINED__
#define __PortableDeviceValues_FWD_DEFINED__

#ifdef __cplusplus
typedef class PortableDeviceValues PortableDeviceValues;
#else
typedef struct PortableDeviceValues PortableDeviceValues;
#endif /* __cplusplus */

#endif 	/* __PortableDeviceValues_FWD_DEFINED__ */


#ifndef __PortableDeviceKeyCollection_FWD_DEFINED__
#define __PortableDeviceKeyCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class PortableDeviceKeyCollection PortableDeviceKeyCollection;
#else
typedef struct PortableDeviceKeyCollection PortableDeviceKeyCollection;
#endif /* __cplusplus */

#endif 	/* __PortableDeviceKeyCollection_FWD_DEFINED__ */


#ifndef __PortableDevicePropVariantCollection_FWD_DEFINED__
#define __PortableDevicePropVariantCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class PortableDevicePropVariantCollection PortableDevicePropVariantCollection;
#else
typedef struct PortableDevicePropVariantCollection PortableDevicePropVariantCollection;
#endif /* __cplusplus */

#endif 	/* __PortableDevicePropVariantCollection_FWD_DEFINED__ */


#ifndef __PortableDeviceValuesCollection_FWD_DEFINED__
#define __PortableDeviceValuesCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class PortableDeviceValuesCollection PortableDeviceValuesCollection;
#else
typedef struct PortableDeviceValuesCollection PortableDeviceValuesCollection;
#endif /* __cplusplus */

#endif 	/* __PortableDeviceValuesCollection_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "propsys.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_PortableDeviceTypes_0000_0000 */
/* [local] */ 

#if (_WIN32_WINNT >= 0x0501) // Longhorn and later







extern RPC_IF_HANDLE __MIDL_itf_PortableDeviceTypes_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_PortableDeviceTypes_0000_0000_v0_0_s_ifspec;

#ifndef __IWpdSerializer_INTERFACE_DEFINED__
#define __IWpdSerializer_INTERFACE_DEFINED__

/* interface IWpdSerializer */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWpdSerializer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b32f4002-bb27-45ff-af4f-06631c1e8dad")
    IWpdSerializer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIPortableDeviceValuesFromBuffer( 
            /* [size_is][in] */ __RPC__in_ecount_full(dwInputBufferLength) BYTE *pBuffer,
            /* [in] */ DWORD dwInputBufferLength,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppParams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteIPortableDeviceValuesToBuffer( 
            /* [in] */ DWORD dwOutputBufferLength,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pResults,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(dwOutputBufferLength, *pdwBytesWritten) BYTE *pBuffer,
            /* [out] */ __RPC__out DWORD *pdwBytesWritten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferFromIPortableDeviceValues( 
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pSource,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pdwBufferSize) BYTE **ppBuffer,
            /* [out] */ __RPC__out DWORD *pdwBufferSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSerializedSize( 
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pSource,
            /* [out] */ __RPC__out DWORD *pdwSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWpdSerializerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWpdSerializer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWpdSerializer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWpdSerializer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetIPortableDeviceValuesFromBuffer )( 
            IWpdSerializer * This,
            /* [size_is][in] */ __RPC__in_ecount_full(dwInputBufferLength) BYTE *pBuffer,
            /* [in] */ DWORD dwInputBufferLength,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppParams);
        
        HRESULT ( STDMETHODCALLTYPE *WriteIPortableDeviceValuesToBuffer )( 
            IWpdSerializer * This,
            /* [in] */ DWORD dwOutputBufferLength,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pResults,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(dwOutputBufferLength, *pdwBytesWritten) BYTE *pBuffer,
            /* [out] */ __RPC__out DWORD *pdwBytesWritten);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferFromIPortableDeviceValues )( 
            IWpdSerializer * This,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pSource,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pdwBufferSize) BYTE **ppBuffer,
            /* [out] */ __RPC__out DWORD *pdwBufferSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetSerializedSize )( 
            IWpdSerializer * This,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pSource,
            /* [out] */ __RPC__out DWORD *pdwSize);
        
        END_INTERFACE
    } IWpdSerializerVtbl;

    interface IWpdSerializer
    {
        CONST_VTBL struct IWpdSerializerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWpdSerializer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWpdSerializer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWpdSerializer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWpdSerializer_GetIPortableDeviceValuesFromBuffer(This,pBuffer,dwInputBufferLength,ppParams)	\
    ( (This)->lpVtbl -> GetIPortableDeviceValuesFromBuffer(This,pBuffer,dwInputBufferLength,ppParams) ) 

#define IWpdSerializer_WriteIPortableDeviceValuesToBuffer(This,dwOutputBufferLength,pResults,pBuffer,pdwBytesWritten)	\
    ( (This)->lpVtbl -> WriteIPortableDeviceValuesToBuffer(This,dwOutputBufferLength,pResults,pBuffer,pdwBytesWritten) ) 

#define IWpdSerializer_GetBufferFromIPortableDeviceValues(This,pSource,ppBuffer,pdwBufferSize)	\
    ( (This)->lpVtbl -> GetBufferFromIPortableDeviceValues(This,pSource,ppBuffer,pdwBufferSize) ) 

#define IWpdSerializer_GetSerializedSize(This,pSource,pdwSize)	\
    ( (This)->lpVtbl -> GetSerializedSize(This,pSource,pdwSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWpdSerializer_INTERFACE_DEFINED__ */


#ifndef __IPortableDeviceValues_INTERFACE_DEFINED__
#define __IPortableDeviceValues_INTERFACE_DEFINED__

/* interface IPortableDeviceValues */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPortableDeviceValues;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6848f6f2-3155-4f86-b6f5-263eeeab3143")
    IPortableDeviceValues : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [in] */ __RPC__in DWORD *pcelt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ const DWORD index,
            /* [unique][out][in] */ __RPC__inout_opt PROPERTYKEY *pKey,
            /* [unique][out][in] */ __RPC__inout_opt PROPVARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in const PROPVARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStringValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in LPCWSTR Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStringValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUnsignedIntegerValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const ULONG Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUnsignedIntegerValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out ULONG *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSignedIntegerValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const LONG Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSignedIntegerValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out LONG *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUnsignedLargeIntegerValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const ULONGLONG Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUnsignedLargeIntegerValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out ULONGLONG *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSignedLargeIntegerValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const LONGLONG Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSignedLargeIntegerValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out LONGLONG *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFloatValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const FLOAT Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFloatValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out FLOAT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetErrorValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const HRESULT Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out HRESULT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetKeyValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPERTYKEY Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeyValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPERTYKEY *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBoolValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const BOOL Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBoolValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out BOOL *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIUnknownValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IUnknown *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIUnknownValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGuidValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFGUID Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuidValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out GUID *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBufferValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [size_is][in] */ __RPC__in_ecount_full(cbValue) BYTE *pValue,
            /* [in] */ DWORD cbValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbValue) BYTE **ppValue,
            /* [out] */ __RPC__out DWORD *pcbValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIPortableDeviceValuesValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIPortableDeviceValuesValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIPortableDevicePropVariantCollectionValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IPortableDevicePropVariantCollection *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIPortableDevicePropVariantCollectionValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IPortableDevicePropVariantCollection **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIPortableDeviceKeyCollectionValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IPortableDeviceKeyCollection *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIPortableDeviceKeyCollectionValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceKeyCollection **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIPortableDeviceValuesCollectionValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IPortableDeviceValuesCollection *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIPortableDeviceValuesCollectionValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValuesCollection **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyValuesFromPropertyStore( 
            /* [in] */ __RPC__in_opt IPropertyStore *pStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyValuesToPropertyStore( 
            /* [in] */ __RPC__in_opt IPropertyStore *pStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPortableDeviceValuesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPortableDeviceValues * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPortableDeviceValues * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in DWORD *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            IPortableDeviceValues * This,
            /* [in] */ const DWORD index,
            /* [unique][out][in] */ __RPC__inout_opt PROPERTYKEY *pKey,
            /* [unique][out][in] */ __RPC__inout_opt PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in const PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetStringValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in LPCWSTR Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnsignedIntegerValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const ULONG Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnsignedIntegerValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out ULONG *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetSignedIntegerValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const LONG Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignedIntegerValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out LONG *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnsignedLargeIntegerValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const ULONGLONG Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnsignedLargeIntegerValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out ULONGLONG *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetSignedLargeIntegerValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const LONGLONG Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignedLargeIntegerValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out LONGLONG *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetFloatValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const FLOAT Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetFloatValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out FLOAT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetErrorValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const HRESULT Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out HRESULT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetKeyValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPERTYKEY Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetKeyValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPERTYKEY *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBoolValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const BOOL Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetBoolValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out BOOL *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetIUnknownValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IUnknown *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetIUnknownValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetGuidValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFGUID Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuidValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out GUID *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBufferValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [size_is][in] */ __RPC__in_ecount_full(cbValue) BYTE *pValue,
            /* [in] */ DWORD cbValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbValue) BYTE **ppValue,
            /* [out] */ __RPC__out DWORD *pcbValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetIPortableDeviceValuesValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetIPortableDeviceValuesValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetIPortableDevicePropVariantCollectionValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IPortableDevicePropVariantCollection *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetIPortableDevicePropVariantCollectionValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IPortableDevicePropVariantCollection **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetIPortableDeviceKeyCollectionValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IPortableDeviceKeyCollection *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetIPortableDeviceKeyCollectionValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceKeyCollection **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetIPortableDeviceValuesCollectionValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IPortableDeviceValuesCollection *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetIPortableDeviceValuesCollectionValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValuesCollection **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key);
        
        HRESULT ( STDMETHODCALLTYPE *CopyValuesFromPropertyStore )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in_opt IPropertyStore *pStore);
        
        HRESULT ( STDMETHODCALLTYPE *CopyValuesToPropertyStore )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in_opt IPropertyStore *pStore);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IPortableDeviceValues * This);
        
        END_INTERFACE
    } IPortableDeviceValuesVtbl;

    interface IPortableDeviceValues
    {
        CONST_VTBL struct IPortableDeviceValuesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPortableDeviceValues_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPortableDeviceValues_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPortableDeviceValues_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPortableDeviceValues_GetCount(This,pcelt)	\
    ( (This)->lpVtbl -> GetCount(This,pcelt) ) 

#define IPortableDeviceValues_GetAt(This,index,pKey,pValue)	\
    ( (This)->lpVtbl -> GetAt(This,index,pKey,pValue) ) 

#define IPortableDeviceValues_SetValue(This,key,pValue)	\
    ( (This)->lpVtbl -> SetValue(This,key,pValue) ) 

#define IPortableDeviceValues_GetValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetStringValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetStringValue(This,key,Value) ) 

#define IPortableDeviceValues_GetStringValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetStringValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetUnsignedIntegerValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetUnsignedIntegerValue(This,key,Value) ) 

#define IPortableDeviceValues_GetUnsignedIntegerValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetUnsignedIntegerValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetSignedIntegerValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetSignedIntegerValue(This,key,Value) ) 

#define IPortableDeviceValues_GetSignedIntegerValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetSignedIntegerValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetUnsignedLargeIntegerValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetUnsignedLargeIntegerValue(This,key,Value) ) 

#define IPortableDeviceValues_GetUnsignedLargeIntegerValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetUnsignedLargeIntegerValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetSignedLargeIntegerValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetSignedLargeIntegerValue(This,key,Value) ) 

#define IPortableDeviceValues_GetSignedLargeIntegerValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetSignedLargeIntegerValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetFloatValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetFloatValue(This,key,Value) ) 

#define IPortableDeviceValues_GetFloatValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetFloatValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetErrorValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetErrorValue(This,key,Value) ) 

#define IPortableDeviceValues_GetErrorValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetErrorValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetKeyValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetKeyValue(This,key,Value) ) 

#define IPortableDeviceValues_GetKeyValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetKeyValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetBoolValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetBoolValue(This,key,Value) ) 

#define IPortableDeviceValues_GetBoolValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetBoolValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetIUnknownValue(This,key,pValue)	\
    ( (This)->lpVtbl -> SetIUnknownValue(This,key,pValue) ) 

#define IPortableDeviceValues_GetIUnknownValue(This,key,ppValue)	\
    ( (This)->lpVtbl -> GetIUnknownValue(This,key,ppValue) ) 

#define IPortableDeviceValues_SetGuidValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetGuidValue(This,key,Value) ) 

#define IPortableDeviceValues_GetGuidValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetGuidValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetBufferValue(This,key,pValue,cbValue)	\
    ( (This)->lpVtbl -> SetBufferValue(This,key,pValue,cbValue) ) 

#define IPortableDeviceValues_GetBufferValue(This,key,ppValue,pcbValue)	\
    ( (This)->lpVtbl -> GetBufferValue(This,key,ppValue,pcbValue) ) 

#define IPortableDeviceValues_SetIPortableDeviceValuesValue(This,key,pValue)	\
    ( (This)->lpVtbl -> SetIPortableDeviceValuesValue(This,key,pValue) ) 

#define IPortableDeviceValues_GetIPortableDeviceValuesValue(This,key,ppValue)	\
    ( (This)->lpVtbl -> GetIPortableDeviceValuesValue(This,key,ppValue) ) 

#define IPortableDeviceValues_SetIPortableDevicePropVariantCollectionValue(This,key,pValue)	\
    ( (This)->lpVtbl -> SetIPortableDevicePropVariantCollectionValue(This,key,pValue) ) 

#define IPortableDeviceValues_GetIPortableDevicePropVariantCollectionValue(This,key,ppValue)	\
    ( (This)->lpVtbl -> GetIPortableDevicePropVariantCollectionValue(This,key,ppValue) ) 

#define IPortableDeviceValues_SetIPortableDeviceKeyCollectionValue(This,key,pValue)	\
    ( (This)->lpVtbl -> SetIPortableDeviceKeyCollectionValue(This,key,pValue) ) 

#define IPortableDeviceValues_GetIPortableDeviceKeyCollectionValue(This,key,ppValue)	\
    ( (This)->lpVtbl -> GetIPortableDeviceKeyCollectionValue(This,key,ppValue) ) 

#define IPortableDeviceValues_SetIPortableDeviceValuesCollectionValue(This,key,pValue)	\
    ( (This)->lpVtbl -> SetIPortableDeviceValuesCollectionValue(This,key,pValue) ) 

#define IPortableDeviceValues_GetIPortableDeviceValuesCollectionValue(This,key,ppValue)	\
    ( (This)->lpVtbl -> GetIPortableDeviceValuesCollectionValue(This,key,ppValue) ) 

#define IPortableDeviceValues_RemoveValue(This,key)	\
    ( (This)->lpVtbl -> RemoveValue(This,key) ) 

#define IPortableDeviceValues_CopyValuesFromPropertyStore(This,pStore)	\
    ( (This)->lpVtbl -> CopyValuesFromPropertyStore(This,pStore) ) 

#define IPortableDeviceValues_CopyValuesToPropertyStore(This,pStore)	\
    ( (This)->lpVtbl -> CopyValuesToPropertyStore(This,pStore) ) 

#define IPortableDeviceValues_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPortableDeviceValues_INTERFACE_DEFINED__ */


#ifndef __IPortableDeviceKeyCollection_INTERFACE_DEFINED__
#define __IPortableDeviceKeyCollection_INTERFACE_DEFINED__

/* interface IPortableDeviceKeyCollection */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPortableDeviceKeyCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dada2357-e0ad-492e-98db-dd61c53ba353")
    IPortableDeviceKeyCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [in] */ __RPC__in DWORD *pcElems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ const DWORD dwIndex,
            /* [in] */ __RPC__in PROPERTYKEY *pKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in REFPROPERTYKEY Key) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ const DWORD dwIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPortableDeviceKeyCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPortableDeviceKeyCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPortableDeviceKeyCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPortableDeviceKeyCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IPortableDeviceKeyCollection * This,
            /* [in] */ __RPC__in DWORD *pcElems);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            IPortableDeviceKeyCollection * This,
            /* [in] */ const DWORD dwIndex,
            /* [in] */ __RPC__in PROPERTYKEY *pKey);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            IPortableDeviceKeyCollection * This,
            /* [in] */ __RPC__in REFPROPERTYKEY Key);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IPortableDeviceKeyCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            IPortableDeviceKeyCollection * This,
            /* [in] */ const DWORD dwIndex);
        
        END_INTERFACE
    } IPortableDeviceKeyCollectionVtbl;

    interface IPortableDeviceKeyCollection
    {
        CONST_VTBL struct IPortableDeviceKeyCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPortableDeviceKeyCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPortableDeviceKeyCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPortableDeviceKeyCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPortableDeviceKeyCollection_GetCount(This,pcElems)	\
    ( (This)->lpVtbl -> GetCount(This,pcElems) ) 

#define IPortableDeviceKeyCollection_GetAt(This,dwIndex,pKey)	\
    ( (This)->lpVtbl -> GetAt(This,dwIndex,pKey) ) 

#define IPortableDeviceKeyCollection_Add(This,Key)	\
    ( (This)->lpVtbl -> Add(This,Key) ) 

#define IPortableDeviceKeyCollection_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define IPortableDeviceKeyCollection_RemoveAt(This,dwIndex)	\
    ( (This)->lpVtbl -> RemoveAt(This,dwIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPortableDeviceKeyCollection_INTERFACE_DEFINED__ */


#ifndef __IPortableDevicePropVariantCollection_INTERFACE_DEFINED__
#define __IPortableDevicePropVariantCollection_INTERFACE_DEFINED__

/* interface IPortableDevicePropVariantCollection */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPortableDevicePropVariantCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("89b2e422-4f1b-4316-bcef-a44afea83eb3")
    IPortableDevicePropVariantCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [in] */ __RPC__in DWORD *pcElems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ const DWORD dwIndex,
            /* [in] */ __RPC__in PROPVARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in const PROPVARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ __RPC__out VARTYPE *pvt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeType( 
            /* [in] */ const VARTYPE vt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ const DWORD dwIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPortableDevicePropVariantCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPortableDevicePropVariantCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPortableDevicePropVariantCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPortableDevicePropVariantCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IPortableDevicePropVariantCollection * This,
            /* [in] */ __RPC__in DWORD *pcElems);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            IPortableDevicePropVariantCollection * This,
            /* [in] */ const DWORD dwIndex,
            /* [in] */ __RPC__in PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            IPortableDevicePropVariantCollection * This,
            /* [in] */ __RPC__in const PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IPortableDevicePropVariantCollection * This,
            /* [out] */ __RPC__out VARTYPE *pvt);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeType )( 
            IPortableDevicePropVariantCollection * This,
            /* [in] */ const VARTYPE vt);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IPortableDevicePropVariantCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            IPortableDevicePropVariantCollection * This,
            /* [in] */ const DWORD dwIndex);
        
        END_INTERFACE
    } IPortableDevicePropVariantCollectionVtbl;

    interface IPortableDevicePropVariantCollection
    {
        CONST_VTBL struct IPortableDevicePropVariantCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPortableDevicePropVariantCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPortableDevicePropVariantCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPortableDevicePropVariantCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPortableDevicePropVariantCollection_GetCount(This,pcElems)	\
    ( (This)->lpVtbl -> GetCount(This,pcElems) ) 

#define IPortableDevicePropVariantCollection_GetAt(This,dwIndex,pValue)	\
    ( (This)->lpVtbl -> GetAt(This,dwIndex,pValue) ) 

#define IPortableDevicePropVariantCollection_Add(This,pValue)	\
    ( (This)->lpVtbl -> Add(This,pValue) ) 

#define IPortableDevicePropVariantCollection_GetType(This,pvt)	\
    ( (This)->lpVtbl -> GetType(This,pvt) ) 

#define IPortableDevicePropVariantCollection_ChangeType(This,vt)	\
    ( (This)->lpVtbl -> ChangeType(This,vt) ) 

#define IPortableDevicePropVariantCollection_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define IPortableDevicePropVariantCollection_RemoveAt(This,dwIndex)	\
    ( (This)->lpVtbl -> RemoveAt(This,dwIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPortableDevicePropVariantCollection_INTERFACE_DEFINED__ */


#ifndef __IPortableDeviceValuesCollection_INTERFACE_DEFINED__
#define __IPortableDeviceValuesCollection_INTERFACE_DEFINED__

/* interface IPortableDeviceValuesCollection */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPortableDeviceValuesCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6e3f2d79-4e07-48c4-8208-d8c2e5af4a99")
    IPortableDeviceValuesCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [in] */ __RPC__in DWORD *pcElems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ const DWORD dwIndex,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppValues) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pValues) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ const DWORD dwIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPortableDeviceValuesCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPortableDeviceValuesCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPortableDeviceValuesCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPortableDeviceValuesCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IPortableDeviceValuesCollection * This,
            /* [in] */ __RPC__in DWORD *pcElems);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            IPortableDeviceValuesCollection * This,
            /* [in] */ const DWORD dwIndex,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppValues);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            IPortableDeviceValuesCollection * This,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pValues);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IPortableDeviceValuesCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            IPortableDeviceValuesCollection * This,
            /* [in] */ const DWORD dwIndex);
        
        END_INTERFACE
    } IPortableDeviceValuesCollectionVtbl;

    interface IPortableDeviceValuesCollection
    {
        CONST_VTBL struct IPortableDeviceValuesCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPortableDeviceValuesCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPortableDeviceValuesCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPortableDeviceValuesCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPortableDeviceValuesCollection_GetCount(This,pcElems)	\
    ( (This)->lpVtbl -> GetCount(This,pcElems) ) 

#define IPortableDeviceValuesCollection_GetAt(This,dwIndex,ppValues)	\
    ( (This)->lpVtbl -> GetAt(This,dwIndex,ppValues) ) 

#define IPortableDeviceValuesCollection_Add(This,pValues)	\
    ( (This)->lpVtbl -> Add(This,pValues) ) 

#define IPortableDeviceValuesCollection_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define IPortableDeviceValuesCollection_RemoveAt(This,dwIndex)	\
    ( (This)->lpVtbl -> RemoveAt(This,dwIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPortableDeviceValuesCollection_INTERFACE_DEFINED__ */



#ifndef __PortableDeviceTypesLib_LIBRARY_DEFINED__
#define __PortableDeviceTypesLib_LIBRARY_DEFINED__

/* library PortableDeviceTypesLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_PortableDeviceTypesLib;

EXTERN_C const CLSID CLSID_WpdSerializer;

#ifdef __cplusplus

class DECLSPEC_UUID("0b91a74b-ad7c-4a9d-b563-29eef9167172")
WpdSerializer;
#endif

EXTERN_C const CLSID CLSID_PortableDeviceValues;

#ifdef __cplusplus

class DECLSPEC_UUID("0c15d503-d017-47ce-9016-7b3f978721cc")
PortableDeviceValues;
#endif

EXTERN_C const CLSID CLSID_PortableDeviceKeyCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("de2d022d-2480-43be-97f0-d1fa2cf98f4f")
PortableDeviceKeyCollection;
#endif

EXTERN_C const CLSID CLSID_PortableDevicePropVariantCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("08a99e2f-6d6d-4b80-af5a-baf2bcbe4cb9")
PortableDevicePropVariantCollection;
#endif

EXTERN_C const CLSID CLSID_PortableDeviceValuesCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("3882134d-14cf-4220-9cb4-435f86d83f60")
PortableDeviceValuesCollection;
#endif
#endif /* __PortableDeviceTypesLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_PortableDeviceTypes_0000_0005 */
/* [local] */ 

#endif // (_WIN32_WINNT >= 0x0501)


extern RPC_IF_HANDLE __MIDL_itf_PortableDeviceTypes_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_PortableDeviceTypes_0000_0005_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\pnrpns.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnrpns.h

Abstract:
    The PNRP interface participates as a WinSock 2.0 Name Space Provider (NSP)
    The actual functions are defined in winsock2.h of the platform SDK

    This header file defines the specific structures and data used for PNRP.

--*/

#ifndef _PNRPNS_H_
#define _PNRPNS_H_

#include "pnrpdef.h"

// Namespaces
#ifndef NS_PNRPNAME
#define NS_PNRPNAME     (38) 
#endif

#ifndef NS_PNRPCLOUD
#define NS_PNRPCLOUD    (39)
#endif

//
// Bit values used for dwFlags in PNRPINFO
//

#define PNRPINFO_HINT           0x00000001      // set if Hint valid

//
// PNRP specific data that is referenced by the lpBlob pointer of WSAQUERYSET
//



typedef struct _PNRPINFO_V1
{
    DWORD                       dwSize;                 // size of this struct
    LPWSTR                      lpwszIdentity;          // identity name string
    DWORD                       nMaxResolve;            // number of desired resolutions
    DWORD                       dwTimeout;              // time in seconds to wait for responses
    DWORD                       dwLifetime;             // time in seconds for validity
    PNRP_RESOLVE_CRITERIA       enResolveCriteria;      // type of matching for resolves
    DWORD                       dwFlags;                // set of flags
    SOCKET_ADDRESS              saHint;                 // service location part of an ID
    PNRP_REGISTERED_ID_STATE    enNameState;            // state of registered name

} PNRPINFO_V1, * PPNRPINFO_V1;



typedef struct _PNRPINFO_V2
{
    DWORD                       dwSize;                 // size of this struct
    LPWSTR                      lpwszIdentity;          // identity name string
    DWORD                       nMaxResolve;            // number of desired resolutions
    DWORD                       dwTimeout;              // time in seconds to wait for responses
    DWORD                       dwLifetime;             // time in seconds for validity
    PNRP_RESOLVE_CRITERIA       enResolveCriteria;      // type of matching for resolves
    DWORD                       dwFlags;                // set of flags
    SOCKET_ADDRESS              saHint;                 // service location part of an ID
    PNRP_REGISTERED_ID_STATE    enNameState;            // state of registered name
    PNRP_EXTENDED_PAYLOAD_TYPE  enExtendedPayloadType;
    union {
        BLOB                    blobPayload;
        PWSTR                   pwszPayload;
    };
   
} PNRPINFO_V2, * PPNRPINFO_V2;



#if defined(PNRP_USE_V1_API)

typedef  PNRPINFO_V1 PNRPINFO;
typedef  PPNRPINFO_V1 PPNRPINFO;


#else
typedef  PNRPINFO_V2 PNRPINFO;
typedef  PPNRPINFO_V2 PPNRPINFO;

#endif
//
// Cloud specific data that is referenced by the lpBlob pointer of WSAQUERYSET
//

typedef struct _PNRPCLOUDINFO
{
    DWORD                       dwSize;                 // size of this struct
    PNRP_CLOUD_ID               Cloud;                  // network cloud information
    PNRP_CLOUD_STATE            enCloudState;           // state of cloud
    PNRP_CLOUD_FLAGS            enCloudFlags;           // flags for cloud
                                                        //   PNRP_CLOUD_NAME_LOCAL - not a network name
} PNRPCLOUDINFO, * PPNRPCLOUDINFO;

#endif // _PNRPNS_H_



/////////////////////////////////////////////////////////////////////////////
//
// These GUIDs are outside conditional includes so you can
//   #include <pnrpns.h>   in precompiled header
// then
//   #include <initguid.h>  in a single source file
//   #include <pnrpns.h>   in that source file a second time to instantiate the GUIDs

#ifdef DEFINE_GUID

// NSP Provider GUID
DEFINE_GUID(NS_PROVIDER_PNRPNAME,   0x03fe89cd, 0x766d, 0x4976, 0xb9, 0xc1, 0xbb, 0x9b, 0xc4, 0x2c, 0x7b, 0x4d);
DEFINE_GUID(NS_PROVIDER_PNRPCLOUD,  0x03fe89ce, 0x766d, 0x4976, 0xb9, 0xc1, 0xbb, 0x9b, 0xc4, 0x2c, 0x7b, 0x4d);

// Service Class GUID (specific to PNRP)
DEFINE_GUID(SVCID_PNRPCLOUD,    0xc2239ce6, 0x00c0, 0x4fbf, 0xba, 0xd6, 0x18, 0x13, 0x93, 0x85, 0xa4, 0x9a);

DEFINE_GUID(SVCID_PNRPNAME_V1,	0xc2239ce5, 0x00c0, 0x4fbf, 0xba, 0xd6, 0x18, 0x13, 0x93, 0x85, 0xa4, 0x9a);
DEFINE_GUID(SVCID_PNRPNAME_V2,	0xc2239ce7, 0x00c0, 0x4fbf, 0xba, 0xd6, 0x18, 0x13, 0x93, 0x85, 0xa4, 0x9a);


#if defined(PNRP_USE_V2_API)

#define SVCID_PNRPNAME SVCID_PNRPNAME_V2

#else

#define SVCID_PNRPNAME SVCID_PNRPNAME_V1

#endif

#endif // DEFINE_GUID
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\PortableDevice.h ===
/****************************************************************************
* Copyright (c) Microsoft Corporation. All rights reserved.
****************************************************************************/
#pragma once 
#if (_WIN32_WINNT >= 0x0501) // Windows XP and later 
#include "propkeydef.h" 

/**************************************************************************** 
* This section declares WPD guids used in PnP 
****************************************************************************/
// 
// GUID_DEVINTERFACE_WPD
//   This GUID is used to identify devices / drivers that support the WPD DDI. 
//   The WPD Class Extension component enables this device interface for WPD Drivers that use it. Clients use this PnP interface when registering for PnP device arrival messages for WPD devices. 
DEFINE_GUID(GUID_DEVINTERFACE_WPD, 0x6AC27878, 0xA6FA, 0x4155, 0xBA, 0x85, 0xF9, 0x8F, 0x49, 0x1D, 0x4F, 0x33 ); 
// 
// GUID_DEVINTERFACE_WPD_PRIVATE
//   This GUID is used to identify devices / drivers that can be used only by a specialized WPD client and will not show up in normal WPD enumeration. 
//   Devices identified with this interface cannot be used with normal WPD applications. Generic WPD drivers and clients should not use this interface. 
DEFINE_GUID(GUID_DEVINTERFACE_WPD_PRIVATE, 0xBA0C718F, 0x4DED, 0x49B7, 0xBD, 0xD3, 0xFA, 0xBE, 0x28, 0x66, 0x12, 0x11 ); 

/**************************************************************************** 
* This section declares WPD defines 
****************************************************************************/
// WPD specific function number used to construct WPD I/O control codes. Drivers should not use this define directly. 
// 
#define WPD_CONTROL_FUNCTION_GENERIC_MESSAGE 0x42 

// Defines WPD specific IOCTL number used by drivers to detect WPD requests that may require READ and WRITE access to the device. 
// 
#define IOCTL_WPD_MESSAGE_READWRITE_ACCESS CTL_CODE(FILE_DEVICE_WPD, WPD_CONTROL_FUNCTION_GENERIC_MESSAGE, METHOD_BUFFERED, (FILE_READ_ACCESS | FILE_WRITE_ACCESS)) 

// Defines WPD specific IOCTL number used by drivers to detect WPD requests that require READ-only access to the device. 
// 
#define IOCTL_WPD_MESSAGE_READ_ACCESS CTL_CODE(FILE_DEVICE_WPD, WPD_CONTROL_FUNCTION_GENERIC_MESSAGE, METHOD_BUFFERED, FILE_READ_ACCESS) 

// Drivers can use this macro to detect whether the incoming IOCTL is a WPD message or not. 
// 
#define IS_WPD_IOCTL(ControlCode) ((ControlCode == IOCTL_WPD_MESSAGE_READWRITE_ACCESS) || (ControlCode == IOCTL_WPD_MESSAGE_READ_ACCESS)) 

// Pre-defined ObjectID for the DEVICE object.
// 
#define WPD_DEVICE_OBJECT_ID L"DEVICE" 

// Pre-defined IWMDMDevice for the IWMDRMDeviceApp license/metering APIs.
// 
#define WMDRMDEVICEAPP_USE_WPD_DEVICE_PTR ((ULONG_PTR)-1) 

// Pre-defined name of a REG_DWORD value that defines the device type, used for representation purposes only. Functional characteristics of the device are decided through functional objects. 
// This value can be retrieved using IPortableDeviceManager::GetDeviceProperty(...). See WPD_DEVICE_TYPES enumeration for possible values. 
#define PORTABLE_DEVICE_TYPE L"PortableDeviceType" 

// Pre-defined name of a REG_SZ/REG_EXPAND_SZ/REG_MULTI_SZ value that indicates the location of the device icon file or device icon resource. 
// This value can be retrieved using IPortableDeviceManager::GetDeviceProperty(...). This REG_SZ/REG_EXPAND_SZ/REG_MULTI_SZ value is either in the form "file.dll, resourceID" or a full file path to an icon file. e.g.: "x:\file.ico" 
#define PORTABLE_DEVICE_ICON L"Icons" 

// Pre-defined name of a REG_DWORD value that indicates the amount of time in milliseconds the WPD Namespace Extension will keep its reference to the device open under idle conditions. 
// This value can be retrieved using IPortableDeviceManager::GetDeviceProperty(...). 
#define PORTABLE_DEVICE_NAMESPACE_TIMEOUT L"PortableDeviceNameSpaceTimeout" 

// Pre-defined name of a REG_DWORD value that is used as a flag to indicate whether the device should, or should not, be shown in the Explorer view. 
// This value can be retrieved using IPortableDeviceManager::GetDeviceProperty(...). Meaning of values are: 0 = include, 1 = exclude. 0 is assumed if this value doesn't exist. 
#define PORTABLE_DEVICE_NAMESPACE_EXCLUDE_FROM_SHELL L"PortableDeviceNameSpaceExcludeFromShell" 

// Pre-defined name of a REG_SZ or REG_MULTI_SZ value containing content type guids that are used indicate for what content types the portable device namespace should attempt to automatically generate a thumbnail when placing new content on the device. 
// This value can be retrieved using IPortableDeviceManager::GetDeviceProperty(...). Values should be a string representation of a GUID, in the form '{00000000-0000-0000-0000-000000000000}'. By default the portable device namespace attempts to automatically generate thumbnails for WPD_CONTENT_TYPE_IMAGE, if a device does not want this behavior it can set this value to an empty string. 
#define PORTABLE_DEVICE_NAMESPACE_THUMBNAIL_CONTENT_TYPES L"PortableDeviceNameSpaceThumbnailContentTypes" 

// Pre-defined name of a REG_DWORD value that indicates whether a Portable Device is a Mass Storage Class (MSC) device. This is used to avoid duplication of the device in certain views and scenarios that include both file system and Portable Devices. 
// This value can be retrieved using IPortableDeviceManager::GetDeviceProperty(...). Meaning of values are: 0 = device is not mass storage, 1 = device is mass storage. 0 is assumed if this value doesn't exist. 
#define PORTABLE_DEVICE_IS_MASS_STORAGE L"PortableDeviceIsMassStorage" 

// Pre-defined value identifying the "Windows Media Digital Rights Management 10 for Portable Devices" scheme for protecting content. 
// This value can be used by drivers to indicate they support WMDRM10-PD. See WPD_DEVICE_SUPPORTED_DRM_SCHEMES. 
#define PORTABLE_DEVICE_DRM_SCHEME_WMDRM10_PD L"WMDRM10-PD" 

// Pre-defined value identifying the "Portable Device Digital Rights Management" scheme for protecting content. 
// This value can be used by drivers to indicate they support PDDRM. See WPD_DEVICE_SUPPORTED_DRM_SCHEMES. 
#define PORTABLE_DEVICE_DRM_SCHEME_PDDRM L"PDDRM" 


/**************************************************************************** 
* This section defines flags used in API arguments 
****************************************************************************/

// Indicates whether the delete request should recursively delete any children.
typedef enum tagDELETE_OBJECT_OPTIONS
{ 
    PORTABLE_DEVICE_DELETE_NO_RECURSION = 0, 
    PORTABLE_DEVICE_DELETE_WITH_RECURSION = 1
} DELETE_OBJECT_OPTIONS; 

// Possible values for PORTABLE_DEVICE_TYPE registry value. 
typedef enum tagWPD_DEVICE_TYPES
{ 
    WPD_DEVICE_TYPE_GENERIC = 0, 
    WPD_DEVICE_TYPE_CAMERA = 1, 
    WPD_DEVICE_TYPE_MEDIA_PLAYER = 2, 
    WPD_DEVICE_TYPE_PHONE = 3, 
    WPD_DEVICE_TYPE_VIDEO = 4, 
    WPD_DEVICE_TYPE_PERSONAL_INFORMATION_MANAGER = 5, 
    WPD_DEVICE_TYPE_AUDIO_RECORDER = 6
} WPD_DEVICE_TYPES; 

// Possible values for WPD_PROPERTY_ATTRIBUTE_FORM 
typedef enum tagWpdAttributeForm
{ 
    WPD_PROPERTY_ATTRIBUTE_FORM_UNSPECIFIED = 0, 
    WPD_PROPERTY_ATTRIBUTE_FORM_RANGE = 1, 
    WPD_PROPERTY_ATTRIBUTE_FORM_ENUMERATION = 2, 
    WPD_PROPERTY_ATTRIBUTE_FORM_REGULAR_EXPRESSION = 3
} WpdAttributeForm; 

// Indicates the type of storage. 
typedef enum tagWPD_STORAGE_TYPE_VALUES
{ 
    WPD_STORAGE_TYPE_UNDEFINED = 0, 
    WPD_STORAGE_TYPE_FIXED_ROM = 1, 
    WPD_STORAGE_TYPE_REMOVABLE_ROM = 2, 
    WPD_STORAGE_TYPE_FIXED_RAM = 3, 
    WPD_STORAGE_TYPE_REMOVABLE_RAM = 4
} WPD_STORAGE_TYPE_VALUES; 

// Indicates write-protection that globally affects the storage. 
typedef enum tagWPD_STORAGE_ACCESS_CAPABILITY_VALUES
{ 
    WPD_STORAGE_ACCESS_CAPABILITY_READWRITE = 0, 
    WPD_STORAGE_ACCESS_CAPABILITY_READ_ONLY_WITHOUT_OBJECT_DELETION = 1, 
    WPD_STORAGE_ACCESS_CAPABILITY_READ_ONLY_WITH_OBJECT_DELETION = 2
} WPD_STORAGE_ACCESS_CAPABILITY_VALUES; 

// Possible values for WPD_SMS_ENCODING 
typedef enum tagWPD_SMS_ENCODING_TYPES
{ 
    SMS_ENCODING_7_BIT = 0, 
    SMS_ENCODING_8_BIT = 1, 
    SMS_ENCODING_UTF_16 = 2
} WPD_SMS_ENCODING_TYPES; 

// Possible values for WPD_PROPERTY_SMS_MESSAGE_TYPE 
typedef enum tagSMS_MESSAGE_TYPES
{ 
    SMS_TEXT_MESSAGE = 0, 
    SMS_BINARY_MESSAGE = 1
} SMS_MESSAGE_TYPES; 

// Indicates whether the device is on battery power or external power.
typedef enum tagWPD_POWER_SOURCES
{ 
    WPD_POWER_SOURCE_BATTERY = 0, 
    WPD_POWER_SOURCE_EXTERNAL = 1
} WPD_POWER_SOURCES; 

// Indicates the way the device weighs color channels.
typedef enum tagWPD_WHITE_BALANCE_SETTINGS
{ 
    WPD_WHITE_BALANCE_UNDEFINED = 0, 
    WPD_WHITE_BALANCE_MANUAL = 1, 
    WPD_WHITE_BALANCE_AUTOMATIC = 2, 
    WPD_WHITE_BALANCE_ONE_PUSH_AUTOMATIC = 3, 
    WPD_WHITE_BALANCE_DAYLIGHT = 4, 
    WPD_WHITE_BALANCE_FLORESCENT = 5, 
    WPD_WHITE_BALANCE_TUNGSTEN = 6, 
    WPD_WHITE_BALANCE_FLASH = 7
} WPD_WHITE_BALANCE_SETTINGS; 

// Indicates the focus mode of the device.
typedef enum tagWPD_FOCUS_MODES
{ 
    WPD_FOCUS_UNDEFINED = 0, 
    WPD_FOCUS_MANUAL = 1, 
    WPD_FOCUS_AUTOMATIC = 2, 
    WPD_FOCUS_AUTOMATIC_MACRO = 3
} WPD_FOCUS_MODES; 

// Indicates the metering mode of the device.
typedef enum tagWPD_EXPOSURE_METERING_MODES
{ 
    WPD_EXPOSURE_METERING_MODE_UNDEFINED = 0, 
    WPD_EXPOSURE_METERING_MODE_AVERAGE = 1, 
    WPD_EXPOSURE_METERING_MODE_CENTER_WEIGHTED_AVERAGE = 2, 
    WPD_EXPOSURE_METERING_MODE_MULTI_SPOT = 3, 
    WPD_EXPOSURE_METERING_MODE_CENTER_SPOT = 4
} WPD_EXPOSURE_METERING_MODES; 

// Indicates the flash mode of the device.
typedef enum tagWPD_FLASH_MODES
{ 
    WPD_FLASH_MODE_UNDEFINED = 0, 
    WPD_FLASH_MODE_AUTO = 1, 
    WPD_FLASH_MODE_OFF = 2, 
    WPD_FLASH_MODE_FILL = 3, 
    WPD_FLASH_MODE_RED_EYE_AUTO = 4, 
    WPD_FLASH_MODE_RED_EYE_FILL = 5, 
    WPD_FLASH_MODE_EXTERNAL_SYNC = 6
} WPD_FLASH_MODES; 

// Indicates the exposure program mode of the device.
typedef enum tagWPD_EXPOSURE_PROGRAM_MODES
{ 
    WPD_EXPOSURE_PROGRAM_MODE_UNDEFINED = 0, 
    WPD_EXPOSURE_PROGRAM_MODE_MANUAL = 1, 
    WPD_EXPOSURE_PROGRAM_MODE_AUTO = 2, 
    WPD_EXPOSURE_PROGRAM_MODE_APERTURE_PRIORITY = 3, 
    WPD_EXPOSURE_PROGRAM_MODE_SHUTTER_PRIORITY = 4, 
    WPD_EXPOSURE_PROGRAM_MODE_CREATIVE = 5, 
    WPD_EXPOSURE_PROGRAM_MODE_ACTION = 6, 
    WPD_EXPOSURE_PROGRAM_MODE_PORTRAIT = 7
} WPD_EXPOSURE_PROGRAM_MODES; 

// Indicates the capture mode of the device.
typedef enum tagWPD_CAPTURE_MODES
{ 
    WPD_CAPTURE_MODE_UNDEFINED = 0, 
    WPD_CAPTURE_MODE_NORMAL = 1, 
    WPD_CAPTURE_MODE_BURST = 2, 
    WPD_CAPTURE_MODE_TIMELAPSE = 3
} WPD_CAPTURE_MODES; 

// Indicates the effect mode of the capture device.
typedef enum tagWPD_EFFECT_MODES
{ 
    WPD_EFFECT_MODE_UNDEFINED = 0, 
    WPD_EFFECT_MODE_COLOR = 1, 
    WPD_EFFECT_MODE_BLACK_AND_WHITE = 2, 
    WPD_EFFECT_MODE_SEPIA = 3
} WPD_EFFECT_MODES; 

// Indicates the metering mode of the capture device.
typedef enum tagWPD_FOCUS_METERING_MODES
{ 
    WPD_FOCUS_METERING_MODE_UNDEFINED = 0, 
    WPD_FOCUS_METERING_MODE_CENTER_SPOT = 1, 
    WPD_FOCUS_METERING_MODE_MULTI_SPOT = 2
} WPD_FOCUS_METERING_MODES; 

// Indicates the type of bitrate for the audio/video data.
typedef enum tagWPD_BITRATE_TYPES
{ 
    WPD_BITRATE_TYPE_UNUSED = 0, 
    WPD_BITRATE_TYPE_DISCRETE = 1, 
    WPD_BITRATE_TYPE_VARIABLE = 2, 
    WPD_BITRATE_TYPE_FREE = 3
} WPD_BITRATE_TYPES; 

// Qualifies the object data in a contextual way.
typedef enum tagWPD_META_GENRES
{ 
    WPD_META_GENRE_UNUSED = 0x0, 
    WPD_META_GENRE_GENERIC_MUSIC_AUDIO_FILE = 0x1, 
    WPD_META_GENRE_GENERIC_NON_MUSIC_AUDIO_FILE = 0x11, 
    WPD_META_GENRE_SPOKEN_WORD_AUDIO_BOOK_FILES = 0x12, 
    WPD_META_GENRE_SPOKEN_WORD_FILES_NON_AUDIO_BOOK = 0x13, 
    WPD_META_GENRE_SPOKEN_WORD_NEWS = 0x14, 
    WPD_META_GENRE_SPOKEN_WORD_TALK_SHOWS = 0x15, 
    WPD_META_GENRE_GENERIC_VIDEO_FILE = 0x21, 
    WPD_META_GENRE_NEWS_VIDEO_FILE = 0x22, 
    WPD_META_GENRE_MUSIC_VIDEO_FILE = 0x23, 
    WPD_META_GENRE_HOME_VIDEO_FILE = 0x24, 
    WPD_META_GENRE_FEATURE_FILM_VIDEO_FILE = 0x25, 
    WPD_META_GENRE_TELEVISION_VIDEO_FILE = 0x26, 
    WPD_META_GENRE_TRAINING_EDUCATIONAL_VIDEO_FILE = 0x27, 
    WPD_META_GENRE_PHOTO_MONTAGE_VIDEO_FILE = 0x28, 
    WPD_META_GENRE_GENERIC_NON_AUDIO_NON_VIDEO = 0x30, 
    WPD_META_GENRE_AUDIO_PODCAST = 0x40, 
    WPD_META_GENRE_VIDEO_PODCAST = 0x41, 
    WPD_META_GENRE_MIXED_PODCAST = 0x42
} WPD_META_GENRES; 

// Indicates the cropped status of an image. 
typedef enum tagWPD_CROPPED_STATUS_VALUES
{ 
    WPD_CROPPED_STATUS_NOT_CROPPED = 0, 
    WPD_CROPPED_STATUS_CROPPED = 1, 
    WPD_CROPPED_STATUS_SHOULD_NOT_BE_CROPPED = 2
} WPD_CROPPED_STATUS_VALUES; 

// Indicates the color corrected status of an image. 
typedef enum tagWPD_COLOR_CORRECTED_STATUS_VALUES
{ 
    WPD_COLOR_CORRECTED_STATUS_NOT_CORRECTED = 0, 
    WPD_COLOR_CORRECTED_STATUS_CORRECTED = 1, 
    WPD_COLOR_CORRECTED_STATUS_SHOULD_NOT_BE_CORRECTED = 2
} WPD_COLOR_CORRECTED_STATUS_VALUES; 

// Identifies the video scan-type information. 
typedef enum tagWPD_VIDEO_SCAN_TYPES
{ 
    WPD_VIDEO_SCAN_TYPE_UNUSED = 0, 
    WPD_VIDEO_SCAN_TYPE_PROGRESSIVE = 1, 
    WPD_VIDEO_SCAN_TYPE_FIELD_INTERLEAVED_UPPER_FIRST = 2, 
    WPD_VIDEO_SCAN_TYPE_FIELD_INTERLEAVED_LOWER_FIRST = 3, 
    WPD_VIDEO_SCAN_TYPE_FIELD_SINGLE_UPPER_FIRST = 4, 
    WPD_VIDEO_SCAN_TYPE_FIELD_SINGLE_LOWER_FIRST = 5, 
    WPD_VIDEO_SCAN_TYPE_MIXED_INTERLACE = 6, 
    WPD_VIDEO_SCAN_TYPE_MIXED_INTERLACE_AND_PROGRESSIVE = 7
} WPD_VIDEO_SCAN_TYPES; 

// Indicates the current state of the operation in progress. 
typedef enum tagWPD_OPERATION_STATES
{ 
    WPD_OPERATION_STATE_UNSPECIFIED = 0, 
    WPD_OPERATION_STATE_STARTED = 1, 
    WPD_OPERATION_STATE_RUNNING = 2, 
    WPD_OPERATION_STATE_PAUSED = 3, 
    WPD_OPERATION_STATE_CANCELLED = 4, 
    WPD_OPERATION_STATE_FINISHED = 5, 
    WPD_OPERATION_STATE_ABORTED = 6
} WPD_OPERATION_STATES; 

// Indicates the units for a referenced section of data. 
typedef enum tagWPD_SECTION_DATA_UNITS_VALUES
{ 
    WPD_SECTION_DATA_UNITS_BYTES = 0, 
    WPD_SECTION_DATA_UNITS_MILLISECONDS = 1
} WPD_SECTION_DATA_UNITS_VALUES; 

// Indicates whether the rendering information profile entry corresponds to an Object or a Resource. 
typedef enum tagWPD_RENDERING_INFORMATION_PROFILE_ENTRY_TYPES
{ 
    WPD_RENDERING_INFORMATION_PROFILE_ENTRY_TYPE_OBJECT = 0, 
    WPD_RENDERING_INFORMATION_PROFILE_ENTRY_TYPE_RESOURCE = 1
} WPD_RENDERING_INFORMATION_PROFILE_ENTRY_TYPES; 

// Indicates the type of access the command requires. This is only used internally by the command access lookup table. There is no need to use these values directly. 
typedef enum tagWPD_COMMAND_ACCESS_TYPES
{ 
    WPD_COMMAND_ACCESS_READ = 1, 
    WPD_COMMAND_ACCESS_READWRITE = 3, 
    WPD_COMMAND_ACCESS_FROM_PROPERTY_WITH_STGM_ACCESS = 4, 
    WPD_COMMAND_ACCESS_FROM_PROPERTY_WITH_FILE_ACCESS = 8
} WPD_COMMAND_ACCESS_TYPES; 

/**************************************************************************** 
* This section declares WPD specific Errors 
****************************************************************************/
#define FACILITY_WPD 42 

#define E_WPD_DEVICE_ALREADY_OPENED MAKE_HRESULT( SEVERITY_ERROR , FACILITY_WPD, 1 ) /* 0x802A0001 */
#define E_WPD_DEVICE_NOT_OPEN MAKE_HRESULT( SEVERITY_ERROR , FACILITY_WPD, 2 ) /* 0x802A0002 */
#define E_WPD_OBJECT_ALREADY_ATTACHED_TO_DEVICE MAKE_HRESULT( SEVERITY_ERROR , FACILITY_WPD, 3 ) /* 0x802A0003 */
#define E_WPD_OBJECT_NOT_ATTACHED_TO_DEVICE MAKE_HRESULT( SEVERITY_ERROR , FACILITY_WPD, 4 ) /* 0x802A0004 */
#define E_WPD_OBJECT_NOT_COMMITED MAKE_HRESULT( SEVERITY_ERROR , FACILITY_WPD, 5 ) /* 0x802A0005 */
#define E_WPD_DEVICE_IS_HUNG MAKE_HRESULT( SEVERITY_ERROR , FACILITY_WPD, 6 ) /* 0x802A0006 */
#define E_WPD_SMS_INVALID_RECIPIENT MAKE_HRESULT( SEVERITY_ERROR , FACILITY_WPD, 100 ) /* 0x802A0064 */
#define E_WPD_SMS_INVALID_MESSAGE_BODY MAKE_HRESULT( SEVERITY_ERROR , FACILITY_WPD, 101 ) /* 0x802A0065 */
#define E_WPD_SMS_SERVICE_UNAVAILABLE MAKE_HRESULT( SEVERITY_ERROR , FACILITY_WPD, 102 ) /* 0x802A0066 */

/**************************************************************************** 
* This section defines all WPD Events 
****************************************************************************/
// 
// WPD_EVENT_NOTIFICATION
//   This GUID is used to identify all WPD driver events to the event sub-system. The driver uses this as the GUID identifier when it queues an event with IWdfDevice::PostEvent(). Applications never use this value. 
DEFINE_GUID(WPD_EVENT_NOTIFICATION, 0x2BA2E40A, 0x6B4C, 0x4295, 0xBB, 0x43, 0x26, 0x32, 0x2B, 0x99, 0xAE, 0xB2 ); 
// 
// WPD_EVENT_OBJECT_ADDED
//   This event is sent after a new object is available on the device. 
DEFINE_GUID(WPD_EVENT_OBJECT_ADDED, 0xA726DA95, 0xE207, 0x4B02, 0x8D, 0x44, 0xBE, 0xF2, 0xE8, 0x6C, 0xBF, 0xFC ); 
// 
// WPD_EVENT_OBJECT_REMOVED
//   This event is sent after a previously existing object has been removed from the device. 
DEFINE_GUID(WPD_EVENT_OBJECT_REMOVED, 0xBE82AB88, 0xA52C, 0x4823, 0x96, 0xE5, 0xD0, 0x27, 0x26, 0x71, 0xFC, 0x38 ); 
// 
// WPD_EVENT_OBJECT_UPDATED
//   This event is sent after an object has been updated such that any connected client should refresh its view of that object. 
DEFINE_GUID(WPD_EVENT_OBJECT_UPDATED, 0x1445A759, 0x2E01, 0x485D, 0x9F, 0x27, 0xFF, 0x07, 0xDA, 0xE6, 0x97, 0xAB ); 
// 
// WPD_EVENT_DEVICE_RESET
//   This event indicates that the device is about to be reset, and all connected clients should close their connection to the device. 
DEFINE_GUID(WPD_EVENT_DEVICE_RESET, 0x7755CF53, 0xC1ED, 0x44F3, 0xB5, 0xA2, 0x45, 0x1E, 0x2C, 0x37, 0x6B, 0x27 ); 
// 
// WPD_EVENT_DEVICE_CAPABILITIES_UPDATED
//   This event indicates that the device capabilities have changed. Clients should re-query the device if they have made any decisions based on device capabilities. 
DEFINE_GUID(WPD_EVENT_DEVICE_CAPABILITIES_UPDATED, 0x36885AA1, 0xCD54, 0x4DAA, 0xB3, 0xD0, 0xAF, 0xB3, 0xE0, 0x3F, 0x59, 0x99 ); 
// 
// WPD_EVENT_STORAGE_FORMAT
//   This event indicates the progress of a format operation on a storage object. 
DEFINE_GUID(WPD_EVENT_STORAGE_FORMAT, 0x3782616B, 0x22BC, 0x4474, 0xA2, 0x51, 0x30, 0x70, 0xF8, 0xD3, 0x88, 0x57 ); 
// 
// WPD_EVENT_OBJECT_TRANSFER_REQUESTED
//   This event is sent to request an application to transfer a particular object from the device. 
DEFINE_GUID(WPD_EVENT_OBJECT_TRANSFER_REQUESTED, 0x8D16A0A1, 0xF2C6, 0x41DA, 0x8F, 0x19, 0x5E, 0x53, 0x72, 0x1A, 0xDB, 0xF2 ); 
// 
// WPD_EVENT_DEVICE_REMOVED
//   This event is sent when a driver for a device is being unloaded. This is typically a result of the device being unplugged. 
DEFINE_GUID(WPD_EVENT_DEVICE_REMOVED, 0xE4CBCA1B, 0x6918, 0x48B9,0x85, 0xEE, 0x02, 0xBE, 0x7C, 0x85, 0x0A, 0xF9 ); 

/**************************************************************************** 
* This section defines all WPD content types 
****************************************************************************/
// 
// WPD_CONTENT_TYPE_FUNCTIONAL_OBJECT
//   Indicates this object represents a functional object, not content data on the device. 
DEFINE_GUID(WPD_CONTENT_TYPE_FUNCTIONAL_OBJECT, 0x99ED0160, 0x17FF, 0x4C44, 0x9D, 0x98, 0x1D, 0x7A, 0x6F, 0x94, 0x19, 0x21 );
// 
// WPD_CONTENT_TYPE_FOLDER
//   Indicates this object is a folder. 
DEFINE_GUID(WPD_CONTENT_TYPE_FOLDER, 0x27E2E392, 0xA111, 0x48E0, 0xAB, 0x0C, 0xE1, 0x77, 0x05, 0xA0, 0x5F, 0x85 );
// 
// WPD_CONTENT_TYPE_IMAGE
//   Indicates this object represents image data (e.g. a JPEG file) 
DEFINE_GUID(WPD_CONTENT_TYPE_IMAGE, 0xef2107d5, 0xa52a, 0x4243, 0xa2, 0x6b, 0x62, 0xd4, 0x17, 0x6d, 0x76, 0x03 );
// 
// WPD_CONTENT_TYPE_DOCUMENT
//   Indicates this object represents document data (e.g. a MS WORD file, TEXT file, etc.) 
DEFINE_GUID(WPD_CONTENT_TYPE_DOCUMENT, 0x680ADF52, 0x950A, 0x4041, 0x9B, 0x41, 0x65, 0xE3, 0x93, 0x64, 0x81, 0x55 );
// 
// WPD_CONTENT_TYPE_CONTACT
//   Indicates this object represents contact data (e.g. name/number, or a VCARD file) 
DEFINE_GUID(WPD_CONTENT_TYPE_CONTACT, 0xEABA8313, 0x4525, 0x4707, 0x9F, 0x0E, 0x87, 0xC6, 0x80, 0x8E, 0x94, 0x35 );
// 
// WPD_CONTENT_TYPE_CONTACT_GROUP
//   Indicates this object represents a group of contacts. 
DEFINE_GUID(WPD_CONTENT_TYPE_CONTACT_GROUP, 0x346B8932, 0x4C36, 0x40D8, 0x94, 0x15, 0x18, 0x28, 0x29, 0x1F, 0x9D, 0xE9 );
// 
// WPD_CONTENT_TYPE_AUDIO
//   Indicates this object represents audio data (e.g. a WMA or MP3 file) 
DEFINE_GUID(WPD_CONTENT_TYPE_AUDIO, 0x4AD2C85E, 0x5E2D, 0x45E5, 0x88, 0x64, 0x4F, 0x22, 0x9E, 0x3C, 0x6C, 0xF0 );
// 
// WPD_CONTENT_TYPE_VIDEO
//   Indicates this object represents video data (e.g. a WMV or AVI file) 
DEFINE_GUID(WPD_CONTENT_TYPE_VIDEO, 0x9261B03C, 0x3D78, 0x4519, 0x85, 0xE3, 0x02, 0xC5, 0xE1, 0xF5, 0x0B, 0xB9 );
// 
// WPD_CONTENT_TYPE_PLAYLIST
//   Indicates this object represents a playlist. 
DEFINE_GUID(WPD_CONTENT_TYPE_PLAYLIST, 0x1A33F7E4, 0xAF13, 0x48F5, 0x99, 0x4E, 0x77, 0x36, 0x9D, 0xFE, 0x04, 0xA3 );
// 
// WPD_CONTENT_TYPE_MIXED_CONTENT_ALBUM
//   Indicates this object represents an album, which may contain objects of different content types (typically, MUSIC, IMAGE and VIDEO). 
DEFINE_GUID(WPD_CONTENT_TYPE_MIXED_CONTENT_ALBUM, 0x00F0C3AC, 0xA593, 0x49AC, 0x92, 0x19, 0x24, 0xAB, 0xCA, 0x5A, 0x25, 0x63 );
// 
// WPD_CONTENT_TYPE_AUDIO_ALBUM
//   Indicates this object represents an audio album. 
DEFINE_GUID(WPD_CONTENT_TYPE_AUDIO_ALBUM, 0xAA18737E, 0x5009, 0x48FA, 0xAE, 0x21, 0x85, 0xF2, 0x43, 0x83, 0xB4, 0xE6 );
// 
// WPD_CONTENT_TYPE_IMAGE_ALBUM
//   Indicates this object represents an image album. 
DEFINE_GUID(WPD_CONTENT_TYPE_IMAGE_ALBUM, 0x75793148, 0x15F5, 0x4A30, 0xA8, 0x13, 0x54, 0xED, 0x8A, 0x37, 0xE2, 0x26 );
// 
// WPD_CONTENT_TYPE_VIDEO_ALBUM
//   Indicates this object represents a video album. 
DEFINE_GUID(WPD_CONTENT_TYPE_VIDEO_ALBUM, 0x012B0DB7, 0xD4C1, 0x45D6, 0xB0, 0x81, 0x94, 0xB8, 0x77, 0x79, 0x61, 0x4F );
// 
// WPD_CONTENT_TYPE_MEMO
//   Indicates this object represents memo data 
DEFINE_GUID(WPD_CONTENT_TYPE_MEMO, 0x9CD20ECF, 0x3B50, 0x414F, 0xA6, 0x41, 0xE4, 0x73, 0xFF, 0xE4, 0x57, 0x51 );
// 
// WPD_CONTENT_TYPE_EMAIL
//   Indicates this object represents e-mail data 
DEFINE_GUID(WPD_CONTENT_TYPE_EMAIL, 0x8038044A, 0x7E51, 0x4F8F, 0x88, 0x3D, 0x1D, 0x06, 0x23, 0xD1, 0x45, 0x33 );
// 
// WPD_CONTENT_TYPE_APPOINTMENT
//   Indicates this object represents an appointment in a calendar 
DEFINE_GUID(WPD_CONTENT_TYPE_APPOINTMENT, 0x0FED060E, 0x8793, 0x4B1E, 0x90, 0xC9, 0x48, 0xAC, 0x38, 0x9A, 0xC6, 0x31 );
// 
// WPD_CONTENT_TYPE_TASK
//   Indicates this object represents a task for tracking (e.g. a TODO list) 
DEFINE_GUID(WPD_CONTENT_TYPE_TASK, 0x63252F2C, 0x887F, 0x4CB6, 0xB1, 0xAC, 0xD2, 0x98, 0x55, 0xDC, 0xEF, 0x6C );
// 
// WPD_CONTENT_TYPE_PROGRAM
//   Indicates this object represents a file that can be run. This could be a script, executable and so on. 
DEFINE_GUID(WPD_CONTENT_TYPE_PROGRAM, 0xD269F96A, 0x247C, 0x4BFF, 0x98, 0xFB, 0x97, 0xF3, 0xC4, 0x92, 0x20, 0xE6 );
// 
// WPD_CONTENT_TYPE_GENERIC_FILE
//   Indicates this object represents a file that does not fall into any of the other predefined WPD types for files. 
DEFINE_GUID(WPD_CONTENT_TYPE_GENERIC_FILE, 0x0085E0A6, 0x8D34, 0x45D7, 0xBC, 0x5C, 0x44, 0x7E, 0x59, 0xC7, 0x3D, 0x48 );
// 
// WPD_CONTENT_TYPE_CALENDAR
//   Indicates this object represents a calender 
DEFINE_GUID(WPD_CONTENT_TYPE_CALENDAR, 0xA1FD5967, 0x6023, 0x49A0, 0x9D, 0xF1, 0xF8, 0x06, 0x0B, 0xE7, 0x51, 0xB0 );
// 
// WPD_CONTENT_TYPE_GENERIC_MESSAGE
//   Indicates this object represents a message (e.g. SMS message, E-Mail message, etc.) 
DEFINE_GUID(WPD_CONTENT_TYPE_GENERIC_MESSAGE, 0xE80EAAF8, 0xB2DB, 0x4133, 0xB6, 0x7E, 0x1B, 0xEF, 0x4B, 0x4A, 0x6E, 0x5F );
// 
// WPD_CONTENT_TYPE_NETWORK_ASSOCIATION
//   Indicates this object represents an association between a host and a device. 
DEFINE_GUID(WPD_CONTENT_TYPE_NETWORK_ASSOCIATION, 0x031DA7EE, 0x18C8, 0x4205, 0x84, 0x7E, 0x89, 0xA1, 0x12, 0x61, 0xD0, 0xF3 );
// 
// WPD_CONTENT_TYPE_CERTIFICATE
//   Indicates this object represents certificate used for authentication. 
DEFINE_GUID(WPD_CONTENT_TYPE_CERTIFICATE, 0xDC3876E8, 0xA948, 0x4060, 0x90, 0x50, 0xCB, 0xD7, 0x7E, 0x8A, 0x3D, 0x87 );
// 
// WPD_CONTENT_TYPE_WIRELESS_PROFILE
//   Indicates this object represents wireless network access information. 
DEFINE_GUID(WPD_CONTENT_TYPE_WIRELESS_PROFILE, 0x0BAC070A, 0x9F5F, 0x4DA4, 0xA8, 0xF6, 0x3D, 0xE4, 0x4D, 0x68, 0xFD, 0x6C );
// 
// WPD_CONTENT_TYPE_MEDIA_CAST
//   Indicates this object represents a media cast. A media cast object can be though of as a container object that groups related content, similar to how a playlist groups songs to play. Often, a media cast object is used to group media content originally published online. 
DEFINE_GUID(WPD_CONTENT_TYPE_MEDIA_CAST, 0x5E88B3CC, 0x3E65, 0x4E62, 0xBF, 0xFF, 0x22, 0x94, 0x95, 0x25, 0x3A, 0xB0 );
// 
// WPD_CONTENT_TYPE_SECTION
//   Indicates this object describes a section of data contained in another object. The WPD_OBJECT_REFERENCES property indicates which object contains the actual data. 
DEFINE_GUID(WPD_CONTENT_TYPE_SECTION, 0x821089F5, 0x1D91, 0x4DC9, 0xBE, 0x3C, 0xBB, 0xB1, 0xB3, 0x5B, 0x18, 0xCE );
// 
// WPD_CONTENT_TYPE_UNSPECIFIED
//   Indicates this object doesn't fall into the predefined WPD content types 
DEFINE_GUID(WPD_CONTENT_TYPE_UNSPECIFIED, 0x28D8D31E, 0x249C, 0x454E, 0xAA, 0xBC, 0x34, 0x88, 0x31, 0x68, 0xE6, 0x34 );
// 
// WPD_CONTENT_TYPE_ALL
//   This content type is only valid as a parameter to API functions and driver commands. It should not be reported as a supported content type by the driver. 
DEFINE_GUID(WPD_CONTENT_TYPE_ALL, 0x80E170D2, 0x1055, 0x4A3E, 0xB9, 0x52, 0x82, 0xCC, 0x4F, 0x8A, 0x86, 0x89 );

/**************************************************************************** 
* This section defines all WPD Functional Categories 
****************************************************************************/
// 
// WPD_FUNCTIONAL_CATEGORY_DEVICE
//   Used for the device object, which is always the top-most object of the device. 
DEFINE_GUID(WPD_FUNCTIONAL_CATEGORY_DEVICE, 0x08EA466B, 0xE3A4, 0x4336, 0xA1, 0xF3, 0xA4, 0x4D, 0x2B, 0x5C, 0x43, 0x8C ); 
// 
// WPD_FUNCTIONAL_CATEGORY_STORAGE
//   Indicates this object encapsulates storage functionality on the device (e.g. memory cards, internal memory) 
DEFINE_GUID(WPD_FUNCTIONAL_CATEGORY_STORAGE, 0x23F05BBC, 0x15DE, 0x4C2A, 0xA5, 0x5B, 0xA9, 0xAF, 0x5C, 0xE4, 0x12, 0xEF ); 
// 
// WPD_FUNCTIONAL_CATEGORY_STILL_IMAGE_CAPTURE
//   Indicates this object encapsulates still image capture functionality on the device (e.g. camera or camera attachment) 
DEFINE_GUID(WPD_FUNCTIONAL_CATEGORY_STILL_IMAGE_CAPTURE, 0x613CA327, 0xAB93, 0x4900, 0xB4, 0xFA, 0x89, 0x5B, 0xB5, 0x87, 0x4B, 0x79 ); 
// 
// WPD_FUNCTIONAL_CATEGORY_AUDIO_CAPTURE
//   Indicates this object encapsulates audio capture functionality on the device (e.g. voice recorder or other audio recording component)
DEFINE_GUID(WPD_FUNCTIONAL_CATEGORY_AUDIO_CAPTURE, 0x3F2A1919, 0xC7C2, 0x4A00, 0x85, 0x5D, 0xF5, 0x7C, 0xF0, 0x6D, 0xEB, 0xBB ); 
// 
// WPD_FUNCTIONAL_CATEGORY_VIDEO_CAPTURE
//   Indicates this object encapsulates video capture functionality on the device (e.g. video recorder or video recording component)
DEFINE_GUID(WPD_FUNCTIONAL_CATEGORY_VIDEO_CAPTURE, 0xE23E5F6B, 0x7243, 0x43AA, 0x8D, 0xF1, 0x0E, 0xB3, 0xD9, 0x68, 0xA9, 0x18 ); 
// 
// WPD_FUNCTIONAL_CATEGORY_SMS
//   Indicates this object encapsulates SMS sending functionality on the device (not the receiving or saved SMS messages since those are represented as content objects on the device)
DEFINE_GUID(WPD_FUNCTIONAL_CATEGORY_SMS, 0x0044A0B1, 0xC1E9, 0x4AFD, 0xB3, 0x58, 0xA6, 0x2C, 0x61, 0x17, 0xC9, 0xCF ); 
// 
// WPD_FUNCTIONAL_CATEGORY_RENDERING_INFORMATION
//   Indicates this object provides information about the rendering characteristics of the device. 
DEFINE_GUID(WPD_FUNCTIONAL_CATEGORY_RENDERING_INFORMATION, 0x08600BA4, 0xA7BA, 0x4A01, 0xAB, 0x0E, 0x00, 0x65, 0xD0, 0xA3, 0x56, 0xD3 ); 
// 
// WPD_FUNCTIONAL_CATEGORY_NETWORK_CONFIGURATION
//   Indicates this object encapsulates network configuration functionality on the device (e.g. WiFi Profiles, Partnerships). 
DEFINE_GUID(WPD_FUNCTIONAL_CATEGORY_NETWORK_CONFIGURATION, 0x48F4DB72, 0x7C6A, 0x4AB0, 0x9E, 0x1A, 0x47, 0x0E, 0x3C, 0xDB, 0xF2, 0x6A ); 
// 
// WPD_FUNCTIONAL_CATEGORY_ALL
//   This functional category is only valid as a parameter to API functions and driver commands. It should not be reported as a supported functional category by the driver. 
DEFINE_GUID(WPD_FUNCTIONAL_CATEGORY_ALL, 0x2D8A6512, 0xA74C, 0x448E, 0xBA, 0x8A, 0xF4, 0xAC, 0x07, 0xC4, 0x93, 0x99 ); 

/**************************************************************************** 
* This section defines all WPD Formats 
****************************************************************************/
// 
// WPD_OBJECT_FORMAT_PROPERTIES_ONLY
//   This object has no data stream and is completely specified by properties only. 
DEFINE_GUID(WPD_OBJECT_FORMAT_PROPERTIES_ONLY, 0x30010000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_UNSPECIFIED
//   An undefined object format on the device (e.g. objects that can not be classified by the other defined WPD format codes) 
DEFINE_GUID(WPD_OBJECT_FORMAT_UNSPECIFIED, 0x30000000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_SCRIPT
//   A device model-specific script 
DEFINE_GUID(WPD_OBJECT_FORMAT_SCRIPT, 0x30020000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_EXECUTABLE
//   A device model-specific binary executable 
DEFINE_GUID(WPD_OBJECT_FORMAT_EXECUTABLE, 0x30030000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_TEXT
//   A text file 
DEFINE_GUID(WPD_OBJECT_FORMAT_TEXT, 0x30040000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_HTML
//   A HyperText Markup Language file (text) 
DEFINE_GUID(WPD_OBJECT_FORMAT_HTML, 0x30050000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_DPOF
//   A Digital Print Order File (text) 
DEFINE_GUID(WPD_OBJECT_FORMAT_DPOF, 0x30060000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_AIFF
//   Audio file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_AIFF, 0x30070000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_WAVE
//   Audio file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_WAVE, 0x30080000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_MP3
//   Audio file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_MP3, 0x30090000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_AVI
//   Video file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_AVI, 0x300A0000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_MPEG
//   Video file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_MPEG, 0x300B0000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_ASF
//   Video file format (Microsoft Advanced Streaming Format)
DEFINE_GUID(WPD_OBJECT_FORMAT_ASF, 0x300C0000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_EXIF
//   Image file format (Exchangeable File Format), JEIDA standard 
DEFINE_GUID(WPD_OBJECT_FORMAT_EXIF, 0x38010000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_TIFFEP
//   Image file format (Tag Image File Format for Electronic Photography) 
DEFINE_GUID(WPD_OBJECT_FORMAT_TIFFEP, 0x38020000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_FLASHPIX
//   Image file format (Structured Storage Image Format) 
DEFINE_GUID(WPD_OBJECT_FORMAT_FLASHPIX, 0x38030000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_BMP
//   Image file format (Microsoft Windows Bitmap file)
DEFINE_GUID(WPD_OBJECT_FORMAT_BMP, 0x38040000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_CIFF
//   Image file format (Canon Camera Image File Format) 
DEFINE_GUID(WPD_OBJECT_FORMAT_CIFF, 0x38050000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_GIF
//   Image file format (Graphics Interchange Format) 
DEFINE_GUID(WPD_OBJECT_FORMAT_GIF, 0x38070000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_JFIF
//   Image file format (JPEG Interchange Format) 
DEFINE_GUID(WPD_OBJECT_FORMAT_JFIF, 0x38080000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_PCD
//   Image file format (PhotoCD Image Pac) 
DEFINE_GUID(WPD_OBJECT_FORMAT_PCD, 0x38090000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_PICT
//   Image file format (Quickdraw Image Format)
DEFINE_GUID(WPD_OBJECT_FORMAT_PICT, 0x380A0000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_PNG
//   Image file format (Portable Network Graphics) 
DEFINE_GUID(WPD_OBJECT_FORMAT_PNG, 0x380B0000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_TIFF
//   Image file format (Tag Image File Format) 
DEFINE_GUID(WPD_OBJECT_FORMAT_TIFF, 0x380D0000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_TIFFIT
//   Image file format (Tag Image File Format for Informational Technology) Graphic Arts 
DEFINE_GUID(WPD_OBJECT_FORMAT_TIFFIT, 0x380E0000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_JP2
//   Image file format (JPEG2000 Baseline File Format) 
DEFINE_GUID(WPD_OBJECT_FORMAT_JP2, 0x380F0000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_JPX
//   Image file format (JPEG2000 Extended File Format) 
DEFINE_GUID(WPD_OBJECT_FORMAT_JPX, 0x38100000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_WINDOWSIMAGEFORMAT
//   Image file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_WINDOWSIMAGEFORMAT, 0xB8810000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_WMA
//   Audio file format (Windows Media Audio) 
DEFINE_GUID(WPD_OBJECT_FORMAT_WMA, 0xB9010000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_WMV
//   Video file format (Windows Media Video) 
DEFINE_GUID(WPD_OBJECT_FORMAT_WMV, 0xB9810000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_WPLPLAYLIST
//   Playlist file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_WPLPLAYLIST, 0xBA100000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_M3UPLAYLIST
//   Playlist file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_M3UPLAYLIST, 0xBA110000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_MPLPLAYLIST
//   Playlist file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_MPLPLAYLIST, 0xBA120000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_ASXPLAYLIST
//   Playlist file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_ASXPLAYLIST, 0xBA130000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_PLSPLAYLIST
//   Playlist file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_PLSPLAYLIST, 0xBA140000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_ABSTRACT_CONTACT_GROUP
//   Generic format for contact group objects 
DEFINE_GUID(WPD_OBJECT_FORMAT_ABSTRACT_CONTACT_GROUP, 0xBA060000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_ABSTRACT_MEDIA_CAST
//   MediaCast file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_ABSTRACT_MEDIA_CAST, 0xBA0B0000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_VCALENDAR1
//   VCALENDAR file format (VCALENDAR Version 1) 
DEFINE_GUID(WPD_OBJECT_FORMAT_VCALENDAR1, 0xBE020000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_VCARD2
//   VCARD file format (VCARD Version 2)
DEFINE_GUID(WPD_OBJECT_FORMAT_VCARD2, 0xBB820000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_VCARD3
//   VCARD file format (VCARD Version 3)
DEFINE_GUID(WPD_OBJECT_FORMAT_VCARD3, 0xBB830000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_ICON
//   Standard Windows ICON format 
DEFINE_GUID(WPD_OBJECT_FORMAT_ICON, 0x077232ED, 0x102C, 0x4638, 0x9C, 0x22, 0x83, 0xF1, 0x42, 0xBF, 0xC8, 0x22 );
// 
// WPD_OBJECT_FORMAT_XML
//   XML file format. 
DEFINE_GUID(WPD_OBJECT_FORMAT_XML, 0xBA820000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_AAC
//   Audio file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_AAC, 0xB9030000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_AUDIBLE
//   Audio file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_AUDIBLE, 0xB9040000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_FLAC
//   Audio file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_FLAC, 0xB9060000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_OGG
//   Audio file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_OGG, 0xB9020000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_MP4
//   Audio or Video file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_MP4, 0xB9820000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_MP2
//   Audio or Video file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_MP2, 0xB9830000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_MICROSOFT_WORD
//   Microsoft Office Word Document file format. 
DEFINE_GUID(WPD_OBJECT_FORMAT_MICROSOFT_WORD, 0xBA830000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_MHT_COMPILED_HTML
//   MHT Compiled HTML Document file format. 
DEFINE_GUID(WPD_OBJECT_FORMAT_MHT_COMPILED_HTML, 0xBA840000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_MICROSOFT_EXCEL
//   Microsoft Office Excel Document file format. 
DEFINE_GUID(WPD_OBJECT_FORMAT_MICROSOFT_EXCEL, 0xBA850000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_MICROSOFT_POWERPOINT
//   Microsoft Office PowerPoint Document file format. 
DEFINE_GUID(WPD_OBJECT_FORMAT_MICROSOFT_POWERPOINT, 0xBA860000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_NETWORK_ASSOCIATION
//   Network Association file format. 
DEFINE_GUID(WPD_OBJECT_FORMAT_NETWORK_ASSOCIATION, 0xB1020000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_X509V3CERTIFICATE
//   X.509 V3 Certificate file format. 
DEFINE_GUID(WPD_OBJECT_FORMAT_X509V3CERTIFICATE, 0xB1030000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_MICROSOFT_WFC
//   Windows Connect Now file format. 
DEFINE_GUID(WPD_OBJECT_FORMAT_MICROSOFT_WFC, 0xB1040000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_3GP
//   Audio or Video file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_3GP, 0xB9840000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_ALL
//   This format is only valid as a parameter to API functions and driver commands. It should not be reported as a supported format by the driver. 
DEFINE_GUID(WPD_OBJECT_FORMAT_ALL, 0xC1F62EB2, 0x4BB3, 0x479C, 0x9C, 0xFA, 0x05, 0xB5, 0xF3, 0xA5, 0x7B, 0x22 );

/**************************************************************************** 
* This section defines all Resource keys. Resources are place-holders for 
* binary data. 
* 
****************************************************************************/ 
// 
// WPD_RESOURCE_DEFAULT 
//   Represents the entire object's data. There can be only one default resource on an object. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_DEFAULT , 0xE81E79BE, 0x34F0, 0x41BF, 0xB5, 0x3F, 0xF1, 0xA0, 0x6A, 0xE8, 0x78, 0x42 , 0 ); 
// 
// WPD_RESOURCE_CONTACT_PHOTO 
//   Represents the contact's photo data. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_CONTACT_PHOTO , 0x2C4D6803, 0x80EA, 0x4580, 0xAF, 0x9A, 0x5B, 0xE1, 0xA2, 0x3E, 0xDD, 0xCB , 0 ); 
// 
// WPD_RESOURCE_THUMBNAIL 
//   Represents the thumbnail data for an object. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_THUMBNAIL , 0xC7C407BA, 0x98FA, 0x46B5, 0x99, 0x60, 0x23, 0xFE, 0xC1, 0x24, 0xCF, 0xDE , 0 ); 
// 
// WPD_RESOURCE_ICON 
//   Represents the icon data for an object. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_ICON , 0xF195FED8, 0xAA28, 0x4EE3, 0xB1, 0x53, 0xE1, 0x82, 0xDD, 0x5E, 0xDC, 0x39 , 0 ); 
// 
// WPD_RESOURCE_AUDIO_CLIP 
//   Represents an audio sample data for an object. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_AUDIO_CLIP , 0x3BC13982, 0x85B1, 0x48E0, 0x95, 0xA6, 0x8D, 0x3A, 0xD0, 0x6B, 0xE1, 0x17 , 0 ); 
// 
// WPD_RESOURCE_ALBUM_ART 
//   Represents the album artwork this media originated from. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_ALBUM_ART , 0xF02AA354, 0x2300, 0x4E2D, 0xA1, 0xB9, 0x3B, 0x67, 0x30, 0xF7, 0xFA, 0x21 , 0 ); 
// 
// WPD_RESOURCE_GENERIC 
//   Represents an arbitrary binary blob associated with this object. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_GENERIC , 0xB9B9F515, 0xBA70, 0x4647, 0x94, 0xDC, 0xFA, 0x49, 0x25, 0xE9, 0x5A, 0x07 , 0 ); 
// 
// WPD_RESOURCE_VIDEO_CLIP 
//   Represents a video sample for an object. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_VIDEO_CLIP , 0xB566EE42, 0x6368, 0x4290, 0x86, 0x62, 0x70, 0x18, 0x2F, 0xB7, 0x9F, 0x20 , 0 ); 
// 
// WPD_RESOURCE_BRANDING_ART 
//   Represents the product branding artwork or logo for an object. This resource is typically found on, but not limited to the device object. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_BRANDING_ART , 0xB633B1AE, 0x6CAF, 0x4A87, 0x95, 0x89, 0x22, 0xDE, 0xD6, 0xDD, 0x58, 0x99 , 0 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_NULL 
* 
* This category is used exclusively for the NULL property key define. 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_NULL , 0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ); 

// 
// WPD_PROPERTY_NULL 
//   [ VT_EMPTY ] A NULL property key. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_NULL , 0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 , 0 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_OBJECT_PROPERTIES_V1 
* 
* This category is for all common object properties. 
****************************************************************************/ 
DEFINE_GUID( WPD_OBJECT_PROPERTIES_V1 , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C ); 

// 
// WPD_OBJECT_ID 
//   [ VT_LPWSTR ] Uniquely identifies object on the Portable Device. 
DEFINE_PROPERTYKEY( WPD_OBJECT_ID , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 2 ); 
// 
// WPD_OBJECT_PARENT_ID 
//   [ VT_LPWSTR ] Object identifier indicating the parent object. 
DEFINE_PROPERTYKEY( WPD_OBJECT_PARENT_ID , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 3 ); 
// 
// WPD_OBJECT_NAME 
//   [ VT_LPWSTR ] The display name for this object. 
DEFINE_PROPERTYKEY( WPD_OBJECT_NAME , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 4 ); 
// 
// WPD_OBJECT_PERSISTENT_UNIQUE_ID 
//   [ VT_LPWSTR ] Uniquely identifies the object on the Portable Device, similar to WPD_OBJECT_ID, but this ID will not change between sessions. 
DEFINE_PROPERTYKEY( WPD_OBJECT_PERSISTENT_UNIQUE_ID , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 5 ); 
// 
// WPD_OBJECT_FORMAT 
//   [ VT_CLSID ] Indicates the format of the object's data. 
DEFINE_PROPERTYKEY( WPD_OBJECT_FORMAT , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 6 ); 
// 
// WPD_OBJECT_CONTENT_TYPE 
//   [ VT_CLSID ] The abstract type for the object content, indicating the kinds of properties and data that may be supported on the object. 
DEFINE_PROPERTYKEY( WPD_OBJECT_CONTENT_TYPE , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 7 ); 
// 
// WPD_OBJECT_ISHIDDEN 
//   [ VT_BOOL ] Indicates whether the object should be hidden. 
DEFINE_PROPERTYKEY( WPD_OBJECT_ISHIDDEN , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 9 ); 
// 
// WPD_OBJECT_ISSYSTEM 
//   [ VT_BOOL ] Indicates whether the object represents system data. 
DEFINE_PROPERTYKEY( WPD_OBJECT_ISSYSTEM , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 10 ); 
// 
// WPD_OBJECT_SIZE 
//   [ VT_UI8 ] The size of the object data. 
DEFINE_PROPERTYKEY( WPD_OBJECT_SIZE , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 11 ); 
// 
// WPD_OBJECT_ORIGINAL_FILE_NAME 
//   [ VT_LPWSTR ] Contains the name of the file this object represents. 
DEFINE_PROPERTYKEY( WPD_OBJECT_ORIGINAL_FILE_NAME , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 12 ); 
// 
// WPD_OBJECT_NON_CONSUMABLE 
//   [ VT_BOOL ] This property determines whether or not this object is intended to be understood by the device, or whether it has been placed on the device just for storage. 
DEFINE_PROPERTYKEY( WPD_OBJECT_NON_CONSUMABLE , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 13 ); 
// 
// WPD_OBJECT_REFERENCES 
//   [ VT_UNKNOWN ] IPortableDevicePropVariantCollection of type VT_LPWSTR indicating a list of ObjectIDs. 
DEFINE_PROPERTYKEY( WPD_OBJECT_REFERENCES , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 14 ); 
// 
// WPD_OBJECT_KEYWORDS 
//   [ VT_LPWSTR ] String containing a list of keywords associated with this object. 
DEFINE_PROPERTYKEY( WPD_OBJECT_KEYWORDS , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 15 ); 
// 
// WPD_OBJECT_SYNC_ID 
//   [ VT_LPWSTR ] Opaque string set by client to retain state between sessions without retaining a catalogue of connected device content. 
DEFINE_PROPERTYKEY( WPD_OBJECT_SYNC_ID , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 16 ); 
// 
// WPD_OBJECT_IS_DRM_PROTECTED 
//   [ VT_BOOL ] Indicates whether the media data is DRM protected. 
DEFINE_PROPERTYKEY( WPD_OBJECT_IS_DRM_PROTECTED , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 17 ); 
// 
// WPD_OBJECT_DATE_CREATED 
//   [ VT_DATE ] Indicates the date and time the object was created on the device. 
DEFINE_PROPERTYKEY( WPD_OBJECT_DATE_CREATED , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 18 ); 
// 
// WPD_OBJECT_DATE_MODIFIED 
//   [ VT_DATE ] Indicates the date and time the object was modified on the device. 
DEFINE_PROPERTYKEY( WPD_OBJECT_DATE_MODIFIED , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 19 ); 
// 
// WPD_OBJECT_DATE_AUTHORED 
//   [ VT_DATE ] Indicates the date and time the object was authored (e.g. for music, this would be the date the music was recorded). 
DEFINE_PROPERTYKEY( WPD_OBJECT_DATE_AUTHORED , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 20 ); 
// 
// WPD_OBJECT_BACK_REFERENCES 
//   [ VT_LPWSTR ] IPortableDevicePropVariantCollection of type VT_LPWSTR indicating a list of ObjectIDs. 
DEFINE_PROPERTYKEY( WPD_OBJECT_BACK_REFERENCES , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 21 ); 
// 
// WPD_OBJECT_CONTAINER_FUNCTIONAL_OBJECT_ID 
//   [ VT_LPWSTR ] Indicates the Object ID of the closest functional object ancestor. For example, objects that represent files/folders under a Storage functional object, will have this property set to the object ID of the storage functional object. 
DEFINE_PROPERTYKEY( WPD_OBJECT_CONTAINER_FUNCTIONAL_OBJECT_ID , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 23 ); 
// 
// WPD_OBJECT_GENERATE_THUMBNAIL_FROM_RESOURCE 
//   [ VT_BOOL ] Indicates whether the thumbnail for this object should be generated from the default resource. 
DEFINE_PROPERTYKEY( WPD_OBJECT_GENERATE_THUMBNAIL_FROM_RESOURCE , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 24 ); 
// 
// WPD_OBJECT_HINT_LOCATION_DISPLAY_NAME 
//   [ VT_LPWSTR ] If this object appears as a hint location, this property indicates the hint-specific name to display instead of the object name. 
DEFINE_PROPERTYKEY( WPD_OBJECT_HINT_LOCATION_DISPLAY_NAME , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 25 ); 
// 
// WPD_OBJECT_CAN_DELETE 
//   [ VT_BOOL ] Indicates whether the object can be deleted, or not. 
DEFINE_PROPERTYKEY( WPD_OBJECT_CAN_DELETE , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 26 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_FUNCTIONAL_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all functional objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_FUNCTIONAL_OBJECT_PROPERTIES_V1 , 0x8F052D93, 0xABCA, 0x4FC5, 0xA5, 0xAC, 0xB0, 0x1D, 0xF4, 0xDB, 0xE5, 0x98 ); 

// 
// WPD_FUNCTIONAL_OBJECT_CATEGORY 
//   [ VT_CLSID ] Indicates the object's functional category. 
DEFINE_PROPERTYKEY( WPD_FUNCTIONAL_OBJECT_CATEGORY , 0x8F052D93, 0xABCA, 0x4FC5, 0xA5, 0xAC, 0xB0, 0x1D, 0xF4, 0xDB, 0xE5, 0x98 , 2 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_FOLDER_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all folder objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_FOLDER_OBJECT_PROPERTIES_V1 , 0x7E9A7ABF, 0xE568, 0x4B34, 0xAA, 0x2F, 0x13, 0xBB, 0x12, 0xAB, 0x17, 0x7D ); 

// 
// WPD_FOLDER_CONTENT_TYPES_ALLOWED 
//   [ VT_UNKNOWN ] Indicates the subset of content types that can be created in this folder directly (i.e. children may have different restrictions). 
DEFINE_PROPERTYKEY( WPD_FOLDER_CONTENT_TYPES_ALLOWED , 0x7E9A7ABF, 0xE568, 0x4B34, 0xAA, 0x2F, 0x13, 0xBB, 0x12, 0xAB, 0x17, 0x7D , 2 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_IMAGE_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all image objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_IMAGE_OBJECT_PROPERTIES_V1 , 0x63D64908, 0x9FA1, 0x479F, 0x85, 0xBA, 0x99, 0x52, 0x21, 0x64, 0x47, 0xDB ); 

// 
// WPD_IMAGE_BITDEPTH 
//   [ VT_UI4 ] Indicates the bitdepth of an image 
DEFINE_PROPERTYKEY( WPD_IMAGE_BITDEPTH , 0x63D64908, 0x9FA1, 0x479F, 0x85, 0xBA, 0x99, 0x52, 0x21, 0x64, 0x47, 0xDB , 3 ); 
// 
// WPD_IMAGE_CROPPED_STATUS 
//   [ VT_UI4 ] Signals whether the file has been cropped. 
DEFINE_PROPERTYKEY( WPD_IMAGE_CROPPED_STATUS , 0x63D64908, 0x9FA1, 0x479F, 0x85, 0xBA, 0x99, 0x52, 0x21, 0x64, 0x47, 0xDB , 4 ); 
// 
// WPD_IMAGE_COLOR_CORRECTED_STATUS 
//   [ VT_UI4 ] Signals whether the file has been color corrected. 
DEFINE_PROPERTYKEY( WPD_IMAGE_COLOR_CORRECTED_STATUS , 0x63D64908, 0x9FA1, 0x479F, 0x85, 0xBA, 0x99, 0x52, 0x21, 0x64, 0x47, 0xDB , 5 ); 
// 
// WPD_IMAGE_FNUMBER 
//   [ VT_UI4 ] Identifies the aperture setting of the lens when this image was captured. 
DEFINE_PROPERTYKEY( WPD_IMAGE_FNUMBER , 0x63D64908, 0x9FA1, 0x479F, 0x85, 0xBA, 0x99, 0x52, 0x21, 0x64, 0x47, 0xDB , 6 ); 
// 
// WPD_IMAGE_EXPOSURE_TIME 
//   [ VT_UI4 ] Identifies the shutter speed of the device when this image was captured. 
DEFINE_PROPERTYKEY( WPD_IMAGE_EXPOSURE_TIME , 0x63D64908, 0x9FA1, 0x479F, 0x85, 0xBA, 0x99, 0x52, 0x21, 0x64, 0x47, 0xDB , 7 ); 
// 
// WPD_IMAGE_EXPOSURE_INDEX 
//   [ VT_UI4 ] Identifies the emulation of film speed settings when this image was captured. 
DEFINE_PROPERTYKEY( WPD_IMAGE_EXPOSURE_INDEX , 0x63D64908, 0x9FA1, 0x479F, 0x85, 0xBA, 0x99, 0x52, 0x21, 0x64, 0x47, 0xDB , 8 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_DOCUMENT_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all document objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_DOCUMENT_OBJECT_PROPERTIES_V1 , 0x0B110203, 0xEB95, 0x4F02, 0x93, 0xE0, 0x97, 0xC6, 0x31, 0x49, 0x3A, 0xD5 ); 


/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_MEDIA_PROPERTIES_V1 
* 
* This category is for properties common to media objects (e.g. audio and video). 
****************************************************************************/ 
DEFINE_GUID( WPD_MEDIA_PROPERTIES_V1 , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 ); 

// 
// WPD_MEDIA_TOTAL_BITRATE 
//   [ VT_UI4 ] The total number of bits that one second will consume. 
DEFINE_PROPERTYKEY( WPD_MEDIA_TOTAL_BITRATE , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 2 ); 
// 
// WPD_MEDIA_BITRATE_TYPE 
//   [ VT_UI4 ] Further qualifies the bitrate of audio or video data. 
DEFINE_PROPERTYKEY( WPD_MEDIA_BITRATE_TYPE , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 3 ); 
// 
// WPD_MEDIA_COPYRIGHT 
//   [ VT_LPWSTR ] Indicates the copyright information. 
DEFINE_PROPERTYKEY( WPD_MEDIA_COPYRIGHT , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 4 ); 
// 
// WPD_MEDIA_SUBSCRIPTION_CONTENT_ID 
//   [ VT_LPWSTR ] Provides additional information to identify a piece of content relative to an online subscription service. 
DEFINE_PROPERTYKEY( WPD_MEDIA_SUBSCRIPTION_CONTENT_ID , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 5 ); 
// 
// WPD_MEDIA_USE_COUNT 
//   [ VT_UI4 ] Indicates the total number of times this media has been played or viewed on the device. 
DEFINE_PROPERTYKEY( WPD_MEDIA_USE_COUNT , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 6 ); 
// 
// WPD_MEDIA_SKIP_COUNT 
//   [ VT_UI4 ] Indicates the total number of times this media was setup to be played or viewed but was manually skipped by the user. 
DEFINE_PROPERTYKEY( WPD_MEDIA_SKIP_COUNT , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 7 ); 
// 
// WPD_MEDIA_LAST_ACCESSED_TIME 
//   [ VT_DATE ] Indicates the date and time the media was last accessed on the device. 
DEFINE_PROPERTYKEY( WPD_MEDIA_LAST_ACCESSED_TIME , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 8 ); 
// 
// WPD_MEDIA_PARENTAL_RATING 
//   [ VT_LPWSTR ] Indicates the parental rating of the media file. 
DEFINE_PROPERTYKEY( WPD_MEDIA_PARENTAL_RATING , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 9 ); 
// 
// WPD_MEDIA_META_GENRE 
//   [ VT_UI4 ] Further qualifies a piece of media in a contextual way. 
DEFINE_PROPERTYKEY( WPD_MEDIA_META_GENRE , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 10 ); 
// 
// WPD_MEDIA_COMPOSER 
//   [ VT_LPWSTR ] Identifies the composer when the composer is not the artist who performed it. 
DEFINE_PROPERTYKEY( WPD_MEDIA_COMPOSER , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 11 ); 
// 
// WPD_MEDIA_EFFECTIVE_RATING 
//   [ VT_UI4 ] Contains an assigned rating for media not set by the user, but is generated based upon usage statistics. 
DEFINE_PROPERTYKEY( WPD_MEDIA_EFFECTIVE_RATING , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 12 ); 
// 
// WPD_MEDIA_SUB_TITLE 
//   [ VT_LPWSTR ] Further qualifies the title when the title is ambiguous or general. 
DEFINE_PROPERTYKEY( WPD_MEDIA_SUB_TITLE , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 13 ); 
// 
// WPD_MEDIA_RELEASE_DATE 
//   [ VT_DATE ] Indicates when the media was released. 
DEFINE_PROPERTYKEY( WPD_MEDIA_RELEASE_DATE , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 14 ); 
// 
// WPD_MEDIA_SAMPLE_RATE 
//   [ VT_UI4 ] Indicates the number of times media selection was sampled per second during encoding. 
DEFINE_PROPERTYKEY( WPD_MEDIA_SAMPLE_RATE , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 15 ); 
// 
// WPD_MEDIA_STAR_RATING 
//   [ VT_UI4 ] Indicates the star rating for this media. 
DEFINE_PROPERTYKEY( WPD_MEDIA_STAR_RATING , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 16 ); 
// 
// WPD_MEDIA_USER_EFFECTIVE_RATING 
//   [ VT_UI4 ] Indicates the rating for this media. 
DEFINE_PROPERTYKEY( WPD_MEDIA_USER_EFFECTIVE_RATING , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 17 ); 
// 
// WPD_MEDIA_TITLE 
//   [ VT_LPWSTR ] Indicates the title of this media. 
DEFINE_PROPERTYKEY( WPD_MEDIA_TITLE , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 18 ); 
// 
// WPD_MEDIA_DURATION 
//   [ VT_UI8 ] Indicates the duration of this media in milliseconds. 
DEFINE_PROPERTYKEY( WPD_MEDIA_DURATION , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 19 ); 
// 
// WPD_MEDIA_BUY_NOW 
//   [ VT_BOOL ] TBD 
DEFINE_PROPERTYKEY( WPD_MEDIA_BUY_NOW , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 20 ); 
// 
// WPD_MEDIA_ENCODING_PROFILE 
//   [ VT_LPWSTR ] Media codecs may be encoded in accordance with a profile, which defines a particular encoding algorithm or optimization process. 
DEFINE_PROPERTYKEY( WPD_MEDIA_ENCODING_PROFILE , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 21 ); 
// 
// WPD_MEDIA_WIDTH 
//   [ VT_UI4 ] Indicates the width of an object in pixels 
DEFINE_PROPERTYKEY( WPD_MEDIA_WIDTH , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 22 ); 
// 
// WPD_MEDIA_HEIGHT 
//   [ VT_UI4 ] Indicates the height of an object in pixels 
DEFINE_PROPERTYKEY( WPD_MEDIA_HEIGHT , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 23 ); 
// 
// WPD_MEDIA_ARTIST 
//   [ VT_LPWSTR ] Indicates the artist for this media. 
DEFINE_PROPERTYKEY( WPD_MEDIA_ARTIST , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 24 ); 
// 
// WPD_MEDIA_ALBUM_ARTIST 
//   [ VT_LPWSTR ] Indicates the artist of the entire album rather than for a particular track. 
DEFINE_PROPERTYKEY( WPD_MEDIA_ALBUM_ARTIST , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 25 ); 
// 
// WPD_MEDIA_OWNER 
//   [ VT_LPWSTR ] Indicates the e-mail address of the owner for this media. 
DEFINE_PROPERTYKEY( WPD_MEDIA_OWNER , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 26 ); 
// 
// WPD_MEDIA_MANAGING_EDITOR 
//   [ VT_LPWSTR ] Indicates the e-mail address of the managing editor for this media. 
DEFINE_PROPERTYKEY( WPD_MEDIA_MANAGING_EDITOR , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 27 ); 
// 
// WPD_MEDIA_WEBMASTER 
//   [ VT_LPWSTR ] Indicates the e-mail address of the Webmaster for this media. 
DEFINE_PROPERTYKEY( WPD_MEDIA_WEBMASTER , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 28 ); 
// 
// WPD_MEDIA_SOURCE_URL 
//   [ VT_LPWSTR ] Identifies the source URL for this object. 
DEFINE_PROPERTYKEY( WPD_MEDIA_SOURCE_URL , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 29 ); 
// 
// WPD_MEDIA_DESTINATION_URL 
//   [ VT_LPWSTR ] Identifies the URL that an object is linked to if a user clicks on it. 
DEFINE_PROPERTYKEY( WPD_MEDIA_DESTINATION_URL , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 30 ); 
// 
// WPD_MEDIA_DESCRIPTION 
//   [ VT_LPWSTR ] Contains a description of the media content for this object. 
DEFINE_PROPERTYKEY( WPD_MEDIA_DESCRIPTION , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 31 ); 
// 
// WPD_MEDIA_GENRE 
//   [ VT_LPWSTR ] A text field indicating the genre this media belongs to. 
DEFINE_PROPERTYKEY( WPD_MEDIA_GENRE , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 32 ); 
// 
// WPD_MEDIA_TIME_BOOKMARK 
//   [ VT_UI8 ] Indicates a bookmark (in milliseconds) of the last position played or viewed on media that have duration. 
DEFINE_PROPERTYKEY( WPD_MEDIA_TIME_BOOKMARK , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 33 ); 
// 
// WPD_MEDIA_OBJECT_BOOKMARK 
//   [ VT_LPWSTR ] Indicates a WPD_OBJECT_ID of the last object viewed or played for those objects that refer to a list of objects (such as playlists or media casts). 
DEFINE_PROPERTYKEY( WPD_MEDIA_OBJECT_BOOKMARK , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 34 ); 
// 
// WPD_MEDIA_LAST_BUILD_DATE 
//   [ VT_DATE ] Indicates the last time a series in a media cast was changed or edited. 
DEFINE_PROPERTYKEY( WPD_MEDIA_LAST_BUILD_DATE , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 35 ); 
// 
// WPD_MEDIA_BYTE_BOOKMARK 
//   [ VT_UI8 ] Indicates a bookmark (as a zero-based byte offset) of the last position played or viewed on this media object. 
DEFINE_PROPERTYKEY( WPD_MEDIA_BYTE_BOOKMARK , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 36 ); 
// 
// WPD_MEDIA_TIME_TO_LIVE 
//   [ VT_UI8 ] It is the number of minutes that indicates how long a channel can be cached before refreshing from the source. Applies to WPD_CONTENT_TYPE_MEDIA_CAST objects. 
DEFINE_PROPERTYKEY( WPD_MEDIA_TIME_TO_LIVE , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 37 ); 
// 
// WPD_MEDIA_GUID 
//   [ VT_LPWSTR ] A text field indicating the GUID of this media. 
DEFINE_PROPERTYKEY( WPD_MEDIA_GUID , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 38 ); 
// 
// WPD_MEDIA_SUB_DESCRIPTION 
//   [ VT_LPWSTR ] Contains a sub description of the media content for this object. 
DEFINE_PROPERTYKEY( WPD_MEDIA_SUB_DESCRIPTION , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 39 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CONTACT_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all contact objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_CONTACT_OBJECT_PROPERTIES_V1 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B ); 

// 
// WPD_CONTACT_DISPLAY_NAME 
//   [ VT_LPWSTR ] Indicates the display name of the contact (e.g "John Doe")
DEFINE_PROPERTYKEY( WPD_CONTACT_DISPLAY_NAME , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 2 ); 
// 
// WPD_CONTACT_FIRST_NAME 
//   [ VT_LPWSTR ] Indicates the first name of the contact (e.g. "John")
DEFINE_PROPERTYKEY( WPD_CONTACT_FIRST_NAME , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 3 ); 
// 
// WPD_CONTACT_MIDDLE_NAMES 
//   [ VT_LPWSTR ] Indicates the middle name of the contact 
DEFINE_PROPERTYKEY( WPD_CONTACT_MIDDLE_NAMES , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 4 ); 
// 
// WPD_CONTACT_LAST_NAME 
//   [ VT_LPWSTR ] Indicates the last name of the contact (e.g. "Doe")
DEFINE_PROPERTYKEY( WPD_CONTACT_LAST_NAME , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 5 ); 
// 
// WPD_CONTACT_PREFIX 
//   [ VT_LPWSTR ] Indicates the prefix of the name of the contact (e.g. "Mr.")
DEFINE_PROPERTYKEY( WPD_CONTACT_PREFIX , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 6 ); 
// 
// WPD_CONTACT_SUFFIX 
//   [ VT_LPWSTR ] Indicates the suffix of the name of the contact (e.g. "Jr.")
DEFINE_PROPERTYKEY( WPD_CONTACT_SUFFIX , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 7 ); 
// 
// WPD_CONTACT_PHONETIC_FIRST_NAME 
//   [ VT_LPWSTR ] The phonetic guide for pronouncing the contact's first name. 
DEFINE_PROPERTYKEY( WPD_CONTACT_PHONETIC_FIRST_NAME , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 8 ); 
// 
// WPD_CONTACT_PHONETIC_LAST_NAME 
//   [ VT_LPWSTR ] The phonetic guide for pronouncing the contact's last name. 
DEFINE_PROPERTYKEY( WPD_CONTACT_PHONETIC_LAST_NAME , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 9 ); 
// 
// WPD_CONTACT_PERSONAL_FULL_POSTAL_ADDRESS 
//   [ VT_LPWSTR ] Indicates the full postal address of the contact (e.g. "555 Dial Drive, PhoneLand, WA 12345") 
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_FULL_POSTAL_ADDRESS , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 10 ); 
// 
// WPD_CONTACT_PERSONAL_POSTAL_ADDRESS_LINE1 
//   [ VT_LPWSTR ] Indicates the first line of a postal address of the contact (e.g. "555 Dial Drive") 
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_POSTAL_ADDRESS_LINE1 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 11 ); 
// 
// WPD_CONTACT_PERSONAL_POSTAL_ADDRESS_LINE2 
//   [ VT_LPWSTR ] Indicates the second line of a postal address of the contact 
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_POSTAL_ADDRESS_LINE2 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 12 ); 
// 
// WPD_CONTACT_PERSONAL_POSTAL_ADDRESS_CITY 
//   [ VT_LPWSTR ] Indicates the city of a postal address of the contact (e.g. "PhoneLand") 
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_POSTAL_ADDRESS_CITY , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 13 ); 
// 
// WPD_CONTACT_PERSONAL_POSTAL_ADDRESS_REGION 
//   [ VT_LPWSTR ] Indicates the region of a postal address of the contact 
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_POSTAL_ADDRESS_REGION , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 14 ); 
// 
// WPD_CONTACT_PERSONAL_POSTAL_ADDRESS_POSTAL_CODE 
//   [ VT_LPWSTR ] Indicates the postal code of the address. 
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_POSTAL_ADDRESS_POSTAL_CODE , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 15 ); 
// 
// WPD_CONTACT_PERSONAL_POSTAL_ADDRESS_COUNTRY 
//   [ VT_LPWSTR ] 
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_POSTAL_ADDRESS_COUNTRY , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 16 ); 
// 
// WPD_CONTACT_BUSINESS_FULL_POSTAL_ADDRESS 
//   [ VT_LPWSTR ] Indicates the full postal address of the contact (e.g. "555 Dial Drive, PhoneLand, WA 12345") 
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_FULL_POSTAL_ADDRESS , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 17 ); 
// 
// WPD_CONTACT_BUSINESS_POSTAL_ADDRESS_LINE1 
//   [ VT_LPWSTR ] Indicates the first line of a postal address of the contact (e.g. "555 Dial Drive") 
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_POSTAL_ADDRESS_LINE1 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 18 ); 
// 
// WPD_CONTACT_BUSINESS_POSTAL_ADDRESS_LINE2 
//   [ VT_LPWSTR ] Indicates the second line of a postal address of the contact 
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_POSTAL_ADDRESS_LINE2 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 19 ); 
// 
// WPD_CONTACT_BUSINESS_POSTAL_ADDRESS_CITY 
//   [ VT_LPWSTR ] Indicates the city of a postal address of the contact (e.g. "PhoneLand") 
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_POSTAL_ADDRESS_CITY , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 20 ); 
// 
// WPD_CONTACT_BUSINESS_POSTAL_ADDRESS_REGION 
//   [ VT_LPWSTR ] Indicates the region of a postal address of the contact 
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_POSTAL_ADDRESS_REGION , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 21 ); 
// 
// WPD_CONTACT_BUSINESS_POSTAL_ADDRESS_POSTAL_CODE 
//   [ VT_LPWSTR ] Indicates the postal code of the address. 
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_POSTAL_ADDRESS_POSTAL_CODE , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 22 ); 
// 
// WPD_CONTACT_BUSINESS_POSTAL_ADDRESS_COUNTRY 
//   [ VT_LPWSTR ] 
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_POSTAL_ADDRESS_COUNTRY , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 23 ); 
// 
// WPD_CONTACT_OTHER_FULL_POSTAL_ADDRESS 
//   [ VT_LPWSTR ] Indicates the full postal address of the contact (e.g. "555 Dial Drive, PhoneLand, WA 12345"). 
DEFINE_PROPERTYKEY( WPD_CONTACT_OTHER_FULL_POSTAL_ADDRESS , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 24 ); 
// 
// WPD_CONTACT_OTHER_POSTAL_ADDRESS_LINE1 
//   [ VT_LPWSTR ] Indicates the first line of a postal address of the contact (e.g. "555 Dial Drive"). 
DEFINE_PROPERTYKEY( WPD_CONTACT_OTHER_POSTAL_ADDRESS_LINE1 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 25 ); 
// 
// WPD_CONTACT_OTHER_POSTAL_ADDRESS_LINE2 
//   [ VT_LPWSTR ] Indicates the second line of a postal address of the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_OTHER_POSTAL_ADDRESS_LINE2 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 26 ); 
// 
// WPD_CONTACT_OTHER_POSTAL_ADDRESS_CITY 
//   [ VT_LPWSTR ] Indicates the city of a postal address of the contact (e.g. "PhoneLand"). 
DEFINE_PROPERTYKEY( WPD_CONTACT_OTHER_POSTAL_ADDRESS_CITY , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 27 ); 
// 
// WPD_CONTACT_OTHER_POSTAL_ADDRESS_REGION 
//   [ VT_LPWSTR ] Indicates the region of a postal address of the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_OTHER_POSTAL_ADDRESS_REGION , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 28 ); 
// 
// WPD_CONTACT_OTHER_POSTAL_ADDRESS_POSTAL_CODE 
//   [ VT_LPWSTR ] Indicates the postal code of the address. 
DEFINE_PROPERTYKEY( WPD_CONTACT_OTHER_POSTAL_ADDRESS_POSTAL_CODE , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 29 ); 
// 
// WPD_CONTACT_OTHER_POSTAL_ADDRESS_POSTAL_COUNTRY 
//   [ VT_LPWSTR ] Indicates the country of the postal address. 
DEFINE_PROPERTYKEY( WPD_CONTACT_OTHER_POSTAL_ADDRESS_POSTAL_COUNTRY , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 30 ); 
// 
// WPD_CONTACT_PRIMARY_EMAIL_ADDRESS 
//   [ VT_LPWSTR ] Indicates the primary email address for the contact e.g. "JohnDoe@PhoneWorld.com"
DEFINE_PROPERTYKEY( WPD_CONTACT_PRIMARY_EMAIL_ADDRESS , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 31 ); 
// 
// WPD_CONTACT_PERSONAL_EMAIL 
//   [ VT_LPWSTR ] Indicates the personal email address for the contact e.g. "JohnDoe@PhoneWorld.com"
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_EMAIL , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 32 ); 
// 
// WPD_CONTACT_PERSONAL_EMAIL2 
//   [ VT_LPWSTR ] Indicates an alternate personal email address for the contact e.g. "JohnDoe@PhoneWorld.com"
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_EMAIL2 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 33 ); 
// 
// WPD_CONTACT_BUSINESS_EMAIL 
//   [ VT_LPWSTR ] Indicates the business email address for the contact e.g. "JohnDoe@PhoneCompany.com"
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_EMAIL , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 34 ); 
// 
// WPD_CONTACT_BUSINESS_EMAIL2 
//   [ VT_LPWSTR ] Indicates an alternate business email address for the contact e.g. "JohnDoe@PhoneCompany.com"
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_EMAIL2 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 35 ); 
// 
// WPD_CONTACT_OTHER_EMAILS 
//   [ VT_UNKNOWN ] An IPortableDevicePropVariantCollection of type VT_LPWSTR, where each element is an alternate email addresses for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_OTHER_EMAILS , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 36 ); 
// 
// WPD_CONTACT_PRIMARY_PHONE 
//   [ VT_LPWSTR ] Indicates the primary phone number for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_PRIMARY_PHONE , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 37 ); 
// 
// WPD_CONTACT_PERSONAL_PHONE 
//   [ VT_LPWSTR ] Indicates the personal phone number for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_PHONE , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 38 ); 
// 
// WPD_CONTACT_PERSONAL_PHONE2 
//   [ VT_LPWSTR ] Indicates an alternate personal phone number for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_PHONE2 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 39 ); 
// 
// WPD_CONTACT_BUSINESS_PHONE 
//   [ VT_LPWSTR ] Indicates the business phone number for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_PHONE , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 40 ); 
// 
// WPD_CONTACT_BUSINESS_PHONE2 
//   [ VT_LPWSTR ] Indicates an alternate business phone number for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_PHONE2 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 41 ); 
// 
// WPD_CONTACT_MOBILE_PHONE 
//   [ VT_LPWSTR ] Indicates the mobile phone number for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_MOBILE_PHONE , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 42 ); 
// 
// WPD_CONTACT_MOBILE_PHONE2 
//   [ VT_LPWSTR ] Indicates an alternate mobile phone number for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_MOBILE_PHONE2 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 43 ); 
// 
// WPD_CONTACT_PERSONAL_FAX 
//   [ VT_LPWSTR ] Indicates the personal fax number for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_FAX , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 44 ); 
// 
// WPD_CONTACT_BUSINESS_FAX 
//   [ VT_LPWSTR ] Indicates the business fax number for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_FAX , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 45 ); 
// 
// WPD_CONTACT_PAGER 
//   [ VT_LPWSTR ] Indicates the pager number for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_PAGER , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 46 ); 
// 
// WPD_CONTACT_OTHER_PHONES 
//   [ VT_UNKNOWN ] An IPortableDevicePropVariantCollection of type VT_LPWSTR, where each element is an alternate phone number for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_OTHER_PHONES , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 47 ); 
// 
// WPD_CONTACT_PRIMARY_WEB_ADDRESS 
//   [ VT_LPWSTR ] Indicates the primary web address for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_PRIMARY_WEB_ADDRESS , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 48 ); 
// 
// WPD_CONTACT_PERSONAL_WEB_ADDRESS 
//   [ VT_LPWSTR ] Indicates the personal web address for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_WEB_ADDRESS , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 49 ); 
// 
// WPD_CONTACT_BUSINESS_WEB_ADDRESS 
//   [ VT_LPWSTR ] Indicates the business web address for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_WEB_ADDRESS , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 50 ); 
// 
// WPD_CONTACT_INSTANT_MESSENGER 
//   [ VT_LPWSTR ] Indicates the instant messenger address for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_INSTANT_MESSENGER , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 51 ); 
// 
// WPD_CONTACT_INSTANT_MESSENGER2 
//   [ VT_LPWSTR ] Indicates an alternate instant messenger address for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_INSTANT_MESSENGER2 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 52 ); 
// 
// WPD_CONTACT_INSTANT_MESSENGER3 
//   [ VT_LPWSTR ] Indicates an alternate instant messenger address for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_INSTANT_MESSENGER3 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 53 ); 
// 
// WPD_CONTACT_COMPANY_NAME 
//   [ VT_LPWSTR ] Indicates the company name for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_COMPANY_NAME , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 54 ); 
// 
// WPD_CONTACT_PHONETIC_COMPANY_NAME 
//   [ VT_LPWSTR ] The phonetic guide for pronouncing the contact's company name. 
DEFINE_PROPERTYKEY( WPD_CONTACT_PHONETIC_COMPANY_NAME , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 55 ); 
// 
// WPD_CONTACT_ROLE 
//   [ VT_LPWSTR ] Indicates the role for the contact e.g. "Software Engineer". 
DEFINE_PROPERTYKEY( WPD_CONTACT_ROLE , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 56 ); 
// 
// WPD_CONTACT_BIRTHDATE 
//   [ VT_DATE ] Indicates the birthdate for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_BIRTHDATE , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 57 ); 
// 
// WPD_CONTACT_PRIMARY_FAX 
//   [ VT_LPWSTR ] Indicates the primary fax number for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_PRIMARY_FAX , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 58 ); 
// 
// WPD_CONTACT_SPOUSE 
//   [ VT_LPWSTR ] Indicates the full name of the spouse for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_SPOUSE , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 59 ); 
// 
// WPD_CONTACT_CHILDREN 
//   [ VT_UNKNOWN ] An IPortableDevicePropVariantCollection of type VT_LPWSTR, where each element is the full name of a child of the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_CHILDREN , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 60 ); 
// 
// WPD_CONTACT_ASSISTANT 
//   [ VT_LPWSTR ] Indicates the full name of the assistant for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_ASSISTANT , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 61 ); 
// 
// WPD_CONTACT_ANNIVERSARY_DATE 
//   [ VT_DATE ] Indicates the anniversary date for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_ANNIVERSARY_DATE , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 62 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_MUSIC_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all music objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_MUSIC_OBJECT_PROPERTIES_V1 , 0xB324F56A, 0xDC5D, 0x46E5, 0xB6, 0xDF, 0xD2, 0xEA, 0x41, 0x48, 0x88, 0xC6 ); 

// 
// WPD_MUSIC_ALBUM 
//   [ VT_LPWSTR ] Indicates the album of the music file. 
DEFINE_PROPERTYKEY( WPD_MUSIC_ALBUM , 0xB324F56A, 0xDC5D, 0x46E5, 0xB6, 0xDF, 0xD2, 0xEA, 0x41, 0x48, 0x88, 0xC6 , 3 ); 
// 
// WPD_MUSIC_TRACK 
//   [ VT_UI4 ] Indicates the track number for the music file. 
DEFINE_PROPERTYKEY( WPD_MUSIC_TRACK , 0xB324F56A, 0xDC5D, 0x46E5, 0xB6, 0xDF, 0xD2, 0xEA, 0x41, 0x48, 0x88, 0xC6 , 4 ); 
// 
// WPD_MUSIC_LYRICS 
//   [ VT_LPWSTR ] Indicates the lyrics for the music file. 
DEFINE_PROPERTYKEY( WPD_MUSIC_LYRICS , 0xB324F56A, 0xDC5D, 0x46E5, 0xB6, 0xDF, 0xD2, 0xEA, 0x41, 0x48, 0x88, 0xC6 , 6 ); 
// 
// WPD_MUSIC_MOOD 
//   [ VT_LPWSTR ] Indicates the mood for the music file. 
DEFINE_PROPERTYKEY( WPD_MUSIC_MOOD , 0xB324F56A, 0xDC5D, 0x46E5, 0xB6, 0xDF, 0xD2, 0xEA, 0x41, 0x48, 0x88, 0xC6 , 8 ); 
// 
// WPD_AUDIO_BITRATE 
//   [ VT_UI4 ] Indicates the bit rate for the audio data, specified in bits per second. 
DEFINE_PROPERTYKEY( WPD_AUDIO_BITRATE , 0xB324F56A, 0xDC5D, 0x46E5, 0xB6, 0xDF, 0xD2, 0xEA, 0x41, 0x48, 0x88, 0xC6 , 9 ); 
// 
// WPD_AUDIO_CHANNEL_COUNT 
//   [ VT_R4 ] Indicates the number of channels in this audio file e.g. 1, 2, 5.1 etc. 
DEFINE_PROPERTYKEY( WPD_AUDIO_CHANNEL_COUNT , 0xB324F56A, 0xDC5D, 0x46E5, 0xB6, 0xDF, 0xD2, 0xEA, 0x41, 0x48, 0x88, 0xC6 , 10 ); 
// 
// WPD_AUDIO_FORMAT_CODE 
//   [ VT_UI4 ] Indicates the registered WAVE format code. 
DEFINE_PROPERTYKEY( WPD_AUDIO_FORMAT_CODE , 0xB324F56A, 0xDC5D, 0x46E5, 0xB6, 0xDF, 0xD2, 0xEA, 0x41, 0x48, 0x88, 0xC6 , 11 ); 
// 
// WPD_AUDIO_BIT_DEPTH 
//   [ VT_UI4 ] This property identifies the bit-depth of the audio. 
DEFINE_PROPERTYKEY( WPD_AUDIO_BIT_DEPTH , 0xB324F56A, 0xDC5D, 0x46E5, 0xB6, 0xDF, 0xD2, 0xEA, 0x41, 0x48, 0x88, 0xC6 , 12 ); 
// 
// WPD_AUDIO_BLOCK_ALIGNMENT 
//   [ VT_UI4 ] TBD 
DEFINE_PROPERTYKEY( WPD_AUDIO_BLOCK_ALIGNMENT , 0xB324F56A, 0xDC5D, 0x46E5, 0xB6, 0xDF, 0xD2, 0xEA, 0x41, 0x48, 0x88, 0xC6 , 13 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_VIDEO_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all video objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_VIDEO_OBJECT_PROPERTIES_V1 , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A ); 

// 
// WPD_VIDEO_AUTHOR 
//   [ VT_LPWSTR ] Indicates the author of the video file. 
DEFINE_PROPERTYKEY( WPD_VIDEO_AUTHOR , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A , 2 ); 
// 
// WPD_VIDEO_RECORDEDTV_STATION_NAME 
//   [ VT_LPWSTR ] Indicates the TV station the video was recorded from. 
DEFINE_PROPERTYKEY( WPD_VIDEO_RECORDEDTV_STATION_NAME , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A , 4 ); 
// 
// WPD_VIDEO_RECORDEDTV_CHANNEL_NUMBER 
//   [ VT_UI4 ] Indicates the TV channel number the video was recorded from. 
DEFINE_PROPERTYKEY( WPD_VIDEO_RECORDEDTV_CHANNEL_NUMBER , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A , 5 ); 
// 
// WPD_VIDEO_RECORDEDTV_REPEAT 
//   [ VT_BOOL ] Indicates whether the recorded TV program was a repeat showing. 
DEFINE_PROPERTYKEY( WPD_VIDEO_RECORDEDTV_REPEAT , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A , 7 ); 
// 
// WPD_VIDEO_BUFFER_SIZE 
//   [ VT_UI4 ] Indicates the video buffer size. 
DEFINE_PROPERTYKEY( WPD_VIDEO_BUFFER_SIZE , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A , 8 ); 
// 
// WPD_VIDEO_CREDITS 
//   [ VT_LPWSTR ] Indicates the credit text for the video file. 
DEFINE_PROPERTYKEY( WPD_VIDEO_CREDITS , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A , 9 ); 
// 
// WPD_VIDEO_KEY_FRAME_DISTANCE 
//   [ VT_UI4 ] Indicates the interval between key frames in milliseconds. 
DEFINE_PROPERTYKEY( WPD_VIDEO_KEY_FRAME_DISTANCE , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A , 10 ); 
// 
// WPD_VIDEO_QUALITY_SETTING 
//   [ VT_UI4 ] Indicates the quality setting for the video file. 
DEFINE_PROPERTYKEY( WPD_VIDEO_QUALITY_SETTING , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A , 11 ); 
// 
// WPD_VIDEO_SCAN_TYPE 
//   [ VT_UI4 ] This property identifies the video scan information. 
DEFINE_PROPERTYKEY( WPD_VIDEO_SCAN_TYPE , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A , 12 ); 
// 
// WPD_VIDEO_BITRATE 
//   [ VT_UI4 ] Indicates the bitrate for the video data. 
DEFINE_PROPERTYKEY( WPD_VIDEO_BITRATE , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A , 13 ); 
// 
// WPD_VIDEO_FOURCC_CODE 
//   [ VT_DWORD ] The registered FourCC code indicating the codec used for the video file. 
DEFINE_PROPERTYKEY( WPD_VIDEO_FOURCC_CODE , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A , 14 ); 
// 
// WPD_VIDEO_FRAMERATE 
//   [ VT_UI4 ] Indicates the frame rate for the video data. 
DEFINE_PROPERTYKEY( WPD_VIDEO_FRAMERATE , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A , 15 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_COMMON_INFORMATION_OBJECT_PROPERTIES_V1 
* 
* This category is properties that pertain to informational objects such as appointments, tasks, memos and even documents. 
****************************************************************************/ 
DEFINE_GUID( WPD_COMMON_INFORMATION_OBJECT_PROPERTIES_V1 , 0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F ); 

// 
// WPD_COMMON_INFORMATION_SUBJECT 
//   [ VT_LPWSTR ] Indicates the subject field of this object. 
DEFINE_PROPERTYKEY( WPD_COMMON_INFORMATION_SUBJECT , 0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F , 2 ); 
// 
// WPD_COMMON_INFORMATION_BODY_TEXT 
//   [ VT_LPWSTR ] This property contains the body text of an object, in plaintext or HTML format. 
DEFINE_PROPERTYKEY( WPD_COMMON_INFORMATION_BODY_TEXT , 0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F , 3 ); 
// 
// WPD_COMMON_INFORMATION_PRIORITY 
//   [ VT_UI4 ] Indicates the priority of this object. 
DEFINE_PROPERTYKEY( WPD_COMMON_INFORMATION_PRIORITY , 0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F , 4 ); 
// 
// WPD_COMMON_INFORMATION_START_DATETIME 
//   [ VT_DATE ] For appointments, tasks and similar objects, this indicates the date/time that this item is scheduled to start. 
DEFINE_PROPERTYKEY( WPD_COMMON_INFORMATION_START_DATETIME , 0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F , 5 ); 
// 
// WPD_COMMON_INFORMATION_END_DATETIME 
//   [ VT_DATE ] For appointments, tasks and similar objects, this indicates the date/time that this item is scheduled to end. 
DEFINE_PROPERTYKEY( WPD_COMMON_INFORMATION_END_DATETIME , 0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F , 6 ); 
// 
// WPD_COMMON_INFORMATION_NOTES 
//   [ VT_LPWSTR ] For appointments, tasks and similar objects, this indicates any notes for this object. 
DEFINE_PROPERTYKEY( WPD_COMMON_INFORMATION_NOTES , 0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F , 7); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_MEMO_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all memo objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_MEMO_OBJECT_PROPERTIES_V1 , 0x5FFBFC7B, 0x7483, 0x41AD, 0xAF, 0xB9, 0xDA, 0x3F, 0x4E, 0x59, 0x2B, 0x8D ); 


/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_EMAIL_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all email objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_EMAIL_OBJECT_PROPERTIES_V1 , 0x41F8F65A, 0x5484, 0x4782, 0xB1, 0x3D, 0x47, 0x40, 0xDD, 0x7C, 0x37, 0xC5 ); 

// 
// WPD_EMAIL_TO_LINE 
//   [ VT_LPWSTR ] Indicates the normal recipients for the message. 
DEFINE_PROPERTYKEY( WPD_EMAIL_TO_LINE , 0x41F8F65A, 0x5484, 0x4782, 0xB1, 0x3D, 0x47, 0x40, 0xDD, 0x7C, 0x37, 0xC5 , 2 ); 
// 
// WPD_EMAIL_CC_LINE 
//   [ VT_LPWSTR ] Indicates the copied recipients for the message. 
DEFINE_PROPERTYKEY( WPD_EMAIL_CC_LINE , 0x41F8F65A, 0x5484, 0x4782, 0xB1, 0x3D, 0x47, 0x40, 0xDD, 0x7C, 0x37, 0xC5 , 3 ); 
// 
// WPD_EMAIL_BCC_LINE 
//   [ VT_LPWSTR ] Indicates the recipients for the message who receive a "blind copy". 
DEFINE_PROPERTYKEY( WPD_EMAIL_BCC_LINE , 0x41F8F65A, 0x5484, 0x4782, 0xB1, 0x3D, 0x47, 0x40, 0xDD, 0x7C, 0x37, 0xC5 , 4 ); 
// 
// WPD_EMAIL_HAS_BEEN_READ 
//   [ VT_BOOL ] Indicates whether the user has read this message. 
DEFINE_PROPERTYKEY( WPD_EMAIL_HAS_BEEN_READ , 0x41F8F65A, 0x5484, 0x4782, 0xB1, 0x3D, 0x47, 0x40, 0xDD, 0x7C, 0x37, 0xC5 , 7 ); 
// 
// WPD_EMAIL_RECEIVED_TIME 
//   [ VT_DATE ] Indicates at what time the message was received. 
DEFINE_PROPERTYKEY( WPD_EMAIL_RECEIVED_TIME , 0x41F8F65A, 0x5484, 0x4782, 0xB1, 0x3D, 0x47, 0x40, 0xDD, 0x7C, 0x37, 0xC5 , 8 ); 
// 
// WPD_EMAIL_HAS_ATTACHMENTS 
//   [ VT_BOOL ] Indicates whether this message has attachments. 
DEFINE_PROPERTYKEY( WPD_EMAIL_HAS_ATTACHMENTS , 0x41F8F65A, 0x5484, 0x4782, 0xB1, 0x3D, 0x47, 0x40, 0xDD, 0x7C, 0x37, 0xC5 , 9 ); 
// 
// WPD_EMAIL_SENDER_ADDRESS 
//   [ VT_LPWSTR ] Indicates who sent the message. 
DEFINE_PROPERTYKEY( WPD_EMAIL_SENDER_ADDRESS , 0x41F8F65A, 0x5484, 0x4782, 0xB1, 0x3D, 0x47, 0x40, 0xDD, 0x7C, 0x37, 0xC5 , 10 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_APPOINTMENT_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all appointment objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_APPOINTMENT_OBJECT_PROPERTIES_V1 , 0xF99EFD03, 0x431D, 0x40D8, 0xA1, 0xC9, 0x4E, 0x22, 0x0D, 0x9C, 0x88, 0xD3 ); 

// 
// WPD_APPOINTMENT_LOCATION 
//   [ VT_LPWSTR ] Indicates the location of the appointment e.g. "Building 5, Conf. room 7". 
DEFINE_PROPERTYKEY( WPD_APPOINTMENT_LOCATION , 0xF99EFD03, 0x431D, 0x40D8, 0xA1, 0xC9, 0x4E, 0x22, 0x0D, 0x9C, 0x88, 0xD3 , 3 ); 
// 
// WPD_APPOINTMENT_TYPE 
//   [ VT_LPWSTR ] Indicates the type of appointment e.g. "Personal", "Business" etc. 
DEFINE_PROPERTYKEY( WPD_APPOINTMENT_TYPE , 0xF99EFD03, 0x431D, 0x40D8, 0xA1, 0xC9, 0x4E, 0x22, 0x0D, 0x9C, 0x88, 0xD3 , 7 ); 
// 
// WPD_APPOINTMENT_REQUIRED_ATTENDEES 
//   [ VT_LPWSTR ] Semi-colon separated list of required attendees. 
DEFINE_PROPERTYKEY( WPD_APPOINTMENT_REQUIRED_ATTENDEES , 0xF99EFD03, 0x431D, 0x40D8, 0xA1, 0xC9, 0x4E, 0x22, 0x0D, 0x9C, 0x88, 0xD3 , 8 ); 
// 
// WPD_APPOINTMENT_OPTIONAL_ATTENDEES 
//   [ VT_LPWSTR ] Semi-colon separated list of optional attendees. 
DEFINE_PROPERTYKEY( WPD_APPOINTMENT_OPTIONAL_ATTENDEES , 0xF99EFD03, 0x431D, 0x40D8, 0xA1, 0xC9, 0x4E, 0x22, 0x0D, 0x9C, 0x88, 0xD3 , 9 ); 
// 
// WPD_APPOINTMENT_ACCEPTED_ATTENDEES 
//   [ VT_LPWSTR ] Semi-colon separated list of attendees who have accepted the appointment. 
DEFINE_PROPERTYKEY( WPD_APPOINTMENT_ACCEPTED_ATTENDEES , 0xF99EFD03, 0x431D, 0x40D8, 0xA1, 0xC9, 0x4E, 0x22, 0x0D, 0x9C, 0x88, 0xD3 , 10 ); 
// 
// WPD_APPOINTMENT_RESOURCES 
//   [ VT_LPWSTR ] Semi-colon separated list of resources needed for the appointment. 
DEFINE_PROPERTYKEY( WPD_APPOINTMENT_RESOURCES , 0xF99EFD03, 0x431D, 0x40D8, 0xA1, 0xC9, 0x4E, 0x22, 0x0D, 0x9C, 0x88, 0xD3 , 11 ); 
// 
// WPD_APPOINTMENT_TENTATIVE_ATTENDEES 
//   [ VT_LPWSTR ] Semi-colon separated list of attendees who have tentatively accepted the appointment. 
DEFINE_PROPERTYKEY( WPD_APPOINTMENT_TENTATIVE_ATTENDEES , 0xF99EFD03, 0x431D, 0x40D8, 0xA1, 0xC9, 0x4E, 0x22, 0x0D, 0x9C, 0x88, 0xD3 , 12 ); 
// 
// WPD_APPOINTMENT_DECLINED_ATTENDEES 
//   [ VT_LPWSTR ] Semi-colon separated list of attendees who have declined the appointment. 
DEFINE_PROPERTYKEY( WPD_APPOINTMENT_DECLINED_ATTENDEES , 0xF99EFD03, 0x431D, 0x40D8, 0xA1, 0xC9, 0x4E, 0x22, 0x0D, 0x9C, 0x88, 0xD3 , 13 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_TASK_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all task objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_TASK_OBJECT_PROPERTIES_V1 , 0xE354E95E, 0xD8A0, 0x4637, 0xA0, 0x3A, 0x0C, 0xB2, 0x68, 0x38, 0xDB, 0xC7 ); 

// 
// WPD_TASK_STATUS 
//   [ VT_LPWSTR ] Indicates the status of the task e.g. "In Progress". 
DEFINE_PROPERTYKEY( WPD_TASK_STATUS , 0xE354E95E, 0xD8A0, 0x4637, 0xA0, 0x3A, 0x0C, 0xB2, 0x68, 0x38, 0xDB, 0xC7 , 6 ); 
// 
// WPD_TASK_PERCENT_COMPLETE 
//   [ VT_UI4 ] Indicates how much of the task has been completed. 
DEFINE_PROPERTYKEY( WPD_TASK_PERCENT_COMPLETE , 0xE354E95E, 0xD8A0, 0x4637, 0xA0, 0x3A, 0x0C, 0xB2, 0x68, 0x38, 0xDB, 0xC7 , 8 ); 
// 
// WPD_TASK_REMINDER_DATE 
//   [ VT_DATE ] Indicates the date and time set for the reminder. If this value is 0, then it is assumed that this task has no reminder. 
DEFINE_PROPERTYKEY( WPD_TASK_REMINDER_DATE , 0xE354E95E, 0xD8A0, 0x4637, 0xA0, 0x3A, 0x0C, 0xB2, 0x68, 0x38, 0xDB, 0xC7 , 10 ); 
// 
// WPD_TASK_OWNER 
//   [ VT_LPWSTR ] Indicates the owner of the task. 
DEFINE_PROPERTYKEY( WPD_TASK_OWNER , 0xE354E95E, 0xD8A0, 0x4637, 0xA0, 0x3A, 0x0C, 0xB2, 0x68, 0x38, 0xDB, 0xC7 , 11 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_STORAGE_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all objects whose functional category is WPD_FUNCTIONAL_CATEGORY_STORAGE. 
****************************************************************************/ 
DEFINE_GUID( WPD_STORAGE_OBJECT_PROPERTIES_V1 , 0x01A3057A, 0x74D6, 0x4E80, 0xBE, 0xA7, 0xDC, 0x4C, 0x21, 0x2C, 0xE5, 0x0A ); 

// 
// WPD_STORAGE_TYPE 
//   [ VT_UI4 ] Indicates the type of storage e.g. fixed, removable etc. 
DEFINE_PROPERTYKEY( WPD_STORAGE_TYPE , 0x01A3057A, 0x74D6, 0x4E80, 0xBE, 0xA7, 0xDC, 0x4C, 0x21, 0x2C, 0xE5, 0x0A , 2 ); 
// 
// WPD_STORAGE_FILE_SYSTEM_TYPE 
//   [ VT_LPWSTR ] Indicates the file system type e.g. "FAT32" or "NTFS" or "My Special File System" 
DEFINE_PROPERTYKEY( WPD_STORAGE_FILE_SYSTEM_TYPE , 0x01A3057A, 0x74D6, 0x4E80, 0xBE, 0xA7, 0xDC, 0x4C, 0x21, 0x2C, 0xE5, 0x0A , 3 ); 
// 
// WPD_STORAGE_CAPACITY 
//   [ VT_UI8 ] Indicates the total storage capacity in bytes. 
DEFINE_PROPERTYKEY( WPD_STORAGE_CAPACITY , 0x01A3057A, 0x74D6, 0x4E80, 0xBE, 0xA7, 0xDC, 0x4C, 0x21, 0x2C, 0xE5, 0x0A , 4 ); 
// 
// WPD_STORAGE_FREE_SPACE_IN_BYTES 
//   [ VT_UI8 ] Indicates the available space in bytes. 
DEFINE_PROPERTYKEY( WPD_STORAGE_FREE_SPACE_IN_BYTES , 0x01A3057A, 0x74D6, 0x4E80, 0xBE, 0xA7, 0xDC, 0x4C, 0x21, 0x2C, 0xE5, 0x0A , 5 ); 
// 
// WPD_STORAGE_FREE_SPACE_IN_OBJECTS 
//   [ VT_UI8 ] Indicates the available space in objects e.g. available slots on a SIM card. 
DEFINE_PROPERTYKEY( WPD_STORAGE_FREE_SPACE_IN_OBJECTS , 0x01A3057A, 0x74D6, 0x4E80, 0xBE, 0xA7, 0xDC, 0x4C, 0x21, 0x2C, 0xE5, 0x0A , 6 ); 
// 
// WPD_STORAGE_DESCRIPTION 
//   [ VT_LPWSTR ] Contains a description of the storage. 
DEFINE_PROPERTYKEY( WPD_STORAGE_DESCRIPTION , 0x01A3057A, 0x74D6, 0x4E80, 0xBE, 0xA7, 0xDC, 0x4C, 0x21, 0x2C, 0xE5, 0x0A , 7 ); 
// 
// WPD_STORAGE_SERIAL_NUMBER 
//   [ VT_LPWSTR ] Contains the serial number of the storage. 
DEFINE_PROPERTYKEY( WPD_STORAGE_SERIAL_NUMBER , 0x01A3057A, 0x74D6, 0x4E80, 0xBE, 0xA7, 0xDC, 0x4C, 0x21, 0x2C, 0xE5, 0x0A , 8 ); 
// 
// WPD_STORAGE_MAX_OBJECT_SIZE 
//   [ VT_UI8 ] Specifies the maximum size of a single object (in bytes) that can be placed on this storage. 
DEFINE_PROPERTYKEY( WPD_STORAGE_MAX_OBJECT_SIZE , 0x01A3057A, 0x74D6, 0x4E80, 0xBE, 0xA7, 0xDC, 0x4C, 0x21, 0x2C, 0xE5, 0x0A , 9 ); 
// 
// WPD_STORAGE_CAPACITY_IN_OBJECTS 
//   [ VT_UI8 ] Indicates the total storage capacity in objects e.g. available slots on a SIM card. 
DEFINE_PROPERTYKEY( WPD_STORAGE_CAPACITY_IN_OBJECTS , 0x01A3057A, 0x74D6, 0x4E80, 0xBE, 0xA7, 0xDC, 0x4C, 0x21, 0x2C, 0xE5, 0x0A , 10 ); 
// 
// WPD_STORAGE_ACCESS_CAPABILITY 
//   [ VT_UI4 ] This property identifies any write-protection that globally affects this storage. This takes precedence over access specified on individual objects. 
DEFINE_PROPERTYKEY( WPD_STORAGE_ACCESS_CAPABILITY , 0x01A3057A, 0x74D6, 0x4E80, 0xBE, 0xA7, 0xDC, 0x4C, 0x21, 0x2C, 0xE5, 0x0A , 11 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_NETWORK_ASSOCIATION_PROPERTIES_V1 
* 
* This category is for properties common to all network association objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_NETWORK_ASSOCIATION_PROPERTIES_V1 , 0xE4C93C1F, 0xB203, 0x43F1, 0xA1, 0x00, 0x5A, 0x07, 0xD1, 0x1B, 0x02, 0x74 ); 

// 
// WPD_NETWORK_ASSOCIATION_HOST_NETWORK_IDENTIFIERS 
//   [ VT_VECTOR | VT_UI1 ] The list of EUI-64 host identifiers valid for this association. 
DEFINE_PROPERTYKEY( WPD_NETWORK_ASSOCIATION_HOST_NETWORK_IDENTIFIERS , 0xE4C93C1F, 0xB203, 0x43F1, 0xA1, 0x00, 0x5A, 0x07, 0xD1, 0x1B, 0x02, 0x74 , 2 ); 
// 
// WPD_NETWORK_ASSOCIATION_X509V3SEQUENCE 
//   [ VT_VECTOR | VT_UI1 ] The sequence of X.509 v3 certificates to be provided for TLS server authentication. 
DEFINE_PROPERTYKEY( WPD_NETWORK_ASSOCIATION_X509V3SEQUENCE , 0xE4C93C1F, 0xB203, 0x43F1, 0xA1, 0x00, 0x5A, 0x07, 0xD1, 0x1B, 0x02, 0x74 , 3 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_STILL_IMAGE_CAPTURE_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all objects whose functional category is WPD_FUNCTIONAL_CATEGORY_STILL_IMAGE_CAPTURE 
****************************************************************************/ 
DEFINE_GUID( WPD_STILL_IMAGE_CAPTURE_OBJECT_PROPERTIES_V1 , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 ); 

// 
// WPD_STILL_IMAGE_CAPTURE_RESOLUTION 
//   [ VT_LPWSTR ] Controls the size of the image dimensions to capture in pixel width and height. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_CAPTURE_RESOLUTION , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 2 ); 
// 
// WPD_STILL_IMAGE_CAPTURE_FORMAT 
//   [ VT_CLSID ] Controls the format of the image to capture. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_CAPTURE_FORMAT , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 3 ); 
// 
// WPD_STILL_IMAGE_COMPRESSION_SETTING 
//   [ VT_UI8 ] Controls the device-specific quality setting. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_COMPRESSION_SETTING , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 4 ); 
// 
// WPD_STILL_IMAGE_WHITE_BALANCE 
//   [ VT_UI4 ] Controls how the device weights color channels. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_WHITE_BALANCE , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 5 ); 
// 
// WPD_STILL_IMAGE_RGB_GAIN 
//   [ VT_LPWSTR ] Controls the RGB gain. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_RGB_GAIN , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 6 ); 
// 
// WPD_STILL_IMAGE_FNUMBER 
//   [ VT_UI4 ] Controls the aperture of the lens. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_FNUMBER , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 7 ); 
// 
// WPD_STILL_IMAGE_FOCAL_LENGTH 
//   [ VT_UI4 ] Controls the 35mm equivalent focal length. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_FOCAL_LENGTH , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 8 ); 
// 
// WPD_STILL_IMAGE_FOCUS_DISTANCE 
//   [ VT_UI4 ] This property corresponds to the focus distance in millimeters 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_FOCUS_DISTANCE , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 9 ); 
// 
// WPD_STILL_IMAGE_FOCUS_MODE 
//   [ VT_UI4 ] Identifies the focusing mode used by the device for image capture. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_FOCUS_MODE , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 10 ); 
// 
// WPD_STILL_IMAGE_EXPOSURE_METERING_MODE 
//   [ VT_UI4 ] Identifies the exposure metering mode used by the device for image capture. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_EXPOSURE_METERING_MODE , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 11 ); 
// 
// WPD_STILL_IMAGE_FLASH_MODE 
//   [ VT_UI4 ] 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_FLASH_MODE , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 12 ); 
// 
// WPD_STILL_IMAGE_EXPOSURE_TIME 
//   [ VT_UI4 ] Controls the shutter speed of the device. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_EXPOSURE_TIME , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 13 ); 
// 
// WPD_STILL_IMAGE_EXPOSURE_PROGRAM_MODE 
//   [ VT_UI4 ] Controls the exposure program mode of the device. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_EXPOSURE_PROGRAM_MODE , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 14 ); 
// 
// WPD_STILL_IMAGE_EXPOSURE_INDEX 
//   [ VT_UI4 ] Controls the emulation of film speed settings. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_EXPOSURE_INDEX , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 15 ); 
// 
// WPD_STILL_IMAGE_EXPOSURE_BIAS_COMPENSATION 
//   [ VT_I4 ] Controls the adjustment of the auto exposure control. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_EXPOSURE_BIAS_COMPENSATION , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 16 ); 
// 
// WPD_STILL_IMAGE_CAPTURE_DELAY 
//   [ VT_UI4 ] Controls the amount of time delay between the capture trigger and the actual data capture (in milliseconds). 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_CAPTURE_DELAY , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 17 ); 
// 
// WPD_STILL_IMAGE_CAPTURE_MODE 
//   [ VT_UI4 ] Controls the type of still image capture. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_CAPTURE_MODE , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 18 ); 
// 
// WPD_STILL_IMAGE_CONTRAST 
//   [ VT_UI4 ] Controls the perceived contrast of captured images. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_CONTRAST , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 19 ); 
// 
// WPD_STILL_IMAGE_SHARPNESS 
//   [ VT_UI4 ] Controls the perceived sharpness of the captured image. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_SHARPNESS , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 20 ); 
// 
// WPD_STILL_IMAGE_DIGITAL_ZOOM 
//   [ VT_UI4 ] Controls the effective zoom ratio of a digital camera's acquired image scaled by a factor of 10. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_DIGITAL_ZOOM , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 21 ); 
// 
// WPD_STILL_IMAGE_EFFECT_MODE 
//   [ VT_UI4 ] Controls the special effect mode of the capture. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_EFFECT_MODE , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 22 ); 
// 
// WPD_STILL_IMAGE_BURST_NUMBER 
//   [ VT_UI4 ] Controls the number of images that the device will attempt to capture upon initiation of a burst operation. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_BURST_NUMBER , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 23 ); 
// 
// WPD_STILL_IMAGE_BURST_INTERVAL 
//   [ VT_UI4 ] Controls the time delay between captures upon initiation of a burst operation. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_BURST_INTERVAL , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 24 ); 
// 
// WPD_STILL_IMAGE_TIMELAPSE_NUMBER 
//   [ VT_UI4 ] Controls the number of images that the device will attempt to capture upon initiation of a time-lapse capture. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_TIMELAPSE_NUMBER , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 25 ); 
// 
// WPD_STILL_IMAGE_TIMELAPSE_INTERVAL 
//   [ VT_UI4 ] Controls the time delay between captures upon initiation of a time-lapse operation. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_TIMELAPSE_INTERVAL , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 26 ); 
// 
// WPD_STILL_IMAGE_FOCUS_METERING_MODE 
//   [ VT_UI4 ] Controls which automatic focus mechanism is used by the device. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_FOCUS_METERING_MODE , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 27 ); 
// 
// WPD_STILL_IMAGE_UPLOAD_URL 
//   [ VT_LPWSTR ] Used to describe the URL that the device may use to upload images upon capture. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_UPLOAD_URL , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 28 ); 
// 
// WPD_STILL_IMAGE_ARTIST 
//   [ VT_LPWSTR ] Contains the owner/user of the device, which may be inserted as meta-data into any images that are captured. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_ARTIST , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 29 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_SMS_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all objects whose functional category is WPD_FUNCTIONAL_CATEGORY_SMS 
****************************************************************************/ 
DEFINE_GUID( WPD_SMS_OBJECT_PROPERTIES_V1 , 0x7E1074CC, 0x50FF, 0x4DD1, 0xA7, 0x42, 0x53, 0xBE, 0x6F, 0x09, 0x3A, 0x0D ); 

// 
// WPD_SMS_PROVIDER 
//   [ VT_LPWSTR ] Indicates the service provider name. 
DEFINE_PROPERTYKEY( WPD_SMS_PROVIDER , 0x7E1074CC, 0x50FF, 0x4DD1, 0xA7, 0x42, 0x53, 0xBE, 0x6F, 0x09, 0x3A, 0x0D , 2 ); 
// 
// WPD_SMS_TIMEOUT 
//   [ VT_UI4 ] Indicates the number of milliseconds until a timeout is returned. 
DEFINE_PROPERTYKEY( WPD_SMS_TIMEOUT , 0x7E1074CC, 0x50FF, 0x4DD1, 0xA7, 0x42, 0x53, 0xBE, 0x6F, 0x09, 0x3A, 0x0D , 3 ); 
// 
// WPD_SMS_MAX_PAYLOAD 
//   [ VT_UI4 ] Indicates the maximum number of bytes that can be contained in a message. 
DEFINE_PROPERTYKEY( WPD_SMS_MAX_PAYLOAD , 0x7E1074CC, 0x50FF, 0x4DD1, 0xA7, 0x42, 0x53, 0xBE, 0x6F, 0x09, 0x3A, 0x0D , 4 ); 
// 
// WPD_SMS_ENCODING 
//   [ VT_UI4 ] Indicates how the driver will encode the text message sent by the client. 
DEFINE_PROPERTYKEY( WPD_SMS_ENCODING , 0x7E1074CC, 0x50FF, 0x4DD1, 0xA7, 0x42, 0x53, 0xBE, 0x6F, 0x09, 0x3A, 0x0D , 5 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_SECTION_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all objects whose content type is WPD_CONTENT_TYPE_SECTION 
****************************************************************************/ 
DEFINE_GUID( WPD_SECTION_OBJECT_PROPERTIES_V1 , 0x516AFD2B, 0xC64E, 0x44F0, 0x98, 0xDC, 0xBE, 0xE1, 0xC8, 0x8F, 0x7D, 0x66 ); 

// 
// WPD_SECTION_DATA_OFFSET 
//   [ VT_UI8 ] Indicates the zero-based offset of the data for the referenced object. 
DEFINE_PROPERTYKEY( WPD_SECTION_DATA_OFFSET , 0x516AFD2B, 0xC64E, 0x44F0, 0x98, 0xDC, 0xBE, 0xE1, 0xC8, 0x8F, 0x7D, 0x66 , 2 ); 
// 
// WPD_SECTION_DATA_LENGTH 
//   [ VT_UI8 ] Indicates the length of data for the referenced object. 
DEFINE_PROPERTYKEY( WPD_SECTION_DATA_LENGTH , 0x516AFD2B, 0xC64E, 0x44F0, 0x98, 0xDC, 0xBE, 0xE1, 0xC8, 0x8F, 0x7D, 0x66 , 3 ); 
// 
// WPD_SECTION_DATA_UNITS 
//   [ VT_UI4 ] Indicates the units for WPD_SECTION_DATA_OFFSET and WPD_SECTION_DATA_LENGTH properties on this object (e.g. offset in bytes, offset in milliseconds etc.). 
DEFINE_PROPERTYKEY( WPD_SECTION_DATA_UNITS , 0x516AFD2B, 0xC64E, 0x44F0, 0x98, 0xDC, 0xBE, 0xE1, 0xC8, 0x8F, 0x7D, 0x66 , 4 ); 
// 
// WPD_SECTION_DATA_REFERENCED_OBJECT_RESOURCE 
//   [ VT_UNKNOWN ] This is an IPortableDeviceKeyCollection containing a single value, which is the key identifying the resource on the referenced object which the WPD_SECTION_DATA_OFFSET and WPD_SECTION_DATA_LENGTH apply to. 
DEFINE_PROPERTYKEY( WPD_SECTION_DATA_REFERENCED_OBJECT_RESOURCE , 0x516AFD2B, 0xC64E, 0x44F0, 0x98, 0xDC, 0xBE, 0xE1, 0xC8, 0x8F, 0x7D, 0x66 , 5 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_RENDERING_INFORMATION_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all objects whose functional category is WPD_FUNCTIONAL_CATEGORY_AUDIO_RENDERING_INFORMATION 
****************************************************************************/ 
DEFINE_GUID( WPD_RENDERING_INFORMATION_OBJECT_PROPERTIES_V1 , 0xC53D039F, 0xEE23, 0x4A31, 0x85, 0x90, 0x76, 0x39, 0x87, 0x98, 0x70, 0xB4 ); 

// 
// WPD_RENDERING_INFORMATION_PROFILES 
//   [ VT_UNKNOWN ] IPortableDeviceValuesCollection, where each element indicates the property settings for a supported profile. 
DEFINE_PROPERTYKEY( WPD_RENDERING_INFORMATION_PROFILES , 0xC53D039F, 0xEE23, 0x4A31, 0x85, 0x90, 0x76, 0x39, 0x87, 0x98, 0x70, 0xB4 , 2 ); 
// 
// WPD_RENDERING_INFORMATION_PROFILE_ENTRY_TYPE 
//   [ VT_UI4 ] Indicates whether a given entry (i.e. an IPortableDeviceValues) in WPD_RENDERING_INFORMATION_PROFILES relates to an Object or a Resource. 
DEFINE_PROPERTYKEY( WPD_RENDERING_INFORMATION_PROFILE_ENTRY_TYPE , 0xC53D039F, 0xEE23, 0x4A31, 0x85, 0x90, 0x76, 0x39, 0x87, 0x98, 0x70, 0xB4 , 3 ); 
// 
// WPD_RENDERING_INFORMATION_PROFILE_ENTRY_CREATABLE_RESOURCES 
//   [ VT_UNKNOWN ] This is an IPortableDeviceKeyCollection identifying the resources that can be created on an object with this rendering profile. 
DEFINE_PROPERTYKEY( WPD_RENDERING_INFORMATION_PROFILE_ENTRY_CREATABLE_RESOURCES , 0xC53D039F, 0xEE23, 0x4A31, 0x85, 0x90, 0x76, 0x39, 0x87, 0x98, 0x70, 0xB4 , 4 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CLIENT_INFORMATION_PROPERTIES_V1 
* 
* 
****************************************************************************/ 
DEFINE_GUID( WPD_CLIENT_INFORMATION_PROPERTIES_V1 , 0x204D9F0C, 0x2292, 0x4080, 0x9F, 0x42, 0x40, 0x66, 0x4E, 0x70, 0xF8, 0x59 ); 

// 
// WPD_CLIENT_NAME 
//   [ VT_LPWSTR ] Specifies the name the client uses to identify itself. 
DEFINE_PROPERTYKEY( WPD_CLIENT_NAME , 0x204D9F0C, 0x2292, 0x4080, 0x9F, 0x42, 0x40, 0x66, 0x4E, 0x70, 0xF8, 0x59 , 2 ); 
// 
// WPD_CLIENT_MAJOR_VERSION 
//   [ VT_UI4 ] Specifies the major version of the client. 
DEFINE_PROPERTYKEY( WPD_CLIENT_MAJOR_VERSION , 0x204D9F0C, 0x2292, 0x4080, 0x9F, 0x42, 0x40, 0x66, 0x4E, 0x70, 0xF8, 0x59 , 3 ); 
// 
// WPD_CLIENT_MINOR_VERSION 
//   [ VT_UI4 ] Specifies the major version of the client. 
DEFINE_PROPERTYKEY( WPD_CLIENT_MINOR_VERSION , 0x204D9F0C, 0x2292, 0x4080, 0x9F, 0x42, 0x40, 0x66, 0x4E, 0x70, 0xF8, 0x59 , 4 ); 
// 
// WPD_CLIENT_REVISION 
//   [ VT_UI4 ] Specifies the revision (or build number) of the client. 
DEFINE_PROPERTYKEY( WPD_CLIENT_REVISION , 0x204D9F0C, 0x2292, 0x4080, 0x9F, 0x42, 0x40, 0x66, 0x4E, 0x70, 0xF8, 0x59 , 5 ); 
// 
// WPD_CLIENT_WMDRM_APPLICATION_PRIVATE_KEY 
//   [ VT_VECTOR | VT_UI1 ] Specifies the Windows Media DRM application private key of the client. 
DEFINE_PROPERTYKEY( WPD_CLIENT_WMDRM_APPLICATION_PRIVATE_KEY , 0x204D9F0C, 0x2292, 0x4080, 0x9F, 0x42, 0x40, 0x66, 0x4E, 0x70, 0xF8, 0x59 , 6 ); 
// 
// WPD_CLIENT_WMDRM_APPLICATION_CERTIFICATE 
//   [ VT_VECTOR | VT_UI1 ] Specifies the Windows Media DRM application certificate of the client. 
DEFINE_PROPERTYKEY( WPD_CLIENT_WMDRM_APPLICATION_CERTIFICATE , 0x204D9F0C, 0x2292, 0x4080, 0x9F, 0x42, 0x40, 0x66, 0x4E, 0x70, 0xF8, 0x59 , 7 ); 
// 
// WPD_CLIENT_SECURITY_QUALITY_OF_SERVICE 
//   [ VT_UI4 ] Specifies the Security Quality of Service for the connection to the driver. This relates to the Security Quality of Service flags for CreateFile. For example, these allow or disallow a driver to impersonate the client. 
DEFINE_PROPERTYKEY( WPD_CLIENT_SECURITY_QUALITY_OF_SERVICE , 0x204D9F0C, 0x2292, 0x4080, 0x9F, 0x42, 0x40, 0x66, 0x4E, 0x70, 0xF8, 0x59 , 8 ); 
// 
// WPD_CLIENT_DESIRED_ACCESS 
//   [ VT_UI4 ] Specifies the desired access the client is requesting to this driver. The possible values are the same as for CreateFile (e.g. GENERIC_READ, GENERIC_WRITE etc.). 
DEFINE_PROPERTYKEY( WPD_CLIENT_DESIRED_ACCESS , 0x204D9F0C, 0x2292, 0x4080, 0x9F, 0x42, 0x40, 0x66, 0x4E, 0x70, 0xF8, 0x59 , 9 ); 
// 
// WPD_CLIENT_SHARE_MODE 
//   [ VT_UI4 ] Specifies the share mode the client is requesting to this driver. The possible values are the same as for CreateFile (e.g. FILE_SHARE_READ, FILE_SHARE_WRITE etc.). 
DEFINE_PROPERTYKEY( WPD_CLIENT_SHARE_MODE , 0x204D9F0C, 0x2292, 0x4080, 0x9F, 0x42, 0x40, 0x66, 0x4E, 0x70, 0xF8, 0x59 , 10 ); 
// 
// WPD_CLIENT_EVENT_COOKIE 
//   [ VT_LPWSTR ] Client supplied cookie returned by the driver in events posted as a direct result of operations issued by this client. 
DEFINE_PROPERTYKEY( WPD_CLIENT_EVENT_COOKIE , 0x204D9F0C, 0x2292, 0x4080, 0x9F, 0x42, 0x40, 0x66, 0x4E, 0x70, 0xF8, 0x59 , 11 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_PROPERTY_ATTRIBUTES_V1 
* 
* 
****************************************************************************/ 
DEFINE_GUID( WPD_PROPERTY_ATTRIBUTES_V1 , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 ); 

// 
// WPD_PROPERTY_ATTRIBUTE_FORM 
//   [ VT_UI4 ] Specifies the form of the valid values allowed for this property. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_ATTRIBUTE_FORM , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 , 2 ); 
// 
// WPD_PROPERTY_ATTRIBUTE_CAN_READ 
//   [ VT_BOOL ] Indicates whether client applications have permission to Read the property. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_ATTRIBUTE_CAN_READ , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 , 3 ); 
// 
// WPD_PROPERTY_ATTRIBUTE_CAN_WRITE 
//   [ VT_BOOL ] Indicates whether client applications have permission to Write the property. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_ATTRIBUTE_CAN_WRITE , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 , 4 ); 
// 
// WPD_PROPERTY_ATTRIBUTE_CAN_DELETE 
//   [ VT_BOOL ] Indicates whether client applications have permission to Delete the property. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_ATTRIBUTE_CAN_DELETE , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 , 5 ); 
// 
// WPD_PROPERTY_ATTRIBUTE_DEFAULT_VALUE 
//   [ VT_XXXX ] Specifies the default value for a write-able property. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_ATTRIBUTE_DEFAULT_VALUE , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 , 6 ); 
// 
// WPD_PROPERTY_ATTRIBUTE_FAST_PROPERTY 
//   [ VT_BOOL ] If True, then this property belongs to the PORTABLE_DEVICE_FAST_PROPERTIES group.
DEFINE_PROPERTYKEY( WPD_PROPERTY_ATTRIBUTE_FAST_PROPERTY , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 , 7 ); 
// 
// WPD_PROPERTY_ATTRIBUTE_RANGE_MIN 
//   [ VT_XXXX ] The minimum value for a property whose form is of WPD_PROPERTY_ATTRIBUTE_FORM_RANGE.
DEFINE_PROPERTYKEY( WPD_PROPERTY_ATTRIBUTE_RANGE_MIN , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 , 8 ); 
// 
// WPD_PROPERTY_ATTRIBUTE_RANGE_MAX 
//   [ VT_XXXX ] The maximum value for a property whose form is of WPD_PROPERTY_ATTRIBUTE_FORM_RANGE.
DEFINE_PROPERTYKEY( WPD_PROPERTY_ATTRIBUTE_RANGE_MAX , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 , 9 ); 
// 
// WPD_PROPERTY_ATTRIBUTE_RANGE_STEP 
//   [ VT_XXXX ] The step value for a property whose form is of WPD_PROPERTY_ATTRIBUTE_FORM_RANGE.
DEFINE_PROPERTYKEY( WPD_PROPERTY_ATTRIBUTE_RANGE_STEP , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 , 10 ); 
// 
// WPD_PROPERTY_ATTRIBUTE_ENUMERATION_ELEMENTS 
//   [ VT_UNKNOWN ] An IPortableDevicePropVariantCollection containing the enumeration values. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_ATTRIBUTE_ENUMERATION_ELEMENTS , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 , 11 ); 
// 
// WPD_PROPERTY_ATTRIBUTE_REGULAR_EXPRESSION 
//   [ VT_LPWSTR ] A regular expression string indicating acceptable values for properties whose form is WPD_PROPERTY_ATTRIBUTE_FORM_REGULAR_EXPRESSION. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_ATTRIBUTE_REGULAR_EXPRESSION , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 , 12 ); 
// 
// WPD_PROPERTY_ATTRIBUTE_MAX_SIZE 
//   [ VT_UI8 ] This indicates the maximum size (in bytes) for the value of this property. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_ATTRIBUTE_MAX_SIZE , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 , 13 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CLASS_EXTENSION_OPTIONS_V1 
* 
* This category of properties relates to options used for the WPD device class extension 
****************************************************************************/ 
DEFINE_GUID( WPD_CLASS_EXTENSION_OPTIONS_V1 , 0x6309FFEF, 0xA87C, 0x4CA7, 0x84, 0x34, 0x79, 0x75, 0x76, 0xE4, 0x0A, 0x96 ); 

// 
// WPD_CLASS_EXTENSION_OPTIONS_SUPPORTED_CONTENT_TYPES 
//   [ VT_UNKNOWN ] Indicates the (super-set) list of content types supported by the driver (similar to calling WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_CONTENT_TYPES on WPD_FUNCTIONAL_CATEGORY_ALL). 
DEFINE_PROPERTYKEY( WPD_CLASS_EXTENSION_OPTIONS_SUPPORTED_CONTENT_TYPES , 0x6309FFEF, 0xA87C, 0x4CA7, 0x84, 0x34, 0x79, 0x75, 0x76, 0xE4, 0x0A, 0x96 , 2 ); 
// 
// WPD_CLASS_EXTENSION_OPTIONS_DONT_REGISTER_WPD_DEVICE_INTERFACE 
//   [ VT_BOOL ] Indicates that the caller does not want the WPD class extension library to register the WPD Device Class interface. The caller will take responsibility for doing it. 
DEFINE_PROPERTYKEY( WPD_CLASS_EXTENSION_OPTIONS_DONT_REGISTER_WPD_DEVICE_INTERFACE , 0x6309FFEF, 0xA87C, 0x4CA7, 0x84, 0x34, 0x79, 0x75, 0x76, 0xE4, 0x0A, 0x96 , 3 ); 
// 
// WPD_CLASS_EXTENSION_OPTIONS_REGISTER_WPD_PRIVATE_DEVICE_INTERFACE 
//   [ VT_BOOL ] Indicates that the caller wants the WPD class extension library to register the private WPD Device Class interface. 
DEFINE_PROPERTYKEY( WPD_CLASS_EXTENSION_OPTIONS_REGISTER_WPD_PRIVATE_DEVICE_INTERFACE , 0x6309FFEF, 0xA87C, 0x4CA7, 0x84, 0x34, 0x79, 0x75, 0x76, 0xE4, 0x0A, 0x96 , 4 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_RESOURCE_ATTRIBUTES_V1 
* 
* 
****************************************************************************/ 
DEFINE_GUID( WPD_RESOURCE_ATTRIBUTES_V1 , 0x1EB6F604, 0x9278, 0x429F, 0x93, 0xCC, 0x5B, 0xB8, 0xC0, 0x66, 0x56, 0xB6 ); 

// 
// WPD_RESOURCE_ATTRIBUTE_TOTAL_SIZE 
//   [ VT_UI8 ] Total size in bytes of the resource data. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_ATTRIBUTE_TOTAL_SIZE , 0x1EB6F604, 0x9278, 0x429F, 0x93, 0xCC, 0x5B, 0xB8, 0xC0, 0x66, 0x56, 0xB6 , 2 ); 
// 
// WPD_RESOURCE_ATTRIBUTE_CAN_READ 
//   [ VT_BOOL ] Indicates whether client applications have permission to open the resource for Read access. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_ATTRIBUTE_CAN_READ , 0x1EB6F604, 0x9278, 0x429F, 0x93, 0xCC, 0x5B, 0xB8, 0xC0, 0x66, 0x56, 0xB6 , 3 ); 
// 
// WPD_RESOURCE_ATTRIBUTE_CAN_WRITE 
//   [ VT_BOOL ] Indicates whether client applications have permission to open the resource for Write access. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_ATTRIBUTE_CAN_WRITE , 0x1EB6F604, 0x9278, 0x429F, 0x93, 0xCC, 0x5B, 0xB8, 0xC0, 0x66, 0x56, 0xB6 , 4 ); 
// 
// WPD_RESOURCE_ATTRIBUTE_CAN_DELETE 
//   [ VT_BOOL ] Indicates whether client applications have permission to Delete a resource from the device. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_ATTRIBUTE_CAN_DELETE , 0x1EB6F604, 0x9278, 0x429F, 0x93, 0xCC, 0x5B, 0xB8, 0xC0, 0x66, 0x56, 0xB6 , 5 ); 
// 
// WPD_RESOURCE_ATTRIBUTE_OPTIMAL_READ_BUFFER_SIZE 
//   [ VT_UI4 ] The recommended buffer size a caller should use when doing buffered reads on the resource. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_ATTRIBUTE_OPTIMAL_READ_BUFFER_SIZE , 0x1EB6F604, 0x9278, 0x429F, 0x93, 0xCC, 0x5B, 0xB8, 0xC0, 0x66, 0x56, 0xB6 , 6 ); 
// 
// WPD_RESOURCE_ATTRIBUTE_OPTIMAL_WRITE_BUFFER_SIZE 
//   [ VT_UI4 ] The recommended buffer size a caller should use when doing buffered writes on the resource. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_ATTRIBUTE_OPTIMAL_WRITE_BUFFER_SIZE , 0x1EB6F604, 0x9278, 0x429F, 0x93, 0xCC, 0x5B, 0xB8, 0xC0, 0x66, 0x56, 0xB6 , 7 ); 
// 
// WPD_RESOURCE_ATTRIBUTE_FORMAT 
//   [ VT_CLSID ] Indicates the format of the resource data. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_ATTRIBUTE_FORMAT , 0x1EB6F604, 0x9278, 0x429F, 0x93, 0xCC, 0x5B, 0xB8, 0xC0, 0x66, 0x56, 0xB6 , 8 ); 
// 
// WPD_RESOURCE_ATTRIBUTE_RESOURCE_KEY 
//   [ VT_UNKNOWN ] This is an IPortableDeviceKeyCollection containing a single value, which is the key identifying the resource. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_ATTRIBUTE_RESOURCE_KEY , 0x1EB6F604, 0x9278, 0x429F, 0x93, 0xCC, 0x5B, 0xB8, 0xC0, 0x66, 0x56, 0xB6 , 9 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_DEVICE_PROPERTIES_V1 
* 
* 
****************************************************************************/ 
DEFINE_GUID( WPD_DEVICE_PROPERTIES_V1 , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC ); 

// 
// WPD_DEVICE_SYNC_PARTNER 
//   [ VT_LPWSTR ] Indicates a human-readable description of a synchronization partner for the device. 
DEFINE_PROPERTYKEY( WPD_DEVICE_SYNC_PARTNER , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 2 ); 
// 
// WPD_DEVICE_FIRMWARE_VERSION 
//   [ VT_LPWSTR ] Indicates the firmware version for the device. 
DEFINE_PROPERTYKEY( WPD_DEVICE_FIRMWARE_VERSION , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 3 ); 
// 
// WPD_DEVICE_POWER_LEVEL 
//   [ VT_UI4 ] Indicates the power level of the device's battery. 
DEFINE_PROPERTYKEY( WPD_DEVICE_POWER_LEVEL , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 4 ); 
// 
// WPD_DEVICE_POWER_SOURCE 
//   [ VT_UI4 ] Indicates the power source of the device e.g. whether it is battery or external. 
DEFINE_PROPERTYKEY( WPD_DEVICE_POWER_SOURCE , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 5 ); 
// 
// WPD_DEVICE_PROTOCOL 
//   [ VT_LPWSTR ] Identifies the device protocol being used. 
DEFINE_PROPERTYKEY( WPD_DEVICE_PROTOCOL , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 6 ); 
// 
// WPD_DEVICE_MANUFACTURER 
//   [ VT_LPWSTR ] Identifies the device manufacturer. 
DEFINE_PROPERTYKEY( WPD_DEVICE_MANUFACTURER , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 7 ); 
// 
// WPD_DEVICE_MODEL 
//   [ VT_LPWSTR ] Identifies the device model. 
DEFINE_PROPERTYKEY( WPD_DEVICE_MODEL , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 8 ); 
// 
// WPD_DEVICE_SERIAL_NUMBER 
//   [ VT_LPWSTR ] Identifies the serial number of the device. 
DEFINE_PROPERTYKEY( WPD_DEVICE_SERIAL_NUMBER , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 9 ); 
// 
// WPD_DEVICE_SUPPORTS_NON_CONSUMABLE 
//   [ VT_BOOL ] Indicates whether the device supports non-consumable objects. 
DEFINE_PROPERTYKEY( WPD_DEVICE_SUPPORTS_NON_CONSUMABLE , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 10 ); 
// 
// WPD_DEVICE_DATETIME 
//   [ VT_DATE ] Represents the current date and time settings of the device. 
DEFINE_PROPERTYKEY( WPD_DEVICE_DATETIME , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 11 ); 
// 
// WPD_DEVICE_FRIENDLY_NAME 
//   [ VT_LPWSTR ] Represents the friendly name set by the user on the device. 
DEFINE_PROPERTYKEY( WPD_DEVICE_FRIENDLY_NAME , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 12 ); 
// 
// WPD_DEVICE_SUPPORTED_DRM_SCHEMES 
//   [ VT_UNKNOWN ] An IPortableDevicePropVariantCollection of VT_LPWSTR values indicating the Digital Rights Management schemes supported by the driver. 
DEFINE_PROPERTYKEY( WPD_DEVICE_SUPPORTED_DRM_SCHEMES , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 13 ); 
// 
// WPD_DEVICE_SUPPORTED_FORMATS_ARE_ORDERED 
//   [ VT_BOOL ] Indicates whether the supported formats returned from the device are in a preferred order. (First format in the list is most preferred by the device, while the last is the least preferred.) 
DEFINE_PROPERTYKEY( WPD_DEVICE_SUPPORTED_FORMATS_ARE_ORDERED , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 14 ); 
// 
// WPD_DEVICE_TYPE 
//   [ VT_UI4 ] Indicates the device type, used for representation purposes only. Functional characteristics of the device are decided through functional objects. 
DEFINE_PROPERTYKEY( WPD_DEVICE_TYPE , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 15 ); 
// 
// WPD_DEVICE_NETWORK_IDENTIFIER 
//   [ VT_UI8 ] Indicates the EUI-64 network identifier of the device, used for out-of-band Network Association operations. 
DEFINE_PROPERTYKEY( WPD_DEVICE_NETWORK_IDENTIFIER , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 16 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_EVENT_PROPERTIES_V1 
* 
* The properties in this category are for properties that may be needed for event processing, but do not have object property equivalents (i.e. they are not exposed as object properties, but rather, used only as event parameters).
****************************************************************************/ 
DEFINE_GUID( WPD_EVENT_PROPERTIES_V1 , 0x15AB1953, 0xF817, 0x4FEF, 0xA9, 0x21, 0x56, 0x76, 0xE8, 0x38, 0xF6, 0xE0 ); 

// 
// WPD_EVENT_PARAMETER_PNP_DEVICE_ID 
//   [ VT_LPWSTR ] Indicates the device that originated the event. 
DEFINE_PROPERTYKEY( WPD_EVENT_PARAMETER_PNP_DEVICE_ID , 0x15AB1953, 0xF817, 0x4FEF, 0xA9, 0x21, 0x56, 0x76, 0xE8, 0x38, 0xF6, 0xE0 , 2 ); 
// 
// WPD_EVENT_PARAMETER_EVENT_ID 
//   [ VT_CLSID ] Indicates the event sent. 
DEFINE_PROPERTYKEY( WPD_EVENT_PARAMETER_EVENT_ID , 0x15AB1953, 0xF817, 0x4FEF, 0xA9, 0x21, 0x56, 0x76, 0xE8, 0x38, 0xF6, 0xE0 , 3 ); 
// 
// WPD_EVENT_PARAMETER_OPERATION_STATE 
//   [ VT_UI4 ] Indicates the current state of the operation (e.g. started, running, stopped etc.). 
DEFINE_PROPERTYKEY( WPD_EVENT_PARAMETER_OPERATION_STATE , 0x15AB1953, 0xF817, 0x4FEF, 0xA9, 0x21, 0x56, 0x76, 0xE8, 0x38, 0xF6, 0xE0 , 4 ); 
// 
// WPD_EVENT_PARAMETER_OPERATION_PROGRESS 
//   [ VT_UI4 ] Indicates the progress of a currently executing operation. Value is from 0 to 100, with 100 indicating that the operation is complete. 
DEFINE_PROPERTYKEY( WPD_EVENT_PARAMETER_OPERATION_PROGRESS , 0x15AB1953, 0xF817, 0x4FEF, 0xA9, 0x21, 0x56, 0x76, 0xE8, 0x38, 0xF6, 0xE0 , 5 ); 
// 
// WPD_EVENT_PARAMETER_OBJECT_PARENT_PERSISTENT_UNIQUE_ID 
//   [ VT_LPWSTR ] Uniquely identifies the parent object, similar to WPD_OBJECT_PARENT_ID, but this ID will not change between sessions. 
DEFINE_PROPERTYKEY( WPD_EVENT_PARAMETER_OBJECT_PARENT_PERSISTENT_UNIQUE_ID , 0x15AB1953, 0xF817, 0x4FEF, 0xA9, 0x21, 0x56, 0x76, 0xE8, 0x38, 0xF6, 0xE0 , 6 ); 
// 
// WPD_EVENT_PARAMETER_OBJECT_CREATION_COOKIE 
//   [ VT_LPWSTR ] This is the cookie handed back to a client when it requested an object creation using the IPortableDeviceContent::CreateObjectWithPropertiesAndData method. 
DEFINE_PROPERTYKEY( WPD_EVENT_PARAMETER_OBJECT_CREATION_COOKIE , 0x15AB1953, 0xF817, 0x4FEF, 0xA9, 0x21, 0x56, 0x76, 0xE8, 0x38, 0xF6, 0xE0 , 7 ); 
// 
// WPD_EVENT_PARAMETER_CHILD_HIERARCHY_CHANGED 
//   [ VT_BOOL ] Indicates that the child hiearchy for the object has changed. 
DEFINE_PROPERTYKEY( WPD_EVENT_PARAMETER_CHILD_HIERARCHY_CHANGED , 0x15AB1953, 0xF817, 0x4FEF, 0xA9, 0x21, 0x56, 0x76, 0xE8, 0x38, 0xF6, 0xE0 , 8 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_EVENT_OPTIONS_V1 
* 
* The properties in this category describe event options.
****************************************************************************/ 
DEFINE_GUID( WPD_EVENT_OPTIONS_V1 , 0xB3D8DAD7, 0xA361, 0x4B83, 0x8A, 0x48, 0x5B, 0x02, 0xCE, 0x10, 0x71, 0x3B ); 

// 
// WPD_EVENT_OPTION_IS_BROADCAST_EVENT 
//   [ VT_BOOL ] Indicates that the event is broadcast to all clients. 
DEFINE_PROPERTYKEY( WPD_EVENT_OPTION_IS_BROADCAST_EVENT , 0xB3D8DAD7, 0xA361, 0x4B83, 0x8A, 0x48, 0x5B, 0x02, 0xCE, 0x10, 0x71, 0x3B , 2 ); 
// 
// WPD_EVENT_OPTION_IS_AUTOPLAY_EVENT 
//   [ VT_BOOL ] Indicates that the event is sent to and handled by Autoplay. 
DEFINE_PROPERTYKEY( WPD_EVENT_OPTION_IS_AUTOPLAY_EVENT , 0xB3D8DAD7, 0xA361, 0x4B83, 0x8A, 0x48, 0x5B, 0x02, 0xCE, 0x10, 0x71, 0x3B , 3 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_API_OPTIONS_V1 
* 
* The properties in this category describe API options.
****************************************************************************/ 
DEFINE_GUID( WPD_API_OPTIONS_V1 , 0x10E54A3E, 0x052D, 0x4777, 0xA1, 0x3C, 0xDE, 0x76, 0x14, 0xBE, 0x2B, 0xC4 ); 

// 
// WPD_API_OPTION_USE_CLEAR_DATA_STREAM 
//   [ VT_BOOL ] Indicates that the data stream created for data transfer will be clear only (i.e. No DRM will be involved). 
DEFINE_PROPERTYKEY( WPD_API_OPTION_USE_CLEAR_DATA_STREAM , 0x10E54A3E, 0x052D, 0x4777, 0xA1, 0x3C, 0xDE, 0x76, 0x14, 0xBE, 0x2B, 0xC4 , 2 ); 
// 
// WPD_API_OPTION_IOCTL_ACCESS 
//   [ VT_UI4 ] An optional property that clients can add to the IN parameter set of IPortableDevice::SendCommand to specify the access required for the command. The Portable Device API uses this to identify whether the IOCTL sent to the driver is sent with FILE_READ_ACCESS or (FILE_READ_ACCESS | FILE_WRITE_ACCESS) access flags. 
DEFINE_PROPERTYKEY( WPD_API_OPTION_IOCTL_ACCESS , 0x10E54A3E, 0x052D, 0x4777, 0xA1, 0x3C, 0xDE, 0x76, 0x14, 0xBE, 0x2B, 0xC4 , 3 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_COMMON 
* 
* 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_COMMON , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A ); 

// ======== Commands ========

// 
// WPD_COMMAND_COMMON_RESET_DEVICE 
//     This command is sent by clients to reset the device. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     None 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_COMMON_RESET_DEVICE , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 2 ); 
// 
// WPD_COMMAND_COMMON_GET_OBJECT_IDS_FROM_PERSISTENT_UNIQUE_IDS 
//     This command is sent when a client wants to get current ObjectIDs representing objects specified by previously acquired Persistent Unique IDs. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_COMMON_PERSISTENT_UNIQUE_IDS 
//  Results: 
//     [ Required ] WPD_PROPERTY_COMMON_OBJECT_IDS 
DEFINE_PROPERTYKEY( WPD_COMMAND_COMMON_GET_OBJECT_IDS_FROM_PERSISTENT_UNIQUE_IDS , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 3 ); 
// 
// WPD_COMMAND_COMMON_SAVE_CLIENT_INFORMATION 
//     This command is sent when a client first connects to a device. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_COMMON_CLIENT_INFORMATION 
//  Results: 
//     [ Optional ] WPD_PROPERTY_COMMON_CLIENT_INFORMATION_CONTEXT 
DEFINE_PROPERTYKEY( WPD_COMMAND_COMMON_SAVE_CLIENT_INFORMATION , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 4 ); 

// ======== Command Parameters ======== 

// 
// WPD_PROPERTY_COMMON_COMMAND_CATEGORY 
//   [ VT_CLSID ] Specifies the command Category (i.e. the GUID portion of the PROPERTYKEY indicating the command). 
DEFINE_PROPERTYKEY( WPD_PROPERTY_COMMON_COMMAND_CATEGORY , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 1001 ); 
// 
// WPD_PROPERTY_COMMON_COMMAND_ID 
//   [ VT_UI4 ] Specifies the command ID, which is the PID portion of the PROPERTYKEY indicating the command. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_COMMON_COMMAND_ID , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 1002 ); 
// 
// WPD_PROPERTY_COMMON_HRESULT 
//   [ VT_ERROR ] The driver sets this to be the HRESULT of the requested operation. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_COMMON_HRESULT , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 1003 ); 
// 
// WPD_PROPERTY_COMMON_DRIVER_ERROR_CODE 
//   [ VT_UI4 ] Special driver specific code which driver may return on error. Typically only for use with diagnostic tools or vertical solutions. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_COMMON_DRIVER_ERROR_CODE , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 1004 ); 
// 
// WPD_PROPERTY_COMMON_COMMAND_TARGET 
//   [ VT_LPWSTR ] Identifies the object which the command is intended for. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_COMMON_COMMAND_TARGET , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 1006 ); 
// 
// WPD_PROPERTY_COMMON_PERSISTENT_UNIQUE_IDS 
//   [ VT_UNKNOWN ] IPortableDevicePropVariantCollection of type VT_LPWSTR specifying list of Persistent Unique IDs. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_COMMON_PERSISTENT_UNIQUE_IDS , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 1007 ); 
// 
// WPD_PROPERTY_COMMON_OBJECT_IDS 
//   [ VT_UNKNOWN ] IPortableDevicePropVariantCollection of type VT_LPWSTR specifying list of Objects IDs. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_COMMON_OBJECT_IDS , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 1008 ); 
// 
// WPD_PROPERTY_COMMON_CLIENT_INFORMATION 
//   [ VT_UNKNOWN ] IPortableDeviceValues used to identify itself to the driver. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_COMMON_CLIENT_INFORMATION , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 1009 ); 
// 
// WPD_PROPERTY_COMMON_CLIENT_INFORMATION_CONTEXT 
//   [ VT_LPWSTR ] Driver specified context which will be sent for the particular client on all subsequent operations. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_COMMON_CLIENT_INFORMATION_CONTEXT , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 1010 ); 

// ======== Command Options ========

// 
// WPD_OPTION_VALID_OBJECT_IDS 
//   [ VT_UNKNOWN ] IPortableDevicePropVariantCollection of type VT_LPWSTR specifying list of Objects IDs of the objects that support the command. 
DEFINE_PROPERTYKEY( WPD_OPTION_VALID_OBJECT_IDS , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 5001 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_OBJECT_ENUMERATION 
* 
* The commands in this category are used for basic object enumeration. 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_OBJECT_ENUMERATION , 0xB7474E91, 0xE7F8, 0x4AD9, 0xB4, 0x00, 0xAD, 0x1A, 0x4B, 0x58, 0xEE, 0xEC ); 

// ======== Commands ========

// 
// WPD_COMMAND_OBJECT_ENUMERATION_START_FIND 
//     The driver receives this command when a client wishes to start enumeration. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_ENUMERATION_PARENT_ID 
//     [ Optional ] WPD_PROPERTY_OBJECT_ENUMERATION_FILTER 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_ENUMERATION_CONTEXT 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_ENUMERATION_START_FIND , 0xB7474E91, 0xE7F8, 0x4AD9, 0xB4, 0x00, 0xAD, 0x1A, 0x4B, 0x58, 0xEE, 0xEC , 2 ); 
// 
// WPD_COMMAND_OBJECT_ENUMERATION_FIND_NEXT 
//     This command is used when the client requests the next batch of ObjectIDs during enumeration. Only objects that match the constraints set up in WPD_COMMAND_OBJECT_ENUMERATION_START_FIND should be returned. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_ENUMERATION_CONTEXT 
//     [ Required ] WPD_PROPERTY_OBJECT_ENUMERATION_NUM_OBJECTS_REQUESTED 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_ENUMERATION_OBJECT_IDS 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_ENUMERATION_FIND_NEXT , 0xB7474E91, 0xE7F8, 0x4AD9, 0xB4, 0x00, 0xAD, 0x1A, 0x4B, 0x58, 0xEE, 0xEC , 3 ); 
// 
// WPD_COMMAND_OBJECT_ENUMERATION_END_FIND 
//     The driver should destroy any resources associated with this enumeration context. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_ENUMERATION_CONTEXT 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_ENUMERATION_END_FIND , 0xB7474E91, 0xE7F8, 0x4AD9, 0xB4, 0x00, 0xAD, 0x1A, 0x4B, 0x58, 0xEE, 0xEC , 4 ); 

// ======== Command Parameters ======== 

// 
// WPD_PROPERTY_OBJECT_ENUMERATION_PARENT_ID 
//   [ VT_LPWSTR ] The ObjectID specifying the parent object where enumeration should start. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_ENUMERATION_PARENT_ID , 0xB7474E91, 0xE7F8, 0x4AD9, 0xB4, 0x00, 0xAD, 0x1A, 0x4B, 0x58, 0xEE, 0xEC , 1001 ); 
// 
// WPD_PROPERTY_OBJECT_ENUMERATION_FILTER 
//   [ VT_UNKNOWN ] This is an IPortableDeviceValues which specifies the properties used to filter on. If the caller does not want filtering, then this value will not be set. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_ENUMERATION_FILTER , 0xB7474E91, 0xE7F8, 0x4AD9, 0xB4, 0x00, 0xAD, 0x1A, 0x4B, 0x58, 0xEE, 0xEC , 1002 ); 
// 
// WPD_PROPERTY_OBJECT_ENUMERATION_OBJECT_IDS 
//   [ VT_UNKNOWN ] This is an IPortableDevicePropVariantCollection of ObjectIDs (of type VT_LPWSTR). If 0 objects are returned, this should be an empty collection, not NULL. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_ENUMERATION_OBJECT_IDS , 0xB7474E91, 0xE7F8, 0x4AD9, 0xB4, 0x00, 0xAD, 0x1A, 0x4B, 0x58, 0xEE, 0xEC , 1003 ); 
// 
// WPD_PROPERTY_OBJECT_ENUMERATION_CONTEXT 
//   [ VT_LPWSTR ] This is a driver-specified identifier for the context associated with this enumeration. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_ENUMERATION_CONTEXT , 0xB7474E91, 0xE7F8, 0x4AD9, 0xB4, 0x00, 0xAD, 0x1A, 0x4B, 0x58, 0xEE, 0xEC , 1004 ); 
// 
// WPD_PROPERTY_OBJECT_ENUMERATION_NUM_OBJECTS_REQUESTED 
//   [ VT_UI4 ] The maximum number of ObjectIDs to return back to the client. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_ENUMERATION_NUM_OBJECTS_REQUESTED , 0xB7474E91, 0xE7F8, 0x4AD9, 0xB4, 0x00, 0xAD, 0x1A, 0x4B, 0x58, 0xEE, 0xEC , 1005 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_OBJECT_PROPERTIES 
* 
* This category of commands is used to perform basic property operations such as Reading/Writing values, listing supported values and so on. 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_OBJECT_PROPERTIES , 0x9E5582E4, 0x0814, 0x44E6, 0x98, 0x1A, 0xB2, 0x99, 0x8D, 0x58, 0x38, 0x04 ); 

// ======== Commands ========

// 
// WPD_COMMAND_OBJECT_PROPERTIES_GET_SUPPORTED 
//     This command is used when the client requests the list of properties supported by the specified object. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_OBJECT_ID 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_KEYS 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_GET_SUPPORTED , 0x9E5582E4, 0x0814, 0x44E6, 0x98, 0x1A, 0xB2, 0x99, 0x8D, 0x58, 0x38, 0x04 , 2 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_GET_ATTRIBUTES 
//     This command is used when the client requests the property attributes for the specified object properties. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_OBJECT_ID 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_KEYS 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_ATTRIBUTES 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_GET_ATTRIBUTES , 0x9E5582E4, 0x0814, 0x44E6, 0x98, 0x1A, 0xB2, 0x99, 0x8D, 0x58, 0x38, 0x04 , 3 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_GET 
//     This command is used when the client requests a set of property values for the specified object. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_OBJECT_ID 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_KEYS 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_VALUES 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_GET , 0x9E5582E4, 0x0814, 0x44E6, 0x98, 0x1A, 0xB2, 0x99, 0x8D, 0x58, 0x38, 0x04 , 4 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_SET 
//     This command is used when the client requests to write a set of property values on the specified object. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_OBJECT_ID 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_VALUES 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_WRITE_RESULTS 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_SET , 0x9E5582E4, 0x0814, 0x44E6, 0x98, 0x1A, 0xB2, 0x99, 0x8D, 0x58, 0x38, 0x04 , 5 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_GET_ALL 
//     This command is used when the client requests all property values for the specified object. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_OBJECT_ID 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_VALUES 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_GET_ALL , 0x9E5582E4, 0x0814, 0x44E6, 0x98, 0x1A, 0xB2, 0x99, 0x8D, 0x58, 0x38, 0x04 , 6 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_DELETE 
//     This command is sent when the caller wants to delete properties from the specified object. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_OBJECT_ID 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_KEYS 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_DELETE , 0x9E5582E4, 0x0814, 0x44E6, 0x98, 0x1A, 0xB2, 0x99, 0x8D, 0x58, 0x38, 0x04 , 7 ); 

// ======== Command Parameters ======== 

// 
// WPD_PROPERTY_OBJECT_PROPERTIES_OBJECT_ID 
//   [ VT_LPWSTR ] The ObjectID specifying the object whose properties are being queried/manipulated. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_OBJECT_ID , 0x9E5582E4, 0x0814, 0x44E6, 0x98, 0x1A, 0xB2, 0x99, 0x8D, 0x58, 0x38, 0x04 , 1001 ); 
// 
// WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_KEYS 
//   [ VT_UNKNOWN ] An IPortableDeviceKeyCollection identifying which specific property values we are querying/manipulating. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_KEYS , 0x9E5582E4, 0x0814, 0x44E6, 0x98, 0x1A, 0xB2, 0x99, 0x8D, 0x58, 0x38, 0x04 , 1002 ); 
// 
// WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_ATTRIBUTES 
//   [ VT_UNKNOWN ] This is an IPortableDeviceValues which contains the attributes for each property requested.
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_ATTRIBUTES , 0x9E5582E4, 0x0814, 0x44E6, 0x98, 0x1A, 0xB2, 0x99, 0x8D, 0x58, 0x38, 0x04 , 1003 ); 
// 
// WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_VALUES 
//   [ VT_UNKNOWN ] This is an IPortableDeviceValues which contains the values read. For any property whose value could not be read, the type must be set to VT_ERROR, and the 'scode' field must contain the failure HRESULT.
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_VALUES , 0x9E5582E4, 0x0814, 0x44E6, 0x98, 0x1A, 0xB2, 0x99, 0x8D, 0x58, 0x38, 0x04 , 1004 ); 
// 
// WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_WRITE_RESULTS 
//   [ VT_UNKNOWN ] This is an IPortableDeviceValues which contains the result of each property write operation.
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_WRITE_RESULTS , 0x9E5582E4, 0x0814, 0x44E6, 0x98, 0x1A, 0xB2, 0x99, 0x8D, 0x58, 0x38, 0x04 , 1005 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_OBJECT_PROPERTIES_BULK 
* 
* This category contains commands and properties for property operations across multiple objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_OBJECT_PROPERTIES_BULK , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E ); 

// ======== Commands ========

// 
// WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_LIST_START 
//     Initializes the operation to get the property values for all caller-specified objects. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_OBJECT_IDS 
//     [ Optional ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_PROPERTY_KEYS 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_CONTEXT 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_LIST_START , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 2 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_LIST_NEXT 
//     Get the next set of property values. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_CONTEXT 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_VALUES 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_LIST_NEXT , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 3 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_LIST_END 
//     Ends the bulk property operation for getting property values by object list. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_CONTEXT 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_LIST_END , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 4 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_FORMAT_START 
//     Initializes the operation to get the property values for objects of the specified format 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_OBJECT_FORMAT 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_PARENT_OBJECT_ID 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_DEPTH 
//     [ Optional ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_PROPERTY_KEYS 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_CONTEXT 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_FORMAT_START , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 5 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_FORMAT_NEXT 
//     Get the next set of property values. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_CONTEXT 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_VALUES 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_FORMAT_NEXT , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 6 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_FORMAT_END 
//     Ends the bulk property operation for getting property values by object format. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_CONTEXT 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_FORMAT_END , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 7 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_BULK_SET_VALUES_BY_OBJECT_LIST_START 
//     Initializes the operation to set the property values for specified objects. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_VALUES 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_CONTEXT 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_SET_VALUES_BY_OBJECT_LIST_START , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 8 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_BULK_SET_VALUES_BY_OBJECT_LIST_NEXT 
//     Set the next set of property values. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_CONTEXT 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_WRITE_RESULTS 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_SET_VALUES_BY_OBJECT_LIST_NEXT , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 9 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_BULK_SET_VALUES_BY_OBJECT_LIST_END 
//     Ends the bulk property operation for setting property values by object list. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_CONTEXT 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_SET_VALUES_BY_OBJECT_LIST_END , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 10 ); 

// ======== Command Parameters ======== 

// 
// WPD_PROPERTY_OBJECT_PROPERTIES_BULK_OBJECT_IDS 
//   [ VT_UNKNOWN ] A collection of ObjectIDs for which supported property list must be returned. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_BULK_OBJECT_IDS , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 1001 ); 
// 
// WPD_PROPERTY_OBJECT_PROPERTIES_BULK_CONTEXT 
//   [ VT_LPWSTR ] The driver-specified context identifying this particular bulk operation. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_BULK_CONTEXT , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 1002 ); 
// 
// WPD_PROPERTY_OBJECT_PROPERTIES_BULK_VALUES 
//   [ VT_UNKNOWN ] Contains an IPortableDeviceValuesCollection specifying the next set of IPortableDeviceValues elements. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_BULK_VALUES , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 1003 ); 
// 
// WPD_PROPERTY_OBJECT_PROPERTIES_BULK_PROPERTY_KEYS 
//   [ VT_UNKNOWN ] Contains an IPortableDeviceKeyCollection specifying which properties the caller wants to return. May not exist, which indicates caller wants ALL properties. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_BULK_PROPERTY_KEYS , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 1004 ); 
// 
// WPD_PROPERTY_OBJECT_PROPERTIES_BULK_DEPTH 
//   [ VT_UI4 ] Contains a value specifying the hierarchical depth from the parent to include in this operation. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_BULK_DEPTH , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 1005 ); 
// 
// WPD_PROPERTY_OBJECT_PROPERTIES_BULK_PARENT_OBJECT_ID 
//   [ VT_LPWSTR ] Contains the ObjectID of the object to start the operation from. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_BULK_PARENT_OBJECT_ID , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 1006 ); 
// 
// WPD_PROPERTY_OBJECT_PROPERTIES_BULK_OBJECT_FORMAT 
//   [ VT_CLSID ] Specifies the object format the client is interested in. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_BULK_OBJECT_FORMAT , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 1007 ); 
// 
// WPD_PROPERTY_OBJECT_PROPERTIES_BULK_WRITE_RESULTS 
//   [ VT_UNKNOWN ] Contains an IPortableDeviceValuesCollection specifying the set of IPortableDeviceValues elements indicating the write results for each property set. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_BULK_WRITE_RESULTS , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 1008 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_OBJECT_RESOURCES 
* 
* The commands in this category are used for basic object resource enumeration and transfer. 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_OBJECT_RESOURCES , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A ); 

// ======== Commands ========

// 
// WPD_COMMAND_OBJECT_RESOURCES_GET_SUPPORTED 
//     This command is sent when a client wants to get the list of resources supported on a particular object. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_OBJECT_ID 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_RESOURCE_KEYS 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_RESOURCES_GET_SUPPORTED , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 2 ); 
// 
// WPD_COMMAND_OBJECT_RESOURCES_GET_ATTRIBUTES 
//     This command is used when the client requests the attributes for the specified object resource. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_OBJECT_ID 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_RESOURCE_KEYS 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_RESOURCE_ATTRIBUTES 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_RESOURCES_GET_ATTRIBUTES , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 3 ); 
// 
// WPD_COMMAND_OBJECT_RESOURCES_OPEN 
//     This command is sent when a client wants to use a particular resource on an object. 
//  Access: 
//     Dependent on the value of WPD_PROPERTY_OBJECT_RESOURCES_ACCESS_MODE. STGM_READ will indicate FILE_READ_ACCESS for the command, anything else will indicate (FILE_READ_ACCESS | FILE_WRITE_ACCESS). 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_OBJECT_ID 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_RESOURCE_KEYS 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_ACCESS_MODE 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_CONTEXT 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_OPTIMAL_TRANSFER_BUFFER_SIZE 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_RESOURCES_OPEN , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 4 ); 
// 
// WPD_COMMAND_OBJECT_RESOURCES_READ 
//     This command is sent when a client wants to read the next band of data from a previously opened object resource. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_CONTEXT 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_NUM_BYTES_TO_READ 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_DATA 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_NUM_BYTES_READ 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_DATA 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_RESOURCES_READ , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 5 ); 
// 
// WPD_COMMAND_OBJECT_RESOURCES_WRITE 
//     This command is sent when a client wants to write the next band of data to a previously opened object resource. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_CONTEXT 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_NUM_BYTES_TO_WRITE 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_DATA 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_NUM_BYTES_WRITTEN 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_RESOURCES_WRITE , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 6 ); 
// 
// WPD_COMMAND_OBJECT_RESOURCES_CLOSE 
//     This command is sent when a client is finished transferring data to a previously opened object resource. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_CONTEXT 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_RESOURCES_CLOSE , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 7 ); 
// 
// WPD_COMMAND_OBJECT_RESOURCES_DELETE 
//     This command is sent when the client wants to delete the data associated with the specified resources from the specified object. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_OBJECT_ID 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_RESOURCE_KEYS 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_RESOURCES_DELETE , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 8 ); 
// 
// WPD_COMMAND_OBJECT_RESOURCES_CREATE_RESOURCE 
//     This command is sent when a client wants to create a new object resource on the device. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_RESOURCE_ATTRIBUTES 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_CONTEXT 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_OPTIMAL_TRANSFER_BUFFER_SIZE 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_RESOURCES_CREATE_RESOURCE , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 9 ); 
// 
// WPD_COMMAND_OBJECT_RESOURCES_REVERT 
//     This command is sent when a client wants to cancel the resource creation request that is currently still in progress. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_CONTEXT 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_RESOURCES_REVERT , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 10 ); 
// 
// WPD_COMMAND_OBJECT_RESOURCES_SEEK 
//     This command is sent when a client wants to seek to a specific offset in the data stream. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_CONTEXT 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_SEEK_OFFSET 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_SEEK_ORIGIN_FLAG 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_POSITION_FROM_START 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_RESOURCES_SEEK , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 11 ); 

// ======== Command Parameters ======== 

// 
// WPD_PROPERTY_OBJECT_RESOURCES_OBJECT_ID 
//   [ VT_LPWSTR ] 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_OBJECT_ID , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1001 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_ACCESS_MODE 
//   [ VT_UI4 ] Specifies the type of access the client is requesting for the resource. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_ACCESS_MODE , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1002 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_RESOURCE_KEYS 
//   [ VT_UNKNOWN ] 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_RESOURCE_KEYS , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1003 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_RESOURCE_ATTRIBUTES 
//   [ VT_UNKNOWN ] This is an IPortableDeviceValues which contains the attributes for the resource requested. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_RESOURCE_ATTRIBUTES , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1004 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_CONTEXT 
//   [ VT_LPWSTR] This is a driver-specified identifier for the context associated with the resource operation. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_CONTEXT , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1005 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_NUM_BYTES_TO_READ 
//   [ VT_UI4 ] Specifies the number of bytes the client is requesting to read. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_NUM_BYTES_TO_READ , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1006 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_NUM_BYTES_READ 
//   [ VT_UI4 ] Specifies the number of bytes actually read from the resource. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_NUM_BYTES_READ , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1007 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_NUM_BYTES_TO_WRITE 
//   [ VT_UI4 ] Specifies the number of bytes the client is requesting to write. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_NUM_BYTES_TO_WRITE , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1008 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_NUM_BYTES_WRITTEN 
//   [ VT_UI4 ] Driver sets this to let caller know how many bytes were actually written. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_NUM_BYTES_WRITTEN , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1009 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_DATA 
//   [ VT_VECTOR|VT_UI1 ] 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_DATA , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1010 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_OPTIMAL_TRANSFER_BUFFER_SIZE 
//   [ VT_UI4 ] Indicates the optimal transfer buffer size (in bytes) that clients should use when reading/writing this resource. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_OPTIMAL_TRANSFER_BUFFER_SIZE , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1011 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_SEEK_OFFSET 
//   [ VT_I8 ] Displacement to be added to the location indicated by the WPD_PROPERTY_OBJECT_RESOURCES_SEEK_ORIGIN_FLAG parameter. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_SEEK_OFFSET , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1012 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_SEEK_ORIGIN_FLAG 
//   [ VT_UI4 ] Specifies the origin of the displacement for the seek operation. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_SEEK_ORIGIN_FLAG , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1013 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_POSITION_FROM_START 
//   [ VT_UI8 ] Value of the new seek pointer from the beginning of the data stream. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_POSITION_FROM_START , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1014 ); 

// ======== Command Options ========

// 
// WPD_OPTION_OBJECT_RESOURCES_SEEK_ON_READ_SUPPORTED 
//   [ VT_BOOL ] Indicates whether the driver can Seek on a resource opened for Read access. 
DEFINE_PROPERTYKEY( WPD_OPTION_OBJECT_RESOURCES_SEEK_ON_READ_SUPPORTED , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 5001 ); 
// 
// WPD_OPTION_OBJECT_RESOURCES_SEEK_ON_WRITE_SUPPORTED 
//   [ VT_BOOL ] Indicates whether the driver can Seek on a resource opened for Write access. 
DEFINE_PROPERTYKEY( WPD_OPTION_OBJECT_RESOURCES_SEEK_ON_WRITE_SUPPORTED , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 5002 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_OBJECT_MANAGEMENT 
* 
* The commands specified in this category are used to Create/Delete objects on the device. 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_OBJECT_MANAGEMENT , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 ); 

// ======== Commands ========

// 
// WPD_COMMAND_OBJECT_MANAGEMENT_CREATE_OBJECT_WITH_PROPERTIES_ONLY 
//     This command is sent when a client wants to create a new object on the device, specified only by properties. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_CREATION_PROPERTIES 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_OBJECT_ID 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_MANAGEMENT_CREATE_OBJECT_WITH_PROPERTIES_ONLY , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 2 ); 
// 
// WPD_COMMAND_OBJECT_MANAGEMENT_CREATE_OBJECT_WITH_PROPERTIES_AND_DATA 
//     This command is sent when a client wants to create a new object on the device, specified by properties and data. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_CREATION_PROPERTIES 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_CONTEXT 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_MANAGEMENT_CREATE_OBJECT_WITH_PROPERTIES_AND_DATA , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 3 ); 
// 
// WPD_COMMAND_OBJECT_MANAGEMENT_WRITE_OBJECT_DATA 
//     This command is sent when a client wants to write the next band of data to a newly created object. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_CONTEXT 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_NUM_BYTES_TO_WRITE 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_DATA 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_NUM_BYTES_WRITTEN 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_MANAGEMENT_WRITE_OBJECT_DATA , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 4 ); 
// 
// WPD_COMMAND_OBJECT_MANAGEMENT_COMMIT_OBJECT 
//     This command is sent when a client has finished sending all the data associated with an object creation request, and wishes to ensure that the object is saved to the device. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_CONTEXT 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_OBJECT_ID 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_MANAGEMENT_COMMIT_OBJECT , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 5 ); 
// 
// WPD_COMMAND_OBJECT_MANAGEMENT_REVERT_OBJECT 
//     This command is sent when a client wants to cancel the object creation request that is currently still in progress. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_CONTEXT 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_MANAGEMENT_REVERT_OBJECT , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 6 ); 
// 
// WPD_COMMAND_OBJECT_MANAGEMENT_DELETE_OBJECTS 
//     This command is sent when the client wishes to remove a set of objects from the device. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_DELETE_OPTIONS 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_OBJECT_IDS 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_DELETE_RESULTS 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_MANAGEMENT_DELETE_OBJECTS , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 7 ); 
// 
// WPD_COMMAND_OBJECT_MANAGEMENT_MOVE_OBJECTS 
//     This command will move the specified objects to the destination folder. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_OBJECT_IDS 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_DESTINATION_FOLDER_OBJECT_ID 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_MOVE_RESULTS 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_MANAGEMENT_MOVE_OBJECTS , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 8 ); 
// 
// WPD_COMMAND_OBJECT_MANAGEMENT_COPY_OBJECTS 
//     This command will copy the specified objects to the destination folder. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_OBJECT_IDS 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_DESTINATION_FOLDER_OBJECT_ID 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_COPY_RESULTS 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_MANAGEMENT_COPY_OBJECTS , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 9 ); 

// ======== Command Parameters ======== 

// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_CREATION_PROPERTIES 
//   [ VT_UNKNOWN ] This is an IPortableDeviceValues which specifies the properties used to create the new object. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_CREATION_PROPERTIES , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1001 ); 
// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_CONTEXT 
//   [ VT_LPWSTR ] This is a driver-specified identifier for the context associated with this 'create object' operation. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_CONTEXT , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1002 ); 
// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_NUM_BYTES_TO_WRITE 
//   [ VT_UI4 ] Specifies the number of bytes the client is requesting to write. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_NUM_BYTES_TO_WRITE , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1003 ); 
// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_NUM_BYTES_WRITTEN 
//   [ VT_UI4 ] Indicates the number of bytes written for the object. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_NUM_BYTES_WRITTEN , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1004 ); 
// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_DATA 
//   [ VT_VECTOR|VT_UI1 ] Indicates binary data of the object being created on the device. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_DATA , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1005 ); 
// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_OBJECT_ID 
//   [ VT_LPWSTR ] Identifies a newly created object on the device. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_OBJECT_ID , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1006 ); 
// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_DELETE_OPTIONS 
//   [ VT_UI4 ] Indicates if the delete operation should be recursive or not. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_DELETE_OPTIONS , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1007 ); 
// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_OPTIMAL_TRANSFER_BUFFER_SIZE 
//   [ VT_UI4 ] Indicates the optimal transfer buffer size (in bytes) that clients should use when writing this object's data. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_OPTIMAL_TRANSFER_BUFFER_SIZE , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1008 ); 
// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_OBJECT_IDS 
//   [ VT_UNKNOWN ] IPortableDevicePropVariantCollection of type VT_LPWSTR, containing the ObjectIDs to delete. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_OBJECT_IDS , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1009 ); 
// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_DELETE_RESULTS 
//   [ VT_UNKNOWN ] IPortableDevicePropVariantCollection of type VT_ERROR, where each element is the HRESULT indicating the success or failure of the operation. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_DELETE_RESULTS , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1010 ); 
// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_DESTINATION_FOLDER_OBJECT_ID 
//   [ VT_LPWSTR ] Indicates the destination folder for the move operation. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_DESTINATION_FOLDER_OBJECT_ID , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1011 ); 
// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_MOVE_RESULTS 
//   [ VT_UNKNOWN ] IPortableDevicePropVariantCollection of type VT_ERROR, where each element is the HRESULT indicating the success or failure of the operation. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_MOVE_RESULTS , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1012 ); 
// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_COPY_RESULTS 
//   [ VT_UNKNOWN ] IPortableDevicePropVariantCollection of type VT_ERROR, where each element is the HRESULT indicating the success or failure of the operation. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_COPY_RESULTS , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1013 ); 

// ======== Command Options ========

// 
// WPD_OPTION_OBJECT_MANAGEMENT_RECURSIVE_DELETE_SUPPORTED 
//   [ VT_BOOL ] Indicates whether the driver supports recursive deletion. 
DEFINE_PROPERTYKEY( WPD_OPTION_OBJECT_MANAGEMENT_RECURSIVE_DELETE_SUPPORTED , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 5001 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_CAPABILITIES 
* 
* This command category is used to query capabilities of the device. 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_CAPABILITIES , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 ); 

// ======== Commands ========

// 
// WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_COMMANDS 
//     Return all commands supported by this driver. This includes custom commands, if any.
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     None 
//  Results: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_SUPPORTED_COMMANDS 
DEFINE_PROPERTYKEY( WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_COMMANDS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 2 ); 
// 
// WPD_COMMAND_CAPABILITIES_GET_COMMAND_OPTIONS 
//     Returns the supported options for the specified command. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_COMMAND 
//  Results: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_COMMAND_OPTIONS 
DEFINE_PROPERTYKEY( WPD_COMMAND_CAPABILITIES_GET_COMMAND_OPTIONS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 3 ); 
// 
// WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_FUNCTIONAL_CATEGORIES 
//     This command is used by clients to query the functional categories supported by the driver. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     None 
//  Results: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_FUNCTIONAL_CATEGORIES 
DEFINE_PROPERTYKEY( WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_FUNCTIONAL_CATEGORIES , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 4 ); 
// 
// WPD_COMMAND_CAPABILITIES_GET_FUNCTIONAL_OBJECTS 
//     Retrieves the ObjectIDs of the objects belonging to the specified functional category. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_FUNCTIONAL_CATEGORY 
//  Results: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_FUNCTIONAL_OBJECTS 
DEFINE_PROPERTYKEY( WPD_COMMAND_CAPABILITIES_GET_FUNCTIONAL_OBJECTS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 5 ); 
// 
// WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_CONTENT_TYPES 
//     Retrieves the list of content types supported by this driver for the specified functional category. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_FUNCTIONAL_CATEGORY 
//  Results: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_CONTENT_TYPES 
DEFINE_PROPERTYKEY( WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_CONTENT_TYPES , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 6 ); 
// 
// WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_FORMATS 
//     This command is used to query the possible formats supported by the specified content type (e.g. for image objects, the driver may choose to support JPEG and BMP files).
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_CONTENT_TYPE 
//  Results: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_FORMATS 
DEFINE_PROPERTYKEY( WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_FORMATS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 7 ); 
// 
// WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_FORMAT_PROPERTIES 
//     Get the list of properties that an object of the given format supports. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_FORMAT 
//  Results: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_PROPERTY_KEYS 
DEFINE_PROPERTYKEY( WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_FORMAT_PROPERTIES , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 8 ); 
// 
// WPD_COMMAND_CAPABILITIES_GET_FIXED_PROPERTY_ATTRIBUTES 
//     Returns the property attributes that are the same for all objects of the given format. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_FORMAT 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_PROPERTY_KEYS 
//  Results: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_PROPERTY_ATTRIBUTES 
DEFINE_PROPERTYKEY( WPD_COMMAND_CAPABILITIES_GET_FIXED_PROPERTY_ATTRIBUTES , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 9 ); 
// 
// WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_EVENTS 
//     Return all events supported by this driver. This includes custom events, if any.
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     None 
//  Results: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_SUPPORTED_EVENTS 
DEFINE_PROPERTYKEY( WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_EVENTS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 10 ); 
// 
// WPD_COMMAND_CAPABILITIES_GET_EVENT_OPTIONS 
//     Return extra information about a specified event, such as whether the event is for notification or action purposes. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_EVENT 
//  Results: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_EVENT_OPTIONS 
DEFINE_PROPERTYKEY( WPD_COMMAND_CAPABILITIES_GET_EVENT_OPTIONS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 11 ); 

// ======== Command Parameters ======== 

// 
// WPD_PROPERTY_CAPABILITIES_SUPPORTED_COMMANDS 
//   [ VT_UNKNOWN ] IPortableDeviceKeyCollection containing all commands a driver supports. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_SUPPORTED_COMMANDS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1001 ); 
// 
// WPD_PROPERTY_CAPABILITIES_COMMAND 
//   [ VT_UNKNOWN ] Indicates the command whose options the caller is interested in. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_COMMAND , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1002 ); 
// 
// WPD_PROPERTY_CAPABILITIES_COMMAND_OPTIONS 
//   [ VT_UNKNOWN ] Contains an IPortableDeviceValues with the relevant command options. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_COMMAND_OPTIONS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1003 ); 
// 
// WPD_PROPERTY_CAPABILITIES_FUNCTIONAL_CATEGORIES 
//   [ VT_UNKNOWN ] An IPortableDevicePropVariantCollection of type VT_CLSID which indicates the functional categories supported by the driver. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_FUNCTIONAL_CATEGORIES , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1004 ); 
// 
// WPD_PROPERTY_CAPABILITIES_FUNCTIONAL_CATEGORY 
//   [ VT_CLSID ] The category the caller is interested in. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_FUNCTIONAL_CATEGORY , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1005 ); 
// 
// WPD_PROPERTY_CAPABILITIES_FUNCTIONAL_OBJECTS 
//   [ VT_UNKNOWN ] An IPortableDevicePropVariantCollection (of type VT_LPWSTR) containing the ObjectIDs of the functional objects who belong to the specified functional category. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_FUNCTIONAL_OBJECTS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1006 ); 
// 
// WPD_PROPERTY_CAPABILITIES_CONTENT_TYPES 
//   [ VT_UNKNOWN ] Indicates list of content types supported for the specified functional category. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_CONTENT_TYPES , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1007 ); 
// 
// WPD_PROPERTY_CAPABILITIES_CONTENT_TYPE 
//   [ VT_CLSID ] Indicates the content type whose formats the caller is interested in. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_CONTENT_TYPE , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1008 ); 
// 
// WPD_PROPERTY_CAPABILITIES_FORMATS 
//   [ VT_UNKNOWN ] An IPortableDevicePropVariantCollection of VT_CLSID values indicating the formats supported for the specified content type. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_FORMATS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1009 ); 
// 
// WPD_PROPERTY_CAPABILITIES_FORMAT 
//   [ VT_CLSID ] Specifies the format the caller is interested in. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_FORMAT , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1010 ); 
// 
// WPD_PROPERTY_CAPABILITIES_PROPERTY_KEYS 
//   [ VT_UNKNOWN ] An IPortableDeviceKeyCollection containing the property keys. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_PROPERTY_KEYS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1011 ); 
// 
// WPD_PROPERTY_CAPABILITIES_PROPERTY_ATTRIBUTES 
//   [ VT_UNKNOWN ] An IPortableDeviceValues containing the property attributes. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_PROPERTY_ATTRIBUTES , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1012 ); 
// 
// WPD_PROPERTY_CAPABILITIES_SUPPORTED_EVENTS 
//   [ VT_UNKNOWN ] IPortableDevicePropVariantCollection of VT_CLSID values containing all events a driver supports. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_SUPPORTED_EVENTS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1013 ); 
// 
// WPD_PROPERTY_CAPABILITIES_EVENT 
//   [ VT_CLSID ] Indicates the event the caller is interested in. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_EVENT , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1014 ); 
// 
// WPD_PROPERTY_CAPABILITIES_EVENT_OPTIONS 
//   [ VT_UNKNOWN ] Contains an IPortableDeviceValues with the relevant event options. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_EVENT_OPTIONS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1015 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_STORAGE 
* 
* This category is for commands and parameters for storage functional objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_STORAGE , 0xD8F907A6, 0x34CC, 0x45FA, 0x97, 0xFB, 0xD0, 0x07, 0xFA, 0x47, 0xEC, 0x94 ); 

// ======== Commands ========

// 
// WPD_COMMAND_STORAGE_FORMAT 
//     This command will format the storage. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_STORAGE_OBJECT_ID 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_STORAGE_FORMAT , 0xD8F907A6, 0x34CC, 0x45FA, 0x97, 0xFB, 0xD0, 0x07, 0xFA, 0x47, 0xEC, 0x94 , 2 ); 
// 
// WPD_COMMAND_STORAGE_EJECT 
//     This will eject the storage, if it is a removable store and is capable of being ejected by the device. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_STORAGE_OBJECT_ID 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_STORAGE_EJECT , 0xD8F907A6, 0x34CC, 0x45FA, 0x97, 0xFB, 0xD0, 0x07, 0xFA, 0x47, 0xEC, 0x94 , 4 ); 

// ======== Command Parameters ======== 

// 
// WPD_PROPERTY_STORAGE_OBJECT_ID 
//   [ VT_LPWSTR ] Indicates the object to format, move or eject. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_STORAGE_OBJECT_ID , 0xD8F907A6, 0x34CC, 0x45FA, 0x97, 0xFB, 0xD0, 0x07, 0xFA, 0x47, 0xEC, 0x94 , 1001 ); 
// 
// WPD_PROPERTY_STORAGE_DESTINATION_OBJECT_ID 
//   [ VT_LPWSTR ] Indicates the (folder) object destination for a move operation. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_STORAGE_DESTINATION_OBJECT_ID , 0xD8F907A6, 0x34CC, 0x45FA, 0x97, 0xFB, 0xD0, 0x07, 0xFA, 0x47, 0xEC, 0x94 , 1002 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_SMS 
* 
* The commands in this category relate to Short-Message-Service functionality, typically exposed on mobile phones. 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_SMS , 0xAFC25D66, 0xFE0D, 0x4114, 0x90, 0x97, 0x97, 0x0C, 0x93, 0xE9, 0x20, 0xD1 ); 

// ======== Commands ========

// 
// WPD_COMMAND_SMS_SEND 
//     This command is used to initiate the sending of an SMS message. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_COMMON_COMMAND_TARGET 
//     [ Required ] WPD_PROPERTY_SMS_RECIPIENT 
//     [ Required ] WPD_PROPERTY_SMS_MESSAGE_TYPE 
//     [ Optional ] WPD_PROPERTY_SMS_TEXT_MESSAGE 
//     [ Optional ] WPD_PROPERTY_SMS_BINARY_MESSAGE 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_SMS_SEND , 0xAFC25D66, 0xFE0D, 0x4114, 0x90, 0x97, 0x97, 0x0C, 0x93, 0xE9, 0x20, 0xD1 , 2 ); 

// ======== Command Parameters ======== 

// 
// WPD_PROPERTY_SMS_RECIPIENT 
//   [ VT_LPWSTR ] Indicates the recipient's address. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_SMS_RECIPIENT , 0xAFC25D66, 0xFE0D, 0x4114, 0x90, 0x97, 0x97, 0x0C, 0x93, 0xE9, 0x20, 0xD1 , 1001 ); 
// 
// WPD_PROPERTY_SMS_MESSAGE_TYPE 
//   [ VT_UI4 ] Indicates whether the message is binary or text. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_SMS_MESSAGE_TYPE , 0xAFC25D66, 0xFE0D, 0x4114, 0x90, 0x97, 0x97, 0x0C, 0x93, 0xE9, 0x20, 0xD1 , 1002 ); 
// 
// WPD_PROPERTY_SMS_TEXT_MESSAGE 
//   [ VT_LPWSTR ] if WPD_PROPERTY_SMS_MESSAGE_TYPE == SMS_TEXT_MESSAGE, then this will contain the message body. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_SMS_TEXT_MESSAGE , 0xAFC25D66, 0xFE0D, 0x4114, 0x90, 0x97, 0x97, 0x0C, 0x93, 0xE9, 0x20, 0xD1 , 1003 ); 
// 
// WPD_PROPERTY_SMS_BINARY_MESSAGE 
//   [ VT_VECTOR|VT_UI1 ] if WPD_PROPERTY_SMS_MESSAGE_TYPE == SMS_BINARY_MESSAGE, then this will contain the binary message body. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_SMS_BINARY_MESSAGE , 0xAFC25D66, 0xFE0D, 0x4114, 0x90, 0x97, 0x97, 0x0C, 0x93, 0xE9, 0x20, 0xD1 , 1004 ); 

// ======== Command Options ========

// 
// WPD_OPTION_SMS_BINARY_MESSAGE_SUPPORTED 
//   [ VT_BOOL ] Indicates whether the driver can support binary messages as well as text messages. 
DEFINE_PROPERTYKEY( WPD_OPTION_SMS_BINARY_MESSAGE_SUPPORTED , 0xAFC25D66, 0xFE0D, 0x4114, 0x90, 0x97, 0x97, 0x0C, 0x93, 0xE9, 0x20, 0xD1 , 5001 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_STILL_IMAGE_CAPTURE 
* 
* 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_STILL_IMAGE_CAPTURE , 0x4FCD6982, 0x22A2, 0x4B05, 0xA4, 0x8B, 0x62, 0xD3, 0x8B, 0xF2, 0x7B, 0x32 ); 

// ======== Commands ========

// 
// WPD_COMMAND_STILL_IMAGE_CAPTURE_INITIATE 
//     Initiates a still image capture. This is processed as a single command i.e. there is no start or stop required. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_COMMON_COMMAND_TARGET 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_STILL_IMAGE_CAPTURE_INITIATE , 0x4FCD6982, 0x22A2, 0x4B05, 0xA4, 0x8B, 0x62, 0xD3, 0x8B, 0xF2, 0x7B, 0x32 , 2 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_MEDIA_CAPTURE 
* 
* 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_MEDIA_CAPTURE , 0x59B433BA, 0xFE44, 0x4D8D, 0x80, 0x8C, 0x6B, 0xCB, 0x9B, 0x0F, 0x15, 0xE8 ); 

// ======== Commands ========

// 
// WPD_COMMAND_MEDIA_CAPTURE_START 
//     Initiates a media capture operation that will only be ended by a subsequent WPD_COMMAND_MEDIA_CAPTURE_STOP command. Typically used to capture media streams such as audio and video. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_COMMON_COMMAND_TARGET 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_MEDIA_CAPTURE_START , 0x59B433BA, 0xFE44, 0x4D8D, 0x80, 0x8C, 0x6B, 0xCB, 0x9B, 0x0F, 0x15, 0xE8 , 2 ); 
// 
// WPD_COMMAND_MEDIA_CAPTURE_STOP 
//     Ends a media capture operation started by a WPD_COMMAND_MEDIA_CAPTURE_START command. Typically used to end capture of media streams such as audio and video. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_COMMON_COMMAND_TARGET 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_MEDIA_CAPTURE_STOP , 0x59B433BA, 0xFE44, 0x4D8D, 0x80, 0x8C, 0x6B, 0xCB, 0x9B, 0x0F, 0x15, 0xE8 , 3 ); 
// 
// WPD_COMMAND_MEDIA_CAPTURE_PAUSE 
//     Pauses a media capture operation started by a WPD_COMMAND_MEDIA_CAPTURE_START command. Typically used to pause capture of media streams such as audio and video. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_COMMON_COMMAND_TARGET 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_MEDIA_CAPTURE_PAUSE , 0x59B433BA, 0xFE44, 0x4D8D, 0x80, 0x8C, 0x6B, 0xCB, 0x9B, 0x0F, 0x15, 0xE8 , 4 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_DEVICE_HINTS 
* 
* The commands in this category relate to hints that a device can provide to improve end-user experience. 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_DEVICE_HINTS , 0x0D5FB92B, 0xCB46, 0x4C4F, 0x83, 0x43, 0x0B, 0xC3, 0xD3, 0xF1, 0x7C, 0x84 ); 

// ======== Commands ========

// 
// WPD_COMMAND_DEVICE_HINTS_GET_CONTENT_LOCATION 
//     This command is used to retrieve the ObjectIDs of folders that contain the specified content type. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_DEVICE_HINTS_CONTENT_TYPE 
//  Results: 
//     [ Required ] WPD_PROPERTY_DEVICE_HINTS_CONTENT_LOCATIONS 
DEFINE_PROPERTYKEY( WPD_COMMAND_DEVICE_HINTS_GET_CONTENT_LOCATION , 0x0D5FB92B, 0xCB46, 0x4C4F, 0x83, 0x43, 0x0B, 0xC3, 0xD3, 0xF1, 0x7C, 0x84 , 2 ); 

// ======== Command Parameters ======== 

// 
// WPD_PROPERTY_DEVICE_HINTS_CONTENT_TYPE 
//   [ VT_CLSID ] Indicates the WPD content type that the caller is looking for. For example, to get the top-level folder objects that contain images, this parameter would be WPD_CONTENT_TYPE_IMAGE. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_DEVICE_HINTS_CONTENT_TYPE , 0x0D5FB92B, 0xCB46, 0x4C4F, 0x83, 0x43, 0x0B, 0xC3, 0xD3, 0xF1, 0x7C, 0x84 , 1001 ); 
// 
// WPD_PROPERTY_DEVICE_HINTS_CONTENT_LOCATIONS 
//   [ VT_UNKNOWN ] IPortableDevicePropVariantCollection of type VT_LPWSTR indicating a list of folder ObjectIDs. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_DEVICE_HINTS_CONTENT_LOCATIONS , 0x0D5FB92B, 0xCB46, 0x4C4F, 0x83, 0x43, 0x0B, 0xC3, 0xD3, 0xF1, 0x7C, 0x84 , 1002 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CLASS_EXTENSION_V1 
* 
* The commands in this category relate to the WPD device class extension. 
****************************************************************************/ 
DEFINE_GUID( WPD_CLASS_EXTENSION_V1 , 0x33FB0D11, 0x64A3, 0x4FAC, 0xB4, 0xC7, 0x3D, 0xFE, 0xAA, 0x99, 0xB0, 0x51 ); 

// ======== Commands ========

// 
// WPD_COMMAND_CLASS_EXTENSION_WRITE_DEVICE_INFORMATION 
//     This command is used to update the a cache of device-specific information. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_CLASS_EXTENSION_DEVICE_INFORMATION_VALUES 
//  Results: 
//     [ Required ] WPD_PROPERTY_CLASS_EXTENSION_DEVICE_INFORMATION_WRITE_RESULTS 
DEFINE_PROPERTYKEY( WPD_COMMAND_CLASS_EXTENSION_WRITE_DEVICE_INFORMATION , 0x33FB0D11, 0x64A3, 0x4FAC, 0xB4, 0xC7, 0x3D, 0xFE, 0xAA, 0x99, 0xB0, 0x51 , 2 ); 

// ======== Command Parameters ======== 

// 
// WPD_PROPERTY_CLASS_EXTENSION_DEVICE_INFORMATION_VALUES 
//   [ VT_UNKNOWN ] This is an IPortableDeviceValues which contains the values. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CLASS_EXTENSION_DEVICE_INFORMATION_VALUES , 0x33FB0D11, 0x64A3, 0x4FAC, 0xB4, 0xC7, 0x3D, 0xFE, 0xAA, 0x99, 0xB0, 0x51 , 1001 ); 
// 
// WPD_PROPERTY_CLASS_EXTENSION_DEVICE_INFORMATION_WRITE_RESULTS 
//   [ VT_UNKNOWN ] This is an IPortableDeviceValues which contains the result of each value write operation.
DEFINE_PROPERTYKEY( WPD_PROPERTY_CLASS_EXTENSION_DEVICE_INFORMATION_WRITE_RESULTS , 0x33FB0D11, 0x64A3, 0x4FAC, 0xB4, 0xC7, 0x3D, 0xFE, 0xAA, 0x99, 0xB0, 0x51 , 1002 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_NETWORK_CONFIGURATION 
* 
* The commands in this category are used for Network Association and WiFi Configuration. 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_NETWORK_CONFIGURATION , 0x78F9C6FC, 0x79B8, 0x473C, 0x90, 0x60, 0x6B, 0xD2, 0x3D, 0xD0, 0x72, 0xC4 ); 

// ======== Commands ========

// 
// WPD_COMMAND_GENERATE_KEYPAIR 
//     Initiates the generation of a public/private key pair and returns the public key. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     None 
//  Results: 
//     [ Required ] WPD_PROPERTY_PUBLIC_KEY 
DEFINE_PROPERTYKEY( WPD_COMMAND_GENERATE_KEYPAIR , 0x78F9C6FC, 0x79B8, 0x473C, 0x90, 0x60, 0x6B, 0xD2, 0x3D, 0xD0, 0x72, 0xC4 , 2 ); 
// 
// WPD_COMMAND_COMMIT_KEYPAIR 
//     Commits a public/private key pair. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     None 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_COMMIT_KEYPAIR , 0x78F9C6FC, 0x79B8, 0x473C, 0x90, 0x60, 0x6B, 0xD2, 0x3D, 0xD0, 0x72, 0xC4 , 3 ); 
// 
// WPD_COMMAND_PROCESS_WIRELESS_PROFILE 
//     Initiates the processing of a Wireless Profile file. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_OBJECT_ID 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_PROCESS_WIRELESS_PROFILE , 0x78F9C6FC, 0x79B8, 0x473C, 0x90, 0x60, 0x6B, 0xD2, 0x3D, 0xD0, 0x72, 0xC4 , 4 ); 

// ======== Command Parameters ======== 

// 
// WPD_PROPERTY_PUBLIC_KEY 
//   [ VT_VECTOR|VT_UI1 ] A public key generated for RSA key exchange. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_PUBLIC_KEY , 0x78F9C6FC, 0x79B8, 0x473C, 0x90, 0x60, 0x6B, 0xD2, 0x3D, 0xD0, 0x72, 0xC4 , 1001 ); 

/**************************************************************************** 
* This section defines Structures and Macros used by driver writers to 
* simplify Wpd Command Access checks. 
* Sample Usage: 
* 
* - Add table used to lookup the Access required for Wpd Commands 
* BEGIN_WPD_COMMAND_ACCESS_MAP(g_WpdCommandAccessMap) 
*    DECLARE_WPD_STANDARD_COMMAND_ACCESS_ENTRIES 
*    - Add any custom commands here e.g. 
*    WPD_COMMAND_ACCESS_ENTRY(MyCustomCommand, WPD_COMMAND_ACCESS_READWRITE) 
* END_WPD_COMMAND_ACCESS_MAP 
* - This enables the driver to use VERIFY_WPD_COMMAND_ACCESS to check command access function for us. 
* DECLARE_VERIFY_WPD_COMMAND_ACCESS; 
* ... 
* - When the driver receives a WPD IOCTL, it can check that the IOCTL specified matches 
* the command payload with: 
*    hr = VERIFY_WPD_COMMAND_ACCESS(ControlCode, pParams, g_WpdCommandAccessMap); 
****************************************************************************/ 

// Structure used as an entry in the Command / Access lookup table. 
typedef struct tagWPD_COMMAND_ACCESS_LOOKUP_ENTRY 
{ 
    PROPERTYKEY Command; 
    DWORD AccessType; 
    PROPERTYKEY AccessProperty; 
} WPD_COMMAND_ACCESS_LOOKUP_ENTRY; 

// Used to start a declaration of a WPD Command Access Lookup Map. This macro is usually followed by: 
// DECLARE_WPD_STANDARD_COMMAND_ACCESS_ENTRIES 
// Zero or more WPD_COMMAND_ACCESS_ENTRY or WPD_COMMAND_ACCESS_PROPERTY_ENTRY macros (one for every custom command). 
// The Map is ended with END_WPD_COMMAND_ACCESS_MAP. 
#define BEGIN_WPD_COMMAND_ACCESS_MAP(x) static WPD_COMMAND_ACCESS_LOOKUP_ENTRY x[] = {

// Ends a WPD Command Access Lookup Map started with BEGIN_WPD_COMMAND_ACCESS_MAP 
#define END_WPD_COMMAND_ACCESS_MAP { WPD_PROPERTY_NULL, 0, WPD_PROPERTY_NULL }, };

// Adds a custom entry to a WPD Command Access Lookup Map started with BEGIN_WPD_COMMAND_ACCESS_MAP 
#define WPD_COMMAND_ACCESS_ENTRY(WpdCommand, WpdCommandAccessType) { WpdCommand, WpdCommandAccessType, WPD_PROPERTY_NULL },

// Adds a custom entry to a WPD Command Access Lookup Map started with BEGIN_WPD_COMMAND_ACCESS_MAP 
#define WPD_COMMAND_ACCESS_PROPERTY_ENTRY(WpdCommand, WpdCommandAccessType, WpdAccessProperty) { WpdCommand, WpdCommandAccessType, WpdAccessProperty },

// Declares entries for all the WPD Commands contained in this header file. Used after BEGIN_WPD_COMMAND_ACCESS_MAP. 
#define DECLARE_WPD_STANDARD_COMMAND_ACCESS_ENTRIES \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_COMMON_RESET_DEVICE, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_COMMON_GET_OBJECT_IDS_FROM_PERSISTENT_UNIQUE_IDS, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_COMMON_SAVE_CLIENT_INFORMATION, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_ENUMERATION_START_FIND, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_ENUMERATION_FIND_NEXT, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_ENUMERATION_END_FIND, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_GET_SUPPORTED, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_GET_ATTRIBUTES, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_GET, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_SET, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_GET_ALL, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_DELETE, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_LIST_START, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_LIST_NEXT, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_LIST_END, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_FORMAT_START, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_FORMAT_NEXT, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_FORMAT_END, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_SET_VALUES_BY_OBJECT_LIST_START, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_SET_VALUES_BY_OBJECT_LIST_NEXT, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_SET_VALUES_BY_OBJECT_LIST_END, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_RESOURCES_GET_SUPPORTED, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_RESOURCES_GET_ATTRIBUTES, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_RESOURCES_OPEN, WPD_COMMAND_ACCESS_FROM_PROPERTY_WITH_STGM_ACCESS, WPD_PROPERTY_OBJECT_RESOURCES_ACCESS_MODE ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_RESOURCES_READ, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_RESOURCES_WRITE, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_RESOURCES_CLOSE, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_RESOURCES_DELETE, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_RESOURCES_CREATE_RESOURCE, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_RESOURCES_REVERT, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_RESOURCES_SEEK, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_MANAGEMENT_CREATE_OBJECT_WITH_PROPERTIES_ONLY, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_MANAGEMENT_CREATE_OBJECT_WITH_PROPERTIES_AND_DATA, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_MANAGEMENT_WRITE_OBJECT_DATA, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_MANAGEMENT_COMMIT_OBJECT, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_MANAGEMENT_REVERT_OBJECT, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_MANAGEMENT_DELETE_OBJECTS, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_MANAGEMENT_MOVE_OBJECTS, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_MANAGEMENT_COPY_OBJECTS, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_COMMANDS, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_CAPABILITIES_GET_COMMAND_OPTIONS, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_FUNCTIONAL_CATEGORIES, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_CAPABILITIES_GET_FUNCTIONAL_OBJECTS, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_CONTENT_TYPES, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_FORMATS, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_FORMAT_PROPERTIES, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_CAPABILITIES_GET_FIXED_PROPERTY_ATTRIBUTES, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_EVENTS, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_CAPABILITIES_GET_EVENT_OPTIONS, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_STORAGE_FORMAT, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_STORAGE_EJECT, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_SMS_SEND, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_STILL_IMAGE_CAPTURE_INITIATE, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_MEDIA_CAPTURE_START, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_MEDIA_CAPTURE_STOP, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_MEDIA_CAPTURE_PAUSE, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_DEVICE_HINTS_GET_CONTENT_LOCATION, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_CLASS_EXTENSION_WRITE_DEVICE_INFORMATION, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_GENERATE_KEYPAIR, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_COMMIT_KEYPAIR, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_PROCESS_WIRELESS_PROFILE, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \


// Declares an instance of the function used to check whether a WPD Command is in the driver's WPD Command Access Map. 
// Driver writers should not call this function directly, but should instead use the IS_COMMAND_IN_WPD_COMMAND_ACCESS_MAP alias. 
#define DECLARE_IS_COMMAND_IN_WPD_COMMAND_ACCESS_MAP() \
BOOL IsCommandInWpdCommandAccessMap( \
    REFPROPERTYKEY                       WpdCommand, \
    __in WPD_COMMAND_ACCESS_LOOKUP_ENTRY *pCommandAccessLookupMap) \
{ \
    BOOL bRet = FALSE; \
    if(pCommandParams == NULL) \
    { \
        return E_POINTER; \
    } \
    while(pCommandAccessLookupMap[dwMapIndex++].Command != WPD_PROPERTY_NULL) \
    { \
        if(IsEqualPropertyKey(pCommandAccessLookupMap[dwMapIndex].Command), WpdCommand) \
        { \
            bRet = TRUE; \
            break; \
        } \
        dwMapIndex++; \
    } \
    return bRet; \
};
        
// This macro is an alias for the function used to check whether a WPD Command is in the driver's WPD Command Access Map (see BEGIN_WPD_COMMAND_ACCESS_MAP) 
#define IS_COMMAND_IN_WPD_COMMAND_ACCESS_MAP IsCommandInWpdCommandAccessMap


// Declares an instance of the function used to verify that WPD Commands are sent with the appropriate Access Flags in the IOCTL.
// Driver writers should not call this function directly, but should instead use the VERIFY_WPD_COMMAND_ACCESS alias.
#define DECLARE_VERIFY_WPD_COMMAND_ACCESS \
HRESULT VerifyWpdCommandAccessFromMap(  \
    const DWORD                          ControlCode, \
    __in IPortableDeviceValues           *pCommandParams, \
    __in WPD_COMMAND_ACCESS_LOOKUP_ENTRY *pCommandAccessLookupMap) \
{ \
    HRESULT     hr                      = S_OK; \
    DWORD       dwMapIndex              = 0; \
    PROPERTYKEY WpdCommand              = WPD_PROPERTY_NULL; \
    DWORD       dwExpectedControlCode   = IOCTL_WPD_MESSAGE_READWRITE_ACCESS; \
    if((pCommandParams == NULL) || (pCommandAccessLookupMap == NULL)) \
    { \
        return E_POINTER; \
    } \
    if(ControlCode == IOCTL_WPD_MESSAGE_READWRITE_ACCESS) \
    { \
        return S_OK; \
    } \
    hr = pCommandParams->GetGuidValue(WPD_PROPERTY_COMMON_COMMAND_CATEGORY, &WpdCommand.fmtid); \
    if(SUCCEEDED(hr)) \
    { \
        hr = pCommandParams->GetUnsignedIntegerValue(WPD_PROPERTY_COMMON_COMMAND_ID, &WpdCommand.pid); \
        if(SUCCEEDED(hr)) \
        { \
            while(!IsEqualPropertyKey(pCommandAccessLookupMap[dwMapIndex].Command, WPD_PROPERTY_NULL)) \
            { \
                if(IsEqualPropertyKey(pCommandAccessLookupMap[dwMapIndex].Command, WpdCommand)) \
                { \
                    switch(pCommandAccessLookupMap[dwMapIndex].AccessType) \
                    { \
                        case WPD_COMMAND_ACCESS_READ: \
                            { \
                                dwExpectedControlCode = IOCTL_WPD_MESSAGE_READ_ACCESS; \
                            } \
                            break; \
                        case WPD_COMMAND_ACCESS_READWRITE: \
                            { \
                                dwExpectedControlCode = IOCTL_WPD_MESSAGE_READWRITE_ACCESS; \
                            } \
                            break; \
                        case WPD_COMMAND_ACCESS_FROM_PROPERTY_WITH_STGM_ACCESS: \
                            { \
                                DWORD dwAccessPropVal = STGM_READWRITE; \
                                HRESULT hrTemp = S_OK; \
                                hrTemp = pCommandParams->GetUnsignedIntegerValue(pCommandAccessLookupMap[dwMapIndex].AccessProperty, &dwAccessPropVal); \
                                if(dwAccessPropVal == STGM_READ) \
                                { \
                                    dwExpectedControlCode = IOCTL_WPD_MESSAGE_READ_ACCESS; \
                                } \
                                else \
                                { \
                                    dwExpectedControlCode = IOCTL_WPD_MESSAGE_READWRITE_ACCESS; \
                                } \
                            } \
                            break; \
                        case WPD_COMMAND_ACCESS_FROM_PROPERTY_WITH_FILE_ACCESS: \
                            { \
                                DWORD dwAccessPropVal = FILE_READ_ACCESS; \
                                HRESULT hrTemp = S_OK; \
                                hrTemp = pCommandParams->GetUnsignedIntegerValue(pCommandAccessLookupMap[dwMapIndex].AccessProperty, &dwAccessPropVal); \
                                if(dwAccessPropVal == FILE_READ_ACCESS) \
                                { \
                                    dwExpectedControlCode = IOCTL_WPD_MESSAGE_READ_ACCESS; \
                                } \
                                else \
                                { \
                                    dwExpectedControlCode = IOCTL_WPD_MESSAGE_READWRITE_ACCESS; \
                                } \
                            } \
                            break; \
                        default: \
                            { \
                                dwExpectedControlCode = IOCTL_WPD_MESSAGE_READWRITE_ACCESS; \
                            } \
                            break; \
                    } \
                    break; \
                } \
                dwMapIndex++; \
            } \
        } \
    } \
    if(SUCCEEDED(hr)) \
    { \
        if(ControlCode != dwExpectedControlCode) \
        { \
            return E_INVALIDARG; \
        } \
    } \
    return hr; \
};
        
// This macro is an alias for the function used to verify that WPD Commands are sent with the appropriate Access Flags in the IOCTL 
#define VERIFY_WPD_COMMAND_ACCESS VerifyWpdCommandAccessFromMap

#endif // (_WIN32_WINNT >= 0x0501)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\PopPack.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/

#if ! (defined(lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 && !defined(_M_I86)) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(pop)
#else
#pragma pack()
#endif
#else
#pragma pack()
#endif
#endif // ! (defined(lint) || defined(RC_INVOKED))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\PortableDeviceApi.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for PortableDeviceApi.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __PortableDeviceApi_h__
#define __PortableDeviceApi_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPortableDeviceManager_FWD_DEFINED__
#define __IPortableDeviceManager_FWD_DEFINED__
typedef interface IPortableDeviceManager IPortableDeviceManager;
#endif 	/* __IPortableDeviceManager_FWD_DEFINED__ */


#ifndef __IPortableDevice_FWD_DEFINED__
#define __IPortableDevice_FWD_DEFINED__
typedef interface IPortableDevice IPortableDevice;
#endif 	/* __IPortableDevice_FWD_DEFINED__ */


#ifndef __IPortableDeviceContent_FWD_DEFINED__
#define __IPortableDeviceContent_FWD_DEFINED__
typedef interface IPortableDeviceContent IPortableDeviceContent;
#endif 	/* __IPortableDeviceContent_FWD_DEFINED__ */


#ifndef __IEnumPortableDeviceObjectIDs_FWD_DEFINED__
#define __IEnumPortableDeviceObjectIDs_FWD_DEFINED__
typedef interface IEnumPortableDeviceObjectIDs IEnumPortableDeviceObjectIDs;
#endif 	/* __IEnumPortableDeviceObjectIDs_FWD_DEFINED__ */


#ifndef __IPortableDeviceProperties_FWD_DEFINED__
#define __IPortableDeviceProperties_FWD_DEFINED__
typedef interface IPortableDeviceProperties IPortableDeviceProperties;
#endif 	/* __IPortableDeviceProperties_FWD_DEFINED__ */


#ifndef __IPortableDeviceResources_FWD_DEFINED__
#define __IPortableDeviceResources_FWD_DEFINED__
typedef interface IPortableDeviceResources IPortableDeviceResources;
#endif 	/* __IPortableDeviceResources_FWD_DEFINED__ */


#ifndef __IPortableDeviceCapabilities_FWD_DEFINED__
#define __IPortableDeviceCapabilities_FWD_DEFINED__
typedef interface IPortableDeviceCapabilities IPortableDeviceCapabilities;
#endif 	/* __IPortableDeviceCapabilities_FWD_DEFINED__ */


#ifndef __IPortableDeviceEventCallback_FWD_DEFINED__
#define __IPortableDeviceEventCallback_FWD_DEFINED__
typedef interface IPortableDeviceEventCallback IPortableDeviceEventCallback;
#endif 	/* __IPortableDeviceEventCallback_FWD_DEFINED__ */


#ifndef __IPortableDeviceDataStream_FWD_DEFINED__
#define __IPortableDeviceDataStream_FWD_DEFINED__
typedef interface IPortableDeviceDataStream IPortableDeviceDataStream;
#endif 	/* __IPortableDeviceDataStream_FWD_DEFINED__ */


#ifndef __IPortableDevicePropertiesBulk_FWD_DEFINED__
#define __IPortableDevicePropertiesBulk_FWD_DEFINED__
typedef interface IPortableDevicePropertiesBulk IPortableDevicePropertiesBulk;
#endif 	/* __IPortableDevicePropertiesBulk_FWD_DEFINED__ */


#ifndef __IPortableDevicePropertiesBulkCallback_FWD_DEFINED__
#define __IPortableDevicePropertiesBulkCallback_FWD_DEFINED__
typedef interface IPortableDevicePropertiesBulkCallback IPortableDevicePropertiesBulkCallback;
#endif 	/* __IPortableDevicePropertiesBulkCallback_FWD_DEFINED__ */


#ifndef __PortableDevice_FWD_DEFINED__
#define __PortableDevice_FWD_DEFINED__

#ifdef __cplusplus
typedef class PortableDevice PortableDevice;
#else
typedef struct PortableDevice PortableDevice;
#endif /* __cplusplus */

#endif 	/* __PortableDevice_FWD_DEFINED__ */


#ifndef __PortableDeviceManager_FWD_DEFINED__
#define __PortableDeviceManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class PortableDeviceManager PortableDeviceManager;
#else
typedef struct PortableDeviceManager PortableDeviceManager;
#endif /* __cplusplus */

#endif 	/* __PortableDeviceManager_FWD_DEFINED__ */


/* header files for imported files */
#include "propidl.h"
#include "PortableDeviceTypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_PortableDeviceApi_0000_0000 */
/* [local] */ 

#if (_WIN32_WINNT >= 0x0501) // XP and later













extern RPC_IF_HANDLE __MIDL_itf_PortableDeviceApi_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_PortableDeviceApi_0000_0000_v0_0_s_ifspec;

#ifndef __IPortableDeviceManager_INTERFACE_DEFINED__
#define __IPortableDeviceManager_INTERFACE_DEFINED__

/* interface IPortableDeviceManager */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPortableDeviceManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a1567595-4c2f-4574-a6fa-ecef917b9a40")
    IPortableDeviceManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDevices( 
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt LPWSTR *pPnPDeviceIDs,
            /* [out][in] */ __RPC__inout DWORD *pcPnPDeviceIDs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RefreshDeviceList( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceFriendlyName( 
            /* [in] */ __RPC__in LPCWSTR pszPnPDeviceID,
            /* [unique][out][in] */ __RPC__inout_opt WCHAR *pDeviceFriendlyName,
            /* [out][in] */ __RPC__inout DWORD *pcchDeviceFriendlyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceDescription( 
            /* [in] */ __RPC__in LPCWSTR pszPnPDeviceID,
            /* [unique][out][in] */ __RPC__inout_opt WCHAR *pDeviceDescription,
            /* [out][in] */ __RPC__inout DWORD *pcchDeviceDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceManufacturer( 
            /* [in] */ __RPC__in LPCWSTR pszPnPDeviceID,
            /* [unique][out][in] */ __RPC__inout_opt WCHAR *pDeviceManufacturer,
            /* [out][in] */ __RPC__inout DWORD *pcchDeviceManufacturer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceProperty( 
            /* [in] */ __RPC__in LPCWSTR pszPnPDeviceID,
            /* [in] */ __RPC__in LPCWSTR pszDevicePropertyName,
            /* [unique][out][in] */ __RPC__inout_opt BYTE *pData,
            /* [unique][out][in] */ __RPC__inout_opt DWORD *pcbData,
            /* [unique][out][in] */ __RPC__inout_opt DWORD *pdwType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrivateDevices( 
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt LPWSTR *pPnPDeviceIDs,
            /* [out][in] */ __RPC__inout DWORD *pcPnPDeviceIDs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPortableDeviceManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPortableDeviceManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPortableDeviceManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPortableDeviceManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDevices )( 
            IPortableDeviceManager * This,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt LPWSTR *pPnPDeviceIDs,
            /* [out][in] */ __RPC__inout DWORD *pcPnPDeviceIDs);
        
        HRESULT ( STDMETHODCALLTYPE *RefreshDeviceList )( 
            IPortableDeviceManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceFriendlyName )( 
            IPortableDeviceManager * This,
            /* [in] */ __RPC__in LPCWSTR pszPnPDeviceID,
            /* [unique][out][in] */ __RPC__inout_opt WCHAR *pDeviceFriendlyName,
            /* [out][in] */ __RPC__inout DWORD *pcchDeviceFriendlyName);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceDescription )( 
            IPortableDeviceManager * This,
            /* [in] */ __RPC__in LPCWSTR pszPnPDeviceID,
            /* [unique][out][in] */ __RPC__inout_opt WCHAR *pDeviceDescription,
            /* [out][in] */ __RPC__inout DWORD *pcchDeviceDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceManufacturer )( 
            IPortableDeviceManager * This,
            /* [in] */ __RPC__in LPCWSTR pszPnPDeviceID,
            /* [unique][out][in] */ __RPC__inout_opt WCHAR *pDeviceManufacturer,
            /* [out][in] */ __RPC__inout DWORD *pcchDeviceManufacturer);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceProperty )( 
            IPortableDeviceManager * This,
            /* [in] */ __RPC__in LPCWSTR pszPnPDeviceID,
            /* [in] */ __RPC__in LPCWSTR pszDevicePropertyName,
            /* [unique][out][in] */ __RPC__inout_opt BYTE *pData,
            /* [unique][out][in] */ __RPC__inout_opt DWORD *pcbData,
            /* [unique][out][in] */ __RPC__inout_opt DWORD *pdwType);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateDevices )( 
            IPortableDeviceManager * This,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt LPWSTR *pPnPDeviceIDs,
            /* [out][in] */ __RPC__inout DWORD *pcPnPDeviceIDs);
        
        END_INTERFACE
    } IPortableDeviceManagerVtbl;

    interface IPortableDeviceManager
    {
        CONST_VTBL struct IPortableDeviceManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPortableDeviceManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPortableDeviceManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPortableDeviceManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPortableDeviceManager_GetDevices(This,pPnPDeviceIDs,pcPnPDeviceIDs)	\
    ( (This)->lpVtbl -> GetDevices(This,pPnPDeviceIDs,pcPnPDeviceIDs) ) 

#define IPortableDeviceManager_RefreshDeviceList(This)	\
    ( (This)->lpVtbl -> RefreshDeviceList(This) ) 

#define IPortableDeviceManager_GetDeviceFriendlyName(This,pszPnPDeviceID,pDeviceFriendlyName,pcchDeviceFriendlyName)	\
    ( (This)->lpVtbl -> GetDeviceFriendlyName(This,pszPnPDeviceID,pDeviceFriendlyName,pcchDeviceFriendlyName) ) 

#define IPortableDeviceManager_GetDeviceDescription(This,pszPnPDeviceID,pDeviceDescription,pcchDeviceDescription)	\
    ( (This)->lpVtbl -> GetDeviceDescription(This,pszPnPDeviceID,pDeviceDescription,pcchDeviceDescription) ) 

#define IPortableDeviceManager_GetDeviceManufacturer(This,pszPnPDeviceID,pDeviceManufacturer,pcchDeviceManufacturer)	\
    ( (This)->lpVtbl -> GetDeviceManufacturer(This,pszPnPDeviceID,pDeviceManufacturer,pcchDeviceManufacturer) ) 

#define IPortableDeviceManager_GetDeviceProperty(This,pszPnPDeviceID,pszDevicePropertyName,pData,pcbData,pdwType)	\
    ( (This)->lpVtbl -> GetDeviceProperty(This,pszPnPDeviceID,pszDevicePropertyName,pData,pcbData,pdwType) ) 

#define IPortableDeviceManager_GetPrivateDevices(This,pPnPDeviceIDs,pcPnPDeviceIDs)	\
    ( (This)->lpVtbl -> GetPrivateDevices(This,pPnPDeviceIDs,pcPnPDeviceIDs) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPortableDeviceManager_INTERFACE_DEFINED__ */


#ifndef __IPortableDevice_INTERFACE_DEFINED__
#define __IPortableDevice_INTERFACE_DEFINED__

/* interface IPortableDevice */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPortableDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("625e2df8-6392-4cf0-9ad1-3cfa5f17775c")
    IPortableDevice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ __RPC__in LPCWSTR pszPnPDeviceID,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pClientInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendCommand( 
            /* [in] */ const DWORD dwFlags,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pParameters,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppResults) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Content( 
            /* [out] */ __RPC__deref_out_opt IPortableDeviceContent **ppContent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Capabilities( 
            /* [out] */ __RPC__deref_out_opt IPortableDeviceCapabilities **ppCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ const DWORD dwFlags,
            /* [in] */ __RPC__in_opt IPortableDeviceEventCallback *pCallback,
            /* [unique][in] */ __RPC__in_opt IPortableDeviceValues *pParameters,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ __RPC__in LPCWSTR pszCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPnPDeviceID( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszPnPDeviceID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPortableDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPortableDevice * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPortableDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPortableDevice * This);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            IPortableDevice * This,
            /* [in] */ __RPC__in LPCWSTR pszPnPDeviceID,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pClientInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SendCommand )( 
            IPortableDevice * This,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pParameters,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppResults);
        
        HRESULT ( STDMETHODCALLTYPE *Content )( 
            IPortableDevice * This,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceContent **ppContent);
        
        HRESULT ( STDMETHODCALLTYPE *Capabilities )( 
            IPortableDevice * This,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceCapabilities **ppCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IPortableDevice * This);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IPortableDevice * This);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            IPortableDevice * This,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ __RPC__in_opt IPortableDeviceEventCallback *pCallback,
            /* [unique][in] */ __RPC__in_opt IPortableDeviceValues *pParameters,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            IPortableDevice * This,
            /* [in] */ __RPC__in LPCWSTR pszCookie);
        
        HRESULT ( STDMETHODCALLTYPE *GetPnPDeviceID )( 
            IPortableDevice * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszPnPDeviceID);
        
        END_INTERFACE
    } IPortableDeviceVtbl;

    interface IPortableDevice
    {
        CONST_VTBL struct IPortableDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPortableDevice_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPortableDevice_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPortableDevice_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPortableDevice_Open(This,pszPnPDeviceID,pClientInfo)	\
    ( (This)->lpVtbl -> Open(This,pszPnPDeviceID,pClientInfo) ) 

#define IPortableDevice_SendCommand(This,dwFlags,pParameters,ppResults)	\
    ( (This)->lpVtbl -> SendCommand(This,dwFlags,pParameters,ppResults) ) 

#define IPortableDevice_Content(This,ppContent)	\
    ( (This)->lpVtbl -> Content(This,ppContent) ) 

#define IPortableDevice_Capabilities(This,ppCapabilities)	\
    ( (This)->lpVtbl -> Capabilities(This,ppCapabilities) ) 

#define IPortableDevice_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define IPortableDevice_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#define IPortableDevice_Advise(This,dwFlags,pCallback,pParameters,ppszCookie)	\
    ( (This)->lpVtbl -> Advise(This,dwFlags,pCallback,pParameters,ppszCookie) ) 

#define IPortableDevice_Unadvise(This,pszCookie)	\
    ( (This)->lpVtbl -> Unadvise(This,pszCookie) ) 

#define IPortableDevice_GetPnPDeviceID(This,ppszPnPDeviceID)	\
    ( (This)->lpVtbl -> GetPnPDeviceID(This,ppszPnPDeviceID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPortableDevice_INTERFACE_DEFINED__ */


#ifndef __IPortableDeviceContent_INTERFACE_DEFINED__
#define __IPortableDeviceContent_INTERFACE_DEFINED__

/* interface IPortableDeviceContent */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPortableDeviceContent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6a96ed84-7c73-4480-9938-bf5af477d426")
    IPortableDeviceContent : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumObjects( 
            /* [in] */ const DWORD dwFlags,
            /* [in] */ __RPC__in LPCWSTR pszParentObjectID,
            /* [unique][in] */ __RPC__in_opt IPortableDeviceValues *pFilter,
            /* [out] */ __RPC__deref_out_opt IEnumPortableDeviceObjectIDs **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Properties( 
            /* [out] */ __RPC__deref_out_opt IPortableDeviceProperties **ppProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Transfer( 
            /* [out] */ __RPC__deref_out_opt IPortableDeviceResources **ppResources) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateObjectWithPropertiesOnly( 
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pValues,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt LPWSTR *ppszObjectID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateObjectWithPropertiesAndData( 
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pValues,
            /* [out] */ __RPC__deref_out_opt IStream **ppData,
            /* [unique][out][in] */ __RPC__inout_opt DWORD *pdwOptimalWriteBufferSize,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt LPWSTR *ppszCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ const DWORD dwOptions,
            /* [in] */ __RPC__in_opt IPortableDevicePropVariantCollection *pObjectIDs,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt IPortableDevicePropVariantCollection **ppResults) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectIDsFromPersistentUniqueIDs( 
            /* [in] */ __RPC__in_opt IPortableDevicePropVariantCollection *pPersistentUniqueIDs,
            /* [out] */ __RPC__deref_out_opt IPortableDevicePropVariantCollection **ppObjectIDs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Move( 
            /* [in] */ __RPC__in_opt IPortableDevicePropVariantCollection *pObjectIDs,
            /* [in] */ __RPC__in LPCWSTR pszDestinationFolderObjectID,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt IPortableDevicePropVariantCollection **ppResults) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Copy( 
            /* [in] */ __RPC__in_opt IPortableDevicePropVariantCollection *pObjectIDs,
            /* [in] */ __RPC__in LPCWSTR pszDestinationFolderObjectID,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt IPortableDevicePropVariantCollection **ppResults) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPortableDeviceContentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPortableDeviceContent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPortableDeviceContent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPortableDeviceContent * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumObjects )( 
            IPortableDeviceContent * This,
            /* [in] */ const DWORD dwFlags,
            /* [in] */ __RPC__in LPCWSTR pszParentObjectID,
            /* [unique][in] */ __RPC__in_opt IPortableDeviceValues *pFilter,
            /* [out] */ __RPC__deref_out_opt IEnumPortableDeviceObjectIDs **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Properties )( 
            IPortableDeviceContent * This,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceProperties **ppProperties);
        
        HRESULT ( STDMETHODCALLTYPE *Transfer )( 
            IPortableDeviceContent * This,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceResources **ppResources);
        
        HRESULT ( STDMETHODCALLTYPE *CreateObjectWithPropertiesOnly )( 
            IPortableDeviceContent * This,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pValues,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt LPWSTR *ppszObjectID);
        
        HRESULT ( STDMETHODCALLTYPE *CreateObjectWithPropertiesAndData )( 
            IPortableDeviceContent * This,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pValues,
            /* [out] */ __RPC__deref_out_opt IStream **ppData,
            /* [unique][out][in] */ __RPC__inout_opt DWORD *pdwOptimalWriteBufferSize,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt LPWSTR *ppszCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IPortableDeviceContent * This,
            /* [in] */ const DWORD dwOptions,
            /* [in] */ __RPC__in_opt IPortableDevicePropVariantCollection *pObjectIDs,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt IPortableDevicePropVariantCollection **ppResults);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectIDsFromPersistentUniqueIDs )( 
            IPortableDeviceContent * This,
            /* [in] */ __RPC__in_opt IPortableDevicePropVariantCollection *pPersistentUniqueIDs,
            /* [out] */ __RPC__deref_out_opt IPortableDevicePropVariantCollection **ppObjectIDs);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IPortableDeviceContent * This);
        
        HRESULT ( STDMETHODCALLTYPE *Move )( 
            IPortableDeviceContent * This,
            /* [in] */ __RPC__in_opt IPortableDevicePropVariantCollection *pObjectIDs,
            /* [in] */ __RPC__in LPCWSTR pszDestinationFolderObjectID,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt IPortableDevicePropVariantCollection **ppResults);
        
        HRESULT ( STDMETHODCALLTYPE *Copy )( 
            IPortableDeviceContent * This,
            /* [in] */ __RPC__in_opt IPortableDevicePropVariantCollection *pObjectIDs,
            /* [in] */ __RPC__in LPCWSTR pszDestinationFolderObjectID,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt IPortableDevicePropVariantCollection **ppResults);
        
        END_INTERFACE
    } IPortableDeviceContentVtbl;

    interface IPortableDeviceContent
    {
        CONST_VTBL struct IPortableDeviceContentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPortableDeviceContent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPortableDeviceContent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPortableDeviceContent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPortableDeviceContent_EnumObjects(This,dwFlags,pszParentObjectID,pFilter,ppEnum)	\
    ( (This)->lpVtbl -> EnumObjects(This,dwFlags,pszParentObjectID,pFilter,ppEnum) ) 

#define IPortableDeviceContent_Properties(This,ppProperties)	\
    ( (This)->lpVtbl -> Properties(This,ppProperties) ) 

#define IPortableDeviceContent_Transfer(This,ppResources)	\
    ( (This)->lpVtbl -> Transfer(This,ppResources) ) 

#define IPortableDeviceContent_CreateObjectWithPropertiesOnly(This,pValues,ppszObjectID)	\
    ( (This)->lpVtbl -> CreateObjectWithPropertiesOnly(This,pValues,ppszObjectID) ) 

#define IPortableDeviceContent_CreateObjectWithPropertiesAndData(This,pValues,ppData,pdwOptimalWriteBufferSize,ppszCookie)	\
    ( (This)->lpVtbl -> CreateObjectWithPropertiesAndData(This,pValues,ppData,pdwOptimalWriteBufferSize,ppszCookie) ) 

#define IPortableDeviceContent_Delete(This,dwOptions,pObjectIDs,ppResults)	\
    ( (This)->lpVtbl -> Delete(This,dwOptions,pObjectIDs,ppResults) ) 

#define IPortableDeviceContent_GetObjectIDsFromPersistentUniqueIDs(This,pPersistentUniqueIDs,ppObjectIDs)	\
    ( (This)->lpVtbl -> GetObjectIDsFromPersistentUniqueIDs(This,pPersistentUniqueIDs,ppObjectIDs) ) 

#define IPortableDeviceContent_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define IPortableDeviceContent_Move(This,pObjectIDs,pszDestinationFolderObjectID,ppResults)	\
    ( (This)->lpVtbl -> Move(This,pObjectIDs,pszDestinationFolderObjectID,ppResults) ) 

#define IPortableDeviceContent_Copy(This,pObjectIDs,pszDestinationFolderObjectID,ppResults)	\
    ( (This)->lpVtbl -> Copy(This,pObjectIDs,pszDestinationFolderObjectID,ppResults) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPortableDeviceContent_INTERFACE_DEFINED__ */


#ifndef __IEnumPortableDeviceObjectIDs_INTERFACE_DEFINED__
#define __IEnumPortableDeviceObjectIDs_INTERFACE_DEFINED__

/* interface IEnumPortableDeviceObjectIDs */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumPortableDeviceObjectIDs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10ece955-cf41-4728-bfa0-41eedf1bbf19")
    IEnumPortableDeviceObjectIDs : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cObjects,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(cObjects, *pcFetched) LPWSTR *pObjIDs,
            /* [unique][out][in] */ __RPC__inout_opt ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cObjects) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumPortableDeviceObjectIDs **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumPortableDeviceObjectIDsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumPortableDeviceObjectIDs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumPortableDeviceObjectIDs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumPortableDeviceObjectIDs * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumPortableDeviceObjectIDs * This,
            /* [in] */ ULONG cObjects,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(cObjects, *pcFetched) LPWSTR *pObjIDs,
            /* [unique][out][in] */ __RPC__inout_opt ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumPortableDeviceObjectIDs * This,
            /* [in] */ ULONG cObjects);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumPortableDeviceObjectIDs * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumPortableDeviceObjectIDs * This,
            /* [out] */ __RPC__deref_out_opt IEnumPortableDeviceObjectIDs **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IEnumPortableDeviceObjectIDs * This);
        
        END_INTERFACE
    } IEnumPortableDeviceObjectIDsVtbl;

    interface IEnumPortableDeviceObjectIDs
    {
        CONST_VTBL struct IEnumPortableDeviceObjectIDsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumPortableDeviceObjectIDs_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumPortableDeviceObjectIDs_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumPortableDeviceObjectIDs_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumPortableDeviceObjectIDs_Next(This,cObjects,pObjIDs,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,cObjects,pObjIDs,pcFetched) ) 

#define IEnumPortableDeviceObjectIDs_Skip(This,cObjects)	\
    ( (This)->lpVtbl -> Skip(This,cObjects) ) 

#define IEnumPortableDeviceObjectIDs_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumPortableDeviceObjectIDs_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#define IEnumPortableDeviceObjectIDs_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumPortableDeviceObjectIDs_INTERFACE_DEFINED__ */


#ifndef __IPortableDeviceProperties_INTERFACE_DEFINED__
#define __IPortableDeviceProperties_INTERFACE_DEFINED__

/* interface IPortableDeviceProperties */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPortableDeviceProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7f6d695c-03df-4439-a809-59266beee3a6")
    IPortableDeviceProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSupportedProperties( 
            /* [in] */ __RPC__in LPCWSTR pszObjectID,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceKeyCollection **ppKeys) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyAttributes( 
            /* [in] */ __RPC__in LPCWSTR pszObjectID,
            /* [in] */ __RPC__in REFPROPERTYKEY Key,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValues( 
            /* [in] */ __RPC__in LPCWSTR pszObjectID,
            /* [unique][in] */ __RPC__in_opt IPortableDeviceKeyCollection *pKeys,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppValues) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValues( 
            /* [in] */ __RPC__in LPCWSTR pszObjectID,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pValues,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppResults) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ __RPC__in LPCWSTR pszObjectID,
            /* [in] */ __RPC__in_opt IPortableDeviceKeyCollection *pKeys) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPortableDevicePropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPortableDeviceProperties * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPortableDeviceProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPortableDeviceProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedProperties )( 
            IPortableDeviceProperties * This,
            /* [in] */ __RPC__in LPCWSTR pszObjectID,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceKeyCollection **ppKeys);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyAttributes )( 
            IPortableDeviceProperties * This,
            /* [in] */ __RPC__in LPCWSTR pszObjectID,
            /* [in] */ __RPC__in REFPROPERTYKEY Key,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetValues )( 
            IPortableDeviceProperties * This,
            /* [in] */ __RPC__in LPCWSTR pszObjectID,
            /* [unique][in] */ __RPC__in_opt IPortableDeviceKeyCollection *pKeys,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppValues);
        
        HRESULT ( STDMETHODCALLTYPE *SetValues )( 
            IPortableDeviceProperties * This,
            /* [in] */ __RPC__in LPCWSTR pszObjectID,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pValues,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppResults);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IPortableDeviceProperties * This,
            /* [in] */ __RPC__in LPCWSTR pszObjectID,
            /* [in] */ __RPC__in_opt IPortableDeviceKeyCollection *pKeys);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IPortableDeviceProperties * This);
        
        END_INTERFACE
    } IPortableDevicePropertiesVtbl;

    interface IPortableDeviceProperties
    {
        CONST_VTBL struct IPortableDevicePropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPortableDeviceProperties_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPortableDeviceProperties_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPortableDeviceProperties_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPortableDeviceProperties_GetSupportedProperties(This,pszObjectID,ppKeys)	\
    ( (This)->lpVtbl -> GetSupportedProperties(This,pszObjectID,ppKeys) ) 

#define IPortableDeviceProperties_GetPropertyAttributes(This,pszObjectID,Key,ppAttributes)	\
    ( (This)->lpVtbl -> GetPropertyAttributes(This,pszObjectID,Key,ppAttributes) ) 

#define IPortableDeviceProperties_GetValues(This,pszObjectID,pKeys,ppValues)	\
    ( (This)->lpVtbl -> GetValues(This,pszObjectID,pKeys,ppValues) ) 

#define IPortableDeviceProperties_SetValues(This,pszObjectID,pValues,ppResults)	\
    ( (This)->lpVtbl -> SetValues(This,pszObjectID,pValues,ppResults) ) 

#define IPortableDeviceProperties_Delete(This,pszObjectID,pKeys)	\
    ( (This)->lpVtbl -> Delete(This,pszObjectID,pKeys) ) 

#define IPortableDeviceProperties_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPortableDeviceProperties_INTERFACE_DEFINED__ */


#ifndef __IPortableDeviceResources_INTERFACE_DEFINED__
#define __IPortableDeviceResources_INTERFACE_DEFINED__

/* interface IPortableDeviceResources */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPortableDeviceResources;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fd8878ac-d841-4d17-891c-e6829cdb6934")
    IPortableDeviceResources : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSupportedResources( 
            /* [in] */ __RPC__in LPCWSTR pszObjectID,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceKeyCollection **ppKeys) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResourceAttributes( 
            /* [in] */ __RPC__in LPCWSTR pszObjectID,
            /* [in] */ __RPC__in REFPROPERTYKEY Key,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppResourceAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [in] */ __RPC__in LPCWSTR pszObjectID,
            /* [in] */ __RPC__in REFPROPERTYKEY Key,
            /* [in] */ const DWORD dwMode,
            /* [unique][out][in] */ __RPC__inout_opt DWORD *pdwOptimalBufferSize,
            /* [out] */ __RPC__deref_out_opt IStream **ppStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ __RPC__in LPCWSTR pszObjectID,
            /* [in] */ __RPC__in_opt IPortableDeviceKeyCollection *pKeys) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateResource( 
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pResourceAttributes,
            /* [out] */ __RPC__deref_out_opt IStream **ppData,
            /* [unique][out][in] */ __RPC__inout_opt DWORD *pdwOptimalWriteBufferSize,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt LPWSTR *ppszCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPortableDeviceResourcesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPortableDeviceResources * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPortableDeviceResources * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPortableDeviceResources * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedResources )( 
            IPortableDeviceResources * This,
            /* [in] */ __RPC__in LPCWSTR pszObjectID,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceKeyCollection **ppKeys);
        
        HRESULT ( STDMETHODCALLTYPE *GetResourceAttributes )( 
            IPortableDeviceResources * This,
            /* [in] */ __RPC__in LPCWSTR pszObjectID,
            /* [in] */ __RPC__in REFPROPERTYKEY Key,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppResourceAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            IPortableDeviceResources * This,
            /* [in] */ __RPC__in LPCWSTR pszObjectID,
            /* [in] */ __RPC__in REFPROPERTYKEY Key,
            /* [in] */ const DWORD dwMode,
            /* [unique][out][in] */ __RPC__inout_opt DWORD *pdwOptimalBufferSize,
            /* [out] */ __RPC__deref_out_opt IStream **ppStream);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IPortableDeviceResources * This,
            /* [in] */ __RPC__in LPCWSTR pszObjectID,
            /* [in] */ __RPC__in_opt IPortableDeviceKeyCollection *pKeys);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IPortableDeviceResources * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateResource )( 
            IPortableDeviceResources * This,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pResourceAttributes,
            /* [out] */ __RPC__deref_out_opt IStream **ppData,
            /* [unique][out][in] */ __RPC__inout_opt DWORD *pdwOptimalWriteBufferSize,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt LPWSTR *ppszCookie);
        
        END_INTERFACE
    } IPortableDeviceResourcesVtbl;

    interface IPortableDeviceResources
    {
        CONST_VTBL struct IPortableDeviceResourcesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPortableDeviceResources_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPortableDeviceResources_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPortableDeviceResources_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPortableDeviceResources_GetSupportedResources(This,pszObjectID,ppKeys)	\
    ( (This)->lpVtbl -> GetSupportedResources(This,pszObjectID,ppKeys) ) 

#define IPortableDeviceResources_GetResourceAttributes(This,pszObjectID,Key,ppResourceAttributes)	\
    ( (This)->lpVtbl -> GetResourceAttributes(This,pszObjectID,Key,ppResourceAttributes) ) 

#define IPortableDeviceResources_GetStream(This,pszObjectID,Key,dwMode,pdwOptimalBufferSize,ppStream)	\
    ( (This)->lpVtbl -> GetStream(This,pszObjectID,Key,dwMode,pdwOptimalBufferSize,ppStream) ) 

#define IPortableDeviceResources_Delete(This,pszObjectID,pKeys)	\
    ( (This)->lpVtbl -> Delete(This,pszObjectID,pKeys) ) 

#define IPortableDeviceResources_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define IPortableDeviceResources_CreateResource(This,pResourceAttributes,ppData,pdwOptimalWriteBufferSize,ppszCookie)	\
    ( (This)->lpVtbl -> CreateResource(This,pResourceAttributes,ppData,pdwOptimalWriteBufferSize,ppszCookie) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPortableDeviceResources_INTERFACE_DEFINED__ */


#ifndef __IPortableDeviceCapabilities_INTERFACE_DEFINED__
#define __IPortableDeviceCapabilities_INTERFACE_DEFINED__

/* interface IPortableDeviceCapabilities */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPortableDeviceCapabilities;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2c8c6dbf-e3dc-4061-becc-8542e810d126")
    IPortableDeviceCapabilities : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSupportedCommands( 
            /* [out] */ __RPC__deref_out_opt IPortableDeviceKeyCollection **ppCommands) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCommandOptions( 
            /* [in] */ __RPC__in REFPROPERTYKEY Command,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionalCategories( 
            /* [out] */ __RPC__deref_out_opt IPortableDevicePropVariantCollection **ppCategories) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionalObjects( 
            /* [in] */ __RPC__in REFGUID Category,
            /* [out] */ __RPC__deref_out_opt IPortableDevicePropVariantCollection **ppObjectIDs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedContentTypes( 
            /* [in] */ __RPC__in REFGUID Category,
            /* [out] */ __RPC__deref_out_opt IPortableDevicePropVariantCollection **ppContentTypes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedFormats( 
            /* [in] */ __RPC__in REFGUID ContentType,
            /* [out] */ __RPC__deref_out_opt IPortableDevicePropVariantCollection **ppFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedFormatProperties( 
            /* [in] */ __RPC__in REFGUID Format,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceKeyCollection **ppKeys) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFixedPropertyAttributes( 
            /* [in] */ __RPC__in REFGUID Format,
            /* [in] */ __RPC__in REFPROPERTYKEY Key,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedEvents( 
            /* [out] */ __RPC__deref_out_opt IPortableDevicePropVariantCollection **ppEvents) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEventOptions( 
            /* [in] */ __RPC__in REFGUID Event,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPortableDeviceCapabilitiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPortableDeviceCapabilities * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPortableDeviceCapabilities * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPortableDeviceCapabilities * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedCommands )( 
            IPortableDeviceCapabilities * This,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceKeyCollection **ppCommands);
        
        HRESULT ( STDMETHODCALLTYPE *GetCommandOptions )( 
            IPortableDeviceCapabilities * This,
            /* [in] */ __RPC__in REFPROPERTYKEY Command,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppOptions);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionalCategories )( 
            IPortableDeviceCapabilities * This,
            /* [out] */ __RPC__deref_out_opt IPortableDevicePropVariantCollection **ppCategories);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionalObjects )( 
            IPortableDeviceCapabilities * This,
            /* [in] */ __RPC__in REFGUID Category,
            /* [out] */ __RPC__deref_out_opt IPortableDevicePropVariantCollection **ppObjectIDs);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedContentTypes )( 
            IPortableDeviceCapabilities * This,
            /* [in] */ __RPC__in REFGUID Category,
            /* [out] */ __RPC__deref_out_opt IPortableDevicePropVariantCollection **ppContentTypes);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedFormats )( 
            IPortableDeviceCapabilities * This,
            /* [in] */ __RPC__in REFGUID ContentType,
            /* [out] */ __RPC__deref_out_opt IPortableDevicePropVariantCollection **ppFormats);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedFormatProperties )( 
            IPortableDeviceCapabilities * This,
            /* [in] */ __RPC__in REFGUID Format,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceKeyCollection **ppKeys);
        
        HRESULT ( STDMETHODCALLTYPE *GetFixedPropertyAttributes )( 
            IPortableDeviceCapabilities * This,
            /* [in] */ __RPC__in REFGUID Format,
            /* [in] */ __RPC__in REFPROPERTYKEY Key,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IPortableDeviceCapabilities * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedEvents )( 
            IPortableDeviceCapabilities * This,
            /* [out] */ __RPC__deref_out_opt IPortableDevicePropVariantCollection **ppEvents);
        
        HRESULT ( STDMETHODCALLTYPE *GetEventOptions )( 
            IPortableDeviceCapabilities * This,
            /* [in] */ __RPC__in REFGUID Event,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppOptions);
        
        END_INTERFACE
    } IPortableDeviceCapabilitiesVtbl;

    interface IPortableDeviceCapabilities
    {
        CONST_VTBL struct IPortableDeviceCapabilitiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPortableDeviceCapabilities_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPortableDeviceCapabilities_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPortableDeviceCapabilities_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPortableDeviceCapabilities_GetSupportedCommands(This,ppCommands)	\
    ( (This)->lpVtbl -> GetSupportedCommands(This,ppCommands) ) 

#define IPortableDeviceCapabilities_GetCommandOptions(This,Command,ppOptions)	\
    ( (This)->lpVtbl -> GetCommandOptions(This,Command,ppOptions) ) 

#define IPortableDeviceCapabilities_GetFunctionalCategories(This,ppCategories)	\
    ( (This)->lpVtbl -> GetFunctionalCategories(This,ppCategories) ) 

#define IPortableDeviceCapabilities_GetFunctionalObjects(This,Category,ppObjectIDs)	\
    ( (This)->lpVtbl -> GetFunctionalObjects(This,Category,ppObjectIDs) ) 

#define IPortableDeviceCapabilities_GetSupportedContentTypes(This,Category,ppContentTypes)	\
    ( (This)->lpVtbl -> GetSupportedContentTypes(This,Category,ppContentTypes) ) 

#define IPortableDeviceCapabilities_GetSupportedFormats(This,ContentType,ppFormats)	\
    ( (This)->lpVtbl -> GetSupportedFormats(This,ContentType,ppFormats) ) 

#define IPortableDeviceCapabilities_GetSupportedFormatProperties(This,Format,ppKeys)	\
    ( (This)->lpVtbl -> GetSupportedFormatProperties(This,Format,ppKeys) ) 

#define IPortableDeviceCapabilities_GetFixedPropertyAttributes(This,Format,Key,ppAttributes)	\
    ( (This)->lpVtbl -> GetFixedPropertyAttributes(This,Format,Key,ppAttributes) ) 

#define IPortableDeviceCapabilities_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define IPortableDeviceCapabilities_GetSupportedEvents(This,ppEvents)	\
    ( (This)->lpVtbl -> GetSupportedEvents(This,ppEvents) ) 

#define IPortableDeviceCapabilities_GetEventOptions(This,Event,ppOptions)	\
    ( (This)->lpVtbl -> GetEventOptions(This,Event,ppOptions) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPortableDeviceCapabilities_INTERFACE_DEFINED__ */


#ifndef __IPortableDeviceEventCallback_INTERFACE_DEFINED__
#define __IPortableDeviceEventCallback_INTERFACE_DEFINED__

/* interface IPortableDeviceEventCallback */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPortableDeviceEventCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a8792a31-f385-493c-a893-40f64eb45f6e")
    IPortableDeviceEventCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnEvent( 
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pEventParameters) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPortableDeviceEventCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPortableDeviceEventCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPortableDeviceEventCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPortableDeviceEventCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnEvent )( 
            IPortableDeviceEventCallback * This,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pEventParameters);
        
        END_INTERFACE
    } IPortableDeviceEventCallbackVtbl;

    interface IPortableDeviceEventCallback
    {
        CONST_VTBL struct IPortableDeviceEventCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPortableDeviceEventCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPortableDeviceEventCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPortableDeviceEventCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPortableDeviceEventCallback_OnEvent(This,pEventParameters)	\
    ( (This)->lpVtbl -> OnEvent(This,pEventParameters) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPortableDeviceEventCallback_INTERFACE_DEFINED__ */


#ifndef __IPortableDeviceDataStream_INTERFACE_DEFINED__
#define __IPortableDeviceDataStream_INTERFACE_DEFINED__

/* interface IPortableDeviceDataStream */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPortableDeviceDataStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("88e04db3-1012-4d64-9996-f703a950d3f4")
    IPortableDeviceDataStream : public IStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetObjectID( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszObjectID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPortableDeviceDataStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPortableDeviceDataStream * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPortableDeviceDataStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPortableDeviceDataStream * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Read )( 
            IPortableDeviceDataStream * This,
            /* [length_is][size_is][out] */ void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbRead);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Write )( 
            IPortableDeviceDataStream * This,
            /* [size_is][in] */ const void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbWritten);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IPortableDeviceDataStream * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE *SetSize )( 
            IPortableDeviceDataStream * This,
            /* [in] */ ULARGE_INTEGER libNewSize);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CopyTo )( 
            IPortableDeviceDataStream * This,
            /* [unique][in] */ IStream *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [out] */ ULARGE_INTEGER *pcbRead,
            /* [out] */ ULARGE_INTEGER *pcbWritten);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IPortableDeviceDataStream * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Revert )( 
            IPortableDeviceDataStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockRegion )( 
            IPortableDeviceDataStream * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockRegion )( 
            IPortableDeviceDataStream * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *Stat )( 
            IPortableDeviceDataStream * This,
            /* [out] */ __RPC__out STATSTG *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IPortableDeviceDataStream * This,
            /* [out] */ __RPC__deref_out_opt IStream **ppstm);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectID )( 
            IPortableDeviceDataStream * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszObjectID);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IPortableDeviceDataStream * This);
        
        END_INTERFACE
    } IPortableDeviceDataStreamVtbl;

    interface IPortableDeviceDataStream
    {
        CONST_VTBL struct IPortableDeviceDataStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPortableDeviceDataStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPortableDeviceDataStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPortableDeviceDataStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPortableDeviceDataStream_Read(This,pv,cb,pcbRead)	\
    ( (This)->lpVtbl -> Read(This,pv,cb,pcbRead) ) 

#define IPortableDeviceDataStream_Write(This,pv,cb,pcbWritten)	\
    ( (This)->lpVtbl -> Write(This,pv,cb,pcbWritten) ) 


#define IPortableDeviceDataStream_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    ( (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition) ) 

#define IPortableDeviceDataStream_SetSize(This,libNewSize)	\
    ( (This)->lpVtbl -> SetSize(This,libNewSize) ) 

#define IPortableDeviceDataStream_CopyTo(This,pstm,cb,pcbRead,pcbWritten)	\
    ( (This)->lpVtbl -> CopyTo(This,pstm,cb,pcbRead,pcbWritten) ) 

#define IPortableDeviceDataStream_Commit(This,grfCommitFlags)	\
    ( (This)->lpVtbl -> Commit(This,grfCommitFlags) ) 

#define IPortableDeviceDataStream_Revert(This)	\
    ( (This)->lpVtbl -> Revert(This) ) 

#define IPortableDeviceDataStream_LockRegion(This,libOffset,cb,dwLockType)	\
    ( (This)->lpVtbl -> LockRegion(This,libOffset,cb,dwLockType) ) 

#define IPortableDeviceDataStream_UnlockRegion(This,libOffset,cb,dwLockType)	\
    ( (This)->lpVtbl -> UnlockRegion(This,libOffset,cb,dwLockType) ) 

#define IPortableDeviceDataStream_Stat(This,pstatstg,grfStatFlag)	\
    ( (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag) ) 

#define IPortableDeviceDataStream_Clone(This,ppstm)	\
    ( (This)->lpVtbl -> Clone(This,ppstm) ) 


#define IPortableDeviceDataStream_GetObjectID(This,ppszObjectID)	\
    ( (This)->lpVtbl -> GetObjectID(This,ppszObjectID) ) 

#define IPortableDeviceDataStream_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPortableDeviceDataStream_INTERFACE_DEFINED__ */


#ifndef __IPortableDevicePropertiesBulk_INTERFACE_DEFINED__
#define __IPortableDevicePropertiesBulk_INTERFACE_DEFINED__

/* interface IPortableDevicePropertiesBulk */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPortableDevicePropertiesBulk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("482b05c0-4056-44ed-9e0f-5e23b009da93")
    IPortableDevicePropertiesBulk : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueueGetValuesByObjectList( 
            /* [in] */ __RPC__in_opt IPortableDevicePropVariantCollection *pObjectIDs,
            /* [in] */ __RPC__in_opt IPortableDeviceKeyCollection *pKeys,
            /* [in] */ __RPC__in_opt IPortableDevicePropertiesBulkCallback *pCallback,
            /* [out] */ __RPC__out GUID *pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueueGetValuesByObjectFormat( 
            /* [in] */ __RPC__in REFGUID pguidObjectFormat,
            /* [in] */ __RPC__in LPCWSTR pszParentObjectID,
            /* [in] */ const DWORD dwDepth,
            /* [in] */ __RPC__in_opt IPortableDeviceKeyCollection *pKeys,
            /* [in] */ __RPC__in_opt IPortableDevicePropertiesBulkCallback *pCallback,
            /* [out] */ __RPC__out GUID *pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueueSetValuesByObjectList( 
            /* [in] */ __RPC__in_opt IPortableDeviceValuesCollection *pObjectValues,
            /* [in] */ __RPC__in_opt IPortableDevicePropertiesBulkCallback *pCallback,
            /* [out] */ __RPC__out GUID *pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ __RPC__in REFGUID pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( 
            /* [in] */ __RPC__in REFGUID pContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPortableDevicePropertiesBulkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPortableDevicePropertiesBulk * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPortableDevicePropertiesBulk * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPortableDevicePropertiesBulk * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueueGetValuesByObjectList )( 
            IPortableDevicePropertiesBulk * This,
            /* [in] */ __RPC__in_opt IPortableDevicePropVariantCollection *pObjectIDs,
            /* [in] */ __RPC__in_opt IPortableDeviceKeyCollection *pKeys,
            /* [in] */ __RPC__in_opt IPortableDevicePropertiesBulkCallback *pCallback,
            /* [out] */ __RPC__out GUID *pContext);
        
        HRESULT ( STDMETHODCALLTYPE *QueueGetValuesByObjectFormat )( 
            IPortableDevicePropertiesBulk * This,
            /* [in] */ __RPC__in REFGUID pguidObjectFormat,
            /* [in] */ __RPC__in LPCWSTR pszParentObjectID,
            /* [in] */ const DWORD dwDepth,
            /* [in] */ __RPC__in_opt IPortableDeviceKeyCollection *pKeys,
            /* [in] */ __RPC__in_opt IPortableDevicePropertiesBulkCallback *pCallback,
            /* [out] */ __RPC__out GUID *pContext);
        
        HRESULT ( STDMETHODCALLTYPE *QueueSetValuesByObjectList )( 
            IPortableDevicePropertiesBulk * This,
            /* [in] */ __RPC__in_opt IPortableDeviceValuesCollection *pObjectValues,
            /* [in] */ __RPC__in_opt IPortableDevicePropertiesBulkCallback *pCallback,
            /* [out] */ __RPC__out GUID *pContext);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IPortableDevicePropertiesBulk * This,
            /* [in] */ __RPC__in REFGUID pContext);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IPortableDevicePropertiesBulk * This,
            /* [in] */ __RPC__in REFGUID pContext);
        
        END_INTERFACE
    } IPortableDevicePropertiesBulkVtbl;

    interface IPortableDevicePropertiesBulk
    {
        CONST_VTBL struct IPortableDevicePropertiesBulkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPortableDevicePropertiesBulk_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPortableDevicePropertiesBulk_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPortableDevicePropertiesBulk_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPortableDevicePropertiesBulk_QueueGetValuesByObjectList(This,pObjectIDs,pKeys,pCallback,pContext)	\
    ( (This)->lpVtbl -> QueueGetValuesByObjectList(This,pObjectIDs,pKeys,pCallback,pContext) ) 

#define IPortableDevicePropertiesBulk_QueueGetValuesByObjectFormat(This,pguidObjectFormat,pszParentObjectID,dwDepth,pKeys,pCallback,pContext)	\
    ( (This)->lpVtbl -> QueueGetValuesByObjectFormat(This,pguidObjectFormat,pszParentObjectID,dwDepth,pKeys,pCallback,pContext) ) 

#define IPortableDevicePropertiesBulk_QueueSetValuesByObjectList(This,pObjectValues,pCallback,pContext)	\
    ( (This)->lpVtbl -> QueueSetValuesByObjectList(This,pObjectValues,pCallback,pContext) ) 

#define IPortableDevicePropertiesBulk_Start(This,pContext)	\
    ( (This)->lpVtbl -> Start(This,pContext) ) 

#define IPortableDevicePropertiesBulk_Cancel(This,pContext)	\
    ( (This)->lpVtbl -> Cancel(This,pContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPortableDevicePropertiesBulk_INTERFACE_DEFINED__ */


#ifndef __IPortableDevicePropertiesBulkCallback_INTERFACE_DEFINED__
#define __IPortableDevicePropertiesBulkCallback_INTERFACE_DEFINED__

/* interface IPortableDevicePropertiesBulkCallback */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPortableDevicePropertiesBulkCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9deacb80-11e8-40e3-a9f3-f557986a7845")
    IPortableDevicePropertiesBulkCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStart( 
            /* [in] */ __RPC__in REFGUID pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ __RPC__in REFGUID pContext,
            /* [in] */ __RPC__in_opt IPortableDeviceValuesCollection *pResults) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEnd( 
            /* [in] */ __RPC__in REFGUID pContext,
            /* [in] */ HRESULT hrStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPortableDevicePropertiesBulkCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPortableDevicePropertiesBulkCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPortableDevicePropertiesBulkCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPortableDevicePropertiesBulkCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStart )( 
            IPortableDevicePropertiesBulkCallback * This,
            /* [in] */ __RPC__in REFGUID pContext);
        
        HRESULT ( STDMETHODCALLTYPE *OnProgress )( 
            IPortableDevicePropertiesBulkCallback * This,
            /* [in] */ __RPC__in REFGUID pContext,
            /* [in] */ __RPC__in_opt IPortableDeviceValuesCollection *pResults);
        
        HRESULT ( STDMETHODCALLTYPE *OnEnd )( 
            IPortableDevicePropertiesBulkCallback * This,
            /* [in] */ __RPC__in REFGUID pContext,
            /* [in] */ HRESULT hrStatus);
        
        END_INTERFACE
    } IPortableDevicePropertiesBulkCallbackVtbl;

    interface IPortableDevicePropertiesBulkCallback
    {
        CONST_VTBL struct IPortableDevicePropertiesBulkCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPortableDevicePropertiesBulkCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPortableDevicePropertiesBulkCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPortableDevicePropertiesBulkCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPortableDevicePropertiesBulkCallback_OnStart(This,pContext)	\
    ( (This)->lpVtbl -> OnStart(This,pContext) ) 

#define IPortableDevicePropertiesBulkCallback_OnProgress(This,pContext,pResults)	\
    ( (This)->lpVtbl -> OnProgress(This,pContext,pResults) ) 

#define IPortableDevicePropertiesBulkCallback_OnEnd(This,pContext,hrStatus)	\
    ( (This)->lpVtbl -> OnEnd(This,pContext,hrStatus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPortableDevicePropertiesBulkCallback_INTERFACE_DEFINED__ */



#ifndef __PortableDeviceApiLib_LIBRARY_DEFINED__
#define __PortableDeviceApiLib_LIBRARY_DEFINED__

/* library PortableDeviceApiLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_PortableDeviceApiLib;

EXTERN_C const CLSID CLSID_PortableDevice;

#ifdef __cplusplus

class DECLSPEC_UUID("728a21c5-3d9e-48d7-9810-864848f0f404")
PortableDevice;
#endif

EXTERN_C const CLSID CLSID_PortableDeviceManager;

#ifdef __cplusplus

class DECLSPEC_UUID("0af10cec-2ecd-4b92-9581-34f6ae0637f3")
PortableDeviceManager;
#endif
#endif /* __PortableDeviceApiLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_PortableDeviceApi_0000_0011 */
/* [local] */ 

#endif  // (_WIN32_WINNT >= 0x0501)


extern RPC_IF_HANDLE __MIDL_itf_PortableDeviceApi_0000_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_PortableDeviceApi_0000_0011_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\pla.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for pla.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __pla_h__
#define __pla_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDataCollectorSet_FWD_DEFINED__
#define __IDataCollectorSet_FWD_DEFINED__
typedef interface IDataCollectorSet IDataCollectorSet;
#endif 	/* __IDataCollectorSet_FWD_DEFINED__ */


#ifndef __IDataManager_FWD_DEFINED__
#define __IDataManager_FWD_DEFINED__
typedef interface IDataManager IDataManager;
#endif 	/* __IDataManager_FWD_DEFINED__ */


#ifndef __IFolderAction_FWD_DEFINED__
#define __IFolderAction_FWD_DEFINED__
typedef interface IFolderAction IFolderAction;
#endif 	/* __IFolderAction_FWD_DEFINED__ */


#ifndef __IFolderActionCollection_FWD_DEFINED__
#define __IFolderActionCollection_FWD_DEFINED__
typedef interface IFolderActionCollection IFolderActionCollection;
#endif 	/* __IFolderActionCollection_FWD_DEFINED__ */


#ifndef __IDataCollector_FWD_DEFINED__
#define __IDataCollector_FWD_DEFINED__
typedef interface IDataCollector IDataCollector;
#endif 	/* __IDataCollector_FWD_DEFINED__ */


#ifndef __IPerformanceCounterDataCollector_FWD_DEFINED__
#define __IPerformanceCounterDataCollector_FWD_DEFINED__
typedef interface IPerformanceCounterDataCollector IPerformanceCounterDataCollector;
#endif 	/* __IPerformanceCounterDataCollector_FWD_DEFINED__ */


#ifndef __ITraceDataCollector_FWD_DEFINED__
#define __ITraceDataCollector_FWD_DEFINED__
typedef interface ITraceDataCollector ITraceDataCollector;
#endif 	/* __ITraceDataCollector_FWD_DEFINED__ */


#ifndef __IConfigurationDataCollector_FWD_DEFINED__
#define __IConfigurationDataCollector_FWD_DEFINED__
typedef interface IConfigurationDataCollector IConfigurationDataCollector;
#endif 	/* __IConfigurationDataCollector_FWD_DEFINED__ */


#ifndef __IAlertDataCollector_FWD_DEFINED__
#define __IAlertDataCollector_FWD_DEFINED__
typedef interface IAlertDataCollector IAlertDataCollector;
#endif 	/* __IAlertDataCollector_FWD_DEFINED__ */


#ifndef __IApiTracingDataCollector_FWD_DEFINED__
#define __IApiTracingDataCollector_FWD_DEFINED__
typedef interface IApiTracingDataCollector IApiTracingDataCollector;
#endif 	/* __IApiTracingDataCollector_FWD_DEFINED__ */


#ifndef __IDataCollectorCollection_FWD_DEFINED__
#define __IDataCollectorCollection_FWD_DEFINED__
typedef interface IDataCollectorCollection IDataCollectorCollection;
#endif 	/* __IDataCollectorCollection_FWD_DEFINED__ */


#ifndef __IDataCollectorSetCollection_FWD_DEFINED__
#define __IDataCollectorSetCollection_FWD_DEFINED__
typedef interface IDataCollectorSetCollection IDataCollectorSetCollection;
#endif 	/* __IDataCollectorSetCollection_FWD_DEFINED__ */


#ifndef __ITraceDataProvider_FWD_DEFINED__
#define __ITraceDataProvider_FWD_DEFINED__
typedef interface ITraceDataProvider ITraceDataProvider;
#endif 	/* __ITraceDataProvider_FWD_DEFINED__ */


#ifndef __ITraceDataProviderCollection_FWD_DEFINED__
#define __ITraceDataProviderCollection_FWD_DEFINED__
typedef interface ITraceDataProviderCollection ITraceDataProviderCollection;
#endif 	/* __ITraceDataProviderCollection_FWD_DEFINED__ */


#ifndef __ISchedule_FWD_DEFINED__
#define __ISchedule_FWD_DEFINED__
typedef interface ISchedule ISchedule;
#endif 	/* __ISchedule_FWD_DEFINED__ */


#ifndef __IScheduleCollection_FWD_DEFINED__
#define __IScheduleCollection_FWD_DEFINED__
typedef interface IScheduleCollection IScheduleCollection;
#endif 	/* __IScheduleCollection_FWD_DEFINED__ */


#ifndef __IValueMapItem_FWD_DEFINED__
#define __IValueMapItem_FWD_DEFINED__
typedef interface IValueMapItem IValueMapItem;
#endif 	/* __IValueMapItem_FWD_DEFINED__ */


#ifndef __IValueMap_FWD_DEFINED__
#define __IValueMap_FWD_DEFINED__
typedef interface IValueMap IValueMap;
#endif 	/* __IValueMap_FWD_DEFINED__ */


#ifndef __DataCollectorSet_FWD_DEFINED__
#define __DataCollectorSet_FWD_DEFINED__

#ifdef __cplusplus
typedef class DataCollectorSet DataCollectorSet;
#else
typedef struct DataCollectorSet DataCollectorSet;
#endif /* __cplusplus */

#endif 	/* __DataCollectorSet_FWD_DEFINED__ */


#ifndef __TraceSession_FWD_DEFINED__
#define __TraceSession_FWD_DEFINED__

#ifdef __cplusplus
typedef class TraceSession TraceSession;
#else
typedef struct TraceSession TraceSession;
#endif /* __cplusplus */

#endif 	/* __TraceSession_FWD_DEFINED__ */


#ifndef __TraceSessionCollection_FWD_DEFINED__
#define __TraceSessionCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class TraceSessionCollection TraceSessionCollection;
#else
typedef struct TraceSessionCollection TraceSessionCollection;
#endif /* __cplusplus */

#endif 	/* __TraceSessionCollection_FWD_DEFINED__ */


#ifndef __TraceDataProvider_FWD_DEFINED__
#define __TraceDataProvider_FWD_DEFINED__

#ifdef __cplusplus
typedef class TraceDataProvider TraceDataProvider;
#else
typedef struct TraceDataProvider TraceDataProvider;
#endif /* __cplusplus */

#endif 	/* __TraceDataProvider_FWD_DEFINED__ */


#ifndef __TraceDataProviderCollection_FWD_DEFINED__
#define __TraceDataProviderCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class TraceDataProviderCollection TraceDataProviderCollection;
#else
typedef struct TraceDataProviderCollection TraceDataProviderCollection;
#endif /* __cplusplus */

#endif 	/* __TraceDataProviderCollection_FWD_DEFINED__ */


#ifndef __DataCollectorSetCollection_FWD_DEFINED__
#define __DataCollectorSetCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class DataCollectorSetCollection DataCollectorSetCollection;
#else
typedef struct DataCollectorSetCollection DataCollectorSetCollection;
#endif /* __cplusplus */

#endif 	/* __DataCollectorSetCollection_FWD_DEFINED__ */


#ifndef __LegacyDataCollectorSet_FWD_DEFINED__
#define __LegacyDataCollectorSet_FWD_DEFINED__

#ifdef __cplusplus
typedef class LegacyDataCollectorSet LegacyDataCollectorSet;
#else
typedef struct LegacyDataCollectorSet LegacyDataCollectorSet;
#endif /* __cplusplus */

#endif 	/* __LegacyDataCollectorSet_FWD_DEFINED__ */


#ifndef __LegacyDataCollectorSetCollection_FWD_DEFINED__
#define __LegacyDataCollectorSetCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class LegacyDataCollectorSetCollection LegacyDataCollectorSetCollection;
#else
typedef struct LegacyDataCollectorSetCollection LegacyDataCollectorSetCollection;
#endif /* __cplusplus */

#endif 	/* __LegacyDataCollectorSetCollection_FWD_DEFINED__ */


#ifndef __LegacyTraceSession_FWD_DEFINED__
#define __LegacyTraceSession_FWD_DEFINED__

#ifdef __cplusplus
typedef class LegacyTraceSession LegacyTraceSession;
#else
typedef struct LegacyTraceSession LegacyTraceSession;
#endif /* __cplusplus */

#endif 	/* __LegacyTraceSession_FWD_DEFINED__ */


#ifndef __LegacyTraceSessionCollection_FWD_DEFINED__
#define __LegacyTraceSessionCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class LegacyTraceSessionCollection LegacyTraceSessionCollection;
#else
typedef struct LegacyTraceSessionCollection LegacyTraceSessionCollection;
#endif /* __cplusplus */

#endif 	/* __LegacyTraceSessionCollection_FWD_DEFINED__ */


#ifndef __ServerDataCollectorSet_FWD_DEFINED__
#define __ServerDataCollectorSet_FWD_DEFINED__

#ifdef __cplusplus
typedef class ServerDataCollectorSet ServerDataCollectorSet;
#else
typedef struct ServerDataCollectorSet ServerDataCollectorSet;
#endif /* __cplusplus */

#endif 	/* __ServerDataCollectorSet_FWD_DEFINED__ */


#ifndef __ServerDataCollectorSetCollection_FWD_DEFINED__
#define __ServerDataCollectorSetCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class ServerDataCollectorSetCollection ServerDataCollectorSetCollection;
#else
typedef struct ServerDataCollectorSetCollection ServerDataCollectorSetCollection;
#endif /* __cplusplus */

#endif 	/* __ServerDataCollectorSetCollection_FWD_DEFINED__ */


#ifndef __SystemDataCollectorSet_FWD_DEFINED__
#define __SystemDataCollectorSet_FWD_DEFINED__

#ifdef __cplusplus
typedef class SystemDataCollectorSet SystemDataCollectorSet;
#else
typedef struct SystemDataCollectorSet SystemDataCollectorSet;
#endif /* __cplusplus */

#endif 	/* __SystemDataCollectorSet_FWD_DEFINED__ */


#ifndef __SystemDataCollectorSetCollection_FWD_DEFINED__
#define __SystemDataCollectorSetCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class SystemDataCollectorSetCollection SystemDataCollectorSetCollection;
#else
typedef struct SystemDataCollectorSetCollection SystemDataCollectorSetCollection;
#endif /* __cplusplus */

#endif 	/* __SystemDataCollectorSetCollection_FWD_DEFINED__ */


#ifndef __BootTraceSession_FWD_DEFINED__
#define __BootTraceSession_FWD_DEFINED__

#ifdef __cplusplus
typedef class BootTraceSession BootTraceSession;
#else
typedef struct BootTraceSession BootTraceSession;
#endif /* __cplusplus */

#endif 	/* __BootTraceSession_FWD_DEFINED__ */


#ifndef __BootTraceSessionCollection_FWD_DEFINED__
#define __BootTraceSessionCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class BootTraceSessionCollection BootTraceSessionCollection;
#else
typedef struct BootTraceSessionCollection BootTraceSessionCollection;
#endif /* __cplusplus */

#endif 	/* __BootTraceSessionCollection_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 



#ifndef __PlaLibrary_LIBRARY_DEFINED__
#define __PlaLibrary_LIBRARY_DEFINED__

/* library PlaLibrary */
/* [control][helpstring][version][uuid] */ 



















typedef /* [public][public][public][uuid] */  DECLSPEC_UUID("03837504-098b-11d8-9414-505054503030") 
enum __MIDL___MIDL_itf_pla_0000_0000_0001
    {	plaPerformanceCounter	= 0,
	plaTrace	= 1,
	plaConfiguration	= 2,
	plaAlert	= 3,
	plaApiTrace	= 4
    } 	DataCollectorType;

typedef /* [public][public][public][uuid] */  DECLSPEC_UUID("03837507-098b-11d8-9414-505054503030") 
enum __MIDL___MIDL_itf_pla_0000_0000_0002
    {	plaCommaSeparated	= 0,
	plaTabSeparated	= 1,
	plaSql	= 2,
	plaBinary	= 3
    } 	FileFormat;

typedef /* [public][public][public][public][public][uuid] */  DECLSPEC_UUID("03837508-098b-11d8-9414-505054503030") 
enum __MIDL___MIDL_itf_pla_0000_0000_0003
    {	plaNone	= 0,
	plaPattern	= 0x1,
	plaComputer	= 0x2,
	plaMonthDayHour	= 0x100,
	plaSerialNumber	= 0x200,
	plaYearDayOfYear	= 0x400,
	plaYearMonth	= 0x800,
	plaYearMonthDay	= 0x1000,
	plaYearMonthDayHour	= 0x2000,
	plaMonthDayHourMinute	= 0x4000
    } 	AutoPathFormat;

typedef /* [public][public][uuid] */  DECLSPEC_UUID("0383750a-098b-11d8-9414-505054503030") 
enum __MIDL___MIDL_itf_pla_0000_0000_0004
    {	plaStopped	= 0,
	plaRunning	= 1,
	plaCompiling	= 2,
	plaPending	= 3,
	plaUndefined	= 4
    } 	DataCollectorSetStatus;

typedef /* [public][public][public][uuid] */  DECLSPEC_UUID("0383750d-098b-11d8-9414-505054503030") 
enum __MIDL___MIDL_itf_pla_0000_0000_0005
    {	plaTimeStamp	= 0,
	plaPerformance	= 1,
	plaSystem	= 2,
	plaCycle	= 3
    } 	ClockType;

typedef /* [public][public][public][uuid] */  DECLSPEC_UUID("0383750e-098b-11d8-9414-505054503030") 
enum __MIDL___MIDL_itf_pla_0000_0000_0006
    {	plaFile	= 0x1,
	plaRealTime	= 0x2,
	plaBoth	= 0x3,
	plaBuffering	= 0x4
    } 	StreamMode;

typedef /* [public][public][uuid] */  DECLSPEC_UUID("0383751f-098b-11d8-9414-505054503030") 
enum __MIDL___MIDL_itf_pla_0000_0000_0007
    {	plaCreateNew	= 0x1,
	plaModify	= 0x2,
	plaCreateOrModify	= 0x3,
	plaUpdateRunningInstance	= 0x10,
	plaFlushTrace	= 0x20,
	plaValidateOnly	= 0x1000
    } 	CommitMode;

typedef /* [public][public][public][public][public][uuid] */  DECLSPEC_UUID("03837535-098b-11d8-9414-505054503030") 
enum __MIDL___MIDL_itf_pla_0000_0000_0008
    {	plaIndex	= 1,
	plaFlag	= 2,
	plaFlagArray	= 3,
	plaValidation	= 4
    } 	ValueMapType;

typedef /* [public][public][public][uuid] */  DECLSPEC_UUID("0383753b-098b-11d8-9414-505054503030") 
enum __MIDL___MIDL_itf_pla_0000_0000_0009
    {	plaRunOnce	= 0,
	plaSunday	= 0x1,
	plaMonday	= 0x2,
	plaTuesday	= 0x4,
	plaWednesday	= 0x8,
	plaThursday	= 0x10,
	plaFriday	= 0x20,
	plaSaturday	= 0x40,
	plaEveryday	= 0x7f
    } 	WeekDays;

typedef /* [public][public][public][uuid] */  DECLSPEC_UUID("0383753f-098b-11d8-9414-505054503030") 
enum __MIDL___MIDL_itf_pla_0000_0000_0010
    {	plaDeleteLargest	= 0,
	plaDeleteOldest	= 1
    } 	ResourcePolicy;

typedef /* [public][public][uuid] */  DECLSPEC_UUID("03837540-098b-11d8-9414-505054503030") 
enum __MIDL___MIDL_itf_pla_0000_0000_0011
    {	plaCreateReport	= 0x1,
	plaRunRules	= 0x2,
	plaCreateHtml	= 0x4,
	plaFolderActions	= 0x8,
	plaResourceFreeing	= 0x10
    } 	DataManagerSteps;

typedef /* [public][public][public][uuid] */  DECLSPEC_UUID("03837542-098b-11d8-9414-505054503030") 
enum __MIDL___MIDL_itf_pla_0000_0000_0012
    {	plaCreateCab	= 0x1,
	plaDeleteData	= 0x2,
	plaSendCab	= 0x4,
	plaDeleteCab	= 0x8,
	plaDeleteReport	= 0x10
    } 	FolderActionSteps;

#define PLA_FUNCTION    HRESULT __stdcall

PLA_FUNCTION
PlaExpandTaskArguments(
    VARIANT vDataSet,
    __out BSTR* args
    );

#define PLA_CAPABILITY_LOCAL                0x10000000
#define PLA_CAPABILITY_V1_SVC               0x00000001
#define PLA_CAPABILITY_V1_SESSION           0x00000002
#define PLA_CAPABILITY_V1_SYSTEM            0x00000004
#define PLA_CAPABILITY_LEGACY_SESSION       0x00000008
#define PLA_CAPABILITY_LEGACY_SVC           0x00000010
#define PLA_CAPABILITY_AUTOLOGGER           0x00000020

#define PLAL_ALERT_CMD_LINE_SINGLE    ((DWORD)0x00000100)
#define PLAL_ALERT_CMD_LINE_A_NAME    ((DWORD)0x00000200)
#define PLAL_ALERT_CMD_LINE_C_NAME    ((DWORD)0x00000400)
#define PLAL_ALERT_CMD_LINE_D_TIME    ((DWORD)0x00000800)
#define PLAL_ALERT_CMD_LINE_L_VAL     ((DWORD)0x00001000)
#define PLAL_ALERT_CMD_LINE_M_VAL     ((DWORD)0x00002000)
#define PLAL_ALERT_CMD_LINE_U_TEXT    ((DWORD)0x00004000)
#define PLAL_ALERT_CMD_LINE_MASK      ((DWORD)0x00007F00)

PLA_FUNCTION
PlaGetServerCapabilities(
    __in_opt BSTR   Server,
    __out    PDWORD Capabilites
    );

PLA_FUNCTION
PlaGetLegacyAlertActionsStringFromFlags(
    __in  DWORD  dwFlags,
    __out BSTR   *pbstrAlertStr
    );

PLA_FUNCTION
PlaGetLegacyAlertActionsFlagsFromString(
    __in  PCWSTR  pszArguments,
    __out LPDWORD pdwFlags
    );

typedef VOID (*PLA_CABEXTRACT_CALLBACK)(PCWSTR FileName, PVOID Context);

HRESULT
PlaExtractCabinet(
    __in     PCWSTR                  CabFileName,
    __in     PCWSTR                  DestPath,
    __in_opt PLA_CABEXTRACT_CALLBACK Callback,
    __in_opt PVOID                   Context
    );

HRESULT
PlaDeleteReport(
    __in PCWSTR Folder
    );


EXTERN_C const IID LIBID_PlaLibrary;

#ifndef __IDataCollectorSet_INTERFACE_DEFINED__
#define __IDataCollectorSet_INTERFACE_DEFINED__

/* interface IDataCollectorSet */
/* [oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IDataCollectorSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03837520-098b-11d8-9414-505054503030")
    IDataCollectorSet : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DataCollectors( 
            /* [retval][out] */ __RPC__deref_out_opt IDataCollectorCollection **collectors) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Duration( 
            /* [retval][out] */ __RPC__out unsigned long *seconds) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Duration( 
            /* [in] */ unsigned long seconds) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *description) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ __RPC__in BSTR description) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DescriptionUnresolved( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Descr) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *DisplayName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DisplayName( 
            /* [in] */ __RPC__in BSTR DisplayName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DisplayNameUnresolved( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Keywords( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *keywords) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Keywords( 
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * keywords) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LatestOutputLocation( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *path) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LatestOutputLocation( 
            /* [in] */ __RPC__in BSTR path) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_OutputLocation( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *path) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RootPath( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *folder) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RootPath( 
            /* [in] */ __RPC__in BSTR folder) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Segment( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *segment) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Segment( 
            /* [in] */ VARIANT_BOOL segment) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SegmentMaxDuration( 
            /* [retval][out] */ __RPC__out unsigned long *seconds) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SegmentMaxDuration( 
            /* [in] */ unsigned long seconds) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SegmentMaxSize( 
            /* [retval][out] */ __RPC__out unsigned long *size) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SegmentMaxSize( 
            /* [in] */ unsigned long size) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SerialNumber( 
            /* [retval][out] */ __RPC__out unsigned long *index) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SerialNumber( 
            /* [in] */ unsigned long index) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Server( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *server) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ __RPC__out DataCollectorSetStatus *status) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Subdirectory( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *folder) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Subdirectory( 
            /* [in] */ __RPC__in BSTR folder) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SubdirectoryFormat( 
            /* [retval][out] */ __RPC__out AutoPathFormat *format) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SubdirectoryFormat( 
            /* [in] */ AutoPathFormat format) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SubdirectoryFormatPattern( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pattern) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SubdirectoryFormatPattern( 
            /* [in] */ __RPC__in BSTR pattern) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Task( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *task) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Task( 
            /* [in] */ __RPC__in BSTR task) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TaskRunAsSelf( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *RunAsSelf) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TaskRunAsSelf( 
            /* [in] */ VARIANT_BOOL RunAsSelf) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TaskArguments( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *task) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TaskArguments( 
            /* [in] */ __RPC__in BSTR task) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TaskUserTextArguments( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *UserText) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TaskUserTextArguments( 
            /* [in] */ __RPC__in BSTR UserText) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Schedules( 
            /* [retval][out] */ __RPC__deref_out_opt IScheduleCollection **ppSchedules) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SchedulesEnabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SchedulesEnabled( 
            /* [in] */ VARIANT_BOOL enabled) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_UserAccount( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *user) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Xml( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *xml) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Security( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrSecurity) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Security( 
            /* [in] */ __RPC__in BSTR bstrSecurity) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_StopOnCompletion( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *Stop) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_StopOnCompletion( 
            /* [in] */ VARIANT_BOOL Stop) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DataManager( 
            /* [retval][out] */ __RPC__deref_out_opt IDataManager **DataManager) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCredentials( 
            __RPC__in BSTR user,
            __RPC__in BSTR password) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Query( 
            /* [in] */ __RPC__in BSTR name,
            /* [unique][in] */ __RPC__in_opt BSTR server) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ __RPC__in BSTR name,
            /* [unique][in] */ __RPC__in_opt BSTR server,
            CommitMode mode,
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **validation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ VARIANT_BOOL Synchronous) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( 
            /* [in] */ VARIANT_BOOL Synchronous) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetXml( 
            /* [in] */ __RPC__in BSTR xml,
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **validation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            __RPC__in BSTR key,
            __RPC__in BSTR value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            __RPC__in BSTR key,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataCollectorSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDataCollectorSet * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDataCollectorSet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDataCollectorSet * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDataCollectorSet * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDataCollectorSet * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDataCollectorSet * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDataCollectorSet * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataCollectors )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollectorCollection **collectors);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__out unsigned long *seconds);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDataCollectorSet * This,
            /* [in] */ unsigned long seconds);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *description);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            IDataCollectorSet * This,
            /* [in] */ __RPC__in BSTR description);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DescriptionUnresolved )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Descr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayName )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *DisplayName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayName )( 
            IDataCollectorSet * This,
            /* [in] */ __RPC__in BSTR DisplayName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayNameUnresolved )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Keywords )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *keywords);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Keywords )( 
            IDataCollectorSet * This,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * keywords);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LatestOutputLocation )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *path);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LatestOutputLocation )( 
            IDataCollectorSet * This,
            /* [in] */ __RPC__in BSTR path);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutputLocation )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *path);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootPath )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *folder);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RootPath )( 
            IDataCollectorSet * This,
            /* [in] */ __RPC__in BSTR folder);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Segment )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *segment);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Segment )( 
            IDataCollectorSet * This,
            /* [in] */ VARIANT_BOOL segment);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SegmentMaxDuration )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__out unsigned long *seconds);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SegmentMaxDuration )( 
            IDataCollectorSet * This,
            /* [in] */ unsigned long seconds);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SegmentMaxSize )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__out unsigned long *size);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SegmentMaxSize )( 
            IDataCollectorSet * This,
            /* [in] */ unsigned long size);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SerialNumber )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__out unsigned long *index);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SerialNumber )( 
            IDataCollectorSet * This,
            /* [in] */ unsigned long index);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Server )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *server);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__out DataCollectorSetStatus *status);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Subdirectory )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *folder);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Subdirectory )( 
            IDataCollectorSet * This,
            /* [in] */ __RPC__in BSTR folder);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubdirectoryFormat )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__out AutoPathFormat *format);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SubdirectoryFormat )( 
            IDataCollectorSet * This,
            /* [in] */ AutoPathFormat format);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubdirectoryFormatPattern )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pattern);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SubdirectoryFormatPattern )( 
            IDataCollectorSet * This,
            /* [in] */ __RPC__in BSTR pattern);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Task )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *task);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Task )( 
            IDataCollectorSet * This,
            /* [in] */ __RPC__in BSTR task);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TaskRunAsSelf )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *RunAsSelf);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TaskRunAsSelf )( 
            IDataCollectorSet * This,
            /* [in] */ VARIANT_BOOL RunAsSelf);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TaskArguments )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *task);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TaskArguments )( 
            IDataCollectorSet * This,
            /* [in] */ __RPC__in BSTR task);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TaskUserTextArguments )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *UserText);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TaskUserTextArguments )( 
            IDataCollectorSet * This,
            /* [in] */ __RPC__in BSTR UserText);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Schedules )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__deref_out_opt IScheduleCollection **ppSchedules);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SchedulesEnabled )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SchedulesEnabled )( 
            IDataCollectorSet * This,
            /* [in] */ VARIANT_BOOL enabled);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserAccount )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *user);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Xml )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *xml);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Security )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrSecurity);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Security )( 
            IDataCollectorSet * This,
            /* [in] */ __RPC__in BSTR bstrSecurity);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_StopOnCompletion )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *Stop);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_StopOnCompletion )( 
            IDataCollectorSet * This,
            /* [in] */ VARIANT_BOOL Stop);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataManager )( 
            IDataCollectorSet * This,
            /* [retval][out] */ __RPC__deref_out_opt IDataManager **DataManager);
        
        HRESULT ( STDMETHODCALLTYPE *SetCredentials )( 
            IDataCollectorSet * This,
            __RPC__in BSTR user,
            __RPC__in BSTR password);
        
        HRESULT ( STDMETHODCALLTYPE *Query )( 
            IDataCollectorSet * This,
            /* [in] */ __RPC__in BSTR name,
            /* [unique][in] */ __RPC__in_opt BSTR server);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IDataCollectorSet * This,
            /* [in] */ __RPC__in BSTR name,
            /* [unique][in] */ __RPC__in_opt BSTR server,
            CommitMode mode,
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **validation);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IDataCollectorSet * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IDataCollectorSet * This,
            /* [in] */ VARIANT_BOOL Synchronous);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IDataCollectorSet * This,
            /* [in] */ VARIANT_BOOL Synchronous);
        
        HRESULT ( STDMETHODCALLTYPE *SetXml )( 
            IDataCollectorSet * This,
            /* [in] */ __RPC__in BSTR xml,
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **validation);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            IDataCollectorSet * This,
            __RPC__in BSTR key,
            __RPC__in BSTR value);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IDataCollectorSet * This,
            __RPC__in BSTR key,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *value);
        
        END_INTERFACE
    } IDataCollectorSetVtbl;

    interface IDataCollectorSet
    {
        CONST_VTBL struct IDataCollectorSetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataCollectorSet_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDataCollectorSet_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDataCollectorSet_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDataCollectorSet_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDataCollectorSet_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDataCollectorSet_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDataCollectorSet_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDataCollectorSet_get_DataCollectors(This,collectors)	\
    ( (This)->lpVtbl -> get_DataCollectors(This,collectors) ) 

#define IDataCollectorSet_get_Duration(This,seconds)	\
    ( (This)->lpVtbl -> get_Duration(This,seconds) ) 

#define IDataCollectorSet_put_Duration(This,seconds)	\
    ( (This)->lpVtbl -> put_Duration(This,seconds) ) 

#define IDataCollectorSet_get_Description(This,description)	\
    ( (This)->lpVtbl -> get_Description(This,description) ) 

#define IDataCollectorSet_put_Description(This,description)	\
    ( (This)->lpVtbl -> put_Description(This,description) ) 

#define IDataCollectorSet_get_DescriptionUnresolved(This,Descr)	\
    ( (This)->lpVtbl -> get_DescriptionUnresolved(This,Descr) ) 

#define IDataCollectorSet_get_DisplayName(This,DisplayName)	\
    ( (This)->lpVtbl -> get_DisplayName(This,DisplayName) ) 

#define IDataCollectorSet_put_DisplayName(This,DisplayName)	\
    ( (This)->lpVtbl -> put_DisplayName(This,DisplayName) ) 

#define IDataCollectorSet_get_DisplayNameUnresolved(This,name)	\
    ( (This)->lpVtbl -> get_DisplayNameUnresolved(This,name) ) 

#define IDataCollectorSet_get_Keywords(This,keywords)	\
    ( (This)->lpVtbl -> get_Keywords(This,keywords) ) 

#define IDataCollectorSet_put_Keywords(This,keywords)	\
    ( (This)->lpVtbl -> put_Keywords(This,keywords) ) 

#define IDataCollectorSet_get_LatestOutputLocation(This,path)	\
    ( (This)->lpVtbl -> get_LatestOutputLocation(This,path) ) 

#define IDataCollectorSet_put_LatestOutputLocation(This,path)	\
    ( (This)->lpVtbl -> put_LatestOutputLocation(This,path) ) 

#define IDataCollectorSet_get_Name(This,name)	\
    ( (This)->lpVtbl -> get_Name(This,name) ) 

#define IDataCollectorSet_get_OutputLocation(This,path)	\
    ( (This)->lpVtbl -> get_OutputLocation(This,path) ) 

#define IDataCollectorSet_get_RootPath(This,folder)	\
    ( (This)->lpVtbl -> get_RootPath(This,folder) ) 

#define IDataCollectorSet_put_RootPath(This,folder)	\
    ( (This)->lpVtbl -> put_RootPath(This,folder) ) 

#define IDataCollectorSet_get_Segment(This,segment)	\
    ( (This)->lpVtbl -> get_Segment(This,segment) ) 

#define IDataCollectorSet_put_Segment(This,segment)	\
    ( (This)->lpVtbl -> put_Segment(This,segment) ) 

#define IDataCollectorSet_get_SegmentMaxDuration(This,seconds)	\
    ( (This)->lpVtbl -> get_SegmentMaxDuration(This,seconds) ) 

#define IDataCollectorSet_put_SegmentMaxDuration(This,seconds)	\
    ( (This)->lpVtbl -> put_SegmentMaxDuration(This,seconds) ) 

#define IDataCollectorSet_get_SegmentMaxSize(This,size)	\
    ( (This)->lpVtbl -> get_SegmentMaxSize(This,size) ) 

#define IDataCollectorSet_put_SegmentMaxSize(This,size)	\
    ( (This)->lpVtbl -> put_SegmentMaxSize(This,size) ) 

#define IDataCollectorSet_get_SerialNumber(This,index)	\
    ( (This)->lpVtbl -> get_SerialNumber(This,index) ) 

#define IDataCollectorSet_put_SerialNumber(This,index)	\
    ( (This)->lpVtbl -> put_SerialNumber(This,index) ) 

#define IDataCollectorSet_get_Server(This,server)	\
    ( (This)->lpVtbl -> get_Server(This,server) ) 

#define IDataCollectorSet_get_Status(This,status)	\
    ( (This)->lpVtbl -> get_Status(This,status) ) 

#define IDataCollectorSet_get_Subdirectory(This,folder)	\
    ( (This)->lpVtbl -> get_Subdirectory(This,folder) ) 

#define IDataCollectorSet_put_Subdirectory(This,folder)	\
    ( (This)->lpVtbl -> put_Subdirectory(This,folder) ) 

#define IDataCollectorSet_get_SubdirectoryFormat(This,format)	\
    ( (This)->lpVtbl -> get_SubdirectoryFormat(This,format) ) 

#define IDataCollectorSet_put_SubdirectoryFormat(This,format)	\
    ( (This)->lpVtbl -> put_SubdirectoryFormat(This,format) ) 

#define IDataCollectorSet_get_SubdirectoryFormatPattern(This,pattern)	\
    ( (This)->lpVtbl -> get_SubdirectoryFormatPattern(This,pattern) ) 

#define IDataCollectorSet_put_SubdirectoryFormatPattern(This,pattern)	\
    ( (This)->lpVtbl -> put_SubdirectoryFormatPattern(This,pattern) ) 

#define IDataCollectorSet_get_Task(This,task)	\
    ( (This)->lpVtbl -> get_Task(This,task) ) 

#define IDataCollectorSet_put_Task(This,task)	\
    ( (This)->lpVtbl -> put_Task(This,task) ) 

#define IDataCollectorSet_get_TaskRunAsSelf(This,RunAsSelf)	\
    ( (This)->lpVtbl -> get_TaskRunAsSelf(This,RunAsSelf) ) 

#define IDataCollectorSet_put_TaskRunAsSelf(This,RunAsSelf)	\
    ( (This)->lpVtbl -> put_TaskRunAsSelf(This,RunAsSelf) ) 

#define IDataCollectorSet_get_TaskArguments(This,task)	\
    ( (This)->lpVtbl -> get_TaskArguments(This,task) ) 

#define IDataCollectorSet_put_TaskArguments(This,task)	\
    ( (This)->lpVtbl -> put_TaskArguments(This,task) ) 

#define IDataCollectorSet_get_TaskUserTextArguments(This,UserText)	\
    ( (This)->lpVtbl -> get_TaskUserTextArguments(This,UserText) ) 

#define IDataCollectorSet_put_TaskUserTextArguments(This,UserText)	\
    ( (This)->lpVtbl -> put_TaskUserTextArguments(This,UserText) ) 

#define IDataCollectorSet_get_Schedules(This,ppSchedules)	\
    ( (This)->lpVtbl -> get_Schedules(This,ppSchedules) ) 

#define IDataCollectorSet_get_SchedulesEnabled(This,enabled)	\
    ( (This)->lpVtbl -> get_SchedulesEnabled(This,enabled) ) 

#define IDataCollectorSet_put_SchedulesEnabled(This,enabled)	\
    ( (This)->lpVtbl -> put_SchedulesEnabled(This,enabled) ) 

#define IDataCollectorSet_get_UserAccount(This,user)	\
    ( (This)->lpVtbl -> get_UserAccount(This,user) ) 

#define IDataCollectorSet_get_Xml(This,xml)	\
    ( (This)->lpVtbl -> get_Xml(This,xml) ) 

#define IDataCollectorSet_get_Security(This,pbstrSecurity)	\
    ( (This)->lpVtbl -> get_Security(This,pbstrSecurity) ) 

#define IDataCollectorSet_put_Security(This,bstrSecurity)	\
    ( (This)->lpVtbl -> put_Security(This,bstrSecurity) ) 

#define IDataCollectorSet_get_StopOnCompletion(This,Stop)	\
    ( (This)->lpVtbl -> get_StopOnCompletion(This,Stop) ) 

#define IDataCollectorSet_put_StopOnCompletion(This,Stop)	\
    ( (This)->lpVtbl -> put_StopOnCompletion(This,Stop) ) 

#define IDataCollectorSet_get_DataManager(This,DataManager)	\
    ( (This)->lpVtbl -> get_DataManager(This,DataManager) ) 

#define IDataCollectorSet_SetCredentials(This,user,password)	\
    ( (This)->lpVtbl -> SetCredentials(This,user,password) ) 

#define IDataCollectorSet_Query(This,name,server)	\
    ( (This)->lpVtbl -> Query(This,name,server) ) 

#define IDataCollectorSet_Commit(This,name,server,mode,validation)	\
    ( (This)->lpVtbl -> Commit(This,name,server,mode,validation) ) 

#define IDataCollectorSet_Delete(This)	\
    ( (This)->lpVtbl -> Delete(This) ) 

#define IDataCollectorSet_Start(This,Synchronous)	\
    ( (This)->lpVtbl -> Start(This,Synchronous) ) 

#define IDataCollectorSet_Stop(This,Synchronous)	\
    ( (This)->lpVtbl -> Stop(This,Synchronous) ) 

#define IDataCollectorSet_SetXml(This,xml,validation)	\
    ( (This)->lpVtbl -> SetXml(This,xml,validation) ) 

#define IDataCollectorSet_SetValue(This,key,value)	\
    ( (This)->lpVtbl -> SetValue(This,key,value) ) 

#define IDataCollectorSet_GetValue(This,key,value)	\
    ( (This)->lpVtbl -> GetValue(This,key,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDataCollectorSet_INTERFACE_DEFINED__ */


#ifndef __IDataManager_INTERFACE_DEFINED__
#define __IDataManager_INTERFACE_DEFINED__

/* interface IDataManager */
/* [oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IDataManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03837541-098b-11d8-9414-505054503030")
    IDataManager : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfEnabled) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL fEnabled) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CheckBeforeRunning( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfCheck) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CheckBeforeRunning( 
            /* [in] */ VARIANT_BOOL fCheck) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MinFreeDisk( 
            /* [retval][out] */ __RPC__out ULONG *MinFreeDisk) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MinFreeDisk( 
            /* [in] */ ULONG MinFreeDisk) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MaxSize( 
            /* [retval][out] */ __RPC__out ULONG *pulMaxSize) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MaxSize( 
            /* [in] */ ULONG ulMaxSize) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MaxFolderCount( 
            /* [retval][out] */ __RPC__out ULONG *pulMaxFolderCount) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MaxFolderCount( 
            /* [in] */ ULONG ulMaxFolderCount) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ResourcePolicy( 
            /* [retval][out] */ __RPC__out ResourcePolicy *pPolicy) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ResourcePolicy( 
            /* [in] */ ResourcePolicy Policy) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FolderActions( 
            /* [retval][out] */ __RPC__deref_out_opt IFolderActionCollection **Actions) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ReportSchema( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ReportSchema) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ReportSchema( 
            /* [in] */ __RPC__in BSTR ReportSchema) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ReportFileName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrFilename) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ReportFileName( 
            /* [in] */ __RPC__in BSTR pbstrFilename) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RuleTargetFileName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Filename) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RuleTargetFileName( 
            /* [in] */ __RPC__in BSTR Filename) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EventsFileName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrFilename) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_EventsFileName( 
            /* [in] */ __RPC__in BSTR pbstrFilename) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Rules( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrXml) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Rules( 
            /* [in] */ __RPC__in BSTR bstrXml) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Run( 
            /* [in] */ DataManagerSteps Steps,
            /* [in] */ __RPC__in BSTR bstrFolder,
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **Errors) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Extract( 
            /* [in] */ __RPC__in BSTR CabFilename,
            /* [in] */ __RPC__in BSTR DestinationPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDataManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDataManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDataManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDataManager * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDataManager * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDataManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDataManager * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            IDataManager * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfEnabled);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            IDataManager * This,
            /* [in] */ VARIANT_BOOL fEnabled);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CheckBeforeRunning )( 
            IDataManager * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfCheck);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CheckBeforeRunning )( 
            IDataManager * This,
            /* [in] */ VARIANT_BOOL fCheck);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinFreeDisk )( 
            IDataManager * This,
            /* [retval][out] */ __RPC__out ULONG *MinFreeDisk);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MinFreeDisk )( 
            IDataManager * This,
            /* [in] */ ULONG MinFreeDisk);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxSize )( 
            IDataManager * This,
            /* [retval][out] */ __RPC__out ULONG *pulMaxSize);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaxSize )( 
            IDataManager * This,
            /* [in] */ ULONG ulMaxSize);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxFolderCount )( 
            IDataManager * This,
            /* [retval][out] */ __RPC__out ULONG *pulMaxFolderCount);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaxFolderCount )( 
            IDataManager * This,
            /* [in] */ ULONG ulMaxFolderCount);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ResourcePolicy )( 
            IDataManager * This,
            /* [retval][out] */ __RPC__out ResourcePolicy *pPolicy);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ResourcePolicy )( 
            IDataManager * This,
            /* [in] */ ResourcePolicy Policy);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FolderActions )( 
            IDataManager * This,
            /* [retval][out] */ __RPC__deref_out_opt IFolderActionCollection **Actions);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReportSchema )( 
            IDataManager * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ReportSchema);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReportSchema )( 
            IDataManager * This,
            /* [in] */ __RPC__in BSTR ReportSchema);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReportFileName )( 
            IDataManager * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrFilename);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReportFileName )( 
            IDataManager * This,
            /* [in] */ __RPC__in BSTR pbstrFilename);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RuleTargetFileName )( 
            IDataManager * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Filename);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RuleTargetFileName )( 
            IDataManager * This,
            /* [in] */ __RPC__in BSTR Filename);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventsFileName )( 
            IDataManager * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrFilename);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EventsFileName )( 
            IDataManager * This,
            /* [in] */ __RPC__in BSTR pbstrFilename);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Rules )( 
            IDataManager * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrXml);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Rules )( 
            IDataManager * This,
            /* [in] */ __RPC__in BSTR bstrXml);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IDataManager * This,
            /* [in] */ DataManagerSteps Steps,
            /* [in] */ __RPC__in BSTR bstrFolder,
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **Errors);
        
        HRESULT ( STDMETHODCALLTYPE *Extract )( 
            IDataManager * This,
            /* [in] */ __RPC__in BSTR CabFilename,
            /* [in] */ __RPC__in BSTR DestinationPath);
        
        END_INTERFACE
    } IDataManagerVtbl;

    interface IDataManager
    {
        CONST_VTBL struct IDataManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDataManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDataManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDataManager_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDataManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDataManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDataManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDataManager_get_Enabled(This,pfEnabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,pfEnabled) ) 

#define IDataManager_put_Enabled(This,fEnabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,fEnabled) ) 

#define IDataManager_get_CheckBeforeRunning(This,pfCheck)	\
    ( (This)->lpVtbl -> get_CheckBeforeRunning(This,pfCheck) ) 

#define IDataManager_put_CheckBeforeRunning(This,fCheck)	\
    ( (This)->lpVtbl -> put_CheckBeforeRunning(This,fCheck) ) 

#define IDataManager_get_MinFreeDisk(This,MinFreeDisk)	\
    ( (This)->lpVtbl -> get_MinFreeDisk(This,MinFreeDisk) ) 

#define IDataManager_put_MinFreeDisk(This,MinFreeDisk)	\
    ( (This)->lpVtbl -> put_MinFreeDisk(This,MinFreeDisk) ) 

#define IDataManager_get_MaxSize(This,pulMaxSize)	\
    ( (This)->lpVtbl -> get_MaxSize(This,pulMaxSize) ) 

#define IDataManager_put_MaxSize(This,ulMaxSize)	\
    ( (This)->lpVtbl -> put_MaxSize(This,ulMaxSize) ) 

#define IDataManager_get_MaxFolderCount(This,pulMaxFolderCount)	\
    ( (This)->lpVtbl -> get_MaxFolderCount(This,pulMaxFolderCount) ) 

#define IDataManager_put_MaxFolderCount(This,ulMaxFolderCount)	\
    ( (This)->lpVtbl -> put_MaxFolderCount(This,ulMaxFolderCount) ) 

#define IDataManager_get_ResourcePolicy(This,pPolicy)	\
    ( (This)->lpVtbl -> get_ResourcePolicy(This,pPolicy) ) 

#define IDataManager_put_ResourcePolicy(This,Policy)	\
    ( (This)->lpVtbl -> put_ResourcePolicy(This,Policy) ) 

#define IDataManager_get_FolderActions(This,Actions)	\
    ( (This)->lpVtbl -> get_FolderActions(This,Actions) ) 

#define IDataManager_get_ReportSchema(This,ReportSchema)	\
    ( (This)->lpVtbl -> get_ReportSchema(This,ReportSchema) ) 

#define IDataManager_put_ReportSchema(This,ReportSchema)	\
    ( (This)->lpVtbl -> put_ReportSchema(This,ReportSchema) ) 

#define IDataManager_get_ReportFileName(This,pbstrFilename)	\
    ( (This)->lpVtbl -> get_ReportFileName(This,pbstrFilename) ) 

#define IDataManager_put_ReportFileName(This,pbstrFilename)	\
    ( (This)->lpVtbl -> put_ReportFileName(This,pbstrFilename) ) 

#define IDataManager_get_RuleTargetFileName(This,Filename)	\
    ( (This)->lpVtbl -> get_RuleTargetFileName(This,Filename) ) 

#define IDataManager_put_RuleTargetFileName(This,Filename)	\
    ( (This)->lpVtbl -> put_RuleTargetFileName(This,Filename) ) 

#define IDataManager_get_EventsFileName(This,pbstrFilename)	\
    ( (This)->lpVtbl -> get_EventsFileName(This,pbstrFilename) ) 

#define IDataManager_put_EventsFileName(This,pbstrFilename)	\
    ( (This)->lpVtbl -> put_EventsFileName(This,pbstrFilename) ) 

#define IDataManager_get_Rules(This,pbstrXml)	\
    ( (This)->lpVtbl -> get_Rules(This,pbstrXml) ) 

#define IDataManager_put_Rules(This,bstrXml)	\
    ( (This)->lpVtbl -> put_Rules(This,bstrXml) ) 

#define IDataManager_Run(This,Steps,bstrFolder,Errors)	\
    ( (This)->lpVtbl -> Run(This,Steps,bstrFolder,Errors) ) 

#define IDataManager_Extract(This,CabFilename,DestinationPath)	\
    ( (This)->lpVtbl -> Extract(This,CabFilename,DestinationPath) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDataManager_INTERFACE_DEFINED__ */


#ifndef __IFolderAction_INTERFACE_DEFINED__
#define __IFolderAction_INTERFACE_DEFINED__

/* interface IFolderAction */
/* [oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IFolderAction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03837543-098b-11d8-9414-505054503030")
    IFolderAction : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Age( 
            /* [retval][out] */ __RPC__out ULONG *pulAge) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Age( 
            /* [in] */ ULONG ulAge) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Size( 
            /* [retval][out] */ __RPC__out ULONG *pulAge) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Size( 
            /* [in] */ ULONG ulAge) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Actions( 
            /* [retval][out] */ __RPC__out FolderActionSteps *Steps) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Actions( 
            /* [in] */ FolderActionSteps Steps) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SendCabTo( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDestination) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SendCabTo( 
            /* [in] */ __RPC__in BSTR bstrDestination) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderActionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFolderAction * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFolderAction * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFolderAction * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFolderAction * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFolderAction * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFolderAction * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFolderAction * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Age )( 
            IFolderAction * This,
            /* [retval][out] */ __RPC__out ULONG *pulAge);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Age )( 
            IFolderAction * This,
            /* [in] */ ULONG ulAge);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Size )( 
            IFolderAction * This,
            /* [retval][out] */ __RPC__out ULONG *pulAge);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Size )( 
            IFolderAction * This,
            /* [in] */ ULONG ulAge);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Actions )( 
            IFolderAction * This,
            /* [retval][out] */ __RPC__out FolderActionSteps *Steps);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Actions )( 
            IFolderAction * This,
            /* [in] */ FolderActionSteps Steps);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SendCabTo )( 
            IFolderAction * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDestination);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SendCabTo )( 
            IFolderAction * This,
            /* [in] */ __RPC__in BSTR bstrDestination);
        
        END_INTERFACE
    } IFolderActionVtbl;

    interface IFolderAction
    {
        CONST_VTBL struct IFolderActionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolderAction_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFolderAction_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFolderAction_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFolderAction_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IFolderAction_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IFolderAction_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IFolderAction_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IFolderAction_get_Age(This,pulAge)	\
    ( (This)->lpVtbl -> get_Age(This,pulAge) ) 

#define IFolderAction_put_Age(This,ulAge)	\
    ( (This)->lpVtbl -> put_Age(This,ulAge) ) 

#define IFolderAction_get_Size(This,pulAge)	\
    ( (This)->lpVtbl -> get_Size(This,pulAge) ) 

#define IFolderAction_put_Size(This,ulAge)	\
    ( (This)->lpVtbl -> put_Size(This,ulAge) ) 

#define IFolderAction_get_Actions(This,Steps)	\
    ( (This)->lpVtbl -> get_Actions(This,Steps) ) 

#define IFolderAction_put_Actions(This,Steps)	\
    ( (This)->lpVtbl -> put_Actions(This,Steps) ) 

#define IFolderAction_get_SendCabTo(This,pbstrDestination)	\
    ( (This)->lpVtbl -> get_SendCabTo(This,pbstrDestination) ) 

#define IFolderAction_put_SendCabTo(This,bstrDestination)	\
    ( (This)->lpVtbl -> put_SendCabTo(This,bstrDestination) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFolderAction_INTERFACE_DEFINED__ */


#ifndef __IFolderActionCollection_INTERFACE_DEFINED__
#define __IFolderActionCollection_INTERFACE_DEFINED__

/* interface IFolderActionCollection */
/* [nonextensible][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IFolderActionCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03837544-098b-11d8-9414-505054503030")
    IFolderActionCollection : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out ULONG *Count) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt IFolderAction **Action) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **Enum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            __RPC__in_opt IFolderAction *Action) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            VARIANT Index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRange( 
            __RPC__in_opt IFolderActionCollection *Actions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateFolderAction( 
            /* [retval][out] */ __RPC__deref_out_opt IFolderAction **FolderAction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderActionCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFolderActionCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFolderActionCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFolderActionCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IFolderActionCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IFolderActionCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IFolderActionCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFolderActionCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IFolderActionCollection * This,
            /* [retval][out] */ __RPC__out ULONG *Count);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IFolderActionCollection * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt IFolderAction **Action);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IFolderActionCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **Enum);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            IFolderActionCollection * This,
            __RPC__in_opt IFolderAction *Action);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IFolderActionCollection * This,
            VARIANT Index);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IFolderActionCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddRange )( 
            IFolderActionCollection * This,
            __RPC__in_opt IFolderActionCollection *Actions);
        
        HRESULT ( STDMETHODCALLTYPE *CreateFolderAction )( 
            IFolderActionCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IFolderAction **FolderAction);
        
        END_INTERFACE
    } IFolderActionCollectionVtbl;

    interface IFolderActionCollection
    {
        CONST_VTBL struct IFolderActionCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolderActionCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFolderActionCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFolderActionCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFolderActionCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IFolderActionCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IFolderActionCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IFolderActionCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IFolderActionCollection_get_Count(This,Count)	\
    ( (This)->lpVtbl -> get_Count(This,Count) ) 

#define IFolderActionCollection_get_Item(This,Index,Action)	\
    ( (This)->lpVtbl -> get_Item(This,Index,Action) ) 

#define IFolderActionCollection_get__NewEnum(This,Enum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,Enum) ) 

#define IFolderActionCollection_Add(This,Action)	\
    ( (This)->lpVtbl -> Add(This,Action) ) 

#define IFolderActionCollection_Remove(This,Index)	\
    ( (This)->lpVtbl -> Remove(This,Index) ) 

#define IFolderActionCollection_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define IFolderActionCollection_AddRange(This,Actions)	\
    ( (This)->lpVtbl -> AddRange(This,Actions) ) 

#define IFolderActionCollection_CreateFolderAction(This,FolderAction)	\
    ( (This)->lpVtbl -> CreateFolderAction(This,FolderAction) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFolderActionCollection_INTERFACE_DEFINED__ */


#ifndef __IDataCollector_INTERFACE_DEFINED__
#define __IDataCollector_INTERFACE_DEFINED__

/* interface IDataCollector */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_IDataCollector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("038374ff-098b-11d8-9414-505054503030")
    IDataCollector : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DataCollectorSet( 
            /* [retval][out] */ __RPC__deref_out_opt IDataCollectorSet **group) = 0;
        
        virtual /* [restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE put_DataCollectorSet( 
            /* [in] */ __RPC__in_opt IDataCollectorSet *group) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DataCollectorType( 
            /* [retval][out] */ __RPC__out DataCollectorType *type) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FileName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_FileName( 
            /* [in] */ __RPC__in BSTR name) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FileNameFormat( 
            /* [retval][out] */ __RPC__out AutoPathFormat *format) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_FileNameFormat( 
            /* [in] */ AutoPathFormat format) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FileNameFormatPattern( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pattern) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_FileNameFormatPattern( 
            /* [in] */ __RPC__in BSTR pattern) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LatestOutputLocation( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *path) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LatestOutputLocation( 
            /* [in] */ __RPC__in BSTR path) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LogAppend( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *append) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LogAppend( 
            /* [in] */ VARIANT_BOOL append) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LogCircular( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *circular) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LogCircular( 
            /* [in] */ VARIANT_BOOL circular) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LogOverwrite( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *overwrite) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LogOverwrite( 
            /* [in] */ VARIANT_BOOL overwrite) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ __RPC__in BSTR name) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_OutputLocation( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *path) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Index( 
            /* [retval][out] */ __RPC__out long *index) = 0;
        
        virtual /* [restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE put_Index( 
            /* [in] */ long index) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Xml( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Xml) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetXml( 
            /* [in] */ __RPC__in BSTR Xml,
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **Validation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateOutputLocation( 
            /* [in] */ VARIANT_BOOL Latest,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Location) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataCollectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDataCollector * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDataCollector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDataCollector * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDataCollector * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDataCollector * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDataCollector * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDataCollector * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataCollectorSet )( 
            IDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollectorSet **group);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DataCollectorSet )( 
            IDataCollector * This,
            /* [in] */ __RPC__in_opt IDataCollectorSet *group);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataCollectorType )( 
            IDataCollector * This,
            /* [retval][out] */ __RPC__out DataCollectorType *type);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            IDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileName )( 
            IDataCollector * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileNameFormat )( 
            IDataCollector * This,
            /* [retval][out] */ __RPC__out AutoPathFormat *format);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileNameFormat )( 
            IDataCollector * This,
            /* [in] */ AutoPathFormat format);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileNameFormatPattern )( 
            IDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pattern);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileNameFormatPattern )( 
            IDataCollector * This,
            /* [in] */ __RPC__in BSTR pattern);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LatestOutputLocation )( 
            IDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *path);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LatestOutputLocation )( 
            IDataCollector * This,
            /* [in] */ __RPC__in BSTR path);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogAppend )( 
            IDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *append);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogAppend )( 
            IDataCollector * This,
            /* [in] */ VARIANT_BOOL append);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogCircular )( 
            IDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *circular);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogCircular )( 
            IDataCollector * This,
            /* [in] */ VARIANT_BOOL circular);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogOverwrite )( 
            IDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *overwrite);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogOverwrite )( 
            IDataCollector * This,
            /* [in] */ VARIANT_BOOL overwrite);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            IDataCollector * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutputLocation )( 
            IDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *path);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Index )( 
            IDataCollector * This,
            /* [retval][out] */ __RPC__out long *index);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Index )( 
            IDataCollector * This,
            /* [in] */ long index);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Xml )( 
            IDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Xml);
        
        HRESULT ( STDMETHODCALLTYPE *SetXml )( 
            IDataCollector * This,
            /* [in] */ __RPC__in BSTR Xml,
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **Validation);
        
        HRESULT ( STDMETHODCALLTYPE *CreateOutputLocation )( 
            IDataCollector * This,
            /* [in] */ VARIANT_BOOL Latest,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Location);
        
        END_INTERFACE
    } IDataCollectorVtbl;

    interface IDataCollector
    {
        CONST_VTBL struct IDataCollectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataCollector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDataCollector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDataCollector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDataCollector_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDataCollector_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDataCollector_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDataCollector_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDataCollector_get_DataCollectorSet(This,group)	\
    ( (This)->lpVtbl -> get_DataCollectorSet(This,group) ) 

#define IDataCollector_put_DataCollectorSet(This,group)	\
    ( (This)->lpVtbl -> put_DataCollectorSet(This,group) ) 

#define IDataCollector_get_DataCollectorType(This,type)	\
    ( (This)->lpVtbl -> get_DataCollectorType(This,type) ) 

#define IDataCollector_get_FileName(This,name)	\
    ( (This)->lpVtbl -> get_FileName(This,name) ) 

#define IDataCollector_put_FileName(This,name)	\
    ( (This)->lpVtbl -> put_FileName(This,name) ) 

#define IDataCollector_get_FileNameFormat(This,format)	\
    ( (This)->lpVtbl -> get_FileNameFormat(This,format) ) 

#define IDataCollector_put_FileNameFormat(This,format)	\
    ( (This)->lpVtbl -> put_FileNameFormat(This,format) ) 

#define IDataCollector_get_FileNameFormatPattern(This,pattern)	\
    ( (This)->lpVtbl -> get_FileNameFormatPattern(This,pattern) ) 

#define IDataCollector_put_FileNameFormatPattern(This,pattern)	\
    ( (This)->lpVtbl -> put_FileNameFormatPattern(This,pattern) ) 

#define IDataCollector_get_LatestOutputLocation(This,path)	\
    ( (This)->lpVtbl -> get_LatestOutputLocation(This,path) ) 

#define IDataCollector_put_LatestOutputLocation(This,path)	\
    ( (This)->lpVtbl -> put_LatestOutputLocation(This,path) ) 

#define IDataCollector_get_LogAppend(This,append)	\
    ( (This)->lpVtbl -> get_LogAppend(This,append) ) 

#define IDataCollector_put_LogAppend(This,append)	\
    ( (This)->lpVtbl -> put_LogAppend(This,append) ) 

#define IDataCollector_get_LogCircular(This,circular)	\
    ( (This)->lpVtbl -> get_LogCircular(This,circular) ) 

#define IDataCollector_put_LogCircular(This,circular)	\
    ( (This)->lpVtbl -> put_LogCircular(This,circular) ) 

#define IDataCollector_get_LogOverwrite(This,overwrite)	\
    ( (This)->lpVtbl -> get_LogOverwrite(This,overwrite) ) 

#define IDataCollector_put_LogOverwrite(This,overwrite)	\
    ( (This)->lpVtbl -> put_LogOverwrite(This,overwrite) ) 

#define IDataCollector_get_Name(This,name)	\
    ( (This)->lpVtbl -> get_Name(This,name) ) 

#define IDataCollector_put_Name(This,name)	\
    ( (This)->lpVtbl -> put_Name(This,name) ) 

#define IDataCollector_get_OutputLocation(This,path)	\
    ( (This)->lpVtbl -> get_OutputLocation(This,path) ) 

#define IDataCollector_get_Index(This,index)	\
    ( (This)->lpVtbl -> get_Index(This,index) ) 

#define IDataCollector_put_Index(This,index)	\
    ( (This)->lpVtbl -> put_Index(This,index) ) 

#define IDataCollector_get_Xml(This,Xml)	\
    ( (This)->lpVtbl -> get_Xml(This,Xml) ) 

#define IDataCollector_SetXml(This,Xml,Validation)	\
    ( (This)->lpVtbl -> SetXml(This,Xml,Validation) ) 

#define IDataCollector_CreateOutputLocation(This,Latest,Location)	\
    ( (This)->lpVtbl -> CreateOutputLocation(This,Latest,Location) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDataCollector_INTERFACE_DEFINED__ */


#ifndef __IPerformanceCounterDataCollector_INTERFACE_DEFINED__
#define __IPerformanceCounterDataCollector_INTERFACE_DEFINED__

/* interface IPerformanceCounterDataCollector */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_IPerformanceCounterDataCollector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03837506-098b-11d8-9414-505054503030")
    IPerformanceCounterDataCollector : public IDataCollector
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DataSourceName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *dsn) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DataSourceName( 
            /* [in] */ __RPC__in BSTR dsn) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PerformanceCounters( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *counters) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PerformanceCounters( 
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * counters) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LogFileFormat( 
            /* [retval][out] */ __RPC__out FileFormat *format) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LogFileFormat( 
            /* [in] */ FileFormat format) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SampleInterval( 
            /* [retval][out] */ __RPC__out unsigned long *interval) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SampleInterval( 
            /* [in] */ unsigned long interval) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SegmentMaxRecords( 
            /* [retval][out] */ __RPC__out unsigned long *records) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SegmentMaxRecords( 
            /* [in] */ unsigned long records) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPerformanceCounterDataCollectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPerformanceCounterDataCollector * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPerformanceCounterDataCollector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPerformanceCounterDataCollector * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPerformanceCounterDataCollector * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPerformanceCounterDataCollector * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPerformanceCounterDataCollector * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPerformanceCounterDataCollector * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataCollectorSet )( 
            IPerformanceCounterDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollectorSet **group);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DataCollectorSet )( 
            IPerformanceCounterDataCollector * This,
            /* [in] */ __RPC__in_opt IDataCollectorSet *group);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataCollectorType )( 
            IPerformanceCounterDataCollector * This,
            /* [retval][out] */ __RPC__out DataCollectorType *type);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            IPerformanceCounterDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileName )( 
            IPerformanceCounterDataCollector * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileNameFormat )( 
            IPerformanceCounterDataCollector * This,
            /* [retval][out] */ __RPC__out AutoPathFormat *format);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileNameFormat )( 
            IPerformanceCounterDataCollector * This,
            /* [in] */ AutoPathFormat format);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileNameFormatPattern )( 
            IPerformanceCounterDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pattern);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileNameFormatPattern )( 
            IPerformanceCounterDataCollector * This,
            /* [in] */ __RPC__in BSTR pattern);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LatestOutputLocation )( 
            IPerformanceCounterDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *path);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LatestOutputLocation )( 
            IPerformanceCounterDataCollector * This,
            /* [in] */ __RPC__in BSTR path);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogAppend )( 
            IPerformanceCounterDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *append);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogAppend )( 
            IPerformanceCounterDataCollector * This,
            /* [in] */ VARIANT_BOOL append);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogCircular )( 
            IPerformanceCounterDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *circular);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogCircular )( 
            IPerformanceCounterDataCollector * This,
            /* [in] */ VARIANT_BOOL circular);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogOverwrite )( 
            IPerformanceCounterDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *overwrite);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogOverwrite )( 
            IPerformanceCounterDataCollector * This,
            /* [in] */ VARIANT_BOOL overwrite);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IPerformanceCounterDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            IPerformanceCounterDataCollector * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutputLocation )( 
            IPerformanceCounterDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *path);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Index )( 
            IPerformanceCounterDataCollector * This,
            /* [retval][out] */ __RPC__out long *index);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Index )( 
            IPerformanceCounterDataCollector * This,
            /* [in] */ long index);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Xml )( 
            IPerformanceCounterDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Xml);
        
        HRESULT ( STDMETHODCALLTYPE *SetXml )( 
            IPerformanceCounterDataCollector * This,
            /* [in] */ __RPC__in BSTR Xml,
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **Validation);
        
        HRESULT ( STDMETHODCALLTYPE *CreateOutputLocation )( 
            IPerformanceCounterDataCollector * This,
            /* [in] */ VARIANT_BOOL Latest,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Location);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataSourceName )( 
            IPerformanceCounterDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *dsn);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DataSourceName )( 
            IPerformanceCounterDataCollector * This,
            /* [in] */ __RPC__in BSTR dsn);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PerformanceCounters )( 
            IPerformanceCounterDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *counters);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PerformanceCounters )( 
            IPerformanceCounterDataCollector * This,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * counters);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogFileFormat )( 
            IPerformanceCounterDataCollector * This,
            /* [retval][out] */ __RPC__out FileFormat *format);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogFileFormat )( 
            IPerformanceCounterDataCollector * This,
            /* [in] */ FileFormat format);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SampleInterval )( 
            IPerformanceCounterDataCollector * This,
            /* [retval][out] */ __RPC__out unsigned long *interval);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SampleInterval )( 
            IPerformanceCounterDataCollector * This,
            /* [in] */ unsigned long interval);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SegmentMaxRecords )( 
            IPerformanceCounterDataCollector * This,
            /* [retval][out] */ __RPC__out unsigned long *records);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SegmentMaxRecords )( 
            IPerformanceCounterDataCollector * This,
            /* [in] */ unsigned long records);
        
        END_INTERFACE
    } IPerformanceCounterDataCollectorVtbl;

    interface IPerformanceCounterDataCollector
    {
        CONST_VTBL struct IPerformanceCounterDataCollectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPerformanceCounterDataCollector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPerformanceCounterDataCollector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPerformanceCounterDataCollector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPerformanceCounterDataCollector_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IPerformanceCounterDataCollector_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IPerformanceCounterDataCollector_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IPerformanceCounterDataCollector_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IPerformanceCounterDataCollector_get_DataCollectorSet(This,group)	\
    ( (This)->lpVtbl -> get_DataCollectorSet(This,group) ) 

#define IPerformanceCounterDataCollector_put_DataCollectorSet(This,group)	\
    ( (This)->lpVtbl -> put_DataCollectorSet(This,group) ) 

#define IPerformanceCounterDataCollector_get_DataCollectorType(This,type)	\
    ( (This)->lpVtbl -> get_DataCollectorType(This,type) ) 

#define IPerformanceCounterDataCollector_get_FileName(This,name)	\
    ( (This)->lpVtbl -> get_FileName(This,name) ) 

#define IPerformanceCounterDataCollector_put_FileName(This,name)	\
    ( (This)->lpVtbl -> put_FileName(This,name) ) 

#define IPerformanceCounterDataCollector_get_FileNameFormat(This,format)	\
    ( (This)->lpVtbl -> get_FileNameFormat(This,format) ) 

#define IPerformanceCounterDataCollector_put_FileNameFormat(This,format)	\
    ( (This)->lpVtbl -> put_FileNameFormat(This,format) ) 

#define IPerformanceCounterDataCollector_get_FileNameFormatPattern(This,pattern)	\
    ( (This)->lpVtbl -> get_FileNameFormatPattern(This,pattern) ) 

#define IPerformanceCounterDataCollector_put_FileNameFormatPattern(This,pattern)	\
    ( (This)->lpVtbl -> put_FileNameFormatPattern(This,pattern) ) 

#define IPerformanceCounterDataCollector_get_LatestOutputLocation(This,path)	\
    ( (This)->lpVtbl -> get_LatestOutputLocation(This,path) ) 

#define IPerformanceCounterDataCollector_put_LatestOutputLocation(This,path)	\
    ( (This)->lpVtbl -> put_LatestOutputLocation(This,path) ) 

#define IPerformanceCounterDataCollector_get_LogAppend(This,append)	\
    ( (This)->lpVtbl -> get_LogAppend(This,append) ) 

#define IPerformanceCounterDataCollector_put_LogAppend(This,append)	\
    ( (This)->lpVtbl -> put_LogAppend(This,append) ) 

#define IPerformanceCounterDataCollector_get_LogCircular(This,circular)	\
    ( (This)->lpVtbl -> get_LogCircular(This,circular) ) 

#define IPerformanceCounterDataCollector_put_LogCircular(This,circular)	\
    ( (This)->lpVtbl -> put_LogCircular(This,circular) ) 

#define IPerformanceCounterDataCollector_get_LogOverwrite(This,overwrite)	\
    ( (This)->lpVtbl -> get_LogOverwrite(This,overwrite) ) 

#define IPerformanceCounterDataCollector_put_LogOverwrite(This,overwrite)	\
    ( (This)->lpVtbl -> put_LogOverwrite(This,overwrite) ) 

#define IPerformanceCounterDataCollector_get_Name(This,name)	\
    ( (This)->lpVtbl -> get_Name(This,name) ) 

#define IPerformanceCounterDataCollector_put_Name(This,name)	\
    ( (This)->lpVtbl -> put_Name(This,name) ) 

#define IPerformanceCounterDataCollector_get_OutputLocation(This,path)	\
    ( (This)->lpVtbl -> get_OutputLocation(This,path) ) 

#define IPerformanceCounterDataCollector_get_Index(This,index)	\
    ( (This)->lpVtbl -> get_Index(This,index) ) 

#define IPerformanceCounterDataCollector_put_Index(This,index)	\
    ( (This)->lpVtbl -> put_Index(This,index) ) 

#define IPerformanceCounterDataCollector_get_Xml(This,Xml)	\
    ( (This)->lpVtbl -> get_Xml(This,Xml) ) 

#define IPerformanceCounterDataCollector_SetXml(This,Xml,Validation)	\
    ( (This)->lpVtbl -> SetXml(This,Xml,Validation) ) 

#define IPerformanceCounterDataCollector_CreateOutputLocation(This,Latest,Location)	\
    ( (This)->lpVtbl -> CreateOutputLocation(This,Latest,Location) ) 


#define IPerformanceCounterDataCollector_get_DataSourceName(This,dsn)	\
    ( (This)->lpVtbl -> get_DataSourceName(This,dsn) ) 

#define IPerformanceCounterDataCollector_put_DataSourceName(This,dsn)	\
    ( (This)->lpVtbl -> put_DataSourceName(This,dsn) ) 

#define IPerformanceCounterDataCollector_get_PerformanceCounters(This,counters)	\
    ( (This)->lpVtbl -> get_PerformanceCounters(This,counters) ) 

#define IPerformanceCounterDataCollector_put_PerformanceCounters(This,counters)	\
    ( (This)->lpVtbl -> put_PerformanceCounters(This,counters) ) 

#define IPerformanceCounterDataCollector_get_LogFileFormat(This,format)	\
    ( (This)->lpVtbl -> get_LogFileFormat(This,format) ) 

#define IPerformanceCounterDataCollector_put_LogFileFormat(This,format)	\
    ( (This)->lpVtbl -> put_LogFileFormat(This,format) ) 

#define IPerformanceCounterDataCollector_get_SampleInterval(This,interval)	\
    ( (This)->lpVtbl -> get_SampleInterval(This,interval) ) 

#define IPerformanceCounterDataCollector_put_SampleInterval(This,interval)	\
    ( (This)->lpVtbl -> put_SampleInterval(This,interval) ) 

#define IPerformanceCounterDataCollector_get_SegmentMaxRecords(This,records)	\
    ( (This)->lpVtbl -> get_SegmentMaxRecords(This,records) ) 

#define IPerformanceCounterDataCollector_put_SegmentMaxRecords(This,records)	\
    ( (This)->lpVtbl -> put_SegmentMaxRecords(This,records) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPerformanceCounterDataCollector_INTERFACE_DEFINED__ */


#ifndef __ITraceDataCollector_INTERFACE_DEFINED__
#define __ITraceDataCollector_INTERFACE_DEFINED__

/* interface ITraceDataCollector */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_ITraceDataCollector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0383750b-098b-11d8-9414-505054503030")
    ITraceDataCollector : public IDataCollector
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BufferSize( 
            /* [retval][out] */ __RPC__out unsigned long *size) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_BufferSize( 
            /* [in] */ unsigned long size) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BuffersLost( 
            /* [retval][out] */ __RPC__out unsigned long *buffers) = 0;
        
        virtual /* [restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE put_BuffersLost( 
            /* [in] */ unsigned long buffers) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BuffersWritten( 
            /* [retval][out] */ __RPC__out unsigned long *buffers) = 0;
        
        virtual /* [restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE put_BuffersWritten( 
            /* [in] */ unsigned long buffers) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ClockType( 
            /* [retval][out] */ __RPC__out ClockType *clock) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ClockType( 
            /* [in] */ ClockType clock) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EventsLost( 
            /* [retval][out] */ __RPC__out unsigned long *events) = 0;
        
        virtual /* [restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE put_EventsLost( 
            /* [in] */ unsigned long events) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ExtendedModes( 
            /* [retval][out] */ __RPC__out unsigned long *mode) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ExtendedModes( 
            /* [in] */ unsigned long mode) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FlushTimer( 
            /* [retval][out] */ __RPC__out unsigned long *seconds) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_FlushTimer( 
            /* [in] */ unsigned long seconds) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FreeBuffers( 
            /* [retval][out] */ __RPC__out unsigned long *buffers) = 0;
        
        virtual /* [restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE put_FreeBuffers( 
            /* [in] */ unsigned long buffers) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Guid( 
            /* [retval][out] */ __RPC__out GUID *guid) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Guid( 
            /* [in] */ GUID guid) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IsKernelTrace( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *kernel) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MaximumBuffers( 
            /* [retval][out] */ __RPC__out unsigned long *buffers) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MaximumBuffers( 
            /* [in] */ unsigned long buffers) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MinimumBuffers( 
            /* [retval][out] */ __RPC__out unsigned long *buffers) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MinimumBuffers( 
            /* [in] */ unsigned long buffers) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_NumberOfBuffers( 
            /* [retval][out] */ __RPC__out unsigned long *buffers) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_NumberOfBuffers( 
            /* [in] */ unsigned long buffers) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PreallocateFile( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allocate) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_PreallocateFile( 
            /* [in] */ VARIANT_BOOL allocate) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProcessMode( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *process) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ProcessMode( 
            /* [in] */ VARIANT_BOOL process) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RealTimeBuffersLost( 
            /* [retval][out] */ __RPC__out unsigned long *buffers) = 0;
        
        virtual /* [restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE put_RealTimeBuffersLost( 
            /* [in] */ unsigned long buffers) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SessionId( 
            /* [retval][out] */ __RPC__out ULONG64 *id) = 0;
        
        virtual /* [restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE put_SessionId( 
            /* [in] */ ULONG64 id) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SessionName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SessionName( 
            /* [in] */ __RPC__in BSTR name) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SessionThreadId( 
            /* [retval][out] */ __RPC__out unsigned long *tid) = 0;
        
        virtual /* [restricted][hidden][propput] */ HRESULT STDMETHODCALLTYPE put_SessionThreadId( 
            /* [in] */ unsigned long tid) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_StreamMode( 
            /* [retval][out] */ __RPC__out StreamMode *mode) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_StreamMode( 
            /* [in] */ StreamMode mode) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TraceDataProviders( 
            /* [retval][out] */ __RPC__deref_out_opt ITraceDataProviderCollection **providers) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITraceDataCollectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITraceDataCollector * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITraceDataCollector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITraceDataCollector * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITraceDataCollector * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITraceDataCollector * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITraceDataCollector * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITraceDataCollector * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataCollectorSet )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollectorSet **group);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DataCollectorSet )( 
            ITraceDataCollector * This,
            /* [in] */ __RPC__in_opt IDataCollectorSet *group);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataCollectorType )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__out DataCollectorType *type);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileName )( 
            ITraceDataCollector * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileNameFormat )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__out AutoPathFormat *format);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileNameFormat )( 
            ITraceDataCollector * This,
            /* [in] */ AutoPathFormat format);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileNameFormatPattern )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pattern);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileNameFormatPattern )( 
            ITraceDataCollector * This,
            /* [in] */ __RPC__in BSTR pattern);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LatestOutputLocation )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *path);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LatestOutputLocation )( 
            ITraceDataCollector * This,
            /* [in] */ __RPC__in BSTR path);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogAppend )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *append);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogAppend )( 
            ITraceDataCollector * This,
            /* [in] */ VARIANT_BOOL append);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogCircular )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *circular);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogCircular )( 
            ITraceDataCollector * This,
            /* [in] */ VARIANT_BOOL circular);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogOverwrite )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *overwrite);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogOverwrite )( 
            ITraceDataCollector * This,
            /* [in] */ VARIANT_BOOL overwrite);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            ITraceDataCollector * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutputLocation )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *path);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Index )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__out long *index);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Index )( 
            ITraceDataCollector * This,
            /* [in] */ long index);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Xml )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Xml);
        
        HRESULT ( STDMETHODCALLTYPE *SetXml )( 
            ITraceDataCollector * This,
            /* [in] */ __RPC__in BSTR Xml,
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **Validation);
        
        HRESULT ( STDMETHODCALLTYPE *CreateOutputLocation )( 
            ITraceDataCollector * This,
            /* [in] */ VARIANT_BOOL Latest,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Location);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BufferSize )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__out unsigned long *size);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_BufferSize )( 
            ITraceDataCollector * This,
            /* [in] */ unsigned long size);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BuffersLost )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__out unsigned long *buffers);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BuffersLost )( 
            ITraceDataCollector * This,
            /* [in] */ unsigned long buffers);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BuffersWritten )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__out unsigned long *buffers);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BuffersWritten )( 
            ITraceDataCollector * This,
            /* [in] */ unsigned long buffers);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClockType )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__out ClockType *clock);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClockType )( 
            ITraceDataCollector * This,
            /* [in] */ ClockType clock);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventsLost )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__out unsigned long *events);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EventsLost )( 
            ITraceDataCollector * This,
            /* [in] */ unsigned long events);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExtendedModes )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__out unsigned long *mode);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ExtendedModes )( 
            ITraceDataCollector * This,
            /* [in] */ unsigned long mode);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FlushTimer )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__out unsigned long *seconds);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FlushTimer )( 
            ITraceDataCollector * This,
            /* [in] */ unsigned long seconds);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FreeBuffers )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__out unsigned long *buffers);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FreeBuffers )( 
            ITraceDataCollector * This,
            /* [in] */ unsigned long buffers);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Guid )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__out GUID *guid);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Guid )( 
            ITraceDataCollector * This,
            /* [in] */ GUID guid);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsKernelTrace )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *kernel);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaximumBuffers )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__out unsigned long *buffers);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaximumBuffers )( 
            ITraceDataCollector * This,
            /* [in] */ unsigned long buffers);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinimumBuffers )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__out unsigned long *buffers);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MinimumBuffers )( 
            ITraceDataCollector * This,
            /* [in] */ unsigned long buffers);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_NumberOfBuffers )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__out unsigned long *buffers);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_NumberOfBuffers )( 
            ITraceDataCollector * This,
            /* [in] */ unsigned long buffers);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PreallocateFile )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allocate);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_PreallocateFile )( 
            ITraceDataCollector * This,
            /* [in] */ VARIANT_BOOL allocate);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProcessMode )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *process);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProcessMode )( 
            ITraceDataCollector * This,
            /* [in] */ VARIANT_BOOL process);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RealTimeBuffersLost )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__out unsigned long *buffers);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RealTimeBuffersLost )( 
            ITraceDataCollector * This,
            /* [in] */ unsigned long buffers);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SessionId )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__out ULONG64 *id);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SessionId )( 
            ITraceDataCollector * This,
            /* [in] */ ULONG64 id);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SessionName )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SessionName )( 
            ITraceDataCollector * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SessionThreadId )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__out unsigned long *tid);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SessionThreadId )( 
            ITraceDataCollector * This,
            /* [in] */ unsigned long tid);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamMode )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__out StreamMode *mode);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_StreamMode )( 
            ITraceDataCollector * This,
            /* [in] */ StreamMode mode);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TraceDataProviders )( 
            ITraceDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt ITraceDataProviderCollection **providers);
        
        END_INTERFACE
    } ITraceDataCollectorVtbl;

    interface ITraceDataCollector
    {
        CONST_VTBL struct ITraceDataCollectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITraceDataCollector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITraceDataCollector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITraceDataCollector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITraceDataCollector_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITraceDataCollector_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITraceDataCollector_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITraceDataCollector_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITraceDataCollector_get_DataCollectorSet(This,group)	\
    ( (This)->lpVtbl -> get_DataCollectorSet(This,group) ) 

#define ITraceDataCollector_put_DataCollectorSet(This,group)	\
    ( (This)->lpVtbl -> put_DataCollectorSet(This,group) ) 

#define ITraceDataCollector_get_DataCollectorType(This,type)	\
    ( (This)->lpVtbl -> get_DataCollectorType(This,type) ) 

#define ITraceDataCollector_get_FileName(This,name)	\
    ( (This)->lpVtbl -> get_FileName(This,name) ) 

#define ITraceDataCollector_put_FileName(This,name)	\
    ( (This)->lpVtbl -> put_FileName(This,name) ) 

#define ITraceDataCollector_get_FileNameFormat(This,format)	\
    ( (This)->lpVtbl -> get_FileNameFormat(This,format) ) 

#define ITraceDataCollector_put_FileNameFormat(This,format)	\
    ( (This)->lpVtbl -> put_FileNameFormat(This,format) ) 

#define ITraceDataCollector_get_FileNameFormatPattern(This,pattern)	\
    ( (This)->lpVtbl -> get_FileNameFormatPattern(This,pattern) ) 

#define ITraceDataCollector_put_FileNameFormatPattern(This,pattern)	\
    ( (This)->lpVtbl -> put_FileNameFormatPattern(This,pattern) ) 

#define ITraceDataCollector_get_LatestOutputLocation(This,path)	\
    ( (This)->lpVtbl -> get_LatestOutputLocation(This,path) ) 

#define ITraceDataCollector_put_LatestOutputLocation(This,path)	\
    ( (This)->lpVtbl -> put_LatestOutputLocation(This,path) ) 

#define ITraceDataCollector_get_LogAppend(This,append)	\
    ( (This)->lpVtbl -> get_LogAppend(This,append) ) 

#define ITraceDataCollector_put_LogAppend(This,append)	\
    ( (This)->lpVtbl -> put_LogAppend(This,append) ) 

#define ITraceDataCollector_get_LogCircular(This,circular)	\
    ( (This)->lpVtbl -> get_LogCircular(This,circular) ) 

#define ITraceDataCollector_put_LogCircular(This,circular)	\
    ( (This)->lpVtbl -> put_LogCircular(This,circular) ) 

#define ITraceDataCollector_get_LogOverwrite(This,overwrite)	\
    ( (This)->lpVtbl -> get_LogOverwrite(This,overwrite) ) 

#define ITraceDataCollector_put_LogOverwrite(This,overwrite)	\
    ( (This)->lpVtbl -> put_LogOverwrite(This,overwrite) ) 

#define ITraceDataCollector_get_Name(This,name)	\
    ( (This)->lpVtbl -> get_Name(This,name) ) 

#define ITraceDataCollector_put_Name(This,name)	\
    ( (This)->lpVtbl -> put_Name(This,name) ) 

#define ITraceDataCollector_get_OutputLocation(This,path)	\
    ( (This)->lpVtbl -> get_OutputLocation(This,path) ) 

#define ITraceDataCollector_get_Index(This,index)	\
    ( (This)->lpVtbl -> get_Index(This,index) ) 

#define ITraceDataCollector_put_Index(This,index)	\
    ( (This)->lpVtbl -> put_Index(This,index) ) 

#define ITraceDataCollector_get_Xml(This,Xml)	\
    ( (This)->lpVtbl -> get_Xml(This,Xml) ) 

#define ITraceDataCollector_SetXml(This,Xml,Validation)	\
    ( (This)->lpVtbl -> SetXml(This,Xml,Validation) ) 

#define ITraceDataCollector_CreateOutputLocation(This,Latest,Location)	\
    ( (This)->lpVtbl -> CreateOutputLocation(This,Latest,Location) ) 


#define ITraceDataCollector_get_BufferSize(This,size)	\
    ( (This)->lpVtbl -> get_BufferSize(This,size) ) 

#define ITraceDataCollector_put_BufferSize(This,size)	\
    ( (This)->lpVtbl -> put_BufferSize(This,size) ) 

#define ITraceDataCollector_get_BuffersLost(This,buffers)	\
    ( (This)->lpVtbl -> get_BuffersLost(This,buffers) ) 

#define ITraceDataCollector_put_BuffersLost(This,buffers)	\
    ( (This)->lpVtbl -> put_BuffersLost(This,buffers) ) 

#define ITraceDataCollector_get_BuffersWritten(This,buffers)	\
    ( (This)->lpVtbl -> get_BuffersWritten(This,buffers) ) 

#define ITraceDataCollector_put_BuffersWritten(This,buffers)	\
    ( (This)->lpVtbl -> put_BuffersWritten(This,buffers) ) 

#define ITraceDataCollector_get_ClockType(This,clock)	\
    ( (This)->lpVtbl -> get_ClockType(This,clock) ) 

#define ITraceDataCollector_put_ClockType(This,clock)	\
    ( (This)->lpVtbl -> put_ClockType(This,clock) ) 

#define ITraceDataCollector_get_EventsLost(This,events)	\
    ( (This)->lpVtbl -> get_EventsLost(This,events) ) 

#define ITraceDataCollector_put_EventsLost(This,events)	\
    ( (This)->lpVtbl -> put_EventsLost(This,events) ) 

#define ITraceDataCollector_get_ExtendedModes(This,mode)	\
    ( (This)->lpVtbl -> get_ExtendedModes(This,mode) ) 

#define ITraceDataCollector_put_ExtendedModes(This,mode)	\
    ( (This)->lpVtbl -> put_ExtendedModes(This,mode) ) 

#define ITraceDataCollector_get_FlushTimer(This,seconds)	\
    ( (This)->lpVtbl -> get_FlushTimer(This,seconds) ) 

#define ITraceDataCollector_put_FlushTimer(This,seconds)	\
    ( (This)->lpVtbl -> put_FlushTimer(This,seconds) ) 

#define ITraceDataCollector_get_FreeBuffers(This,buffers)	\
    ( (This)->lpVtbl -> get_FreeBuffers(This,buffers) ) 

#define ITraceDataCollector_put_FreeBuffers(This,buffers)	\
    ( (This)->lpVtbl -> put_FreeBuffers(This,buffers) ) 

#define ITraceDataCollector_get_Guid(This,guid)	\
    ( (This)->lpVtbl -> get_Guid(This,guid) ) 

#define ITraceDataCollector_put_Guid(This,guid)	\
    ( (This)->lpVtbl -> put_Guid(This,guid) ) 

#define ITraceDataCollector_get_IsKernelTrace(This,kernel)	\
    ( (This)->lpVtbl -> get_IsKernelTrace(This,kernel) ) 

#define ITraceDataCollector_get_MaximumBuffers(This,buffers)	\
    ( (This)->lpVtbl -> get_MaximumBuffers(This,buffers) ) 

#define ITraceDataCollector_put_MaximumBuffers(This,buffers)	\
    ( (This)->lpVtbl -> put_MaximumBuffers(This,buffers) ) 

#define ITraceDataCollector_get_MinimumBuffers(This,buffers)	\
    ( (This)->lpVtbl -> get_MinimumBuffers(This,buffers) ) 

#define ITraceDataCollector_put_MinimumBuffers(This,buffers)	\
    ( (This)->lpVtbl -> put_MinimumBuffers(This,buffers) ) 

#define ITraceDataCollector_get_NumberOfBuffers(This,buffers)	\
    ( (This)->lpVtbl -> get_NumberOfBuffers(This,buffers) ) 

#define ITraceDataCollector_put_NumberOfBuffers(This,buffers)	\
    ( (This)->lpVtbl -> put_NumberOfBuffers(This,buffers) ) 

#define ITraceDataCollector_get_PreallocateFile(This,allocate)	\
    ( (This)->lpVtbl -> get_PreallocateFile(This,allocate) ) 

#define ITraceDataCollector_put_PreallocateFile(This,allocate)	\
    ( (This)->lpVtbl -> put_PreallocateFile(This,allocate) ) 

#define ITraceDataCollector_get_ProcessMode(This,process)	\
    ( (This)->lpVtbl -> get_ProcessMode(This,process) ) 

#define ITraceDataCollector_put_ProcessMode(This,process)	\
    ( (This)->lpVtbl -> put_ProcessMode(This,process) ) 

#define ITraceDataCollector_get_RealTimeBuffersLost(This,buffers)	\
    ( (This)->lpVtbl -> get_RealTimeBuffersLost(This,buffers) ) 

#define ITraceDataCollector_put_RealTimeBuffersLost(This,buffers)	\
    ( (This)->lpVtbl -> put_RealTimeBuffersLost(This,buffers) ) 

#define ITraceDataCollector_get_SessionId(This,id)	\
    ( (This)->lpVtbl -> get_SessionId(This,id) ) 

#define ITraceDataCollector_put_SessionId(This,id)	\
    ( (This)->lpVtbl -> put_SessionId(This,id) ) 

#define ITraceDataCollector_get_SessionName(This,name)	\
    ( (This)->lpVtbl -> get_SessionName(This,name) ) 

#define ITraceDataCollector_put_SessionName(This,name)	\
    ( (This)->lpVtbl -> put_SessionName(This,name) ) 

#define ITraceDataCollector_get_SessionThreadId(This,tid)	\
    ( (This)->lpVtbl -> get_SessionThreadId(This,tid) ) 

#define ITraceDataCollector_put_SessionThreadId(This,tid)	\
    ( (This)->lpVtbl -> put_SessionThreadId(This,tid) ) 

#define ITraceDataCollector_get_StreamMode(This,mode)	\
    ( (This)->lpVtbl -> get_StreamMode(This,mode) ) 

#define ITraceDataCollector_put_StreamMode(This,mode)	\
    ( (This)->lpVtbl -> put_StreamMode(This,mode) ) 

#define ITraceDataCollector_get_TraceDataProviders(This,providers)	\
    ( (This)->lpVtbl -> get_TraceDataProviders(This,providers) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITraceDataCollector_INTERFACE_DEFINED__ */


#ifndef __IConfigurationDataCollector_INTERFACE_DEFINED__
#define __IConfigurationDataCollector_INTERFACE_DEFINED__

/* interface IConfigurationDataCollector */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_IConfigurationDataCollector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03837514-098b-11d8-9414-505054503030")
    IConfigurationDataCollector : public IDataCollector
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FileMaxCount( 
            /* [retval][out] */ __RPC__out unsigned long *count) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_FileMaxCount( 
            /* [in] */ unsigned long count) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FileMaxRecursiveDepth( 
            /* [retval][out] */ __RPC__out unsigned long *depth) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_FileMaxRecursiveDepth( 
            /* [in] */ unsigned long depth) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FileMaxTotalSize( 
            /* [retval][out] */ __RPC__out unsigned long *size) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_FileMaxTotalSize( 
            /* [in] */ unsigned long size) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Files( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *Files) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Files( 
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * Files) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ManagementQueries( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *Queries) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ManagementQueries( 
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * Queries) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_QueryNetworkAdapters( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *network) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_QueryNetworkAdapters( 
            /* [in] */ VARIANT_BOOL network) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RegistryKeys( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *query) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RegistryKeys( 
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * query) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RegistryMaxRecursiveDepth( 
            /* [retval][out] */ __RPC__out unsigned long *depth) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_RegistryMaxRecursiveDepth( 
            /* [in] */ unsigned long depth) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SystemStateFile( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *FileName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SystemStateFile( 
            /* [in] */ __RPC__in BSTR FileName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConfigurationDataCollectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IConfigurationDataCollector * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IConfigurationDataCollector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IConfigurationDataCollector * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IConfigurationDataCollector * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IConfigurationDataCollector * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IConfigurationDataCollector * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IConfigurationDataCollector * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataCollectorSet )( 
            IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollectorSet **group);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DataCollectorSet )( 
            IConfigurationDataCollector * This,
            /* [in] */ __RPC__in_opt IDataCollectorSet *group);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataCollectorType )( 
            IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__out DataCollectorType *type);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileName )( 
            IConfigurationDataCollector * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileNameFormat )( 
            IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__out AutoPathFormat *format);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileNameFormat )( 
            IConfigurationDataCollector * This,
            /* [in] */ AutoPathFormat format);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileNameFormatPattern )( 
            IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pattern);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileNameFormatPattern )( 
            IConfigurationDataCollector * This,
            /* [in] */ __RPC__in BSTR pattern);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LatestOutputLocation )( 
            IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *path);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LatestOutputLocation )( 
            IConfigurationDataCollector * This,
            /* [in] */ __RPC__in BSTR path);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogAppend )( 
            IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *append);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogAppend )( 
            IConfigurationDataCollector * This,
            /* [in] */ VARIANT_BOOL append);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogCircular )( 
            IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *circular);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogCircular )( 
            IConfigurationDataCollector * This,
            /* [in] */ VARIANT_BOOL circular);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogOverwrite )( 
            IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *overwrite);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogOverwrite )( 
            IConfigurationDataCollector * This,
            /* [in] */ VARIANT_BOOL overwrite);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            IConfigurationDataCollector * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutputLocation )( 
            IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *path);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Index )( 
            IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__out long *index);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Index )( 
            IConfigurationDataCollector * This,
            /* [in] */ long index);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Xml )( 
            IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Xml);
        
        HRESULT ( STDMETHODCALLTYPE *SetXml )( 
            IConfigurationDataCollector * This,
            /* [in] */ __RPC__in BSTR Xml,
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **Validation);
        
        HRESULT ( STDMETHODCALLTYPE *CreateOutputLocation )( 
            IConfigurationDataCollector * This,
            /* [in] */ VARIANT_BOOL Latest,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Location);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileMaxCount )( 
            IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__out unsigned long *count);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileMaxCount )( 
            IConfigurationDataCollector * This,
            /* [in] */ unsigned long count);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileMaxRecursiveDepth )( 
            IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__out unsigned long *depth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileMaxRecursiveDepth )( 
            IConfigurationDataCollector * This,
            /* [in] */ unsigned long depth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileMaxTotalSize )( 
            IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__out unsigned long *size);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileMaxTotalSize )( 
            IConfigurationDataCollector * This,
            /* [in] */ unsigned long size);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Files )( 
            IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *Files);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Files )( 
            IConfigurationDataCollector * This,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * Files);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ManagementQueries )( 
            IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *Queries);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ManagementQueries )( 
            IConfigurationDataCollector * This,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * Queries);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_QueryNetworkAdapters )( 
            IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *network);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_QueryNetworkAdapters )( 
            IConfigurationDataCollector * This,
            /* [in] */ VARIANT_BOOL network);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RegistryKeys )( 
            IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *query);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RegistryKeys )( 
            IConfigurationDataCollector * This,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * query);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RegistryMaxRecursiveDepth )( 
            IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__out unsigned long *depth);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_RegistryMaxRecursiveDepth )( 
            IConfigurationDataCollector * This,
            /* [in] */ unsigned long depth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SystemStateFile )( 
            IConfigurationDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *FileName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SystemStateFile )( 
            IConfigurationDataCollector * This,
            /* [in] */ __RPC__in BSTR FileName);
        
        END_INTERFACE
    } IConfigurationDataCollectorVtbl;

    interface IConfigurationDataCollector
    {
        CONST_VTBL struct IConfigurationDataCollectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConfigurationDataCollector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IConfigurationDataCollector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IConfigurationDataCollector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IConfigurationDataCollector_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IConfigurationDataCollector_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IConfigurationDataCollector_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IConfigurationDataCollector_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IConfigurationDataCollector_get_DataCollectorSet(This,group)	\
    ( (This)->lpVtbl -> get_DataCollectorSet(This,group) ) 

#define IConfigurationDataCollector_put_DataCollectorSet(This,group)	\
    ( (This)->lpVtbl -> put_DataCollectorSet(This,group) ) 

#define IConfigurationDataCollector_get_DataCollectorType(This,type)	\
    ( (This)->lpVtbl -> get_DataCollectorType(This,type) ) 

#define IConfigurationDataCollector_get_FileName(This,name)	\
    ( (This)->lpVtbl -> get_FileName(This,name) ) 

#define IConfigurationDataCollector_put_FileName(This,name)	\
    ( (This)->lpVtbl -> put_FileName(This,name) ) 

#define IConfigurationDataCollector_get_FileNameFormat(This,format)	\
    ( (This)->lpVtbl -> get_FileNameFormat(This,format) ) 

#define IConfigurationDataCollector_put_FileNameFormat(This,format)	\
    ( (This)->lpVtbl -> put_FileNameFormat(This,format) ) 

#define IConfigurationDataCollector_get_FileNameFormatPattern(This,pattern)	\
    ( (This)->lpVtbl -> get_FileNameFormatPattern(This,pattern) ) 

#define IConfigurationDataCollector_put_FileNameFormatPattern(This,pattern)	\
    ( (This)->lpVtbl -> put_FileNameFormatPattern(This,pattern) ) 

#define IConfigurationDataCollector_get_LatestOutputLocation(This,path)	\
    ( (This)->lpVtbl -> get_LatestOutputLocation(This,path) ) 

#define IConfigurationDataCollector_put_LatestOutputLocation(This,path)	\
    ( (This)->lpVtbl -> put_LatestOutputLocation(This,path) ) 

#define IConfigurationDataCollector_get_LogAppend(This,append)	\
    ( (This)->lpVtbl -> get_LogAppend(This,append) ) 

#define IConfigurationDataCollector_put_LogAppend(This,append)	\
    ( (This)->lpVtbl -> put_LogAppend(This,append) ) 

#define IConfigurationDataCollector_get_LogCircular(This,circular)	\
    ( (This)->lpVtbl -> get_LogCircular(This,circular) ) 

#define IConfigurationDataCollector_put_LogCircular(This,circular)	\
    ( (This)->lpVtbl -> put_LogCircular(This,circular) ) 

#define IConfigurationDataCollector_get_LogOverwrite(This,overwrite)	\
    ( (This)->lpVtbl -> get_LogOverwrite(This,overwrite) ) 

#define IConfigurationDataCollector_put_LogOverwrite(This,overwrite)	\
    ( (This)->lpVtbl -> put_LogOverwrite(This,overwrite) ) 

#define IConfigurationDataCollector_get_Name(This,name)	\
    ( (This)->lpVtbl -> get_Name(This,name) ) 

#define IConfigurationDataCollector_put_Name(This,name)	\
    ( (This)->lpVtbl -> put_Name(This,name) ) 

#define IConfigurationDataCollector_get_OutputLocation(This,path)	\
    ( (This)->lpVtbl -> get_OutputLocation(This,path) ) 

#define IConfigurationDataCollector_get_Index(This,index)	\
    ( (This)->lpVtbl -> get_Index(This,index) ) 

#define IConfigurationDataCollector_put_Index(This,index)	\
    ( (This)->lpVtbl -> put_Index(This,index) ) 

#define IConfigurationDataCollector_get_Xml(This,Xml)	\
    ( (This)->lpVtbl -> get_Xml(This,Xml) ) 

#define IConfigurationDataCollector_SetXml(This,Xml,Validation)	\
    ( (This)->lpVtbl -> SetXml(This,Xml,Validation) ) 

#define IConfigurationDataCollector_CreateOutputLocation(This,Latest,Location)	\
    ( (This)->lpVtbl -> CreateOutputLocation(This,Latest,Location) ) 


#define IConfigurationDataCollector_get_FileMaxCount(This,count)	\
    ( (This)->lpVtbl -> get_FileMaxCount(This,count) ) 

#define IConfigurationDataCollector_put_FileMaxCount(This,count)	\
    ( (This)->lpVtbl -> put_FileMaxCount(This,count) ) 

#define IConfigurationDataCollector_get_FileMaxRecursiveDepth(This,depth)	\
    ( (This)->lpVtbl -> get_FileMaxRecursiveDepth(This,depth) ) 

#define IConfigurationDataCollector_put_FileMaxRecursiveDepth(This,depth)	\
    ( (This)->lpVtbl -> put_FileMaxRecursiveDepth(This,depth) ) 

#define IConfigurationDataCollector_get_FileMaxTotalSize(This,size)	\
    ( (This)->lpVtbl -> get_FileMaxTotalSize(This,size) ) 

#define IConfigurationDataCollector_put_FileMaxTotalSize(This,size)	\
    ( (This)->lpVtbl -> put_FileMaxTotalSize(This,size) ) 

#define IConfigurationDataCollector_get_Files(This,Files)	\
    ( (This)->lpVtbl -> get_Files(This,Files) ) 

#define IConfigurationDataCollector_put_Files(This,Files)	\
    ( (This)->lpVtbl -> put_Files(This,Files) ) 

#define IConfigurationDataCollector_get_ManagementQueries(This,Queries)	\
    ( (This)->lpVtbl -> get_ManagementQueries(This,Queries) ) 

#define IConfigurationDataCollector_put_ManagementQueries(This,Queries)	\
    ( (This)->lpVtbl -> put_ManagementQueries(This,Queries) ) 

#define IConfigurationDataCollector_get_QueryNetworkAdapters(This,network)	\
    ( (This)->lpVtbl -> get_QueryNetworkAdapters(This,network) ) 

#define IConfigurationDataCollector_put_QueryNetworkAdapters(This,network)	\
    ( (This)->lpVtbl -> put_QueryNetworkAdapters(This,network) ) 

#define IConfigurationDataCollector_get_RegistryKeys(This,query)	\
    ( (This)->lpVtbl -> get_RegistryKeys(This,query) ) 

#define IConfigurationDataCollector_put_RegistryKeys(This,query)	\
    ( (This)->lpVtbl -> put_RegistryKeys(This,query) ) 

#define IConfigurationDataCollector_get_RegistryMaxRecursiveDepth(This,depth)	\
    ( (This)->lpVtbl -> get_RegistryMaxRecursiveDepth(This,depth) ) 

#define IConfigurationDataCollector_put_RegistryMaxRecursiveDepth(This,depth)	\
    ( (This)->lpVtbl -> put_RegistryMaxRecursiveDepth(This,depth) ) 

#define IConfigurationDataCollector_get_SystemStateFile(This,FileName)	\
    ( (This)->lpVtbl -> get_SystemStateFile(This,FileName) ) 

#define IConfigurationDataCollector_put_SystemStateFile(This,FileName)	\
    ( (This)->lpVtbl -> put_SystemStateFile(This,FileName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IConfigurationDataCollector_INTERFACE_DEFINED__ */


#ifndef __IAlertDataCollector_INTERFACE_DEFINED__
#define __IAlertDataCollector_INTERFACE_DEFINED__

/* interface IAlertDataCollector */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_IAlertDataCollector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03837516-098b-11d8-9414-505054503030")
    IAlertDataCollector : public IDataCollector
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_AlertThresholds( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *alerts) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_AlertThresholds( 
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * alerts) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EventLog( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *log) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_EventLog( 
            /* [in] */ VARIANT_BOOL log) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SampleInterval( 
            /* [retval][out] */ __RPC__out unsigned long *interval) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SampleInterval( 
            /* [in] */ unsigned long interval) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Task( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *task) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Task( 
            /* [in] */ __RPC__in BSTR task) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TaskRunAsSelf( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *RunAsSelf) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TaskRunAsSelf( 
            /* [in] */ VARIANT_BOOL RunAsSelf) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TaskArguments( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *task) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TaskArguments( 
            /* [in] */ __RPC__in BSTR task) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TaskUserTextArguments( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *task) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TaskUserTextArguments( 
            /* [in] */ __RPC__in BSTR task) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TriggerDataCollectorSet( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TriggerDataCollectorSet( 
            /* [in] */ __RPC__in BSTR name) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAlertDataCollectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAlertDataCollector * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAlertDataCollector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAlertDataCollector * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAlertDataCollector * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAlertDataCollector * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAlertDataCollector * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAlertDataCollector * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataCollectorSet )( 
            IAlertDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollectorSet **group);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DataCollectorSet )( 
            IAlertDataCollector * This,
            /* [in] */ __RPC__in_opt IDataCollectorSet *group);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataCollectorType )( 
            IAlertDataCollector * This,
            /* [retval][out] */ __RPC__out DataCollectorType *type);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            IAlertDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileName )( 
            IAlertDataCollector * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileNameFormat )( 
            IAlertDataCollector * This,
            /* [retval][out] */ __RPC__out AutoPathFormat *format);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileNameFormat )( 
            IAlertDataCollector * This,
            /* [in] */ AutoPathFormat format);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileNameFormatPattern )( 
            IAlertDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pattern);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileNameFormatPattern )( 
            IAlertDataCollector * This,
            /* [in] */ __RPC__in BSTR pattern);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LatestOutputLocation )( 
            IAlertDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *path);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LatestOutputLocation )( 
            IAlertDataCollector * This,
            /* [in] */ __RPC__in BSTR path);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogAppend )( 
            IAlertDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *append);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogAppend )( 
            IAlertDataCollector * This,
            /* [in] */ VARIANT_BOOL append);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogCircular )( 
            IAlertDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *circular);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogCircular )( 
            IAlertDataCollector * This,
            /* [in] */ VARIANT_BOOL circular);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogOverwrite )( 
            IAlertDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *overwrite);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogOverwrite )( 
            IAlertDataCollector * This,
            /* [in] */ VARIANT_BOOL overwrite);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IAlertDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            IAlertDataCollector * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutputLocation )( 
            IAlertDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *path);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Index )( 
            IAlertDataCollector * This,
            /* [retval][out] */ __RPC__out long *index);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Index )( 
            IAlertDataCollector * This,
            /* [in] */ long index);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Xml )( 
            IAlertDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Xml);
        
        HRESULT ( STDMETHODCALLTYPE *SetXml )( 
            IAlertDataCollector * This,
            /* [in] */ __RPC__in BSTR Xml,
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **Validation);
        
        HRESULT ( STDMETHODCALLTYPE *CreateOutputLocation )( 
            IAlertDataCollector * This,
            /* [in] */ VARIANT_BOOL Latest,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Location);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AlertThresholds )( 
            IAlertDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *alerts);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_AlertThresholds )( 
            IAlertDataCollector * This,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * alerts);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventLog )( 
            IAlertDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *log);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EventLog )( 
            IAlertDataCollector * This,
            /* [in] */ VARIANT_BOOL log);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SampleInterval )( 
            IAlertDataCollector * This,
            /* [retval][out] */ __RPC__out unsigned long *interval);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SampleInterval )( 
            IAlertDataCollector * This,
            /* [in] */ unsigned long interval);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Task )( 
            IAlertDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *task);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Task )( 
            IAlertDataCollector * This,
            /* [in] */ __RPC__in BSTR task);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TaskRunAsSelf )( 
            IAlertDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *RunAsSelf);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TaskRunAsSelf )( 
            IAlertDataCollector * This,
            /* [in] */ VARIANT_BOOL RunAsSelf);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TaskArguments )( 
            IAlertDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *task);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TaskArguments )( 
            IAlertDataCollector * This,
            /* [in] */ __RPC__in BSTR task);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TaskUserTextArguments )( 
            IAlertDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *task);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TaskUserTextArguments )( 
            IAlertDataCollector * This,
            /* [in] */ __RPC__in BSTR task);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TriggerDataCollectorSet )( 
            IAlertDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TriggerDataCollectorSet )( 
            IAlertDataCollector * This,
            /* [in] */ __RPC__in BSTR name);
        
        END_INTERFACE
    } IAlertDataCollectorVtbl;

    interface IAlertDataCollector
    {
        CONST_VTBL struct IAlertDataCollectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAlertDataCollector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAlertDataCollector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAlertDataCollector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAlertDataCollector_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAlertDataCollector_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAlertDataCollector_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAlertDataCollector_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IAlertDataCollector_get_DataCollectorSet(This,group)	\
    ( (This)->lpVtbl -> get_DataCollectorSet(This,group) ) 

#define IAlertDataCollector_put_DataCollectorSet(This,group)	\
    ( (This)->lpVtbl -> put_DataCollectorSet(This,group) ) 

#define IAlertDataCollector_get_DataCollectorType(This,type)	\
    ( (This)->lpVtbl -> get_DataCollectorType(This,type) ) 

#define IAlertDataCollector_get_FileName(This,name)	\
    ( (This)->lpVtbl -> get_FileName(This,name) ) 

#define IAlertDataCollector_put_FileName(This,name)	\
    ( (This)->lpVtbl -> put_FileName(This,name) ) 

#define IAlertDataCollector_get_FileNameFormat(This,format)	\
    ( (This)->lpVtbl -> get_FileNameFormat(This,format) ) 

#define IAlertDataCollector_put_FileNameFormat(This,format)	\
    ( (This)->lpVtbl -> put_FileNameFormat(This,format) ) 

#define IAlertDataCollector_get_FileNameFormatPattern(This,pattern)	\
    ( (This)->lpVtbl -> get_FileNameFormatPattern(This,pattern) ) 

#define IAlertDataCollector_put_FileNameFormatPattern(This,pattern)	\
    ( (This)->lpVtbl -> put_FileNameFormatPattern(This,pattern) ) 

#define IAlertDataCollector_get_LatestOutputLocation(This,path)	\
    ( (This)->lpVtbl -> get_LatestOutputLocation(This,path) ) 

#define IAlertDataCollector_put_LatestOutputLocation(This,path)	\
    ( (This)->lpVtbl -> put_LatestOutputLocation(This,path) ) 

#define IAlertDataCollector_get_LogAppend(This,append)	\
    ( (This)->lpVtbl -> get_LogAppend(This,append) ) 

#define IAlertDataCollector_put_LogAppend(This,append)	\
    ( (This)->lpVtbl -> put_LogAppend(This,append) ) 

#define IAlertDataCollector_get_LogCircular(This,circular)	\
    ( (This)->lpVtbl -> get_LogCircular(This,circular) ) 

#define IAlertDataCollector_put_LogCircular(This,circular)	\
    ( (This)->lpVtbl -> put_LogCircular(This,circular) ) 

#define IAlertDataCollector_get_LogOverwrite(This,overwrite)	\
    ( (This)->lpVtbl -> get_LogOverwrite(This,overwrite) ) 

#define IAlertDataCollector_put_LogOverwrite(This,overwrite)	\
    ( (This)->lpVtbl -> put_LogOverwrite(This,overwrite) ) 

#define IAlertDataCollector_get_Name(This,name)	\
    ( (This)->lpVtbl -> get_Name(This,name) ) 

#define IAlertDataCollector_put_Name(This,name)	\
    ( (This)->lpVtbl -> put_Name(This,name) ) 

#define IAlertDataCollector_get_OutputLocation(This,path)	\
    ( (This)->lpVtbl -> get_OutputLocation(This,path) ) 

#define IAlertDataCollector_get_Index(This,index)	\
    ( (This)->lpVtbl -> get_Index(This,index) ) 

#define IAlertDataCollector_put_Index(This,index)	\
    ( (This)->lpVtbl -> put_Index(This,index) ) 

#define IAlertDataCollector_get_Xml(This,Xml)	\
    ( (This)->lpVtbl -> get_Xml(This,Xml) ) 

#define IAlertDataCollector_SetXml(This,Xml,Validation)	\
    ( (This)->lpVtbl -> SetXml(This,Xml,Validation) ) 

#define IAlertDataCollector_CreateOutputLocation(This,Latest,Location)	\
    ( (This)->lpVtbl -> CreateOutputLocation(This,Latest,Location) ) 


#define IAlertDataCollector_get_AlertThresholds(This,alerts)	\
    ( (This)->lpVtbl -> get_AlertThresholds(This,alerts) ) 

#define IAlertDataCollector_put_AlertThresholds(This,alerts)	\
    ( (This)->lpVtbl -> put_AlertThresholds(This,alerts) ) 

#define IAlertDataCollector_get_EventLog(This,log)	\
    ( (This)->lpVtbl -> get_EventLog(This,log) ) 

#define IAlertDataCollector_put_EventLog(This,log)	\
    ( (This)->lpVtbl -> put_EventLog(This,log) ) 

#define IAlertDataCollector_get_SampleInterval(This,interval)	\
    ( (This)->lpVtbl -> get_SampleInterval(This,interval) ) 

#define IAlertDataCollector_put_SampleInterval(This,interval)	\
    ( (This)->lpVtbl -> put_SampleInterval(This,interval) ) 

#define IAlertDataCollector_get_Task(This,task)	\
    ( (This)->lpVtbl -> get_Task(This,task) ) 

#define IAlertDataCollector_put_Task(This,task)	\
    ( (This)->lpVtbl -> put_Task(This,task) ) 

#define IAlertDataCollector_get_TaskRunAsSelf(This,RunAsSelf)	\
    ( (This)->lpVtbl -> get_TaskRunAsSelf(This,RunAsSelf) ) 

#define IAlertDataCollector_put_TaskRunAsSelf(This,RunAsSelf)	\
    ( (This)->lpVtbl -> put_TaskRunAsSelf(This,RunAsSelf) ) 

#define IAlertDataCollector_get_TaskArguments(This,task)	\
    ( (This)->lpVtbl -> get_TaskArguments(This,task) ) 

#define IAlertDataCollector_put_TaskArguments(This,task)	\
    ( (This)->lpVtbl -> put_TaskArguments(This,task) ) 

#define IAlertDataCollector_get_TaskUserTextArguments(This,task)	\
    ( (This)->lpVtbl -> get_TaskUserTextArguments(This,task) ) 

#define IAlertDataCollector_put_TaskUserTextArguments(This,task)	\
    ( (This)->lpVtbl -> put_TaskUserTextArguments(This,task) ) 

#define IAlertDataCollector_get_TriggerDataCollectorSet(This,name)	\
    ( (This)->lpVtbl -> get_TriggerDataCollectorSet(This,name) ) 

#define IAlertDataCollector_put_TriggerDataCollectorSet(This,name)	\
    ( (This)->lpVtbl -> put_TriggerDataCollectorSet(This,name) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAlertDataCollector_INTERFACE_DEFINED__ */


#ifndef __IApiTracingDataCollector_INTERFACE_DEFINED__
#define __IApiTracingDataCollector_INTERFACE_DEFINED__

/* interface IApiTracingDataCollector */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_IApiTracingDataCollector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0383751a-098b-11d8-9414-505054503030")
    IApiTracingDataCollector : public IDataCollector
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LogApiNamesOnly( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *logapinames) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LogApiNamesOnly( 
            /* [in] */ VARIANT_BOOL logapinames) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LogApisRecursively( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *logrecursively) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LogApisRecursively( 
            /* [in] */ VARIANT_BOOL logrecursively) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ExePath( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *exepath) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ExePath( 
            /* [in] */ __RPC__in BSTR exepath) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LogFilePath( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *logfilepath) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LogFilePath( 
            /* [in] */ __RPC__in BSTR logfilepath) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IncludeModules( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *includemodules) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_IncludeModules( 
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * includemodules) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IncludeApis( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *includeapis) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_IncludeApis( 
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * includeapis) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ExcludeApis( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *excludeapis) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ExcludeApis( 
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * excludeapis) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IApiTracingDataCollectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IApiTracingDataCollector * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IApiTracingDataCollector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IApiTracingDataCollector * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IApiTracingDataCollector * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IApiTracingDataCollector * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IApiTracingDataCollector * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IApiTracingDataCollector * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataCollectorSet )( 
            IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollectorSet **group);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DataCollectorSet )( 
            IApiTracingDataCollector * This,
            /* [in] */ __RPC__in_opt IDataCollectorSet *group);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataCollectorType )( 
            IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__out DataCollectorType *type);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileName )( 
            IApiTracingDataCollector * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileNameFormat )( 
            IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__out AutoPathFormat *format);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileNameFormat )( 
            IApiTracingDataCollector * This,
            /* [in] */ AutoPathFormat format);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileNameFormatPattern )( 
            IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pattern);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileNameFormatPattern )( 
            IApiTracingDataCollector * This,
            /* [in] */ __RPC__in BSTR pattern);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LatestOutputLocation )( 
            IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *path);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LatestOutputLocation )( 
            IApiTracingDataCollector * This,
            /* [in] */ __RPC__in BSTR path);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogAppend )( 
            IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *append);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogAppend )( 
            IApiTracingDataCollector * This,
            /* [in] */ VARIANT_BOOL append);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogCircular )( 
            IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *circular);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogCircular )( 
            IApiTracingDataCollector * This,
            /* [in] */ VARIANT_BOOL circular);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogOverwrite )( 
            IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *overwrite);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogOverwrite )( 
            IApiTracingDataCollector * This,
            /* [in] */ VARIANT_BOOL overwrite);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            IApiTracingDataCollector * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutputLocation )( 
            IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *path);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Index )( 
            IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__out long *index);
        
        /* [restricted][hidden][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Index )( 
            IApiTracingDataCollector * This,
            /* [in] */ long index);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Xml )( 
            IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Xml);
        
        HRESULT ( STDMETHODCALLTYPE *SetXml )( 
            IApiTracingDataCollector * This,
            /* [in] */ __RPC__in BSTR Xml,
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **Validation);
        
        HRESULT ( STDMETHODCALLTYPE *CreateOutputLocation )( 
            IApiTracingDataCollector * This,
            /* [in] */ VARIANT_BOOL Latest,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Location);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogApiNamesOnly )( 
            IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *logapinames);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogApiNamesOnly )( 
            IApiTracingDataCollector * This,
            /* [in] */ VARIANT_BOOL logapinames);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogApisRecursively )( 
            IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *logrecursively);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogApisRecursively )( 
            IApiTracingDataCollector * This,
            /* [in] */ VARIANT_BOOL logrecursively);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExePath )( 
            IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *exepath);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ExePath )( 
            IApiTracingDataCollector * This,
            /* [in] */ __RPC__in BSTR exepath);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogFilePath )( 
            IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *logfilepath);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogFilePath )( 
            IApiTracingDataCollector * This,
            /* [in] */ __RPC__in BSTR logfilepath);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IncludeModules )( 
            IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *includemodules);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_IncludeModules )( 
            IApiTracingDataCollector * This,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * includemodules);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IncludeApis )( 
            IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *includeapis);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_IncludeApis )( 
            IApiTracingDataCollector * This,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * includeapis);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExcludeApis )( 
            IApiTracingDataCollector * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *excludeapis);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ExcludeApis )( 
            IApiTracingDataCollector * This,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * excludeapis);
        
        END_INTERFACE
    } IApiTracingDataCollectorVtbl;

    interface IApiTracingDataCollector
    {
        CONST_VTBL struct IApiTracingDataCollectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApiTracingDataCollector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IApiTracingDataCollector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IApiTracingDataCollector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IApiTracingDataCollector_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IApiTracingDataCollector_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IApiTracingDataCollector_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IApiTracingDataCollector_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IApiTracingDataCollector_get_DataCollectorSet(This,group)	\
    ( (This)->lpVtbl -> get_DataCollectorSet(This,group) ) 

#define IApiTracingDataCollector_put_DataCollectorSet(This,group)	\
    ( (This)->lpVtbl -> put_DataCollectorSet(This,group) ) 

#define IApiTracingDataCollector_get_DataCollectorType(This,type)	\
    ( (This)->lpVtbl -> get_DataCollectorType(This,type) ) 

#define IApiTracingDataCollector_get_FileName(This,name)	\
    ( (This)->lpVtbl -> get_FileName(This,name) ) 

#define IApiTracingDataCollector_put_FileName(This,name)	\
    ( (This)->lpVtbl -> put_FileName(This,name) ) 

#define IApiTracingDataCollector_get_FileNameFormat(This,format)	\
    ( (This)->lpVtbl -> get_FileNameFormat(This,format) ) 

#define IApiTracingDataCollector_put_FileNameFormat(This,format)	\
    ( (This)->lpVtbl -> put_FileNameFormat(This,format) ) 

#define IApiTracingDataCollector_get_FileNameFormatPattern(This,pattern)	\
    ( (This)->lpVtbl -> get_FileNameFormatPattern(This,pattern) ) 

#define IApiTracingDataCollector_put_FileNameFormatPattern(This,pattern)	\
    ( (This)->lpVtbl -> put_FileNameFormatPattern(This,pattern) ) 

#define IApiTracingDataCollector_get_LatestOutputLocation(This,path)	\
    ( (This)->lpVtbl -> get_LatestOutputLocation(This,path) ) 

#define IApiTracingDataCollector_put_LatestOutputLocation(This,path)	\
    ( (This)->lpVtbl -> put_LatestOutputLocation(This,path) ) 

#define IApiTracingDataCollector_get_LogAppend(This,append)	\
    ( (This)->lpVtbl -> get_LogAppend(This,append) ) 

#define IApiTracingDataCollector_put_LogAppend(This,append)	\
    ( (This)->lpVtbl -> put_LogAppend(This,append) ) 

#define IApiTracingDataCollector_get_LogCircular(This,circular)	\
    ( (This)->lpVtbl -> get_LogCircular(This,circular) ) 

#define IApiTracingDataCollector_put_LogCircular(This,circular)	\
    ( (This)->lpVtbl -> put_LogCircular(This,circular) ) 

#define IApiTracingDataCollector_get_LogOverwrite(This,overwrite)	\
    ( (This)->lpVtbl -> get_LogOverwrite(This,overwrite) ) 

#define IApiTracingDataCollector_put_LogOverwrite(This,overwrite)	\
    ( (This)->lpVtbl -> put_LogOverwrite(This,overwrite) ) 

#define IApiTracingDataCollector_get_Name(This,name)	\
    ( (This)->lpVtbl -> get_Name(This,name) ) 

#define IApiTracingDataCollector_put_Name(This,name)	\
    ( (This)->lpVtbl -> put_Name(This,name) ) 

#define IApiTracingDataCollector_get_OutputLocation(This,path)	\
    ( (This)->lpVtbl -> get_OutputLocation(This,path) ) 

#define IApiTracingDataCollector_get_Index(This,index)	\
    ( (This)->lpVtbl -> get_Index(This,index) ) 

#define IApiTracingDataCollector_put_Index(This,index)	\
    ( (This)->lpVtbl -> put_Index(This,index) ) 

#define IApiTracingDataCollector_get_Xml(This,Xml)	\
    ( (This)->lpVtbl -> get_Xml(This,Xml) ) 

#define IApiTracingDataCollector_SetXml(This,Xml,Validation)	\
    ( (This)->lpVtbl -> SetXml(This,Xml,Validation) ) 

#define IApiTracingDataCollector_CreateOutputLocation(This,Latest,Location)	\
    ( (This)->lpVtbl -> CreateOutputLocation(This,Latest,Location) ) 


#define IApiTracingDataCollector_get_LogApiNamesOnly(This,logapinames)	\
    ( (This)->lpVtbl -> get_LogApiNamesOnly(This,logapinames) ) 

#define IApiTracingDataCollector_put_LogApiNamesOnly(This,logapinames)	\
    ( (This)->lpVtbl -> put_LogApiNamesOnly(This,logapinames) ) 

#define IApiTracingDataCollector_get_LogApisRecursively(This,logrecursively)	\
    ( (This)->lpVtbl -> get_LogApisRecursively(This,logrecursively) ) 

#define IApiTracingDataCollector_put_LogApisRecursively(This,logrecursively)	\
    ( (This)->lpVtbl -> put_LogApisRecursively(This,logrecursively) ) 

#define IApiTracingDataCollector_get_ExePath(This,exepath)	\
    ( (This)->lpVtbl -> get_ExePath(This,exepath) ) 

#define IApiTracingDataCollector_put_ExePath(This,exepath)	\
    ( (This)->lpVtbl -> put_ExePath(This,exepath) ) 

#define IApiTracingDataCollector_get_LogFilePath(This,logfilepath)	\
    ( (This)->lpVtbl -> get_LogFilePath(This,logfilepath) ) 

#define IApiTracingDataCollector_put_LogFilePath(This,logfilepath)	\
    ( (This)->lpVtbl -> put_LogFilePath(This,logfilepath) ) 

#define IApiTracingDataCollector_get_IncludeModules(This,includemodules)	\
    ( (This)->lpVtbl -> get_IncludeModules(This,includemodules) ) 

#define IApiTracingDataCollector_put_IncludeModules(This,includemodules)	\
    ( (This)->lpVtbl -> put_IncludeModules(This,includemodules) ) 

#define IApiTracingDataCollector_get_IncludeApis(This,includeapis)	\
    ( (This)->lpVtbl -> get_IncludeApis(This,includeapis) ) 

#define IApiTracingDataCollector_put_IncludeApis(This,includeapis)	\
    ( (This)->lpVtbl -> put_IncludeApis(This,includeapis) ) 

#define IApiTracingDataCollector_get_ExcludeApis(This,excludeapis)	\
    ( (This)->lpVtbl -> get_ExcludeApis(This,excludeapis) ) 

#define IApiTracingDataCollector_put_ExcludeApis(This,excludeapis)	\
    ( (This)->lpVtbl -> put_ExcludeApis(This,excludeapis) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IApiTracingDataCollector_INTERFACE_DEFINED__ */


#ifndef __IDataCollectorCollection_INTERFACE_DEFINED__
#define __IDataCollectorCollection_INTERFACE_DEFINED__

/* interface IDataCollectorCollection */
/* [nonextensible][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IDataCollectorCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03837502-098b-11d8-9414-505054503030")
    IDataCollectorCollection : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *retVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollector **collector) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            __RPC__in_opt IDataCollector *collector) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            VARIANT collector) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRange( 
            __RPC__in_opt IDataCollectorCollection *collectors) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDataCollectorFromXml( 
            /* [in] */ __RPC__in BSTR bstrXml,
            /* [out] */ __RPC__deref_out_opt IValueMap **pValidation,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollector **pCollector) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDataCollector( 
            /* [in] */ DataCollectorType Type,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollector **Collector) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataCollectorCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDataCollectorCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDataCollectorCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDataCollectorCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDataCollectorCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDataCollectorCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDataCollectorCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDataCollectorCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDataCollectorCollection * This,
            /* [retval][out] */ __RPC__out long *retVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IDataCollectorCollection * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollector **collector);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDataCollectorCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retVal);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            IDataCollectorCollection * This,
            __RPC__in_opt IDataCollector *collector);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IDataCollectorCollection * This,
            VARIANT collector);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IDataCollectorCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddRange )( 
            IDataCollectorCollection * This,
            __RPC__in_opt IDataCollectorCollection *collectors);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDataCollectorFromXml )( 
            IDataCollectorCollection * This,
            /* [in] */ __RPC__in BSTR bstrXml,
            /* [out] */ __RPC__deref_out_opt IValueMap **pValidation,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollector **pCollector);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDataCollector )( 
            IDataCollectorCollection * This,
            /* [in] */ DataCollectorType Type,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollector **Collector);
        
        END_INTERFACE
    } IDataCollectorCollectionVtbl;

    interface IDataCollectorCollection
    {
        CONST_VTBL struct IDataCollectorCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataCollectorCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDataCollectorCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDataCollectorCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDataCollectorCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDataCollectorCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDataCollectorCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDataCollectorCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDataCollectorCollection_get_Count(This,retVal)	\
    ( (This)->lpVtbl -> get_Count(This,retVal) ) 

#define IDataCollectorCollection_get_Item(This,index,collector)	\
    ( (This)->lpVtbl -> get_Item(This,index,collector) ) 

#define IDataCollectorCollection_get__NewEnum(This,retVal)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retVal) ) 

#define IDataCollectorCollection_Add(This,collector)	\
    ( (This)->lpVtbl -> Add(This,collector) ) 

#define IDataCollectorCollection_Remove(This,collector)	\
    ( (This)->lpVtbl -> Remove(This,collector) ) 

#define IDataCollectorCollection_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define IDataCollectorCollection_AddRange(This,collectors)	\
    ( (This)->lpVtbl -> AddRange(This,collectors) ) 

#define IDataCollectorCollection_CreateDataCollectorFromXml(This,bstrXml,pValidation,pCollector)	\
    ( (This)->lpVtbl -> CreateDataCollectorFromXml(This,bstrXml,pValidation,pCollector) ) 

#define IDataCollectorCollection_CreateDataCollector(This,Type,Collector)	\
    ( (This)->lpVtbl -> CreateDataCollector(This,Type,Collector) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDataCollectorCollection_INTERFACE_DEFINED__ */


#ifndef __IDataCollectorSetCollection_INTERFACE_DEFINED__
#define __IDataCollectorSetCollection_INTERFACE_DEFINED__

/* interface IDataCollectorSetCollection */
/* [nonextensible][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IDataCollectorSetCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03837524-098b-11d8-9414-505054503030")
    IDataCollectorSetCollection : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *retVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollectorSet **set) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            __RPC__in_opt IDataCollectorSet *set) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            VARIANT set) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRange( 
            __RPC__in_opt IDataCollectorSetCollection *sets) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataCollectorSets( 
            /* [unique][in] */ __RPC__in_opt BSTR server,
            /* [unique][in] */ __RPC__in_opt BSTR filter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataCollectorSetCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDataCollectorSetCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDataCollectorSetCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDataCollectorSetCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDataCollectorSetCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDataCollectorSetCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDataCollectorSetCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDataCollectorSetCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDataCollectorSetCollection * This,
            /* [retval][out] */ __RPC__out long *retVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IDataCollectorSetCollection * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt IDataCollectorSet **set);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IDataCollectorSetCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retVal);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            IDataCollectorSetCollection * This,
            __RPC__in_opt IDataCollectorSet *set);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IDataCollectorSetCollection * This,
            VARIANT set);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IDataCollectorSetCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddRange )( 
            IDataCollectorSetCollection * This,
            __RPC__in_opt IDataCollectorSetCollection *sets);
        
        HRESULT ( STDMETHODCALLTYPE *GetDataCollectorSets )( 
            IDataCollectorSetCollection * This,
            /* [unique][in] */ __RPC__in_opt BSTR server,
            /* [unique][in] */ __RPC__in_opt BSTR filter);
        
        END_INTERFACE
    } IDataCollectorSetCollectionVtbl;

    interface IDataCollectorSetCollection
    {
        CONST_VTBL struct IDataCollectorSetCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataCollectorSetCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDataCollectorSetCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDataCollectorSetCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDataCollectorSetCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDataCollectorSetCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDataCollectorSetCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDataCollectorSetCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDataCollectorSetCollection_get_Count(This,retVal)	\
    ( (This)->lpVtbl -> get_Count(This,retVal) ) 

#define IDataCollectorSetCollection_get_Item(This,index,set)	\
    ( (This)->lpVtbl -> get_Item(This,index,set) ) 

#define IDataCollectorSetCollection_get__NewEnum(This,retVal)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retVal) ) 

#define IDataCollectorSetCollection_Add(This,set)	\
    ( (This)->lpVtbl -> Add(This,set) ) 

#define IDataCollectorSetCollection_Remove(This,set)	\
    ( (This)->lpVtbl -> Remove(This,set) ) 

#define IDataCollectorSetCollection_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define IDataCollectorSetCollection_AddRange(This,sets)	\
    ( (This)->lpVtbl -> AddRange(This,sets) ) 

#define IDataCollectorSetCollection_GetDataCollectorSets(This,server,filter)	\
    ( (This)->lpVtbl -> GetDataCollectorSets(This,server,filter) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDataCollectorSetCollection_INTERFACE_DEFINED__ */


#ifndef __ITraceDataProvider_INTERFACE_DEFINED__
#define __ITraceDataProvider_INTERFACE_DEFINED__

/* interface ITraceDataProvider */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_ITraceDataProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03837512-098b-11d8-9414-505054503030")
    ITraceDataProvider : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DisplayName( 
            /* [in] */ __RPC__in BSTR name) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Guid( 
            /* [retval][out] */ __RPC__out GUID *guid) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Guid( 
            /* [in] */ GUID guid) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Level( 
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **ppLevel) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_KeywordsAny( 
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **ppKeywords) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_KeywordsAll( 
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **ppKeywords) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **ppProperties) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FilterEnabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *FilterEnabled) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_FilterEnabled( 
            /* [in] */ VARIANT_BOOL FilterEnabled) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FilterType( 
            /* [retval][out] */ __RPC__out ULONG *pulType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_FilterType( 
            /* [in] */ ULONG ulType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FilterData( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppData) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_FilterData( 
            /* [in] */ __RPC__in SAFEARRAY * pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Query( 
            /* [in] */ __RPC__in BSTR bstrName,
            /* [unique][in] */ __RPC__in_opt BSTR bstrServer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resolve( 
            /* [in] */ __RPC__in_opt IDispatch *pFrom) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSecurity( 
            /* [in] */ __RPC__in BSTR Sddl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSecurity( 
            /* [in] */ ULONG SecurityInfo,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Sddl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisteredProcesses( 
            /* [out] */ __RPC__deref_out_opt IValueMap **Processes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITraceDataProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITraceDataProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITraceDataProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITraceDataProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITraceDataProvider * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITraceDataProvider * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITraceDataProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITraceDataProvider * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayName )( 
            ITraceDataProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayName )( 
            ITraceDataProvider * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Guid )( 
            ITraceDataProvider * This,
            /* [retval][out] */ __RPC__out GUID *guid);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Guid )( 
            ITraceDataProvider * This,
            /* [in] */ GUID guid);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Level )( 
            ITraceDataProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **ppLevel);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeywordsAny )( 
            ITraceDataProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **ppKeywords);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeywordsAll )( 
            ITraceDataProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **ppKeywords);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            ITraceDataProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt IValueMap **ppProperties);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FilterEnabled )( 
            ITraceDataProvider * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *FilterEnabled);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FilterEnabled )( 
            ITraceDataProvider * This,
            /* [in] */ VARIANT_BOOL FilterEnabled);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FilterType )( 
            ITraceDataProvider * This,
            /* [retval][out] */ __RPC__out ULONG *pulType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FilterType )( 
            ITraceDataProvider * This,
            /* [in] */ ULONG ulType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FilterData )( 
            ITraceDataProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppData);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FilterData )( 
            ITraceDataProvider * This,
            /* [in] */ __RPC__in SAFEARRAY * pData);
        
        HRESULT ( STDMETHODCALLTYPE *Query )( 
            ITraceDataProvider * This,
            /* [in] */ __RPC__in BSTR bstrName,
            /* [unique][in] */ __RPC__in_opt BSTR bstrServer);
        
        HRESULT ( STDMETHODCALLTYPE *Resolve )( 
            ITraceDataProvider * This,
            /* [in] */ __RPC__in_opt IDispatch *pFrom);
        
        HRESULT ( STDMETHODCALLTYPE *SetSecurity )( 
            ITraceDataProvider * This,
            /* [in] */ __RPC__in BSTR Sddl);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecurity )( 
            ITraceDataProvider * This,
            /* [in] */ ULONG SecurityInfo,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *Sddl);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisteredProcesses )( 
            ITraceDataProvider * This,
            /* [out] */ __RPC__deref_out_opt IValueMap **Processes);
        
        END_INTERFACE
    } ITraceDataProviderVtbl;

    interface ITraceDataProvider
    {
        CONST_VTBL struct ITraceDataProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITraceDataProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITraceDataProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITraceDataProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITraceDataProvider_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITraceDataProvider_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITraceDataProvider_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITraceDataProvider_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITraceDataProvider_get_DisplayName(This,name)	\
    ( (This)->lpVtbl -> get_DisplayName(This,name) ) 

#define ITraceDataProvider_put_DisplayName(This,name)	\
    ( (This)->lpVtbl -> put_DisplayName(This,name) ) 

#define ITraceDataProvider_get_Guid(This,guid)	\
    ( (This)->lpVtbl -> get_Guid(This,guid) ) 

#define ITraceDataProvider_put_Guid(This,guid)	\
    ( (This)->lpVtbl -> put_Guid(This,guid) ) 

#define ITraceDataProvider_get_Level(This,ppLevel)	\
    ( (This)->lpVtbl -> get_Level(This,ppLevel) ) 

#define ITraceDataProvider_get_KeywordsAny(This,ppKeywords)	\
    ( (This)->lpVtbl -> get_KeywordsAny(This,ppKeywords) ) 

#define ITraceDataProvider_get_KeywordsAll(This,ppKeywords)	\
    ( (This)->lpVtbl -> get_KeywordsAll(This,ppKeywords) ) 

#define ITraceDataProvider_get_Properties(This,ppProperties)	\
    ( (This)->lpVtbl -> get_Properties(This,ppProperties) ) 

#define ITraceDataProvider_get_FilterEnabled(This,FilterEnabled)	\
    ( (This)->lpVtbl -> get_FilterEnabled(This,FilterEnabled) ) 

#define ITraceDataProvider_put_FilterEnabled(This,FilterEnabled)	\
    ( (This)->lpVtbl -> put_FilterEnabled(This,FilterEnabled) ) 

#define ITraceDataProvider_get_FilterType(This,pulType)	\
    ( (This)->lpVtbl -> get_FilterType(This,pulType) ) 

#define ITraceDataProvider_put_FilterType(This,ulType)	\
    ( (This)->lpVtbl -> put_FilterType(This,ulType) ) 

#define ITraceDataProvider_get_FilterData(This,ppData)	\
    ( (This)->lpVtbl -> get_FilterData(This,ppData) ) 

#define ITraceDataProvider_put_FilterData(This,pData)	\
    ( (This)->lpVtbl -> put_FilterData(This,pData) ) 

#define ITraceDataProvider_Query(This,bstrName,bstrServer)	\
    ( (This)->lpVtbl -> Query(This,bstrName,bstrServer) ) 

#define ITraceDataProvider_Resolve(This,pFrom)	\
    ( (This)->lpVtbl -> Resolve(This,pFrom) ) 

#define ITraceDataProvider_SetSecurity(This,Sddl)	\
    ( (This)->lpVtbl -> SetSecurity(This,Sddl) ) 

#define ITraceDataProvider_GetSecurity(This,SecurityInfo,Sddl)	\
    ( (This)->lpVtbl -> GetSecurity(This,SecurityInfo,Sddl) ) 

#define ITraceDataProvider_GetRegisteredProcesses(This,Processes)	\
    ( (This)->lpVtbl -> GetRegisteredProcesses(This,Processes) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITraceDataProvider_INTERFACE_DEFINED__ */


#ifndef __ITraceDataProviderCollection_INTERFACE_DEFINED__
#define __ITraceDataProviderCollection_INTERFACE_DEFINED__

/* interface ITraceDataProviderCollection */
/* [nonextensible][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_ITraceDataProviderCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03837510-098b-11d8-9414-505054503030")
    ITraceDataProviderCollection : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *retVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt ITraceDataProvider **ppProvider) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            __RPC__in_opt ITraceDataProvider *pProvider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            VARIANT vProvider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRange( 
            __RPC__in_opt ITraceDataProviderCollection *providers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateTraceDataProvider( 
            /* [retval][out] */ __RPC__deref_out_opt ITraceDataProvider **Provider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTraceDataProviders( 
            /* [unique][in] */ __RPC__in_opt BSTR server) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTraceDataProvidersByProcess( 
            /* [unique][in] */ __RPC__in_opt BSTR Server,
            /* [in] */ ULONG Pid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITraceDataProviderCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITraceDataProviderCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITraceDataProviderCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITraceDataProviderCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITraceDataProviderCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITraceDataProviderCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITraceDataProviderCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITraceDataProviderCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ITraceDataProviderCollection * This,
            /* [retval][out] */ __RPC__out long *retVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            ITraceDataProviderCollection * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt ITraceDataProvider **ppProvider);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            ITraceDataProviderCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retVal);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            ITraceDataProviderCollection * This,
            __RPC__in_opt ITraceDataProvider *pProvider);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            ITraceDataProviderCollection * This,
            VARIANT vProvider);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            ITraceDataProviderCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddRange )( 
            ITraceDataProviderCollection * This,
            __RPC__in_opt ITraceDataProviderCollection *providers);
        
        HRESULT ( STDMETHODCALLTYPE *CreateTraceDataProvider )( 
            ITraceDataProviderCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt ITraceDataProvider **Provider);
        
        HRESULT ( STDMETHODCALLTYPE *GetTraceDataProviders )( 
            ITraceDataProviderCollection * This,
            /* [unique][in] */ __RPC__in_opt BSTR server);
        
        HRESULT ( STDMETHODCALLTYPE *GetTraceDataProvidersByProcess )( 
            ITraceDataProviderCollection * This,
            /* [unique][in] */ __RPC__in_opt BSTR Server,
            /* [in] */ ULONG Pid);
        
        END_INTERFACE
    } ITraceDataProviderCollectionVtbl;

    interface ITraceDataProviderCollection
    {
        CONST_VTBL struct ITraceDataProviderCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITraceDataProviderCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITraceDataProviderCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITraceDataProviderCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITraceDataProviderCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITraceDataProviderCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITraceDataProviderCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITraceDataProviderCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITraceDataProviderCollection_get_Count(This,retVal)	\
    ( (This)->lpVtbl -> get_Count(This,retVal) ) 

#define ITraceDataProviderCollection_get_Item(This,index,ppProvider)	\
    ( (This)->lpVtbl -> get_Item(This,index,ppProvider) ) 

#define ITraceDataProviderCollection_get__NewEnum(This,retVal)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retVal) ) 

#define ITraceDataProviderCollection_Add(This,pProvider)	\
    ( (This)->lpVtbl -> Add(This,pProvider) ) 

#define ITraceDataProviderCollection_Remove(This,vProvider)	\
    ( (This)->lpVtbl -> Remove(This,vProvider) ) 

#define ITraceDataProviderCollection_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define ITraceDataProviderCollection_AddRange(This,providers)	\
    ( (This)->lpVtbl -> AddRange(This,providers) ) 

#define ITraceDataProviderCollection_CreateTraceDataProvider(This,Provider)	\
    ( (This)->lpVtbl -> CreateTraceDataProvider(This,Provider) ) 

#define ITraceDataProviderCollection_GetTraceDataProviders(This,server)	\
    ( (This)->lpVtbl -> GetTraceDataProviders(This,server) ) 

#define ITraceDataProviderCollection_GetTraceDataProvidersByProcess(This,Server,Pid)	\
    ( (This)->lpVtbl -> GetTraceDataProvidersByProcess(This,Server,Pid) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITraceDataProviderCollection_INTERFACE_DEFINED__ */


#ifndef __ISchedule_INTERFACE_DEFINED__
#define __ISchedule_INTERFACE_DEFINED__

/* interface ISchedule */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_ISchedule;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0383753a-098b-11d8-9414-505054503030")
    ISchedule : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_StartDate( 
            /* [retval][out] */ __RPC__out VARIANT *start) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_StartDate( 
            /* [in] */ VARIANT start) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EndDate( 
            /* [retval][out] */ __RPC__out VARIANT *end) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_EndDate( 
            /* [in] */ VARIANT end) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_StartTime( 
            /* [retval][out] */ __RPC__out VARIANT *start) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_StartTime( 
            /* [in] */ VARIANT start) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Days( 
            /* [retval][out] */ __RPC__out WeekDays *days) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Days( 
            /* [in] */ WeekDays days) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScheduleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISchedule * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISchedule * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISchedule * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISchedule * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISchedule * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISchedule * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISchedule * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartDate )( 
            ISchedule * This,
            /* [retval][out] */ __RPC__out VARIANT *start);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartDate )( 
            ISchedule * This,
            /* [in] */ VARIANT start);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_EndDate )( 
            ISchedule * This,
            /* [retval][out] */ __RPC__out VARIANT *end);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_EndDate )( 
            ISchedule * This,
            /* [in] */ VARIANT end);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartTime )( 
            ISchedule * This,
            /* [retval][out] */ __RPC__out VARIANT *start);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartTime )( 
            ISchedule * This,
            /* [in] */ VARIANT start);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Days )( 
            ISchedule * This,
            /* [retval][out] */ __RPC__out WeekDays *days);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Days )( 
            ISchedule * This,
            /* [in] */ WeekDays days);
        
        END_INTERFACE
    } IScheduleVtbl;

    interface ISchedule
    {
        CONST_VTBL struct IScheduleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchedule_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISchedule_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISchedule_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISchedule_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISchedule_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISchedule_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISchedule_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISchedule_get_StartDate(This,start)	\
    ( (This)->lpVtbl -> get_StartDate(This,start) ) 

#define ISchedule_put_StartDate(This,start)	\
    ( (This)->lpVtbl -> put_StartDate(This,start) ) 

#define ISchedule_get_EndDate(This,end)	\
    ( (This)->lpVtbl -> get_EndDate(This,end) ) 

#define ISchedule_put_EndDate(This,end)	\
    ( (This)->lpVtbl -> put_EndDate(This,end) ) 

#define ISchedule_get_StartTime(This,start)	\
    ( (This)->lpVtbl -> get_StartTime(This,start) ) 

#define ISchedule_put_StartTime(This,start)	\
    ( (This)->lpVtbl -> put_StartTime(This,start) ) 

#define ISchedule_get_Days(This,days)	\
    ( (This)->lpVtbl -> get_Days(This,days) ) 

#define ISchedule_put_Days(This,days)	\
    ( (This)->lpVtbl -> put_Days(This,days) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISchedule_INTERFACE_DEFINED__ */


#ifndef __IScheduleCollection_INTERFACE_DEFINED__
#define __IScheduleCollection_INTERFACE_DEFINED__

/* interface IScheduleCollection */
/* [nonextensible][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IScheduleCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0383753d-098b-11d8-9414-505054503030")
    IScheduleCollection : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *retVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt ISchedule **ppSchedule) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ienum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            __RPC__in_opt ISchedule *pSchedule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            VARIANT vSchedule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRange( 
            __RPC__in_opt IScheduleCollection *pSchedules) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSchedule( 
            /* [retval][out] */ __RPC__deref_out_opt ISchedule **Schedule) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScheduleCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IScheduleCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IScheduleCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IScheduleCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IScheduleCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IScheduleCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IScheduleCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IScheduleCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IScheduleCollection * This,
            /* [retval][out] */ __RPC__out long *retVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IScheduleCollection * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt ISchedule **ppSchedule);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IScheduleCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ienum);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            IScheduleCollection * This,
            __RPC__in_opt ISchedule *pSchedule);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IScheduleCollection * This,
            VARIANT vSchedule);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IScheduleCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddRange )( 
            IScheduleCollection * This,
            __RPC__in_opt IScheduleCollection *pSchedules);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSchedule )( 
            IScheduleCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt ISchedule **Schedule);
        
        END_INTERFACE
    } IScheduleCollectionVtbl;

    interface IScheduleCollection
    {
        CONST_VTBL struct IScheduleCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScheduleCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IScheduleCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IScheduleCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IScheduleCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IScheduleCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IScheduleCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IScheduleCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IScheduleCollection_get_Count(This,retVal)	\
    ( (This)->lpVtbl -> get_Count(This,retVal) ) 

#define IScheduleCollection_get_Item(This,index,ppSchedule)	\
    ( (This)->lpVtbl -> get_Item(This,index,ppSchedule) ) 

#define IScheduleCollection_get__NewEnum(This,ienum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ienum) ) 

#define IScheduleCollection_Add(This,pSchedule)	\
    ( (This)->lpVtbl -> Add(This,pSchedule) ) 

#define IScheduleCollection_Remove(This,vSchedule)	\
    ( (This)->lpVtbl -> Remove(This,vSchedule) ) 

#define IScheduleCollection_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define IScheduleCollection_AddRange(This,pSchedules)	\
    ( (This)->lpVtbl -> AddRange(This,pSchedules) ) 

#define IScheduleCollection_CreateSchedule(This,Schedule)	\
    ( (This)->lpVtbl -> CreateSchedule(This,Schedule) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IScheduleCollection_INTERFACE_DEFINED__ */


#ifndef __IValueMapItem_INTERFACE_DEFINED__
#define __IValueMapItem_INTERFACE_DEFINED__

/* interface IValueMapItem */
/* [nonextensible][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IValueMapItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03837533-098b-11d8-9414-505054503030")
    IValueMapItem : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *description) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ __RPC__in BSTR description) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL enabled) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *key) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Key( 
            /* [in] */ __RPC__in BSTR key) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ __RPC__out VARIANT *Value) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ VARIANT Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ValueMapType( 
            /* [retval][out] */ __RPC__out ValueMapType *type) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ValueMapType( 
            /* [in] */ ValueMapType type) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IValueMapItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IValueMapItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IValueMapItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IValueMapItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IValueMapItem * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IValueMapItem * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IValueMapItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IValueMapItem * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IValueMapItem * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *description);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            IValueMapItem * This,
            /* [in] */ __RPC__in BSTR description);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            IValueMapItem * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            IValueMapItem * This,
            /* [in] */ VARIANT_BOOL enabled);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Key )( 
            IValueMapItem * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *key);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Key )( 
            IValueMapItem * This,
            /* [in] */ __RPC__in BSTR key);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            IValueMapItem * This,
            /* [retval][out] */ __RPC__out VARIANT *Value);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Value )( 
            IValueMapItem * This,
            /* [in] */ VARIANT Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ValueMapType )( 
            IValueMapItem * This,
            /* [retval][out] */ __RPC__out ValueMapType *type);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ValueMapType )( 
            IValueMapItem * This,
            /* [in] */ ValueMapType type);
        
        END_INTERFACE
    } IValueMapItemVtbl;

    interface IValueMapItem
    {
        CONST_VTBL struct IValueMapItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IValueMapItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IValueMapItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IValueMapItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IValueMapItem_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IValueMapItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IValueMapItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IValueMapItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IValueMapItem_get_Description(This,description)	\
    ( (This)->lpVtbl -> get_Description(This,description) ) 

#define IValueMapItem_put_Description(This,description)	\
    ( (This)->lpVtbl -> put_Description(This,description) ) 

#define IValueMapItem_get_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,enabled) ) 

#define IValueMapItem_put_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,enabled) ) 

#define IValueMapItem_get_Key(This,key)	\
    ( (This)->lpVtbl -> get_Key(This,key) ) 

#define IValueMapItem_put_Key(This,key)	\
    ( (This)->lpVtbl -> put_Key(This,key) ) 

#define IValueMapItem_get_Value(This,Value)	\
    ( (This)->lpVtbl -> get_Value(This,Value) ) 

#define IValueMapItem_put_Value(This,Value)	\
    ( (This)->lpVtbl -> put_Value(This,Value) ) 

#define IValueMapItem_get_ValueMapType(This,type)	\
    ( (This)->lpVtbl -> get_ValueMapType(This,type) ) 

#define IValueMapItem_put_ValueMapType(This,type)	\
    ( (This)->lpVtbl -> put_ValueMapType(This,type) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IValueMapItem_INTERFACE_DEFINED__ */


#ifndef __IValueMap_INTERFACE_DEFINED__
#define __IValueMap_INTERFACE_DEFINED__

/* interface IValueMap */
/* [nonextensible][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IValueMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03837534-098b-11d8-9414-505054503030")
    IValueMap : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *retVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt IValueMapItem **value) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *description) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ __RPC__in BSTR description) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ __RPC__out VARIANT *Value) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ VARIANT Value) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ValueMapType( 
            /* [retval][out] */ __RPC__out ValueMapType *type) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ValueMapType( 
            /* [in] */ ValueMapType type) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            VARIANT value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            VARIANT value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRange( 
            __RPC__in_opt IValueMap *map) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateValueMapItem( 
            /* [retval][out] */ __RPC__deref_out_opt IValueMapItem **Item) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IValueMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IValueMap * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IValueMap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IValueMap * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IValueMap * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IValueMap * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IValueMap * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IValueMap * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IValueMap * This,
            /* [retval][out] */ __RPC__out long *retVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IValueMap * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt IValueMapItem **value);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IValueMap * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IValueMap * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *description);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            IValueMap * This,
            /* [in] */ __RPC__in BSTR description);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            IValueMap * This,
            /* [retval][out] */ __RPC__out VARIANT *Value);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Value )( 
            IValueMap * This,
            /* [in] */ VARIANT Value);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ValueMapType )( 
            IValueMap * This,
            /* [retval][out] */ __RPC__out ValueMapType *type);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ValueMapType )( 
            IValueMap * This,
            /* [in] */ ValueMapType type);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            IValueMap * This,
            VARIANT value);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IValueMap * This,
            VARIANT value);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IValueMap * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddRange )( 
            IValueMap * This,
            __RPC__in_opt IValueMap *map);
        
        HRESULT ( STDMETHODCALLTYPE *CreateValueMapItem )( 
            IValueMap * This,
            /* [retval][out] */ __RPC__deref_out_opt IValueMapItem **Item);
        
        END_INTERFACE
    } IValueMapVtbl;

    interface IValueMap
    {
        CONST_VTBL struct IValueMapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IValueMap_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IValueMap_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IValueMap_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IValueMap_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IValueMap_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IValueMap_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IValueMap_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IValueMap_get_Count(This,retVal)	\
    ( (This)->lpVtbl -> get_Count(This,retVal) ) 

#define IValueMap_get_Item(This,index,value)	\
    ( (This)->lpVtbl -> get_Item(This,index,value) ) 

#define IValueMap_get__NewEnum(This,retVal)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retVal) ) 

#define IValueMap_get_Description(This,description)	\
    ( (This)->lpVtbl -> get_Description(This,description) ) 

#define IValueMap_put_Description(This,description)	\
    ( (This)->lpVtbl -> put_Description(This,description) ) 

#define IValueMap_get_Value(This,Value)	\
    ( (This)->lpVtbl -> get_Value(This,Value) ) 

#define IValueMap_put_Value(This,Value)	\
    ( (This)->lpVtbl -> put_Value(This,Value) ) 

#define IValueMap_get_ValueMapType(This,type)	\
    ( (This)->lpVtbl -> get_ValueMapType(This,type) ) 

#define IValueMap_put_ValueMapType(This,type)	\
    ( (This)->lpVtbl -> put_ValueMapType(This,type) ) 

#define IValueMap_Add(This,value)	\
    ( (This)->lpVtbl -> Add(This,value) ) 

#define IValueMap_Remove(This,value)	\
    ( (This)->lpVtbl -> Remove(This,value) ) 

#define IValueMap_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define IValueMap_AddRange(This,map)	\
    ( (This)->lpVtbl -> AddRange(This,map) ) 

#define IValueMap_CreateValueMapItem(This,Item)	\
    ( (This)->lpVtbl -> CreateValueMapItem(This,Item) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IValueMap_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DataCollectorSet;

#ifdef __cplusplus

class DECLSPEC_UUID("03837521-098b-11d8-9414-505054503030")
DataCollectorSet;
#endif

EXTERN_C const CLSID CLSID_TraceSession;

#ifdef __cplusplus

class DECLSPEC_UUID("0383751c-098b-11d8-9414-505054503030")
TraceSession;
#endif

EXTERN_C const CLSID CLSID_TraceSessionCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("03837530-098b-11d8-9414-505054503030")
TraceSessionCollection;
#endif

EXTERN_C const CLSID CLSID_TraceDataProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("03837513-098b-11d8-9414-505054503030")
TraceDataProvider;
#endif

EXTERN_C const CLSID CLSID_TraceDataProviderCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("03837511-098b-11d8-9414-505054503030")
TraceDataProviderCollection;
#endif

EXTERN_C const CLSID CLSID_DataCollectorSetCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("03837525-098b-11d8-9414-505054503030")
DataCollectorSetCollection;
#endif

EXTERN_C const CLSID CLSID_LegacyDataCollectorSet;

#ifdef __cplusplus

class DECLSPEC_UUID("03837526-098b-11d8-9414-505054503030")
LegacyDataCollectorSet;
#endif

EXTERN_C const CLSID CLSID_LegacyDataCollectorSetCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("03837527-098b-11d8-9414-505054503030")
LegacyDataCollectorSetCollection;
#endif

EXTERN_C const CLSID CLSID_LegacyTraceSession;

#ifdef __cplusplus

class DECLSPEC_UUID("03837528-098b-11d8-9414-505054503030")
LegacyTraceSession;
#endif

EXTERN_C const CLSID CLSID_LegacyTraceSessionCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("03837529-098b-11d8-9414-505054503030")
LegacyTraceSessionCollection;
#endif

EXTERN_C const CLSID CLSID_ServerDataCollectorSet;

#ifdef __cplusplus

class DECLSPEC_UUID("03837531-098b-11d8-9414-505054503030")
ServerDataCollectorSet;
#endif

EXTERN_C const CLSID CLSID_ServerDataCollectorSetCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("03837532-098b-11d8-9414-505054503030")
ServerDataCollectorSetCollection;
#endif

EXTERN_C const CLSID CLSID_SystemDataCollectorSet;

#ifdef __cplusplus

class DECLSPEC_UUID("03837546-098b-11d8-9414-505054503030")
SystemDataCollectorSet;
#endif

EXTERN_C const CLSID CLSID_SystemDataCollectorSetCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("03837547-098b-11d8-9414-505054503030")
SystemDataCollectorSetCollection;
#endif

EXTERN_C const CLSID CLSID_BootTraceSession;

#ifdef __cplusplus

class DECLSPEC_UUID("03837538-098b-11d8-9414-505054503030")
BootTraceSession;
#endif

EXTERN_C const CLSID CLSID_BootTraceSessionCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("03837539-098b-11d8-9414-505054503030")
BootTraceSessionCollection;
#endif
#endif /* __PlaLibrary_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\ProfInfo.h ===
//=============================================================================
//  profinfo.h   -   Header file for profile info structure.
//
//  Copyright (c) Microsoft Corporation 2000
//  All rights reserved
//
//=============================================================================

#ifndef _INC_PROFINFO
#define _INC_PROFINFO

#ifdef __midl
#define FAR
#define MIDL_STRING [string, unique]
#else
#define MIDL_STRING
#endif  // __midl

typedef struct _PROFILEINFOA {
    DWORD       dwSize;                 // Set to sizeof(PROFILEINFO) before calling
    DWORD       dwFlags;                // See PI_ flags defined in userenv.h
    MIDL_STRING LPSTR       lpUserName;             // User name (required)
    MIDL_STRING LPSTR       lpProfilePath;          // Roaming profile path (optional, can be NULL)
    MIDL_STRING LPSTR       lpDefaultPath;          // Default user profile path (optional, can be NULL)
    MIDL_STRING LPSTR       lpServerName;           // Validating domain controller name in netbios format (optional, can be NULL but group NT4 style policy won't be applied)
    MIDL_STRING LPSTR       lpPolicyPath;           // Path to the NT4 style policy file (optional, can be NULL)
#ifdef __midl
    ULONG_PTR   hProfile;               // Filled in by the function.  Registry key handle open to the root.
#else
    HANDLE      hProfile;               // Filled in by the function.  Registry key handle open to the root.
#endif
    } PROFILEINFOA, FAR * LPPROFILEINFOA;
typedef struct _PROFILEINFOW {
    DWORD       dwSize;                 // Set to sizeof(PROFILEINFO) before calling
    DWORD       dwFlags;                // See PI_ flags defined in userenv.h
    MIDL_STRING LPWSTR      lpUserName;             // User name (required)
    MIDL_STRING LPWSTR      lpProfilePath;          // Roaming profile path (optional, can be NULL)
    MIDL_STRING LPWSTR      lpDefaultPath;          // Default user profile path (optional, can be NULL)
    MIDL_STRING LPWSTR      lpServerName;           // Validating domain controller name in netbios format (optional, can be NULL but group NT4 style policy won't be applied)
    MIDL_STRING LPWSTR      lpPolicyPath;           // Path to the NT4 style policy file (optional, can be NULL)
#ifdef __midl
    ULONG_PTR   hProfile;               // Filled in by the function.  Registry key handle open to the root.
#else
    HANDLE      hProfile;               // Filled in by the function.  Registry key handle open to the root.
#endif
    } PROFILEINFOW, FAR * LPPROFILEINFOW;
#ifdef UNICODE
typedef PROFILEINFOW PROFILEINFO;
typedef LPPROFILEINFOW LPPROFILEINFO;
#else
typedef PROFILEINFOA PROFILEINFO;
typedef LPPROFILEINFOA LPPROFILEINFO;
#endif // UNICODE

#endif  // _INC_PROFINFO
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\propapi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2006.
//
//  File:       propapi.h
//
//  Contents:   Structured storage properties APIs
//
//--------------------------------------------------------------------------


#ifndef _PROPAPI_H_
#define _PROPAPI_H_

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

typedef VOID* NTPROP;

#include <propidl.h>

EXTERN_C ULONG __stdcall
StgPropertyLengthAsVariant(
            __in_bcount(cbProp) const SERIALIZEDPROPERTYVALUE* pProp,
            ULONG cbProp,
            USHORT CodePage,
            __reserved BYTE bReserved);


#ifdef __cplusplus
}
#endif

#endif // ifndef _PROPAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\prnasnot.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    prnasnot.h

Abstract:

    Header file for Print APIs

Revision History:

--*/
#ifndef _PRINTASYNCNOTIFY_H_
#define _PRINTASYNCNOTIFY_H_

#if (NTDDI_VERSION >= NTDDI_LONGHORN)

#include "initguid.h"
#include <objbase.h>

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif

DEFINE_GUID(IID_IPrintAsyncNotifyChannel,        0x4a5031b1, 0x1f3f, 0x4db0, 0xa4, 0x62, 0x45, 0x30, 0xed, 0x8b, 0x04, 0x51);
DEFINE_GUID(IID_IPrintAsyncNotifyCallback,       0x7def34c1, 0x9d92, 0x4c99, 0xb3, 0xb3, 0xdb, 0x94, 0xa9, 0xd4, 0x19, 0x1b);
DEFINE_GUID(IID_IPrintAsyncNotifyDataObject,     0x77cf513e, 0x5d49, 0x4789, 0x9f, 0x30, 0xd0, 0x82, 0x2b, 0x33, 0x5c, 0x0d);

DEFINE_GUID(NOTIFICATION_RELEASE,                0xba9a5027, 0xa70e, 0x4ae7, 0x9b, 0x7d, 0xeb, 0x3e, 0x06, 0xad, 0x41, 0x57);

//
// Global Application Bidi Notification Channel
//   All Apps interested in Bidi Notifications from the Print subsystem should register for
//   notifications on this Channel GUID
//
// {2ABAD223-B994-4aca-82FC-4571B1B585AC}
DEFINE_GUID(PRINT_APP_BIDI_NOTIFY_CHANNEL, 0x2ABAD223, 0xB994, 0x4aca, 0x82, 0xFC, 0x45, 0x71, 0xB1, 0xB5, 0x85, 0xAC);

//
// Global Port Monitor Bidi Notification Channel
//   This is the Global Channel GUID that all Bidi enabled Port Monitor should open to send
//   Bidi Schema notifications up
//
// {25DF3B0E-74A9-47f5-80CE-79B4B1EB5C58}
DEFINE_GUID(PRINT_PORT_MONITOR_NOTIFY_CHANNEL, 0x25df3b0e, 0x74a9, 0x47f5, 0x80, 0xce, 0x79, 0xb4, 0xb1, 0xeb, 0x5c, 0x58);

#ifdef __cplusplus
extern "C" {
#endif

typedef enum
{
    kPerUser,
    kAllUsers,

} PrintAsyncNotifyUserFilter;

typedef enum
{
    kBiDirectional,
    kUniDirectional

} PrintAsyncNotifyConversationStyle;

typedef GUID PrintAsyncNotificationType;

//#undef IUnknown

#undef  INTERFACE
#define INTERFACE IPrintAsyncNotifyDataObject
DECLARE_INTERFACE_(IPrintAsyncNotifyDataObject, IUnknown)
{
    STDMETHOD(QueryInterface)(
        THIS_
        REFIID riid,
        void** ppvObj
        ) PURE;

    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;

    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    STDMETHOD(AcquireData)(
         THIS_
         OUT BYTE**,
         OUT ULONG*,
         OUT PrintAsyncNotificationType**
         ) PURE;

    STDMETHOD(ReleaseData)(
        THIS
        ) PURE;
};

typedef interface IPrintAsyncNotifyCallback IPrintAsyncNotifyCallback;

#undef  INTERFACE
#define INTERFACE IPrintAsyncNotifyChannel
DECLARE_INTERFACE_(IPrintAsyncNotifyChannel, IUnknown)
{
    STDMETHOD(QueryInterface)(
        THIS_
        REFIID riid,
        void** ppvObj
        ) PURE;

    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;

    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    STDMETHOD(SendNotification)(
         THIS_
         IN IPrintAsyncNotifyDataObject*
         ) PURE;

    STDMETHOD(CloseChannel)(
         THIS_
         IN IPrintAsyncNotifyDataObject*
         ) PURE;
};


#undef  INTERFACE
#define INTERFACE IPrintAsyncNotifyCallback
DECLARE_INTERFACE_(IPrintAsyncNotifyCallback, IUnknown)
{
    STDMETHOD(QueryInterface)(
        THIS_
        REFIID riid,
        void** ppvObj
        ) PURE;

    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;

    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    STDMETHOD(OnEventNotify)(
         THIS_
         IN IPrintAsyncNotifyChannel*,
         IN IPrintAsyncNotifyDataObject*
         ) PURE;

    STDMETHOD(ChannelClosed)(
         THIS_
         IN IPrintAsyncNotifyChannel*,
         IN IPrintAsyncNotifyDataObject*
         ) PURE;
};

#undef INTERFACE

HRESULT
WINAPI
RegisterForPrintAsyncNotifications(
    __in_opt    PCWSTR                              pszName,
    __in        PrintAsyncNotificationType*         pNotificationType,
                PrintAsyncNotifyUserFilter          eUserFilter,
                PrintAsyncNotifyConversationStyle   eConversationStyle,
    __in        IPrintAsyncNotifyCallback*          pCallback,
    __out       HANDLE*                             phNotify
    );

HRESULT
WINAPI
UnRegisterForPrintAsyncNotifications(
    __in        HANDLE
    );

HRESULT
WINAPI
CreatePrintAsyncNotifyChannel(
    __in_opt    PCWSTR                              pszName,
    __in        PrintAsyncNotificationType*         pNotificationType,
                PrintAsyncNotifyUserFilter          eUserFilter,
                PrintAsyncNotifyConversationStyle   eConversationStyle,
    __in_opt    IPrintAsyncNotifyCallback*          pCallback,
    __out       IPrintAsyncNotifyChannel**          ppIAsynchNotification
    );

typedef enum
{
    CHANNEL_CLOSED_BY_SERVER                    = 0x01,
    CHANNEL_CLOSED_BY_ANOTHER_LISTENER          = 0x02,
    CHANNEL_CLOSED_BY_SAME_LISTENER             = 0x03,
    CHANNEL_RELEASED_BY_LISTENER                = 0x04,
    UNIRECTIONAL_NOTIFICATION_LOST              = 0x05,
    ASYNC_NOTIFICATION_FAILURE                  = 0x06,
    NO_LISTENERS                                = 0x07,
    CHANNEL_ALREADY_CLOSED                      = 0x08,
    CHANNEL_ALREADY_OPENED                      = 0x09,
    CHANNEL_WAITING_FOR_CLIENT_NOTIFICATION     = 0x0a,
    CHANNEL_NOT_OPENED                          = 0x0b,
    ASYNC_CALL_ALREADY_PARKED                   = 0x0c,
    NOT_REGISTERED                              = 0x0d,
    ALREADY_UNREGISTERED                        = 0x0e,
    ALREADY_REGISTERED                          = 0x0f,
    CHANNEL_ACQUIRED                            = 0x10,
    ASYNC_CALL_IN_PROGRESS                      = 0x11,
    MAX_NOTIFICATION_SIZE_EXCEEDED              = 0x12,
    INTERNAL_NOTIFICATION_QUEUE_IS_FULL         = 0x13,
    INVALID_NOTIFICATION_TYPE                   = 0x14,
    MAX_REGISTRATION_COUNT_EXCEEDED             = 0x15,
    MAX_CHANNEL_COUNT_EXCEEDED                  = 0x16,
    LOCAL_ONLY_REGISTRATION                     = 0x17,
    REMOTE_ONLY_REGISTRATION                    = 0x18,

} PrintAsyncNotifyError;

#ifdef __cplusplus
}
#endif

#endif // (NTDDI_VERSION >= NTDDI_LONGHORN)

#endif //  _PRINTASYNCNOTIFY_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\prntvpt.h ===
/*++

Copyright (c) 1996-2004 Microsoft Corporation

Module Name:

    prnptntv.h

Abstract:

    Print ticket APIs for Win32 applications

--*/

#ifndef _PRNPTNTV_H_
#define _PRNPTNTV_H_

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

DECLARE_HANDLE(HPTPROVIDER);

#define PRINTTICKET_ISTREAM_APIS 1

#define S_PT_NO_CONFLICT                 (0x00040001)
#define S_PT_CONFLICT_RESOLVED           (0x00040002)

/*
    PrintTicket stream provided by the caller did not
    follow PrintTicket framework specification or the XML
    could not be parsed.  If returned by 
    PTMergeAndValidatePrintTicket, it indicates that the 
    base ticket contained the error.
*/
#define E_PRINTTICKET_FORMAT             (0x80040003)

/*
    PrintCapabilities document generated by the driver
    did not follow the specification.  This indicates an
    error in the driver.
*/
#define E_PRINTCAPABILITIES_FORMAT       (0x80040004)

/*
    The delta print ticket parameter passed to 
    PTMergeAndValidatePrintTicket did not
    follow PrintTicket framework specification or
    the XML could not be parsed.
*/
#define E_DELTA_PRINTTICKET_FORMAT       (0x80040005)

typedef enum tagEDefaultDevmodeType
{
    kUserDefaultDevmode,
    kPrinterDefaultDevmode
} EDefaultDevmodeType;

typedef enum 
{
    kPTPageScope,
    kPTDocumentScope,
    kPTJobScope
} EPrintTicketScope;


HRESULT WINAPI
PTQuerySchemaVersionSupport(
            __in        PCWSTR       pszPrinterName,
            __out       DWORD       *pMaxVersion
            );

HRESULT WINAPI
PTOpenProvider( 
            __in        PCWSTR       pszPrinterName,
                        DWORD        dwVersion,
            __out       HPTPROVIDER *phProvider
            );

HRESULT WINAPI
PTOpenProviderEx( 
            __in  PCWSTR       pszPrinterName,
                  DWORD        dwMaxVersion,
                  DWORD        dwPrefVersion,
            __out HPTPROVIDER *phProvider,
            __out DWORD       *pUsedVersion
            );

HRESULT WINAPI
PTCloseProvider(
            __in  HPTPROVIDER hProvider
            );

HRESULT WINAPI
PTReleaseMemory(
    __in PVOID pBuffer
    );
    
HRESULT WINAPI
PTGetPrintCapabilities( 
            __in            HPTPROVIDER         hProvider,
            __in_opt        IStream            *pPrintTicket,
            __inout         IStream            *pCapabilities,
            __out_opt       BSTR               *pbstrErrorMessage
            );
        
HRESULT WINAPI
PTMergeAndValidatePrintTicket(
            __in            HPTPROVIDER        hProvider,
            __in            IStream           *pBaseTicket,
            __in_opt        IStream           *pDeltaTicket,
            __in            EPrintTicketScope  scope,
            __inout         IStream           *pResultTicket, 
            __out_opt       BSTR              *pbstrErrorMessage 
            );

HRESULT WINAPI
PTConvertPrintTicketToDevMode( 
            __in                     HPTPROVIDER          hProvider,
            __in                     IStream             *pPrintTicket,
                                     EDefaultDevmodeType  baseDevmodeType,
            __in                     EPrintTicketScope  scope,
            __out                    ULONG               *pcbDevmode,
            __deref_out_bcount(*pcbDevmode) OUT PDEVMODE *ppDevmode,
            __out_opt                BSTR                *pbstrErrorMessage 
            );
        
HRESULT WINAPI
PTConvertDevModeToPrintTicket( 
            __in        HPTPROVIDER        hProvider,
                        ULONG              cbDevmode,
            __in        PDEVMODE           pDevmode,
            __in        EPrintTicketScope  scope,
            __inout     IStream           *pPrintTicket
            );
        
#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* _PRNPTNTV_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\powrprof.h ===
/*****************************************************************************\
*                                                                             *
* powrprof.h - - Interface for powrprof.dll, the power policy applicator      *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

// Registry storage structures for the GLOBAL_POWER_POLICY data. There are two
// structures, GLOBAL_MACHINE_POWER_POLICY and GLOBAL_USER_POWER_POLICY. the
// GLOBAL_MACHINE_POWER_POLICY stores per machine data for which there is no UI.
// GLOBAL_USER_POWER_POLICY stores the per user data.

typedef struct _GLOBAL_MACHINE_POWER_POLICY{
    ULONG                   Revision;
    SYSTEM_POWER_STATE      LidOpenWakeAc;
    SYSTEM_POWER_STATE      LidOpenWakeDc;
    ULONG                   BroadcastCapacityResolution;
} GLOBAL_MACHINE_POWER_POLICY, *PGLOBAL_MACHINE_POWER_POLICY;

typedef struct _GLOBAL_USER_POWER_POLICY{
    ULONG                   Revision;
    POWER_ACTION_POLICY     PowerButtonAc;
    POWER_ACTION_POLICY     PowerButtonDc;
    POWER_ACTION_POLICY     SleepButtonAc;
    POWER_ACTION_POLICY     SleepButtonDc;
    POWER_ACTION_POLICY     LidCloseAc;
    POWER_ACTION_POLICY     LidCloseDc;
    SYSTEM_POWER_LEVEL      DischargePolicy[NUM_DISCHARGE_POLICIES];
    ULONG                   GlobalFlags;
} GLOBAL_USER_POWER_POLICY, *PGLOBAL_USER_POWER_POLICY;

// Structure to manage global power policies at the user level. This structure
// contains data which is common across all power policy profiles.

typedef struct _GLOBAL_POWER_POLICY{
    GLOBAL_USER_POWER_POLICY    user;
    GLOBAL_MACHINE_POWER_POLICY mach;
} GLOBAL_POWER_POLICY, *PGLOBAL_POWER_POLICY;


// Registry storage structures for the POWER_POLICY data. There are three
// structures, MACHINE_POWER_POLICY, MACHINE_PROCESSOR_POWER_POLICY and
// USER_POWER_POLICY. the MACHINE_POWER_POLICY stores per machine data for 
// which there is no UI.  USER_POWER_POLICY stores the per user data.

typedef struct _MACHINE_POWER_POLICY{
    ULONG                   Revision;       // 1

    // meaning of power action "sleep"
    SYSTEM_POWER_STATE      MinSleepAc;
    SYSTEM_POWER_STATE      MinSleepDc;
    SYSTEM_POWER_STATE      ReducedLatencySleepAc;
    SYSTEM_POWER_STATE      ReducedLatencySleepDc;

    // parameters for dozing
    ULONG                   DozeTimeoutAc;
    ULONG                   DozeTimeoutDc;
    ULONG                   DozeS4TimeoutAc;
    ULONG                   DozeS4TimeoutDc;

    // processor policies
    UCHAR                   MinThrottleAc;
    UCHAR                   MinThrottleDc;
    UCHAR                   pad1[2];
    POWER_ACTION_POLICY     OverThrottledAc;
    POWER_ACTION_POLICY     OverThrottledDc;

} MACHINE_POWER_POLICY, *PMACHINE_POWER_POLICY;


#if (NTDDI_VERSION >= NTDDI_WINXP) // Windows XP Version
//
// deprecated
//
typedef struct _MACHINE_PROCESSOR_POWER_POLICY {
    ULONG                   Revision;       // 1
    
    PROCESSOR_POWER_POLICY  ProcessorPolicyAc;    
    PROCESSOR_POWER_POLICY  ProcessorPolicyDc;    

} MACHINE_PROCESSOR_POWER_POLICY, *PMACHINE_PROCESSOR_POWER_POLICY;
#endif

typedef struct _USER_POWER_POLICY{
    ULONG                   Revision;       // 1


    // "system idle" detection
    POWER_ACTION_POLICY     IdleAc;
    POWER_ACTION_POLICY     IdleDc;
    ULONG                   IdleTimeoutAc;
    ULONG                   IdleTimeoutDc;
    UCHAR                   IdleSensitivityAc;
    UCHAR                   IdleSensitivityDc;
    
    // Throttling Policy
    UCHAR                   ThrottlePolicyAc;
    UCHAR                   ThrottlePolicyDc;

    // meaning of power action "sleep"
    SYSTEM_POWER_STATE      MaxSleepAc;
    SYSTEM_POWER_STATE      MaxSleepDc;

    // For future use
    ULONG                   Reserved[2];

    // video policies
    ULONG                   VideoTimeoutAc;
    ULONG                   VideoTimeoutDc;

    // hard disk policies
    ULONG                   SpindownTimeoutAc;
    ULONG                   SpindownTimeoutDc;

    // processor policies
    BOOLEAN                 OptimizeForPowerAc;
    BOOLEAN                 OptimizeForPowerDc;
    UCHAR                   FanThrottleToleranceAc;
    UCHAR                   FanThrottleToleranceDc;
    UCHAR                   ForcedThrottleAc;
    UCHAR                   ForcedThrottleDc;
    
} USER_POWER_POLICY, *PUSER_POWER_POLICY;

// Structure to manage power policies at the user level. This structure
// contains data which is unique across power policy profiles.

typedef struct _POWER_POLICY{
    USER_POWER_POLICY       user;
    MACHINE_POWER_POLICY    mach;
} POWER_POLICY, *PPOWER_POLICY;


// Constants for GlobalFlags

#define EnableSysTrayBatteryMeter   0x01
#define EnableMultiBatteryDisplay   0x02
#define EnablePasswordLogon         0x04
#define EnableWakeOnRing            0x08
#define EnableVideoDimDisplay       0x10

//
// Power setting attribute flags
//

#define POWER_ATTRIBUTE_HIDE        0x00000001

// This constant is passed as a uiID to WritePwrScheme.
#define NEWSCHEME (UINT)-1

// Prototype for EnumPwrSchemes callback proceedures.

#if (NTDDI_VERSION >= NTDDI_LONGHORN)
typedef BOOLEAN (CALLBACK* PWRSCHEMESENUMPROC)(UINT, DWORD, LPWSTR, DWORD, LPWSTR, PPOWER_POLICY, LPARAM);
#else
typedef BOOLEAN (CALLBACK* PWRSCHEMESENUMPROC)(UINT, DWORD, LPTSTR, DWORD, LPTSTR, PPOWER_POLICY, LPARAM);
#endif
typedef BOOLEAN (CALLBACK* PFNNTINITIATEPWRACTION)(POWER_ACTION, SYSTEM_POWER_STATE, ULONG, BOOLEAN);

// Public function prototypes

BOOLEAN
WINAPI
GetPwrDiskSpindownRange(
    __out PUINT puiMax,
    __out PUINT puiMin
    );   

BOOLEAN 
WINAPI
EnumPwrSchemes(
    __in PWRSCHEMESENUMPROC lpfn,
    __in LPARAM lParam
    );

BOOLEAN 
WINAPI ReadGlobalPwrPolicy(
        __in PGLOBAL_POWER_POLICY pGlobalPowerPolicy
    );
        
BOOLEAN 
WINAPI 
ReadPwrScheme(
        __in UINT uiID,
    __out PPOWER_POLICY pPowerPolicy
    );
    
BOOLEAN
WINAPI
WritePwrScheme(
    __in PUINT puiID,
    __in LPCWSTR lpszSchemeName,
    __in_opt LPCWSTR lpszDescription,
    __in PPOWER_POLICY lpScheme
    );

BOOLEAN 
WINAPI 
WriteGlobalPwrPolicy(
        __in PGLOBAL_POWER_POLICY pGlobalPowerPolicy
    );
        
BOOLEAN 
WINAPI 
DeletePwrScheme(
        __in UINT uiID
        );
        
BOOLEAN 
WINAPI 
GetActivePwrScheme(
        __out PUINT puiID
    );
        
BOOLEAN
WINAPI
SetActivePwrScheme(
    __in UINT uiID,
    __in_opt PGLOBAL_POWER_POLICY pGlobalPowerPolicy,
    __in_opt PPOWER_POLICY pPowerPolicy
    );
    
BOOLEAN 
WINAPI 
GetPwrCapabilities(
        __in PSYSTEM_POWER_CAPABILITIES lpspc
    );

BOOLEAN 
WINAPI
IsPwrSuspendAllowed(
        VOID
        );

BOOLEAN 
WINAPI
IsPwrHibernateAllowed(
        VOID
        );
        
BOOLEAN 
WINAPI
IsPwrShutdownAllowed(
        VOID
        );

BOOLEAN 
WINAPI
IsAdminOverrideActive(
    __in PADMINISTRATOR_POWER_POLICY papp
    );
    
BOOLEAN 
WINAPI 
SetSuspendState(
        __in BOOLEAN bHibernate,
    __in BOOLEAN bForce,
    __in BOOLEAN bWakeupEventsDisabled
    );
    
BOOLEAN 
WINAPI 
GetCurrentPowerPolicies(
        __out PGLOBAL_POWER_POLICY pGlobalPowerPolicy,
    __out PPOWER_POLICY pPowerPolicy
    );

BOOLEAN 
WINAPI 
CanUserWritePwrScheme(
        VOID
        );


#if (NTDDI_VERSION >= NTDDI_WINXP) // Windows XP Version
//
// deprecated.
//
BOOLEAN 
WINAPI 
ReadProcessorPwrScheme(
        __in UINT uiID,
    __out PMACHINE_PROCESSOR_POWER_POLICY pMachineProcessorPowerPolicy
    );

//
// deprecated.
//    
BOOLEAN 
WINAPI 
WriteProcessorPwrScheme(
        __in UINT uiID,
    __in PMACHINE_PROCESSOR_POWER_POLICY pMachineProcessorPowerPolicy
    );
#endif // (NTDDI_VERSION >= NTDDI_WINXP) // Windows XP Version

BOOLEAN 
WINAPI 
ValidatePowerPolicies(
        __inout_opt PGLOBAL_POWER_POLICY pGlobalPowerPolicy,
    __inout_opt PPOWER_POLICY pPowerPolicy
    );
    
#ifndef NT_SUCCESS
#define NTSTATUS LONG
#define _OVERRIDE_NTSTATUS_
#endif

NTSTATUS WINAPI CallNtPowerInformation(POWER_INFORMATION_LEVEL, __in_bcount_opt(cbin) PVOID pvin, ULONG cbin, __out_bcount_opt(cbout) PVOID pvout, ULONG cbout);

#ifdef _OVERRIDE_NTSTATUS_
#undef NTSTATUS
#endif

#if (NTDDI_VERSION >= NTDDI_LONGHORN)
//
// Enum which defines which field inside of a
// power setting is being accessed.
//
typedef enum _POWER_DATA_ACCESSOR {
        
        //
        // Used by read/write and enumeration engines
        //
        ACCESS_AC_POWER_SETTING_INDEX = 0,
        ACCESS_DC_POWER_SETTING_INDEX,
        ACCESS_FRIENDLY_NAME,
        ACCESS_DESCRIPTION,
        ACCESS_POSSIBLE_POWER_SETTING,
        ACCESS_POSSIBLE_POWER_SETTING_FRIENDLY_NAME,
        ACCESS_POSSIBLE_POWER_SETTING_DESCRIPTION,
        ACCESS_DEFAULT_AC_POWER_SETTING,
        ACCESS_DEFAULT_DC_POWER_SETTING,
        ACCESS_POSSIBLE_VALUE_MIN,
        ACCESS_POSSIBLE_VALUE_MAX,
        ACCESS_POSSIBLE_VALUE_INCREMENT,
        ACCESS_POSSIBLE_VALUE_UNITS,
        ACCESS_ICON_RESOURCE,
        ACCESS_DEFAULT_SECURITY_DESCRIPTOR,
        ACCESS_ATTRIBUTES,
        
        //
        // Used by enumeration engine.
        //
        ACCESS_SCHEME,
        ACCESS_SUBGROUP,
        ACCESS_INDIVIDUAL_SETTING,
        
        //
        // Used by access check
        //
        ACCESS_ACTIVE_SCHEME,
        ACCESS_CREATE_SCHEME
        
} POWER_DATA_ACCESSOR, *PPOWER_DATA_ACCESSOR;

//
// =========================================
// Power Scheme APIs
// =========================================
//

DWORD
WINAPI
PowerSettingAccessCheck (
    __in POWER_DATA_ACCESSOR AccessFlags,
    __in_opt CONST GUID *PowerGuid
    );

//
// Read functions.
//
DWORD
WINAPI
PowerReadACValueIndex (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __out LPDWORD AcValueIndex
    );

DWORD
WINAPI
PowerReadDCValueIndex (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __out LPDWORD DcValueIndex
    );

DWORD
WINAPI
PowerReadACValue (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __out_opt PULONG Type,
    __out_bcount_opt(*BufferSize) LPBYTE Buffer,
    __inout_opt LPDWORD BufferSize
    );

DWORD
WINAPI
PowerReadDCValue (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __out_opt PULONG Type,
    __out_bcount_opt(*BufferSize) PUCHAR Buffer,
    __inout LPDWORD BufferSize
    );

DWORD
WINAPI
PowerReadFriendlyName (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __out_bcount_opt(*BufferSize) PUCHAR Buffer,
    __inout LPDWORD BufferSize
    );

DWORD
WINAPI
PowerReadDescription (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __out_bcount_opt(*BufferSize) PUCHAR Buffer,
    __inout LPDWORD BufferSize
    );

DWORD
WINAPI
PowerReadPossibleValue (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __out_opt PULONG Type,
    __in ULONG PossibleSettingIndex,
    __out_bcount_opt(*BufferSize) PUCHAR Buffer,
    __inout LPDWORD BufferSize
    );

DWORD
WINAPI
PowerReadPossibleFriendlyName (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in ULONG PossibleSettingIndex,
    __out_bcount_opt(*BufferSize) PUCHAR Buffer,
    __inout LPDWORD BufferSize
    );

DWORD
WINAPI
PowerReadPossibleDescription (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in ULONG PossibleSettingIndex,
    __out_bcount_opt(*BufferSize) PUCHAR Buffer,
    __inout LPDWORD BufferSize
    );

DWORD
WINAPI
PowerReadValueMin (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __out LPDWORD ValueMinimum
    );

DWORD
WINAPI
PowerReadValueMax (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __out LPDWORD ValueMaximum
    );

DWORD
WINAPI
PowerReadValueIncrement (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __out LPDWORD ValueIncrement
    );

DWORD
WINAPI
PowerReadValueUnitsSpecifier (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __out_bcount_opt(*BufferSize) UCHAR *Buffer,
    __inout LPDWORD BufferSize
    );

DWORD
WINAPI
PowerReadACDefaultIndex (
    __in_opt HKEY RootPowerKey,
    __in CONST GUID *SchemePersonalityGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid OPTIONAL,
    __in CONST GUID *PowerSettingGuid,
    __out LPDWORD AcDefaultIndex
    );

DWORD
WINAPI
PowerReadDCDefaultIndex (
    __in_opt HKEY RootPowerKey,
    __in CONST GUID *SchemePersonalityGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in CONST GUID *PowerSettingGuid,
    __out LPDWORD DcDefaultIndex
    );

DWORD
WINAPI
PowerReadIconResourceSpecifier (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __out_bcount_opt(*BufferSize) PUCHAR Buffer,
    __inout LPDWORD BufferSize
    );
    
DWORD
WINAPI
PowerReadSettingAttributes (
    __in_opt CONST GUID *SubGroupGuid,
    __in_opt CONST GUID *PowerSettingGuid
    );

//
// Write functions.
//
DWORD
WINAPI
PowerWriteACValueIndex (
    __in_opt HKEY RootPowerKey,
    __in CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in DWORD AcValueIndex
    );

DWORD
WINAPI
PowerWriteDCValueIndex (
    __in_opt HKEY RootPowerKey,
    __in CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in DWORD DcValueIndex
    );

DWORD
WINAPI
PowerWriteFriendlyName (
    __in_opt HKEY RootPowerKey,
    __in CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in UCHAR *Buffer,
    __in DWORD BufferSize
    );

DWORD
WINAPI
PowerWriteDescription (
    __in_opt HKEY RootPowerKey,
    __in CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in_bcount(BufferSize) UCHAR *Buffer,
    __in DWORD BufferSize
    );

DWORD
WINAPI
PowerWritePossibleValue (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in ULONG Type,
    __in ULONG PossibleSettingIndex,
    __in_bcount(BufferSize) UCHAR *Buffer,
    __in DWORD BufferSize
    );

DWORD
WINAPI
PowerWritePossibleFriendlyName (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in ULONG PossibleSettingIndex,
    __in_bcount(BufferSize) UCHAR *Buffer,
    __in DWORD BufferSize
    );

DWORD
WINAPI
PowerWritePossibleDescription (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in ULONG PossibleSettingIndex,
    __in_bcount(BufferSize) UCHAR *Buffer,
    __in DWORD BufferSize
    );

DWORD
WINAPI
PowerWriteValueMin (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in DWORD ValueMinimum
    );

DWORD
WINAPI
PowerWriteValueMax (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in DWORD ValueMaximum
    );
    
DWORD
WINAPI
PowerWriteValueIncrement (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in DWORD ValueIncrement
    );

DWORD
WINAPI
PowerWriteValueUnitsSpecifier (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in_bcount(BufferSize) UCHAR *Buffer,
    __in DWORD BufferSize
    );

DWORD
WINAPI
PowerWriteACDefaultIndex (
    __in_opt HKEY RootSystemPowerKey,
    __in CONST GUID *SchemePersonalityGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in CONST GUID *PowerSettingGuid,
    __in DWORD DefaultAcIndex
    );

DWORD
WINAPI
PowerWriteDCDefaultIndex (
    __in_opt HKEY RootSystemPowerKey,
    __in CONST GUID *SchemePersonalityGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in CONST GUID *PowerSettingGuid,
    __in DWORD DefaultDcIndex
    );

DWORD
WINAPI
PowerWriteIconResourceSpecifier (
    __in_opt HKEY RootPowerKey,
    __in CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in_bcount(BufferSize) UCHAR *Buffer,
    __in DWORD BufferSize
    );
    
DWORD
PowerWriteSettingAttributes (
    __in_opt CONST GUID *SubGroupGuid,
    __in_opt CONST GUID *PowerSettingGuid,
    __in DWORD Attributes
    );

DWORD
WINAPI
PowerDuplicateScheme (
    __in_opt HKEY RootPowerKey,
    __in CONST GUID *SourceSchemeGuid,
    __in GUID **DestinationSchemeGuid
    );
    
DWORD
PowerImportPowerScheme (
    __in_opt HKEY RootPowerKey,
    __in LPCWSTR ImportFileNamePath,
    __deref_inout GUID **DestinationSchemeGuid
    );

DWORD
WINAPI
PowerDeleteScheme (
    __in_opt HKEY RootPowerKey,
    __in CONST GUID *SchemeGuid
    );

DWORD 
WINAPI
PowerRemovePowerSetting (
   __in CONST GUID *PowerSettingSubKeyGuid,
   __in CONST GUID *PowerSettingGuid
   );

DWORD
WINAPI
PowerCreateSetting (
    __in_opt HKEY RootSystemPowerKey,
    __in CONST GUID *SubGroupOfPowerSettingsGuid,
    __in CONST GUID *PowerSettingGuid
    );

DWORD
WINAPI
PowerCreatePossibleSetting (
    __in_opt HKEY RootSystemPowerKey,
    __in CONST GUID *SubGroupOfPowerSettingsGuid,
    __in CONST GUID *PowerSettingGuid,
    __in ULONG PossibleSettingIndex 
    );

//
// Enumerate Functions.
//
DWORD
WINAPI
PowerEnumerate (
    __in_opt HKEY RootPowerKey,
    __in_opt CONST GUID *SchemeGuid,
    __in_opt CONST GUID *SubGroupOfPowerSettingsGuid,
    __in POWER_DATA_ACCESSOR AccessFlags,
    __in ULONG Index,
    __out_bcount_opt(*BufferSize) UCHAR *Buffer,
    __inout DWORD *BufferSize
    );

//
// Activate Functions.
//
DWORD
WINAPI
PowerSetActiveScheme (
    __in_opt HKEY UserRootPowerKey,
    __in_opt CONST GUID *SchemeGuid
    );

DWORD
WINAPI
PowerGetActiveScheme (
    __in_opt HKEY UserRootPowerKey,
    __deref_out GUID **ActivePolicyGuid
    );
    
DWORD
PowerOpenUserPowerKey (
    __out HKEY *phUserPowerKey,
    __in REGSAM Access,
    __in BOOL OpenExisting
    );

DWORD
PowerOpenSystemPowerKey (
    __out HKEY *phSystemPowerKey,
    __in REGSAM Access,
    __in BOOL OpenExisting
    );
        
DWORD
WINAPI
PowerCanRestoreIndividualDefaultPowerScheme (
    __in CONST GUID *SchemeGuid
    );

DWORD
WINAPI
PowerRestoreIndividualDefaultPowerScheme (
    __in CONST GUID *SchemeGuid
    );

DWORD
WINAPI
PowerRestoreDefaultPowerSchemes(
    VOID
    );

DWORD
WINAPI
PowerReplaceDefaultPowerSchemes(
    VOID
    );

POWER_PLATFORM_ROLE
WINAPI
PowerDeterminePlatformRole(
    VOID
    );

#endif // #if (NTDDI_VERSION >= NTDDI_LONGHORN)




#if (NTDDI_VERSION >= NTDDI_WS03) // Windows server03

//
// =========================================
// Device Power APIs
// =========================================
//
//
// ========================================================
// These flags tell us how to interpret a query of
// device power.  Use these (or a combination of these)
// for the QueryInterpretationFlags parameter sent into
// DevicePowerEnumDevices().
//
// They'll ask us for some devices that supports some
// D state.  These flags help us determine what the
// user really wants.  I.e. does he want the device
// name, or the hardware ID.  Does he want some device
// that supports some D state, or does he want us to
// go see if that devices supports some S state? ...
// ========================================================
//

//
// Return HardwareID instead of the friendly device name, which
// is the default.
//
#define DEVICEPOWER_HARDWAREID             (0x80000000)

//
//
// 'and' the requested power states.  I.e. if the user requested
// that we query devices supporting D1 and D3, this flag says
// "give me devices that support D1 *and* D3".  Without this
// flag, the query would be interpreted as "give me devices
// that support D1 *or* D3".
//
#define DEVICEPOWER_AND_OPERATION          (0x40000000)

// Only preform the query on devices that are present in the system.
//
#define DEVICEPOWER_FILTER_DEVICES_PRESENT (0x20000000)

//
// Only preform the query on devices that are actual hardware.
//
#define DEVICEPOWER_FILTER_HARDWARE        (0x10000000)

//
// Only preform the query on devices that are armed to wake the
// system from a sleep state.
//
#define DEVICEPOWER_FILTER_WAKEENABLED     (0x08000000)

//
// Only preform the query on devices that are capable of being programmed
// to wake the system from a sleep state.
//
#define DEVICEPOWER_FILTER_WAKEPROGRAMMABLE (0x04000000)

//
// Go find the device who's name is specifed by an input
// parameter, then see if it's got the capabilities specified
// in QueryFlags.
//
#define DEVICEPOWER_FILTER_ON_NAME         (0x02000000)



//
// Define flags to set/clear capabilities in the devices.
//

//
// Enable the device to wake the system from a sleep state.
//
#define DEVICEPOWER_SET_WAKEENABLED (0x00000001)

//
// Disable the device from waking the system from a sleep
// state.
//
#define DEVICEPOWER_CLEAR_WAKEENABLED (0x00000002)




//
// For the QueryFlags parameter, the user should send in
// one of the PDCAP_D*_SUPPORTED flags found in ntpoapi.h.
//
// #define PDCAP_D0_SUPPORTED              0x00000001
// #define PDCAP_D1_SUPPORTED              0x00000002
// #define PDCAP_D2_SUPPORTED              0x00000004
// #define PDCAP_D3_SUPPORTED              0x00000008
// #define PDCAP_WAKE_FROM_D0_SUPPORTED    0x00000010
// #define PDCAP_WAKE_FROM_D1_SUPPORTED    0x00000020
// #define PDCAP_WAKE_FROM_D2_SUPPORTED    0x00000040
// #define PDCAP_WAKE_FROM_D3_SUPPORTED    0x00000080
// #define PDCAP_WARM_EJECT_SUPPORTED      0x00000100
//
// The user can also send in a combination of these values
// to do queries that match either or both of the specified
// flags.  E.g. if the user used (PDCAP_D1_SUPPORTED | PDCAP_D3_SUPPORTED),
// then the query would return a device that supported *either*
// D1 or D3.  The user could specify QUERY_AND_OPERATION in
// QueryInterpretationFlags to get a device that supported
// D1 *and* D3.
//

//
// We also support querying on S states.  Although devices don't
// really understand system states, we can use the D-to-S state
// mappings to derive this.  For example, if we ask a device if
// he supports S2, we can derive that by looking at his D-to-S
// mappings.  Suppose the device has a D-to-S state mapping
// that looks like this:
// S0 -> D0
// S1 -> D3
// S2 -> D3
// S3 -> D3
// S4 -> D3
// S5 -> D3
//
// We see that S2 maps to D3 on this device.  Does this device
// actually support D3?  We can find that out.  If so, then we
// say that this device supports S2.
//
// We have to make up the S-state vectors because there's no
// existing values like the PDCAP_D* values.
//
#define PDCAP_S0_SUPPORTED              0x00010000
#define PDCAP_S1_SUPPORTED              0x00020000
#define PDCAP_S2_SUPPORTED              0x00040000
#define PDCAP_S3_SUPPORTED              0x00080000
#define PDCAP_WAKE_FROM_S0_SUPPORTED    0x00100000
#define PDCAP_WAKE_FROM_S1_SUPPORTED    0x00200000
#define PDCAP_WAKE_FROM_S2_SUPPORTED    0x00400000
#define PDCAP_WAKE_FROM_S3_SUPPORTED    0x00800000
#define PDCAP_S4_SUPPORTED              0x01000000
#define PDCAP_S5_SUPPORTED              0x02000000


//
// Function prototypes
//
extern
BOOLEAN    
DevicePowerEnumDevices(
    __in ULONG  QueryIndex,
    __in ULONG  QueryInterpretationFlags,
    __in ULONG  QueryFlags,
    __out_bcount_opt(*pBufferSize) PBYTE  pReturnBuffer,
    __inout PULONG pBufferSize
    );

extern
DWORD
DevicePowerSetDeviceState(
    __in LPCWSTR DeviceDescription,
    __in ULONG SetFlags,
    __in_opt PVOID SetData
    );

BOOLEAN
DevicePowerOpen(
    __in_opt ULONG DebugMask
    );

BOOLEAN
DevicePowerClose(
    VOID
    );
#endif  // (NTDDI_VERSION >= NTDDI_WS03) Windows server03 version



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\pre64pra.h ===
// pre64pra.h is a deprecated file from previous versions of the Windows SDK
// This file will be removed in the future - and its dependent win32.mak file
// updated appropriately.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\propkey.h ===
//===========================================================================
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
//===========================================================================


#ifndef _INC_PROPKEY
#define _INC_PROPKEY

#ifndef DEFINE_API_PKEY
#define DEFINE_API_PKEY(name, managed_name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8, pid) \
        DEFINE_PROPERTYKEY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8, pid)
#endif

#include <propkeydef.h>

#ifndef _WIN32_IE
#define _WIN32_IE 0x0501
#else
#if (_WIN32_IE < 0x0400) && defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0500)
#error _WIN32_IE setting conflicts with _WIN32_WINNT setting
#endif
#endif

 
//-----------------------------------------------------------------------------
// Audio properties

//  Name:     System.Audio.ChannelCount -- PKEY_Audio_ChannelCount
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_AudioSummaryInformation) 64440490-4C8B-11D1-8B70-080036B11A03, 7 (PIDASI_CHANNEL_COUNT)
//
//  Indicates the channel count for the audio file.  Values: 1 (mono), 2 (stereo).
DEFINE_PROPERTYKEY(PKEY_Audio_ChannelCount, 0x64440490, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 7);

// Possible discrete values for PKEY_Audio_ChannelCount are:
#define AUDIO_CHANNELCOUNT_MONO             1ul
#define AUDIO_CHANNELCOUNT_STEREO           2ul

//  Name:     System.Audio.Compression -- PKEY_Audio_Compression
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_AudioSummaryInformation) 64440490-4C8B-11D1-8B70-080036B11A03, 10 (PIDASI_COMPRESSION)
//
//  
DEFINE_PROPERTYKEY(PKEY_Audio_Compression, 0x64440490, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 10);

//  Name:     System.Audio.EncodingBitrate -- PKEY_Audio_EncodingBitrate
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_AudioSummaryInformation) 64440490-4C8B-11D1-8B70-080036B11A03, 4 (PIDASI_AVG_DATA_RATE)
//
//  Indicates the average data rate in Hz for the audio file in "bits per second".
DEFINE_PROPERTYKEY(PKEY_Audio_EncodingBitrate, 0x64440490, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 4);

//  Name:     System.Audio.Format -- PKEY_Audio_Format
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)  Legacy code may treat this as VT_BSTR.
//  FormatID: (FMTID_AudioSummaryInformation) 64440490-4C8B-11D1-8B70-080036B11A03, 2 (PIDASI_FORMAT)
//
//  Indicates the format of the audio file.
DEFINE_PROPERTYKEY(PKEY_Audio_Format, 0x64440490, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 2);

//  Name:     System.Audio.IsVariableBitRate -- PKEY_Audio_IsVariableBitRate
//  Type:     Boolean -- VT_BOOL
//  FormatID: E6822FEE-8C17-4D62-823C-8E9CFCBD1D5C, 100
DEFINE_PROPERTYKEY(PKEY_Audio_IsVariableBitRate, 0xE6822FEE, 0x8C17, 0x4D62, 0x82, 0x3C, 0x8E, 0x9C, 0xFC, 0xBD, 0x1D, 0x5C, 100);

//  Name:     System.Audio.PeakValue -- PKEY_Audio_PeakValue
//  Type:     UInt32 -- VT_UI4
//  FormatID: 2579E5D0-1116-4084-BD9A-9B4F7CB4DF5E, 100
DEFINE_PROPERTYKEY(PKEY_Audio_PeakValue, 0x2579E5D0, 0x1116, 0x4084, 0xBD, 0x9A, 0x9B, 0x4F, 0x7C, 0xB4, 0xDF, 0x5E, 100);

//  Name:     System.Audio.SampleRate -- PKEY_Audio_SampleRate
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_AudioSummaryInformation) 64440490-4C8B-11D1-8B70-080036B11A03, 5 (PIDASI_SAMPLE_RATE)
//
//  Indicates the audio sample rate for the audio file in "samples per second".
DEFINE_PROPERTYKEY(PKEY_Audio_SampleRate, 0x64440490, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 5);

//  Name:     System.Audio.SampleSize -- PKEY_Audio_SampleSize
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_AudioSummaryInformation) 64440490-4C8B-11D1-8B70-080036B11A03, 6 (PIDASI_SAMPLE_SIZE)
//
//  Indicates the audio sample size for the audio file in "bits per sample".
DEFINE_PROPERTYKEY(PKEY_Audio_SampleSize, 0x64440490, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 6);

//  Name:     System.Audio.StreamName -- PKEY_Audio_StreamName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_AudioSummaryInformation) 64440490-4C8B-11D1-8B70-080036B11A03, 9 (PIDASI_STREAM_NAME)
//
//  
DEFINE_PROPERTYKEY(PKEY_Audio_StreamName, 0x64440490, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 9);

//  Name:     System.Audio.StreamNumber -- PKEY_Audio_StreamNumber
//  Type:     UInt16 -- VT_UI2
//  FormatID: (FMTID_AudioSummaryInformation) 64440490-4C8B-11D1-8B70-080036B11A03, 8 (PIDASI_STREAM_NUMBER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Audio_StreamNumber, 0x64440490, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 8);

 
 
//-----------------------------------------------------------------------------
// Calendar properties

//  Name:     System.Calendar.Duration -- PKEY_Calendar_Duration
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 293CA35A-09AA-4DD2-B180-1FE245728A52, 100
//
//  The duration as specified in a string.
DEFINE_PROPERTYKEY(PKEY_Calendar_Duration, 0x293CA35A, 0x09AA, 0x4DD2, 0xB1, 0x80, 0x1F, 0xE2, 0x45, 0x72, 0x8A, 0x52, 100);

//  Name:     System.Calendar.IsOnline -- PKEY_Calendar_IsOnline
//  Type:     Boolean -- VT_BOOL
//  FormatID: BFEE9149-E3E2-49A7-A862-C05988145CEC, 100
//
//  Identifies if the event is an online event.
DEFINE_PROPERTYKEY(PKEY_Calendar_IsOnline, 0xBFEE9149, 0xE3E2, 0x49A7, 0xA8, 0x62, 0xC0, 0x59, 0x88, 0x14, 0x5C, 0xEC, 100);

//  Name:     System.Calendar.IsRecurring -- PKEY_Calendar_IsRecurring
//  Type:     Boolean -- VT_BOOL
//  FormatID: 315B9C8D-80A9-4EF9-AE16-8E746DA51D70, 100
DEFINE_PROPERTYKEY(PKEY_Calendar_IsRecurring, 0x315B9C8D, 0x80A9, 0x4EF9, 0xAE, 0x16, 0x8E, 0x74, 0x6D, 0xA5, 0x1D, 0x70, 100);

//  Name:     System.Calendar.Location -- PKEY_Calendar_Location
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: F6272D18-CECC-40B1-B26A-3911717AA7BD, 100
DEFINE_PROPERTYKEY(PKEY_Calendar_Location, 0xF6272D18, 0xCECC, 0x40B1, 0xB2, 0x6A, 0x39, 0x11, 0x71, 0x7A, 0xA7, 0xBD, 100);

//  Name:     System.Calendar.OptionalAttendeeAddresses -- PKEY_Calendar_OptionalAttendeeAddresses
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: D55BAE5A-3892-417A-A649-C6AC5AAAEAB3, 100
DEFINE_PROPERTYKEY(PKEY_Calendar_OptionalAttendeeAddresses, 0xD55BAE5A, 0x3892, 0x417A, 0xA6, 0x49, 0xC6, 0xAC, 0x5A, 0xAA, 0xEA, 0xB3, 100);

//  Name:     System.Calendar.OptionalAttendeeNames -- PKEY_Calendar_OptionalAttendeeNames
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: 09429607-582D-437F-84C3-DE93A2B24C3C, 100
DEFINE_PROPERTYKEY(PKEY_Calendar_OptionalAttendeeNames, 0x09429607, 0x582D, 0x437F, 0x84, 0xC3, 0xDE, 0x93, 0xA2, 0xB2, 0x4C, 0x3C, 100);

//  Name:     System.Calendar.OrganizerAddress -- PKEY_Calendar_OrganizerAddress
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 744C8242-4DF5-456C-AB9E-014EFB9021E3, 100
//
//  Address of the organizer organizing the event.
DEFINE_PROPERTYKEY(PKEY_Calendar_OrganizerAddress, 0x744C8242, 0x4DF5, 0x456C, 0xAB, 0x9E, 0x01, 0x4E, 0xFB, 0x90, 0x21, 0xE3, 100);

//  Name:     System.Calendar.OrganizerName -- PKEY_Calendar_OrganizerName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: AAA660F9-9865-458E-B484-01BC7FE3973E, 100
//
//  Name of the organizer organizing the event.
DEFINE_PROPERTYKEY(PKEY_Calendar_OrganizerName, 0xAAA660F9, 0x9865, 0x458E, 0xB4, 0x84, 0x01, 0xBC, 0x7F, 0xE3, 0x97, 0x3E, 100);

//  Name:     System.Calendar.ReminderTime -- PKEY_Calendar_ReminderTime
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: 72FC5BA4-24F9-4011-9F3F-ADD27AFAD818, 100
DEFINE_PROPERTYKEY(PKEY_Calendar_ReminderTime, 0x72FC5BA4, 0x24F9, 0x4011, 0x9F, 0x3F, 0xAD, 0xD2, 0x7A, 0xFA, 0xD8, 0x18, 100);

//  Name:     System.Calendar.RequiredAttendeeAddresses -- PKEY_Calendar_RequiredAttendeeAddresses
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: 0BA7D6C3-568D-4159-AB91-781A91FB71E5, 100
DEFINE_PROPERTYKEY(PKEY_Calendar_RequiredAttendeeAddresses, 0x0BA7D6C3, 0x568D, 0x4159, 0xAB, 0x91, 0x78, 0x1A, 0x91, 0xFB, 0x71, 0xE5, 100);

//  Name:     System.Calendar.RequiredAttendeeNames -- PKEY_Calendar_RequiredAttendeeNames
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: B33AF30B-F552-4584-936C-CB93E5CDA29F, 100
DEFINE_PROPERTYKEY(PKEY_Calendar_RequiredAttendeeNames, 0xB33AF30B, 0xF552, 0x4584, 0x93, 0x6C, 0xCB, 0x93, 0xE5, 0xCD, 0xA2, 0x9F, 100);

//  Name:     System.Calendar.Resources -- PKEY_Calendar_Resources
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: 00F58A38-C54B-4C40-8696-97235980EAE1, 100
DEFINE_PROPERTYKEY(PKEY_Calendar_Resources, 0x00F58A38, 0xC54B, 0x4C40, 0x86, 0x96, 0x97, 0x23, 0x59, 0x80, 0xEA, 0xE1, 100);

//  Name:     System.Calendar.ShowTimeAs -- PKEY_Calendar_ShowTimeAs
//  Type:     UInt16 -- VT_UI2
//  FormatID: 5BF396D4-5EB2-466F-BDE9-2FB3F2361D6E, 100
//
//  
DEFINE_PROPERTYKEY(PKEY_Calendar_ShowTimeAs, 0x5BF396D4, 0x5EB2, 0x466F, 0xBD, 0xE9, 0x2F, 0xB3, 0xF2, 0x36, 0x1D, 0x6E, 100);

// Possible discrete values for PKEY_Calendar_ShowTimeAs are:
#define CALENDAR_SHOWTIMEAS_FREE            0u
#define CALENDAR_SHOWTIMEAS_TENTATIVE       1u
#define CALENDAR_SHOWTIMEAS_BUSY            2u
#define CALENDAR_SHOWTIMEAS_OOF             3u

//  Name:     System.Calendar.ShowTimeAsText -- PKEY_Calendar_ShowTimeAsText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 53DA57CF-62C0-45C4-81DE-7610BCEFD7F5, 100
//  
//  This is the user-friendly form of System.Calendar.ShowTimeAs.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Calendar_ShowTimeAsText, 0x53DA57CF, 0x62C0, 0x45C4, 0x81, 0xDE, 0x76, 0x10, 0xBC, 0xEF, 0xD7, 0xF5, 100);
 
//-----------------------------------------------------------------------------
// Communication properties



//  Name:     System.Communication.AccountName -- PKEY_Communication_AccountName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 9
//
//  Account Name
DEFINE_PROPERTYKEY(PKEY_Communication_AccountName, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 9);

//  Name:     System.Communication.Suffix -- PKEY_Communication_Suffix
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 807B653A-9E91-43EF-8F97-11CE04EE20C5, 100
DEFINE_PROPERTYKEY(PKEY_Communication_Suffix, 0x807B653A, 0x9E91, 0x43EF, 0x8F, 0x97, 0x11, 0xCE, 0x04, 0xEE, 0x20, 0xC5, 100);

//  Name:     System.Communication.TaskStatus -- PKEY_Communication_TaskStatus
//  Type:     UInt16 -- VT_UI2
//  FormatID: BE1A72C6-9A1D-46B7-AFE7-AFAF8CEF4999, 100
DEFINE_PROPERTYKEY(PKEY_Communication_TaskStatus, 0xBE1A72C6, 0x9A1D, 0x46B7, 0xAF, 0xE7, 0xAF, 0xAF, 0x8C, 0xEF, 0x49, 0x99, 100);

// Possible discrete values for PKEY_Communication_TaskStatus are:
#define TASKSTATUS_NOTSTARTED               0u
#define TASKSTATUS_INPROGRESS               1u
#define TASKSTATUS_COMPLETE                 2u
#define TASKSTATUS_WAITING                  3u
#define TASKSTATUS_DEFERRED                 4u

//  Name:     System.Communication.TaskStatusText -- PKEY_Communication_TaskStatusText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: A6744477-C237-475B-A075-54F34498292A, 100
//  
//  This is the user-friendly form of System.Communication.TaskStatus.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Communication_TaskStatusText, 0xA6744477, 0xC237, 0x475B, 0xA0, 0x75, 0x54, 0xF3, 0x44, 0x98, 0x29, 0x2A, 100);
 
//-----------------------------------------------------------------------------
// Computer properties



//  Name:     System.Computer.DecoratedFreeSpace -- PKEY_Computer_DecoratedFreeSpace
//  Type:     Multivalue UInt64 -- VT_VECTOR | VT_UI8  (For variants: VT_ARRAY | VT_UI8)
//  FormatID: (FMTID_Volume) 9B174B35-40FF-11D2-A27E-00C04FC30871, 7  (Filesystem Volume Properties)
//
//  Free space and total space: "%s free of %s"
DEFINE_PROPERTYKEY(PKEY_Computer_DecoratedFreeSpace, 0x9B174B35, 0x40FF, 0x11D2, 0xA2, 0x7E, 0x00, 0xC0, 0x4F, 0xC3, 0x08, 0x71, 7);
 
//-----------------------------------------------------------------------------
// Contact properties



//  Name:     System.Contact.Anniversary -- PKEY_Contact_Anniversary
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: 9AD5BADB-CEA7-4470-A03D-B84E51B9949E, 100
DEFINE_PROPERTYKEY(PKEY_Contact_Anniversary, 0x9AD5BADB, 0xCEA7, 0x4470, 0xA0, 0x3D, 0xB8, 0x4E, 0x51, 0xB9, 0x94, 0x9E, 100);

//  Name:     System.Contact.AssistantName -- PKEY_Contact_AssistantName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: CD102C9C-5540-4A88-A6F6-64E4981C8CD1, 100
DEFINE_PROPERTYKEY(PKEY_Contact_AssistantName, 0xCD102C9C, 0x5540, 0x4A88, 0xA6, 0xF6, 0x64, 0xE4, 0x98, 0x1C, 0x8C, 0xD1, 100);

//  Name:     System.Contact.AssistantTelephone -- PKEY_Contact_AssistantTelephone
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 9A93244D-A7AD-4FF8-9B99-45EE4CC09AF6, 100
DEFINE_PROPERTYKEY(PKEY_Contact_AssistantTelephone, 0x9A93244D, 0xA7AD, 0x4FF8, 0x9B, 0x99, 0x45, 0xEE, 0x4C, 0xC0, 0x9A, 0xF6, 100);

//  Name:     System.Contact.Birthday -- PKEY_Contact_Birthday
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: 176DC63C-2688-4E89-8143-A347800F25E9, 47
DEFINE_PROPERTYKEY(PKEY_Contact_Birthday, 0x176DC63C, 0x2688, 0x4E89, 0x81, 0x43, 0xA3, 0x47, 0x80, 0x0F, 0x25, 0xE9, 47);

//  Name:     System.Contact.BusinessAddress -- PKEY_Contact_BusinessAddress
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 730FB6DD-CF7C-426B-A03F-BD166CC9EE24, 100
DEFINE_PROPERTYKEY(PKEY_Contact_BusinessAddress, 0x730FB6DD, 0xCF7C, 0x426B, 0xA0, 0x3F, 0xBD, 0x16, 0x6C, 0xC9, 0xEE, 0x24, 100);

//  Name:     System.Contact.BusinessAddressCity -- PKEY_Contact_BusinessAddressCity
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 402B5934-EC5A-48C3-93E6-85E86A2D934E, 100
DEFINE_PROPERTYKEY(PKEY_Contact_BusinessAddressCity, 0x402B5934, 0xEC5A, 0x48C3, 0x93, 0xE6, 0x85, 0xE8, 0x6A, 0x2D, 0x93, 0x4E, 100);

//  Name:     System.Contact.BusinessAddressCountry -- PKEY_Contact_BusinessAddressCountry
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: B0B87314-FCF6-4FEB-8DFF-A50DA6AF561C, 100
DEFINE_PROPERTYKEY(PKEY_Contact_BusinessAddressCountry, 0xB0B87314, 0xFCF6, 0x4FEB, 0x8D, 0xFF, 0xA5, 0x0D, 0xA6, 0xAF, 0x56, 0x1C, 100);

//  Name:     System.Contact.BusinessAddressPostalCode -- PKEY_Contact_BusinessAddressPostalCode
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: E1D4A09E-D758-4CD1-B6EC-34A8B5A73F80, 100
DEFINE_PROPERTYKEY(PKEY_Contact_BusinessAddressPostalCode, 0xE1D4A09E, 0xD758, 0x4CD1, 0xB6, 0xEC, 0x34, 0xA8, 0xB5, 0xA7, 0x3F, 0x80, 100);

//  Name:     System.Contact.BusinessAddressPostOfficeBox -- PKEY_Contact_BusinessAddressPostOfficeBox
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: BC4E71CE-17F9-48D5-BEE9-021DF0EA5409, 100
DEFINE_PROPERTYKEY(PKEY_Contact_BusinessAddressPostOfficeBox, 0xBC4E71CE, 0x17F9, 0x48D5, 0xBE, 0xE9, 0x02, 0x1D, 0xF0, 0xEA, 0x54, 0x09, 100);

//  Name:     System.Contact.BusinessAddressState -- PKEY_Contact_BusinessAddressState
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 446F787F-10C4-41CB-A6C4-4D0343551597, 100
DEFINE_PROPERTYKEY(PKEY_Contact_BusinessAddressState, 0x446F787F, 0x10C4, 0x41CB, 0xA6, 0xC4, 0x4D, 0x03, 0x43, 0x55, 0x15, 0x97, 100);

//  Name:     System.Contact.BusinessAddressStreet -- PKEY_Contact_BusinessAddressStreet
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: DDD1460F-C0BF-4553-8CE4-10433C908FB0, 100
DEFINE_PROPERTYKEY(PKEY_Contact_BusinessAddressStreet, 0xDDD1460F, 0xC0BF, 0x4553, 0x8C, 0xE4, 0x10, 0x43, 0x3C, 0x90, 0x8F, 0xB0, 100);

//  Name:     System.Contact.BusinessFaxNumber -- PKEY_Contact_BusinessFaxNumber
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 91EFF6F3-2E27-42CA-933E-7C999FBE310B, 100
//
//  Business fax number of the contact.
DEFINE_PROPERTYKEY(PKEY_Contact_BusinessFaxNumber, 0x91EFF6F3, 0x2E27, 0x42CA, 0x93, 0x3E, 0x7C, 0x99, 0x9F, 0xBE, 0x31, 0x0B, 100);

//  Name:     System.Contact.BusinessHomePage -- PKEY_Contact_BusinessHomePage
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 56310920-2491-4919-99CE-EADB06FAFDB2, 100
DEFINE_PROPERTYKEY(PKEY_Contact_BusinessHomePage, 0x56310920, 0x2491, 0x4919, 0x99, 0xCE, 0xEA, 0xDB, 0x06, 0xFA, 0xFD, 0xB2, 100);

//  Name:     System.Contact.BusinessTelephone -- PKEY_Contact_BusinessTelephone
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 6A15E5A0-0A1E-4CD7-BB8C-D2F1B0C929BC, 100
DEFINE_PROPERTYKEY(PKEY_Contact_BusinessTelephone, 0x6A15E5A0, 0x0A1E, 0x4CD7, 0xBB, 0x8C, 0xD2, 0xF1, 0xB0, 0xC9, 0x29, 0xBC, 100);

//  Name:     System.Contact.CallbackTelephone -- PKEY_Contact_CallbackTelephone
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: BF53D1C3-49E0-4F7F-8567-5A821D8AC542, 100
DEFINE_PROPERTYKEY(PKEY_Contact_CallbackTelephone, 0xBF53D1C3, 0x49E0, 0x4F7F, 0x85, 0x67, 0x5A, 0x82, 0x1D, 0x8A, 0xC5, 0x42, 100);

//  Name:     System.Contact.CarTelephone -- PKEY_Contact_CarTelephone
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 8FDC6DEA-B929-412B-BA90-397A257465FE, 100
DEFINE_PROPERTYKEY(PKEY_Contact_CarTelephone, 0x8FDC6DEA, 0xB929, 0x412B, 0xBA, 0x90, 0x39, 0x7A, 0x25, 0x74, 0x65, 0xFE, 100);

//  Name:     System.Contact.Children -- PKEY_Contact_Children
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: D4729704-8EF1-43EF-9024-2BD381187FD5, 100
DEFINE_PROPERTYKEY(PKEY_Contact_Children, 0xD4729704, 0x8EF1, 0x43EF, 0x90, 0x24, 0x2B, 0xD3, 0x81, 0x18, 0x7F, 0xD5, 100);

//  Name:     System.Contact.CompanyMainTelephone -- PKEY_Contact_CompanyMainTelephone
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 8589E481-6040-473D-B171-7FA89C2708ED, 100
DEFINE_PROPERTYKEY(PKEY_Contact_CompanyMainTelephone, 0x8589E481, 0x6040, 0x473D, 0xB1, 0x71, 0x7F, 0xA8, 0x9C, 0x27, 0x08, 0xED, 100);

//  Name:     System.Contact.Department -- PKEY_Contact_Department
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: FC9F7306-FF8F-4D49-9FB6-3FFE5C0951EC, 100
DEFINE_PROPERTYKEY(PKEY_Contact_Department, 0xFC9F7306, 0xFF8F, 0x4D49, 0x9F, 0xB6, 0x3F, 0xFE, 0x5C, 0x09, 0x51, 0xEC, 100);

//  Name:     System.Contact.EmailAddress -- PKEY_Contact_EmailAddress
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: F8FA7FA3-D12B-4785-8A4E-691A94F7A3E7, 100
DEFINE_PROPERTYKEY(PKEY_Contact_EmailAddress, 0xF8FA7FA3, 0xD12B, 0x4785, 0x8A, 0x4E, 0x69, 0x1A, 0x94, 0xF7, 0xA3, 0xE7, 100);

//  Name:     System.Contact.EmailAddress2 -- PKEY_Contact_EmailAddress2
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 38965063-EDC8-4268-8491-B7723172CF29, 100
DEFINE_PROPERTYKEY(PKEY_Contact_EmailAddress2, 0x38965063, 0xEDC8, 0x4268, 0x84, 0x91, 0xB7, 0x72, 0x31, 0x72, 0xCF, 0x29, 100);

//  Name:     System.Contact.EmailAddress3 -- PKEY_Contact_EmailAddress3
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 644D37B4-E1B3-4BAD-B099-7E7C04966ACA, 100
DEFINE_PROPERTYKEY(PKEY_Contact_EmailAddress3, 0x644D37B4, 0xE1B3, 0x4BAD, 0xB0, 0x99, 0x7E, 0x7C, 0x04, 0x96, 0x6A, 0xCA, 100);

//  Name:     System.Contact.EmailAddresses -- PKEY_Contact_EmailAddresses
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: 84D8F337-981D-44B3-9615-C7596DBA17E3, 100
DEFINE_PROPERTYKEY(PKEY_Contact_EmailAddresses, 0x84D8F337, 0x981D, 0x44B3, 0x96, 0x15, 0xC7, 0x59, 0x6D, 0xBA, 0x17, 0xE3, 100);

//  Name:     System.Contact.EmailName -- PKEY_Contact_EmailName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: CC6F4F24-6083-4BD4-8754-674D0DE87AB8, 100
DEFINE_PROPERTYKEY(PKEY_Contact_EmailName, 0xCC6F4F24, 0x6083, 0x4BD4, 0x87, 0x54, 0x67, 0x4D, 0x0D, 0xE8, 0x7A, 0xB8, 100);

//  Name:     System.Contact.FileAsName -- PKEY_Contact_FileAsName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: F1A24AA7-9CA7-40F6-89EC-97DEF9FFE8DB, 100
DEFINE_PROPERTYKEY(PKEY_Contact_FileAsName, 0xF1A24AA7, 0x9CA7, 0x40F6, 0x89, 0xEC, 0x97, 0xDE, 0xF9, 0xFF, 0xE8, 0xDB, 100);

//  Name:     System.Contact.FirstName -- PKEY_Contact_FirstName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 14977844-6B49-4AAD-A714-A4513BF60460, 100
DEFINE_PROPERTYKEY(PKEY_Contact_FirstName, 0x14977844, 0x6B49, 0x4AAD, 0xA7, 0x14, 0xA4, 0x51, 0x3B, 0xF6, 0x04, 0x60, 100);

//  Name:     System.Contact.FullName -- PKEY_Contact_FullName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 635E9051-50A5-4BA2-B9DB-4ED056C77296, 100
DEFINE_PROPERTYKEY(PKEY_Contact_FullName, 0x635E9051, 0x50A5, 0x4BA2, 0xB9, 0xDB, 0x4E, 0xD0, 0x56, 0xC7, 0x72, 0x96, 100);

//  Name:     System.Contact.Gender -- PKEY_Contact_Gender
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 3C8CEE58-D4F0-4CF9-B756-4E5D24447BCD, 100
DEFINE_PROPERTYKEY(PKEY_Contact_Gender, 0x3C8CEE58, 0xD4F0, 0x4CF9, 0xB7, 0x56, 0x4E, 0x5D, 0x24, 0x44, 0x7B, 0xCD, 100);

//  Name:     System.Contact.Hobbies -- PKEY_Contact_Hobbies
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: 5DC2253F-5E11-4ADF-9CFE-910DD01E3E70, 100
DEFINE_PROPERTYKEY(PKEY_Contact_Hobbies, 0x5DC2253F, 0x5E11, 0x4ADF, 0x9C, 0xFE, 0x91, 0x0D, 0xD0, 0x1E, 0x3E, 0x70, 100);

//  Name:     System.Contact.HomeAddress -- PKEY_Contact_HomeAddress
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 98F98354-617A-46B8-8560-5B1B64BF1F89, 100
DEFINE_PROPERTYKEY(PKEY_Contact_HomeAddress, 0x98F98354, 0x617A, 0x46B8, 0x85, 0x60, 0x5B, 0x1B, 0x64, 0xBF, 0x1F, 0x89, 100);

//  Name:     System.Contact.HomeAddressCity -- PKEY_Contact_HomeAddressCity
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 176DC63C-2688-4E89-8143-A347800F25E9, 65
DEFINE_PROPERTYKEY(PKEY_Contact_HomeAddressCity, 0x176DC63C, 0x2688, 0x4E89, 0x81, 0x43, 0xA3, 0x47, 0x80, 0x0F, 0x25, 0xE9, 65);

//  Name:     System.Contact.HomeAddressCountry -- PKEY_Contact_HomeAddressCountry
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 08A65AA1-F4C9-43DD-9DDF-A33D8E7EAD85, 100
DEFINE_PROPERTYKEY(PKEY_Contact_HomeAddressCountry, 0x08A65AA1, 0xF4C9, 0x43DD, 0x9D, 0xDF, 0xA3, 0x3D, 0x8E, 0x7E, 0xAD, 0x85, 100);

//  Name:     System.Contact.HomeAddressPostalCode -- PKEY_Contact_HomeAddressPostalCode
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 8AFCC170-8A46-4B53-9EEE-90BAE7151E62, 100
DEFINE_PROPERTYKEY(PKEY_Contact_HomeAddressPostalCode, 0x8AFCC170, 0x8A46, 0x4B53, 0x9E, 0xEE, 0x90, 0xBA, 0xE7, 0x15, 0x1E, 0x62, 100);

//  Name:     System.Contact.HomeAddressPostOfficeBox -- PKEY_Contact_HomeAddressPostOfficeBox
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 7B9F6399-0A3F-4B12-89BD-4ADC51C918AF, 100
DEFINE_PROPERTYKEY(PKEY_Contact_HomeAddressPostOfficeBox, 0x7B9F6399, 0x0A3F, 0x4B12, 0x89, 0xBD, 0x4A, 0xDC, 0x51, 0xC9, 0x18, 0xAF, 100);

//  Name:     System.Contact.HomeAddressState -- PKEY_Contact_HomeAddressState
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: C89A23D0-7D6D-4EB8-87D4-776A82D493E5, 100
DEFINE_PROPERTYKEY(PKEY_Contact_HomeAddressState, 0xC89A23D0, 0x7D6D, 0x4EB8, 0x87, 0xD4, 0x77, 0x6A, 0x82, 0xD4, 0x93, 0xE5, 100);

//  Name:     System.Contact.HomeAddressStreet -- PKEY_Contact_HomeAddressStreet
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 0ADEF160-DB3F-4308-9A21-06237B16FA2A, 100
DEFINE_PROPERTYKEY(PKEY_Contact_HomeAddressStreet, 0x0ADEF160, 0xDB3F, 0x4308, 0x9A, 0x21, 0x06, 0x23, 0x7B, 0x16, 0xFA, 0x2A, 100);

//  Name:     System.Contact.HomeFaxNumber -- PKEY_Contact_HomeFaxNumber
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 660E04D6-81AB-4977-A09F-82313113AB26, 100
DEFINE_PROPERTYKEY(PKEY_Contact_HomeFaxNumber, 0x660E04D6, 0x81AB, 0x4977, 0xA0, 0x9F, 0x82, 0x31, 0x31, 0x13, 0xAB, 0x26, 100);

//  Name:     System.Contact.HomeTelephone -- PKEY_Contact_HomeTelephone
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 176DC63C-2688-4E89-8143-A347800F25E9, 20
DEFINE_PROPERTYKEY(PKEY_Contact_HomeTelephone, 0x176DC63C, 0x2688, 0x4E89, 0x81, 0x43, 0xA3, 0x47, 0x80, 0x0F, 0x25, 0xE9, 20);

//  Name:     System.Contact.IMAddress -- PKEY_Contact_IMAddress
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: D68DBD8A-3374-4B81-9972-3EC30682DB3D, 100
DEFINE_PROPERTYKEY(PKEY_Contact_IMAddress, 0xD68DBD8A, 0x3374, 0x4B81, 0x99, 0x72, 0x3E, 0xC3, 0x06, 0x82, 0xDB, 0x3D, 100);

//  Name:     System.Contact.Initials -- PKEY_Contact_Initials
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: F3D8F40D-50CB-44A2-9718-40CB9119495D, 100
DEFINE_PROPERTYKEY(PKEY_Contact_Initials, 0xF3D8F40D, 0x50CB, 0x44A2, 0x97, 0x18, 0x40, 0xCB, 0x91, 0x19, 0x49, 0x5D, 100);

//  Name:     System.Contact.JA.CompanyNamePhonetic -- PKEY_Contact_JA_CompanyNamePhonetic
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 897B3694-FE9E-43E6-8066-260F590C0100, 2
//  
//  
DEFINE_PROPERTYKEY(PKEY_Contact_JA_CompanyNamePhonetic, 0x897B3694, 0xFE9E, 0x43E6, 0x80, 0x66, 0x26, 0x0F, 0x59, 0x0C, 0x01, 0x00, 2);

//  Name:     System.Contact.JA.FirstNamePhonetic -- PKEY_Contact_JA_FirstNamePhonetic
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 897B3694-FE9E-43E6-8066-260F590C0100, 3
//  
//  
DEFINE_PROPERTYKEY(PKEY_Contact_JA_FirstNamePhonetic, 0x897B3694, 0xFE9E, 0x43E6, 0x80, 0x66, 0x26, 0x0F, 0x59, 0x0C, 0x01, 0x00, 3);

//  Name:     System.Contact.JA.LastNamePhonetic -- PKEY_Contact_JA_LastNamePhonetic
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 897B3694-FE9E-43E6-8066-260F590C0100, 4
//  
//  
DEFINE_PROPERTYKEY(PKEY_Contact_JA_LastNamePhonetic, 0x897B3694, 0xFE9E, 0x43E6, 0x80, 0x66, 0x26, 0x0F, 0x59, 0x0C, 0x01, 0x00, 4);

//  Name:     System.Contact.JobTitle -- PKEY_Contact_JobTitle
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 176DC63C-2688-4E89-8143-A347800F25E9, 6
DEFINE_PROPERTYKEY(PKEY_Contact_JobTitle, 0x176DC63C, 0x2688, 0x4E89, 0x81, 0x43, 0xA3, 0x47, 0x80, 0x0F, 0x25, 0xE9, 6);

//  Name:     System.Contact.Label -- PKEY_Contact_Label
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 97B0AD89-DF49-49CC-834E-660974FD755B, 100
DEFINE_PROPERTYKEY(PKEY_Contact_Label, 0x97B0AD89, 0xDF49, 0x49CC, 0x83, 0x4E, 0x66, 0x09, 0x74, 0xFD, 0x75, 0x5B, 100);

//  Name:     System.Contact.LastName -- PKEY_Contact_LastName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 8F367200-C270-457C-B1D4-E07C5BCD90C7, 100
DEFINE_PROPERTYKEY(PKEY_Contact_LastName, 0x8F367200, 0xC270, 0x457C, 0xB1, 0xD4, 0xE0, 0x7C, 0x5B, 0xCD, 0x90, 0xC7, 100);

//  Name:     System.Contact.MailingAddress -- PKEY_Contact_MailingAddress
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: C0AC206A-827E-4650-95AE-77E2BB74FCC9, 100
DEFINE_PROPERTYKEY(PKEY_Contact_MailingAddress, 0xC0AC206A, 0x827E, 0x4650, 0x95, 0xAE, 0x77, 0xE2, 0xBB, 0x74, 0xFC, 0xC9, 100);

//  Name:     System.Contact.MiddleName -- PKEY_Contact_MiddleName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 176DC63C-2688-4E89-8143-A347800F25E9, 71
DEFINE_PROPERTYKEY(PKEY_Contact_MiddleName, 0x176DC63C, 0x2688, 0x4E89, 0x81, 0x43, 0xA3, 0x47, 0x80, 0x0F, 0x25, 0xE9, 71);

//  Name:     System.Contact.MobileTelephone -- PKEY_Contact_MobileTelephone
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 176DC63C-2688-4E89-8143-A347800F25E9, 35
DEFINE_PROPERTYKEY(PKEY_Contact_MobileTelephone, 0x176DC63C, 0x2688, 0x4E89, 0x81, 0x43, 0xA3, 0x47, 0x80, 0x0F, 0x25, 0xE9, 35);

//  Name:     System.Contact.NickName -- PKEY_Contact_NickName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 176DC63C-2688-4E89-8143-A347800F25E9, 74
DEFINE_PROPERTYKEY(PKEY_Contact_NickName, 0x176DC63C, 0x2688, 0x4E89, 0x81, 0x43, 0xA3, 0x47, 0x80, 0x0F, 0x25, 0xE9, 74);

//  Name:     System.Contact.OfficeLocation -- PKEY_Contact_OfficeLocation
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 176DC63C-2688-4E89-8143-A347800F25E9, 7
DEFINE_PROPERTYKEY(PKEY_Contact_OfficeLocation, 0x176DC63C, 0x2688, 0x4E89, 0x81, 0x43, 0xA3, 0x47, 0x80, 0x0F, 0x25, 0xE9, 7);

//  Name:     System.Contact.OtherAddress -- PKEY_Contact_OtherAddress
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 508161FA-313B-43D5-83A1-C1ACCF68622C, 100
DEFINE_PROPERTYKEY(PKEY_Contact_OtherAddress, 0x508161FA, 0x313B, 0x43D5, 0x83, 0xA1, 0xC1, 0xAC, 0xCF, 0x68, 0x62, 0x2C, 100);

//  Name:     System.Contact.OtherAddressCity -- PKEY_Contact_OtherAddressCity
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 6E682923-7F7B-4F0C-A337-CFCA296687BF, 100
DEFINE_PROPERTYKEY(PKEY_Contact_OtherAddressCity, 0x6E682923, 0x7F7B, 0x4F0C, 0xA3, 0x37, 0xCF, 0xCA, 0x29, 0x66, 0x87, 0xBF, 100);

//  Name:     System.Contact.OtherAddressCountry -- PKEY_Contact_OtherAddressCountry
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 8F167568-0AAE-4322-8ED9-6055B7B0E398, 100
DEFINE_PROPERTYKEY(PKEY_Contact_OtherAddressCountry, 0x8F167568, 0x0AAE, 0x4322, 0x8E, 0xD9, 0x60, 0x55, 0xB7, 0xB0, 0xE3, 0x98, 100);

//  Name:     System.Contact.OtherAddressPostalCode -- PKEY_Contact_OtherAddressPostalCode
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 95C656C1-2ABF-4148-9ED3-9EC602E3B7CD, 100
DEFINE_PROPERTYKEY(PKEY_Contact_OtherAddressPostalCode, 0x95C656C1, 0x2ABF, 0x4148, 0x9E, 0xD3, 0x9E, 0xC6, 0x02, 0xE3, 0xB7, 0xCD, 100);

//  Name:     System.Contact.OtherAddressPostOfficeBox -- PKEY_Contact_OtherAddressPostOfficeBox
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 8B26EA41-058F-43F6-AECC-4035681CE977, 100
DEFINE_PROPERTYKEY(PKEY_Contact_OtherAddressPostOfficeBox, 0x8B26EA41, 0x058F, 0x43F6, 0xAE, 0xCC, 0x40, 0x35, 0x68, 0x1C, 0xE9, 0x77, 100);

//  Name:     System.Contact.OtherAddressState -- PKEY_Contact_OtherAddressState
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 71B377D6-E570-425F-A170-809FAE73E54E, 100
DEFINE_PROPERTYKEY(PKEY_Contact_OtherAddressState, 0x71B377D6, 0xE570, 0x425F, 0xA1, 0x70, 0x80, 0x9F, 0xAE, 0x73, 0xE5, 0x4E, 100);

//  Name:     System.Contact.OtherAddressStreet -- PKEY_Contact_OtherAddressStreet
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: FF962609-B7D6-4999-862D-95180D529AEA, 100
DEFINE_PROPERTYKEY(PKEY_Contact_OtherAddressStreet, 0xFF962609, 0xB7D6, 0x4999, 0x86, 0x2D, 0x95, 0x18, 0x0D, 0x52, 0x9A, 0xEA, 100);

//  Name:     System.Contact.PagerTelephone -- PKEY_Contact_PagerTelephone
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: D6304E01-F8F5-4F45-8B15-D024A6296789, 100
DEFINE_PROPERTYKEY(PKEY_Contact_PagerTelephone, 0xD6304E01, 0xF8F5, 0x4F45, 0x8B, 0x15, 0xD0, 0x24, 0xA6, 0x29, 0x67, 0x89, 100);

//  Name:     System.Contact.PersonalTitle -- PKEY_Contact_PersonalTitle
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 176DC63C-2688-4E89-8143-A347800F25E9, 69
DEFINE_PROPERTYKEY(PKEY_Contact_PersonalTitle, 0x176DC63C, 0x2688, 0x4E89, 0x81, 0x43, 0xA3, 0x47, 0x80, 0x0F, 0x25, 0xE9, 69);

//  Name:     System.Contact.PrimaryAddressCity -- PKEY_Contact_PrimaryAddressCity
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: C8EA94F0-A9E3-4969-A94B-9C62A95324E0, 100
DEFINE_PROPERTYKEY(PKEY_Contact_PrimaryAddressCity, 0xC8EA94F0, 0xA9E3, 0x4969, 0xA9, 0x4B, 0x9C, 0x62, 0xA9, 0x53, 0x24, 0xE0, 100);

//  Name:     System.Contact.PrimaryAddressCountry -- PKEY_Contact_PrimaryAddressCountry
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: E53D799D-0F3F-466E-B2FF-74634A3CB7A4, 100
DEFINE_PROPERTYKEY(PKEY_Contact_PrimaryAddressCountry, 0xE53D799D, 0x0F3F, 0x466E, 0xB2, 0xFF, 0x74, 0x63, 0x4A, 0x3C, 0xB7, 0xA4, 100);

//  Name:     System.Contact.PrimaryAddressPostalCode -- PKEY_Contact_PrimaryAddressPostalCode
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 18BBD425-ECFD-46EF-B612-7B4A6034EDA0, 100
DEFINE_PROPERTYKEY(PKEY_Contact_PrimaryAddressPostalCode, 0x18BBD425, 0xECFD, 0x46EF, 0xB6, 0x12, 0x7B, 0x4A, 0x60, 0x34, 0xED, 0xA0, 100);

//  Name:     System.Contact.PrimaryAddressPostOfficeBox -- PKEY_Contact_PrimaryAddressPostOfficeBox
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: DE5EF3C7-46E1-484E-9999-62C5308394C1, 100
DEFINE_PROPERTYKEY(PKEY_Contact_PrimaryAddressPostOfficeBox, 0xDE5EF3C7, 0x46E1, 0x484E, 0x99, 0x99, 0x62, 0xC5, 0x30, 0x83, 0x94, 0xC1, 100);

//  Name:     System.Contact.PrimaryAddressState -- PKEY_Contact_PrimaryAddressState
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: F1176DFE-7138-4640-8B4C-AE375DC70A6D, 100
DEFINE_PROPERTYKEY(PKEY_Contact_PrimaryAddressState, 0xF1176DFE, 0x7138, 0x4640, 0x8B, 0x4C, 0xAE, 0x37, 0x5D, 0xC7, 0x0A, 0x6D, 100);

//  Name:     System.Contact.PrimaryAddressStreet -- PKEY_Contact_PrimaryAddressStreet
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 63C25B20-96BE-488F-8788-C09C407AD812, 100
DEFINE_PROPERTYKEY(PKEY_Contact_PrimaryAddressStreet, 0x63C25B20, 0x96BE, 0x488F, 0x87, 0x88, 0xC0, 0x9C, 0x40, 0x7A, 0xD8, 0x12, 100);

//  Name:     System.Contact.PrimaryEmailAddress -- PKEY_Contact_PrimaryEmailAddress
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 176DC63C-2688-4E89-8143-A347800F25E9, 48
DEFINE_PROPERTYKEY(PKEY_Contact_PrimaryEmailAddress, 0x176DC63C, 0x2688, 0x4E89, 0x81, 0x43, 0xA3, 0x47, 0x80, 0x0F, 0x25, 0xE9, 48);

//  Name:     System.Contact.PrimaryTelephone -- PKEY_Contact_PrimaryTelephone
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 176DC63C-2688-4E89-8143-A347800F25E9, 25
DEFINE_PROPERTYKEY(PKEY_Contact_PrimaryTelephone, 0x176DC63C, 0x2688, 0x4E89, 0x81, 0x43, 0xA3, 0x47, 0x80, 0x0F, 0x25, 0xE9, 25);

//  Name:     System.Contact.Profession -- PKEY_Contact_Profession
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 7268AF55-1CE4-4F6E-A41F-B6E4EF10E4A9, 100
DEFINE_PROPERTYKEY(PKEY_Contact_Profession, 0x7268AF55, 0x1CE4, 0x4F6E, 0xA4, 0x1F, 0xB6, 0xE4, 0xEF, 0x10, 0xE4, 0xA9, 100);

//  Name:     System.Contact.SpouseName -- PKEY_Contact_SpouseName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 9D2408B6-3167-422B-82B0-F583B7A7CFE3, 100
DEFINE_PROPERTYKEY(PKEY_Contact_SpouseName, 0x9D2408B6, 0x3167, 0x422B, 0x82, 0xB0, 0xF5, 0x83, 0xB7, 0xA7, 0xCF, 0xE3, 100);

//  Name:     System.Contact.Suffix -- PKEY_Contact_Suffix
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 176DC63C-2688-4E89-8143-A347800F25E9, 73
DEFINE_PROPERTYKEY(PKEY_Contact_Suffix, 0x176DC63C, 0x2688, 0x4E89, 0x81, 0x43, 0xA3, 0x47, 0x80, 0x0F, 0x25, 0xE9, 73);

//  Name:     System.Contact.TelexNumber -- PKEY_Contact_TelexNumber
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: C554493C-C1F7-40C1-A76C-EF8C0614003E, 100
DEFINE_PROPERTYKEY(PKEY_Contact_TelexNumber, 0xC554493C, 0xC1F7, 0x40C1, 0xA7, 0x6C, 0xEF, 0x8C, 0x06, 0x14, 0x00, 0x3E, 100);

//  Name:     System.Contact.TTYTDDTelephone -- PKEY_Contact_TTYTDDTelephone
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: AAF16BAC-2B55-45E6-9F6D-415EB94910DF, 100
DEFINE_PROPERTYKEY(PKEY_Contact_TTYTDDTelephone, 0xAAF16BAC, 0x2B55, 0x45E6, 0x9F, 0x6D, 0x41, 0x5E, 0xB9, 0x49, 0x10, 0xDF, 100);

//  Name:     System.Contact.WebPage -- PKEY_Contact_WebPage
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 18
DEFINE_PROPERTYKEY(PKEY_Contact_WebPage, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 18);
 
//-----------------------------------------------------------------------------
// Core properties



//  Name:     System.AcquisitionID -- PKEY_AcquisitionID
//  Type:     Int32 -- VT_I4
//  FormatID: 65A98875-3C80-40AB-ABBC-EFDAF77DBEE2, 100
//
//  Hash to determine acquisition session.
DEFINE_PROPERTYKEY(PKEY_AcquisitionID, 0x65A98875, 0x3C80, 0x40AB, 0xAB, 0xBC, 0xEF, 0xDA, 0xF7, 0x7D, 0xBE, 0xE2, 100);

//  Name:     System.ApplicationName -- PKEY_ApplicationName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)  Legacy code may treat this as VT_LPSTR.
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 18 (PIDSI_APPNAME)
//
//  
DEFINE_PROPERTYKEY(PKEY_ApplicationName, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 18);

//  Name:     System.Author -- PKEY_Author
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)  Legacy code may treat this as VT_LPSTR.
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 4 (PIDSI_AUTHOR)
//
//  
DEFINE_PROPERTYKEY(PKEY_Author, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 4);

//  Name:     System.Capacity -- PKEY_Capacity
//  Type:     UInt64 -- VT_UI8
//  FormatID: (FMTID_Volume) 9B174B35-40FF-11D2-A27E-00C04FC30871, 3 (PID_VOLUME_CAPACITY)  (Filesystem Volume Properties)
//
//  The amount of total space in bytes.
DEFINE_PROPERTYKEY(PKEY_Capacity, 0x9B174B35, 0x40FF, 0x11D2, 0xA2, 0x7E, 0x00, 0xC0, 0x4F, 0xC3, 0x08, 0x71, 3);

//  Name:     System.Category -- PKEY_Category
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 2 (PIDDSI_CATEGORY)
//
//  Legacy code treats this as VT_LPSTR.
DEFINE_PROPERTYKEY(PKEY_Category, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 2);

//  Name:     System.Comment -- PKEY_Comment
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)  Legacy code may treat this as VT_LPSTR.
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 6 (PIDSI_COMMENTS)
//
//  Comments.
DEFINE_PROPERTYKEY(PKEY_Comment, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 6);

//  Name:     System.Company -- PKEY_Company
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 15 (PIDDSI_COMPANY)
//
//  The company or publisher.
DEFINE_PROPERTYKEY(PKEY_Company, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 15);

//  Name:     System.ComputerName -- PKEY_ComputerName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_ShellDetails) 28636AA6-953D-11D2-B5D6-00C04FD918D0, 5 (PID_COMPUTERNAME)
//
//  
DEFINE_PROPERTYKEY(PKEY_ComputerName, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 5);

//  Name:     System.ContainedItems -- PKEY_ContainedItems
//  Type:     Multivalue Guid -- VT_VECTOR | VT_CLSID  (For variants: VT_ARRAY | VT_CLSID)
//  FormatID: (FMTID_ShellDetails) 28636AA6-953D-11D2-B5D6-00C04FD918D0, 29
//  
//  The list of type of items, this item contains. For example, this item contains urls, attachments etc.
//  This is represented as a vector array of GUIDs where each GUID represents certain type.
DEFINE_PROPERTYKEY(PKEY_ContainedItems, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 29);

//  Name:     System.ContentStatus -- PKEY_ContentStatus
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 27
DEFINE_PROPERTYKEY(PKEY_ContentStatus, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 27);

//  Name:     System.ContentType -- PKEY_ContentType
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 26
DEFINE_PROPERTYKEY(PKEY_ContentType, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 26);

//  Name:     System.Copyright -- PKEY_Copyright
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 11 (PIDMSI_COPYRIGHT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Copyright, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 11);

//  Name:     System.DateAccessed -- PKEY_DateAccessed
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_Storage) B725F130-47EF-101A-A5F1-02608C9EEBAC, 16 (PID_STG_ACCESSTIME)
//
//  The time of the last access to the item.  The Indexing Service friendly name is 'access'.
DEFINE_PROPERTYKEY(PKEY_DateAccessed, 0xB725F130, 0x47EF, 0x101A, 0xA5, 0xF1, 0x02, 0x60, 0x8C, 0x9E, 0xEB, 0xAC, 16);

//  Name:     System.DateAcquired -- PKEY_DateAcquired
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: 2CBAA8F5-D81F-47CA-B17A-F8D822300131, 100
//  
//  The time the file entered the system via acquisition.  This is not the same as System.DateImported.
//  Examples are when pictures are acquired from a camera, or when music is purchased online.
DEFINE_PROPERTYKEY(PKEY_DateAcquired, 0x2CBAA8F5, 0xD81F, 0x47CA, 0xB1, 0x7A, 0xF8, 0xD8, 0x22, 0x30, 0x01, 0x31, 100);

//  Name:     System.DateArchived -- PKEY_DateArchived
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: 43F8D7B7-A444-4F87-9383-52271C9B915C, 100
DEFINE_PROPERTYKEY(PKEY_DateArchived, 0x43F8D7B7, 0xA444, 0x4F87, 0x93, 0x83, 0x52, 0x27, 0x1C, 0x9B, 0x91, 0x5C, 100);

//  Name:     System.DateCompleted -- PKEY_DateCompleted
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: 72FAB781-ACDA-43E5-B155-B2434F85E678, 100
DEFINE_PROPERTYKEY(PKEY_DateCompleted, 0x72FAB781, 0xACDA, 0x43E5, 0xB1, 0x55, 0xB2, 0x43, 0x4F, 0x85, 0xE6, 0x78, 100);

//  Name:     System.DateCreated -- PKEY_DateCreated
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_Storage) B725F130-47EF-101A-A5F1-02608C9EEBAC, 15 (PID_STG_CREATETIME)
//
//  The date and time the item was created. The Indexing Service friendly name is 'create'.
DEFINE_PROPERTYKEY(PKEY_DateCreated, 0xB725F130, 0x47EF, 0x101A, 0xA5, 0xF1, 0x02, 0x60, 0x8C, 0x9E, 0xEB, 0xAC, 15);

//  Name:     System.DateImported -- PKEY_DateImported
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 18258
//
//  The time the file is imported into a separate database.  This is not the same as System.DateAcquired.  (Eg, 2003:05:22 13:55:04)
DEFINE_PROPERTYKEY(PKEY_DateImported, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 18258);

//  Name:     System.DateModified -- PKEY_DateModified
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_Storage) B725F130-47EF-101A-A5F1-02608C9EEBAC, 14 (PID_STG_WRITETIME)
//
//  The date and time of the last write to the item. The Indexing Service friendly name is 'write'.
DEFINE_PROPERTYKEY(PKEY_DateModified, 0xB725F130, 0x47EF, 0x101A, 0xA5, 0xF1, 0x02, 0x60, 0x8C, 0x9E, 0xEB, 0xAC, 14);

//  Name:     System.DueDate -- PKEY_DueDate
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: 3F8472B5-E0AF-4DB2-8071-C53FE76AE7CE, 100
DEFINE_PROPERTYKEY(PKEY_DueDate, 0x3F8472B5, 0xE0AF, 0x4DB2, 0x80, 0x71, 0xC5, 0x3F, 0xE7, 0x6A, 0xE7, 0xCE, 100);

//  Name:     System.EndDate -- PKEY_EndDate
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: C75FAA05-96FD-49E7-9CB4-9F601082D553, 100
DEFINE_PROPERTYKEY(PKEY_EndDate, 0xC75FAA05, 0x96FD, 0x49E7, 0x9C, 0xB4, 0x9F, 0x60, 0x10, 0x82, 0xD5, 0x53, 100);

//  Name:     System.FileAllocationSize -- PKEY_FileAllocationSize
//  Type:     UInt64 -- VT_UI8
//  FormatID: (FMTID_Storage) B725F130-47EF-101A-A5F1-02608C9EEBAC, 18 (PID_STG_ALLOCSIZE)
//
//  
DEFINE_PROPERTYKEY(PKEY_FileAllocationSize, 0xB725F130, 0x47EF, 0x101A, 0xA5, 0xF1, 0x02, 0x60, 0x8C, 0x9E, 0xEB, 0xAC, 18);

//  Name:     System.FileAttributes -- PKEY_FileAttributes
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_Storage) B725F130-47EF-101A-A5F1-02608C9EEBAC, 13 (PID_STG_ATTRIBUTES)
//  
//  This is the WIN32_FIND_DATA dwFileAttributes for the file-based item.
DEFINE_PROPERTYKEY(PKEY_FileAttributes, 0xB725F130, 0x47EF, 0x101A, 0xA5, 0xF1, 0x02, 0x60, 0x8C, 0x9E, 0xEB, 0xAC, 13);

//  Name:     System.FileCount -- PKEY_FileCount
//  Type:     UInt64 -- VT_UI8
//  FormatID: (FMTID_ShellDetails) 28636AA6-953D-11D2-B5D6-00C04FD918D0, 12
//
//  
DEFINE_PROPERTYKEY(PKEY_FileCount, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 12);

//  Name:     System.FileDescription -- PKEY_FileDescription
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSFMTID_VERSION) 0CEF7D53-FA64-11D1-A203-0000F81FEDEE, 3 (PIDVSI_FileDescription)
//  
//  This is a user-friendly description of the file.
DEFINE_PROPERTYKEY(PKEY_FileDescription, 0x0CEF7D53, 0xFA64, 0x11D1, 0xA2, 0x03, 0x00, 0x00, 0xF8, 0x1F, 0xED, 0xEE, 3);

//  Name:     System.FileExtension -- PKEY_FileExtension
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: E4F10A3C-49E6-405D-8288-A23BD4EEAA6C, 100
//  
//  This is the file extension of the file based item, including the leading period.  
//  
//  If System.FileName is VT_EMPTY, then this property should be too.  Otherwise, it should be derived
//  appropriately by the data source from System.FileName.  If System.FileName does not have a file 
//  extension, this value should be VT_EMPTY.
//  
//  To obtain the type of any item (including an item that is not a file), use System.ItemType.
//  
//  Example values:
//  
//      If the path is...                     The property value is...
//      -----------------                     ------------------------
//      "c:\foo\bar\hello.txt"                ".txt"
//      "\\server\share\mydir\goodnews.doc"   ".doc"
//      "\\server\share\numbers.xls"          ".xls"
//      "\\server\share\folder"               VT_EMPTY
//      "c:\foo\MyFolder"                     VT_EMPTY
//      [desktop]                             VT_EMPTY
DEFINE_PROPERTYKEY(PKEY_FileExtension, 0xE4F10A3C, 0x49E6, 0x405D, 0x82, 0x88, 0xA2, 0x3B, 0xD4, 0xEE, 0xAA, 0x6C, 100);

//  Name:     System.FileFRN -- PKEY_FileFRN
//  Type:     UInt64 -- VT_UI8
//  FormatID: (FMTID_Storage) B725F130-47EF-101A-A5F1-02608C9EEBAC, 21 (PID_STG_FRN)
//  
//  This is the unique file ID, also known as the File Reference Number. For a given file, this is the same value
//  as is found in the structure variable FILE_ID_BOTH_DIR_INFO.FileId, via GetFileInformationByHandleEx().
DEFINE_PROPERTYKEY(PKEY_FileFRN, 0xB725F130, 0x47EF, 0x101A, 0xA5, 0xF1, 0x02, 0x60, 0x8C, 0x9E, 0xEB, 0xAC, 21);

//  Name:     System.FileName -- PKEY_FileName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 41CF5AE0-F75A-4806-BD87-59C7D9248EB9, 100
//  
//  This is the file name (including extension) of the file.
//  
//  It is possible that the item might not exist on a filesystem (ie, it may not be opened 
//  using CreateFile).  Nonetheless, if the item is represented as a file from the logical sense 
//  (and its name follows standard Win32 file-naming syntax), then the data source should emit this property.
//  
//  If an item is not a file, then the value for this property is VT_EMPTY.  See 
//  System.ItemNameDisplay.
//  
//  This has the same value as System.ParsingName for items that are provided by the Shell's file folder.
//  
//  Example values:
//  
//      If the path is...                     The property value is...
//      -----------------                     ------------------------
//      "c:\foo\bar\hello.txt"                "hello.txt"
//      "\\server\share\mydir\goodnews.doc"   "goodnews.doc"
//      "\\server\share\numbers.xls"          "numbers.xls"
//      "c:\foo\MyFolder"                     "MyFolder"
//      (email message)                       VT_EMPTY
//      (song on portable device)             "song.wma"
DEFINE_PROPERTYKEY(PKEY_FileName, 0x41CF5AE0, 0xF75A, 0x4806, 0xBD, 0x87, 0x59, 0xC7, 0xD9, 0x24, 0x8E, 0xB9, 100);

//  Name:     System.FileOwner -- PKEY_FileOwner
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_Misc) 9B174B34-40FF-11D2-A27E-00C04FC30871, 4 (PID_MISC_OWNER)
//  
//  This is the owner of the file, according to the file system.
DEFINE_PROPERTYKEY(PKEY_FileOwner, 0x9B174B34, 0x40FF, 0x11D2, 0xA2, 0x7E, 0x00, 0xC0, 0x4F, 0xC3, 0x08, 0x71, 4);

//  Name:     System.FileVersion -- PKEY_FileVersion
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSFMTID_VERSION) 0CEF7D53-FA64-11D1-A203-0000F81FEDEE, 4 (PIDVSI_FileVersion)
//
//  
DEFINE_PROPERTYKEY(PKEY_FileVersion, 0x0CEF7D53, 0xFA64, 0x11D1, 0xA2, 0x03, 0x00, 0x00, 0xF8, 0x1F, 0xED, 0xEE, 4);

//  Name:     System.FindData -- PKEY_FindData
//  Type:     Buffer -- VT_VECTOR | VT_UI1  (For variants: VT_ARRAY | VT_UI1)
//  FormatID: (FMTID_ShellDetails) 28636AA6-953D-11D2-B5D6-00C04FD918D0, 0 (PID_FINDDATA)
//
//  WIN32_FIND_DATAW in buffer of bytes.
DEFINE_PROPERTYKEY(PKEY_FindData, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 0);

//  Name:     System.FlagColor -- PKEY_FlagColor
//  Type:     UInt16 -- VT_UI2
//  FormatID: 67DF94DE-0CA7-4D6F-B792-053A3E4F03CF, 100
//
//  
DEFINE_PROPERTYKEY(PKEY_FlagColor, 0x67DF94DE, 0x0CA7, 0x4D6F, 0xB7, 0x92, 0x05, 0x3A, 0x3E, 0x4F, 0x03, 0xCF, 100);

// Possible discrete values for PKEY_FlagColor are:
#define FLAGCOLOR_PURPLE                    1u
#define FLAGCOLOR_ORANGE                    2u
#define FLAGCOLOR_GREEN                     3u
#define FLAGCOLOR_YELLOW                    4u
#define FLAGCOLOR_BLUE                      5u
#define FLAGCOLOR_RED                       6u

//  Name:     System.FlagColorText -- PKEY_FlagColorText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 45EAE747-8E2A-40AE-8CBF-CA52ABA6152A, 100
//  
//  This is the user-friendly form of System.FlagColor.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_FlagColorText, 0x45EAE747, 0x8E2A, 0x40AE, 0x8C, 0xBF, 0xCA, 0x52, 0xAB, 0xA6, 0x15, 0x2A, 100);

//  Name:     System.FlagStatus -- PKEY_FlagStatus
//  Type:     Int32 -- VT_I4
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 12
//
//  Status of Flag.  Values: (0=none 1=white 2=Red).  cdoPR_FLAG_STATUS
DEFINE_PROPERTYKEY(PKEY_FlagStatus, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 12);

// Possible discrete values for PKEY_FlagStatus are:
#define FLAGSTATUS_NOTFLAGGED               0l
#define FLAGSTATUS_COMPLETED                1l
#define FLAGSTATUS_FOLLOWUP                 2l

//  Name:     System.FlagStatusText -- PKEY_FlagStatusText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: DC54FD2E-189D-4871-AA01-08C2F57A4ABC, 100
//  
//  This is the user-friendly form of System.FlagStatus.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_FlagStatusText, 0xDC54FD2E, 0x189D, 0x4871, 0xAA, 0x01, 0x08, 0xC2, 0xF5, 0x7A, 0x4A, 0xBC, 100);

//  Name:     System.FreeSpace -- PKEY_FreeSpace
//  Type:     UInt64 -- VT_UI8
//  FormatID: (FMTID_Volume) 9B174B35-40FF-11D2-A27E-00C04FC30871, 2 (PID_VOLUME_FREE)  (Filesystem Volume Properties)
//
//  The amount of free space in bytes.
DEFINE_PROPERTYKEY(PKEY_FreeSpace, 0x9B174B35, 0x40FF, 0x11D2, 0xA2, 0x7E, 0x00, 0xC0, 0x4F, 0xC3, 0x08, 0x71, 2);

//  Name:     System.Identity -- PKEY_Identity
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: A26F4AFC-7346-4299-BE47-EB1AE613139F, 100
DEFINE_PROPERTYKEY(PKEY_Identity, 0xA26F4AFC, 0x7346, 0x4299, 0xBE, 0x47, 0xEB, 0x1A, 0xE6, 0x13, 0x13, 0x9F, 100);

//  Name:     System.Importance -- PKEY_Importance
//  Type:     Int32 -- VT_I4
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 11
DEFINE_PROPERTYKEY(PKEY_Importance, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 11);

// Possible range of values for PKEY_Importance are:
#define IMPORTANCE_LOW_MIN                  0l
#define IMPORTANCE_LOW_SET                  1l
#define IMPORTANCE_LOW_MAX                  1l

#define IMPORTANCE_NORMAL_MIN               2l
#define IMPORTANCE_NORMAL_SET               3l
#define IMPORTANCE_NORMAL_MAX               4l

#define IMPORTANCE_HIGH_MIN                 5l
#define IMPORTANCE_HIGH_SET                 5l
#define IMPORTANCE_HIGH_MAX                 5l


//  Name:     System.ImportanceText -- PKEY_ImportanceText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: A3B29791-7713-4E1D-BB40-17DB85F01831, 100
//  
//  This is the user-friendly form of System.Importance.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_ImportanceText, 0xA3B29791, 0x7713, 0x4E1D, 0xBB, 0x40, 0x17, 0xDB, 0x85, 0xF0, 0x18, 0x31, 100);

//  Name:     System.IsAttachment -- PKEY_IsAttachment
//  Type:     Boolean -- VT_BOOL
//  FormatID: F23F425C-71A1-4FA8-922F-678EA4A60408, 100
//
//  Identifies if this item is an attachment.
DEFINE_PROPERTYKEY(PKEY_IsAttachment, 0xF23F425C, 0x71A1, 0x4FA8, 0x92, 0x2F, 0x67, 0x8E, 0xA4, 0xA6, 0x04, 0x08, 100);

//  Name:     System.IsDeleted -- PKEY_IsDeleted
//  Type:     Boolean -- VT_BOOL
//  FormatID: 5CDA5FC8-33EE-4FF3-9094-AE7BD8868C4D, 100
DEFINE_PROPERTYKEY(PKEY_IsDeleted, 0x5CDA5FC8, 0x33EE, 0x4FF3, 0x90, 0x94, 0xAE, 0x7B, 0xD8, 0x86, 0x8C, 0x4D, 100);

//  Name:     System.IsFlagged -- PKEY_IsFlagged
//  Type:     Boolean -- VT_BOOL
//  FormatID: 5DA84765-E3FF-4278-86B0-A27967FBDD03, 100
DEFINE_PROPERTYKEY(PKEY_IsFlagged, 0x5DA84765, 0xE3FF, 0x4278, 0x86, 0xB0, 0xA2, 0x79, 0x67, 0xFB, 0xDD, 0x03, 100);

//  Name:     System.IsFlaggedComplete -- PKEY_IsFlaggedComplete
//  Type:     Boolean -- VT_BOOL
//  FormatID: A6F360D2-55F9-48DE-B909-620E090A647C, 100
DEFINE_PROPERTYKEY(PKEY_IsFlaggedComplete, 0xA6F360D2, 0x55F9, 0x48DE, 0xB9, 0x09, 0x62, 0x0E, 0x09, 0x0A, 0x64, 0x7C, 100);

//  Name:     System.IsIncomplete -- PKEY_IsIncomplete
//  Type:     Boolean -- VT_BOOL
//  FormatID: 346C8BD1-2E6A-4C45-89A4-61B78E8E700F, 100
//
//  Identifies if the message was not completely received for some error condition.
DEFINE_PROPERTYKEY(PKEY_IsIncomplete, 0x346C8BD1, 0x2E6A, 0x4C45, 0x89, 0xA4, 0x61, 0xB7, 0x8E, 0x8E, 0x70, 0x0F, 100);

//  Name:     System.IsRead -- PKEY_IsRead
//  Type:     Boolean -- VT_BOOL
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 10
//
//  Has the item been read?
DEFINE_PROPERTYKEY(PKEY_IsRead, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 10);

//  Name:     System.IsSendToTarget -- PKEY_IsSendToTarget
//  Type:     Boolean -- VT_BOOL
//  FormatID: (FMTID_ShellDetails) 28636AA6-953D-11D2-B5D6-00C04FD918D0, 33
//
//  Provided by certain shell folders. Return TRUE if the folder is a valid Send To target.
DEFINE_PROPERTYKEY(PKEY_IsSendToTarget, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 33);

//  Name:     System.IsShared -- PKEY_IsShared
//  Type:     Boolean -- VT_BOOL
//  FormatID: EF884C5B-2BFE-41BB-AAE5-76EEDF4F9902, 100
//
//  Is this item shared?
DEFINE_PROPERTYKEY(PKEY_IsShared, 0xEF884C5B, 0x2BFE, 0x41BB, 0xAA, 0xE5, 0x76, 0xEE, 0xDF, 0x4F, 0x99, 0x02, 100);

//  Name:     System.ItemAuthors -- PKEY_ItemAuthors
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: D0A04F0A-462A-48A4-BB2F-3706E88DBD7D, 100
//  
//  This is the generic list of authors associated with an item. 
//  
//  For example, the artist name for a track is the item author.
DEFINE_PROPERTYKEY(PKEY_ItemAuthors, 0xD0A04F0A, 0x462A, 0x48A4, 0xBB, 0x2F, 0x37, 0x06, 0xE8, 0x8D, 0xBD, 0x7D, 100);

//  Name:     System.ItemDate -- PKEY_ItemDate
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: F7DB74B4-4287-4103-AFBA-F1B13DCD75CF, 100
//  
//  This is the main date for an item. The date of interest. 
//  
//  For example, for photos this maps to System.Photo.DateTaken.
DEFINE_PROPERTYKEY(PKEY_ItemDate, 0xF7DB74B4, 0x4287, 0x4103, 0xAF, 0xBA, 0xF1, 0xB1, 0x3D, 0xCD, 0x75, 0xCF, 100);

//  Name:     System.ItemFolderNameDisplay -- PKEY_ItemFolderNameDisplay
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_Storage) B725F130-47EF-101A-A5F1-02608C9EEBAC, 2 (PID_STG_DIRECTORY)
//  
//  This is the user-friendly display name of the parent folder of an item.
//  
//  If System.ItemFolderPathDisplay is VT_EMPTY, then this property should be too.  Otherwise, it 
//  should be derived appropriately by the data source from System.ItemFolderPathDisplay.
//  
//  Example values:
//  
//      If the path is...                     The property value is...
//      -----------------                     ------------------------
//      "c:\foo\bar\hello.txt"                "bar"
//      "\\server\share\mydir\goodnews.doc"   "mydir"
//      "\\server\share\numbers.xls"          "share"
//      "c:\foo\MyFolder"                     "foo"
//      "/Mailbox Account/Inbox/'Re: Hello!'" "Inbox"
DEFINE_PROPERTYKEY(PKEY_ItemFolderNameDisplay, 0xB725F130, 0x47EF, 0x101A, 0xA5, 0xF1, 0x02, 0x60, 0x8C, 0x9E, 0xEB, 0xAC, 2);

//  Name:     System.ItemFolderPathDisplay -- PKEY_ItemFolderPathDisplay
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 6
//  
//  This is the user-friendly display path of the parent folder of an item.
//  
//  If System.ItemPathDisplay is VT_EMPTY, then this property should be too.  Otherwise, it should 
//  be derived appropriately by the data source from System.ItemPathDisplay.
//  
//  Example values:
//  
//      If the path is...                     The property value is...
//      -----------------                     ------------------------
//      "c:\foo\bar\hello.txt"                "c:\foo\bar"
//      "\\server\share\mydir\goodnews.doc"   "\\server\share\mydir"
//      "\\server\share\numbers.xls"          "\\server\share"
//      "c:\foo\MyFolder"                     "c:\foo"
//      "/Mailbox Account/Inbox/'Re: Hello!'" "/Mailbox Account/Inbox"
DEFINE_PROPERTYKEY(PKEY_ItemFolderPathDisplay, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 6);

//  Name:     System.ItemFolderPathDisplayNarrow -- PKEY_ItemFolderPathDisplayNarrow
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: DABD30ED-0043-4789-A7F8-D013A4736622, 100
//  
//  This is the user-friendly display path of the parent folder of an item.  The format of the string
//  should be tailored such that the folder name comes first, to optimize for a narrow viewing column.
//  
//  If the folder is a file folder, the value includes localized names if they are present.
//  
//  If System.ItemFolderPathDisplay is VT_EMPTY, then this property should be too.  Otherwise, it should
//  be derived appropriately by the data source from System.ItemFolderPathDisplay.
//  
//  Example values:
//  
//      If the path is...                     The property value is...
//      -----------------                     ------------------------
//      "c:\foo\bar\hello.txt"                "bar (c:\foo)"
//      "\\server\share\mydir\goodnews.doc"   "mydir (\\server\share)"
//      "\\server\share\numbers.xls"          "share (\\server)"
//      "c:\foo\MyFolder"                     "foo (c:\)"
//      "/Mailbox Account/Inbox/'Re: Hello!'" "Inbox (/Mailbox Account)"
DEFINE_PROPERTYKEY(PKEY_ItemFolderPathDisplayNarrow, 0xDABD30ED, 0x0043, 0x4789, 0xA7, 0xF8, 0xD0, 0x13, 0xA4, 0x73, 0x66, 0x22, 100);

//  Name:     System.ItemName -- PKEY_ItemName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 6B8DA074-3B5C-43BC-886F-0A2CDCE00B6F, 100
//  
//  This is the base-name of the System.ItemNameDisplay.
//  
//  If the item is a file this property
//  includes the extension in all cases, and will be localized if a localized name is available.
//  
//  If the item is a message, then the value of this property does not include the forwarding or
//  reply prefixes (see System.ItemNamePrefix).
DEFINE_PROPERTYKEY(PKEY_ItemName, 0x6B8DA074, 0x3B5C, 0x43BC, 0x88, 0x6F, 0x0A, 0x2C, 0xDC, 0xE0, 0x0B, 0x6F, 100);

//  Name:     System.ItemNameDisplay -- PKEY_ItemNameDisplay
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_Storage) B725F130-47EF-101A-A5F1-02608C9EEBAC, 10 (PID_STG_NAME)
//  
//  This is the display name in "most complete" form.  This is the best effort unique representation
//  of the name of an item that makes sense for end users to read.  It is the concatentation of
//  System.ItemNamePrefix and System.ItemName.
//  
//  If the item is a file this property
//  includes the extension in all cases, and will be localized if a localized name is available.
//  
//  There are acceptable cases when System.FileName is not VT_EMPTY, yet the value of this property 
//  is completely different.  Email messages are a key example.  If the item is an email message, 
//  the item name is likely the subject.  In that case, the value must be the concatenation of the
//  System.ItemNamePrefix and System.ItemName.  Since the value of System.ItemNamePrefix excludes
//  any trailing whitespace, the concatenation must include a whitespace when generating System.ItemNameDisplay.
//  
//  Note that this property is not guaranteed to be unique, but the idea is to promote the most likely
//  candidate that can be unique and also makes sense for end users. For example, for documents, you
//  might think about using System.Title as the System.ItemNameDisplay, but in practice the title of
//  the documents may not be useful or unique enough to be of value as the sole System.ItemNameDisplay.  
//  Instead, providing the value of System.FileName as the value of System.ItemNameDisplay is a better
//  candidate.  In Windows Mail, the emails are stored in the file system as .eml files and the 
//  System.FileName for those files are not human-friendly as they contain GUIDs. In this example, 
//  promoting System.Subject as System.ItemNameDisplay makes more sense.
//  
//  Compatibility notes:
//  
//  Shell folder implementations on Vista: use PKEY_ItemNameDisplay for the name column when
//  you want Explorer to call ISF::GetDisplayNameOf(SHGDN_NORMAL) to get the value of the name. Use
//  another PKEY (like PKEY_ItemName) when you want Explorer to call either the folder's property store or
//  ISF2::GetDetailsEx in order to get the value of the name.
//  
//  Shell folder implementations on XP: the first column needs to be the name column, and Explorer
//  will call ISF::GetDisplayNameOf to get the value of the name.  The PKEY/SCID does not matter.
//  
//  Example values:
//  
//      File:          "hello.txt"
//      Message:       "Re: Let's talk about Tom's argyle socks!"
//      Device folder: "song.wma"
//      Folder:        "Documents"
DEFINE_PROPERTYKEY(PKEY_ItemNameDisplay, 0xB725F130, 0x47EF, 0x101A, 0xA5, 0xF1, 0x02, 0x60, 0x8C, 0x9E, 0xEB, 0xAC, 10);

//  Name:     System.ItemNamePrefix -- PKEY_ItemNamePrefix
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: D7313FF1-A77A-401C-8C99-3DBDD68ADD36, 100
//  
//  This is the prefix of an item, used for email messages.
//  where the subject begins with "Re:" which is the prefix.
//  
//  If the item is a file, then the value of this property is VT_EMPTY.
//  
//  If the item is a message, then the value of this property is the forwarding or reply 
//  prefixes (including delimiting colon, but no whitespace), or VT_EMPTY if there is no prefix.
//  
//  Example values:
//  
//  System.ItemNamePrefix    System.ItemName      System.ItemNameDisplay
//  ---------------------    -------------------  ----------------------
//  VT_EMPTY                 "Great day"          "Great day"
//  "Re:"                    "Great day"          "Re: Great day"
//  "Fwd: "                  "Monthly budget"     "Fwd: Monthly budget"
//  VT_EMPTY                 "accounts.xls"       "accounts.xls"
DEFINE_PROPERTYKEY(PKEY_ItemNamePrefix, 0xD7313FF1, 0xA77A, 0x401C, 0x8C, 0x99, 0x3D, 0xBD, 0xD6, 0x8A, 0xDD, 0x36, 100);

//  Name:     System.ItemParticipants -- PKEY_ItemParticipants
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: D4D0AA16-9948-41A4-AA85-D97FF9646993, 100
//  
//  This is the generic list of people associated with an item and who contributed 
//  to the item. 
//  
//  For example, this is the combination of people in the To list, Cc list and 
//  sender of an email message.
DEFINE_PROPERTYKEY(PKEY_ItemParticipants, 0xD4D0AA16, 0x9948, 0x41A4, 0xAA, 0x85, 0xD9, 0x7F, 0xF9, 0x64, 0x69, 0x93, 100);

//  Name:     System.ItemPathDisplay -- PKEY_ItemPathDisplay
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 7
//  
//  This is the user-friendly display path to the item.
//  
//  If the item is a file or folder this property
//  includes the extension in all cases, and will be localized if a localized name is available.
//  
//  For other items,this is the user-friendly equivalent, assuming the item exists in hierarchical storage.
//  
//  Unlike System.ItemUrl, this property value does not include the URL scheme.
//  
//  To parse an item path, use System.ItemUrl or System.ParsingPath.  To reference shell 
//  namespace items using shell APIs, use System.ParsingPath.
//  
//  Example values:
//  
//      If the path is...                     The property value is...
//      -----------------                     ------------------------
//      "c:\foo\bar\hello.txt"                "c:\foo\bar\hello.txt"
//      "\\server\share\mydir\goodnews.doc"   "\\server\share\mydir\goodnews.doc"
//      "\\server\share\numbers.xls"          "\\server\share\numbers.xls"
//      "c:\foo\MyFolder"                     "c:\foo\MyFolder"
//      "/Mailbox Account/Inbox/'Re: Hello!'" "/Mailbox Account/Inbox/'Re: Hello!'"
DEFINE_PROPERTYKEY(PKEY_ItemPathDisplay, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 7);

//  Name:     System.ItemPathDisplayNarrow -- PKEY_ItemPathDisplayNarrow
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_ShellDetails) 28636AA6-953D-11D2-B5D6-00C04FD918D0, 8
//  
//  This is the user-friendly display path to the item. The format of the string should be 
//  tailored such that the name comes first, to optimize for a narrow viewing column.
//  
//  If the item is a file, the value excludes the file extension, and includes localized names if they are present.
//  If the item is a message, the value includes the System.ItemNamePrefix.
//  
//  To parse an item path, use System.ItemUrl or System.ParsingPath.
//  
//  Example values:
//  
//      If the path is...                     The property value is...
//      -----------------                     ------------------------
//      "c:\foo\bar\hello.txt"                "hello (c:\foo\bar)"
//      "\\server\share\mydir\goodnews.doc"   "goodnews (\\server\share\mydir)"
//      "\\server\share\folder"               "folder (\\server\share)"
//      "c:\foo\MyFolder"                     "MyFolder (c:\foo)"
//      "/Mailbox Account/Inbox/'Re: Hello!'" "Re: Hello! (/Mailbox Account/Inbox)"
DEFINE_PROPERTYKEY(PKEY_ItemPathDisplayNarrow, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 8);

//  Name:     System.ItemType -- PKEY_ItemType
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_ShellDetails) 28636AA6-953D-11D2-B5D6-00C04FD918D0, 11
//  
//  This is the canonical type of the item and is intended to be programmatically
//  parsed.
//  
//  If there is no canonical type, the value is VT_EMPTY.
//  
//  If the item is a file (ie, System.FileName is not VT_EMPTY), the value is the same as
//  System.FileExtension.
//  
//  Use System.ItemTypeText when you want to display the type to end users in a view.  (If
//   the item is a file, passing the System.ItemType value to PSFormatForDisplay will
//   result in the same value as System.ItemTypeText.)
//  
//  Example values:
//  
//      If the path is...                     The property value is...
//      -----------------                     ------------------------
//      "c:\foo\bar\hello.txt"                ".txt"
//      "\\server\share\mydir\goodnews.doc"   ".doc"
//      "\\server\share\folder"               "Directory"
//      "c:\foo\MyFolder"                     "Directory"
//      [desktop]                             "Folder"
//      "/Mailbox Account/Inbox/'Re: Hello!'" "MAPI/IPM.Message"
DEFINE_PROPERTYKEY(PKEY_ItemType, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 11);

//  Name:     System.ItemTypeText -- PKEY_ItemTypeText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_Storage) B725F130-47EF-101A-A5F1-02608C9EEBAC, 4 (PID_STG_STORAGETYPE)
//  
//  This is the user friendly type name of the item.  This is not intended to be
//  programmatically parsed.
//  
//  If System.ItemType is VT_EMPTY, the value of this property is also VT_EMPTY.
//  
//  If the item is a file, the value of this property is the same as if you passed the 
//  file's System.ItemType value to PSFormatForDisplay.
//  
//  This property should not be confused with System.Kind, where System.Kind is a high-level
//  user friendly kind name. For example, for a document, System.Kind = "Document" and 
//  System.Item.Type = ".doc" and System.Item.TypeText = "Microsoft Word Document"
//  
//  Example values:
//  
//      If the path is...                     The property value is...
//      -----------------                     ------------------------
//      "c:\foo\bar\hello.txt"                "Text File"
//      "\\server\share\mydir\goodnews.doc"   "Microsoft Word Document"
//      "\\server\share\folder"               "File Folder"
//      "c:\foo\MyFolder"                     "File Folder"
//      "/Mailbox Account/Inbox/'Re: Hello!'" "Outlook E-Mail Message"
DEFINE_PROPERTYKEY(PKEY_ItemTypeText, 0xB725F130, 0x47EF, 0x101A, 0xA5, 0xF1, 0x02, 0x60, 0x8C, 0x9E, 0xEB, 0xAC, 4);

//  Name:     System.ItemUrl -- PKEY_ItemUrl
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_Query) 49691C90-7E17-101A-A91C-08002B2ECDA9, 9 (PROPID_QUERY_VIRTUALPATH)
//  
//  This always represents a well formed URL that points to the item.  
//  
//  To reference shell namespace items using shell APIs, use System.ParsingPath.
//  
//  Example values:
//  
//      Files:    "file:///c:/foo/bar/hello.txt"
//                "csc://{GUID}/..."
//      Messages: "mapi://..."
DEFINE_PROPERTYKEY(PKEY_ItemUrl, 0x49691C90, 0x7E17, 0x101A, 0xA9, 0x1C, 0x08, 0x00, 0x2B, 0x2E, 0xCD, 0xA9, 9);

//  Name:     System.Keywords -- PKEY_Keywords
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)  Legacy code may treat this as VT_LPSTR.
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 5 (PIDSI_KEYWORDS)
//
//  The keywords for the item.  Also referred to as tags.
DEFINE_PROPERTYKEY(PKEY_Keywords, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 5);

//  Name:     System.Kind -- PKEY_Kind
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: 1E3EE840-BC2B-476C-8237-2ACD1A839B22, 3
//  
//  System.Kind is used to map extensions to various .Search folders.
//  Extensions are mapped to Kinds at HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Explorer\KindMap
//  The list of kinds is not extensible.
DEFINE_PROPERTYKEY(PKEY_Kind, 0x1E3EE840, 0xBC2B, 0x476C, 0x82, 0x37, 0x2A, 0xCD, 0x1A, 0x83, 0x9B, 0x22, 3);

// Possible discrete values for PKEY_Kind are:
#define KIND_CALENDAR                       L"calendar"
#define KIND_COMMUNICATION                  L"communication"
#define KIND_CONTACT                        L"contact"
#define KIND_DOCUMENT                       L"document"
#define KIND_EMAIL                          L"email"
#define KIND_FEED                           L"feed"
#define KIND_FOLDER                         L"folder"
#define KIND_GAME                           L"game"
#define KIND_INSTANTMESSAGE                 L"instantmessage"
#define KIND_JOURNAL                        L"journal"
#define KIND_LINK                           L"link"
#define KIND_MOVIE                          L"movie"
#define KIND_MUSIC                          L"music"
#define KIND_NOTE                           L"note"
#define KIND_PICTURE                        L"picture"
#define KIND_PROGRAM                        L"program"
#define KIND_RECORDEDTV                     L"recordedtv"
#define KIND_SEARCHFOLDER                   L"searchfolder"
#define KIND_TASK                           L"task"
#define KIND_VIDEO                          L"video"
#define KIND_WEBHISTORY                     L"webhistory"

//  Name:     System.KindText -- PKEY_KindText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: F04BEF95-C585-4197-A2B7-DF46FDC9EE6D, 100
//  
//  This is the user-friendly form of System.Kind.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_KindText, 0xF04BEF95, 0xC585, 0x4197, 0xA2, 0xB7, 0xDF, 0x46, 0xFD, 0xC9, 0xEE, 0x6D, 100);

//  Name:     System.Language -- PKEY_Language
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 28
//
//  
DEFINE_PROPERTYKEY(PKEY_Language, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 28);

//  Name:     System.MileageInformation -- PKEY_MileageInformation
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: FDF84370-031A-4ADD-9E91-0D775F1C6605, 100
DEFINE_PROPERTYKEY(PKEY_MileageInformation, 0xFDF84370, 0x031A, 0x4ADD, 0x9E, 0x91, 0x0D, 0x77, 0x5F, 0x1C, 0x66, 0x05, 100);

//  Name:     System.MIMEType -- PKEY_MIMEType
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 0B63E350-9CCC-11D0-BCDB-00805FCCCE04, 5
//
//  The MIME type.  Eg, for EML files: 'message/rfc822'.
DEFINE_PROPERTYKEY(PKEY_MIMEType, 0x0B63E350, 0x9CCC, 0x11D0, 0xBC, 0xDB, 0x00, 0x80, 0x5F, 0xCC, 0xCE, 0x04, 5);

//  Name:     System.Null -- PKEY_Null
//  Type:     Null -- VT_NULL
//  FormatID: 00000000-0000-0000-0000-000000000000, 0
DEFINE_PROPERTYKEY(PKEY_Null, 0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0);

//  Name:     System.OfflineAvailability -- PKEY_OfflineAvailability
//  Type:     UInt32 -- VT_UI4
//  FormatID: A94688B6-7D9F-4570-A648-E3DFC0AB2B3F, 100
DEFINE_PROPERTYKEY(PKEY_OfflineAvailability, 0xA94688B6, 0x7D9F, 0x4570, 0xA6, 0x48, 0xE3, 0xDF, 0xC0, 0xAB, 0x2B, 0x3F, 100);

// Possible discrete values for PKEY_OfflineAvailability are:
#define OFFLINEAVAILABILITY_NOT_AVAILABLE   0ul
#define OFFLINEAVAILABILITY_AVAILABLE       1ul
#define OFFLINEAVAILABILITY_ALWAYS_AVAILABLE 2ul

//  Name:     System.OfflineStatus -- PKEY_OfflineStatus
//  Type:     UInt32 -- VT_UI4
//  FormatID: 6D24888F-4718-4BDA-AFED-EA0FB4386CD8, 100
DEFINE_PROPERTYKEY(PKEY_OfflineStatus, 0x6D24888F, 0x4718, 0x4BDA, 0xAF, 0xED, 0xEA, 0x0F, 0xB4, 0x38, 0x6C, 0xD8, 100);

// Possible discrete values for PKEY_OfflineStatus are:
#define OFFLINESTATUS_ONLINE                0ul
#define OFFLINESTATUS_OFFLINE               1ul
#define OFFLINESTATUS_OFFLINE_FORCED        2ul
#define OFFLINESTATUS_OFFLINE_SLOW          3ul
#define OFFLINESTATUS_OFFLINE_ERROR         4ul
#define OFFLINESTATUS_OFFLINE_ITEM_VERSION_CONFLICT 5ul
#define OFFLINESTATUS_OFFLINE_SUSPENDED     6ul

//  Name:     System.OriginalFileName -- PKEY_OriginalFileName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSFMTID_VERSION) 0CEF7D53-FA64-11D1-A203-0000F81FEDEE, 6
//  
//  
DEFINE_PROPERTYKEY(PKEY_OriginalFileName, 0x0CEF7D53, 0xFA64, 0x11D1, 0xA2, 0x03, 0x00, 0x00, 0xF8, 0x1F, 0xED, 0xEE, 6);

//  Name:     System.ParentalRating -- PKEY_ParentalRating
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 21 (PIDMSI_PARENTAL_RATING)
//
//  
DEFINE_PROPERTYKEY(PKEY_ParentalRating, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 21);

//  Name:     System.ParentalRatingReason -- PKEY_ParentalRatingReason
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 10984E0A-F9F2-4321-B7EF-BAF195AF4319, 100
DEFINE_PROPERTYKEY(PKEY_ParentalRatingReason, 0x10984E0A, 0xF9F2, 0x4321, 0xB7, 0xEF, 0xBA, 0xF1, 0x95, 0xAF, 0x43, 0x19, 100);

//  Name:     System.ParentalRatingsOrganization -- PKEY_ParentalRatingsOrganization
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: A7FE0840-1344-46F0-8D37-52ED712A4BF9, 100
DEFINE_PROPERTYKEY(PKEY_ParentalRatingsOrganization, 0xA7FE0840, 0x1344, 0x46F0, 0x8D, 0x37, 0x52, 0xED, 0x71, 0x2A, 0x4B, 0xF9, 100);

//  Name:     System.ParsingBindContext -- PKEY_ParsingBindContext
//  Type:     Any -- VT_NULL  Legacy code may treat this as VT_UNKNOWN.
//  FormatID: DFB9A04D-362F-4CA3-B30B-0254B17B5B84, 100
//  
//  used to get the IBindCtx for an item for parsing
DEFINE_PROPERTYKEY(PKEY_ParsingBindContext, 0xDFB9A04D, 0x362F, 0x4CA3, 0xB3, 0x0B, 0x02, 0x54, 0xB1, 0x7B, 0x5B, 0x84, 100);

//  Name:     System.ParsingName -- PKEY_ParsingName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_ShellDetails) 28636AA6-953D-11D2-B5D6-00C04FD918D0, 24
//  
//  The shell namespace name of an item relative to a parent folder.  This name may be passed to 
//  IShellFolder::ParseDisplayName() of the parent shell folder.
DEFINE_PROPERTYKEY(PKEY_ParsingName, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 24);

//  Name:     System.ParsingPath -- PKEY_ParsingPath
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_ShellDetails) 28636AA6-953D-11D2-B5D6-00C04FD918D0, 30
//  
//  This is the shell namespace path to the item.  This path may be passed to 
//  SHParseDisplayName to parse the path to the correct shell folder.
//  
//  If the item is a file, the value is identical to System.ItemPathDisplay.
//  
//  If the item cannot be accessed through the shell namespace, this value is VT_EMPTY.
DEFINE_PROPERTYKEY(PKEY_ParsingPath, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 30);

//  Name:     System.PerceivedType -- PKEY_PerceivedType
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_ShellDetails) 28636AA6-953D-11D2-B5D6-00C04FD918D0, 9
//
//  The perceived type of a shell item, based upon its canonical type.
DEFINE_PROPERTYKEY(PKEY_PerceivedType, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 9);

// For the enumerated values of PKEY_PerceivedType, see the PERCEIVED_TYPE_* values in shtypes.idl.

//  Name:     System.PercentFull -- PKEY_PercentFull
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_Volume) 9B174B35-40FF-11D2-A27E-00C04FC30871, 5  (Filesystem Volume Properties)
//
//  The amount filled as a percentage, multiplied by 100 (ie, the valid range is 0 through 100).
DEFINE_PROPERTYKEY(PKEY_PercentFull, 0x9B174B35, 0x40FF, 0x11D2, 0xA2, 0x7E, 0x00, 0xC0, 0x4F, 0xC3, 0x08, 0x71, 5);

//  Name:     System.Priority -- PKEY_Priority
//  Type:     UInt16 -- VT_UI2
//  FormatID: 9C1FCF74-2D97-41BA-B4AE-CB2E3661A6E4, 5
//
//  
DEFINE_PROPERTYKEY(PKEY_Priority, 0x9C1FCF74, 0x2D97, 0x41BA, 0xB4, 0xAE, 0xCB, 0x2E, 0x36, 0x61, 0xA6, 0xE4, 5);

// Possible discrete values for PKEY_Priority are:
#define PRIORITY_PROP_LOW                   0u
#define PRIORITY_PROP_NORMAL                1u
#define PRIORITY_PROP_HIGH                  2u

//  Name:     System.PriorityText -- PKEY_PriorityText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: D98BE98B-B86B-4095-BF52-9D23B2E0A752, 100
//  
//  This is the user-friendly form of System.Priority.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_PriorityText, 0xD98BE98B, 0xB86B, 0x4095, 0xBF, 0x52, 0x9D, 0x23, 0xB2, 0xE0, 0xA7, 0x52, 100);

//  Name:     System.Project -- PKEY_Project
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 39A7F922-477C-48DE-8BC8-B28441E342E3, 100
DEFINE_PROPERTYKEY(PKEY_Project, 0x39A7F922, 0x477C, 0x48DE, 0x8B, 0xC8, 0xB2, 0x84, 0x41, 0xE3, 0x42, 0xE3, 100);

//  Name:     System.ProviderItemID -- PKEY_ProviderItemID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: F21D9941-81F0-471A-ADEE-4E74B49217ED, 100
//  
//  
DEFINE_PROPERTYKEY(PKEY_ProviderItemID, 0xF21D9941, 0x81F0, 0x471A, 0xAD, 0xEE, 0x4E, 0x74, 0xB4, 0x92, 0x17, 0xED, 100);

//  Name:     System.Rating -- PKEY_Rating
//  Type:     UInt32 -- VT_UI4
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 9 (PIDMSI_RATING)
//  
//  Indicates the users preference rating of an item on a scale of 0-99 (0 = unrated, 1-12 = One Star, 
//  13-37 = Two Stars, 38-62 = Three Stars, 63-87 = Four Stars, 88-99 = Five Stars).
DEFINE_PROPERTYKEY(PKEY_Rating, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 9);

// Use the following constants to convert between visual stars and the ratings value:
#define RATING_UNRATED_MIN                  0ul
#define RATING_UNRATED_SET                  0ul
#define RATING_UNRATED_MAX                  0ul

#define RATING_ONE_STAR_MIN                 1ul
#define RATING_ONE_STAR_SET                 1ul
#define RATING_ONE_STAR_MAX                 12ul

#define RATING_TWO_STARS_MIN                13ul
#define RATING_TWO_STARS_SET                25ul
#define RATING_TWO_STARS_MAX                37ul

#define RATING_THREE_STARS_MIN              38ul
#define RATING_THREE_STARS_SET              50ul
#define RATING_THREE_STARS_MAX              62ul

#define RATING_FOUR_STARS_MIN               63ul
#define RATING_FOUR_STARS_SET               75ul
#define RATING_FOUR_STARS_MAX               87ul

#define RATING_FIVE_STARS_MIN               88ul
#define RATING_FIVE_STARS_SET               99ul
#define RATING_FIVE_STARS_MAX               99ul


//  Name:     System.RatingText -- PKEY_RatingText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 90197CA7-FD8F-4E8C-9DA3-B57E1E609295, 100
//  
//  This is the user-friendly form of System.Rating.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_RatingText, 0x90197CA7, 0xFD8F, 0x4E8C, 0x9D, 0xA3, 0xB5, 0x7E, 0x1E, 0x60, 0x92, 0x95, 100);

//  Name:     System.Sensitivity -- PKEY_Sensitivity
//  Type:     UInt16 -- VT_UI2
//  FormatID: F8D3F6AC-4874-42CB-BE59-AB454B30716A, 100
//
//  
DEFINE_PROPERTYKEY(PKEY_Sensitivity, 0xF8D3F6AC, 0x4874, 0x42CB, 0xBE, 0x59, 0xAB, 0x45, 0x4B, 0x30, 0x71, 0x6A, 100);

// Possible discrete values for PKEY_Sensitivity are:
#define SENSITIVITY_PROP_NORMAL             0u
#define SENSITIVITY_PROP_PERSONAL           1u
#define SENSITIVITY_PROP_PRIVATE            2u
#define SENSITIVITY_PROP_CONFIDENTIAL       3u

//  Name:     System.SensitivityText -- PKEY_SensitivityText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: D0C7F054-3F72-4725-8527-129A577CB269, 100
//  
//  This is the user-friendly form of System.Sensitivity.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_SensitivityText, 0xD0C7F054, 0x3F72, 0x4725, 0x85, 0x27, 0x12, 0x9A, 0x57, 0x7C, 0xB2, 0x69, 100);

//  Name:     System.SFGAOFlags -- PKEY_SFGAOFlags
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_ShellDetails) 28636AA6-953D-11D2-B5D6-00C04FD918D0, 25
//
//  IShellFolder::GetAttributesOf flags, with SFGAO_PKEYSFGAOMASK attributes masked out.
DEFINE_PROPERTYKEY(PKEY_SFGAOFlags, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 25);

//  Name:     System.SharedWith -- PKEY_SharedWith
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: EF884C5B-2BFE-41BB-AAE5-76EEDF4F9902, 200
//
//  Who is the item shared with?
DEFINE_PROPERTYKEY(PKEY_SharedWith, 0xEF884C5B, 0x2BFE, 0x41BB, 0xAA, 0xE5, 0x76, 0xEE, 0xDF, 0x4F, 0x99, 0x02, 200);

//  Name:     System.ShareUserRating -- PKEY_ShareUserRating
//  Type:     UInt32 -- VT_UI4
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 12 (PIDMSI_SHARE_USER_RATING)
//
//  
DEFINE_PROPERTYKEY(PKEY_ShareUserRating, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 12);

//  Name:     System.Shell.OmitFromView -- PKEY_Shell_OmitFromView
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: DE35258C-C695-4CBC-B982-38B0AD24CED0, 2
//  
//  Set this to a string value of 'True' to omit this item from shell views
DEFINE_PROPERTYKEY(PKEY_Shell_OmitFromView, 0xDE35258C, 0xC695, 0x4CBC, 0xB9, 0x82, 0x38, 0xB0, 0xAD, 0x24, 0xCE, 0xD0, 2);

//  Name:     System.SimpleRating -- PKEY_SimpleRating
//  Type:     UInt32 -- VT_UI4
//  FormatID: A09F084E-AD41-489F-8076-AA5BE3082BCA, 100
//  
//  Indicates the users preference rating of an item on a scale of 0-5 (0=unrated, 1=One Star, 2=Two Stars, 3=Three Stars,
//  4=Four Stars, 5=Five Stars)
DEFINE_PROPERTYKEY(PKEY_SimpleRating, 0xA09F084E, 0xAD41, 0x489F, 0x80, 0x76, 0xAA, 0x5B, 0xE3, 0x08, 0x2B, 0xCA, 100);

//  Name:     System.Size -- PKEY_Size
//  Type:     UInt64 -- VT_UI8
//  FormatID: (FMTID_Storage) B725F130-47EF-101A-A5F1-02608C9EEBAC, 12 (PID_STG_SIZE)
//
//  
DEFINE_PROPERTYKEY(PKEY_Size, 0xB725F130, 0x47EF, 0x101A, 0xA5, 0xF1, 0x02, 0x60, 0x8C, 0x9E, 0xEB, 0xAC, 12);

//  Name:     System.SoftwareUsed -- PKEY_SoftwareUsed
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 305
//
//  PropertyTagSoftwareUsed
DEFINE_PROPERTYKEY(PKEY_SoftwareUsed, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 305);

//  Name:     System.SourceItem -- PKEY_SourceItem
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 668CDFA5-7A1B-4323-AE4B-E527393A1D81, 100
DEFINE_PROPERTYKEY(PKEY_SourceItem, 0x668CDFA5, 0x7A1B, 0x4323, 0xAE, 0x4B, 0xE5, 0x27, 0x39, 0x3A, 0x1D, 0x81, 100);

//  Name:     System.StartDate -- PKEY_StartDate
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: 48FD6EC8-8A12-4CDF-A03E-4EC5A511EDDE, 100
DEFINE_PROPERTYKEY(PKEY_StartDate, 0x48FD6EC8, 0x8A12, 0x4CDF, 0xA0, 0x3E, 0x4E, 0xC5, 0xA5, 0x11, 0xED, 0xDE, 100);

//  Name:     System.Status -- PKEY_Status
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_IntSite) 000214A1-0000-0000-C000-000000000046, 9
DEFINE_PROPERTYKEY(PKEY_Status, 0x000214A1, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 9);

//  Name:     System.Subject -- PKEY_Subject
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 3 (PIDSI_SUBJECT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Subject, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 3);

//  Name:     System.Thumbnail -- PKEY_Thumbnail
//  Type:     Clipboard -- VT_CF
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 17 (PIDSI_THUMBNAIL)
//
//  A data that represents the thumbnail in VT_CF format.
DEFINE_PROPERTYKEY(PKEY_Thumbnail, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 17);

//  Name:     System.ThumbnailCacheId -- PKEY_ThumbnailCacheId
//  Type:     UInt64 -- VT_UI8
//  FormatID: 446D16B1-8DAD-4870-A748-402EA43D788C, 100
//  
//  Unique value that can be used as a key to cache thumbnails. The value changes when the name, volume, or data modified 
//  of an item changes.
DEFINE_PROPERTYKEY(PKEY_ThumbnailCacheId, 0x446D16B1, 0x8DAD, 0x4870, 0xA7, 0x48, 0x40, 0x2E, 0xA4, 0x3D, 0x78, 0x8C, 100);

//  Name:     System.ThumbnailStream -- PKEY_ThumbnailStream
//  Type:     Stream -- VT_STREAM
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 27
//
//  Data that represents the thumbnail in VT_STREAM format that GDI+/WindowsCodecs supports (jpg, png, etc).
DEFINE_PROPERTYKEY(PKEY_ThumbnailStream, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 27);

//  Name:     System.Title -- PKEY_Title
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)  Legacy code may treat this as VT_LPSTR.
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 2 (PIDSI_TITLE)
//
//  Title of item.
DEFINE_PROPERTYKEY(PKEY_Title, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 2);

//  Name:     System.TotalFileSize -- PKEY_TotalFileSize
//  Type:     UInt64 -- VT_UI8
//  FormatID: (FMTID_ShellDetails) 28636AA6-953D-11D2-B5D6-00C04FD918D0, 14
//
//  
DEFINE_PROPERTYKEY(PKEY_TotalFileSize, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 14);

//  Name:     System.Trademarks -- PKEY_Trademarks
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSFMTID_VERSION) 0CEF7D53-FA64-11D1-A203-0000F81FEDEE, 9 (PIDVSI_Trademarks)
//
//  
DEFINE_PROPERTYKEY(PKEY_Trademarks, 0x0CEF7D53, 0xFA64, 0x11D1, 0xA2, 0x03, 0x00, 0x00, 0xF8, 0x1F, 0xED, 0xEE, 9);
 
//-----------------------------------------------------------------------------
// Document properties



//  Name:     System.Document.ByteCount -- PKEY_Document_ByteCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 4 (PIDDSI_BYTECOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_ByteCount, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 4);

//  Name:     System.Document.CharacterCount -- PKEY_Document_CharacterCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 16 (PIDSI_CHARCOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_CharacterCount, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 16);

//  Name:     System.Document.ClientID -- PKEY_Document_ClientID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 276D7BB0-5B34-4FB0-AA4B-158ED12A1809, 100
DEFINE_PROPERTYKEY(PKEY_Document_ClientID, 0x276D7BB0, 0x5B34, 0x4FB0, 0xAA, 0x4B, 0x15, 0x8E, 0xD1, 0x2A, 0x18, 0x09, 100);

//  Name:     System.Document.Contributor -- PKEY_Document_Contributor
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: F334115E-DA1B-4509-9B3D-119504DC7ABB, 100
DEFINE_PROPERTYKEY(PKEY_Document_Contributor, 0xF334115E, 0xDA1B, 0x4509, 0x9B, 0x3D, 0x11, 0x95, 0x04, 0xDC, 0x7A, 0xBB, 100);

//  Name:     System.Document.DateCreated -- PKEY_Document_DateCreated
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 12 (PIDSI_CREATE_DTM)
//  
//  This property is stored in the document, not obtained from the file system.
DEFINE_PROPERTYKEY(PKEY_Document_DateCreated, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 12);

//  Name:     System.Document.DatePrinted -- PKEY_Document_DatePrinted
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 11 (PIDSI_LASTPRINTED)
//
//  Legacy name: "DocLastPrinted".
DEFINE_PROPERTYKEY(PKEY_Document_DatePrinted, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 11);

//  Name:     System.Document.DateSaved -- PKEY_Document_DateSaved
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 13 (PIDSI_LASTSAVE_DTM)
//
//  Legacy name: "DocLastSavedTm".
DEFINE_PROPERTYKEY(PKEY_Document_DateSaved, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 13);

//  Name:     System.Document.Division -- PKEY_Document_Division
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 1E005EE6-BF27-428B-B01C-79676ACD2870, 100
DEFINE_PROPERTYKEY(PKEY_Document_Division, 0x1E005EE6, 0xBF27, 0x428B, 0xB0, 0x1C, 0x79, 0x67, 0x6A, 0xCD, 0x28, 0x70, 100);

//  Name:     System.Document.DocumentID -- PKEY_Document_DocumentID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: E08805C8-E395-40DF-80D2-54F0D6C43154, 100
DEFINE_PROPERTYKEY(PKEY_Document_DocumentID, 0xE08805C8, 0xE395, 0x40DF, 0x80, 0xD2, 0x54, 0xF0, 0xD6, 0xC4, 0x31, 0x54, 100);

//  Name:     System.Document.HiddenSlideCount -- PKEY_Document_HiddenSlideCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 9 (PIDDSI_HIDDENCOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_HiddenSlideCount, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 9);

//  Name:     System.Document.LastAuthor -- PKEY_Document_LastAuthor
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 8 (PIDSI_LASTAUTHOR)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_LastAuthor, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 8);

//  Name:     System.Document.LineCount -- PKEY_Document_LineCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 5 (PIDDSI_LINECOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_LineCount, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 5);

//  Name:     System.Document.Manager -- PKEY_Document_Manager
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 14 (PIDDSI_MANAGER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_Manager, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 14);

//  Name:     System.Document.MultimediaClipCount -- PKEY_Document_MultimediaClipCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 10 (PIDDSI_MMCLIPCOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_MultimediaClipCount, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 10);

//  Name:     System.Document.NoteCount -- PKEY_Document_NoteCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 8 (PIDDSI_NOTECOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_NoteCount, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 8);

//  Name:     System.Document.PageCount -- PKEY_Document_PageCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 14 (PIDSI_PAGECOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_PageCount, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 14);

//  Name:     System.Document.ParagraphCount -- PKEY_Document_ParagraphCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 6 (PIDDSI_PARCOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_ParagraphCount, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 6);

//  Name:     System.Document.PresentationFormat -- PKEY_Document_PresentationFormat
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 3 (PIDDSI_PRESFORMAT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_PresentationFormat, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 3);

//  Name:     System.Document.RevisionNumber -- PKEY_Document_RevisionNumber
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 9 (PIDSI_REVNUMBER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_RevisionNumber, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 9);

//  Name:     System.Document.Security -- PKEY_Document_Security
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 19
//
//  Access control information, from SummaryInfo propset
DEFINE_PROPERTYKEY(PKEY_Document_Security, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 19);

//  Name:     System.Document.SlideCount -- PKEY_Document_SlideCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 7 (PIDDSI_SLIDECOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_SlideCount, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 7);

//  Name:     System.Document.Template -- PKEY_Document_Template
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 7 (PIDSI_TEMPLATE)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_Template, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 7);

//  Name:     System.Document.TotalEditingTime -- PKEY_Document_TotalEditingTime
//  Type:     UInt64 -- VT_UI8
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 10 (PIDSI_EDITTIME)
//
//  100ns units, not milliseconds. VT_FILETIME for IPropertySetStorage handlers (legacy)
DEFINE_PROPERTYKEY(PKEY_Document_TotalEditingTime, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 10);

//  Name:     System.Document.Version -- PKEY_Document_Version
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_DocumentSummaryInformation) D5CDD502-2E9C-101B-9397-08002B2CF9AE, 29
DEFINE_PROPERTYKEY(PKEY_Document_Version, 0xD5CDD502, 0x2E9C, 0x101B, 0x93, 0x97, 0x08, 0x00, 0x2B, 0x2C, 0xF9, 0xAE, 29);

//  Name:     System.Document.WordCount -- PKEY_Document_WordCount
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_SummaryInformation) F29F85E0-4FF9-1068-AB91-08002B27B3D9, 15 (PIDSI_WORDCOUNT)
//
//  
DEFINE_PROPERTYKEY(PKEY_Document_WordCount, 0xF29F85E0, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9, 15);

 
 
//-----------------------------------------------------------------------------
// DRM properties

//  Name:     System.DRM.DatePlayExpires -- PKEY_DRM_DatePlayExpires
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_DRM) AEAC19E4-89AE-4508-B9B7-BB867ABEE2ED, 6 (PIDDRSI_PLAYEXPIRES)
//
//  Indicates when play expires for digital rights management.
DEFINE_PROPERTYKEY(PKEY_DRM_DatePlayExpires, 0xAEAC19E4, 0x89AE, 0x4508, 0xB9, 0xB7, 0xBB, 0x86, 0x7A, 0xBE, 0xE2, 0xED, 6);

//  Name:     System.DRM.DatePlayStarts -- PKEY_DRM_DatePlayStarts
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_DRM) AEAC19E4-89AE-4508-B9B7-BB867ABEE2ED, 5 (PIDDRSI_PLAYSTARTS)
//
//  Indicates when play starts for digital rights management.
DEFINE_PROPERTYKEY(PKEY_DRM_DatePlayStarts, 0xAEAC19E4, 0x89AE, 0x4508, 0xB9, 0xB7, 0xBB, 0x86, 0x7A, 0xBE, 0xE2, 0xED, 5);

//  Name:     System.DRM.Description -- PKEY_DRM_Description
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_DRM) AEAC19E4-89AE-4508-B9B7-BB867ABEE2ED, 3 (PIDDRSI_DESCRIPTION)
//
//  Displays the description for digital rights management.
DEFINE_PROPERTYKEY(PKEY_DRM_Description, 0xAEAC19E4, 0x89AE, 0x4508, 0xB9, 0xB7, 0xBB, 0x86, 0x7A, 0xBE, 0xE2, 0xED, 3);

//  Name:     System.DRM.IsProtected -- PKEY_DRM_IsProtected
//  Type:     Boolean -- VT_BOOL
//  FormatID: (FMTID_DRM) AEAC19E4-89AE-4508-B9B7-BB867ABEE2ED, 2 (PIDDRSI_PROTECTED)
//
//  
DEFINE_PROPERTYKEY(PKEY_DRM_IsProtected, 0xAEAC19E4, 0x89AE, 0x4508, 0xB9, 0xB7, 0xBB, 0x86, 0x7A, 0xBE, 0xE2, 0xED, 2);

//  Name:     System.DRM.PlayCount -- PKEY_DRM_PlayCount
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_DRM) AEAC19E4-89AE-4508-B9B7-BB867ABEE2ED, 4 (PIDDRSI_PLAYCOUNT)
//
//  Indicates the play count for digital rights management.
DEFINE_PROPERTYKEY(PKEY_DRM_PlayCount, 0xAEAC19E4, 0x89AE, 0x4508, 0xB9, 0xB7, 0xBB, 0x86, 0x7A, 0xBE, 0xE2, 0xED, 4);
 
//-----------------------------------------------------------------------------
// GPS properties

//  Name:     System.GPS.Altitude -- PKEY_GPS_Altitude
//  Type:     Double -- VT_R8
//  FormatID: 827EDB4F-5B73-44A7-891D-FDFFABEA35CA, 100
//  
//  Indicates the altitude based on the reference in PKEY_GPS_AltitudeRef.  Calculated from PKEY_GPS_AltitudeNumerator and 
//  PKEY_GPS_AltitudeDenominator
DEFINE_PROPERTYKEY(PKEY_GPS_Altitude, 0x827EDB4F, 0x5B73, 0x44A7, 0x89, 0x1D, 0xFD, 0xFF, 0xAB, 0xEA, 0x35, 0xCA, 100);

//  Name:     System.GPS.AltitudeDenominator -- PKEY_GPS_AltitudeDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 78342DCB-E358-4145-AE9A-6BFE4E0F9F51, 100
//
//  Denominator of PKEY_GPS_Altitude
DEFINE_PROPERTYKEY(PKEY_GPS_AltitudeDenominator, 0x78342DCB, 0xE358, 0x4145, 0xAE, 0x9A, 0x6B, 0xFE, 0x4E, 0x0F, 0x9F, 0x51, 100);

//  Name:     System.GPS.AltitudeNumerator -- PKEY_GPS_AltitudeNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 2DAD1EB7-816D-40D3-9EC3-C9773BE2AADE, 100
//
//  Numerator of PKEY_GPS_Altitude
DEFINE_PROPERTYKEY(PKEY_GPS_AltitudeNumerator, 0x2DAD1EB7, 0x816D, 0x40D3, 0x9E, 0xC3, 0xC9, 0x77, 0x3B, 0xE2, 0xAA, 0xDE, 100);

//  Name:     System.GPS.AltitudeRef -- PKEY_GPS_AltitudeRef
//  Type:     Byte -- VT_UI1
//  FormatID: 46AC629D-75EA-4515-867F-6DC4321C5844, 100
//
//  Indicates the reference for the altitude property. (eg: above sea level, below sea level, absolute value)
DEFINE_PROPERTYKEY(PKEY_GPS_AltitudeRef, 0x46AC629D, 0x75EA, 0x4515, 0x86, 0x7F, 0x6D, 0xC4, 0x32, 0x1C, 0x58, 0x44, 100);

//  Name:     System.GPS.AreaInformation -- PKEY_GPS_AreaInformation
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 972E333E-AC7E-49F1-8ADF-A70D07A9BCAB, 100
//
//  Represents the name of the GPS area
DEFINE_PROPERTYKEY(PKEY_GPS_AreaInformation, 0x972E333E, 0xAC7E, 0x49F1, 0x8A, 0xDF, 0xA7, 0x0D, 0x07, 0xA9, 0xBC, 0xAB, 100);

//  Name:     System.GPS.Date -- PKEY_GPS_Date
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: 3602C812-0F3B-45F0-85AD-603468D69423, 100
//
//  Date and time of the GPS record
DEFINE_PROPERTYKEY(PKEY_GPS_Date, 0x3602C812, 0x0F3B, 0x45F0, 0x85, 0xAD, 0x60, 0x34, 0x68, 0xD6, 0x94, 0x23, 100);

//  Name:     System.GPS.DestBearing -- PKEY_GPS_DestBearing
//  Type:     Double -- VT_R8
//  FormatID: C66D4B3C-E888-47CC-B99F-9DCA3EE34DEA, 100
//  
//  Indicates the bearing to the destination point.  Calculated from PKEY_GPS_DestBearingNumerator and 
//  PKEY_GPS_DestBearingDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_DestBearing, 0xC66D4B3C, 0xE888, 0x47CC, 0xB9, 0x9F, 0x9D, 0xCA, 0x3E, 0xE3, 0x4D, 0xEA, 100);

//  Name:     System.GPS.DestBearingDenominator -- PKEY_GPS_DestBearingDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 7ABCF4F8-7C3F-4988-AC91-8D2C2E97ECA5, 100
//
//  Denominator of PKEY_GPS_DestBearing
DEFINE_PROPERTYKEY(PKEY_GPS_DestBearingDenominator, 0x7ABCF4F8, 0x7C3F, 0x4988, 0xAC, 0x91, 0x8D, 0x2C, 0x2E, 0x97, 0xEC, 0xA5, 100);

//  Name:     System.GPS.DestBearingNumerator -- PKEY_GPS_DestBearingNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: BA3B1DA9-86EE-4B5D-A2A4-A271A429F0CF, 100
//
//  Numerator of PKEY_GPS_DestBearing
DEFINE_PROPERTYKEY(PKEY_GPS_DestBearingNumerator, 0xBA3B1DA9, 0x86EE, 0x4B5D, 0xA2, 0xA4, 0xA2, 0x71, 0xA4, 0x29, 0xF0, 0xCF, 100);

//  Name:     System.GPS.DestBearingRef -- PKEY_GPS_DestBearingRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 9AB84393-2A0F-4B75-BB22-7279786977CB, 100
//
//  Indicates the reference used for the giving the bearing to the destination point.  (eg: true direction, magnetic direction)
DEFINE_PROPERTYKEY(PKEY_GPS_DestBearingRef, 0x9AB84393, 0x2A0F, 0x4B75, 0xBB, 0x22, 0x72, 0x79, 0x78, 0x69, 0x77, 0xCB, 100);

//  Name:     System.GPS.DestDistance -- PKEY_GPS_DestDistance
//  Type:     Double -- VT_R8
//  FormatID: A93EAE04-6804-4F24-AC81-09B266452118, 100
//  
//  Indicates the distance to the destination point.  Calculated from PKEY_GPS_DestDistanceNumerator and 
//  PKEY_GPS_DestDistanceDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_DestDistance, 0xA93EAE04, 0x6804, 0x4F24, 0xAC, 0x81, 0x09, 0xB2, 0x66, 0x45, 0x21, 0x18, 100);

//  Name:     System.GPS.DestDistanceDenominator -- PKEY_GPS_DestDistanceDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 9BC2C99B-AC71-4127-9D1C-2596D0D7DCB7, 100
//
//  Denominator of PKEY_GPS_DestDistance
DEFINE_PROPERTYKEY(PKEY_GPS_DestDistanceDenominator, 0x9BC2C99B, 0xAC71, 0x4127, 0x9D, 0x1C, 0x25, 0x96, 0xD0, 0xD7, 0xDC, 0xB7, 100);

//  Name:     System.GPS.DestDistanceNumerator -- PKEY_GPS_DestDistanceNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 2BDA47DA-08C6-4FE1-80BC-A72FC517C5D0, 100
//
//  Numerator of PKEY_GPS_DestDistance
DEFINE_PROPERTYKEY(PKEY_GPS_DestDistanceNumerator, 0x2BDA47DA, 0x08C6, 0x4FE1, 0x80, 0xBC, 0xA7, 0x2F, 0xC5, 0x17, 0xC5, 0xD0, 100);

//  Name:     System.GPS.DestDistanceRef -- PKEY_GPS_DestDistanceRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: ED4DF2D3-8695-450B-856F-F5C1C53ACB66, 100
//
//  Indicates the unit used to express the distance to the destination.  (eg: kilometers, miles, knots)
DEFINE_PROPERTYKEY(PKEY_GPS_DestDistanceRef, 0xED4DF2D3, 0x8695, 0x450B, 0x85, 0x6F, 0xF5, 0xC1, 0xC5, 0x3A, 0xCB, 0x66, 100);

//  Name:     System.GPS.DestLatitude -- PKEY_GPS_DestLatitude
//  Type:     Multivalue Double -- VT_VECTOR | VT_R8  (For variants: VT_ARRAY | VT_R8)
//  FormatID: 9D1D7CC5-5C39-451C-86B3-928E2D18CC47, 100
//  
//  Indicates the latitude of the destination point.  This is an array of three values.  Index 0 is the degrees, index 1 
//  is the minutes, index 2 is the seconds.  Each is calculated from the values in PKEY_GPS_DestLatitudeNumerator and 
//  PKEY_GPS_DestLatitudeDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_DestLatitude, 0x9D1D7CC5, 0x5C39, 0x451C, 0x86, 0xB3, 0x92, 0x8E, 0x2D, 0x18, 0xCC, 0x47, 100);

//  Name:     System.GPS.DestLatitudeDenominator -- PKEY_GPS_DestLatitudeDenominator
//  Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4  (For variants: VT_ARRAY | VT_UI4)
//  FormatID: 3A372292-7FCA-49A7-99D5-E47BB2D4E7AB, 100
//
//  Denominator of PKEY_GPS_DestLatitude
DEFINE_PROPERTYKEY(PKEY_GPS_DestLatitudeDenominator, 0x3A372292, 0x7FCA, 0x49A7, 0x99, 0xD5, 0xE4, 0x7B, 0xB2, 0xD4, 0xE7, 0xAB, 100);

//  Name:     System.GPS.DestLatitudeNumerator -- PKEY_GPS_DestLatitudeNumerator
//  Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4  (For variants: VT_ARRAY | VT_UI4)
//  FormatID: ECF4B6F6-D5A6-433C-BB92-4076650FC890, 100
//
//  Numerator of PKEY_GPS_DestLatitude
DEFINE_PROPERTYKEY(PKEY_GPS_DestLatitudeNumerator, 0xECF4B6F6, 0xD5A6, 0x433C, 0xBB, 0x92, 0x40, 0x76, 0x65, 0x0F, 0xC8, 0x90, 100);

//  Name:     System.GPS.DestLatitudeRef -- PKEY_GPS_DestLatitudeRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: CEA820B9-CE61-4885-A128-005D9087C192, 100
//
//  Indicates whether the latitude destination point is north or south latitude
DEFINE_PROPERTYKEY(PKEY_GPS_DestLatitudeRef, 0xCEA820B9, 0xCE61, 0x4885, 0xA1, 0x28, 0x00, 0x5D, 0x90, 0x87, 0xC1, 0x92, 100);

//  Name:     System.GPS.DestLongitude -- PKEY_GPS_DestLongitude
//  Type:     Multivalue Double -- VT_VECTOR | VT_R8  (For variants: VT_ARRAY | VT_R8)
//  FormatID: 47A96261-CB4C-4807-8AD3-40B9D9DBC6BC, 100
//  
//  Indicates the latitude of the destination point.  This is an array of three values.  Index 0 is the degrees, index 1 
//  is the minutes, index 2 is the seconds.  Each is calculated from the values in PKEY_GPS_DestLongitudeNumerator and 
//  PKEY_GPS_DestLongitudeDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_DestLongitude, 0x47A96261, 0xCB4C, 0x4807, 0x8A, 0xD3, 0x40, 0xB9, 0xD9, 0xDB, 0xC6, 0xBC, 100);

//  Name:     System.GPS.DestLongitudeDenominator -- PKEY_GPS_DestLongitudeDenominator
//  Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4  (For variants: VT_ARRAY | VT_UI4)
//  FormatID: 425D69E5-48AD-4900-8D80-6EB6B8D0AC86, 100
//
//  Denominator of PKEY_GPS_DestLongitude
DEFINE_PROPERTYKEY(PKEY_GPS_DestLongitudeDenominator, 0x425D69E5, 0x48AD, 0x4900, 0x8D, 0x80, 0x6E, 0xB6, 0xB8, 0xD0, 0xAC, 0x86, 100);

//  Name:     System.GPS.DestLongitudeNumerator -- PKEY_GPS_DestLongitudeNumerator
//  Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4  (For variants: VT_ARRAY | VT_UI4)
//  FormatID: A3250282-FB6D-48D5-9A89-DBCACE75CCCF, 100
//
//  Numerator of PKEY_GPS_DestLongitude
DEFINE_PROPERTYKEY(PKEY_GPS_DestLongitudeNumerator, 0xA3250282, 0xFB6D, 0x48D5, 0x9A, 0x89, 0xDB, 0xCA, 0xCE, 0x75, 0xCC, 0xCF, 100);

//  Name:     System.GPS.DestLongitudeRef -- PKEY_GPS_DestLongitudeRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 182C1EA6-7C1C-4083-AB4B-AC6C9F4ED128, 100
//
//  Indicates whether the longitude destination point is east or west longitude
DEFINE_PROPERTYKEY(PKEY_GPS_DestLongitudeRef, 0x182C1EA6, 0x7C1C, 0x4083, 0xAB, 0x4B, 0xAC, 0x6C, 0x9F, 0x4E, 0xD1, 0x28, 100);

//  Name:     System.GPS.Differential -- PKEY_GPS_Differential
//  Type:     UInt16 -- VT_UI2
//  FormatID: AAF4EE25-BD3B-4DD7-BFC4-47F77BB00F6D, 100
//
//  Indicates whether differential correction was applied to the GPS receiver
DEFINE_PROPERTYKEY(PKEY_GPS_Differential, 0xAAF4EE25, 0xBD3B, 0x4DD7, 0xBF, 0xC4, 0x47, 0xF7, 0x7B, 0xB0, 0x0F, 0x6D, 100);

//  Name:     System.GPS.DOP -- PKEY_GPS_DOP
//  Type:     Double -- VT_R8
//  FormatID: 0CF8FB02-1837-42F1-A697-A7017AA289B9, 100
//
//  Indicates the GPS DOP (data degree of precision).  Calculated from PKEY_GPS_DOPNumerator and PKEY_GPS_DOPDenominator
DEFINE_PROPERTYKEY(PKEY_GPS_DOP, 0x0CF8FB02, 0x1837, 0x42F1, 0xA6, 0x97, 0xA7, 0x01, 0x7A, 0xA2, 0x89, 0xB9, 100);

//  Name:     System.GPS.DOPDenominator -- PKEY_GPS_DOPDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: A0BE94C5-50BA-487B-BD35-0654BE8881ED, 100
//
//  Denominator of PKEY_GPS_DOP
DEFINE_PROPERTYKEY(PKEY_GPS_DOPDenominator, 0xA0BE94C5, 0x50BA, 0x487B, 0xBD, 0x35, 0x06, 0x54, 0xBE, 0x88, 0x81, 0xED, 100);

//  Name:     System.GPS.DOPNumerator -- PKEY_GPS_DOPNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 47166B16-364F-4AA0-9F31-E2AB3DF449C3, 100
//
//  Numerator of PKEY_GPS_DOP
DEFINE_PROPERTYKEY(PKEY_GPS_DOPNumerator, 0x47166B16, 0x364F, 0x4AA0, 0x9F, 0x31, 0xE2, 0xAB, 0x3D, 0xF4, 0x49, 0xC3, 100);

//  Name:     System.GPS.ImgDirection -- PKEY_GPS_ImgDirection
//  Type:     Double -- VT_R8
//  FormatID: 16473C91-D017-4ED9-BA4D-B6BAA55DBCF8, 100
//  
//  Indicates direction of the image when it was captured.  Calculated from PKEY_GPS_ImgDirectionNumerator and 
//  PKEY_GPS_ImgDirectionDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_ImgDirection, 0x16473C91, 0xD017, 0x4ED9, 0xBA, 0x4D, 0xB6, 0xBA, 0xA5, 0x5D, 0xBC, 0xF8, 100);

//  Name:     System.GPS.ImgDirectionDenominator -- PKEY_GPS_ImgDirectionDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 10B24595-41A2-4E20-93C2-5761C1395F32, 100
//
//  Denominator of PKEY_GPS_ImgDirection
DEFINE_PROPERTYKEY(PKEY_GPS_ImgDirectionDenominator, 0x10B24595, 0x41A2, 0x4E20, 0x93, 0xC2, 0x57, 0x61, 0xC1, 0x39, 0x5F, 0x32, 100);

//  Name:     System.GPS.ImgDirectionNumerator -- PKEY_GPS_ImgDirectionNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: DC5877C7-225F-45F7-BAC7-E81334B6130A, 100
//
//  Numerator of PKEY_GPS_ImgDirection
DEFINE_PROPERTYKEY(PKEY_GPS_ImgDirectionNumerator, 0xDC5877C7, 0x225F, 0x45F7, 0xBA, 0xC7, 0xE8, 0x13, 0x34, 0xB6, 0x13, 0x0A, 100);

//  Name:     System.GPS.ImgDirectionRef -- PKEY_GPS_ImgDirectionRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: A4AAA5B7-1AD0-445F-811A-0F8F6E67F6B5, 100
//
//  Indicates reference for giving the direction of the image when it was captured.  (eg: true direction, magnetic direction)
DEFINE_PROPERTYKEY(PKEY_GPS_ImgDirectionRef, 0xA4AAA5B7, 0x1AD0, 0x445F, 0x81, 0x1A, 0x0F, 0x8F, 0x6E, 0x67, 0xF6, 0xB5, 100);

//  Name:     System.GPS.Latitude -- PKEY_GPS_Latitude
//  Type:     Multivalue Double -- VT_VECTOR | VT_R8  (For variants: VT_ARRAY | VT_R8)
//  FormatID: 8727CFFF-4868-4EC6-AD5B-81B98521D1AB, 100
//  
//  Indicates the latitude.  This is an array of three values.  Index 0 is the degrees, index 1 is the minutes, index 2 
//  is the seconds.  Each is calculated from the values in PKEY_GPS_LatitudeNumerator and PKEY_GPS_LatitudeDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_Latitude, 0x8727CFFF, 0x4868, 0x4EC6, 0xAD, 0x5B, 0x81, 0xB9, 0x85, 0x21, 0xD1, 0xAB, 100);

//  Name:     System.GPS.LatitudeDenominator -- PKEY_GPS_LatitudeDenominator
//  Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4  (For variants: VT_ARRAY | VT_UI4)
//  FormatID: 16E634EE-2BFF-497B-BD8A-4341AD39EEB9, 100
//
//  Denominator of PKEY_GPS_Latitude
DEFINE_PROPERTYKEY(PKEY_GPS_LatitudeDenominator, 0x16E634EE, 0x2BFF, 0x497B, 0xBD, 0x8A, 0x43, 0x41, 0xAD, 0x39, 0xEE, 0xB9, 100);

//  Name:     System.GPS.LatitudeNumerator -- PKEY_GPS_LatitudeNumerator
//  Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4  (For variants: VT_ARRAY | VT_UI4)
//  FormatID: 7DDAAAD1-CCC8-41AE-B750-B2CB8031AEA2, 100
//
//  Numerator of PKEY_GPS_Latitude
DEFINE_PROPERTYKEY(PKEY_GPS_LatitudeNumerator, 0x7DDAAAD1, 0xCCC8, 0x41AE, 0xB7, 0x50, 0xB2, 0xCB, 0x80, 0x31, 0xAE, 0xA2, 100);

//  Name:     System.GPS.LatitudeRef -- PKEY_GPS_LatitudeRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 029C0252-5B86-46C7-ACA0-2769FFC8E3D4, 100
//
//  Indicates whether latitude is north or south latitude 
DEFINE_PROPERTYKEY(PKEY_GPS_LatitudeRef, 0x029C0252, 0x5B86, 0x46C7, 0xAC, 0xA0, 0x27, 0x69, 0xFF, 0xC8, 0xE3, 0xD4, 100);

//  Name:     System.GPS.Longitude -- PKEY_GPS_Longitude
//  Type:     Multivalue Double -- VT_VECTOR | VT_R8  (For variants: VT_ARRAY | VT_R8)
//  FormatID: C4C4DBB2-B593-466B-BBDA-D03D27D5E43A, 100
//  
//  Indicates the longitude.  This is an array of three values.  Index 0 is the degrees, index 1 is the minutes, index 2 
//  is the seconds.  Each is calculated from the values in PKEY_GPS_LongitudeNumerator and PKEY_GPS_LongitudeDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_Longitude, 0xC4C4DBB2, 0xB593, 0x466B, 0xBB, 0xDA, 0xD0, 0x3D, 0x27, 0xD5, 0xE4, 0x3A, 100);

//  Name:     System.GPS.LongitudeDenominator -- PKEY_GPS_LongitudeDenominator
//  Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4  (For variants: VT_ARRAY | VT_UI4)
//  FormatID: BE6E176C-4534-4D2C-ACE5-31DEDAC1606B, 100
//
//  Denominator of PKEY_GPS_Longitude
DEFINE_PROPERTYKEY(PKEY_GPS_LongitudeDenominator, 0xBE6E176C, 0x4534, 0x4D2C, 0xAC, 0xE5, 0x31, 0xDE, 0xDA, 0xC1, 0x60, 0x6B, 100);

//  Name:     System.GPS.LongitudeNumerator -- PKEY_GPS_LongitudeNumerator
//  Type:     Multivalue UInt32 -- VT_VECTOR | VT_UI4  (For variants: VT_ARRAY | VT_UI4)
//  FormatID: 02B0F689-A914-4E45-821D-1DDA452ED2C4, 100
//
//  Numerator of PKEY_GPS_Longitude
DEFINE_PROPERTYKEY(PKEY_GPS_LongitudeNumerator, 0x02B0F689, 0xA914, 0x4E45, 0x82, 0x1D, 0x1D, 0xDA, 0x45, 0x2E, 0xD2, 0xC4, 100);

//  Name:     System.GPS.LongitudeRef -- PKEY_GPS_LongitudeRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 33DCF22B-28D5-464C-8035-1EE9EFD25278, 100
//
//  Indicates whether longitude is east or west longitude
DEFINE_PROPERTYKEY(PKEY_GPS_LongitudeRef, 0x33DCF22B, 0x28D5, 0x464C, 0x80, 0x35, 0x1E, 0xE9, 0xEF, 0xD2, 0x52, 0x78, 100);

//  Name:     System.GPS.MapDatum -- PKEY_GPS_MapDatum
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 2CA2DAE6-EDDC-407D-BEF1-773942ABFA95, 100
//
//  Indicates the geodetic survey data used by the GPS receiver
DEFINE_PROPERTYKEY(PKEY_GPS_MapDatum, 0x2CA2DAE6, 0xEDDC, 0x407D, 0xBE, 0xF1, 0x77, 0x39, 0x42, 0xAB, 0xFA, 0x95, 100);

//  Name:     System.GPS.MeasureMode -- PKEY_GPS_MeasureMode
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: A015ED5D-AAEA-4D58-8A86-3C586920EA0B, 100
//
//  Indicates the GPS measurement mode.  (eg: 2-dimensional, 3-dimensional)
DEFINE_PROPERTYKEY(PKEY_GPS_MeasureMode, 0xA015ED5D, 0xAAEA, 0x4D58, 0x8A, 0x86, 0x3C, 0x58, 0x69, 0x20, 0xEA, 0x0B, 100);

//  Name:     System.GPS.ProcessingMethod -- PKEY_GPS_ProcessingMethod
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 59D49E61-840F-4AA9-A939-E2099B7F6399, 100
//
//  Indicates the name of the method used for location finding
DEFINE_PROPERTYKEY(PKEY_GPS_ProcessingMethod, 0x59D49E61, 0x840F, 0x4AA9, 0xA9, 0x39, 0xE2, 0x09, 0x9B, 0x7F, 0x63, 0x99, 100);

//  Name:     System.GPS.Satellites -- PKEY_GPS_Satellites
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 467EE575-1F25-4557-AD4E-B8B58B0D9C15, 100
//
//  Indicates the GPS satellites used for measurements
DEFINE_PROPERTYKEY(PKEY_GPS_Satellites, 0x467EE575, 0x1F25, 0x4557, 0xAD, 0x4E, 0xB8, 0xB5, 0x8B, 0x0D, 0x9C, 0x15, 100);

//  Name:     System.GPS.Speed -- PKEY_GPS_Speed
//  Type:     Double -- VT_R8
//  FormatID: DA5D0862-6E76-4E1B-BABD-70021BD25494, 100
//  
//  Indicates the speed of the GPS receiver movement.  Calculated from PKEY_GPS_SpeedNumerator and 
//  PKEY_GPS_SpeedDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_Speed, 0xDA5D0862, 0x6E76, 0x4E1B, 0xBA, 0xBD, 0x70, 0x02, 0x1B, 0xD2, 0x54, 0x94, 100);

//  Name:     System.GPS.SpeedDenominator -- PKEY_GPS_SpeedDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 7D122D5A-AE5E-4335-8841-D71E7CE72F53, 100
//
//  Denominator of PKEY_GPS_Speed
DEFINE_PROPERTYKEY(PKEY_GPS_SpeedDenominator, 0x7D122D5A, 0xAE5E, 0x4335, 0x88, 0x41, 0xD7, 0x1E, 0x7C, 0xE7, 0x2F, 0x53, 100);

//  Name:     System.GPS.SpeedNumerator -- PKEY_GPS_SpeedNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: ACC9CE3D-C213-4942-8B48-6D0820F21C6D, 100
//
//  Numerator of PKEY_GPS_Speed
DEFINE_PROPERTYKEY(PKEY_GPS_SpeedNumerator, 0xACC9CE3D, 0xC213, 0x4942, 0x8B, 0x48, 0x6D, 0x08, 0x20, 0xF2, 0x1C, 0x6D, 100);

//  Name:     System.GPS.SpeedRef -- PKEY_GPS_SpeedRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: ECF7F4C9-544F-4D6D-9D98-8AD79ADAF453, 100
//  
//  Indicates the unit used to express the speed of the GPS receiver movement.  (eg: kilometers per hour, 
//  miles per hour, knots).
DEFINE_PROPERTYKEY(PKEY_GPS_SpeedRef, 0xECF7F4C9, 0x544F, 0x4D6D, 0x9D, 0x98, 0x8A, 0xD7, 0x9A, 0xDA, 0xF4, 0x53, 100);

//  Name:     System.GPS.Status -- PKEY_GPS_Status
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 125491F4-818F-46B2-91B5-D537753617B2, 100
//  
//  Indicates the status of the GPS receiver when the image was recorded.  (eg: measurement in progress, 
//  measurement interoperability).
DEFINE_PROPERTYKEY(PKEY_GPS_Status, 0x125491F4, 0x818F, 0x46B2, 0x91, 0xB5, 0xD5, 0x37, 0x75, 0x36, 0x17, 0xB2, 100);

//  Name:     System.GPS.Track -- PKEY_GPS_Track
//  Type:     Double -- VT_R8
//  FormatID: 76C09943-7C33-49E3-9E7E-CDBA872CFADA, 100
//  
//  Indicates the direction of the GPS receiver movement.  Calculated from PKEY_GPS_TrackNumerator and 
//  PKEY_GPS_TrackDenominator.
DEFINE_PROPERTYKEY(PKEY_GPS_Track, 0x76C09943, 0x7C33, 0x49E3, 0x9E, 0x7E, 0xCD, 0xBA, 0x87, 0x2C, 0xFA, 0xDA, 100);

//  Name:     System.GPS.TrackDenominator -- PKEY_GPS_TrackDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: C8D1920C-01F6-40C0-AC86-2F3A4AD00770, 100
//
//  Denominator of PKEY_GPS_Track
DEFINE_PROPERTYKEY(PKEY_GPS_TrackDenominator, 0xC8D1920C, 0x01F6, 0x40C0, 0xAC, 0x86, 0x2F, 0x3A, 0x4A, 0xD0, 0x07, 0x70, 100);

//  Name:     System.GPS.TrackNumerator -- PKEY_GPS_TrackNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 702926F4-44A6-43E1-AE71-45627116893B, 100
//
//  Numerator of PKEY_GPS_Track
DEFINE_PROPERTYKEY(PKEY_GPS_TrackNumerator, 0x702926F4, 0x44A6, 0x43E1, 0xAE, 0x71, 0x45, 0x62, 0x71, 0x16, 0x89, 0x3B, 100);

//  Name:     System.GPS.TrackRef -- PKEY_GPS_TrackRef
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 35DBE6FE-44C3-4400-AAAE-D2C799C407E8, 100
//
//  Indicates reference for the direction of the GPS receiver movement.  (eg: true direction, magnetic direction)
DEFINE_PROPERTYKEY(PKEY_GPS_TrackRef, 0x35DBE6FE, 0x44C3, 0x4400, 0xAA, 0xAE, 0xD2, 0xC7, 0x99, 0xC4, 0x07, 0xE8, 100);

//  Name:     System.GPS.VersionID -- PKEY_GPS_VersionID
//  Type:     Buffer -- VT_VECTOR | VT_UI1  (For variants: VT_ARRAY | VT_UI1)
//  FormatID: 22704DA4-C6B2-4A99-8E56-F16DF8C92599, 100
//
//  Indicates the version of the GPS information
DEFINE_PROPERTYKEY(PKEY_GPS_VersionID, 0x22704DA4, 0xC6B2, 0x4A99, 0x8E, 0x56, 0xF1, 0x6D, 0xF8, 0xC9, 0x25, 0x99, 100);
 
//-----------------------------------------------------------------------------
// Image properties



//  Name:     System.Image.BitDepth -- PKEY_Image_BitDepth
//  Type:     UInt32 -- VT_UI4
//  FormatID: (PSGUID_IMAGESUMMARYINFORMATION) 6444048F-4C8B-11D1-8B70-080036B11A03, 7 (PIDISI_BITDEPTH)
//
//  
DEFINE_PROPERTYKEY(PKEY_Image_BitDepth, 0x6444048F, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 7);

//  Name:     System.Image.ColorSpace -- PKEY_Image_ColorSpace
//  Type:     UInt16 -- VT_UI2
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 40961
//
//  PropertyTagExifColorSpace
DEFINE_PROPERTYKEY(PKEY_Image_ColorSpace, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 40961);

// Possible discrete values for PKEY_Image_ColorSpace are:
#define IMAGE_COLORSPACE_SRGB               1u
#define IMAGE_COLORSPACE_UNCALIBRATED       0xFFFFu

//  Name:     System.Image.CompressedBitsPerPixel -- PKEY_Image_CompressedBitsPerPixel
//  Type:     Double -- VT_R8
//  FormatID: 364B6FA9-37AB-482A-BE2B-AE02F60D4318, 100
//
//  Calculated from PKEY_Image_CompressedBitsPerPixelNumerator and PKEY_Image_CompressedBitsPerPixelDenominator.
DEFINE_PROPERTYKEY(PKEY_Image_CompressedBitsPerPixel, 0x364B6FA9, 0x37AB, 0x482A, 0xBE, 0x2B, 0xAE, 0x02, 0xF6, 0x0D, 0x43, 0x18, 100);

//  Name:     System.Image.CompressedBitsPerPixelDenominator -- PKEY_Image_CompressedBitsPerPixelDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 1F8844E1-24AD-4508-9DFD-5326A415CE02, 100
//
//  Denominator of PKEY_Image_CompressedBitsPerPixel.
DEFINE_PROPERTYKEY(PKEY_Image_CompressedBitsPerPixelDenominator, 0x1F8844E1, 0x24AD, 0x4508, 0x9D, 0xFD, 0x53, 0x26, 0xA4, 0x15, 0xCE, 0x02, 100);

//  Name:     System.Image.CompressedBitsPerPixelNumerator -- PKEY_Image_CompressedBitsPerPixelNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: D21A7148-D32C-4624-8900-277210F79C0F, 100
//
//  Numerator of PKEY_Image_CompressedBitsPerPixel.
DEFINE_PROPERTYKEY(PKEY_Image_CompressedBitsPerPixelNumerator, 0xD21A7148, 0xD32C, 0x4624, 0x89, 0x00, 0x27, 0x72, 0x10, 0xF7, 0x9C, 0x0F, 100);

//  Name:     System.Image.Compression -- PKEY_Image_Compression
//  Type:     UInt16 -- VT_UI2
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 259
//
//  Indicates the image compression level.  PropertyTagCompression.
DEFINE_PROPERTYKEY(PKEY_Image_Compression, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 259);

// Possible discrete values for PKEY_Image_Compression are:
#define IMAGE_COMPRESSION_UNCOMPRESSED      1u
#define IMAGE_COMPRESSION_CCITT_T3          2u
#define IMAGE_COMPRESSION_CCITT_T4          3u
#define IMAGE_COMPRESSION_CCITT_T6          4u
#define IMAGE_COMPRESSION_LZW               5u
#define IMAGE_COMPRESSION_JPEG              6u
#define IMAGE_COMPRESSION_PACKBITS          32773u

//  Name:     System.Image.CompressionText -- PKEY_Image_CompressionText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 3F08E66F-2F44-4BB9-A682-AC35D2562322, 100
//  
//  This is the user-friendly form of System.Image.Compression.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Image_CompressionText, 0x3F08E66F, 0x2F44, 0x4BB9, 0xA6, 0x82, 0xAC, 0x35, 0xD2, 0x56, 0x23, 0x22, 100);

//  Name:     System.Image.Dimensions -- PKEY_Image_Dimensions
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_IMAGESUMMARYINFORMATION) 6444048F-4C8B-11D1-8B70-080036B11A03, 13 (PIDISI_DIMENSIONS)
//
//  Indicates the dimensions of the image.
DEFINE_PROPERTYKEY(PKEY_Image_Dimensions, 0x6444048F, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 13);

//  Name:     System.Image.HorizontalResolution -- PKEY_Image_HorizontalResolution
//  Type:     Double -- VT_R8
//  FormatID: (PSGUID_IMAGESUMMARYINFORMATION) 6444048F-4C8B-11D1-8B70-080036B11A03, 5 (PIDISI_RESOLUTIONX)
//
//  
DEFINE_PROPERTYKEY(PKEY_Image_HorizontalResolution, 0x6444048F, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 5);

//  Name:     System.Image.HorizontalSize -- PKEY_Image_HorizontalSize
//  Type:     UInt32 -- VT_UI4
//  FormatID: (PSGUID_IMAGESUMMARYINFORMATION) 6444048F-4C8B-11D1-8B70-080036B11A03, 3 (PIDISI_CX)
//
//  
DEFINE_PROPERTYKEY(PKEY_Image_HorizontalSize, 0x6444048F, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 3);

//  Name:     System.Image.ImageID -- PKEY_Image_ImageID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 10DABE05-32AA-4C29-BF1A-63E2D220587F, 100
DEFINE_PROPERTYKEY(PKEY_Image_ImageID, 0x10DABE05, 0x32AA, 0x4C29, 0xBF, 0x1A, 0x63, 0xE2, 0xD2, 0x20, 0x58, 0x7F, 100);

//  Name:     System.Image.ResolutionUnit -- PKEY_Image_ResolutionUnit
//  Type:     Int16 -- VT_I2
//  FormatID: 19B51FA6-1F92-4A5C-AB48-7DF0ABD67444, 100
DEFINE_PROPERTYKEY(PKEY_Image_ResolutionUnit, 0x19B51FA6, 0x1F92, 0x4A5C, 0xAB, 0x48, 0x7D, 0xF0, 0xAB, 0xD6, 0x74, 0x44, 100);

//  Name:     System.Image.VerticalResolution -- PKEY_Image_VerticalResolution
//  Type:     Double -- VT_R8
//  FormatID: (PSGUID_IMAGESUMMARYINFORMATION) 6444048F-4C8B-11D1-8B70-080036B11A03, 6 (PIDISI_RESOLUTIONY)
//
//  
DEFINE_PROPERTYKEY(PKEY_Image_VerticalResolution, 0x6444048F, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 6);

//  Name:     System.Image.VerticalSize -- PKEY_Image_VerticalSize
//  Type:     UInt32 -- VT_UI4
//  FormatID: (PSGUID_IMAGESUMMARYINFORMATION) 6444048F-4C8B-11D1-8B70-080036B11A03, 4 (PIDISI_CY)
//
//  
DEFINE_PROPERTYKEY(PKEY_Image_VerticalSize, 0x6444048F, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 4);

 
 
//-----------------------------------------------------------------------------
// Journal properties

//  Name:     System.Journal.Contacts -- PKEY_Journal_Contacts
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: DEA7C82C-1D89-4A66-9427-A4E3DEBABCB1, 100
DEFINE_PROPERTYKEY(PKEY_Journal_Contacts, 0xDEA7C82C, 0x1D89, 0x4A66, 0x94, 0x27, 0xA4, 0xE3, 0xDE, 0xBA, 0xBC, 0xB1, 100);

//  Name:     System.Journal.EntryType -- PKEY_Journal_EntryType
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 95BEB1FC-326D-4644-B396-CD3ED90E6DDF, 100
DEFINE_PROPERTYKEY(PKEY_Journal_EntryType, 0x95BEB1FC, 0x326D, 0x4644, 0xB3, 0x96, 0xCD, 0x3E, 0xD9, 0x0E, 0x6D, 0xDF, 100);
 
//-----------------------------------------------------------------------------
// Link properties



//  Name:     System.Link.Comment -- PKEY_Link_Comment
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_LINK) B9B4B3FC-2B51-4A42-B5D8-324146AFCF25, 5
DEFINE_PROPERTYKEY(PKEY_Link_Comment, 0xB9B4B3FC, 0x2B51, 0x4A42, 0xB5, 0xD8, 0x32, 0x41, 0x46, 0xAF, 0xCF, 0x25, 5);

//  Name:     System.Link.DateVisited -- PKEY_Link_DateVisited
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: 5CBF2787-48CF-4208-B90E-EE5E5D420294, 23  (PKEYs relating to URLs.  Used by IE History.)
DEFINE_PROPERTYKEY(PKEY_Link_DateVisited, 0x5CBF2787, 0x48CF, 0x4208, 0xB9, 0x0E, 0xEE, 0x5E, 0x5D, 0x42, 0x02, 0x94, 23);

//  Name:     System.Link.Description -- PKEY_Link_Description
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 5CBF2787-48CF-4208-B90E-EE5E5D420294, 21  (PKEYs relating to URLs.  Used by IE History.)
DEFINE_PROPERTYKEY(PKEY_Link_Description, 0x5CBF2787, 0x48CF, 0x4208, 0xB9, 0x0E, 0xEE, 0x5E, 0x5D, 0x42, 0x02, 0x94, 21);

//  Name:     System.Link.Status -- PKEY_Link_Status
//  Type:     Int32 -- VT_I4
//  FormatID: (PSGUID_LINK) B9B4B3FC-2B51-4A42-B5D8-324146AFCF25, 3 (PID_LINK_TARGET_TYPE)
//
//  
DEFINE_PROPERTYKEY(PKEY_Link_Status, 0xB9B4B3FC, 0x2B51, 0x4A42, 0xB5, 0xD8, 0x32, 0x41, 0x46, 0xAF, 0xCF, 0x25, 3);

// Possible discrete values for PKEY_Link_Status are:
#define LINK_STATUS_RESOLVED                1l
#define LINK_STATUS_BROKEN                  2l

//  Name:     System.Link.TargetExtension -- PKEY_Link_TargetExtension
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: 7A7D76F4-B630-4BD7-95FF-37CC51A975C9, 2
//
//  The file extension of the link target.  See System.File.Extension
DEFINE_PROPERTYKEY(PKEY_Link_TargetExtension, 0x7A7D76F4, 0xB630, 0x4BD7, 0x95, 0xFF, 0x37, 0xCC, 0x51, 0xA9, 0x75, 0xC9, 2);

//  Name:     System.Link.TargetParsingPath -- PKEY_Link_TargetParsingPath
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_LINK) B9B4B3FC-2B51-4A42-B5D8-324146AFCF25, 2 (PID_LINK_TARGET)
//  
//  This is the shell namespace path to the target of the link item.  This path may be passed to 
//  SHParseDisplayName to parse the path to the correct shell folder.
//  
//  If the target item is a file, the value is identical to System.ItemPathDisplay.
//  
//  If the target item cannot be accessed through the shell namespace, this value is VT_EMPTY.
DEFINE_PROPERTYKEY(PKEY_Link_TargetParsingPath, 0xB9B4B3FC, 0x2B51, 0x4A42, 0xB5, 0xD8, 0x32, 0x41, 0x46, 0xAF, 0xCF, 0x25, 2);

//  Name:     System.Link.TargetSFGAOFlags -- PKEY_Link_TargetSFGAOFlags
//  Type:     UInt32 -- VT_UI4
//  FormatID: (PSGUID_LINK) B9B4B3FC-2B51-4A42-B5D8-324146AFCF25, 8
//  
//  IShellFolder::GetAttributesOf flags for the target of a link, with SFGAO_PKEYSFGAOMASK 
//  attributes masked out.
DEFINE_PROPERTYKEY(PKEY_Link_TargetSFGAOFlags, 0xB9B4B3FC, 0x2B51, 0x4A42, 0xB5, 0xD8, 0x32, 0x41, 0x46, 0xAF, 0xCF, 0x25, 8);
 
//-----------------------------------------------------------------------------
// Media properties



//  Name:     System.Media.AuthorUrl -- PKEY_Media_AuthorUrl
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 32 (PIDMSI_AUTHOR_URL)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_AuthorUrl, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 32);

//  Name:     System.Media.AverageLevel -- PKEY_Media_AverageLevel
//  Type:     UInt32 -- VT_UI4
//  FormatID: 09EDD5B6-B301-43C5-9990-D00302EFFD46, 100
DEFINE_PROPERTYKEY(PKEY_Media_AverageLevel, 0x09EDD5B6, 0xB301, 0x43C5, 0x99, 0x90, 0xD0, 0x03, 0x02, 0xEF, 0xFD, 0x46, 100);

//  Name:     System.Media.ClassPrimaryID -- PKEY_Media_ClassPrimaryID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 13 (PIDMSI_CLASS_PRIMARY_ID)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_ClassPrimaryID, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 13);

//  Name:     System.Media.ClassSecondaryID -- PKEY_Media_ClassSecondaryID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 14 (PIDMSI_CLASS_SECONDARY_ID)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_ClassSecondaryID, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 14);

//  Name:     System.Media.CollectionGroupID -- PKEY_Media_CollectionGroupID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 24 (PIDMSI_COLLECTION_GROUP_ID)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_CollectionGroupID, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 24);

//  Name:     System.Media.CollectionID -- PKEY_Media_CollectionID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 25 (PIDMSI_COLLECTION_ID)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_CollectionID, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 25);

//  Name:     System.Media.ContentDistributor -- PKEY_Media_ContentDistributor
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 18 (PIDMSI_CONTENTDISTRIBUTOR)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_ContentDistributor, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 18);

//  Name:     System.Media.ContentID -- PKEY_Media_ContentID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 26 (PIDMSI_CONTENT_ID)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_ContentID, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 26);

//  Name:     System.Media.CreatorApplication -- PKEY_Media_CreatorApplication
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 27 (PIDMSI_TOOL_NAME)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_CreatorApplication, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 27);

//  Name:     System.Media.CreatorApplicationVersion -- PKEY_Media_CreatorApplicationVersion
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 28 (PIDMSI_TOOL_VERSION)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_CreatorApplicationVersion, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 28);

//  Name:     System.Media.DateEncoded -- PKEY_Media_DateEncoded
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: 2E4B640D-5019-46D8-8881-55414CC5CAA0, 100
//
//  DateTime is in UTC (in the doc, not file system).
DEFINE_PROPERTYKEY(PKEY_Media_DateEncoded, 0x2E4B640D, 0x5019, 0x46D8, 0x88, 0x81, 0x55, 0x41, 0x4C, 0xC5, 0xCA, 0xA0, 100);

//  Name:     System.Media.DateReleased -- PKEY_Media_DateReleased
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: DE41CC29-6971-4290-B472-F59F2E2F31E2, 100
DEFINE_PROPERTYKEY(PKEY_Media_DateReleased, 0xDE41CC29, 0x6971, 0x4290, 0xB4, 0x72, 0xF5, 0x9F, 0x2E, 0x2F, 0x31, 0xE2, 100);

//  Name:     System.Media.Duration -- PKEY_Media_Duration
//  Type:     UInt64 -- VT_UI8
//  FormatID: (FMTID_AudioSummaryInformation) 64440490-4C8B-11D1-8B70-080036B11A03, 3 (PIDASI_TIMELENGTH)
//
//  100ns units, not milliseconds
DEFINE_PROPERTYKEY(PKEY_Media_Duration, 0x64440490, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 3);

//  Name:     System.Media.DVDID -- PKEY_Media_DVDID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 15 (PIDMSI_DVDID)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_DVDID, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 15);

//  Name:     System.Media.EncodedBy -- PKEY_Media_EncodedBy
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 36 (PIDMSI_ENCODED_BY)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_EncodedBy, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 36);

//  Name:     System.Media.EncodingSettings -- PKEY_Media_EncodingSettings
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 37 (PIDMSI_ENCODING_SETTINGS)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_EncodingSettings, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 37);

//  Name:     System.Media.FrameCount -- PKEY_Media_FrameCount
//  Type:     UInt32 -- VT_UI4
//  FormatID: (PSGUID_IMAGESUMMARYINFORMATION) 6444048F-4C8B-11D1-8B70-080036B11A03, 12 (PIDISI_FRAMECOUNT)
//
//  Indicates the frame count for the image.
DEFINE_PROPERTYKEY(PKEY_Media_FrameCount, 0x6444048F, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 12);

//  Name:     System.Media.MCDI -- PKEY_Media_MCDI
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 16 (PIDMSI_MCDI)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_MCDI, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 16);

//  Name:     System.Media.MetadataContentProvider -- PKEY_Media_MetadataContentProvider
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 17 (PIDMSI_PROVIDER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_MetadataContentProvider, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 17);

//  Name:     System.Media.Producer -- PKEY_Media_Producer
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 22 (PIDMSI_PRODUCER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_Producer, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 22);

//  Name:     System.Media.PromotionUrl -- PKEY_Media_PromotionUrl
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 33 (PIDMSI_PROMOTION_URL)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_PromotionUrl, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 33);

//  Name:     System.Media.ProtectionType -- PKEY_Media_ProtectionType
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 38
//  
//  If media is protected, how is it protected?
DEFINE_PROPERTYKEY(PKEY_Media_ProtectionType, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 38);

//  Name:     System.Media.ProviderRating -- PKEY_Media_ProviderRating
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 39
//  
//  Rating (0 - 99) supplied by metadata provider
DEFINE_PROPERTYKEY(PKEY_Media_ProviderRating, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 39);

//  Name:     System.Media.ProviderStyle -- PKEY_Media_ProviderStyle
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 40
//  
//  Style of music or video, supplied by metadata provider
DEFINE_PROPERTYKEY(PKEY_Media_ProviderStyle, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 40);

//  Name:     System.Media.Publisher -- PKEY_Media_Publisher
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 30 (PIDMSI_PUBLISHER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_Publisher, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 30);

//  Name:     System.Media.SubscriptionContentId -- PKEY_Media_SubscriptionContentId
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 9AEBAE7A-9644-487D-A92C-657585ED751A, 100
DEFINE_PROPERTYKEY(PKEY_Media_SubscriptionContentId, 0x9AEBAE7A, 0x9644, 0x487D, 0xA9, 0x2C, 0x65, 0x75, 0x85, 0xED, 0x75, 0x1A, 100);

//  Name:     System.Media.SubTitle -- PKEY_Media_SubTitle
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 38 (PIDSI_MUSIC_SUB_TITLE)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_SubTitle, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 38);

//  Name:     System.Media.UniqueFileIdentifier -- PKEY_Media_UniqueFileIdentifier
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 35 (PIDMSI_UNIQUE_FILE_IDENTIFIER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_UniqueFileIdentifier, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 35);

//  Name:     System.Media.UserNoAutoInfo -- PKEY_Media_UserNoAutoInfo
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 41
//  
//  If true, do NOT alter this file's metadata. Set by user.
DEFINE_PROPERTYKEY(PKEY_Media_UserNoAutoInfo, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 41);

//  Name:     System.Media.UserWebUrl -- PKEY_Media_UserWebUrl
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 34 (PIDMSI_USER_WEB_URL)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_UserWebUrl, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 34);

//  Name:     System.Media.Writer -- PKEY_Media_Writer
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 23 (PIDMSI_WRITER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_Writer, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 23);

//  Name:     System.Media.Year -- PKEY_Media_Year
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 5 (PIDSI_MUSIC_YEAR)
//
//  
DEFINE_PROPERTYKEY(PKEY_Media_Year, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 5);
 
//-----------------------------------------------------------------------------
// Message properties



//  Name:     System.Message.AttachmentContents -- PKEY_Message_AttachmentContents
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 3143BF7C-80A8-4854-8880-E2E40189BDD0, 100
DEFINE_PROPERTYKEY(PKEY_Message_AttachmentContents, 0x3143BF7C, 0x80A8, 0x4854, 0x88, 0x80, 0xE2, 0xE4, 0x01, 0x89, 0xBD, 0xD0, 100);

//  Name:     System.Message.AttachmentNames -- PKEY_Message_AttachmentNames
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 21
//
//  The names of the attachments in a message
DEFINE_PROPERTYKEY(PKEY_Message_AttachmentNames, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 21);

//  Name:     System.Message.BccAddress -- PKEY_Message_BccAddress
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 2
//
//  Addresses in Bcc: field
DEFINE_PROPERTYKEY(PKEY_Message_BccAddress, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 2);

//  Name:     System.Message.BccName -- PKEY_Message_BccName
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 3
//
//  person names in Bcc: field
DEFINE_PROPERTYKEY(PKEY_Message_BccName, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 3);

//  Name:     System.Message.CcAddress -- PKEY_Message_CcAddress
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 4
//
//  Addresses in Cc: field
DEFINE_PROPERTYKEY(PKEY_Message_CcAddress, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 4);

//  Name:     System.Message.CcName -- PKEY_Message_CcName
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 5
//
//  person names in Cc: field
DEFINE_PROPERTYKEY(PKEY_Message_CcName, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 5);

//  Name:     System.Message.ConversationID -- PKEY_Message_ConversationID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: DC8F80BD-AF1E-4289-85B6-3DFC1B493992, 100
DEFINE_PROPERTYKEY(PKEY_Message_ConversationID, 0xDC8F80BD, 0xAF1E, 0x4289, 0x85, 0xB6, 0x3D, 0xFC, 0x1B, 0x49, 0x39, 0x92, 100);

//  Name:     System.Message.ConversationIndex -- PKEY_Message_ConversationIndex
//  Type:     Buffer -- VT_VECTOR | VT_UI1  (For variants: VT_ARRAY | VT_UI1)
//  FormatID: DC8F80BD-AF1E-4289-85B6-3DFC1B493992, 101
//  
//  
DEFINE_PROPERTYKEY(PKEY_Message_ConversationIndex, 0xDC8F80BD, 0xAF1E, 0x4289, 0x85, 0xB6, 0x3D, 0xFC, 0x1B, 0x49, 0x39, 0x92, 101);

//  Name:     System.Message.DateReceived -- PKEY_Message_DateReceived
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 20
//
//  Date and Time communication was received
DEFINE_PROPERTYKEY(PKEY_Message_DateReceived, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 20);

//  Name:     System.Message.DateSent -- PKEY_Message_DateSent
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 19
//
//  Date and Time communication was sent
DEFINE_PROPERTYKEY(PKEY_Message_DateSent, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 19);

//  Name:     System.Message.FromAddress -- PKEY_Message_FromAddress
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 13
DEFINE_PROPERTYKEY(PKEY_Message_FromAddress, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 13);

//  Name:     System.Message.FromName -- PKEY_Message_FromName
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 14
//
//  Address in from field as person name
DEFINE_PROPERTYKEY(PKEY_Message_FromName, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 14);

//  Name:     System.Message.HasAttachments -- PKEY_Message_HasAttachments
//  Type:     Boolean -- VT_BOOL
//  FormatID: 9C1FCF74-2D97-41BA-B4AE-CB2E3661A6E4, 8
//
//  
DEFINE_PROPERTYKEY(PKEY_Message_HasAttachments, 0x9C1FCF74, 0x2D97, 0x41BA, 0xB4, 0xAE, 0xCB, 0x2E, 0x36, 0x61, 0xA6, 0xE4, 8);

//  Name:     System.Message.IsFwdOrReply -- PKEY_Message_IsFwdOrReply
//  Type:     Int32 -- VT_I4
//  FormatID: 9A9BC088-4F6D-469E-9919-E705412040F9, 100
DEFINE_PROPERTYKEY(PKEY_Message_IsFwdOrReply, 0x9A9BC088, 0x4F6D, 0x469E, 0x99, 0x19, 0xE7, 0x05, 0x41, 0x20, 0x40, 0xF9, 100);

//  Name:     System.Message.MessageClass -- PKEY_Message_MessageClass
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: CD9ED458-08CE-418F-A70E-F912C7BB9C5C, 103
//  
//  What type of outlook msg this is (meeting, task, mail, etc.)
DEFINE_PROPERTYKEY(PKEY_Message_MessageClass, 0xCD9ED458, 0x08CE, 0x418F, 0xA7, 0x0E, 0xF9, 0x12, 0xC7, 0xBB, 0x9C, 0x5C, 103);

//  Name:     System.Message.SenderAddress -- PKEY_Message_SenderAddress
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 0BE1C8E7-1981-4676-AE14-FDD78F05A6E7, 100
DEFINE_PROPERTYKEY(PKEY_Message_SenderAddress, 0x0BE1C8E7, 0x1981, 0x4676, 0xAE, 0x14, 0xFD, 0xD7, 0x8F, 0x05, 0xA6, 0xE7, 100);

//  Name:     System.Message.SenderName -- PKEY_Message_SenderName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 0DA41CFA-D224-4A18-AE2F-596158DB4B3A, 100
DEFINE_PROPERTYKEY(PKEY_Message_SenderName, 0x0DA41CFA, 0xD224, 0x4A18, 0xAE, 0x2F, 0x59, 0x61, 0x58, 0xDB, 0x4B, 0x3A, 100);

//  Name:     System.Message.Store -- PKEY_Message_Store
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 15
//
//  The store (aka protocol handler) FILE, MAIL, OUTLOOKEXPRESS
DEFINE_PROPERTYKEY(PKEY_Message_Store, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 15);

//  Name:     System.Message.ToAddress -- PKEY_Message_ToAddress
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 16
//
//  Addresses in To: field
DEFINE_PROPERTYKEY(PKEY_Message_ToAddress, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 16);

//  Name:     System.Message.ToDoTitle -- PKEY_Message_ToDoTitle
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: BCCC8A3C-8CEF-42E5-9B1C-C69079398BC7, 100
DEFINE_PROPERTYKEY(PKEY_Message_ToDoTitle, 0xBCCC8A3C, 0x8CEF, 0x42E5, 0x9B, 0x1C, 0xC6, 0x90, 0x79, 0x39, 0x8B, 0xC7, 100);

//  Name:     System.Message.ToName -- PKEY_Message_ToName
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: E3E0584C-B788-4A5A-BB20-7F5A44C9ACDD, 17
//
//  Person names in To: field
DEFINE_PROPERTYKEY(PKEY_Message_ToName, 0xE3E0584C, 0xB788, 0x4A5A, 0xBB, 0x20, 0x7F, 0x5A, 0x44, 0xC9, 0xAC, 0xDD, 17);
 
//-----------------------------------------------------------------------------
// Music properties

//  Name:     System.Music.AlbumArtist -- PKEY_Music_AlbumArtist
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 13 (PIDSI_MUSIC_ALBUM_ARTIST)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_AlbumArtist, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 13);

//  Name:     System.Music.AlbumTitle -- PKEY_Music_AlbumTitle
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 4 (PIDSI_MUSIC_ALBUM)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_AlbumTitle, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 4);

//  Name:     System.Music.Artist -- PKEY_Music_Artist
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 2 (PIDSI_MUSIC_ARTIST)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_Artist, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 2);

//  Name:     System.Music.BeatsPerMinute -- PKEY_Music_BeatsPerMinute
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 35 (PIDSI_MUSIC_BEATS_PER_MINUTE)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_BeatsPerMinute, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 35);

//  Name:     System.Music.Composer -- PKEY_Music_Composer
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 19 (PIDMSI_COMPOSER)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_Composer, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 19);

//  Name:     System.Music.Conductor -- PKEY_Music_Conductor
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 36 (PIDSI_MUSIC_CONDUCTOR)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_Conductor, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 36);

//  Name:     System.Music.ContentGroupDescription -- PKEY_Music_ContentGroupDescription
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 33 (PIDSI_MUSIC_CONTENT_GROUP_DESCRIPTION)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_ContentGroupDescription, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 33);

//  Name:     System.Music.Genre -- PKEY_Music_Genre
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 11 (PIDSI_MUSIC_GENRE)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_Genre, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 11);

//  Name:     System.Music.InitialKey -- PKEY_Music_InitialKey
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 34 (PIDSI_MUSIC_INITIAL_KEY)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_InitialKey, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 34);

//  Name:     System.Music.Lyrics -- PKEY_Music_Lyrics
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 12 (PIDSI_MUSIC_LYRICS)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_Lyrics, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 12);

//  Name:     System.Music.Mood -- PKEY_Music_Mood
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 39 (PIDSI_MUSIC_MOOD)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_Mood, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 39);

//  Name:     System.Music.PartOfSet -- PKEY_Music_PartOfSet
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 37 (PIDSI_MUSIC_PART_OF_SET)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_PartOfSet, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 37);

//  Name:     System.Music.Period -- PKEY_Music_Period
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 31 (PIDMSI_PERIOD)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_Period, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 31);

//  Name:     System.Music.SynchronizedLyrics -- PKEY_Music_SynchronizedLyrics
//  Type:     Blob -- VT_BLOB
//  FormatID: 6B223B6A-162E-4AA9-B39F-05D678FC6D77, 100
DEFINE_PROPERTYKEY(PKEY_Music_SynchronizedLyrics, 0x6B223B6A, 0x162E, 0x4AA9, 0xB3, 0x9F, 0x05, 0xD6, 0x78, 0xFC, 0x6D, 0x77, 100);

//  Name:     System.Music.TrackNumber -- PKEY_Music_TrackNumber
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_MUSIC) 56A3372E-CE9C-11D2-9F0E-006097C686F6, 7 (PIDSI_MUSIC_TRACK)
//
//  
DEFINE_PROPERTYKEY(PKEY_Music_TrackNumber, 0x56A3372E, 0xCE9C, 0x11D2, 0x9F, 0x0E, 0x00, 0x60, 0x97, 0xC6, 0x86, 0xF6, 7);

 
 
//-----------------------------------------------------------------------------
// Note properties

//  Name:     System.Note.Color -- PKEY_Note_Color
//  Type:     UInt16 -- VT_UI2
//  FormatID: 4776CAFA-BCE4-4CB1-A23E-265E76D8EB11, 100
DEFINE_PROPERTYKEY(PKEY_Note_Color, 0x4776CAFA, 0xBCE4, 0x4CB1, 0xA2, 0x3E, 0x26, 0x5E, 0x76, 0xD8, 0xEB, 0x11, 100);

// Possible discrete values for PKEY_Note_Color are:
#define NOTE_COLOR_BLUE                     0u
#define NOTE_COLOR_GREEN                    1u
#define NOTE_COLOR_PINK                     2u
#define NOTE_COLOR_YELLOW                   3u
#define NOTE_COLOR_WHITE                    4u
#define NOTE_COLOR_LIGHTGREEN               5u

//  Name:     System.Note.ColorText -- PKEY_Note_ColorText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 46B4E8DE-CDB2-440D-885C-1658EB65B914, 100
//  
//  This is the user-friendly form of System.Note.Color.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Note_ColorText, 0x46B4E8DE, 0xCDB2, 0x440D, 0x88, 0x5C, 0x16, 0x58, 0xEB, 0x65, 0xB9, 0x14, 100);
 
//-----------------------------------------------------------------------------
// Photo properties



//  Name:     System.Photo.Aperture -- PKEY_Photo_Aperture
//  Type:     Double -- VT_R8
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 37378
//
//  PropertyTagExifAperture.  Calculated from PKEY_Photo_ApertureNumerator and PKEY_Photo_ApertureDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_Aperture, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 37378);

//  Name:     System.Photo.ApertureDenominator -- PKEY_Photo_ApertureDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: E1A9A38B-6685-46BD-875E-570DC7AD7320, 100
//
//  Denominator of PKEY_Photo_Aperture
DEFINE_PROPERTYKEY(PKEY_Photo_ApertureDenominator, 0xE1A9A38B, 0x6685, 0x46BD, 0x87, 0x5E, 0x57, 0x0D, 0xC7, 0xAD, 0x73, 0x20, 100);

//  Name:     System.Photo.ApertureNumerator -- PKEY_Photo_ApertureNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 0337ECEC-39FB-4581-A0BD-4C4CC51E9914, 100
//
//  Numerator of PKEY_Photo_Aperture
DEFINE_PROPERTYKEY(PKEY_Photo_ApertureNumerator, 0x0337ECEC, 0x39FB, 0x4581, 0xA0, 0xBD, 0x4C, 0x4C, 0xC5, 0x1E, 0x99, 0x14, 100);

//  Name:     System.Photo.Brightness -- PKEY_Photo_Brightness
//  Type:     Double -- VT_R8
//  FormatID: 1A701BF6-478C-4361-83AB-3701BB053C58, 100 (PropertyTagExifBrightness)
//  
//  This is the brightness of the photo.
//  
//  Calculated from PKEY_Photo_BrightnessNumerator and PKEY_Photo_BrightnessDenominator.
//  
//  The units are "APEX", normally in the range of -99.99 to 99.99. If the numerator of 
//  the recorded value is FFFFFFFF.H, "Unknown" should be indicated.
DEFINE_PROPERTYKEY(PKEY_Photo_Brightness, 0x1A701BF6, 0x478C, 0x4361, 0x83, 0xAB, 0x37, 0x01, 0xBB, 0x05, 0x3C, 0x58, 100);

//  Name:     System.Photo.BrightnessDenominator -- PKEY_Photo_BrightnessDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 6EBE6946-2321-440A-90F0-C043EFD32476, 100
//
//  Denominator of PKEY_Photo_Brightness
DEFINE_PROPERTYKEY(PKEY_Photo_BrightnessDenominator, 0x6EBE6946, 0x2321, 0x440A, 0x90, 0xF0, 0xC0, 0x43, 0xEF, 0xD3, 0x24, 0x76, 100);

//  Name:     System.Photo.BrightnessNumerator -- PKEY_Photo_BrightnessNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 9E7D118F-B314-45A0-8CFB-D654B917C9E9, 100
//
//  Numerator of PKEY_Photo_Brightness
DEFINE_PROPERTYKEY(PKEY_Photo_BrightnessNumerator, 0x9E7D118F, 0xB314, 0x45A0, 0x8C, 0xFB, 0xD6, 0x54, 0xB9, 0x17, 0xC9, 0xE9, 100);

//  Name:     System.Photo.CameraManufacturer -- PKEY_Photo_CameraManufacturer
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 271 (PropertyTagEquipMake)
//
//  
DEFINE_PROPERTYKEY(PKEY_Photo_CameraManufacturer, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 271);

//  Name:     System.Photo.CameraModel -- PKEY_Photo_CameraModel
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 272 (PropertyTagEquipModel)
//
//  
DEFINE_PROPERTYKEY(PKEY_Photo_CameraModel, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 272);

//  Name:     System.Photo.CameraSerialNumber -- PKEY_Photo_CameraSerialNumber
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 273
//
//  Serial number of camera that produced this photo
DEFINE_PROPERTYKEY(PKEY_Photo_CameraSerialNumber, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 273);

//  Name:     System.Photo.Contrast -- PKEY_Photo_Contrast
//  Type:     UInt32 -- VT_UI4
//  FormatID: 2A785BA9-8D23-4DED-82E6-60A350C86A10, 100
//  
//  This indicates the direction of contrast processing applied by the camera 
//  when the image was shot.
DEFINE_PROPERTYKEY(PKEY_Photo_Contrast, 0x2A785BA9, 0x8D23, 0x4DED, 0x82, 0xE6, 0x60, 0xA3, 0x50, 0xC8, 0x6A, 0x10, 100);

// Possible discrete values for PKEY_Photo_Contrast are:
#define PHOTO_CONTRAST_NORMAL               0ul
#define PHOTO_CONTRAST_SOFT                 1ul
#define PHOTO_CONTRAST_HARD                 2ul

//  Name:     System.Photo.ContrastText -- PKEY_Photo_ContrastText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 59DDE9F2-5253-40EA-9A8B-479E96C6249A, 100
//  
//  This is the user-friendly form of System.Photo.Contrast.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_ContrastText, 0x59DDE9F2, 0x5253, 0x40EA, 0x9A, 0x8B, 0x47, 0x9E, 0x96, 0xC6, 0x24, 0x9A, 100);

//  Name:     System.Photo.DateTaken -- PKEY_Photo_DateTaken
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 36867
//
//  PropertyTagExifDTOrig
DEFINE_PROPERTYKEY(PKEY_Photo_DateTaken, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 36867);

//  Name:     System.Photo.DigitalZoom -- PKEY_Photo_DigitalZoom
//  Type:     Double -- VT_R8
//  FormatID: F85BF840-A925-4BC2-B0C4-8E36B598679E, 100
//
//  PropertyTagExifDigitalZoom.  Calculated from PKEY_Photo_DigitalZoomNumerator and PKEY_Photo_DigitalZoomDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_DigitalZoom, 0xF85BF840, 0xA925, 0x4BC2, 0xB0, 0xC4, 0x8E, 0x36, 0xB5, 0x98, 0x67, 0x9E, 100);

//  Name:     System.Photo.DigitalZoomDenominator -- PKEY_Photo_DigitalZoomDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 745BAF0E-E5C1-4CFB-8A1B-D031A0A52393, 100
//
//  Denominator of PKEY_Photo_DigitalZoom
DEFINE_PROPERTYKEY(PKEY_Photo_DigitalZoomDenominator, 0x745BAF0E, 0xE5C1, 0x4CFB, 0x8A, 0x1B, 0xD0, 0x31, 0xA0, 0xA5, 0x23, 0x93, 100);

//  Name:     System.Photo.DigitalZoomNumerator -- PKEY_Photo_DigitalZoomNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 16CBB924-6500-473B-A5BE-F1599BCBE413, 100
//
//  Numerator of PKEY_Photo_DigitalZoom
DEFINE_PROPERTYKEY(PKEY_Photo_DigitalZoomNumerator, 0x16CBB924, 0x6500, 0x473B, 0xA5, 0xBE, 0xF1, 0x59, 0x9B, 0xCB, 0xE4, 0x13, 100);

//  Name:     System.Photo.Event -- PKEY_Photo_Event
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 18248
//
//  The event at which the photo was taken
DEFINE_PROPERTYKEY(PKEY_Photo_Event, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 18248);

//  Name:     System.Photo.EXIFVersion -- PKEY_Photo_EXIFVersion
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: D35F743A-EB2E-47F2-A286-844132CB1427, 100
//
//  The EXIF version.
DEFINE_PROPERTYKEY(PKEY_Photo_EXIFVersion, 0xD35F743A, 0xEB2E, 0x47F2, 0xA2, 0x86, 0x84, 0x41, 0x32, 0xCB, 0x14, 0x27, 100);

//  Name:     System.Photo.ExposureBias -- PKEY_Photo_ExposureBias
//  Type:     Double -- VT_R8
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 37380
//
//  PropertyTagExifExposureBias.  Calculated from PKEY_Photo_ExposureBiasNumerator and PKEY_Photo_ExposureBiasDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureBias, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 37380);

//  Name:     System.Photo.ExposureBiasDenominator -- PKEY_Photo_ExposureBiasDenominator
//  Type:     Int32 -- VT_I4
//  FormatID: AB205E50-04B7-461C-A18C-2F233836E627, 100
//
//  Denominator of PKEY_Photo_ExposureBias
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureBiasDenominator, 0xAB205E50, 0x04B7, 0x461C, 0xA1, 0x8C, 0x2F, 0x23, 0x38, 0x36, 0xE6, 0x27, 100);

//  Name:     System.Photo.ExposureBiasNumerator -- PKEY_Photo_ExposureBiasNumerator
//  Type:     Int32 -- VT_I4
//  FormatID: 738BF284-1D87-420B-92CF-5834BF6EF9ED, 100
//
//  Numerator of PKEY_Photo_ExposureBias
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureBiasNumerator, 0x738BF284, 0x1D87, 0x420B, 0x92, 0xCF, 0x58, 0x34, 0xBF, 0x6E, 0xF9, 0xED, 100);

//  Name:     System.Photo.ExposureIndex -- PKEY_Photo_ExposureIndex
//  Type:     Double -- VT_R8
//  FormatID: 967B5AF8-995A-46ED-9E11-35B3C5B9782D, 100
//
//  PropertyTagExifExposureIndex.  Calculated from PKEY_Photo_ExposureIndexNumerator and PKEY_Photo_ExposureIndexDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureIndex, 0x967B5AF8, 0x995A, 0x46ED, 0x9E, 0x11, 0x35, 0xB3, 0xC5, 0xB9, 0x78, 0x2D, 100);

//  Name:     System.Photo.ExposureIndexDenominator -- PKEY_Photo_ExposureIndexDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 93112F89-C28B-492F-8A9D-4BE2062CEE8A, 100
//
//  Denominator of PKEY_Photo_ExposureIndex
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureIndexDenominator, 0x93112F89, 0xC28B, 0x492F, 0x8A, 0x9D, 0x4B, 0xE2, 0x06, 0x2C, 0xEE, 0x8A, 100);

//  Name:     System.Photo.ExposureIndexNumerator -- PKEY_Photo_ExposureIndexNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: CDEDCF30-8919-44DF-8F4C-4EB2FFDB8D89, 100
//
//  Numerator of PKEY_Photo_ExposureIndex
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureIndexNumerator, 0xCDEDCF30, 0x8919, 0x44DF, 0x8F, 0x4C, 0x4E, 0xB2, 0xFF, 0xDB, 0x8D, 0x89, 100);

//  Name:     System.Photo.ExposureProgram -- PKEY_Photo_ExposureProgram
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 34850 (PropertyTagExifExposureProg)
//
//  
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureProgram, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 34850);

// Possible discrete values for PKEY_Photo_ExposureProgram are:
#define PHOTO_EXPOSUREPROGRAM_UNKNOWN       0ul
#define PHOTO_EXPOSUREPROGRAM_MANUAL        1ul
#define PHOTO_EXPOSUREPROGRAM_NORMAL        2ul
#define PHOTO_EXPOSUREPROGRAM_APERTURE      3ul
#define PHOTO_EXPOSUREPROGRAM_SHUTTER       4ul
#define PHOTO_EXPOSUREPROGRAM_CREATIVE      5ul
#define PHOTO_EXPOSUREPROGRAM_ACTION        6ul
#define PHOTO_EXPOSUREPROGRAM_PORTRAIT      7ul
#define PHOTO_EXPOSUREPROGRAM_LANDSCAPE     8ul

//  Name:     System.Photo.ExposureProgramText -- PKEY_Photo_ExposureProgramText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: FEC690B7-5F30-4646-AE47-4CAAFBA884A3, 100
//  
//  This is the user-friendly form of System.Photo.ExposureProgram.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureProgramText, 0xFEC690B7, 0x5F30, 0x4646, 0xAE, 0x47, 0x4C, 0xAA, 0xFB, 0xA8, 0x84, 0xA3, 100);

//  Name:     System.Photo.ExposureTime -- PKEY_Photo_ExposureTime
//  Type:     Double -- VT_R8
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 33434
//
//  PropertyTagExifExposureTime.  Calculated from  PKEY_Photo_ExposureTimeNumerator and PKEY_Photo_ExposureTimeDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureTime, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 33434);

//  Name:     System.Photo.ExposureTimeDenominator -- PKEY_Photo_ExposureTimeDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 55E98597-AD16-42E0-B624-21599A199838, 100
//
//  Denominator of PKEY_Photo_ExposureTime
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureTimeDenominator, 0x55E98597, 0xAD16, 0x42E0, 0xB6, 0x24, 0x21, 0x59, 0x9A, 0x19, 0x98, 0x38, 100);

//  Name:     System.Photo.ExposureTimeNumerator -- PKEY_Photo_ExposureTimeNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 257E44E2-9031-4323-AC38-85C552871B2E, 100
//
//  Numerator of PKEY_Photo_ExposureTime
DEFINE_PROPERTYKEY(PKEY_Photo_ExposureTimeNumerator, 0x257E44E2, 0x9031, 0x4323, 0xAC, 0x38, 0x85, 0xC5, 0x52, 0x87, 0x1B, 0x2E, 100);

//  Name:     System.Photo.Flash -- PKEY_Photo_Flash
//  Type:     Byte -- VT_UI1
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 37385
//
//  PropertyTagExifFlash
DEFINE_PROPERTYKEY(PKEY_Photo_Flash, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 37385);

// Possible discrete values for PKEY_Photo_Flash are:
#define PHOTO_FLASH_NONE                    0
#define PHOTO_FLASH_FLASH                   1
#define PHOTO_FLASH_WITHOUTSTROBE           5
#define PHOTO_FLASH_WITHSTROBE              7

//  Name:     System.Photo.FlashEnergy -- PKEY_Photo_FlashEnergy
//  Type:     Double -- VT_R8
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 41483
//
//  PropertyTagExifFlashEnergy.  Calculated from PKEY_Photo_FlashEnergyNumerator and PKEY_Photo_FlashEnergyDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_FlashEnergy, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 41483);

//  Name:     System.Photo.FlashEnergyDenominator -- PKEY_Photo_FlashEnergyDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: D7B61C70-6323-49CD-A5FC-C84277162C97, 100
//
//  Denominator of PKEY_Photo_FlashEnergy
DEFINE_PROPERTYKEY(PKEY_Photo_FlashEnergyDenominator, 0xD7B61C70, 0x6323, 0x49CD, 0xA5, 0xFC, 0xC8, 0x42, 0x77, 0x16, 0x2C, 0x97, 100);

//  Name:     System.Photo.FlashEnergyNumerator -- PKEY_Photo_FlashEnergyNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: FCAD3D3D-0858-400F-AAA3-2F66CCE2A6BC, 100
//
//  Numerator of PKEY_Photo_FlashEnergy
DEFINE_PROPERTYKEY(PKEY_Photo_FlashEnergyNumerator, 0xFCAD3D3D, 0x0858, 0x400F, 0xAA, 0xA3, 0x2F, 0x66, 0xCC, 0xE2, 0xA6, 0xBC, 100);

//  Name:     System.Photo.FlashManufacturer -- PKEY_Photo_FlashManufacturer
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: AABAF6C9-E0C5-4719-8585-57B103E584FE, 100
DEFINE_PROPERTYKEY(PKEY_Photo_FlashManufacturer, 0xAABAF6C9, 0xE0C5, 0x4719, 0x85, 0x85, 0x57, 0xB1, 0x03, 0xE5, 0x84, 0xFE, 100);

//  Name:     System.Photo.FlashModel -- PKEY_Photo_FlashModel
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: FE83BB35-4D1A-42E2-916B-06F3E1AF719E, 100
DEFINE_PROPERTYKEY(PKEY_Photo_FlashModel, 0xFE83BB35, 0x4D1A, 0x42E2, 0x91, 0x6B, 0x06, 0xF3, 0xE1, 0xAF, 0x71, 0x9E, 100);

//  Name:     System.Photo.FlashText -- PKEY_Photo_FlashText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 6B8B68F6-200B-47EA-8D25-D8050F57339F, 100
//  
//  This is the user-friendly form of System.Photo.Flash.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_FlashText, 0x6B8B68F6, 0x200B, 0x47EA, 0x8D, 0x25, 0xD8, 0x05, 0x0F, 0x57, 0x33, 0x9F, 100);

//  Name:     System.Photo.FNumber -- PKEY_Photo_FNumber
//  Type:     Double -- VT_R8
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 33437
//
//  PropertyTagExifFNumber.  Calculated from PKEY_Photo_FNumberNumerator and PKEY_Photo_FNumberDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_FNumber, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 33437);

//  Name:     System.Photo.FNumberDenominator -- PKEY_Photo_FNumberDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: E92A2496-223B-4463-A4E3-30EABBA79D80, 100
//
//  Denominator of PKEY_Photo_FNumber
DEFINE_PROPERTYKEY(PKEY_Photo_FNumberDenominator, 0xE92A2496, 0x223B, 0x4463, 0xA4, 0xE3, 0x30, 0xEA, 0xBB, 0xA7, 0x9D, 0x80, 100);

//  Name:     System.Photo.FNumberNumerator -- PKEY_Photo_FNumberNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 1B97738A-FDFC-462F-9D93-1957E08BE90C, 100
//
//  Numerator of PKEY_Photo_FNumber
DEFINE_PROPERTYKEY(PKEY_Photo_FNumberNumerator, 0x1B97738A, 0xFDFC, 0x462F, 0x9D, 0x93, 0x19, 0x57, 0xE0, 0x8B, 0xE9, 0x0C, 100);

//  Name:     System.Photo.FocalLength -- PKEY_Photo_FocalLength
//  Type:     Double -- VT_R8
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 37386
//
//  PropertyTagExifFocalLength.  Calculated from PKEY_Photo_FocalLengthNumerator and PKEY_Photo_FocalLengthDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_FocalLength, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 37386);

//  Name:     System.Photo.FocalLengthDenominator -- PKEY_Photo_FocalLengthDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 305BC615-DCA1-44A5-9FD4-10C0BA79412E, 100
//
//  Denominator of PKEY_Photo_FocalLength
DEFINE_PROPERTYKEY(PKEY_Photo_FocalLengthDenominator, 0x305BC615, 0xDCA1, 0x44A5, 0x9F, 0xD4, 0x10, 0xC0, 0xBA, 0x79, 0x41, 0x2E, 100);

//  Name:     System.Photo.FocalLengthInFilm -- PKEY_Photo_FocalLengthInFilm
//  Type:     UInt16 -- VT_UI2
//  FormatID: A0E74609-B84D-4F49-B860-462BD9971F98, 100
DEFINE_PROPERTYKEY(PKEY_Photo_FocalLengthInFilm, 0xA0E74609, 0xB84D, 0x4F49, 0xB8, 0x60, 0x46, 0x2B, 0xD9, 0x97, 0x1F, 0x98, 100);

//  Name:     System.Photo.FocalLengthNumerator -- PKEY_Photo_FocalLengthNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 776B6B3B-1E3D-4B0C-9A0E-8FBAF2A8492A, 100
//
//  Numerator of PKEY_Photo_FocalLength
DEFINE_PROPERTYKEY(PKEY_Photo_FocalLengthNumerator, 0x776B6B3B, 0x1E3D, 0x4B0C, 0x9A, 0x0E, 0x8F, 0xBA, 0xF2, 0xA8, 0x49, 0x2A, 100);

//  Name:     System.Photo.FocalPlaneXResolution -- PKEY_Photo_FocalPlaneXResolution
//  Type:     Double -- VT_R8
//  FormatID: CFC08D97-C6F7-4484-89DD-EBEF4356FE76, 100
//  
//  PropertyTagExifFocalXRes.  Calculated from PKEY_Photo_FocalPlaneXResolutionNumerator and 
//  PKEY_Photo_FocalPlaneXResolutionDenominator.
DEFINE_PROPERTYKEY(PKEY_Photo_FocalPlaneXResolution, 0xCFC08D97, 0xC6F7, 0x4484, 0x89, 0xDD, 0xEB, 0xEF, 0x43, 0x56, 0xFE, 0x76, 100);

//  Name:     System.Photo.FocalPlaneXResolutionDenominator -- PKEY_Photo_FocalPlaneXResolutionDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 0933F3F5-4786-4F46-A8E8-D64DD37FA521, 100
//
//  Denominator of PKEY_Photo_FocalPlaneXResolution
DEFINE_PROPERTYKEY(PKEY_Photo_FocalPlaneXResolutionDenominator, 0x0933F3F5, 0x4786, 0x4F46, 0xA8, 0xE8, 0xD6, 0x4D, 0xD3, 0x7F, 0xA5, 0x21, 100);

//  Name:     System.Photo.FocalPlaneXResolutionNumerator -- PKEY_Photo_FocalPlaneXResolutionNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: DCCB10AF-B4E2-4B88-95F9-031B4D5AB490, 100
//
//  Numerator of PKEY_Photo_FocalPlaneXResolution
DEFINE_PROPERTYKEY(PKEY_Photo_FocalPlaneXResolutionNumerator, 0xDCCB10AF, 0xB4E2, 0x4B88, 0x95, 0xF9, 0x03, 0x1B, 0x4D, 0x5A, 0xB4, 0x90, 100);

//  Name:     System.Photo.FocalPlaneYResolution -- PKEY_Photo_FocalPlaneYResolution
//  Type:     Double -- VT_R8
//  FormatID: 4FFFE4D0-914F-4AC4-8D6F-C9C61DE169B1, 100
//  
//  PropertyTagExifFocalYRes.  Calculated from PKEY_Photo_FocalPlaneYResolutionNumerator and 
//  PKEY_Photo_FocalPlaneYResolutionDenominator.
DEFINE_PROPERTYKEY(PKEY_Photo_FocalPlaneYResolution, 0x4FFFE4D0, 0x914F, 0x4AC4, 0x8D, 0x6F, 0xC9, 0xC6, 0x1D, 0xE1, 0x69, 0xB1, 100);

//  Name:     System.Photo.FocalPlaneYResolutionDenominator -- PKEY_Photo_FocalPlaneYResolutionDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 1D6179A6-A876-4031-B013-3347B2B64DC8, 100
//
//  Denominator of PKEY_Photo_FocalPlaneYResolution
DEFINE_PROPERTYKEY(PKEY_Photo_FocalPlaneYResolutionDenominator, 0x1D6179A6, 0xA876, 0x4031, 0xB0, 0x13, 0x33, 0x47, 0xB2, 0xB6, 0x4D, 0xC8, 100);

//  Name:     System.Photo.FocalPlaneYResolutionNumerator -- PKEY_Photo_FocalPlaneYResolutionNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: A2E541C5-4440-4BA8-867E-75CFC06828CD, 100
//
//  Numerator of PKEY_Photo_FocalPlaneYResolution
DEFINE_PROPERTYKEY(PKEY_Photo_FocalPlaneYResolutionNumerator, 0xA2E541C5, 0x4440, 0x4BA8, 0x86, 0x7E, 0x75, 0xCF, 0xC0, 0x68, 0x28, 0xCD, 100);

//  Name:     System.Photo.GainControl -- PKEY_Photo_GainControl
//  Type:     Double -- VT_R8
//  FormatID: FA304789-00C7-4D80-904A-1E4DCC7265AA, 100 (PropertyTagExifGainControl)
//  
//  This indicates the degree of overall image gain adjustment.
//  
//  Calculated from PKEY_Photo_GainControlNumerator and PKEY_Photo_GainControlDenominator.
DEFINE_PROPERTYKEY(PKEY_Photo_GainControl, 0xFA304789, 0x00C7, 0x4D80, 0x90, 0x4A, 0x1E, 0x4D, 0xCC, 0x72, 0x65, 0xAA, 100);

// Possible discrete values for PKEY_Photo_GainControl are:
#define PHOTO_GAINCONTROL_NONE              0.0
#define PHOTO_GAINCONTROL_LOWGAINUP         1.0
#define PHOTO_GAINCONTROL_HIGHGAINUP        2.0
#define PHOTO_GAINCONTROL_LOWGAINDOWN       3.0
#define PHOTO_GAINCONTROL_HIGHGAINDOWN      4.0

//  Name:     System.Photo.GainControlDenominator -- PKEY_Photo_GainControlDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 42864DFD-9DA4-4F77-BDED-4AAD7B256735, 100
//
//  Denominator of PKEY_Photo_GainControl
DEFINE_PROPERTYKEY(PKEY_Photo_GainControlDenominator, 0x42864DFD, 0x9DA4, 0x4F77, 0xBD, 0xED, 0x4A, 0xAD, 0x7B, 0x25, 0x67, 0x35, 100);

//  Name:     System.Photo.GainControlNumerator -- PKEY_Photo_GainControlNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 8E8ECF7C-B7B8-4EB8-A63F-0EE715C96F9E, 100
//
//  Numerator of PKEY_Photo_GainControl
DEFINE_PROPERTYKEY(PKEY_Photo_GainControlNumerator, 0x8E8ECF7C, 0xB7B8, 0x4EB8, 0xA6, 0x3F, 0x0E, 0xE7, 0x15, 0xC9, 0x6F, 0x9E, 100);

//  Name:     System.Photo.GainControlText -- PKEY_Photo_GainControlText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: C06238B2-0BF9-4279-A723-25856715CB9D, 100
//  
//  This is the user-friendly form of System.Photo.GainControl.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_GainControlText, 0xC06238B2, 0x0BF9, 0x4279, 0xA7, 0x23, 0x25, 0x85, 0x67, 0x15, 0xCB, 0x9D, 100);

//  Name:     System.Photo.ISOSpeed -- PKEY_Photo_ISOSpeed
//  Type:     UInt16 -- VT_UI2
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 34855
//
//  PropertyTagExifISOSpeed
DEFINE_PROPERTYKEY(PKEY_Photo_ISOSpeed, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 34855);

//  Name:     System.Photo.LensManufacturer -- PKEY_Photo_LensManufacturer
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: E6DDCAF7-29C5-4F0A-9A68-D19412EC7090, 100
DEFINE_PROPERTYKEY(PKEY_Photo_LensManufacturer, 0xE6DDCAF7, 0x29C5, 0x4F0A, 0x9A, 0x68, 0xD1, 0x94, 0x12, 0xEC, 0x70, 0x90, 100);

//  Name:     System.Photo.LensModel -- PKEY_Photo_LensModel
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: E1277516-2B5F-4869-89B1-2E585BD38B7A, 100
DEFINE_PROPERTYKEY(PKEY_Photo_LensModel, 0xE1277516, 0x2B5F, 0x4869, 0x89, 0xB1, 0x2E, 0x58, 0x5B, 0xD3, 0x8B, 0x7A, 100);

//  Name:     System.Photo.LightSource -- PKEY_Photo_LightSource
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 37384
//
//  PropertyTagExifLightSource
DEFINE_PROPERTYKEY(PKEY_Photo_LightSource, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 37384);

// Possible discrete values for PKEY_Photo_LightSource are:
#define PHOTO_LIGHTSOURCE_UNKNOWN           0ul
#define PHOTO_LIGHTSOURCE_DAYLIGHT          1ul
#define PHOTO_LIGHTSOURCE_FLUORESCENT       2ul
#define PHOTO_LIGHTSOURCE_TUNGSTEN          3ul
#define PHOTO_LIGHTSOURCE_STANDARD_A        17ul
#define PHOTO_LIGHTSOURCE_STANDARD_B        18ul
#define PHOTO_LIGHTSOURCE_STANDARD_C        19ul
#define PHOTO_LIGHTSOURCE_D55               20ul
#define PHOTO_LIGHTSOURCE_D65               21ul
#define PHOTO_LIGHTSOURCE_D75               22ul

//  Name:     System.Photo.MakerNote -- PKEY_Photo_MakerNote
//  Type:     Buffer -- VT_VECTOR | VT_UI1  (For variants: VT_ARRAY | VT_UI1)
//  FormatID: FA303353-B659-4052-85E9-BCAC79549B84, 100
DEFINE_PROPERTYKEY(PKEY_Photo_MakerNote, 0xFA303353, 0xB659, 0x4052, 0x85, 0xE9, 0xBC, 0xAC, 0x79, 0x54, 0x9B, 0x84, 100);

//  Name:     System.Photo.MakerNoteOffset -- PKEY_Photo_MakerNoteOffset
//  Type:     UInt64 -- VT_UI8
//  FormatID: 813F4124-34E6-4D17-AB3E-6B1F3C2247A1, 100
DEFINE_PROPERTYKEY(PKEY_Photo_MakerNoteOffset, 0x813F4124, 0x34E6, 0x4D17, 0xAB, 0x3E, 0x6B, 0x1F, 0x3C, 0x22, 0x47, 0xA1, 100);

//  Name:     System.Photo.MaxAperture -- PKEY_Photo_MaxAperture
//  Type:     Double -- VT_R8
//  FormatID: 08F6D7C2-E3F2-44FC-AF1E-5AA5C81A2D3E, 100
//
//  Calculated from PKEY_Photo_MaxApertureNumerator and PKEY_Photo_MaxApertureDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_MaxAperture, 0x08F6D7C2, 0xE3F2, 0x44FC, 0xAF, 0x1E, 0x5A, 0xA5, 0xC8, 0x1A, 0x2D, 0x3E, 100);

//  Name:     System.Photo.MaxApertureDenominator -- PKEY_Photo_MaxApertureDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: C77724D4-601F-46C5-9B89-C53F93BCEB77, 100
//
//  Denominator of PKEY_Photo_MaxAperture
DEFINE_PROPERTYKEY(PKEY_Photo_MaxApertureDenominator, 0xC77724D4, 0x601F, 0x46C5, 0x9B, 0x89, 0xC5, 0x3F, 0x93, 0xBC, 0xEB, 0x77, 100);

//  Name:     System.Photo.MaxApertureNumerator -- PKEY_Photo_MaxApertureNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: C107E191-A459-44C5-9AE6-B952AD4B906D, 100
//
//  Numerator of PKEY_Photo_MaxAperture
DEFINE_PROPERTYKEY(PKEY_Photo_MaxApertureNumerator, 0xC107E191, 0xA459, 0x44C5, 0x9A, 0xE6, 0xB9, 0x52, 0xAD, 0x4B, 0x90, 0x6D, 100);

//  Name:     System.Photo.MeteringMode -- PKEY_Photo_MeteringMode
//  Type:     UInt16 -- VT_UI2
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 37383
//
//  PropertyTagExifMeteringMode
DEFINE_PROPERTYKEY(PKEY_Photo_MeteringMode, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 37383);

// Possible discrete values for PKEY_Photo_MeteringMode are:
#define PHOTO_METERINGMODE_UNKNOWN          0u
#define PHOTO_METERINGMODE_AVERAGE          1u
#define PHOTO_METERINGMODE_CENTER           2u
#define PHOTO_METERINGMODE_SPOT             3u
#define PHOTO_METERINGMODE_MULTISPOT        4u
#define PHOTO_METERINGMODE_PATTERN          5u
#define PHOTO_METERINGMODE_PARTIAL          6u

//  Name:     System.Photo.MeteringModeText -- PKEY_Photo_MeteringModeText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: F628FD8C-7BA8-465A-A65B-C5AA79263A9E, 100
//  
//  This is the user-friendly form of System.Photo.MeteringMode.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_MeteringModeText, 0xF628FD8C, 0x7BA8, 0x465A, 0xA6, 0x5B, 0xC5, 0xAA, 0x79, 0x26, 0x3A, 0x9E, 100);

//  Name:     System.Photo.Orientation -- PKEY_Photo_Orientation
//  Type:     UInt16 -- VT_UI2
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 274 (PropertyTagOrientation)
//  
//  This is the image orientation viewed in terms of rows and columns.
DEFINE_PROPERTYKEY(PKEY_Photo_Orientation, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 274);

// Possible discrete values for PKEY_Photo_Orientation are:
#define PHOTO_ORIENTATION_NORMAL            1u
#define PHOTO_ORIENTATION_FLIPHORIZONTAL    2u
#define PHOTO_ORIENTATION_ROTATE180         3u
#define PHOTO_ORIENTATION_FLIPVERTICAL      4u
#define PHOTO_ORIENTATION_TRANSPOSE         5u
#define PHOTO_ORIENTATION_ROTATE270         6u
#define PHOTO_ORIENTATION_TRANSVERSE        7u
#define PHOTO_ORIENTATION_ROTATE90          8u

//  Name:     System.Photo.OrientationText -- PKEY_Photo_OrientationText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: A9EA193C-C511-498A-A06B-58E2776DCC28, 100
//  
//  This is the user-friendly form of System.Photo.Orientation.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_OrientationText, 0xA9EA193C, 0xC511, 0x498A, 0xA0, 0x6B, 0x58, 0xE2, 0x77, 0x6D, 0xCC, 0x28, 100);

//  Name:     System.Photo.PhotometricInterpretation -- PKEY_Photo_PhotometricInterpretation
//  Type:     UInt16 -- VT_UI2
//  FormatID: 341796F1-1DF9-4B1C-A564-91BDEFA43877, 100
//  
//  This is the pixel composition. In JPEG compressed data, a JPEG marker is used 
//  instead of this property.
DEFINE_PROPERTYKEY(PKEY_Photo_PhotometricInterpretation, 0x341796F1, 0x1DF9, 0x4B1C, 0xA5, 0x64, 0x91, 0xBD, 0xEF, 0xA4, 0x38, 0x77, 100);

// Possible discrete values for PKEY_Photo_PhotometricInterpretation are:
#define PHOTO_PHOTOMETRIC_RGB               2u
#define PHOTO_PHOTOMETRIC_YCBCR             6u

//  Name:     System.Photo.PhotometricInterpretationText -- PKEY_Photo_PhotometricInterpretationText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 821437D6-9EAB-4765-A589-3B1CBBD22A61, 100
//  
//  This is the user-friendly form of System.Photo.PhotometricInterpretation.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_PhotometricInterpretationText, 0x821437D6, 0x9EAB, 0x4765, 0xA5, 0x89, 0x3B, 0x1C, 0xBB, 0xD2, 0x2A, 0x61, 100);

//  Name:     System.Photo.ProgramMode -- PKEY_Photo_ProgramMode
//  Type:     UInt32 -- VT_UI4
//  FormatID: 6D217F6D-3F6A-4825-B470-5F03CA2FBE9B, 100
//  
//  This is the class of the program used by the camera to set exposure when the 
//  picture is taken.
DEFINE_PROPERTYKEY(PKEY_Photo_ProgramMode, 0x6D217F6D, 0x3F6A, 0x4825, 0xB4, 0x70, 0x5F, 0x03, 0xCA, 0x2F, 0xBE, 0x9B, 100);

// Possible discrete values for PKEY_Photo_ProgramMode are:
#define PHOTO_PROGRAMMODE_NOTDEFINED        0ul
#define PHOTO_PROGRAMMODE_MANUAL            1ul
#define PHOTO_PROGRAMMODE_NORMAL            2ul
#define PHOTO_PROGRAMMODE_APERTURE          3ul
#define PHOTO_PROGRAMMODE_SHUTTER           4ul
#define PHOTO_PROGRAMMODE_CREATIVE          5ul
#define PHOTO_PROGRAMMODE_ACTION            6ul
#define PHOTO_PROGRAMMODE_PORTRAIT          7ul
#define PHOTO_PROGRAMMODE_LANDSCAPE         8ul

//  Name:     System.Photo.ProgramModeText -- PKEY_Photo_ProgramModeText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 7FE3AA27-2648-42F3-89B0-454E5CB150C3, 100
//  
//  This is the user-friendly form of System.Photo.ProgramMode.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_ProgramModeText, 0x7FE3AA27, 0x2648, 0x42F3, 0x89, 0xB0, 0x45, 0x4E, 0x5C, 0xB1, 0x50, 0xC3, 100);

//  Name:     System.Photo.RelatedSoundFile -- PKEY_Photo_RelatedSoundFile
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 318A6B45-087F-4DC2-B8CC-05359551FC9E, 100
DEFINE_PROPERTYKEY(PKEY_Photo_RelatedSoundFile, 0x318A6B45, 0x087F, 0x4DC2, 0xB8, 0xCC, 0x05, 0x35, 0x95, 0x51, 0xFC, 0x9E, 100);

//  Name:     System.Photo.Saturation -- PKEY_Photo_Saturation
//  Type:     UInt32 -- VT_UI4
//  FormatID: 49237325-A95A-4F67-B211-816B2D45D2E0, 100
//  
//  This indicates the direction of saturation processing applied by the camera when 
//  the image was shot.
DEFINE_PROPERTYKEY(PKEY_Photo_Saturation, 0x49237325, 0xA95A, 0x4F67, 0xB2, 0x11, 0x81, 0x6B, 0x2D, 0x45, 0xD2, 0xE0, 100);

// Possible discrete values for PKEY_Photo_Saturation are:
#define PHOTO_SATURATION_NORMAL             0ul
#define PHOTO_SATURATION_LOW                1ul
#define PHOTO_SATURATION_HIGH               2ul

//  Name:     System.Photo.SaturationText -- PKEY_Photo_SaturationText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 61478C08-B600-4A84-BBE4-E99C45F0A072, 100
//  
//  This is the user-friendly form of System.Photo.Saturation.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_SaturationText, 0x61478C08, 0xB600, 0x4A84, 0xBB, 0xE4, 0xE9, 0x9C, 0x45, 0xF0, 0xA0, 0x72, 100);

//  Name:     System.Photo.Sharpness -- PKEY_Photo_Sharpness
//  Type:     UInt32 -- VT_UI4
//  FormatID: FC6976DB-8349-4970-AE97-B3C5316A08F0, 100
//  
//  This indicates the direction of sharpness processing applied by the camera when 
//  the image was shot.
DEFINE_PROPERTYKEY(PKEY_Photo_Sharpness, 0xFC6976DB, 0x8349, 0x4970, 0xAE, 0x97, 0xB3, 0xC5, 0x31, 0x6A, 0x08, 0xF0, 100);

// Possible discrete values for PKEY_Photo_Sharpness are:
#define PHOTO_SHARPNESS_NORMAL              0ul
#define PHOTO_SHARPNESS_SOFT                1ul
#define PHOTO_SHARPNESS_HARD                2ul

//  Name:     System.Photo.SharpnessText -- PKEY_Photo_SharpnessText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 51EC3F47-DD50-421D-8769-334F50424B1E, 100
//  
//  This is the user-friendly form of System.Photo.Sharpness.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_SharpnessText, 0x51EC3F47, 0xDD50, 0x421D, 0x87, 0x69, 0x33, 0x4F, 0x50, 0x42, 0x4B, 0x1E, 100);

//  Name:     System.Photo.ShutterSpeed -- PKEY_Photo_ShutterSpeed
//  Type:     Double -- VT_R8
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 37377
//
//  PropertyTagExifShutterSpeed.  Calculated from PKEY_Photo_ShutterSpeedNumerator and PKEY_Photo_ShutterSpeedDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_ShutterSpeed, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 37377);

//  Name:     System.Photo.ShutterSpeedDenominator -- PKEY_Photo_ShutterSpeedDenominator
//  Type:     Int32 -- VT_I4
//  FormatID: E13D8975-81C7-4948-AE3F-37CAE11E8FF7, 100
//
//  Denominator of PKEY_Photo_ShutterSpeed
DEFINE_PROPERTYKEY(PKEY_Photo_ShutterSpeedDenominator, 0xE13D8975, 0x81C7, 0x4948, 0xAE, 0x3F, 0x37, 0xCA, 0xE1, 0x1E, 0x8F, 0xF7, 100);

//  Name:     System.Photo.ShutterSpeedNumerator -- PKEY_Photo_ShutterSpeedNumerator
//  Type:     Int32 -- VT_I4
//  FormatID: 16EA4042-D6F4-4BCA-8349-7C78D30FB333, 100
//
//  Numerator of PKEY_Photo_ShutterSpeed
DEFINE_PROPERTYKEY(PKEY_Photo_ShutterSpeedNumerator, 0x16EA4042, 0xD6F4, 0x4BCA, 0x83, 0x49, 0x7C, 0x78, 0xD3, 0x0F, 0xB3, 0x33, 100);

//  Name:     System.Photo.SubjectDistance -- PKEY_Photo_SubjectDistance
//  Type:     Double -- VT_R8
//  FormatID: (FMTID_ImageProperties) 14B81DA1-0135-4D31-96D9-6CBFC9671A99, 37382
//
//  PropertyTagExifSubjectDist.  Calculated from PKEY_Photo_SubjectDistanceNumerator and PKEY_Photo_SubjectDistanceDenominator
DEFINE_PROPERTYKEY(PKEY_Photo_SubjectDistance, 0x14B81DA1, 0x0135, 0x4D31, 0x96, 0xD9, 0x6C, 0xBF, 0xC9, 0x67, 0x1A, 0x99, 37382);

//  Name:     System.Photo.SubjectDistanceDenominator -- PKEY_Photo_SubjectDistanceDenominator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 0C840A88-B043-466D-9766-D4B26DA3FA77, 100
//
//  Denominator of PKEY_Photo_SubjectDistance
DEFINE_PROPERTYKEY(PKEY_Photo_SubjectDistanceDenominator, 0x0C840A88, 0xB043, 0x466D, 0x97, 0x66, 0xD4, 0xB2, 0x6D, 0xA3, 0xFA, 0x77, 100);

//  Name:     System.Photo.SubjectDistanceNumerator -- PKEY_Photo_SubjectDistanceNumerator
//  Type:     UInt32 -- VT_UI4
//  FormatID: 8AF4961C-F526-43E5-AA81-DB768219178D, 100
//
//  Numerator of PKEY_Photo_SubjectDistance
DEFINE_PROPERTYKEY(PKEY_Photo_SubjectDistanceNumerator, 0x8AF4961C, 0xF526, 0x43E5, 0xAA, 0x81, 0xDB, 0x76, 0x82, 0x19, 0x17, 0x8D, 100);

//  Name:     System.Photo.TranscodedForSync -- PKEY_Photo_TranscodedForSync
//  Type:     Boolean -- VT_BOOL
//  FormatID: 9A8EBB75-6458-4E82-BACB-35C0095B03BB, 100
DEFINE_PROPERTYKEY(PKEY_Photo_TranscodedForSync, 0x9A8EBB75, 0x6458, 0x4E82, 0xBA, 0xCB, 0x35, 0xC0, 0x09, 0x5B, 0x03, 0xBB, 100);

//  Name:     System.Photo.WhiteBalance -- PKEY_Photo_WhiteBalance
//  Type:     UInt32 -- VT_UI4
//  FormatID: EE3D3D8A-5381-4CFA-B13B-AAF66B5F4EC9, 100
//  
//  This indicates the white balance mode set when the image was shot.
DEFINE_PROPERTYKEY(PKEY_Photo_WhiteBalance, 0xEE3D3D8A, 0x5381, 0x4CFA, 0xB1, 0x3B, 0xAA, 0xF6, 0x6B, 0x5F, 0x4E, 0xC9, 100);

// Possible discrete values for PKEY_Photo_WhiteBalance are:
#define PHOTO_WHITEBALANCE_AUTO             0ul
#define PHOTO_WHITEBALANCE_MANUAL           1ul

//  Name:     System.Photo.WhiteBalanceText -- PKEY_Photo_WhiteBalanceText
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 6336B95E-C7A7-426D-86FD-7AE3D39C84B4, 100
//  
//  This is the user-friendly form of System.Photo.WhiteBalance.  Not intended to be parsed 
//  programmatically.
DEFINE_PROPERTYKEY(PKEY_Photo_WhiteBalanceText, 0x6336B95E, 0xC7A7, 0x426D, 0x86, 0xFD, 0x7A, 0xE3, 0xD3, 0x9C, 0x84, 0xB4, 100);
 
//-----------------------------------------------------------------------------
// PropGroup properties

//  Name:     System.PropGroup.Advanced -- PKEY_PropGroup_Advanced
//  Type:     Null -- VT_NULL
//  FormatID: 900A403B-097B-4B95-8AE2-071FDAEEB118, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Advanced, 0x900A403B, 0x097B, 0x4B95, 0x8A, 0xE2, 0x07, 0x1F, 0xDA, 0xEE, 0xB1, 0x18, 100);

//  Name:     System.PropGroup.Audio -- PKEY_PropGroup_Audio
//  Type:     Null -- VT_NULL
//  FormatID: 2804D469-788F-48AA-8570-71B9C187E138, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Audio, 0x2804D469, 0x788F, 0x48AA, 0x85, 0x70, 0x71, 0xB9, 0xC1, 0x87, 0xE1, 0x38, 100);

//  Name:     System.PropGroup.Calendar -- PKEY_PropGroup_Calendar
//  Type:     Null -- VT_NULL
//  FormatID: 9973D2B5-BFD8-438A-BA94-5349B293181A, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Calendar, 0x9973D2B5, 0xBFD8, 0x438A, 0xBA, 0x94, 0x53, 0x49, 0xB2, 0x93, 0x18, 0x1A, 100);

//  Name:     System.PropGroup.Camera -- PKEY_PropGroup_Camera
//  Type:     Null -- VT_NULL
//  FormatID: DE00DE32-547E-4981-AD4B-542F2E9007D8, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Camera, 0xDE00DE32, 0x547E, 0x4981, 0xAD, 0x4B, 0x54, 0x2F, 0x2E, 0x90, 0x07, 0xD8, 100);

//  Name:     System.PropGroup.Contact -- PKEY_PropGroup_Contact
//  Type:     Null -- VT_NULL
//  FormatID: DF975FD3-250A-4004-858F-34E29A3E37AA, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Contact, 0xDF975FD3, 0x250A, 0x4004, 0x85, 0x8F, 0x34, 0xE2, 0x9A, 0x3E, 0x37, 0xAA, 100);

//  Name:     System.PropGroup.Content -- PKEY_PropGroup_Content
//  Type:     Null -- VT_NULL
//  FormatID: D0DAB0BA-368A-4050-A882-6C010FD19A4F, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Content, 0xD0DAB0BA, 0x368A, 0x4050, 0xA8, 0x82, 0x6C, 0x01, 0x0F, 0xD1, 0x9A, 0x4F, 100);

//  Name:     System.PropGroup.Description -- PKEY_PropGroup_Description
//  Type:     Null -- VT_NULL
//  FormatID: 8969B275-9475-4E00-A887-FF93B8B41E44, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Description, 0x8969B275, 0x9475, 0x4E00, 0xA8, 0x87, 0xFF, 0x93, 0xB8, 0xB4, 0x1E, 0x44, 100);

//  Name:     System.PropGroup.FileSystem -- PKEY_PropGroup_FileSystem
//  Type:     Null -- VT_NULL
//  FormatID: E3A7D2C1-80FC-4B40-8F34-30EA111BDC2E, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_FileSystem, 0xE3A7D2C1, 0x80FC, 0x4B40, 0x8F, 0x34, 0x30, 0xEA, 0x11, 0x1B, 0xDC, 0x2E, 100);

//  Name:     System.PropGroup.General -- PKEY_PropGroup_General
//  Type:     Null -- VT_NULL
//  FormatID: CC301630-B192-4C22-B372-9F4C6D338E07, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_General, 0xCC301630, 0xB192, 0x4C22, 0xB3, 0x72, 0x9F, 0x4C, 0x6D, 0x33, 0x8E, 0x07, 100);

//  Name:     System.PropGroup.GPS -- PKEY_PropGroup_GPS
//  Type:     Null -- VT_NULL
//  FormatID: F3713ADA-90E3-4E11-AAE5-FDC17685B9BE, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_GPS, 0xF3713ADA, 0x90E3, 0x4E11, 0xAA, 0xE5, 0xFD, 0xC1, 0x76, 0x85, 0xB9, 0xBE, 100);

//  Name:     System.PropGroup.Image -- PKEY_PropGroup_Image
//  Type:     Null -- VT_NULL
//  FormatID: E3690A87-0FA8-4A2A-9A9F-FCE8827055AC, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Image, 0xE3690A87, 0x0FA8, 0x4A2A, 0x9A, 0x9F, 0xFC, 0xE8, 0x82, 0x70, 0x55, 0xAC, 100);

//  Name:     System.PropGroup.Media -- PKEY_PropGroup_Media
//  Type:     Null -- VT_NULL
//  FormatID: 61872CF7-6B5E-4B4B-AC2D-59DA84459248, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Media, 0x61872CF7, 0x6B5E, 0x4B4B, 0xAC, 0x2D, 0x59, 0xDA, 0x84, 0x45, 0x92, 0x48, 100);

//  Name:     System.PropGroup.MediaAdvanced -- PKEY_PropGroup_MediaAdvanced
//  Type:     Null -- VT_NULL
//  FormatID: 8859A284-DE7E-4642-99BA-D431D044B1EC, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_MediaAdvanced, 0x8859A284, 0xDE7E, 0x4642, 0x99, 0xBA, 0xD4, 0x31, 0xD0, 0x44, 0xB1, 0xEC, 100);

//  Name:     System.PropGroup.Message -- PKEY_PropGroup_Message
//  Type:     Null -- VT_NULL
//  FormatID: 7FD7259D-16B4-4135-9F97-7C96ECD2FA9E, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Message, 0x7FD7259D, 0x16B4, 0x4135, 0x9F, 0x97, 0x7C, 0x96, 0xEC, 0xD2, 0xFA, 0x9E, 100);

//  Name:     System.PropGroup.Music -- PKEY_PropGroup_Music
//  Type:     Null -- VT_NULL
//  FormatID: 68DD6094-7216-40F1-A029-43FE7127043F, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Music, 0x68DD6094, 0x7216, 0x40F1, 0xA0, 0x29, 0x43, 0xFE, 0x71, 0x27, 0x04, 0x3F, 100);

//  Name:     System.PropGroup.Origin -- PKEY_PropGroup_Origin
//  Type:     Null -- VT_NULL
//  FormatID: 2598D2FB-5569-4367-95DF-5CD3A177E1A5, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Origin, 0x2598D2FB, 0x5569, 0x4367, 0x95, 0xDF, 0x5C, 0xD3, 0xA1, 0x77, 0xE1, 0xA5, 100);

//  Name:     System.PropGroup.PhotoAdvanced -- PKEY_PropGroup_PhotoAdvanced
//  Type:     Null -- VT_NULL
//  FormatID: 0CB2BF5A-9EE7-4A86-8222-F01E07FDADAF, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_PhotoAdvanced, 0x0CB2BF5A, 0x9EE7, 0x4A86, 0x82, 0x22, 0xF0, 0x1E, 0x07, 0xFD, 0xAD, 0xAF, 100);

//  Name:     System.PropGroup.RecordedTV -- PKEY_PropGroup_RecordedTV
//  Type:     Null -- VT_NULL
//  FormatID: E7B33238-6584-4170-A5C0-AC25EFD9DA56, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_RecordedTV, 0xE7B33238, 0x6584, 0x4170, 0xA5, 0xC0, 0xAC, 0x25, 0xEF, 0xD9, 0xDA, 0x56, 100);

//  Name:     System.PropGroup.Video -- PKEY_PropGroup_Video
//  Type:     Null -- VT_NULL
//  FormatID: BEBE0920-7671-4C54-A3EB-49FDDFC191EE, 100
DEFINE_PROPERTYKEY(PKEY_PropGroup_Video, 0xBEBE0920, 0x7671, 0x4C54, 0xA3, 0xEB, 0x49, 0xFD, 0xDF, 0xC1, 0x91, 0xEE, 100);
 
//-----------------------------------------------------------------------------
// PropList properties



//  Name:     System.PropList.ConflictPrompt -- PKEY_PropList_ConflictPrompt
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: C9944A21-A406-48FE-8225-AEC7E24C211B, 11
//  
//  The list of properties to show in the file operation conflict resolution dialog. Properties with empty 
//  values will not be displayed. Register under the regvalue of "ConflictPrompt".
DEFINE_PROPERTYKEY(PKEY_PropList_ConflictPrompt, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 11);

//  Name:     System.PropList.ExtendedTileInfo -- PKEY_PropList_ExtendedTileInfo
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: C9944A21-A406-48FE-8225-AEC7E24C211B, 9
//  
//  The list of properties to show in the listview on extended tiles. Register under the regvalue of 
//  "ExtendedTileInfo".
DEFINE_PROPERTYKEY(PKEY_PropList_ExtendedTileInfo, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 9);

//  Name:     System.PropList.FileOperationPrompt -- PKEY_PropList_FileOperationPrompt
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: C9944A21-A406-48FE-8225-AEC7E24C211B, 10
//  
//  The list of properties to show in the file operation confirmation dialog. Properties with empty values 
//  will not be displayed. If this list is not specified, then the InfoTip property list is used instead. 
//  Register under the regvalue of "FileOperationPrompt".
DEFINE_PROPERTYKEY(PKEY_PropList_FileOperationPrompt, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 10);

//  Name:     System.PropList.FullDetails -- PKEY_PropList_FullDetails
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: C9944A21-A406-48FE-8225-AEC7E24C211B, 2
//  
//  The list of all the properties to show in the details page.  Property groups can be included in this list 
//  in order to more easily organize the UI.  Register under the regvalue of "FullDetails".
DEFINE_PROPERTYKEY(PKEY_PropList_FullDetails, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 2);

//  Name:     System.PropList.InfoTip -- PKEY_PropList_InfoTip
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: C9944A21-A406-48FE-8225-AEC7E24C211B, 4 (PID_PROPLIST_INFOTIP)
//  
//  The list of properties to show in the infotip. Properties with empty values will not be displayed. Register 
//  under the regvalue of "InfoTip".
DEFINE_PROPERTYKEY(PKEY_PropList_InfoTip, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 4);

//  Name:     System.PropList.NonPersonal -- PKEY_PropList_NonPersonal
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 49D1091F-082E-493F-B23F-D2308AA9668C, 100
//  
//  The list of properties that are considered 'non-personal'. When told to remove all non-personal properties 
//  from a given file, the system will leave these particular properties untouched. Register under the regvalue 
//  of "NonPersonal".
DEFINE_PROPERTYKEY(PKEY_PropList_NonPersonal, 0x49D1091F, 0x082E, 0x493F, 0xB2, 0x3F, 0xD2, 0x30, 0x8A, 0xA9, 0x66, 0x8C, 100);

//  Name:     System.PropList.PreviewDetails -- PKEY_PropList_PreviewDetails
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: C9944A21-A406-48FE-8225-AEC7E24C211B, 8
//
//  The list of properties to display in the preview pane.  Register under the regvalue of "PreviewDetails".
DEFINE_PROPERTYKEY(PKEY_PropList_PreviewDetails, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 8);

//  Name:     System.PropList.PreviewTitle -- PKEY_PropList_PreviewTitle
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: C9944A21-A406-48FE-8225-AEC7E24C211B, 6
//  
//  The one or two properties to display in the preview pane title section.  The optional second property is 
//  displayed as a subtitle.  Register under the regvalue of "PreviewTitle".
DEFINE_PROPERTYKEY(PKEY_PropList_PreviewTitle, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 6);

//  Name:     System.PropList.QuickTip -- PKEY_PropList_QuickTip
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: C9944A21-A406-48FE-8225-AEC7E24C211B, 5 (PID_PROPLIST_QUICKTIP)
//  
//  The list of properties to show in the infotip when the item is on a slow network. Properties with empty 
//  values will not be displayed. Register under the regvalue of "QuickTip".
DEFINE_PROPERTYKEY(PKEY_PropList_QuickTip, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 5);

//  Name:     System.PropList.TileInfo -- PKEY_PropList_TileInfo
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: C9944A21-A406-48FE-8225-AEC7E24C211B, 3 (PID_PROPLIST_TILEINFO)
//  
//  The list of properties to show in the listview on tiles. Register under the regvalue of "TileInfo".
DEFINE_PROPERTYKEY(PKEY_PropList_TileInfo, 0xC9944A21, 0xA406, 0x48FE, 0x82, 0x25, 0xAE, 0xC7, 0xE2, 0x4C, 0x21, 0x1B, 3);

//  Name:     System.PropList.XPDetailsPanel -- PKEY_PropList_XPDetailsPanel
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_WebView) F2275480-F782-4291-BD94-F13693513AEC, 0 (PID_DISPLAY_PROPERTIES)
//
//  The list of properties to display in the XP webview details panel. Obsolete.
DEFINE_PROPERTYKEY(PKEY_PropList_XPDetailsPanel, 0xF2275480, 0xF782, 0x4291, 0xBD, 0x94, 0xF1, 0x36, 0x93, 0x51, 0x3A, 0xEC, 0);
 
//-----------------------------------------------------------------------------
// RecordedTV properties



//  Name:     System.RecordedTV.ChannelNumber -- PKEY_RecordedTV_ChannelNumber
//  Type:     UInt32 -- VT_UI4
//  FormatID: 6D748DE2-8D38-4CC3-AC60-F009B057C557, 7
//
//  Example: 42
DEFINE_PROPERTYKEY(PKEY_RecordedTV_ChannelNumber, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 7);

//  Name:     System.RecordedTV.Credits -- PKEY_RecordedTV_Credits
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 6D748DE2-8D38-4CC3-AC60-F009B057C557, 4
//
//  Example: "Don Messick/Frank Welker/Casey Kasem/Heather North/Nicole Jaffe;;;"
DEFINE_PROPERTYKEY(PKEY_RecordedTV_Credits, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 4);

//  Name:     System.RecordedTV.DateContentExpires -- PKEY_RecordedTV_DateContentExpires
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: 6D748DE2-8D38-4CC3-AC60-F009B057C557, 15
DEFINE_PROPERTYKEY(PKEY_RecordedTV_DateContentExpires, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 15);

//  Name:     System.RecordedTV.EpisodeName -- PKEY_RecordedTV_EpisodeName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 6D748DE2-8D38-4CC3-AC60-F009B057C557, 2
//
//  Example: "Nowhere to Hyde"
DEFINE_PROPERTYKEY(PKEY_RecordedTV_EpisodeName, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 2);

//  Name:     System.RecordedTV.IsATSCContent -- PKEY_RecordedTV_IsATSCContent
//  Type:     Boolean -- VT_BOOL
//  FormatID: 6D748DE2-8D38-4CC3-AC60-F009B057C557, 16
DEFINE_PROPERTYKEY(PKEY_RecordedTV_IsATSCContent, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 16);

//  Name:     System.RecordedTV.IsClosedCaptioningAvailable -- PKEY_RecordedTV_IsClosedCaptioningAvailable
//  Type:     Boolean -- VT_BOOL
//  FormatID: 6D748DE2-8D38-4CC3-AC60-F009B057C557, 12
DEFINE_PROPERTYKEY(PKEY_RecordedTV_IsClosedCaptioningAvailable, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 12);

//  Name:     System.RecordedTV.IsDTVContent -- PKEY_RecordedTV_IsDTVContent
//  Type:     Boolean -- VT_BOOL
//  FormatID: 6D748DE2-8D38-4CC3-AC60-F009B057C557, 17
DEFINE_PROPERTYKEY(PKEY_RecordedTV_IsDTVContent, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 17);

//  Name:     System.RecordedTV.IsHDContent -- PKEY_RecordedTV_IsHDContent
//  Type:     Boolean -- VT_BOOL
//  FormatID: 6D748DE2-8D38-4CC3-AC60-F009B057C557, 18
DEFINE_PROPERTYKEY(PKEY_RecordedTV_IsHDContent, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 18);

//  Name:     System.RecordedTV.IsRepeatBroadcast -- PKEY_RecordedTV_IsRepeatBroadcast
//  Type:     Boolean -- VT_BOOL
//  FormatID: 6D748DE2-8D38-4CC3-AC60-F009B057C557, 13
DEFINE_PROPERTYKEY(PKEY_RecordedTV_IsRepeatBroadcast, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 13);

//  Name:     System.RecordedTV.IsSAP -- PKEY_RecordedTV_IsSAP
//  Type:     Boolean -- VT_BOOL
//  FormatID: 6D748DE2-8D38-4CC3-AC60-F009B057C557, 14
DEFINE_PROPERTYKEY(PKEY_RecordedTV_IsSAP, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 14);

//  Name:     System.RecordedTV.NetworkAffiliation -- PKEY_RecordedTV_NetworkAffiliation
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 2C53C813-FB63-4E22-A1AB-0B331CA1E273, 100
DEFINE_PROPERTYKEY(PKEY_RecordedTV_NetworkAffiliation, 0x2C53C813, 0xFB63, 0x4E22, 0xA1, 0xAB, 0x0B, 0x33, 0x1C, 0xA1, 0xE2, 0x73, 100);

//  Name:     System.RecordedTV.OriginalBroadcastDate -- PKEY_RecordedTV_OriginalBroadcastDate
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: 4684FE97-8765-4842-9C13-F006447B178C, 100
DEFINE_PROPERTYKEY(PKEY_RecordedTV_OriginalBroadcastDate, 0x4684FE97, 0x8765, 0x4842, 0x9C, 0x13, 0xF0, 0x06, 0x44, 0x7B, 0x17, 0x8C, 100);

//  Name:     System.RecordedTV.ProgramDescription -- PKEY_RecordedTV_ProgramDescription
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 6D748DE2-8D38-4CC3-AC60-F009B057C557, 3
DEFINE_PROPERTYKEY(PKEY_RecordedTV_ProgramDescription, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 3);

//  Name:     System.RecordedTV.RecordingTime -- PKEY_RecordedTV_RecordingTime
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: A5477F61-7A82-4ECA-9DDE-98B69B2479B3, 100
DEFINE_PROPERTYKEY(PKEY_RecordedTV_RecordingTime, 0xA5477F61, 0x7A82, 0x4ECA, 0x9D, 0xDE, 0x98, 0xB6, 0x9B, 0x24, 0x79, 0xB3, 100);

//  Name:     System.RecordedTV.StationCallSign -- PKEY_RecordedTV_StationCallSign
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 6D748DE2-8D38-4CC3-AC60-F009B057C557, 5
//
//  Example: "TOONP"
DEFINE_PROPERTYKEY(PKEY_RecordedTV_StationCallSign, 0x6D748DE2, 0x8D38, 0x4CC3, 0xAC, 0x60, 0xF0, 0x09, 0xB0, 0x57, 0xC5, 0x57, 5);

//  Name:     System.RecordedTV.StationName -- PKEY_RecordedTV_StationName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 1B5439E7-EBA1-4AF8-BDD7-7AF1D4549493, 100
DEFINE_PROPERTYKEY(PKEY_RecordedTV_StationName, 0x1B5439E7, 0xEBA1, 0x4AF8, 0xBD, 0xD7, 0x7A, 0xF1, 0xD4, 0x54, 0x94, 0x93, 100);
 
//-----------------------------------------------------------------------------
// Search properties



//  Name:     System.Search.AutoSummary -- PKEY_Search_AutoSummary
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 560C36C0-503A-11CF-BAA1-00004C752A9A, 2
//
//  General Summary of the document.
DEFINE_PROPERTYKEY(PKEY_Search_AutoSummary, 0x560C36C0, 0x503A, 0x11CF, 0xBA, 0xA1, 0x00, 0x00, 0x4C, 0x75, 0x2A, 0x9A, 2);

//  Name:     System.Search.ContainerHash -- PKEY_Search_ContainerHash
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: BCEEE283-35DF-4D53-826A-F36A3EEFC6BE, 100
//
//  Hash code used to identify attachments to be deleted based on a common container url
DEFINE_PROPERTYKEY(PKEY_Search_ContainerHash, 0xBCEEE283, 0x35DF, 0x4D53, 0x82, 0x6A, 0xF3, 0x6A, 0x3E, 0xEF, 0xC6, 0xBE, 100);

//  Name:     System.Search.Contents -- PKEY_Search_Contents
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_Storage) B725F130-47EF-101A-A5F1-02608C9EEBAC, 19 (PID_STG_CONTENTS)
//  
//  The contents of the item. This property is for query restrictions only; it cannot be retrieved in a 
//  query result. The Indexing Service friendly name is 'contents'.
DEFINE_PROPERTYKEY(PKEY_Search_Contents, 0xB725F130, 0x47EF, 0x101A, 0xA5, 0xF1, 0x02, 0x60, 0x8C, 0x9E, 0xEB, 0xAC, 19);

//  Name:     System.Search.EntryID -- PKEY_Search_EntryID
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_Query) 49691C90-7E17-101A-A91C-08002B2ECDA9, 5 (PROPID_QUERY_WORKID)
//  
//  The entry ID for an item within a given catalog in the Windows Search Index.
//  This value may be recycled, and therefore is not considered unique over time.
DEFINE_PROPERTYKEY(PKEY_Search_EntryID, 0x49691C90, 0x7E17, 0x101A, 0xA9, 0x1C, 0x08, 0x00, 0x2B, 0x2E, 0xCD, 0xA9, 5);

//  Name:     System.Search.GatherTime -- PKEY_Search_GatherTime
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: 0B63E350-9CCC-11D0-BCDB-00805FCCCE04, 8
//
//  The Datetime that the Windows Search Gatherer process last pushed properties of this document to the Windows Search Gatherer Plugins.
DEFINE_PROPERTYKEY(PKEY_Search_GatherTime, 0x0B63E350, 0x9CCC, 0x11D0, 0xBC, 0xDB, 0x00, 0x80, 0x5F, 0xCC, 0xCE, 0x04, 8);

//  Name:     System.Search.IsClosedDirectory -- PKEY_Search_IsClosedDirectory
//  Type:     Boolean -- VT_BOOL
//  FormatID: 0B63E343-9CCC-11D0-BCDB-00805FCCCE04, 23
//
//  If this property is emitted with a value of TRUE, then it indicates that this URL's last modified time applies to all of it's children, and if this URL is deleted then all of it's children are deleted as well.  For example, this would be emitted as TRUE when emitting the URL of an email so that all attachments are tied to the last modified time of that email.
DEFINE_PROPERTYKEY(PKEY_Search_IsClosedDirectory, 0x0B63E343, 0x9CCC, 0x11D0, 0xBC, 0xDB, 0x00, 0x80, 0x5F, 0xCC, 0xCE, 0x04, 23);

//  Name:     System.Search.IsFullyContained -- PKEY_Search_IsFullyContained
//  Type:     Boolean -- VT_BOOL
//  FormatID: 0B63E343-9CCC-11D0-BCDB-00805FCCCE04, 24
//
//  Any child URL of a URL which has System.Search.IsClosedDirectory=TRUE must emit System.Search.IsFullyContained=TRUE.  This ensures that the URL is not deleted at the end of a crawl because it hasn't been visited (which is the normal mechanism for detecting deletes).  For example an email attachment would emit this property
DEFINE_PROPERTYKEY(PKEY_Search_IsFullyContained, 0x0B63E343, 0x9CCC, 0x11D0, 0xBC, 0xDB, 0x00, 0x80, 0x5F, 0xCC, 0xCE, 0x04, 24);

//  Name:     System.Search.QueryFocusedSummary -- PKEY_Search_QueryFocusedSummary
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 560C36C0-503A-11CF-BAA1-00004C752A9A, 3
//
//  Query Focused Summary of the document.
DEFINE_PROPERTYKEY(PKEY_Search_QueryFocusedSummary, 0x560C36C0, 0x503A, 0x11CF, 0xBA, 0xA1, 0x00, 0x00, 0x4C, 0x75, 0x2A, 0x9A, 3);

//  Name:     System.Search.Rank -- PKEY_Search_Rank
//  Type:     Int32 -- VT_I4
//  FormatID: (FMTID_Query) 49691C90-7E17-101A-A91C-08002B2ECDA9, 3 (PROPID_QUERY_RANK)
//  
//  Relevance rank of row. Ranges from 0-1000. Larger numbers = better matches.  Query-time only, not 
//  defined in Search schema, retrievable but not searchable.
DEFINE_PROPERTYKEY(PKEY_Search_Rank, 0x49691C90, 0x7E17, 0x101A, 0xA9, 0x1C, 0x08, 0x00, 0x2B, 0x2E, 0xCD, 0xA9, 3);

//  Name:     System.Search.Store -- PKEY_Search_Store
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: A06992B3-8CAF-4ED7-A547-B259E32AC9FC, 100
//
//  The identifier for the protocol handler that produced this item. (E.g. MAPI, CSC, FILE etc.)
DEFINE_PROPERTYKEY(PKEY_Search_Store, 0xA06992B3, 0x8CAF, 0x4ED7, 0xA5, 0x47, 0xB2, 0x59, 0xE3, 0x2A, 0xC9, 0xFC, 100);

//  Name:     System.Search.UrlToIndex -- PKEY_Search_UrlToIndex
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 0B63E343-9CCC-11D0-BCDB-00805FCCCE04, 2
//
//  This property should be emitted by a container IFilter for each child URL within the container.  The children will eventually be crawled by the indexer if they are within scope.
DEFINE_PROPERTYKEY(PKEY_Search_UrlToIndex, 0x0B63E343, 0x9CCC, 0x11D0, 0xBC, 0xDB, 0x00, 0x80, 0x5F, 0xCC, 0xCE, 0x04, 2);

//  Name:     System.Search.UrlToIndexWithModificationTime -- PKEY_Search_UrlToIndexWithModificationTime
//  Type:     Multivalue Any -- VT_VECTOR | VT_NULL  (For variants: VT_ARRAY | VT_NULL)
//  FormatID: 0B63E343-9CCC-11D0-BCDB-00805FCCCE04, 12
//
//  This property is the same as System.Search.UrlToIndex except that it includes the time the URL was last modified.  This is an optimization for the indexer as it doesn't have to call back into the protocol handler to ask for this information to determine if the content needs to be indexed again.  The property is a vector with two elements, a VT_LPWSTR with the URL and a VT_FILETIME for the last modified time.
DEFINE_PROPERTYKEY(PKEY_Search_UrlToIndexWithModificationTime, 0x0B63E343, 0x9CCC, 0x11D0, 0xBC, 0xDB, 0x00, 0x80, 0x5F, 0xCC, 0xCE, 0x04, 12);
 
//-----------------------------------------------------------------------------
// Shell properties



//  Name:     System.DescriptionID -- PKEY_DescriptionID
//  Type:     Buffer -- VT_VECTOR | VT_UI1  (For variants: VT_ARRAY | VT_UI1)
//  FormatID: (FMTID_ShellDetails) 28636AA6-953D-11D2-B5D6-00C04FD918D0, 2 (PID_DESCRIPTIONID)
//
//  The contents of a SHDESCRIPTIONID structure as a buffer of bytes.
DEFINE_PROPERTYKEY(PKEY_DescriptionID, 0x28636AA6, 0x953D, 0x11D2, 0xB5, 0xD6, 0x00, 0xC0, 0x4F, 0xD9, 0x18, 0xD0, 2);

//  Name:     System.Link.TargetSFGAOFlagsStrings -- PKEY_Link_TargetSFGAOFlagsStrings
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: D6942081-D53B-443D-AD47-5E059D9CD27A, 3
//  
//  Expresses the SFGAO flags of a link as string values and is used as a query optimization.  See 
//  PKEY_Shell_SFGAOFlagsStrings for possible values of this.
DEFINE_PROPERTYKEY(PKEY_Link_TargetSFGAOFlagsStrings, 0xD6942081, 0xD53B, 0x443D, 0xAD, 0x47, 0x5E, 0x05, 0x9D, 0x9C, 0xD2, 0x7A, 3);

//  Name:     System.Link.TargetUrl -- PKEY_Link_TargetUrl
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 5CBF2787-48CF-4208-B90E-EE5E5D420294, 2  (PKEYs relating to URLs.  Used by IE History.)
DEFINE_PROPERTYKEY(PKEY_Link_TargetUrl, 0x5CBF2787, 0x48CF, 0x4208, 0xB9, 0x0E, 0xEE, 0x5E, 0x5D, 0x42, 0x02, 0x94, 2);

//  Name:     System.Shell.SFGAOFlagsStrings -- PKEY_Shell_SFGAOFlagsStrings
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: D6942081-D53B-443D-AD47-5E059D9CD27A, 2
//
//  Expresses the SFGAO flags as string values and is used as a query optimization.
DEFINE_PROPERTYKEY(PKEY_Shell_SFGAOFlagsStrings, 0xD6942081, 0xD53B, 0x443D, 0xAD, 0x47, 0x5E, 0x05, 0x9D, 0x9C, 0xD2, 0x7A, 2);

// Possible discrete values for PKEY_Shell_SFGAOFlagsStrings are:
#define SFGAOSTR_FILESYS                    L"filesys"               // SFGAO_FILESYSTEM
#define SFGAOSTR_FILEANC                    L"fileanc"               // SFGAO_FILESYSANCESTOR
#define SFGAOSTR_STORAGEANC                 L"storageanc"               // SFGAO_STORAGEANCESTOR
#define SFGAOSTR_STREAM                     L"stream"               // SFGAO_STREAM
#define SFGAOSTR_LINK                       L"link"               // SFGAO_LINK
#define SFGAOSTR_HIDDEN                     L"hidden"               // SFGAO_HIDDEN
#define SFGAOSTR_FOLDER                     L"folder"               // SFGAO_FOLDER
#define SFGAOSTR_NONENUM                    L"nonenum"               // SFGAO_NONENUMERATED
#define SFGAOSTR_BROWSABLE                  L"browsable"               // SFGAO_BROWSABLE
 
//-----------------------------------------------------------------------------
// Software properties



//  Name:     System.Software.DateLastUsed -- PKEY_Software_DateLastUsed
//  Type:     DateTime -- VT_FILETIME  (For variants: VT_DATE)
//  FormatID: 841E4F90-FF59-4D16-8947-E81BBFFAB36D, 16
//  
//  
DEFINE_PROPERTYKEY(PKEY_Software_DateLastUsed, 0x841E4F90, 0xFF59, 0x4D16, 0x89, 0x47, 0xE8, 0x1B, 0xBF, 0xFA, 0xB3, 0x6D, 16);

//  Name:     System.Software.ProductName -- PKEY_Software_ProductName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (PSFMTID_VERSION) 0CEF7D53-FA64-11D1-A203-0000F81FEDEE, 7
//  
//  
DEFINE_PROPERTYKEY(PKEY_Software_ProductName, 0x0CEF7D53, 0xFA64, 0x11D1, 0xA2, 0x03, 0x00, 0x00, 0xF8, 0x1F, 0xED, 0xEE, 7);
 
//-----------------------------------------------------------------------------
// Sync properties



//  Name:     System.Sync.Comments -- PKEY_Sync_Comments
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 7BD5533E-AF15-44DB-B8C8-BD6624E1D032, 13
DEFINE_PROPERTYKEY(PKEY_Sync_Comments, 0x7BD5533E, 0xAF15, 0x44DB, 0xB8, 0xC8, 0xBD, 0x66, 0x24, 0xE1, 0xD0, 0x32, 13);

//  Name:     System.Sync.ConflictDescription -- PKEY_Sync_ConflictDescription
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: CE50C159-2FB8-41FD-BE68-D3E042E274BC, 4
DEFINE_PROPERTYKEY(PKEY_Sync_ConflictDescription, 0xCE50C159, 0x2FB8, 0x41FD, 0xBE, 0x68, 0xD3, 0xE0, 0x42, 0xE2, 0x74, 0xBC, 4);

//  Name:     System.Sync.ConflictFirstLocation -- PKEY_Sync_ConflictFirstLocation
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: CE50C159-2FB8-41FD-BE68-D3E042E274BC, 6
DEFINE_PROPERTYKEY(PKEY_Sync_ConflictFirstLocation, 0xCE50C159, 0x2FB8, 0x41FD, 0xBE, 0x68, 0xD3, 0xE0, 0x42, 0xE2, 0x74, 0xBC, 6);

//  Name:     System.Sync.ConflictSecondLocation -- PKEY_Sync_ConflictSecondLocation
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: CE50C159-2FB8-41FD-BE68-D3E042E274BC, 7
DEFINE_PROPERTYKEY(PKEY_Sync_ConflictSecondLocation, 0xCE50C159, 0x2FB8, 0x41FD, 0xBE, 0x68, 0xD3, 0xE0, 0x42, 0xE2, 0x74, 0xBC, 7);

//  Name:     System.Sync.HandlerCollectionID -- PKEY_Sync_HandlerCollectionID
//  Type:     Guid -- VT_CLSID
//  FormatID: 7BD5533E-AF15-44DB-B8C8-BD6624E1D032, 2
DEFINE_PROPERTYKEY(PKEY_Sync_HandlerCollectionID, 0x7BD5533E, 0xAF15, 0x44DB, 0xB8, 0xC8, 0xBD, 0x66, 0x24, 0xE1, 0xD0, 0x32, 2);

//  Name:     System.Sync.HandlerID -- PKEY_Sync_HandlerID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 7BD5533E-AF15-44DB-B8C8-BD6624E1D032, 3
DEFINE_PROPERTYKEY(PKEY_Sync_HandlerID, 0x7BD5533E, 0xAF15, 0x44DB, 0xB8, 0xC8, 0xBD, 0x66, 0x24, 0xE1, 0xD0, 0x32, 3);

//  Name:     System.Sync.HandlerName -- PKEY_Sync_HandlerName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: CE50C159-2FB8-41FD-BE68-D3E042E274BC, 2
DEFINE_PROPERTYKEY(PKEY_Sync_HandlerName, 0xCE50C159, 0x2FB8, 0x41FD, 0xBE, 0x68, 0xD3, 0xE0, 0x42, 0xE2, 0x74, 0xBC, 2);

//  Name:     System.Sync.HandlerType -- PKEY_Sync_HandlerType
//  Type:     UInt32 -- VT_UI4
//  FormatID: 7BD5533E-AF15-44DB-B8C8-BD6624E1D032, 8
//  
//  
DEFINE_PROPERTYKEY(PKEY_Sync_HandlerType, 0x7BD5533E, 0xAF15, 0x44DB, 0xB8, 0xC8, 0xBD, 0x66, 0x24, 0xE1, 0xD0, 0x32, 8);

// Possible discrete values for PKEY_Sync_HandlerType are:
#define SYNC_HANDLERTYPE_OTHER              0ul
#define SYNC_HANDLERTYPE_PROGRAMS           1ul
#define SYNC_HANDLERTYPE_DEVICES            2ul
#define SYNC_HANDLERTYPE_FOLDERS            3ul
#define SYNC_HANDLERTYPE_WEBSERVICES        4ul
#define SYNC_HANDLERTYPE_COMPUTERS          5ul

//  Name:     System.Sync.HandlerTypeLabel -- PKEY_Sync_HandlerTypeLabel
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 7BD5533E-AF15-44DB-B8C8-BD6624E1D032, 9
//  
//  
DEFINE_PROPERTYKEY(PKEY_Sync_HandlerTypeLabel, 0x7BD5533E, 0xAF15, 0x44DB, 0xB8, 0xC8, 0xBD, 0x66, 0x24, 0xE1, 0xD0, 0x32, 9);

//  Name:     System.Sync.ItemID -- PKEY_Sync_ItemID
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 7BD5533E-AF15-44DB-B8C8-BD6624E1D032, 6
DEFINE_PROPERTYKEY(PKEY_Sync_ItemID, 0x7BD5533E, 0xAF15, 0x44DB, 0xB8, 0xC8, 0xBD, 0x66, 0x24, 0xE1, 0xD0, 0x32, 6);

//  Name:     System.Sync.ItemName -- PKEY_Sync_ItemName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: CE50C159-2FB8-41FD-BE68-D3E042E274BC, 3
DEFINE_PROPERTYKEY(PKEY_Sync_ItemName, 0xCE50C159, 0x2FB8, 0x41FD, 0xBE, 0x68, 0xD3, 0xE0, 0x42, 0xE2, 0x74, 0xBC, 3);
 
//-----------------------------------------------------------------------------
// Task properties

//  Name:     System.Task.BillingInformation -- PKEY_Task_BillingInformation
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: D37D52C6-261C-4303-82B3-08B926AC6F12, 100
DEFINE_PROPERTYKEY(PKEY_Task_BillingInformation, 0xD37D52C6, 0x261C, 0x4303, 0x82, 0xB3, 0x08, 0xB9, 0x26, 0xAC, 0x6F, 0x12, 100);

//  Name:     System.Task.CompletionStatus -- PKEY_Task_CompletionStatus
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 084D8A0A-E6D5-40DE-BF1F-C8820E7C877C, 100
DEFINE_PROPERTYKEY(PKEY_Task_CompletionStatus, 0x084D8A0A, 0xE6D5, 0x40DE, 0xBF, 0x1F, 0xC8, 0x82, 0x0E, 0x7C, 0x87, 0x7C, 100);

//  Name:     System.Task.Owner -- PKEY_Task_Owner
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: 08C7CC5F-60F2-4494-AD75-55E3E0B5ADD0, 100
DEFINE_PROPERTYKEY(PKEY_Task_Owner, 0x08C7CC5F, 0x60F2, 0x4494, 0xAD, 0x75, 0x55, 0xE3, 0xE0, 0xB5, 0xAD, 0xD0, 100);

 
 
//-----------------------------------------------------------------------------
// Video properties

//  Name:     System.Video.Compression -- PKEY_Video_Compression
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_VideoSummaryInformation) 64440491-4C8B-11D1-8B70-080036B11A03, 10 (PIDVSI_COMPRESSION)
//
//  Indicates the level of compression for the video stream.  "Compression".
DEFINE_PROPERTYKEY(PKEY_Video_Compression, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 10);

//  Name:     System.Video.Director -- PKEY_Video_Director
//  Type:     Multivalue String -- VT_VECTOR | VT_LPWSTR  (For variants: VT_ARRAY | VT_BSTR)
//  FormatID: (PSGUID_MEDIAFILESUMMARYINFORMATION) 64440492-4C8B-11D1-8B70-080036B11A03, 20 (PIDMSI_DIRECTOR)
//
//  
DEFINE_PROPERTYKEY(PKEY_Video_Director, 0x64440492, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 20);

//  Name:     System.Video.EncodingBitrate -- PKEY_Video_EncodingBitrate
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) 64440491-4C8B-11D1-8B70-080036B11A03, 8 (PIDVSI_DATA_RATE)
//
//  Indicates the data rate in "bits per second" for the video stream. "DataRate".
DEFINE_PROPERTYKEY(PKEY_Video_EncodingBitrate, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 8);

//  Name:     System.Video.FourCC -- PKEY_Video_FourCC
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) 64440491-4C8B-11D1-8B70-080036B11A03, 44
//  
//  Indicates the 4CC for the video stream.
DEFINE_PROPERTYKEY(PKEY_Video_FourCC, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 44);

//  Name:     System.Video.FrameHeight -- PKEY_Video_FrameHeight
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) 64440491-4C8B-11D1-8B70-080036B11A03, 4
//
//  Indicates the frame height for the video stream.
DEFINE_PROPERTYKEY(PKEY_Video_FrameHeight, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 4);

//  Name:     System.Video.FrameRate -- PKEY_Video_FrameRate
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) 64440491-4C8B-11D1-8B70-080036B11A03, 6 (PIDVSI_FRAME_RATE)
//
//  Indicates the frame rate in "frames per millisecond" for the video stream.  "FrameRate".
DEFINE_PROPERTYKEY(PKEY_Video_FrameRate, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 6);

//  Name:     System.Video.FrameWidth -- PKEY_Video_FrameWidth
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) 64440491-4C8B-11D1-8B70-080036B11A03, 3
//
//  Indicates the frame width for the video stream.
DEFINE_PROPERTYKEY(PKEY_Video_FrameWidth, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 3);

//  Name:     System.Video.HorizontalAspectRatio -- PKEY_Video_HorizontalAspectRatio
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) 64440491-4C8B-11D1-8B70-080036B11A03, 42
//  
//  Indicates the horizontal portion of the aspect ratio. The X portion of XX:YY,
//  like 16:9.
DEFINE_PROPERTYKEY(PKEY_Video_HorizontalAspectRatio, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 42);

//  Name:     System.Video.SampleSize -- PKEY_Video_SampleSize
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) 64440491-4C8B-11D1-8B70-080036B11A03, 9 (PIDVSI_SAMPLE_SIZE)
//
//  Indicates the sample size in bits for the video stream.  "SampleSize".
DEFINE_PROPERTYKEY(PKEY_Video_SampleSize, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 9);

//  Name:     System.Video.StreamName -- PKEY_Video_StreamName
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_VideoSummaryInformation) 64440491-4C8B-11D1-8B70-080036B11A03, 2 (PIDVSI_STREAM_NAME)
//
//  Indicates the name for the video stream. "StreamName".
DEFINE_PROPERTYKEY(PKEY_Video_StreamName, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 2);

//  Name:     System.Video.StreamNumber -- PKEY_Video_StreamNumber
//  Type:     UInt16 -- VT_UI2
//  FormatID: (FMTID_VideoSummaryInformation) 64440491-4C8B-11D1-8B70-080036B11A03, 11 (PIDVSI_STREAM_NUMBER)
//
//  "Stream Number".
DEFINE_PROPERTYKEY(PKEY_Video_StreamNumber, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 11);

//  Name:     System.Video.TotalBitrate -- PKEY_Video_TotalBitrate
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) 64440491-4C8B-11D1-8B70-080036B11A03, 43 (PIDVSI_TOTAL_BITRATE)
//
//  Indicates the total data rate in "bits per second" for all video and audio streams.
DEFINE_PROPERTYKEY(PKEY_Video_TotalBitrate, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 43);

//  Name:     System.Video.VerticalAspectRatio -- PKEY_Video_VerticalAspectRatio
//  Type:     UInt32 -- VT_UI4
//  FormatID: (FMTID_VideoSummaryInformation) 64440491-4C8B-11D1-8B70-080036B11A03, 45
//  
//  Indicates the vertical portion of the aspect ratio. The Y portion of 
//  XX:YY, like 16:9.
DEFINE_PROPERTYKEY(PKEY_Video_VerticalAspectRatio, 0x64440491, 0x4C8B, 0x11D1, 0x8B, 0x70, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03, 45);

 
 
//-----------------------------------------------------------------------------
// Volume properties

//  Name:     System.Volume.FileSystem -- PKEY_Volume_FileSystem
//  Type:     String -- VT_LPWSTR  (For variants: VT_BSTR)
//  FormatID: (FMTID_Volume) 9B174B35-40FF-11D2-A27E-00C04FC30871, 4 (PID_VOLUME_FILESYSTEM)  (Filesystem Volume Properties)
//
//  Indicates the filesystem of the volume.
DEFINE_PROPERTYKEY(PKEY_Volume_FileSystem, 0x9B174B35, 0x40FF, 0x11D2, 0xA2, 0x7E, 0x00, 0xC0, 0x4F, 0xC3, 0x08, 0x71, 4);

//  Name:     System.Volume.IsMappedDrive -- PKEY_Volume_IsMappedDrive
//  Type:     Boolean -- VT_BOOL
//  FormatID: 149C0B69-2C2D-48FC-808F-D318D78C4636, 2
DEFINE_PROPERTYKEY(PKEY_Volume_IsMappedDrive, 0x149C0B69, 0x2C2D, 0x48FC, 0x80, 0x8F, 0xD3, 0x18, 0xD7, 0x8C, 0x46, 0x36, 2);

//  Name:     System.Volume.IsRoot -- PKEY_Volume_IsRoot
//  Type:     Boolean -- VT_BOOL
//  FormatID: (FMTID_Volume) 9B174B35-40FF-11D2-A27E-00C04FC30871, 10  (Filesystem Volume Properties)
//
//  
DEFINE_PROPERTYKEY(PKEY_Volume_IsRoot, 0x9B174B35, 0x40FF, 0x11D2, 0xA2, 0x7E, 0x00, 0xC0, 0x4F, 0xC3, 0x08, 0x71, 10);

#endif  /* _INC_PROPKEY */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\PropIdl.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for propidl.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __propidl_h__
#define __propidl_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPropertyStorage_FWD_DEFINED__
#define __IPropertyStorage_FWD_DEFINED__
typedef interface IPropertyStorage IPropertyStorage;
#endif 	/* __IPropertyStorage_FWD_DEFINED__ */


#ifndef __IPropertySetStorage_FWD_DEFINED__
#define __IPropertySetStorage_FWD_DEFINED__
typedef interface IPropertySetStorage IPropertySetStorage;
#endif 	/* __IPropertySetStorage_FWD_DEFINED__ */


#ifndef __IEnumSTATPROPSTG_FWD_DEFINED__
#define __IEnumSTATPROPSTG_FWD_DEFINED__
typedef interface IEnumSTATPROPSTG IEnumSTATPROPSTG;
#endif 	/* __IEnumSTATPROPSTG_FWD_DEFINED__ */


#ifndef __IEnumSTATPROPSETSTG_FWD_DEFINED__
#define __IEnumSTATPROPSETSTG_FWD_DEFINED__
typedef interface IEnumSTATPROPSETSTG IEnumSTATPROPSETSTG;
#endif 	/* __IEnumSTATPROPSETSTG_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_propidl_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)    /* Nameless struct/union */
#pragma warning(disable:4237)    /* obsolete member named 'bool' */
#endif
#if ( _MSC_VER >= 1020 )
#pragma once
#endif



typedef struct tagVersionedStream
    {
    GUID guidVersion;
    IStream *pStream;
    } 	VERSIONEDSTREAM;

typedef struct tagVersionedStream *LPVERSIONEDSTREAM;


// Flags for IPropertySetStorage::Create
#define	PROPSETFLAG_DEFAULT	( 0 )

#define	PROPSETFLAG_NONSIMPLE	( 1 )

#define	PROPSETFLAG_ANSI	( 2 )

//   (This flag is only supported on StgCreatePropStg & StgOpenPropStg
#define	PROPSETFLAG_UNBUFFERED	( 4 )

//   (This flag causes a version-1 property set to be created
#define	PROPSETFLAG_CASE_SENSITIVE	( 8 )


// Flags for the reservied PID_BEHAVIOR property
#define	PROPSET_BEHAVIOR_CASE_SENSITIVE	( 1 )

#ifdef MIDL_PASS
// This is the PROPVARIANT definition for marshaling.
typedef struct tag_inner_PROPVARIANT PROPVARIANT;

#else
// This is the standard C layout of the PROPVARIANT.
typedef struct tagPROPVARIANT PROPVARIANT;
#endif
typedef struct tagCAC
    {
    ULONG cElems;
    CHAR *pElems;
    } 	CAC;

typedef struct tagCAUB
    {
    ULONG cElems;
    UCHAR *pElems;
    } 	CAUB;

typedef struct tagCAI
    {
    ULONG cElems;
    SHORT *pElems;
    } 	CAI;

typedef struct tagCAUI
    {
    ULONG cElems;
    USHORT *pElems;
    } 	CAUI;

typedef struct tagCAL
    {
    ULONG cElems;
    LONG *pElems;
    } 	CAL;

typedef struct tagCAUL
    {
    ULONG cElems;
    ULONG *pElems;
    } 	CAUL;

typedef struct tagCAFLT
    {
    ULONG cElems;
    FLOAT *pElems;
    } 	CAFLT;

typedef struct tagCADBL
    {
    ULONG cElems;
    DOUBLE *pElems;
    } 	CADBL;

typedef struct tagCACY
    {
    ULONG cElems;
    CY *pElems;
    } 	CACY;

typedef struct tagCADATE
    {
    ULONG cElems;
    DATE *pElems;
    } 	CADATE;

typedef struct tagCABSTR
    {
    ULONG cElems;
    BSTR *pElems;
    } 	CABSTR;

typedef struct tagCABSTRBLOB
    {
    ULONG cElems;
    BSTRBLOB *pElems;
    } 	CABSTRBLOB;

typedef struct tagCABOOL
    {
    ULONG cElems;
    VARIANT_BOOL *pElems;
    } 	CABOOL;

typedef struct tagCASCODE
    {
    ULONG cElems;
    SCODE *pElems;
    } 	CASCODE;

typedef struct tagCAPROPVARIANT
    {
    ULONG cElems;
    PROPVARIANT *pElems;
    } 	CAPROPVARIANT;

typedef struct tagCAH
    {
    ULONG cElems;
    LARGE_INTEGER *pElems;
    } 	CAH;

typedef struct tagCAUH
    {
    ULONG cElems;
    ULARGE_INTEGER *pElems;
    } 	CAUH;

typedef struct tagCALPSTR
    {
    ULONG cElems;
    LPSTR *pElems;
    } 	CALPSTR;

typedef struct tagCALPWSTR
    {
    ULONG cElems;
    LPWSTR *pElems;
    } 	CALPWSTR;

typedef struct tagCAFILETIME
    {
    ULONG cElems;
    FILETIME *pElems;
    } 	CAFILETIME;

typedef struct tagCACLIPDATA
    {
    ULONG cElems;
    CLIPDATA *pElems;
    } 	CACLIPDATA;

typedef struct tagCACLSID
    {
    ULONG cElems;
    CLSID *pElems;
    } 	CACLSID;

#ifdef MIDL_PASS
// This is the PROPVARIANT padding layout for marshaling.
typedef BYTE PROPVAR_PAD1;

typedef BYTE PROPVAR_PAD2;

typedef ULONG PROPVAR_PAD3;

#else
// This is the standard C layout of the structure.
typedef WORD PROPVAR_PAD1;
typedef WORD PROPVAR_PAD2;
typedef WORD PROPVAR_PAD3;
#define tag_inner_PROPVARIANT
#endif
#ifndef MIDL_PASS
struct tagPROPVARIANT {
  union {
#endif
struct tag_inner_PROPVARIANT
    {
    VARTYPE vt;
    PROPVAR_PAD1 wReserved1;
    PROPVAR_PAD2 wReserved2;
    PROPVAR_PAD3 wReserved3;
    /* [switch_type] */ union 
        {
         /* Empty union arm */ 
        CHAR cVal;
        UCHAR bVal;
        SHORT iVal;
        USHORT uiVal;
        LONG lVal;
        ULONG ulVal;
        INT intVal;
        UINT uintVal;
        LARGE_INTEGER hVal;
        ULARGE_INTEGER uhVal;
        FLOAT fltVal;
        DOUBLE dblVal;
        VARIANT_BOOL boolVal;
        _VARIANT_BOOL bool;
        SCODE scode;
        CY cyVal;
        DATE date;
        FILETIME filetime;
        CLSID *puuid;
        CLIPDATA *pclipdata;
        BSTR bstrVal;
        BSTRBLOB bstrblobVal;
        BLOB blob;
        LPSTR pszVal;
        LPWSTR pwszVal;
        IUnknown *punkVal;
        IDispatch *pdispVal;
        IStream *pStream;
        IStorage *pStorage;
        LPVERSIONEDSTREAM pVersionedStream;
        LPSAFEARRAY parray;
        CAC cac;
        CAUB caub;
        CAI cai;
        CAUI caui;
        CAL cal;
        CAUL caul;
        CAH cah;
        CAUH cauh;
        CAFLT caflt;
        CADBL cadbl;
        CABOOL cabool;
        CASCODE cascode;
        CACY cacy;
        CADATE cadate;
        CAFILETIME cafiletime;
        CACLSID cauuid;
        CACLIPDATA caclipdata;
        CABSTR cabstr;
        CABSTRBLOB cabstrblob;
        CALPSTR calpstr;
        CALPWSTR calpwstr;
        CAPROPVARIANT capropvar;
        CHAR *pcVal;
        UCHAR *pbVal;
        SHORT *piVal;
        USHORT *puiVal;
        LONG *plVal;
        ULONG *pulVal;
        INT *pintVal;
        UINT *puintVal;
        FLOAT *pfltVal;
        DOUBLE *pdblVal;
        VARIANT_BOOL *pboolVal;
        DECIMAL *pdecVal;
        SCODE *pscode;
        CY *pcyVal;
        DATE *pdate;
        BSTR *pbstrVal;
        IUnknown **ppunkVal;
        IDispatch **ppdispVal;
        LPSAFEARRAY *pparray;
        PROPVARIANT *pvarVal;
        } 	;
    } ;
#ifndef MIDL_PASS
    DECIMAL decVal;
  };
};
#endif
#ifdef MIDL_PASS
// This is the LPPROPVARIANT definition for marshaling.
typedef struct tag_inner_PROPVARIANT *LPPROPVARIANT;

typedef const PROPVARIANT *REFPROPVARIANT;

#else

// This is the standard C layout of the PROPVARIANT.
typedef struct tagPROPVARIANT * LPPROPVARIANT;

#ifndef _REFPROPVARIANT_DEFINED
#define _REFPROPVARIANT_DEFINED
#ifdef __cplusplus
#define REFPROPVARIANT const PROPVARIANT &
#else
#define REFPROPVARIANT const PROPVARIANT * __MIDL_CONST
#endif
#endif

#endif // MIDL_PASS

// Reserved global Property IDs
#define	PID_DICTIONARY	( 0 )

#define	PID_CODEPAGE	( 0x1 )

#define	PID_FIRST_USABLE	( 0x2 )

#define	PID_FIRST_NAME_DEFAULT	( 0xfff )

#define	PID_LOCALE	( 0x80000000 )

#define	PID_MODIFY_TIME	( 0x80000001 )

#define	PID_SECURITY	( 0x80000002 )

#define	PID_BEHAVIOR	( 0x80000003 )

#define	PID_ILLEGAL	( 0xffffffff )

// Range which is read-only to downlevel implementations
#define	PID_MIN_READONLY	( 0x80000000 )

#define	PID_MAX_READONLY	( 0xbfffffff )

// Property IDs for the DiscardableInformation Property Set

#define PIDDI_THUMBNAIL          0x00000002L // VT_BLOB

// Property IDs for the SummaryInformation Property Set

#define PIDSI_TITLE               0x00000002L  // VT_LPSTR
#define PIDSI_SUBJECT             0x00000003L  // VT_LPSTR
#define PIDSI_AUTHOR              0x00000004L  // VT_LPSTR
#define PIDSI_KEYWORDS            0x00000005L  // VT_LPSTR
#define PIDSI_COMMENTS            0x00000006L  // VT_LPSTR
#define PIDSI_TEMPLATE            0x00000007L  // VT_LPSTR
#define PIDSI_LASTAUTHOR          0x00000008L  // VT_LPSTR
#define PIDSI_REVNUMBER           0x00000009L  // VT_LPSTR
#define PIDSI_EDITTIME            0x0000000aL  // VT_FILETIME (UTC)
#define PIDSI_LASTPRINTED         0x0000000bL  // VT_FILETIME (UTC)
#define PIDSI_CREATE_DTM          0x0000000cL  // VT_FILETIME (UTC)
#define PIDSI_LASTSAVE_DTM        0x0000000dL  // VT_FILETIME (UTC)
#define PIDSI_PAGECOUNT           0x0000000eL  // VT_I4
#define PIDSI_WORDCOUNT           0x0000000fL  // VT_I4
#define PIDSI_CHARCOUNT           0x00000010L  // VT_I4
#define PIDSI_THUMBNAIL           0x00000011L  // VT_CF
#define PIDSI_APPNAME             0x00000012L  // VT_LPSTR
#define PIDSI_DOC_SECURITY        0x00000013L  // VT_I4

// Property IDs for the DocSummaryInformation Property Set

#define PIDDSI_CATEGORY          0x00000002 // VT_LPSTR
#define PIDDSI_PRESFORMAT        0x00000003 // VT_LPSTR
#define PIDDSI_BYTECOUNT         0x00000004 // VT_I4
#define PIDDSI_LINECOUNT         0x00000005 // VT_I4
#define PIDDSI_PARCOUNT          0x00000006 // VT_I4
#define PIDDSI_SLIDECOUNT        0x00000007 // VT_I4
#define PIDDSI_NOTECOUNT         0x00000008 // VT_I4
#define PIDDSI_HIDDENCOUNT       0x00000009 // VT_I4
#define PIDDSI_MMCLIPCOUNT       0x0000000A // VT_I4
#define PIDDSI_SCALE             0x0000000B // VT_BOOL
#define PIDDSI_HEADINGPAIR       0x0000000C // VT_VARIANT | VT_VECTOR
#define PIDDSI_DOCPARTS          0x0000000D // VT_LPSTR | VT_VECTOR
#define PIDDSI_MANAGER           0x0000000E // VT_LPSTR
#define PIDDSI_COMPANY           0x0000000F // VT_LPSTR
#define PIDDSI_LINKSDIRTY        0x00000010 // VT_BOOL


//  FMTID_MediaFileSummaryInfo - Property IDs

#define PIDMSI_EDITOR                   0x00000002L  // VT_LPWSTR
#define PIDMSI_SUPPLIER                 0x00000003L  // VT_LPWSTR
#define PIDMSI_SOURCE                   0x00000004L  // VT_LPWSTR
#define PIDMSI_SEQUENCE_NO              0x00000005L  // VT_LPWSTR
#define PIDMSI_PROJECT                  0x00000006L  // VT_LPWSTR
#define PIDMSI_STATUS                   0x00000007L  // VT_UI4
#define PIDMSI_OWNER                    0x00000008L  // VT_LPWSTR
#define PIDMSI_RATING                   0x00000009L  // VT_LPWSTR
#define PIDMSI_PRODUCTION               0x0000000AL  // VT_FILETIME (UTC)
#define PIDMSI_COPYRIGHT                0x0000000BL  // VT_LPWSTR

//  PIDMSI_STATUS value definitions

enum PIDMSI_STATUS_VALUE
    {	PIDMSI_STATUS_NORMAL	= 0,
	PIDMSI_STATUS_NEW	= ( PIDMSI_STATUS_NORMAL + 1 ) ,
	PIDMSI_STATUS_PRELIM	= ( PIDMSI_STATUS_NEW + 1 ) ,
	PIDMSI_STATUS_DRAFT	= ( PIDMSI_STATUS_PRELIM + 1 ) ,
	PIDMSI_STATUS_INPROGRESS	= ( PIDMSI_STATUS_DRAFT + 1 ) ,
	PIDMSI_STATUS_EDIT	= ( PIDMSI_STATUS_INPROGRESS + 1 ) ,
	PIDMSI_STATUS_REVIEW	= ( PIDMSI_STATUS_EDIT + 1 ) ,
	PIDMSI_STATUS_PROOF	= ( PIDMSI_STATUS_REVIEW + 1 ) ,
	PIDMSI_STATUS_FINAL	= ( PIDMSI_STATUS_PROOF + 1 ) ,
	PIDMSI_STATUS_OTHER	= 0x7fff
    } ;
#define	PRSPEC_INVALID	( 0xffffffff )

#define	PRSPEC_LPWSTR	( 0 )

#define	PRSPEC_PROPID	( 1 )

typedef struct tagPROPSPEC
    {
    ULONG ulKind;
    /* [switch_type] */ union 
        {
        PROPID propid;
        LPOLESTR lpwstr;
         /* Empty union arm */ 
        } 	;
    } 	PROPSPEC;

typedef struct tagSTATPROPSTG
    {
    LPOLESTR lpwstrName;
    PROPID propid;
    VARTYPE vt;
    } 	STATPROPSTG;

// Macros for parsing the OS Version of the Property Set Header
#define PROPSETHDR_OSVER_KIND(dwOSVer)      HIWORD( (dwOSVer) )
#define PROPSETHDR_OSVER_MAJOR(dwOSVer)     LOBYTE(LOWORD( (dwOSVer) ))
#define PROPSETHDR_OSVER_MINOR(dwOSVer)     HIBYTE(LOWORD( (dwOSVer) ))
#define PROPSETHDR_OSVERSION_UNKNOWN        0xFFFFFFFF
typedef struct tagSTATPROPSETSTG
    {
    FMTID fmtid;
    CLSID clsid;
    DWORD grfFlags;
    FILETIME mtime;
    FILETIME ctime;
    FILETIME atime;
    DWORD dwOSVersion;
    } 	STATPROPSETSTG;



extern RPC_IF_HANDLE __MIDL_itf_propidl_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propidl_0000_0000_v0_0_s_ifspec;

#ifndef __IPropertyStorage_INTERFACE_DEFINED__
#define __IPropertyStorage_INTERFACE_DEFINED__

/* interface IPropertyStorage */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IPropertyStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000138-0000-0000-C000-000000000046")
    IPropertyStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReadMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) PROPVARIANT rgpropvar[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPVARIANT rgpropvar[  ],
            /* [in] */ PROPID propidNameFirst) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadPropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpropid) LPOLESTR rglpwstrName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WritePropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const LPOLESTR rglpwstrName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeletePropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ DWORD grfCommitFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Revert( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enum( 
            /* [out] */ __RPC__deref_out_opt IEnumSTATPROPSTG **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimes( 
            /* [in] */ __RPC__in const FILETIME *pctime,
            /* [in] */ __RPC__in const FILETIME *patime,
            /* [in] */ __RPC__in const FILETIME *pmtime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClass( 
            /* [in] */ __RPC__in REFCLSID clsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stat( 
            /* [out] */ __RPC__out STATPROPSETSTG *pstatpsstg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyStorage * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyStorage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReadMultiple )( 
            IPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) PROPVARIANT rgpropvar[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *WriteMultiple )( 
            IPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPVARIANT rgpropvar[  ],
            /* [in] */ PROPID propidNameFirst);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteMultiple )( 
            IPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ReadPropertyNames )( 
            IPropertyStorage * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpropid) LPOLESTR rglpwstrName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *WritePropertyNames )( 
            IPropertyStorage * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const LPOLESTR rglpwstrName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *DeletePropertyNames )( 
            IPropertyStorage * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IPropertyStorage * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Revert )( 
            IPropertyStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *Enum )( 
            IPropertyStorage * This,
            /* [out] */ __RPC__deref_out_opt IEnumSTATPROPSTG **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimes )( 
            IPropertyStorage * This,
            /* [in] */ __RPC__in const FILETIME *pctime,
            /* [in] */ __RPC__in const FILETIME *patime,
            /* [in] */ __RPC__in const FILETIME *pmtime);
        
        HRESULT ( STDMETHODCALLTYPE *SetClass )( 
            IPropertyStorage * This,
            /* [in] */ __RPC__in REFCLSID clsid);
        
        HRESULT ( STDMETHODCALLTYPE *Stat )( 
            IPropertyStorage * This,
            /* [out] */ __RPC__out STATPROPSETSTG *pstatpsstg);
        
        END_INTERFACE
    } IPropertyStorageVtbl;

    interface IPropertyStorage
    {
        CONST_VTBL struct IPropertyStorageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyStorage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyStorage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyStorage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyStorage_ReadMultiple(This,cpspec,rgpspec,rgpropvar)	\
    ( (This)->lpVtbl -> ReadMultiple(This,cpspec,rgpspec,rgpropvar) ) 

#define IPropertyStorage_WriteMultiple(This,cpspec,rgpspec,rgpropvar,propidNameFirst)	\
    ( (This)->lpVtbl -> WriteMultiple(This,cpspec,rgpspec,rgpropvar,propidNameFirst) ) 

#define IPropertyStorage_DeleteMultiple(This,cpspec,rgpspec)	\
    ( (This)->lpVtbl -> DeleteMultiple(This,cpspec,rgpspec) ) 

#define IPropertyStorage_ReadPropertyNames(This,cpropid,rgpropid,rglpwstrName)	\
    ( (This)->lpVtbl -> ReadPropertyNames(This,cpropid,rgpropid,rglpwstrName) ) 

#define IPropertyStorage_WritePropertyNames(This,cpropid,rgpropid,rglpwstrName)	\
    ( (This)->lpVtbl -> WritePropertyNames(This,cpropid,rgpropid,rglpwstrName) ) 

#define IPropertyStorage_DeletePropertyNames(This,cpropid,rgpropid)	\
    ( (This)->lpVtbl -> DeletePropertyNames(This,cpropid,rgpropid) ) 

#define IPropertyStorage_Commit(This,grfCommitFlags)	\
    ( (This)->lpVtbl -> Commit(This,grfCommitFlags) ) 

#define IPropertyStorage_Revert(This)	\
    ( (This)->lpVtbl -> Revert(This) ) 

#define IPropertyStorage_Enum(This,ppenum)	\
    ( (This)->lpVtbl -> Enum(This,ppenum) ) 

#define IPropertyStorage_SetTimes(This,pctime,patime,pmtime)	\
    ( (This)->lpVtbl -> SetTimes(This,pctime,patime,pmtime) ) 

#define IPropertyStorage_SetClass(This,clsid)	\
    ( (This)->lpVtbl -> SetClass(This,clsid) ) 

#define IPropertyStorage_Stat(This,pstatpsstg)	\
    ( (This)->lpVtbl -> Stat(This,pstatpsstg) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyStorage_INTERFACE_DEFINED__ */


#ifndef __IPropertySetStorage_INTERFACE_DEFINED__
#define __IPropertySetStorage_INTERFACE_DEFINED__

/* interface IPropertySetStorage */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IPropertySetStorage *LPPROPERTYSETSTORAGE;


EXTERN_C const IID IID_IPropertySetStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0000013A-0000-0000-C000-000000000046")
    IPropertySetStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ __RPC__in REFFMTID rfmtid,
            /* [unique][in] */ __RPC__in_opt const CLSID *pclsid,
            /* [in] */ DWORD grfFlags,
            /* [in] */ DWORD grfMode,
            /* [out] */ __RPC__deref_out_opt IPropertyStorage **ppprstg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ __RPC__in REFFMTID rfmtid,
            /* [in] */ DWORD grfMode,
            /* [out] */ __RPC__deref_out_opt IPropertyStorage **ppprstg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ __RPC__in REFFMTID rfmtid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enum( 
            /* [out] */ __RPC__deref_out_opt IEnumSTATPROPSETSTG **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertySetStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertySetStorage * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertySetStorage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertySetStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            IPropertySetStorage * This,
            /* [in] */ __RPC__in REFFMTID rfmtid,
            /* [unique][in] */ __RPC__in_opt const CLSID *pclsid,
            /* [in] */ DWORD grfFlags,
            /* [in] */ DWORD grfMode,
            /* [out] */ __RPC__deref_out_opt IPropertyStorage **ppprstg);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            IPropertySetStorage * This,
            /* [in] */ __RPC__in REFFMTID rfmtid,
            /* [in] */ DWORD grfMode,
            /* [out] */ __RPC__deref_out_opt IPropertyStorage **ppprstg);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IPropertySetStorage * This,
            /* [in] */ __RPC__in REFFMTID rfmtid);
        
        HRESULT ( STDMETHODCALLTYPE *Enum )( 
            IPropertySetStorage * This,
            /* [out] */ __RPC__deref_out_opt IEnumSTATPROPSETSTG **ppenum);
        
        END_INTERFACE
    } IPropertySetStorageVtbl;

    interface IPropertySetStorage
    {
        CONST_VTBL struct IPropertySetStorageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySetStorage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertySetStorage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertySetStorage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertySetStorage_Create(This,rfmtid,pclsid,grfFlags,grfMode,ppprstg)	\
    ( (This)->lpVtbl -> Create(This,rfmtid,pclsid,grfFlags,grfMode,ppprstg) ) 

#define IPropertySetStorage_Open(This,rfmtid,grfMode,ppprstg)	\
    ( (This)->lpVtbl -> Open(This,rfmtid,grfMode,ppprstg) ) 

#define IPropertySetStorage_Delete(This,rfmtid)	\
    ( (This)->lpVtbl -> Delete(This,rfmtid) ) 

#define IPropertySetStorage_Enum(This,ppenum)	\
    ( (This)->lpVtbl -> Enum(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertySetStorage_INTERFACE_DEFINED__ */


#ifndef __IEnumSTATPROPSTG_INTERFACE_DEFINED__
#define __IEnumSTATPROPSTG_INTERFACE_DEFINED__

/* interface IEnumSTATPROPSTG */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IEnumSTATPROPSTG *LPENUMSTATPROPSTG;


EXTERN_C const IID IID_IEnumSTATPROPSTG;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000139-0000-0000-C000-000000000046")
    IEnumSTATPROPSTG : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ STATPROPSTG *rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumSTATPROPSTG **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSTATPROPSTGVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumSTATPROPSTG * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumSTATPROPSTG * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumSTATPROPSTG * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumSTATPROPSTG * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ STATPROPSTG *rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumSTATPROPSTG * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumSTATPROPSTG * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumSTATPROPSTG * This,
            /* [out] */ __RPC__deref_out_opt IEnumSTATPROPSTG **ppenum);
        
        END_INTERFACE
    } IEnumSTATPROPSTGVtbl;

    interface IEnumSTATPROPSTG
    {
        CONST_VTBL struct IEnumSTATPROPSTGVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSTATPROPSTG_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumSTATPROPSTG_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumSTATPROPSTG_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumSTATPROPSTG_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumSTATPROPSTG_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumSTATPROPSTG_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumSTATPROPSTG_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSTG_RemoteNext_Proxy( 
    IEnumSTATPROPSTG * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) STATPROPSTG *rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);


void __RPC_STUB IEnumSTATPROPSTG_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumSTATPROPSTG_INTERFACE_DEFINED__ */


#ifndef __IEnumSTATPROPSETSTG_INTERFACE_DEFINED__
#define __IEnumSTATPROPSETSTG_INTERFACE_DEFINED__

/* interface IEnumSTATPROPSETSTG */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IEnumSTATPROPSETSTG *LPENUMSTATPROPSETSTG;


EXTERN_C const IID IID_IEnumSTATPROPSETSTG;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0000013B-0000-0000-C000-000000000046")
    IEnumSTATPROPSETSTG : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ STATPROPSETSTG *rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumSTATPROPSETSTG **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSTATPROPSETSTGVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumSTATPROPSETSTG * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumSTATPROPSETSTG * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumSTATPROPSETSTG * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumSTATPROPSETSTG * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ STATPROPSETSTG *rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumSTATPROPSETSTG * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumSTATPROPSETSTG * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumSTATPROPSETSTG * This,
            /* [out] */ __RPC__deref_out_opt IEnumSTATPROPSETSTG **ppenum);
        
        END_INTERFACE
    } IEnumSTATPROPSETSTGVtbl;

    interface IEnumSTATPROPSETSTG
    {
        CONST_VTBL struct IEnumSTATPROPSETSTGVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSTATPROPSETSTG_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumSTATPROPSETSTG_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumSTATPROPSETSTG_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumSTATPROPSETSTG_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumSTATPROPSETSTG_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumSTATPROPSETSTG_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumSTATPROPSETSTG_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSETSTG_RemoteNext_Proxy( 
    IEnumSTATPROPSETSTG * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) STATPROPSETSTG *rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);


void __RPC_STUB IEnumSTATPROPSETSTG_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumSTATPROPSETSTG_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_propidl_0000_0004 */
/* [local] */ 

typedef /* [unique] */  __RPC_unique_pointer IPropertyStorage *LPPROPERTYSTORAGE;

WINOLEAPI PropVariantCopy ( PROPVARIANT * pvarDest, const PROPVARIANT * pvarSrc );
WINOLEAPI PropVariantClear ( PROPVARIANT * pvar );
WINOLEAPI FreePropVariantArray ( ULONG cVariants, PROPVARIANT * rgvars );

#define _PROPVARIANTINIT_DEFINED_
#   ifdef __cplusplus
inline void PropVariantInit ( PROPVARIANT * pvar )
{
    memset ( pvar, 0, sizeof(PROPVARIANT) );
}
#   else
#   define PropVariantInit(pvar) memset ( (pvar), 0, sizeof(PROPVARIANT) )
#   endif


#ifndef _STGCREATEPROPSTG_DEFINED_
WINOLEAPI StgCreatePropStg( IUnknown* pUnk, REFFMTID fmtid, const CLSID *pclsid, DWORD grfFlags, DWORD dwReserved, IPropertyStorage **ppPropStg );
WINOLEAPI StgOpenPropStg( IUnknown* pUnk, REFFMTID fmtid, DWORD grfFlags, DWORD dwReserved, IPropertyStorage **ppPropStg );
WINOLEAPI StgCreatePropSetStg( IStorage *pStorage, DWORD dwReserved, IPropertySetStorage **ppPropSetStg);

#define CCH_MAX_PROPSTG_NAME    31
__checkReturn WINOLEAPI FmtIdToPropStgName( const FMTID *pfmtid, __out_ecount(CCH_MAX_PROPSTG_NAME+1) LPOLESTR oszName );
WINOLEAPI PropStgNameToFmtId( __in __nullterminated const LPOLESTR oszName, FMTID *pfmtid );
#endif
#ifndef _SERIALIZEDPROPERTYVALUE_DEFINED_
#define _SERIALIZEDPROPERTYVALUE_DEFINED_
typedef struct tagSERIALIZEDPROPERTYVALUE		// prop
{
    DWORD	dwType;
    BYTE	rgb[1];
} SERIALIZEDPROPERTYVALUE;
#endif

EXTERN_C SERIALIZEDPROPERTYVALUE* __stdcall
StgConvertVariantToProperty(
            __in const PROPVARIANT* pvar,
            USHORT CodePage,
            __out_bcount_opt(*pcb) SERIALIZEDPROPERTYVALUE* pprop,
            __inout ULONG* pcb,
            PROPID pid,
            __reserved BOOLEAN fReserved,
            __out_opt ULONG* pcIndirect);

#ifdef __cplusplus
class PMemoryAllocator;

EXTERN_C BOOLEAN __stdcall
StgConvertPropertyToVariant(
            __in const SERIALIZEDPROPERTYVALUE* pprop,
            USHORT CodePage,
            __out PROPVARIANT* pvar,
            __in PMemoryAllocator* pma);
#endif
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)    /* Nameless struct/union */
#pragma warning(default:4237)    /* keywords bool, true, false, etc.. */
#endif


extern RPC_IF_HANDLE __MIDL_itf_propidl_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propidl_0000_0004_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     unsigned long *, LPSAFEARRAY * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSTG_Next_Proxy( 
    IEnumSTATPROPSTG * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATPROPSTG *rgelt,
    /* [out] */ ULONG *pceltFetched);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSTG_Next_Stub( 
    IEnumSTATPROPSTG * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) STATPROPSTG *rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSETSTG_Next_Proxy( 
    IEnumSTATPROPSETSTG * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATPROPSETSTG *rgelt,
    /* [out] */ ULONG *pceltFetched);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSETSTG_Next_Stub( 
    IEnumSTATPROPSETSTG * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) STATPROPSETSTG *rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\PostMake.Inc ===
#----------------------------------------------------------------------------
#
# Descriptions:
#   Generic Make File Postfix for EDK Environment
#
# Copyright:
#   Copyright (C) Microsoft Corp. 1993-1999.  All Rights Reserved.
#
#----------------------------------------------------------------------------

!ifndef PRIVATE_CLEAN
clean:
!else
generic_clean:
!endif
    del $(DIRBLD)\*.obj \
        $(DIRBLD)\*.err \
        $(DIRBLD)\*.lib \
        $(DIRBLD)\*.exe \
        $(DIRBLD)\*.dll \
        $(DIRBLD)\*.map \
        $(DIRBLD)\*.res \
        $(DIRBLD)\*.pch \
        $(DIRBLD)\*.exp

cleanall: clean
    del $(DIRPCH)\*.obj \
        $(DIRPCH)\*.pch

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Disable precompiled headers if NOPCH is defined.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

!ifdef NOPCH
!include "nopch.inc"
!endif

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Pre-compiled header default #1 used in most .C EDK sources.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

$(DIRPCH)\edk.obj: $(DIRPCHSRC)\edk.c
!if "$(OUTERR)"=="YES"
    @echo $(CC) $(CL) $(PCHCR1) $(CFLAGS) $(DIRPCHSRC)\edk.c $(OSYM) $(ERRFILE)
!endif
    $(CC) $(CL) $(PCHCR1) $(CFLAGS) $(DIRPCHSRC)\edk.c $(OSYM) $(ERRFILE)

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Pre-compiled header default #2 used in most .CPP EDK sources.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

$(DIRPCH)\edkx.obj: $(DIRPCHSRC)\edkx.cpp
!if "$(OUTERR)"=="YES"
    @echo $(CC) $(CL) $(PCHCR2) $(CFLAGS) $(DIRPCHSRC)\edkx.cpp $(OSYM) $(ERRFILE)
!endif
    $(CC) $(CL) $(PCHCR2) $(CFLAGS) $(DIRPCHSRC)\edkx.cpp $(OSYM) $(ERRFILE)

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Pre-compiled header default #3 used for .CPP and MFC applications.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

$(DIRPCH)\edkafx.obj: $(DIRPCHSRC)\edkafx.cpp
!if "$(OUTERR)"=="YES"
    @echo $(CC) $(CL) $(PCHCR3) $(CPPFLAGS) $(DIRPCHSRC)\edkafx.cpp $(OSYM) $(ERRFILE)
!endif
    $(CC) $(CL) $(PCHCR3) $(CPPFLAGS) $(DIRPCHSRC)\edkafx.cpp $(OSYM) $(ERRFILE)

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Pre-compiled header default #4 used in UNICODE .C EDK sources.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

$(DIRPCH)\edku.obj: $(DIRPCHSRC)\edku.c
!if "$(OUTERR)"=="YES"
    @echo $(CC) $(CL) $(PCHCR4) $(CFLAGS) $(DIRPCHSRC)\edku.c $(OSYM) $(ERRFILE)
!endif
    $(CC) $(CL) $(PCHCR4) $(CFLAGS) $(DIRPCHSRC)\edku.c $(OSYM) $(ERRFILE)

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\propkeydef.h ===
#ifndef PID_FIRST_USABLE
#define PID_FIRST_USABLE 2
#endif

#ifndef REFPROPERTYKEY
#ifdef __cplusplus
#define REFPROPERTYKEY const PROPERTYKEY &
#else // !__cplusplus
#define REFPROPERTYKEY const PROPERTYKEY * __MIDL_CONST
#endif // __cplusplus
#endif //REFPROPERTYKEY

#ifdef DEFINE_PROPERTYKEY
#undef DEFINE_PROPERTYKEY
#endif

#ifdef INITGUID
#define DEFINE_PROPERTYKEY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8, pid) EXTERN_C const PROPERTYKEY DECLSPEC_SELECTANY name = { { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }, pid }
#else
#define DEFINE_PROPERTYKEY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8, pid) EXTERN_C const PROPERTYKEY name
#endif // INITGUID

#ifndef IsEqualPropertyKey
#define IsEqualPropertyKey(a, b)   (((a).pid == (b).pid) && IsEqualIID((a).fmtid, (b).fmtid) )
#endif  // IsEqualPropertyKey
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\Provider.h ===
//***************************************************************************
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  Provider.h
//
//  Purpose: declaration of Provider class
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _PROVIDER_H__
#define _PROVIDER_H__

/////////////////////////////////////////////////////
// INSTANCE Provider
//
// pure virtual base class for providers
// holds instances
// gathers information and instantiates instances
/////////////////////////////////////////////////////
class POLARITY Provider : public CThreadBase
{
    // CWbemProviderGlue needs to access some protected/private methods
    // which we don't want to publish to just anyone.

    friend class CWbemProviderGlue;

public:
    Provider( LPCWSTR a_pszName, LPCWSTR a_pszNameSpace = NULL );
    ~Provider();
    static BOOL initFailed();


protected:
    /* Override These Methods To Implement Your Provider */

    // This is the entrypoint for changes.
    // You are handed a changed instance.
    // If you can make the changes - do so.
    // If you cannot return an appropriate error code (WBEM_E_XXXXXXX)
    // base object returns WBEM_E_PROVIDER_NOT_CAPABLE
    virtual HRESULT PutInstance(const CInstance& newInstance, long lFlags = 0L);

    // entrypoint to delete an instance
    // examine the instance passed in, determine whether you can delete it
    virtual HRESULT DeleteInstance(const CInstance& newInstance, long lFlags = 0L);

    // execute a method
    virtual HRESULT ExecMethod(const CInstance& cInstance, 
        __in const BSTR bstrMethodName, 
        __in CInstance *pInParams, 
        __out CInstance *pOutParams, 
        long lFlags = 0L);

    // find and create all instances of your class
    virtual HRESULT EnumerateInstances(__in MethodContext *pMethodContext, long lFlags = 0L);

    // you will be given an object with the key properties filled in
    // you need to fill in all of the rest of the properties, or
    // return WBEM_E_NOT_FOUND if the object doesn't exist.
    virtual HRESULT GetObject(__inout CInstance *pInstance, long lFlags = 0L);

    // You will be given an object with the key properties filled in.
    // You can either fill in all the properties, or check the Query object
    // to see what properties are required.  If you don't implement this method, the
    // GetObject(CInstance, long) method will be called instead.
    virtual HRESULT GetObject(__inout CInstance *pInstance, long lFlags, __in CFrameworkQuery &Query);

    // If a provider wants to process queries, they should override this
    virtual HRESULT ExecQuery(__in MethodContext *pMethodContext, 
        __in CFrameworkQuery& cQuery, 
        long lFlags = 0L);

    // flushes cache
    // only override if you allocate memory that could be flushed
    virtual void Flush(void);

    /* Helpers - Use These, Do Not Override */

    // allocate a new instance & return pointer to it
    // the memory is your responsibility to Release()
    // UNLESS you pass it off to Provider::Commit
    CInstance *CreateNewInstance(__in MethodContext *pMethodContext);

    // used to send your new instance back to the framework
    // set bCache to true to cache object 
    // !! caching is NOT IMPLEMENTED in this release !!
    // do not delete or release the pointer once committed.
    HRESULT Commit(__inout CInstance *pInstance, bool bCache = false);

    // Helper function for building a WBEM Object Path for a local Instance
    bool GetLocalInstancePath( const CInstance *pInstance, __out CHString& strPath );

    //   Builds a full instance path from a relative path
    CHString MakeLocalPath( const CHString &strRelPath );

    // Returns the computer name as a CHString.  Save yourself the os call,
    // since we've got it hanging around anyway.
    const CHString &GetLocalComputerName() {return s_strComputerName;}
    const CHString &GetNamespace() {return m_strNameSpace;}

    // sets the CreationClassName property to the name of this provider
    bool SetCreationClassName(__inout CInstance *pInstance);

    // accesses the name of the provider
    const CHString &GetProviderName() {return m_name;}

    // Flag validation constants
    enum FlagDefs
    {
        EnumerationFlags = (WBEM_FLAG_DIRECT_READ | WBEM_FLAG_SEND_STATUS),
        GetObjFlags = (WBEM_FLAG_SEND_STATUS | WBEM_FLAG_DIRECT_READ),
        MethodFlags = WBEM_FLAG_SEND_STATUS,
        DeletionFlags = WBEM_FLAG_SEND_STATUS,
        PutInstanceFlags = (WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_SEND_STATUS),
        QueryFlags = WBEM_FLAG_SEND_STATUS | WBEM_FLAG_DIRECT_READ
    };

    // returns WBEM_E_UNSUPPORTED_PARAMETER or WBEM_S_NO_ERROR
    HRESULT ValidateFlags(long lFlags, FlagDefs lAcceptableFlags);

    // you can override the following to support flags 
    // above and beyond those listed in FlagDefs above
    virtual HRESULT ValidateEnumerationFlags(long lFlags);
    virtual HRESULT ValidateGetObjFlags(long lFlags);
    virtual HRESULT ValidateMethodFlags(long lFlags);
    virtual HRESULT ValidateQueryFlags(long lFlags);
    virtual HRESULT ValidateDeletionFlags(long lFlags);
    virtual HRESULT ValidatePutInstanceFlags(long lFlags);

private:
    static BOOL initFailed_;

    IWbemServices       *m_pIMosProvider;    // provides instances
    CHString            m_name;             // name of this provider
    CHString            m_strNameSpace;     // name of this provider's namespace
    IWbemClassObject    *m_piClassObject;    // holds class object from which others are cloned.

    static CHString     s_strComputerName;  // Holds the computer name for building
    // instance paths.

    BOOL ValidateIMOSPointer( void );       // This function ensures that our IMOS
    // pointer is available, and is called
    // by the framework entrypoint functions

    /* Interfaces For Use by the Framework         */
    HRESULT GetObject(  __in ParsedObjectPath *pParsedObjectPath, 
        __in MethodContext *pContext, long lFlags = 0L );

    HRESULT ExecuteQuery( __in MethodContext *pContext, 
        __in CFrameworkQuery &pQuery, 
        long lFlags = 0L);

    HRESULT CreateInstanceEnum( __in MethodContext *pContext, long lFlags = 0L );

    HRESULT PutInstance( __in IWbemClassObject __RPC_FAR *pInst,
        long lFlags,
        __in MethodContext *pContext );

    HRESULT DeleteInstance( __in ParsedObjectPath *pParsedObjectPath,
        long lFlags,
        __in MethodContext *pContext );

    HRESULT ExecMethod( __in ParsedObjectPath *pParsedObjectPath,
        __in BSTR bstrMethodName,
        long lFlags,
        __in CInstance *pInParams,
        __out CInstance *pOutParams,
        __in MethodContext *pContext );

    // Static helper function called by constructor to make sure the
    // computer name variable is properly initialized.
    static void WINAPI InitComputerName( void );

    // Sets an instance key from a parsed object path.
    BOOL SetKeyFromParsedObjectPath( __inout CInstance *pInstance, 
        __in ParsedObjectPath *pParsedObjectPath );

    IWbemClassObject *GetClassObjectInterface(__in MethodContext *pMethodContext);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\ProvExce.h ===
//***************************************************************************
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  ProvExce.h
//
//  Purpose: Exception handling classes
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _PROVIDER_EXCEPT_H
#define _PROVIDER_EXCEPT_H

#ifdef _M_CEE_PURE
#define PROVIDER_EXCEPT_API_INLINE __clrcall
#define PROVIDER_EXCEPT_SE_TRANSLATOR_FUNC_TYPE __se_translator_function_m
#else
#define PROVIDER_EXCEPT_API_INLINE __cdecl
#define PROVIDER_EXCEPT_SE_TRANSLATOR_FUNC_TYPE _se_translator_function
#endif

/**************************************************************
 *
 **************************************************************/

#include <eh.h>

/**************************************************************
 *
 **************************************************************/

class CHeap_Exception
{
public:

	enum HEAP_ERROR
	{
		E_ALLOCATION_ERROR = 0 ,
		E_FREE_ERROR
	};

private:

	HEAP_ERROR m_Error;

public:

	CHeap_Exception ( HEAP_ERROR e ) : m_Error ( e ) {}
	~CHeap_Exception () {}

	HEAP_ERROR GetError() { return m_Error ; }
} ;

/**************************************************************
 *
 **************************************************************/

class CStructured_Exception
{
private:

    UINT m_nSE ;
	EXCEPTION_POINTERS *m_pExp ;

public:

    CStructured_Exception () {}
    CStructured_Exception ( UINT n , EXCEPTION_POINTERS *pExp ) : m_nSE ( n ) , m_pExp ( pExp ) {}
    ~CStructured_Exception () {}
    UINT GetSENumber () { return m_nSE ; }
	EXCEPTION_POINTERS *GetExtendedInfo() { return m_pExp ; }
} ;

/**************************************************************
 *
 **************************************************************/

#ifndef _M_CEE_PURE

class CSetStructuredExceptionHandler
{
private:

    PROVIDER_EXCEPT_SE_TRANSLATOR_FUNC_TYPE m_PrevFunc ;

public:

    static void PROVIDER_EXCEPT_API_INLINE trans_func ( UINT u , EXCEPTION_POINTERS *pExp )
	{
		throw CStructured_Exception ( u , pExp ) ;
	}

	CSetStructuredExceptionHandler () : m_PrevFunc ( NULL )
	{
		// Foreign exception translator is no longer used
	}

	~CSetStructuredExceptionHandler ()
	{
	}
} ;

#endif // ndef _M_CEE_PURE

/**************************************************************
 *
 **************************************************************/


#endif //_PROVIDER_EXCEPT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\propsys.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for propsys.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __propsys_h__
#define __propsys_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IInitializeWithFile_FWD_DEFINED__
#define __IInitializeWithFile_FWD_DEFINED__
typedef interface IInitializeWithFile IInitializeWithFile;
#endif 	/* __IInitializeWithFile_FWD_DEFINED__ */


#ifndef __IInitializeWithStream_FWD_DEFINED__
#define __IInitializeWithStream_FWD_DEFINED__
typedef interface IInitializeWithStream IInitializeWithStream;
#endif 	/* __IInitializeWithStream_FWD_DEFINED__ */


#ifndef __IPropertyStore_FWD_DEFINED__
#define __IPropertyStore_FWD_DEFINED__
typedef interface IPropertyStore IPropertyStore;
#endif 	/* __IPropertyStore_FWD_DEFINED__ */


#ifndef __INamedPropertyStore_FWD_DEFINED__
#define __INamedPropertyStore_FWD_DEFINED__
typedef interface INamedPropertyStore INamedPropertyStore;
#endif 	/* __INamedPropertyStore_FWD_DEFINED__ */


#ifndef __IObjectWithPropertyKey_FWD_DEFINED__
#define __IObjectWithPropertyKey_FWD_DEFINED__
typedef interface IObjectWithPropertyKey IObjectWithPropertyKey;
#endif 	/* __IObjectWithPropertyKey_FWD_DEFINED__ */


#ifndef __IPropertyChange_FWD_DEFINED__
#define __IPropertyChange_FWD_DEFINED__
typedef interface IPropertyChange IPropertyChange;
#endif 	/* __IPropertyChange_FWD_DEFINED__ */


#ifndef __IPropertyChangeArray_FWD_DEFINED__
#define __IPropertyChangeArray_FWD_DEFINED__
typedef interface IPropertyChangeArray IPropertyChangeArray;
#endif 	/* __IPropertyChangeArray_FWD_DEFINED__ */


#ifndef __IPropertyStoreCapabilities_FWD_DEFINED__
#define __IPropertyStoreCapabilities_FWD_DEFINED__
typedef interface IPropertyStoreCapabilities IPropertyStoreCapabilities;
#endif 	/* __IPropertyStoreCapabilities_FWD_DEFINED__ */


#ifndef __IPropertyStoreCache_FWD_DEFINED__
#define __IPropertyStoreCache_FWD_DEFINED__
typedef interface IPropertyStoreCache IPropertyStoreCache;
#endif 	/* __IPropertyStoreCache_FWD_DEFINED__ */


#ifndef __IPropertyEnumType_FWD_DEFINED__
#define __IPropertyEnumType_FWD_DEFINED__
typedef interface IPropertyEnumType IPropertyEnumType;
#endif 	/* __IPropertyEnumType_FWD_DEFINED__ */


#ifndef __IPropertyEnumTypeList_FWD_DEFINED__
#define __IPropertyEnumTypeList_FWD_DEFINED__
typedef interface IPropertyEnumTypeList IPropertyEnumTypeList;
#endif 	/* __IPropertyEnumTypeList_FWD_DEFINED__ */


#ifndef __IPropertyDescription_FWD_DEFINED__
#define __IPropertyDescription_FWD_DEFINED__
typedef interface IPropertyDescription IPropertyDescription;
#endif 	/* __IPropertyDescription_FWD_DEFINED__ */


#ifndef __IPropertyDescriptionAliasInfo_FWD_DEFINED__
#define __IPropertyDescriptionAliasInfo_FWD_DEFINED__
typedef interface IPropertyDescriptionAliasInfo IPropertyDescriptionAliasInfo;
#endif 	/* __IPropertyDescriptionAliasInfo_FWD_DEFINED__ */


#ifndef __IPropertyDescriptionSearchInfo_FWD_DEFINED__
#define __IPropertyDescriptionSearchInfo_FWD_DEFINED__
typedef interface IPropertyDescriptionSearchInfo IPropertyDescriptionSearchInfo;
#endif 	/* __IPropertyDescriptionSearchInfo_FWD_DEFINED__ */


#ifndef __IPropertySystem_FWD_DEFINED__
#define __IPropertySystem_FWD_DEFINED__
typedef interface IPropertySystem IPropertySystem;
#endif 	/* __IPropertySystem_FWD_DEFINED__ */


#ifndef __IPropertyDescriptionList_FWD_DEFINED__
#define __IPropertyDescriptionList_FWD_DEFINED__
typedef interface IPropertyDescriptionList IPropertyDescriptionList;
#endif 	/* __IPropertyDescriptionList_FWD_DEFINED__ */


#ifndef __IPropertyStoreFactory_FWD_DEFINED__
#define __IPropertyStoreFactory_FWD_DEFINED__
typedef interface IPropertyStoreFactory IPropertyStoreFactory;
#endif 	/* __IPropertyStoreFactory_FWD_DEFINED__ */


#ifndef __IDelayedPropertyStoreFactory_FWD_DEFINED__
#define __IDelayedPropertyStoreFactory_FWD_DEFINED__
typedef interface IDelayedPropertyStoreFactory IDelayedPropertyStoreFactory;
#endif 	/* __IDelayedPropertyStoreFactory_FWD_DEFINED__ */


#ifndef __IPersistSerializedPropStorage_FWD_DEFINED__
#define __IPersistSerializedPropStorage_FWD_DEFINED__
typedef interface IPersistSerializedPropStorage IPersistSerializedPropStorage;
#endif 	/* __IPersistSerializedPropStorage_FWD_DEFINED__ */


#ifndef __IPropertySystemChangeNotify_FWD_DEFINED__
#define __IPropertySystemChangeNotify_FWD_DEFINED__
typedef interface IPropertySystemChangeNotify IPropertySystemChangeNotify;
#endif 	/* __IPropertySystemChangeNotify_FWD_DEFINED__ */


#ifndef __ICreateObject_FWD_DEFINED__
#define __ICreateObject_FWD_DEFINED__
typedef interface ICreateObject ICreateObject;
#endif 	/* __ICreateObject_FWD_DEFINED__ */


#ifndef __InMemoryPropertyStore_FWD_DEFINED__
#define __InMemoryPropertyStore_FWD_DEFINED__

#ifdef __cplusplus
typedef class InMemoryPropertyStore InMemoryPropertyStore;
#else
typedef struct InMemoryPropertyStore InMemoryPropertyStore;
#endif /* __cplusplus */

#endif 	/* __InMemoryPropertyStore_FWD_DEFINED__ */


#ifndef __PropertySystem_FWD_DEFINED__
#define __PropertySystem_FWD_DEFINED__

#ifdef __cplusplus
typedef class PropertySystem PropertySystem;
#else
typedef struct PropertySystem PropertySystem;
#endif /* __cplusplus */

#endif 	/* __PropertySystem_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "ocidl.h"
#include "shtypes.h"
#include "structuredquery.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_propsys_0000_0000 */
/* [local] */ 

#ifndef PSSTDAPI
#if defined(_PROPSYS_)
#define PSSTDAPI          STDAPI
#define PSSTDAPI_(type)   STDAPI_(type)
#else
#define PSSTDAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define PSSTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif
#endif // PSSTDAPI
#if 0
typedef PROPERTYKEY *REFPROPERTYKEY;

#endif // 0
#include <propkeydef.h>


extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0000_v0_0_s_ifspec;

#ifndef __IInitializeWithFile_INTERFACE_DEFINED__
#define __IInitializeWithFile_INTERFACE_DEFINED__

/* interface IInitializeWithFile */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IInitializeWithFile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b7d14566-0509-4cce-a71f-0a554233bd9b")
    IInitializeWithFile : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ __RPC__in LPCWSTR pszFilePath,
            /* [in] */ DWORD grfMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInitializeWithFileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInitializeWithFile * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInitializeWithFile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInitializeWithFile * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IInitializeWithFile * This,
            /* [string][in] */ __RPC__in LPCWSTR pszFilePath,
            /* [in] */ DWORD grfMode);
        
        END_INTERFACE
    } IInitializeWithFileVtbl;

    interface IInitializeWithFile
    {
        CONST_VTBL struct IInitializeWithFileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInitializeWithFile_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInitializeWithFile_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInitializeWithFile_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInitializeWithFile_Initialize(This,pszFilePath,grfMode)	\
    ( (This)->lpVtbl -> Initialize(This,pszFilePath,grfMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInitializeWithFile_INTERFACE_DEFINED__ */


#ifndef __IInitializeWithStream_INTERFACE_DEFINED__
#define __IInitializeWithStream_INTERFACE_DEFINED__

/* interface IInitializeWithStream */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IInitializeWithStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b824b49d-22ac-4161-ac8a-9916e8fa3f7f")
    IInitializeWithStream : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IStream *pstream,
            /* [in] */ DWORD grfMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInitializeWithStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInitializeWithStream * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInitializeWithStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInitializeWithStream * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IInitializeWithStream * This,
            /* [in] */ IStream *pstream,
            /* [in] */ DWORD grfMode);
        
        END_INTERFACE
    } IInitializeWithStreamVtbl;

    interface IInitializeWithStream
    {
        CONST_VTBL struct IInitializeWithStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInitializeWithStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInitializeWithStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInitializeWithStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInitializeWithStream_Initialize(This,pstream,grfMode)	\
    ( (This)->lpVtbl -> Initialize(This,pstream,grfMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IInitializeWithStream_RemoteInitialize_Proxy( 
    IInitializeWithStream * This,
    /* [in] */ __RPC__in_opt IStream *pstream,
    /* [in] */ DWORD grfMode);


void __RPC_STUB IInitializeWithStream_RemoteInitialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInitializeWithStream_INTERFACE_DEFINED__ */


#ifndef __IPropertyStore_INTERFACE_DEFINED__
#define __IPropertyStore_INTERFACE_DEFINED__

/* interface IPropertyStore */
/* [unique][object][helpstring][uuid] */ 


EXTERN_C const IID IID_IPropertyStore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("886d8eeb-8cf2-4446-8d02-cdba1dbdcf99")
    IPropertyStore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out DWORD *cProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ DWORD iProp,
            /* [out] */ __RPC__out PROPERTYKEY *pkey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *pv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPVARIANT propvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyStoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyStore * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyStore * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyStore * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IPropertyStore * This,
            /* [out] */ __RPC__out DWORD *cProps);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            IPropertyStore * This,
            /* [in] */ DWORD iProp,
            /* [out] */ __RPC__out PROPERTYKEY *pkey);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IPropertyStore * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *pv);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            IPropertyStore * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPVARIANT propvar);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IPropertyStore * This);
        
        END_INTERFACE
    } IPropertyStoreVtbl;

    interface IPropertyStore
    {
        CONST_VTBL struct IPropertyStoreVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyStore_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyStore_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyStore_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyStore_GetCount(This,cProps)	\
    ( (This)->lpVtbl -> GetCount(This,cProps) ) 

#define IPropertyStore_GetAt(This,iProp,pkey)	\
    ( (This)->lpVtbl -> GetAt(This,iProp,pkey) ) 

#define IPropertyStore_GetValue(This,key,pv)	\
    ( (This)->lpVtbl -> GetValue(This,key,pv) ) 

#define IPropertyStore_SetValue(This,key,propvar)	\
    ( (This)->lpVtbl -> SetValue(This,key,propvar) ) 

#define IPropertyStore_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyStore_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_propsys_0000_0003 */
/* [local] */ 

typedef /* [unique] */  __RPC_unique_pointer IPropertyStore *LPPROPERTYSTORE;



extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0003_v0_0_s_ifspec;

#ifndef __INamedPropertyStore_INTERFACE_DEFINED__
#define __INamedPropertyStore_INTERFACE_DEFINED__

/* interface INamedPropertyStore */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_INamedPropertyStore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("71604b0f-97b0-4764-8577-2f13e98a1422")
    INamedPropertyStore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNamedValue( 
            /* [string][in] */ __RPC__in LPCWSTR pszName,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNamedValue( 
            /* [string][in] */ __RPC__in LPCWSTR pszName,
            /* [in] */ __RPC__in REFPROPVARIANT propvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNameCount( 
            /* [out] */ __RPC__out DWORD *pdwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNameAt( 
            /* [in] */ DWORD iProp,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INamedPropertyStoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INamedPropertyStore * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INamedPropertyStore * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INamedPropertyStore * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNamedValue )( 
            INamedPropertyStore * This,
            /* [string][in] */ __RPC__in LPCWSTR pszName,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar);
        
        HRESULT ( STDMETHODCALLTYPE *SetNamedValue )( 
            INamedPropertyStore * This,
            /* [string][in] */ __RPC__in LPCWSTR pszName,
            /* [in] */ __RPC__in REFPROPVARIANT propvar);
        
        HRESULT ( STDMETHODCALLTYPE *GetNameCount )( 
            INamedPropertyStore * This,
            /* [out] */ __RPC__out DWORD *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetNameAt )( 
            INamedPropertyStore * This,
            /* [in] */ DWORD iProp,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        END_INTERFACE
    } INamedPropertyStoreVtbl;

    interface INamedPropertyStore
    {
        CONST_VTBL struct INamedPropertyStoreVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INamedPropertyStore_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INamedPropertyStore_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INamedPropertyStore_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INamedPropertyStore_GetNamedValue(This,pszName,ppropvar)	\
    ( (This)->lpVtbl -> GetNamedValue(This,pszName,ppropvar) ) 

#define INamedPropertyStore_SetNamedValue(This,pszName,propvar)	\
    ( (This)->lpVtbl -> SetNamedValue(This,pszName,propvar) ) 

#define INamedPropertyStore_GetNameCount(This,pdwCount)	\
    ( (This)->lpVtbl -> GetNameCount(This,pdwCount) ) 

#define INamedPropertyStore_GetNameAt(This,iProp,pbstrName)	\
    ( (This)->lpVtbl -> GetNameAt(This,iProp,pbstrName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INamedPropertyStore_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_propsys_0000_0004 */
/* [local] */ 

/* [v1_enum] */ 
enum tagGETPROPERTYSTOREFLAGS
    {	GPS_DEFAULT	= 0,
	GPS_HANDLERPROPERTIESONLY	= 0x1,
	GPS_READWRITE	= 0x2,
	GPS_TEMPORARY	= 0x4,
	GPS_FASTPROPERTIESONLY	= 0x8,
	GPS_OPENSLOWITEM	= 0x10,
	GPS_DELAYCREATION	= 0x20,
	GPS_BESTEFFORT	= 0x40,
	GPS_MASK_VALID	= 0x7f
    } ;
typedef int GETPROPERTYSTOREFLAGS;



extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0004_v0_0_s_ifspec;

#ifndef __IObjectWithPropertyKey_INTERFACE_DEFINED__
#define __IObjectWithPropertyKey_INTERFACE_DEFINED__

/* interface IObjectWithPropertyKey */
/* [uuid][object] */ 


EXTERN_C const IID IID_IObjectWithPropertyKey;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fc0ca0a7-c316-4fd2-9031-3e628e6d4f23")
    IObjectWithPropertyKey : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPropertyKey( 
            /* [in] */ __RPC__in REFPROPERTYKEY key) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyKey( 
            /* [out] */ __RPC__out PROPERTYKEY *pkey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectWithPropertyKeyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjectWithPropertyKey * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjectWithPropertyKey * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjectWithPropertyKey * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPropertyKey )( 
            IObjectWithPropertyKey * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
            IObjectWithPropertyKey * This,
            /* [out] */ __RPC__out PROPERTYKEY *pkey);
        
        END_INTERFACE
    } IObjectWithPropertyKeyVtbl;

    interface IObjectWithPropertyKey
    {
        CONST_VTBL struct IObjectWithPropertyKeyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectWithPropertyKey_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjectWithPropertyKey_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjectWithPropertyKey_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjectWithPropertyKey_SetPropertyKey(This,key)	\
    ( (This)->lpVtbl -> SetPropertyKey(This,key) ) 

#define IObjectWithPropertyKey_GetPropertyKey(This,pkey)	\
    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjectWithPropertyKey_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_propsys_0000_0005 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum tagPKA_FLAGS
    {	PKA_SET	= 0,
	PKA_APPEND	= ( PKA_SET + 1 ) ,
	PKA_DELETE	= ( PKA_APPEND + 1 ) 
    } 	PKA_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0005_v0_0_s_ifspec;

#ifndef __IPropertyChange_INTERFACE_DEFINED__
#define __IPropertyChange_INTERFACE_DEFINED__

/* interface IPropertyChange */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertyChange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f917bc8a-1bba-4478-a245-1bde03eb9431")
    IPropertyChange : public IObjectWithPropertyKey
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ApplyToPropVariant( 
            /* [in] */ __RPC__in REFPROPVARIANT propvarIn,
            /* [out] */ __RPC__out PROPVARIANT *ppropvarOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyChangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyChange * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyChange * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyChange * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPropertyKey )( 
            IPropertyChange * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
            IPropertyChange * This,
            /* [out] */ __RPC__out PROPERTYKEY *pkey);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyToPropVariant )( 
            IPropertyChange * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvarIn,
            /* [out] */ __RPC__out PROPVARIANT *ppropvarOut);
        
        END_INTERFACE
    } IPropertyChangeVtbl;

    interface IPropertyChange
    {
        CONST_VTBL struct IPropertyChangeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyChange_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyChange_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyChange_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyChange_SetPropertyKey(This,key)	\
    ( (This)->lpVtbl -> SetPropertyKey(This,key) ) 

#define IPropertyChange_GetPropertyKey(This,pkey)	\
    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 


#define IPropertyChange_ApplyToPropVariant(This,propvarIn,ppropvarOut)	\
    ( (This)->lpVtbl -> ApplyToPropVariant(This,propvarIn,ppropvarOut) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyChange_INTERFACE_DEFINED__ */


#ifndef __IPropertyChangeArray_INTERFACE_DEFINED__
#define __IPropertyChangeArray_INTERFACE_DEFINED__

/* interface IPropertyChangeArray */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertyChangeArray;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("380f5cad-1b5e-42f2-805d-637fd392d31e")
    IPropertyChangeArray : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out UINT *pcOperations) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT iIndex,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertAt( 
            /* [in] */ UINT iIndex,
            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppendOrReplace( 
            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ UINT iIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsKeyInArray( 
            /* [in] */ __RPC__in REFPROPERTYKEY key) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyChangeArrayVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyChangeArray * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyChangeArray * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyChangeArray * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IPropertyChangeArray * This,
            /* [out] */ __RPC__out UINT *pcOperations);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            IPropertyChangeArray * This,
            /* [in] */ UINT iIndex,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *InsertAt )( 
            IPropertyChangeArray * This,
            /* [in] */ UINT iIndex,
            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            IPropertyChangeArray * This,
            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange);
        
        HRESULT ( STDMETHODCALLTYPE *AppendOrReplace )( 
            IPropertyChangeArray * This,
            /* [in] */ __RPC__in_opt IPropertyChange *ppropChange);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            IPropertyChangeArray * This,
            /* [in] */ UINT iIndex);
        
        HRESULT ( STDMETHODCALLTYPE *IsKeyInArray )( 
            IPropertyChangeArray * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key);
        
        END_INTERFACE
    } IPropertyChangeArrayVtbl;

    interface IPropertyChangeArray
    {
        CONST_VTBL struct IPropertyChangeArrayVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyChangeArray_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyChangeArray_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyChangeArray_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyChangeArray_GetCount(This,pcOperations)	\
    ( (This)->lpVtbl -> GetCount(This,pcOperations) ) 

#define IPropertyChangeArray_GetAt(This,iIndex,riid,ppv)	\
    ( (This)->lpVtbl -> GetAt(This,iIndex,riid,ppv) ) 

#define IPropertyChangeArray_InsertAt(This,iIndex,ppropChange)	\
    ( (This)->lpVtbl -> InsertAt(This,iIndex,ppropChange) ) 

#define IPropertyChangeArray_Append(This,ppropChange)	\
    ( (This)->lpVtbl -> Append(This,ppropChange) ) 

#define IPropertyChangeArray_AppendOrReplace(This,ppropChange)	\
    ( (This)->lpVtbl -> AppendOrReplace(This,ppropChange) ) 

#define IPropertyChangeArray_RemoveAt(This,iIndex)	\
    ( (This)->lpVtbl -> RemoveAt(This,iIndex) ) 

#define IPropertyChangeArray_IsKeyInArray(This,key)	\
    ( (This)->lpVtbl -> IsKeyInArray(This,key) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyChangeArray_INTERFACE_DEFINED__ */


#ifndef __IPropertyStoreCapabilities_INTERFACE_DEFINED__
#define __IPropertyStoreCapabilities_INTERFACE_DEFINED__

/* interface IPropertyStoreCapabilities */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertyStoreCapabilities;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c8e2d566-186e-4d49-bf41-6909ead56acc")
    IPropertyStoreCapabilities : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsPropertyWritable( 
            /* [in] */ __RPC__in REFPROPERTYKEY key) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyStoreCapabilitiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyStoreCapabilities * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyStoreCapabilities * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyStoreCapabilities * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsPropertyWritable )( 
            IPropertyStoreCapabilities * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key);
        
        END_INTERFACE
    } IPropertyStoreCapabilitiesVtbl;

    interface IPropertyStoreCapabilities
    {
        CONST_VTBL struct IPropertyStoreCapabilitiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyStoreCapabilities_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyStoreCapabilities_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyStoreCapabilities_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyStoreCapabilities_IsPropertyWritable(This,key)	\
    ( (This)->lpVtbl -> IsPropertyWritable(This,key) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyStoreCapabilities_INTERFACE_DEFINED__ */


#ifndef __IPropertyStoreCache_INTERFACE_DEFINED__
#define __IPropertyStoreCache_INTERFACE_DEFINED__

/* interface IPropertyStoreCache */
/* [unique][object][uuid] */ 

typedef /* [v1_enum] */ 
enum _PSC_STATE
    {	PSC_NORMAL	= 0,
	PSC_NOTINSOURCE	= 1,
	PSC_DIRTY	= 2,
	PSC_READONLY	= 3
    } 	PSC_STATE;


EXTERN_C const IID IID_IPropertyStoreCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3017056d-9a91-4e90-937d-746c72abbf4f")
    IPropertyStoreCache : public IPropertyStore
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PSC_STATE *pstate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValueAndState( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar,
            /* [out] */ __RPC__out PSC_STATE *pstate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetState( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ PSC_STATE state) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValueAndState( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *ppropvar,
            /* [in] */ PSC_STATE state) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyStoreCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyStoreCache * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyStoreCache * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyStoreCache * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IPropertyStoreCache * This,
            /* [out] */ __RPC__out DWORD *cProps);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            IPropertyStoreCache * This,
            /* [in] */ DWORD iProp,
            /* [out] */ __RPC__out PROPERTYKEY *pkey);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IPropertyStoreCache * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *pv);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            IPropertyStoreCache * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPVARIANT propvar);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IPropertyStoreCache * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IPropertyStoreCache * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PSC_STATE *pstate);
        
        HRESULT ( STDMETHODCALLTYPE *GetValueAndState )( 
            IPropertyStoreCache * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar,
            /* [out] */ __RPC__out PSC_STATE *pstate);
        
        HRESULT ( STDMETHODCALLTYPE *SetState )( 
            IPropertyStoreCache * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ PSC_STATE state);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueAndState )( 
            IPropertyStoreCache * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *ppropvar,
            /* [in] */ PSC_STATE state);
        
        END_INTERFACE
    } IPropertyStoreCacheVtbl;

    interface IPropertyStoreCache
    {
        CONST_VTBL struct IPropertyStoreCacheVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyStoreCache_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyStoreCache_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyStoreCache_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyStoreCache_GetCount(This,cProps)	\
    ( (This)->lpVtbl -> GetCount(This,cProps) ) 

#define IPropertyStoreCache_GetAt(This,iProp,pkey)	\
    ( (This)->lpVtbl -> GetAt(This,iProp,pkey) ) 

#define IPropertyStoreCache_GetValue(This,key,pv)	\
    ( (This)->lpVtbl -> GetValue(This,key,pv) ) 

#define IPropertyStoreCache_SetValue(This,key,propvar)	\
    ( (This)->lpVtbl -> SetValue(This,key,propvar) ) 

#define IPropertyStoreCache_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 


#define IPropertyStoreCache_GetState(This,key,pstate)	\
    ( (This)->lpVtbl -> GetState(This,key,pstate) ) 

#define IPropertyStoreCache_GetValueAndState(This,key,ppropvar,pstate)	\
    ( (This)->lpVtbl -> GetValueAndState(This,key,ppropvar,pstate) ) 

#define IPropertyStoreCache_SetState(This,key,state)	\
    ( (This)->lpVtbl -> SetState(This,key,state) ) 

#define IPropertyStoreCache_SetValueAndState(This,key,ppropvar,state)	\
    ( (This)->lpVtbl -> SetValueAndState(This,key,ppropvar,state) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyStoreCache_INTERFACE_DEFINED__ */


#ifndef __IPropertyEnumType_INTERFACE_DEFINED__
#define __IPropertyEnumType_INTERFACE_DEFINED__

/* interface IPropertyEnumType */
/* [unique][object][uuid] */ 

/* [v1_enum] */ 
enum tagPROPENUMTYPE
    {	PET_DISCRETEVALUE	= 0,
	PET_RANGEDVALUE	= 1,
	PET_DEFAULTVALUE	= 2,
	PET_ENDRANGE	= 3
    } ;
typedef enum tagPROPENUMTYPE PROPENUMTYPE;


EXTERN_C const IID IID_IPropertyEnumType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("11e1fbf9-2d56-4a6b-8db3-7cd193a471f2")
    IPropertyEnumType : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEnumType( 
            /* [out] */ __RPC__out PROPENUMTYPE *penumtype) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ __RPC__out PROPVARIANT *ppropvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRangeMinValue( 
            /* [out] */ __RPC__out PROPVARIANT *ppropvarMin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRangeSetValue( 
            /* [out] */ __RPC__out PROPVARIANT *ppropvarSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayText( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszDisplay) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyEnumTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyEnumType * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyEnumType * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyEnumType * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumType )( 
            IPropertyEnumType * This,
            /* [out] */ __RPC__out PROPENUMTYPE *penumtype);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IPropertyEnumType * This,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar);
        
        HRESULT ( STDMETHODCALLTYPE *GetRangeMinValue )( 
            IPropertyEnumType * This,
            /* [out] */ __RPC__out PROPVARIANT *ppropvarMin);
        
        HRESULT ( STDMETHODCALLTYPE *GetRangeSetValue )( 
            IPropertyEnumType * This,
            /* [out] */ __RPC__out PROPVARIANT *ppropvarSet);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayText )( 
            IPropertyEnumType * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszDisplay);
        
        END_INTERFACE
    } IPropertyEnumTypeVtbl;

    interface IPropertyEnumType
    {
        CONST_VTBL struct IPropertyEnumTypeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyEnumType_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyEnumType_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyEnumType_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyEnumType_GetEnumType(This,penumtype)	\
    ( (This)->lpVtbl -> GetEnumType(This,penumtype) ) 

#define IPropertyEnumType_GetValue(This,ppropvar)	\
    ( (This)->lpVtbl -> GetValue(This,ppropvar) ) 

#define IPropertyEnumType_GetRangeMinValue(This,ppropvarMin)	\
    ( (This)->lpVtbl -> GetRangeMinValue(This,ppropvarMin) ) 

#define IPropertyEnumType_GetRangeSetValue(This,ppropvarSet)	\
    ( (This)->lpVtbl -> GetRangeSetValue(This,ppropvarSet) ) 

#define IPropertyEnumType_GetDisplayText(This,ppszDisplay)	\
    ( (This)->lpVtbl -> GetDisplayText(This,ppszDisplay) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyEnumType_INTERFACE_DEFINED__ */


#ifndef __IPropertyEnumTypeList_INTERFACE_DEFINED__
#define __IPropertyEnumTypeList_INTERFACE_DEFINED__

/* interface IPropertyEnumTypeList */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertyEnumTypeList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a99400f4-3d84-4557-94ba-1242fb2cc9a6")
    IPropertyEnumTypeList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out UINT *pctypes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT itype,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConditionAt( 
            /* [in] */ UINT nIndex,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindMatchingIndex( 
            /* [in] */ __RPC__in REFPROPVARIANT propvarCmp,
            /* [out] */ __RPC__out UINT *pnIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyEnumTypeListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyEnumTypeList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyEnumTypeList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyEnumTypeList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IPropertyEnumTypeList * This,
            /* [out] */ __RPC__out UINT *pctypes);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            IPropertyEnumTypeList * This,
            /* [in] */ UINT itype,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetConditionAt )( 
            IPropertyEnumTypeList * This,
            /* [in] */ UINT nIndex,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *FindMatchingIndex )( 
            IPropertyEnumTypeList * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvarCmp,
            /* [out] */ __RPC__out UINT *pnIndex);
        
        END_INTERFACE
    } IPropertyEnumTypeListVtbl;

    interface IPropertyEnumTypeList
    {
        CONST_VTBL struct IPropertyEnumTypeListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyEnumTypeList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyEnumTypeList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyEnumTypeList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyEnumTypeList_GetCount(This,pctypes)	\
    ( (This)->lpVtbl -> GetCount(This,pctypes) ) 

#define IPropertyEnumTypeList_GetAt(This,itype,riid,ppv)	\
    ( (This)->lpVtbl -> GetAt(This,itype,riid,ppv) ) 

#define IPropertyEnumTypeList_GetConditionAt(This,nIndex,riid,ppv)	\
    ( (This)->lpVtbl -> GetConditionAt(This,nIndex,riid,ppv) ) 

#define IPropertyEnumTypeList_FindMatchingIndex(This,propvarCmp,pnIndex)	\
    ( (This)->lpVtbl -> FindMatchingIndex(This,propvarCmp,pnIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyEnumTypeList_INTERFACE_DEFINED__ */


#ifndef __IPropertyDescription_INTERFACE_DEFINED__
#define __IPropertyDescription_INTERFACE_DEFINED__

/* interface IPropertyDescription */
/* [unique][object][uuid] */ 

/* [v1_enum] */ 
enum tagPROPDESC_TYPE_FLAGS
    {	PDTF_DEFAULT	= 0,
	PDTF_MULTIPLEVALUES	= 0x1,
	PDTF_ISINNATE	= 0x2,
	PDTF_ISGROUP	= 0x4,
	PDTF_CANGROUPBY	= 0x8,
	PDTF_CANSTACKBY	= 0x10,
	PDTF_ISTREEPROPERTY	= 0x20,
	PDTF_INCLUDEINFULLTEXTQUERY	= 0x40,
	PDTF_ISVIEWABLE	= 0x80,
	PDTF_ISQUERYABLE	= 0x100,
	PDTF_ISSYSTEMPROPERTY	= 0x80000000,
	PDTF_MASK_ALL	= 0x800001ff
    } ;
typedef int PROPDESC_TYPE_FLAGS;

/* [v1_enum] */ 
enum tagPROPDESC_VIEW_FLAGS
    {	PDVF_DEFAULT	= 0,
	PDVF_CENTERALIGN	= 0x1,
	PDVF_RIGHTALIGN	= 0x2,
	PDVF_BEGINNEWGROUP	= 0x4,
	PDVF_FILLAREA	= 0x8,
	PDVF_SORTDESCENDING	= 0x10,
	PDVF_SHOWONLYIFPRESENT	= 0x20,
	PDVF_SHOWBYDEFAULT	= 0x40,
	PDVF_SHOWINPRIMARYLIST	= 0x80,
	PDVF_SHOWINSECONDARYLIST	= 0x100,
	PDVF_HIDELABEL	= 0x200,
	PDVF_HIDDEN	= 0x800,
	PDVF_CANWRAP	= 0x1000,
	PDVF_MASK_ALL	= 0x1bff
    } ;
typedef int PROPDESC_VIEW_FLAGS;

/* [v1_enum] */ 
enum tagPROPDESC_DISPLAYTYPE
    {	PDDT_STRING	= 0,
	PDDT_NUMBER	= 1,
	PDDT_BOOLEAN	= 2,
	PDDT_DATETIME	= 3,
	PDDT_ENUMERATED	= 4
    } ;
typedef enum tagPROPDESC_DISPLAYTYPE PROPDESC_DISPLAYTYPE;

/* [v1_enum] */ 
enum tagPROPDESC_GROUPING_RANGE
    {	PDGR_DISCRETE	= 0,
	PDGR_ALPHANUMERIC	= 1,
	PDGR_SIZE	= 2,
	PDGR_DYNAMIC	= 3,
	PDGR_DATE	= 4,
	PDGR_PERCENT	= 5,
	PDGR_ENUMERATED	= 6
    } ;
typedef enum tagPROPDESC_GROUPING_RANGE PROPDESC_GROUPING_RANGE;

/* [v1_enum] */ 
enum tagPROPDESC_FORMAT_FLAGS
    {	PDFF_DEFAULT	= 0,
	PDFF_PREFIXNAME	= 0x1,
	PDFF_FILENAME	= 0x2,
	PDFF_ALWAYSKB	= 0x4,
	PDFF_RESERVED_RIGHTTOLEFT	= 0x8,
	PDFF_SHORTTIME	= 0x10,
	PDFF_LONGTIME	= 0x20,
	PDFF_HIDETIME	= 0x40,
	PDFF_SHORTDATE	= 0x80,
	PDFF_LONGDATE	= 0x100,
	PDFF_HIDEDATE	= 0x200,
	PDFF_RELATIVEDATE	= 0x400,
	PDFF_USEEDITINVITATION	= 0x800,
	PDFF_READONLY	= 0x1000,
	PDFF_NOAUTOREADINGORDER	= 0x2000
    } ;
typedef int PROPDESC_FORMAT_FLAGS;

/* [v1_enum] */ 
enum tagPROPDESC_SORTDESCRIPTION
    {	PDSD_GENERAL	= 0,
	PDSD_A_Z	= 1,
	PDSD_LOWEST_HIGHEST	= 2,
	PDSD_SMALLEST_BIGGEST	= 3,
	PDSD_OLDEST_NEWEST	= 4
    } ;
typedef enum tagPROPDESC_SORTDESCRIPTION PROPDESC_SORTDESCRIPTION;

/* [v1_enum] */ 
enum tagPROPDESC_RELATIVEDESCRIPTION_TYPE
    {	PDRDT_GENERAL	= 0,
	PDRDT_DATE	= 1,
	PDRDT_SIZE	= 2,
	PDRDT_COUNT	= 3,
	PDRDT_REVISION	= 4,
	PDRDT_LENGTH	= 5,
	PDRDT_DURATION	= 6,
	PDRDT_SPEED	= 7,
	PDRDT_RATE	= 8,
	PDRDT_RATING	= 9,
	PDRDT_PRIORITY	= 10
    } ;
typedef enum tagPROPDESC_RELATIVEDESCRIPTION_TYPE PROPDESC_RELATIVEDESCRIPTION_TYPE;

/* [v1_enum] */ 
enum tagPROPDESC_AGGREGATION_TYPE
    {	PDAT_DEFAULT	= 0,
	PDAT_FIRST	= 1,
	PDAT_SUM	= 2,
	PDAT_AVERAGE	= 3,
	PDAT_DATERANGE	= 4,
	PDAT_UNION	= 5,
	PDAT_MAX	= 6,
	PDAT_MIN	= 7
    } ;
typedef enum tagPROPDESC_AGGREGATION_TYPE PROPDESC_AGGREGATION_TYPE;

/* [v1_enum] */ 
enum tagPROPDESC_CONDITION_TYPE
    {	PDCOT_NONE	= 0,
	PDCOT_STRING	= 1,
	PDCOT_SIZE	= 2,
	PDCOT_DATETIME	= 3,
	PDCOT_BOOLEAN	= 4,
	PDCOT_NUMBER	= 5
    } ;
typedef enum tagPROPDESC_CONDITION_TYPE PROPDESC_CONDITION_TYPE;


EXTERN_C const IID IID_IPropertyDescription;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6f79d558-3e96-4549-a1d1-7d75d2288814")
    IPropertyDescription : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyKey( 
            /* [out] */ __RPC__out PROPERTYKEY *pkey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCanonicalName( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyType( 
            /* [out] */ __RPC__out VARTYPE *pvartype) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEditInvitation( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInvite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeFlags( 
            /* [in] */ PROPDESC_TYPE_FLAGS mask,
            /* [out] */ __RPC__out PROPDESC_TYPE_FLAGS *ppdtFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetViewFlags( 
            /* [out] */ __RPC__out PROPDESC_VIEW_FLAGS *ppdvFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultColumnWidth( 
            /* [out] */ __RPC__out UINT *pcxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayType( 
            /* [out] */ __RPC__out PROPDESC_DISPLAYTYPE *pdisplaytype) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumnState( 
            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupingRange( 
            /* [out] */ __RPC__out PROPDESC_GROUPING_RANGE *pgr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRelativeDescriptionType( 
            /* [out] */ __RPC__out PROPDESC_RELATIVEDESCRIPTION_TYPE *prdt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRelativeDescription( 
            /* [in] */ __RPC__in REFPROPVARIANT propvar1,
            /* [in] */ __RPC__in REFPROPVARIANT propvar2,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc1,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSortDescription( 
            /* [out] */ __RPC__out PROPDESC_SORTDESCRIPTION *psd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSortDescriptionLabel( 
            /* [in] */ BOOL fDescending,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAggregationType( 
            /* [out] */ __RPC__out PROPDESC_AGGREGATION_TYPE *paggtype) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConditionType( 
            /* [out] */ __RPC__out PROPDESC_CONDITION_TYPE *pcontype,
            /* [out] */ __RPC__out CONDITION_OPERATION *popDefault) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnumTypeList( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CoerceToCanonicalValue( 
            /* [out][in] */ PROPVARIANT *ppropvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FormatForDisplay( 
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdfFlags,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsValueCanonical( 
            /* [in] */ __RPC__in REFPROPVARIANT propvar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyDescriptionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyDescription * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyDescription * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyDescription * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
            IPropertyDescription * This,
            /* [out] */ __RPC__out PROPERTYKEY *pkey);
        
        HRESULT ( STDMETHODCALLTYPE *GetCanonicalName )( 
            IPropertyDescription * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyType )( 
            IPropertyDescription * This,
            /* [out] */ __RPC__out VARTYPE *pvartype);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            IPropertyDescription * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetEditInvitation )( 
            IPropertyDescription * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInvite);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeFlags )( 
            IPropertyDescription * This,
            /* [in] */ PROPDESC_TYPE_FLAGS mask,
            /* [out] */ __RPC__out PROPDESC_TYPE_FLAGS *ppdtFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewFlags )( 
            IPropertyDescription * This,
            /* [out] */ __RPC__out PROPDESC_VIEW_FLAGS *ppdvFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultColumnWidth )( 
            IPropertyDescription * This,
            /* [out] */ __RPC__out UINT *pcxChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayType )( 
            IPropertyDescription * This,
            /* [out] */ __RPC__out PROPDESC_DISPLAYTYPE *pdisplaytype);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnState )( 
            IPropertyDescription * This,
            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupingRange )( 
            IPropertyDescription * This,
            /* [out] */ __RPC__out PROPDESC_GROUPING_RANGE *pgr);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescriptionType )( 
            IPropertyDescription * This,
            /* [out] */ __RPC__out PROPDESC_RELATIVEDESCRIPTION_TYPE *prdt);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescription )( 
            IPropertyDescription * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar1,
            /* [in] */ __RPC__in REFPROPVARIANT propvar2,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc1,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc2);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDescription )( 
            IPropertyDescription * This,
            /* [out] */ __RPC__out PROPDESC_SORTDESCRIPTION *psd);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDescriptionLabel )( 
            IPropertyDescription * This,
            /* [in] */ BOOL fDescending,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetAggregationType )( 
            IPropertyDescription * This,
            /* [out] */ __RPC__out PROPDESC_AGGREGATION_TYPE *paggtype);
        
        HRESULT ( STDMETHODCALLTYPE *GetConditionType )( 
            IPropertyDescription * This,
            /* [out] */ __RPC__out PROPDESC_CONDITION_TYPE *pcontype,
            /* [out] */ __RPC__out CONDITION_OPERATION *popDefault);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumTypeList )( 
            IPropertyDescription * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CoerceToCanonicalValue )( 
            IPropertyDescription * This,
            /* [out][in] */ PROPVARIANT *ppropvar);
        
        HRESULT ( STDMETHODCALLTYPE *FormatForDisplay )( 
            IPropertyDescription * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdfFlags,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay);
        
        HRESULT ( STDMETHODCALLTYPE *IsValueCanonical )( 
            IPropertyDescription * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar);
        
        END_INTERFACE
    } IPropertyDescriptionVtbl;

    interface IPropertyDescription
    {
        CONST_VTBL struct IPropertyDescriptionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyDescription_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyDescription_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyDescription_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyDescription_GetPropertyKey(This,pkey)	\
    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 

#define IPropertyDescription_GetCanonicalName(This,ppszName)	\
    ( (This)->lpVtbl -> GetCanonicalName(This,ppszName) ) 

#define IPropertyDescription_GetPropertyType(This,pvartype)	\
    ( (This)->lpVtbl -> GetPropertyType(This,pvartype) ) 

#define IPropertyDescription_GetDisplayName(This,ppszName)	\
    ( (This)->lpVtbl -> GetDisplayName(This,ppszName) ) 

#define IPropertyDescription_GetEditInvitation(This,ppszInvite)	\
    ( (This)->lpVtbl -> GetEditInvitation(This,ppszInvite) ) 

#define IPropertyDescription_GetTypeFlags(This,mask,ppdtFlags)	\
    ( (This)->lpVtbl -> GetTypeFlags(This,mask,ppdtFlags) ) 

#define IPropertyDescription_GetViewFlags(This,ppdvFlags)	\
    ( (This)->lpVtbl -> GetViewFlags(This,ppdvFlags) ) 

#define IPropertyDescription_GetDefaultColumnWidth(This,pcxChars)	\
    ( (This)->lpVtbl -> GetDefaultColumnWidth(This,pcxChars) ) 

#define IPropertyDescription_GetDisplayType(This,pdisplaytype)	\
    ( (This)->lpVtbl -> GetDisplayType(This,pdisplaytype) ) 

#define IPropertyDescription_GetColumnState(This,pcsFlags)	\
    ( (This)->lpVtbl -> GetColumnState(This,pcsFlags) ) 

#define IPropertyDescription_GetGroupingRange(This,pgr)	\
    ( (This)->lpVtbl -> GetGroupingRange(This,pgr) ) 

#define IPropertyDescription_GetRelativeDescriptionType(This,prdt)	\
    ( (This)->lpVtbl -> GetRelativeDescriptionType(This,prdt) ) 

#define IPropertyDescription_GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2)	\
    ( (This)->lpVtbl -> GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2) ) 

#define IPropertyDescription_GetSortDescription(This,psd)	\
    ( (This)->lpVtbl -> GetSortDescription(This,psd) ) 

#define IPropertyDescription_GetSortDescriptionLabel(This,fDescending,ppszDescription)	\
    ( (This)->lpVtbl -> GetSortDescriptionLabel(This,fDescending,ppszDescription) ) 

#define IPropertyDescription_GetAggregationType(This,paggtype)	\
    ( (This)->lpVtbl -> GetAggregationType(This,paggtype) ) 

#define IPropertyDescription_GetConditionType(This,pcontype,popDefault)	\
    ( (This)->lpVtbl -> GetConditionType(This,pcontype,popDefault) ) 

#define IPropertyDescription_GetEnumTypeList(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetEnumTypeList(This,riid,ppv) ) 

#define IPropertyDescription_CoerceToCanonicalValue(This,ppropvar)	\
    ( (This)->lpVtbl -> CoerceToCanonicalValue(This,ppropvar) ) 

#define IPropertyDescription_FormatForDisplay(This,propvar,pdfFlags,ppszDisplay)	\
    ( (This)->lpVtbl -> FormatForDisplay(This,propvar,pdfFlags,ppszDisplay) ) 

#define IPropertyDescription_IsValueCanonical(This,propvar)	\
    ( (This)->lpVtbl -> IsValueCanonical(This,propvar) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IPropertyDescription_RemoteCoerceToCanonicalValue_Proxy( 
    IPropertyDescription * This,
    /* [in] */ __RPC__in REFPROPVARIANT propvar,
    /* [out] */ __RPC__out PROPVARIANT *ppropvar);


void __RPC_STUB IPropertyDescription_RemoteCoerceToCanonicalValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertyDescription_INTERFACE_DEFINED__ */


#ifndef __IPropertyDescriptionAliasInfo_INTERFACE_DEFINED__
#define __IPropertyDescriptionAliasInfo_INTERFACE_DEFINED__

/* interface IPropertyDescriptionAliasInfo */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertyDescriptionAliasInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f67104fc-2af9-46fd-b32d-243c1404f3d1")
    IPropertyDescriptionAliasInfo : public IPropertyDescription
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSortByAlias( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAdditionalSortByAliases( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyDescriptionAliasInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyDescriptionAliasInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyDescriptionAliasInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyDescriptionAliasInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
            IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out PROPERTYKEY *pkey);
        
        HRESULT ( STDMETHODCALLTYPE *GetCanonicalName )( 
            IPropertyDescriptionAliasInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyType )( 
            IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out VARTYPE *pvartype);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            IPropertyDescriptionAliasInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetEditInvitation )( 
            IPropertyDescriptionAliasInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInvite);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeFlags )( 
            IPropertyDescriptionAliasInfo * This,
            /* [in] */ PROPDESC_TYPE_FLAGS mask,
            /* [out] */ __RPC__out PROPDESC_TYPE_FLAGS *ppdtFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewFlags )( 
            IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out PROPDESC_VIEW_FLAGS *ppdvFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultColumnWidth )( 
            IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out UINT *pcxChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayType )( 
            IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out PROPDESC_DISPLAYTYPE *pdisplaytype);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnState )( 
            IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupingRange )( 
            IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out PROPDESC_GROUPING_RANGE *pgr);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescriptionType )( 
            IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out PROPDESC_RELATIVEDESCRIPTION_TYPE *prdt);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescription )( 
            IPropertyDescriptionAliasInfo * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar1,
            /* [in] */ __RPC__in REFPROPVARIANT propvar2,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc1,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc2);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDescription )( 
            IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out PROPDESC_SORTDESCRIPTION *psd);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDescriptionLabel )( 
            IPropertyDescriptionAliasInfo * This,
            /* [in] */ BOOL fDescending,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetAggregationType )( 
            IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out PROPDESC_AGGREGATION_TYPE *paggtype);
        
        HRESULT ( STDMETHODCALLTYPE *GetConditionType )( 
            IPropertyDescriptionAliasInfo * This,
            /* [out] */ __RPC__out PROPDESC_CONDITION_TYPE *pcontype,
            /* [out] */ __RPC__out CONDITION_OPERATION *popDefault);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumTypeList )( 
            IPropertyDescriptionAliasInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CoerceToCanonicalValue )( 
            IPropertyDescriptionAliasInfo * This,
            /* [out][in] */ PROPVARIANT *ppropvar);
        
        HRESULT ( STDMETHODCALLTYPE *FormatForDisplay )( 
            IPropertyDescriptionAliasInfo * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdfFlags,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay);
        
        HRESULT ( STDMETHODCALLTYPE *IsValueCanonical )( 
            IPropertyDescriptionAliasInfo * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortByAlias )( 
            IPropertyDescriptionAliasInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetAdditionalSortByAliases )( 
            IPropertyDescriptionAliasInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IPropertyDescriptionAliasInfoVtbl;

    interface IPropertyDescriptionAliasInfo
    {
        CONST_VTBL struct IPropertyDescriptionAliasInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyDescriptionAliasInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyDescriptionAliasInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyDescriptionAliasInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyDescriptionAliasInfo_GetPropertyKey(This,pkey)	\
    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 

#define IPropertyDescriptionAliasInfo_GetCanonicalName(This,ppszName)	\
    ( (This)->lpVtbl -> GetCanonicalName(This,ppszName) ) 

#define IPropertyDescriptionAliasInfo_GetPropertyType(This,pvartype)	\
    ( (This)->lpVtbl -> GetPropertyType(This,pvartype) ) 

#define IPropertyDescriptionAliasInfo_GetDisplayName(This,ppszName)	\
    ( (This)->lpVtbl -> GetDisplayName(This,ppszName) ) 

#define IPropertyDescriptionAliasInfo_GetEditInvitation(This,ppszInvite)	\
    ( (This)->lpVtbl -> GetEditInvitation(This,ppszInvite) ) 

#define IPropertyDescriptionAliasInfo_GetTypeFlags(This,mask,ppdtFlags)	\
    ( (This)->lpVtbl -> GetTypeFlags(This,mask,ppdtFlags) ) 

#define IPropertyDescriptionAliasInfo_GetViewFlags(This,ppdvFlags)	\
    ( (This)->lpVtbl -> GetViewFlags(This,ppdvFlags) ) 

#define IPropertyDescriptionAliasInfo_GetDefaultColumnWidth(This,pcxChars)	\
    ( (This)->lpVtbl -> GetDefaultColumnWidth(This,pcxChars) ) 

#define IPropertyDescriptionAliasInfo_GetDisplayType(This,pdisplaytype)	\
    ( (This)->lpVtbl -> GetDisplayType(This,pdisplaytype) ) 

#define IPropertyDescriptionAliasInfo_GetColumnState(This,pcsFlags)	\
    ( (This)->lpVtbl -> GetColumnState(This,pcsFlags) ) 

#define IPropertyDescriptionAliasInfo_GetGroupingRange(This,pgr)	\
    ( (This)->lpVtbl -> GetGroupingRange(This,pgr) ) 

#define IPropertyDescriptionAliasInfo_GetRelativeDescriptionType(This,prdt)	\
    ( (This)->lpVtbl -> GetRelativeDescriptionType(This,prdt) ) 

#define IPropertyDescriptionAliasInfo_GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2)	\
    ( (This)->lpVtbl -> GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2) ) 

#define IPropertyDescriptionAliasInfo_GetSortDescription(This,psd)	\
    ( (This)->lpVtbl -> GetSortDescription(This,psd) ) 

#define IPropertyDescriptionAliasInfo_GetSortDescriptionLabel(This,fDescending,ppszDescription)	\
    ( (This)->lpVtbl -> GetSortDescriptionLabel(This,fDescending,ppszDescription) ) 

#define IPropertyDescriptionAliasInfo_GetAggregationType(This,paggtype)	\
    ( (This)->lpVtbl -> GetAggregationType(This,paggtype) ) 

#define IPropertyDescriptionAliasInfo_GetConditionType(This,pcontype,popDefault)	\
    ( (This)->lpVtbl -> GetConditionType(This,pcontype,popDefault) ) 

#define IPropertyDescriptionAliasInfo_GetEnumTypeList(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetEnumTypeList(This,riid,ppv) ) 

#define IPropertyDescriptionAliasInfo_CoerceToCanonicalValue(This,ppropvar)	\
    ( (This)->lpVtbl -> CoerceToCanonicalValue(This,ppropvar) ) 

#define IPropertyDescriptionAliasInfo_FormatForDisplay(This,propvar,pdfFlags,ppszDisplay)	\
    ( (This)->lpVtbl -> FormatForDisplay(This,propvar,pdfFlags,ppszDisplay) ) 

#define IPropertyDescriptionAliasInfo_IsValueCanonical(This,propvar)	\
    ( (This)->lpVtbl -> IsValueCanonical(This,propvar) ) 


#define IPropertyDescriptionAliasInfo_GetSortByAlias(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetSortByAlias(This,riid,ppv) ) 

#define IPropertyDescriptionAliasInfo_GetAdditionalSortByAliases(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetAdditionalSortByAliases(This,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyDescriptionAliasInfo_INTERFACE_DEFINED__ */


#ifndef __IPropertyDescriptionSearchInfo_INTERFACE_DEFINED__
#define __IPropertyDescriptionSearchInfo_INTERFACE_DEFINED__

/* interface IPropertyDescriptionSearchInfo */
/* [unique][object][uuid] */ 

/* [v1_enum] */ 
enum tagPROPDESC_SEARCHINFO_FLAGS
    {	PDSIF_DEFAULT	= 0,
	PDSIF_ININVERTEDINDEX	= 0x1,
	PDSIF_ISCOLUMN	= 0x2,
	PDSIF_ISCOLUMNSPARSE	= 0x4
    } ;
typedef int PROPDESC_SEARCHINFO_FLAGS;

typedef /* [v1_enum] */ 
enum tagPROPDESC_COLUMNINDEX_TYPE
    {	PDCIT_NONE	= 0,
	PDCIT_ONDISK	= 1,
	PDCIT_INMEMORY	= 2
    } 	PROPDESC_COLUMNINDEX_TYPE;


EXTERN_C const IID IID_IPropertyDescriptionSearchInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("078f91bd-29a2-440f-924e-46a291524520")
    IPropertyDescriptionSearchInfo : public IPropertyDescription
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSearchInfoFlags( 
            /* [out] */ __RPC__out PROPDESC_SEARCHINFO_FLAGS *ppdsiFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumnIndexType( 
            /* [out] */ __RPC__out PROPDESC_COLUMNINDEX_TYPE *ppdciType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProjectionString( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszProjection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxSize( 
            /* [out] */ __RPC__out UINT *pcbMaxSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyDescriptionSearchInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyDescriptionSearchInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyDescriptionSearchInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyDescriptionSearchInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyKey )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPERTYKEY *pkey);
        
        HRESULT ( STDMETHODCALLTYPE *GetCanonicalName )( 
            IPropertyDescriptionSearchInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyType )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out VARTYPE *pvartype);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            IPropertyDescriptionSearchInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetEditInvitation )( 
            IPropertyDescriptionSearchInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszInvite);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeFlags )( 
            IPropertyDescriptionSearchInfo * This,
            /* [in] */ PROPDESC_TYPE_FLAGS mask,
            /* [out] */ __RPC__out PROPDESC_TYPE_FLAGS *ppdtFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewFlags )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_VIEW_FLAGS *ppdvFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultColumnWidth )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out UINT *pcxChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayType )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_DISPLAYTYPE *pdisplaytype);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnState )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out SHCOLSTATEF *pcsFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupingRange )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_GROUPING_RANGE *pgr);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescriptionType )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_RELATIVEDESCRIPTION_TYPE *prdt);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelativeDescription )( 
            IPropertyDescriptionSearchInfo * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar1,
            /* [in] */ __RPC__in REFPROPVARIANT propvar2,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc1,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDesc2);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDescription )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_SORTDESCRIPTION *psd);
        
        HRESULT ( STDMETHODCALLTYPE *GetSortDescriptionLabel )( 
            IPropertyDescriptionSearchInfo * This,
            /* [in] */ BOOL fDescending,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetAggregationType )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_AGGREGATION_TYPE *paggtype);
        
        HRESULT ( STDMETHODCALLTYPE *GetConditionType )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_CONDITION_TYPE *pcontype,
            /* [out] */ __RPC__out CONDITION_OPERATION *popDefault);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumTypeList )( 
            IPropertyDescriptionSearchInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CoerceToCanonicalValue )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out][in] */ PROPVARIANT *ppropvar);
        
        HRESULT ( STDMETHODCALLTYPE *FormatForDisplay )( 
            IPropertyDescriptionSearchInfo * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdfFlags,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay);
        
        HRESULT ( STDMETHODCALLTYPE *IsValueCanonical )( 
            IPropertyDescriptionSearchInfo * This,
            /* [in] */ __RPC__in REFPROPVARIANT propvar);
        
        HRESULT ( STDMETHODCALLTYPE *GetSearchInfoFlags )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_SEARCHINFO_FLAGS *ppdsiFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnIndexType )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out PROPDESC_COLUMNINDEX_TYPE *ppdciType);
        
        HRESULT ( STDMETHODCALLTYPE *GetProjectionString )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszProjection);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxSize )( 
            IPropertyDescriptionSearchInfo * This,
            /* [out] */ __RPC__out UINT *pcbMaxSize);
        
        END_INTERFACE
    } IPropertyDescriptionSearchInfoVtbl;

    interface IPropertyDescriptionSearchInfo
    {
        CONST_VTBL struct IPropertyDescriptionSearchInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyDescriptionSearchInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyDescriptionSearchInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyDescriptionSearchInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyDescriptionSearchInfo_GetPropertyKey(This,pkey)	\
    ( (This)->lpVtbl -> GetPropertyKey(This,pkey) ) 

#define IPropertyDescriptionSearchInfo_GetCanonicalName(This,ppszName)	\
    ( (This)->lpVtbl -> GetCanonicalName(This,ppszName) ) 

#define IPropertyDescriptionSearchInfo_GetPropertyType(This,pvartype)	\
    ( (This)->lpVtbl -> GetPropertyType(This,pvartype) ) 

#define IPropertyDescriptionSearchInfo_GetDisplayName(This,ppszName)	\
    ( (This)->lpVtbl -> GetDisplayName(This,ppszName) ) 

#define IPropertyDescriptionSearchInfo_GetEditInvitation(This,ppszInvite)	\
    ( (This)->lpVtbl -> GetEditInvitation(This,ppszInvite) ) 

#define IPropertyDescriptionSearchInfo_GetTypeFlags(This,mask,ppdtFlags)	\
    ( (This)->lpVtbl -> GetTypeFlags(This,mask,ppdtFlags) ) 

#define IPropertyDescriptionSearchInfo_GetViewFlags(This,ppdvFlags)	\
    ( (This)->lpVtbl -> GetViewFlags(This,ppdvFlags) ) 

#define IPropertyDescriptionSearchInfo_GetDefaultColumnWidth(This,pcxChars)	\
    ( (This)->lpVtbl -> GetDefaultColumnWidth(This,pcxChars) ) 

#define IPropertyDescriptionSearchInfo_GetDisplayType(This,pdisplaytype)	\
    ( (This)->lpVtbl -> GetDisplayType(This,pdisplaytype) ) 

#define IPropertyDescriptionSearchInfo_GetColumnState(This,pcsFlags)	\
    ( (This)->lpVtbl -> GetColumnState(This,pcsFlags) ) 

#define IPropertyDescriptionSearchInfo_GetGroupingRange(This,pgr)	\
    ( (This)->lpVtbl -> GetGroupingRange(This,pgr) ) 

#define IPropertyDescriptionSearchInfo_GetRelativeDescriptionType(This,prdt)	\
    ( (This)->lpVtbl -> GetRelativeDescriptionType(This,prdt) ) 

#define IPropertyDescriptionSearchInfo_GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2)	\
    ( (This)->lpVtbl -> GetRelativeDescription(This,propvar1,propvar2,ppszDesc1,ppszDesc2) ) 

#define IPropertyDescriptionSearchInfo_GetSortDescription(This,psd)	\
    ( (This)->lpVtbl -> GetSortDescription(This,psd) ) 

#define IPropertyDescriptionSearchInfo_GetSortDescriptionLabel(This,fDescending,ppszDescription)	\
    ( (This)->lpVtbl -> GetSortDescriptionLabel(This,fDescending,ppszDescription) ) 

#define IPropertyDescriptionSearchInfo_GetAggregationType(This,paggtype)	\
    ( (This)->lpVtbl -> GetAggregationType(This,paggtype) ) 

#define IPropertyDescriptionSearchInfo_GetConditionType(This,pcontype,popDefault)	\
    ( (This)->lpVtbl -> GetConditionType(This,pcontype,popDefault) ) 

#define IPropertyDescriptionSearchInfo_GetEnumTypeList(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetEnumTypeList(This,riid,ppv) ) 

#define IPropertyDescriptionSearchInfo_CoerceToCanonicalValue(This,ppropvar)	\
    ( (This)->lpVtbl -> CoerceToCanonicalValue(This,ppropvar) ) 

#define IPropertyDescriptionSearchInfo_FormatForDisplay(This,propvar,pdfFlags,ppszDisplay)	\
    ( (This)->lpVtbl -> FormatForDisplay(This,propvar,pdfFlags,ppszDisplay) ) 

#define IPropertyDescriptionSearchInfo_IsValueCanonical(This,propvar)	\
    ( (This)->lpVtbl -> IsValueCanonical(This,propvar) ) 


#define IPropertyDescriptionSearchInfo_GetSearchInfoFlags(This,ppdsiFlags)	\
    ( (This)->lpVtbl -> GetSearchInfoFlags(This,ppdsiFlags) ) 

#define IPropertyDescriptionSearchInfo_GetColumnIndexType(This,ppdciType)	\
    ( (This)->lpVtbl -> GetColumnIndexType(This,ppdciType) ) 

#define IPropertyDescriptionSearchInfo_GetProjectionString(This,ppszProjection)	\
    ( (This)->lpVtbl -> GetProjectionString(This,ppszProjection) ) 

#define IPropertyDescriptionSearchInfo_GetMaxSize(This,pcbMaxSize)	\
    ( (This)->lpVtbl -> GetMaxSize(This,pcbMaxSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyDescriptionSearchInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_propsys_0000_0014 */
/* [local] */ 

/* [v1_enum] */ 
enum tagPROPDESC_ENUMFILTER
    {	PDEF_ALL	= 0,
	PDEF_SYSTEM	= 1,
	PDEF_NONSYSTEM	= 2,
	PDEF_VIEWABLE	= 3,
	PDEF_QUERYABLE	= 4,
	PDEF_INFULLTEXTQUERY	= 5,
	PDEF_COLUMN	= 6
    } ;
typedef enum tagPROPDESC_ENUMFILTER PROPDESC_ENUMFILTER;



extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0014_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0014_v0_0_s_ifspec;

#ifndef __IPropertySystem_INTERFACE_DEFINED__
#define __IPropertySystem_INTERFACE_DEFINED__

/* interface IPropertySystem */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertySystem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ca724e8a-c3e6-442b-88a4-6fb0db8035a3")
    IPropertySystem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyDescription( 
            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyDescriptionByName( 
            /* [string][in] */ __RPC__in LPCWSTR pszCanonicalName,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyDescriptionListFromString( 
            /* [string][in] */ __RPC__in LPCWSTR pszPropList,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumeratePropertyDescriptions( 
            /* [in] */ PROPDESC_ENUMFILTER filterOn,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FormatForDisplay( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdff,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchText) LPWSTR pszText,
            /* [in] */ DWORD cchText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FormatForDisplayAlloc( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdff,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterPropertySchema( 
            /* [string][in] */ __RPC__in LPCWSTR pszPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterPropertySchema( 
            /* [string][in] */ __RPC__in LPCWSTR pszPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RefreshPropertySchema( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertySystemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertySystem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertySystem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertySystem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyDescription )( 
            IPropertySystem * This,
            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyDescriptionByName )( 
            IPropertySystem * This,
            /* [string][in] */ __RPC__in LPCWSTR pszCanonicalName,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyDescriptionListFromString )( 
            IPropertySystem * This,
            /* [string][in] */ __RPC__in LPCWSTR pszPropList,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *EnumeratePropertyDescriptions )( 
            IPropertySystem * This,
            /* [in] */ PROPDESC_ENUMFILTER filterOn,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *FormatForDisplay )( 
            IPropertySystem * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdff,
            /* [size_is][string][out] */ __RPC__out_ecount_full_string(cchText) LPWSTR pszText,
            /* [in] */ DWORD cchText);
        
        HRESULT ( STDMETHODCALLTYPE *FormatForDisplayAlloc )( 
            IPropertySystem * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPVARIANT propvar,
            /* [in] */ PROPDESC_FORMAT_FLAGS pdff,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDisplay);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterPropertySchema )( 
            IPropertySystem * This,
            /* [string][in] */ __RPC__in LPCWSTR pszPath);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterPropertySchema )( 
            IPropertySystem * This,
            /* [string][in] */ __RPC__in LPCWSTR pszPath);
        
        HRESULT ( STDMETHODCALLTYPE *RefreshPropertySchema )( 
            IPropertySystem * This);
        
        END_INTERFACE
    } IPropertySystemVtbl;

    interface IPropertySystem
    {
        CONST_VTBL struct IPropertySystemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySystem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertySystem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertySystem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertySystem_GetPropertyDescription(This,propkey,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyDescription(This,propkey,riid,ppv) ) 

#define IPropertySystem_GetPropertyDescriptionByName(This,pszCanonicalName,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyDescriptionByName(This,pszCanonicalName,riid,ppv) ) 

#define IPropertySystem_GetPropertyDescriptionListFromString(This,pszPropList,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyDescriptionListFromString(This,pszPropList,riid,ppv) ) 

#define IPropertySystem_EnumeratePropertyDescriptions(This,filterOn,riid,ppv)	\
    ( (This)->lpVtbl -> EnumeratePropertyDescriptions(This,filterOn,riid,ppv) ) 

#define IPropertySystem_FormatForDisplay(This,key,propvar,pdff,pszText,cchText)	\
    ( (This)->lpVtbl -> FormatForDisplay(This,key,propvar,pdff,pszText,cchText) ) 

#define IPropertySystem_FormatForDisplayAlloc(This,key,propvar,pdff,ppszDisplay)	\
    ( (This)->lpVtbl -> FormatForDisplayAlloc(This,key,propvar,pdff,ppszDisplay) ) 

#define IPropertySystem_RegisterPropertySchema(This,pszPath)	\
    ( (This)->lpVtbl -> RegisterPropertySchema(This,pszPath) ) 

#define IPropertySystem_UnregisterPropertySchema(This,pszPath)	\
    ( (This)->lpVtbl -> UnregisterPropertySchema(This,pszPath) ) 

#define IPropertySystem_RefreshPropertySchema(This)	\
    ( (This)->lpVtbl -> RefreshPropertySchema(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertySystem_INTERFACE_DEFINED__ */


#ifndef __IPropertyDescriptionList_INTERFACE_DEFINED__
#define __IPropertyDescriptionList_INTERFACE_DEFINED__

/* interface IPropertyDescriptionList */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertyDescriptionList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1f9fc1d0-c39b-4b26-817f-011967d3440e")
    IPropertyDescriptionList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out UINT *pcElem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ UINT iElem,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyDescriptionListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyDescriptionList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyDescriptionList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyDescriptionList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IPropertyDescriptionList * This,
            /* [out] */ __RPC__out UINT *pcElem);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            IPropertyDescriptionList * This,
            /* [in] */ UINT iElem,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IPropertyDescriptionListVtbl;

    interface IPropertyDescriptionList
    {
        CONST_VTBL struct IPropertyDescriptionListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyDescriptionList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyDescriptionList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyDescriptionList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyDescriptionList_GetCount(This,pcElem)	\
    ( (This)->lpVtbl -> GetCount(This,pcElem) ) 

#define IPropertyDescriptionList_GetAt(This,iElem,riid,ppv)	\
    ( (This)->lpVtbl -> GetAt(This,iElem,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyDescriptionList_INTERFACE_DEFINED__ */


#ifndef __IPropertyStoreFactory_INTERFACE_DEFINED__
#define __IPropertyStoreFactory_INTERFACE_DEFINED__

/* interface IPropertyStoreFactory */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertyStoreFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bc110b6d-57e8-4148-a9c6-91015ab2f3a5")
    IPropertyStoreFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyStore( 
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [unique][in] */ __RPC__in_opt IUnknown *pUnkFactory,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyStoreForKeys( 
            /* [unique][in] */ __RPC__in_opt const PROPERTYKEY *rgKeys,
            /* [in] */ UINT cKeys,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyStoreFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyStoreFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyStoreFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyStoreFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStore )( 
            IPropertyStoreFactory * This,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [unique][in] */ __RPC__in_opt IUnknown *pUnkFactory,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStoreForKeys )( 
            IPropertyStoreFactory * This,
            /* [unique][in] */ __RPC__in_opt const PROPERTYKEY *rgKeys,
            /* [in] */ UINT cKeys,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IPropertyStoreFactoryVtbl;

    interface IPropertyStoreFactory
    {
        CONST_VTBL struct IPropertyStoreFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyStoreFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyStoreFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyStoreFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyStoreFactory_GetPropertyStore(This,flags,pUnkFactory,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyStore(This,flags,pUnkFactory,riid,ppv) ) 

#define IPropertyStoreFactory_GetPropertyStoreForKeys(This,rgKeys,cKeys,flags,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyStoreForKeys(This,rgKeys,cKeys,flags,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyStoreFactory_INTERFACE_DEFINED__ */


#ifndef __IDelayedPropertyStoreFactory_INTERFACE_DEFINED__
#define __IDelayedPropertyStoreFactory_INTERFACE_DEFINED__

/* interface IDelayedPropertyStoreFactory */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IDelayedPropertyStoreFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("40d4577f-e237-4bdb-bd69-58f089431b6a")
    IDelayedPropertyStoreFactory : public IPropertyStoreFactory
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDelayedPropertyStore( 
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ DWORD dwStoreId,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDelayedPropertyStoreFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDelayedPropertyStoreFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDelayedPropertyStoreFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDelayedPropertyStoreFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStore )( 
            IDelayedPropertyStoreFactory * This,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [unique][in] */ __RPC__in_opt IUnknown *pUnkFactory,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStoreForKeys )( 
            IDelayedPropertyStoreFactory * This,
            /* [unique][in] */ __RPC__in_opt const PROPERTYKEY *rgKeys,
            /* [in] */ UINT cKeys,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetDelayedPropertyStore )( 
            IDelayedPropertyStoreFactory * This,
            /* [in] */ GETPROPERTYSTOREFLAGS flags,
            /* [in] */ DWORD dwStoreId,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } IDelayedPropertyStoreFactoryVtbl;

    interface IDelayedPropertyStoreFactory
    {
        CONST_VTBL struct IDelayedPropertyStoreFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDelayedPropertyStoreFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDelayedPropertyStoreFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDelayedPropertyStoreFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDelayedPropertyStoreFactory_GetPropertyStore(This,flags,pUnkFactory,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyStore(This,flags,pUnkFactory,riid,ppv) ) 

#define IDelayedPropertyStoreFactory_GetPropertyStoreForKeys(This,rgKeys,cKeys,flags,riid,ppv)	\
    ( (This)->lpVtbl -> GetPropertyStoreForKeys(This,rgKeys,cKeys,flags,riid,ppv) ) 


#define IDelayedPropertyStoreFactory_GetDelayedPropertyStore(This,flags,dwStoreId,riid,ppv)	\
    ( (This)->lpVtbl -> GetDelayedPropertyStore(This,flags,dwStoreId,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDelayedPropertyStoreFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_propsys_0000_0018 */
/* [local] */ 

/* [v1_enum] */ 
enum tagPERSIST_SPROPSTORE_FLAGS
    {	FPSPS_READONLY	= 0x1
    } ;
typedef int PERSIST_SPROPSTORE_FLAGS;

typedef struct tagSERIALIZEDPROPSTORAGE SERIALIZEDPROPSTORAGE;

typedef SERIALIZEDPROPSTORAGE __unaligned *PUSERIALIZEDPROPSTORAGE;

typedef const SERIALIZEDPROPSTORAGE __unaligned *PCUSERIALIZEDPROPSTORAGE;



extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0018_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0018_v0_0_s_ifspec;

#ifndef __IPersistSerializedPropStorage_INTERFACE_DEFINED__
#define __IPersistSerializedPropStorage_INTERFACE_DEFINED__

/* interface IPersistSerializedPropStorage */
/* [object][local][unique][uuid] */ 


EXTERN_C const IID IID_IPersistSerializedPropStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e318ad57-0aa0-450f-aca5-6fab7103d917")
    IPersistSerializedPropStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ PERSIST_SPROPSTORE_FLAGS flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPropertyStorage( 
            /* [in] */ 
            __in_bcount(cb)  PCUSERIALIZEDPROPSTORAGE psps,
            /* [in] */ 
            __in  DWORD cb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyStorage( 
            /* [out] */ 
            __deref_out_bcount(*pcb)  SERIALIZEDPROPSTORAGE **ppsps,
            /* [out] */ 
            __out  DWORD *pcb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistSerializedPropStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPersistSerializedPropStorage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPersistSerializedPropStorage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPersistSerializedPropStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            IPersistSerializedPropStorage * This,
            /* [in] */ PERSIST_SPROPSTORE_FLAGS flags);
        
        HRESULT ( STDMETHODCALLTYPE *SetPropertyStorage )( 
            IPersistSerializedPropStorage * This,
            /* [in] */ 
            __in_bcount(cb)  PCUSERIALIZEDPROPSTORAGE psps,
            /* [in] */ 
            __in  DWORD cb);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyStorage )( 
            IPersistSerializedPropStorage * This,
            /* [out] */ 
            __deref_out_bcount(*pcb)  SERIALIZEDPROPSTORAGE **ppsps,
            /* [out] */ 
            __out  DWORD *pcb);
        
        END_INTERFACE
    } IPersistSerializedPropStorageVtbl;

    interface IPersistSerializedPropStorage
    {
        CONST_VTBL struct IPersistSerializedPropStorageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistSerializedPropStorage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPersistSerializedPropStorage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPersistSerializedPropStorage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPersistSerializedPropStorage_SetFlags(This,flags)	\
    ( (This)->lpVtbl -> SetFlags(This,flags) ) 

#define IPersistSerializedPropStorage_SetPropertyStorage(This,psps,cb)	\
    ( (This)->lpVtbl -> SetPropertyStorage(This,psps,cb) ) 

#define IPersistSerializedPropStorage_GetPropertyStorage(This,ppsps,pcb)	\
    ( (This)->lpVtbl -> GetPropertyStorage(This,ppsps,pcb) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPersistSerializedPropStorage_INTERFACE_DEFINED__ */


#ifndef __IPropertySystemChangeNotify_INTERFACE_DEFINED__
#define __IPropertySystemChangeNotify_INTERFACE_DEFINED__

/* interface IPropertySystemChangeNotify */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IPropertySystemChangeNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fa955fd9-38be-4879-a6ce-824cf52d609f")
    IPropertySystemChangeNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SchemaRefreshed( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertySystemChangeNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertySystemChangeNotify * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertySystemChangeNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertySystemChangeNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *SchemaRefreshed )( 
            IPropertySystemChangeNotify * This);
        
        END_INTERFACE
    } IPropertySystemChangeNotifyVtbl;

    interface IPropertySystemChangeNotify
    {
        CONST_VTBL struct IPropertySystemChangeNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySystemChangeNotify_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertySystemChangeNotify_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertySystemChangeNotify_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertySystemChangeNotify_SchemaRefreshed(This)	\
    ( (This)->lpVtbl -> SchemaRefreshed(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertySystemChangeNotify_INTERFACE_DEFINED__ */


#ifndef __ICreateObject_INTERFACE_DEFINED__
#define __ICreateObject_INTERFACE_DEFINED__

/* interface ICreateObject */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_ICreateObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("75121952-e0d0-43e5-9380-1d80483acf72")
    ICreateObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateObject( 
            /* [in] */ __RPC__in REFCLSID clsid,
            /* [unique][in] */ __RPC__in_opt IUnknown *pUnkOuter,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreateObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICreateObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICreateObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICreateObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateObject )( 
            ICreateObject * This,
            /* [in] */ __RPC__in REFCLSID clsid,
            /* [unique][in] */ __RPC__in_opt IUnknown *pUnkOuter,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } ICreateObjectVtbl;

    interface ICreateObject
    {
        CONST_VTBL struct ICreateObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreateObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICreateObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICreateObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICreateObject_CreateObject(This,clsid,pUnkOuter,riid,ppv)	\
    ( (This)->lpVtbl -> CreateObject(This,clsid,pUnkOuter,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICreateObject_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_propsys_0000_0021 */
/* [local] */ 

// Format a property value for display purposes
PSSTDAPI PSFormatForDisplay(
    __in REFPROPERTYKEY propkey,
    __in REFPROPVARIANT propvar,
    __in PROPDESC_FORMAT_FLAGS pdfFlags,
    __out_ecount(cchText) LPWSTR pwszText,
    __in DWORD cchText);

PSSTDAPI PSFormatForDisplayAlloc(
    __in REFPROPERTYKEY key,
    __in REFPROPVARIANT propvar,
    __in PROPDESC_FORMAT_FLAGS pdff,
    __deref_out PWSTR *ppszDisplay);

PSSTDAPI PSFormatPropertyValue(
    __in IPropertyStore *pps,
    __in IPropertyDescription *ppd,
    __in PROPDESC_FORMAT_FLAGS pdff,
    __deref_out LPWSTR *ppszDisplay);


#define PKEY_PIDSTR_MAX     10   // will take care of any long integer value
#define GUIDSTRING_MAX      (1 + 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)  // "{12345678-1234-1234-1234-123456789012}"
#define PKEYSTR_MAX         (GUIDSTRING_MAX + 1 + PKEY_PIDSTR_MAX)

// Convert a PROPERTYKEY to and from a PWSTR
PSSTDAPI PSStringFromPropertyKey(
    __in REFPROPERTYKEY pkey,
    __out_ecount(cch) LPWSTR psz,
    __in UINT cch);

PSSTDAPI PSPropertyKeyFromString(
    __in LPCWSTR pszString,
    __out PROPERTYKEY *pkey);


// Creates an in-memory property store
// Returns an IPropertyStore, IPersistSerializedPropStorage, and related interfaces interface
PSSTDAPI PSCreateMemoryPropertyStore(
    __in REFIID riid,
    __deref_out void **ppv);


// Create a read-only, delay-bind multiplexing property store
// Returns an IPropertyStore interface or related interfaces
PSSTDAPI PSCreateDelayedMultiplexPropertyStore(
    __in GETPROPERTYSTOREFLAGS flags,
    __in IDelayedPropertyStoreFactory *pdpsf,
    __in_ecount(cStores) const DWORD *rgStoreIds,
    __in DWORD cStores,
    __in REFIID riid,
    __deref_out void **ppv);


// Create a read-only property store from one or more sources (which each must support either IPropertyStore or IPropertySetStorage)
// Returns an IPropertyStore interface or related interfaces
PSSTDAPI PSCreateMultiplexPropertyStore(
    __in_ecount(cStores) IUnknown **prgpunkStores,
    __in DWORD cStores,
    __in REFIID riid,
    __deref_out void **ppv);


// Create a container for IPropertyChanges
// Returns an IPropertyChangeArray interface
PSSTDAPI PSCreatePropertyChangeArray(
    __in_ecount_opt(cChanges) const PROPERTYKEY *rgpropkey,
    __in_ecount_opt(cChanges) const PKA_FLAGS *rgflags,
    __in_ecount_opt(cChanges) const PROPVARIANT *rgpropvar,
    __in UINT cChanges,
    __in REFIID riid,
    __deref_out void **ppv);


// Create a simple property change
// Returns an IPropertyChange interface
PSSTDAPI PSCreateSimplePropertyChange(
    __in PKA_FLAGS flags,
    __in REFPROPERTYKEY key,
    __in REFPROPVARIANT propvar,
    __in REFIID riid,
    __deref_out void **ppv);


// Get a property description
// Returns an IPropertyDescription interface
PSSTDAPI PSGetPropertyDescription(
    __in REFPROPERTYKEY propkey,
    __in REFIID riid,
    __deref_out void **ppv);

PSSTDAPI PSGetPropertyDescriptionByName(
    __in LPCWSTR pszCanonicalName,
    __in REFIID riid,
    __deref_out void **ppv);


// Lookup a per-machine registered file property handler
PSSTDAPI PSLookupPropertyHandlerCLSID(
    __in PCWSTR pszFilePath,
    __out CLSID *pclsid);
// Get a property handler, on Vista or downlevel to XP
// punkItem is a shell item created with an SHCreateItemXXX API
// Returns an IPropertyStore
PSSTDAPI PSGetItemPropertyHandler(
    __in IUnknown *punkItem,
    __in BOOL fReadWrite,
    __in REFIID riid,
    __deref_out void **ppv);


// Get a property handler, on Vista or downlevel to XP
// punkItem is a shell item created with an SHCreateItemXXX API
// punkCreateObject supports ICreateObject
// Returns an IPropertyStore
PSSTDAPI PSGetItemPropertyHandlerWithCreateObject(
    __in IUnknown *punkItem,
    __in BOOL fReadWrite,
    __in IUnknown *punkCreateObject,
    __in REFIID riid,
    __deref_out void **ppv);


// Get or set a property value from a store
PSSTDAPI PSGetPropertyValue(
    __in IPropertyStore *pps,
    __in IPropertyDescription *ppd,
    __out PROPVARIANT *ppropvar);

PSSTDAPI PSSetPropertyValue(
    __in IPropertyStore *pps,
    __in IPropertyDescription *ppd,
    __in REFPROPVARIANT propvar);


// Interact with the set of property descriptions
PSSTDAPI PSRegisterPropertySchema(
    __in PCWSTR pszPath);

PSSTDAPI PSUnregisterPropertySchema(
    __in PCWSTR pszPath);

PSSTDAPI PSRefreshPropertySchema();

// Returns either: IPropertyDescriptionList or IEnumUnknown interfaces
PSSTDAPI PSEnumeratePropertyDescriptions(
    __in PROPDESC_ENUMFILTER filterOn,
    __in REFIID riid,
    __deref_out void **ppv);


// Convert between a PROPERTYKEY and its canonical name
PSSTDAPI PSGetPropertyKeyFromName(
    __in PCWSTR pszName,
    __out PROPERTYKEY *ppropkey);

PSSTDAPI PSGetNameFromPropertyKey(
    __in REFPROPERTYKEY propkey,
    __deref_out PWSTR *ppszCanonicalName);


// Coerce and canonicalize a property value
PSSTDAPI PSCoerceToCanonicalValue(
    __in REFPROPERTYKEY key,
    __inout PROPVARIANT *ppropvar);


// Convert a 'prop:' string into a list of property descriptions
// Returns an IPropertyDescriptionList interface
PSSTDAPI PSGetPropertyDescriptionListFromString(
    __in LPCWSTR pszPropList,
    __in REFIID riid,
    __deref_out void **ppv);


// Wrap an IPropertySetStorage interface in an IPropertyStore interface
// Returns an IPropertyStore or related interface
PSSTDAPI PSCreatePropertyStoreFromPropertySetStorage(
    __in IPropertySetStorage *ppss,
    DWORD grfMode,
    REFIID riid,
    __deref_out void **ppv);


// punkSource must support IPropertyStore or IPropertySetStorage
// On success, the returned ppv is guaranteed to support IPropertyStore.
// If punkSource already supports IPropertyStore, no wrapper is created.
PSSTDAPI PSCreatePropertyStoreFromObject(
    __in IUnknown *punk,
    __in DWORD grfMode,
    __in REFIID riid,
    __deref_out void **ppv);


// punkSource must support IPropertyStore
// riid may be IPropertyStore, IPropertySetStorage, IPropertyStoreCapabilities, or IObjectProvider
PSSTDAPI PSCreateAdapterFromPropertyStore(
    __in IPropertyStore *pps,
    __in REFIID riid,
    __deref_out void **ppv);


// Talk to the property system using an interface
// Returns an IPropertySystem interface
PSSTDAPI PSGetPropertySystem(
    __in REFIID riid,
    __deref_out void **ppv);


// Obtain a value from serialized property storage
PSSTDAPI PSGetPropertyFromPropertyStorage(
    __in_bcount(cb) PCUSERIALIZEDPROPSTORAGE psps, 
    __in DWORD cb, 
    __in REFPROPERTYKEY rpkey, 
    __out PROPVARIANT *ppropvar);


// Obtain a named value from serialized property storage
PSSTDAPI PSGetNamedPropertyFromPropertyStorage(
    __in_bcount(cb) PCUSERIALIZEDPROPSTORAGE psps, 
    __in DWORD cb, 
    __in LPCWSTR pszName, 
    __out PROPVARIANT *ppropvar);




extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0021_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_propsys_0000_0021_v0_0_s_ifspec;


#ifndef __PropSysObjects_LIBRARY_DEFINED__
#define __PropSysObjects_LIBRARY_DEFINED__

/* library PropSysObjects */
/* [version][lcid][uuid] */ 


EXTERN_C const IID LIBID_PropSysObjects;

EXTERN_C const CLSID CLSID_InMemoryPropertyStore;

#ifdef __cplusplus

class DECLSPEC_UUID("9a02e012-6303-4e1e-b9a1-630f802592c5")
InMemoryPropertyStore;
#endif

EXTERN_C const CLSID CLSID_PropertySystem;

#ifdef __cplusplus

class DECLSPEC_UUID("b8967f85-58ae-4f46-9fb2-5d7904798f4b")
PropertySystem;
#endif
#endif /* __PropSysObjects_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     unsigned long *, LPSAFEARRAY * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IInitializeWithStream_Initialize_Proxy( 
    IInitializeWithStream * This,
    /* [in] */ IStream *pstream,
    /* [in] */ DWORD grfMode);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IInitializeWithStream_Initialize_Stub( 
    IInitializeWithStream * This,
    /* [in] */ __RPC__in_opt IStream *pstream,
    /* [in] */ DWORD grfMode);

/* [local] */ HRESULT STDMETHODCALLTYPE IPropertyDescription_CoerceToCanonicalValue_Proxy( 
    IPropertyDescription * This,
    /* [out][in] */ PROPVARIANT *ppropvar);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IPropertyDescription_CoerceToCanonicalValue_Stub( 
    IPropertyDescription * This,
    /* [in] */ __RPC__in REFPROPVARIANT propvar,
    /* [out] */ __RPC__out PROPVARIANT *ppropvar);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\propvarutil.h ===
//===========================================================================
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// propvarutil.h - Variant and PropVariant helpers
//
//===========================================================================

#pragma once

typedef __success(return >= 0) LONG NTSTATUS;
#include <propapi.h>
#include <shtypes.h>
#include <shlwapi.h>

#ifndef PSSTDAPI
#if defined(_PROPSYS_)
#define PSSTDAPI          STDAPI
#define PSSTDAPI_(type)   STDAPI_(type)
#else
#define PSSTDAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define PSSTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif
#endif // PSSTDAPI

enum tagPSTIME_FLAGS
{
    PSTF_UTC   = 0x00000000,
    PSTF_LOCAL = 0x00000001,
};
typedef int PSTIME_FLAGS;

//====================
//
// PropVariant Helpers
//
//====================

// Initialize a propvariant
PSSTDAPI InitPropVariantFromResource(HINSTANCE hinst, UINT id, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromBuffer(__in_bcount(cb) const void *pv, UINT cb, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromCLSID(REFCLSID clsid, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromGUIDAsString(REFGUID guid, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromFileTime(const FILETIME *pftIn, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromPropVariantVectorElem(REFPROPVARIANT propvarIn, ULONG iElem, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantVectorFromPropVariant(REFPROPVARIANT propvarSingle, __out PROPVARIANT *ppropvarVector);
PSSTDAPI InitPropVariantFromStrRet(__in STRRET *pstrret, PCUITEMID_CHILD pidl, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromBooleanVector(__in_ecount_opt(cElems) const BOOL *prgf, ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromInt16Vector(__in_ecount_opt(cElems) const SHORT *prgn, ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromUInt16Vector(__in_ecount_opt(cElems) const USHORT *prgn, ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromInt32Vector(__in_ecount_opt(cElems) const LONG *prgn, ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromUInt32Vector(__in_ecount_opt(cElems) const ULONG *prgn, ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromInt64Vector(__in_ecount_opt(cElems) const LONGLONG *prgn, ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromUInt64Vector(__in_ecount_opt(cElems) const ULONGLONG *prgn, ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromDoubleVector(__in_ecount_opt(cElems) const DOUBLE *prgn, ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromFileTimeVector(__in_ecount_opt(cElems) const FILETIME *prgft, ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromStringVector(__in_ecount_opt(cElems) PCWSTR *prgsz, ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromStringAsVector(PCWSTR psz, __out PROPVARIANT *ppropvar);
#ifdef __cplusplus
HRESULT  InitPropVariantFromBoolean(BOOL fVal, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromInt16(SHORT nVal, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromUInt16(USHORT uiVal, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromInt32(LONG lVal, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromUInt32(ULONG ulVal, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromInt64(LONGLONG llVal, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromUInt64(ULONGLONG ullVal, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromDouble(DOUBLE dblVal, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromString(PCWSTR psz, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromGUIDAsBuffer(REFGUID guid, __out PROPVARIANT *ppropvar);
BOOL     IsPropVariantVector(REFPROPVARIANT propvar);
BOOL     IsPropVariantString(REFPROPVARIANT propvar);
#endif

// Extract data from a propvariant
PSSTDAPI_(BOOL)      PropVariantToBooleanWithDefault(REFPROPVARIANT propvarIn, BOOL fDefault);
PSSTDAPI_(SHORT)     PropVariantToInt16WithDefault(REFPROPVARIANT propvarIn, SHORT iDefault);
PSSTDAPI_(USHORT)    PropVariantToUInt16WithDefault(REFPROPVARIANT propvarIn, USHORT uiDefault);
PSSTDAPI_(LONG)      PropVariantToInt32WithDefault(REFPROPVARIANT propvarIn, LONG lDefault);
PSSTDAPI_(ULONG)     PropVariantToUInt32WithDefault(REFPROPVARIANT propvarIn, ULONG ulDefault);
PSSTDAPI_(LONGLONG)  PropVariantToInt64WithDefault(REFPROPVARIANT propvarIn, LONGLONG llDefault);
PSSTDAPI_(ULONGLONG) PropVariantToUInt64WithDefault(REFPROPVARIANT propvarIn, ULONGLONG ullDefault);
PSSTDAPI_(DOUBLE)    PropVariantToDoubleWithDefault(REFPROPVARIANT propvarIn, DOUBLE dblDefault);
PSSTDAPI_(PCWSTR)    PropVariantToStringWithDefault(REFPROPVARIANT propvarIn, __in_opt LPCWSTR pszDefault);

PSSTDAPI             PropVariantToBoolean(REFPROPVARIANT propvarIn, __out BOOL *pfRet);
PSSTDAPI             PropVariantToInt16(REFPROPVARIANT propvarIn, __out SHORT *piRet);
PSSTDAPI             PropVariantToUInt16(REFPROPVARIANT propvarIn, __out USHORT *puiRet);
PSSTDAPI             PropVariantToInt32(REFPROPVARIANT propvarIn, __out LONG *plRet);
PSSTDAPI             PropVariantToUInt32(REFPROPVARIANT propvarIn, __out ULONG *pulRet);
PSSTDAPI             PropVariantToInt64(REFPROPVARIANT propvarIn, __out LONGLONG *pllRet);
PSSTDAPI             PropVariantToUInt64(REFPROPVARIANT propvarIn, __out ULONGLONG *pullRet);
PSSTDAPI             PropVariantToDouble(REFPROPVARIANT propvarIn, __out DOUBLE *pdblRet);
PSSTDAPI             PropVariantToBuffer(REFPROPVARIANT propvar, __out_bcount(cb) void *pv, UINT cb);
PSSTDAPI             PropVariantToString(REFPROPVARIANT propvar, __out_ecount(cch) PWSTR psz, UINT cch);
PSSTDAPI             PropVariantToGUID(REFPROPVARIANT propvar, __out GUID *pguid);
PSSTDAPI             PropVariantToStringAlloc(__in REFPROPVARIANT propvar, __deref_out PWSTR *ppszOut);
PSSTDAPI             PropVariantToBSTR(__in REFPROPVARIANT propvar, __deref_out BSTR *pbstrOut);
PSSTDAPI             PropVariantToStrRet(REFPROPVARIANT propvar, __out STRRET *pstrret);
PSSTDAPI             PropVariantToFileTime(REFPROPVARIANT propvar, PSTIME_FLAGS pstfOut, __out FILETIME* pftOut);
#ifdef __cplusplus
HRESULT              PropVariantToCLSID(REFPROPVARIANT propvar, __out CLSID *pclsid);
#endif


// Returns element count of a VT_VECTOR or VT_ARRAY value; or 1 otherwise
PSSTDAPI_(ULONG) PropVariantGetElementCount(REFPROPVARIANT propvar);

// Extract data from a propvariant into a vector
PSSTDAPI PropVariantToBooleanVector(REFPROPVARIANT propvar, __out_ecount_part(crgf, *pcElem) BOOL *prgf, ULONG crgf, __out ULONG *pcElem);
PSSTDAPI PropVariantToInt16Vector(REFPROPVARIANT propvar, __out_ecount_part(crgn, *pcElem) SHORT *prgn, ULONG crgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToUInt16Vector(REFPROPVARIANT propvar, __out_ecount_part(crgn, *pcElem) USHORT *prgn, ULONG crgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToInt32Vector(REFPROPVARIANT propvar, __out_ecount_part(crgn, *pcElem) LONG *prgn, ULONG crgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToUInt32Vector(REFPROPVARIANT propvar, __out_ecount_part(crgn, *pcElem) ULONG *prgn, ULONG crgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToInt64Vector(REFPROPVARIANT propvar, __out_ecount_part(crgn, *pcElem) LONGLONG *prgn, ULONG crgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToUInt64Vector(REFPROPVARIANT propvar, __out_ecount_part(crgn, *pcElem) ULONGLONG *prgn, ULONG crgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToDoubleVector(REFPROPVARIANT propvar, __out_ecount_part(crgn, *pcElem) DOUBLE *prgn, ULONG crgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToFileTimeVector(REFPROPVARIANT propvar, __out_ecount_part(crgft, *pcElem) FILETIME *prgft, ULONG crgft, __out ULONG *pcElem);
PSSTDAPI PropVariantToStringVector(REFPROPVARIANT propvar, __out_ecount_part(crgsz, *pcElem) PWSTR *prgsz, ULONG crgsz, __out ULONG *pcElem);

// Extract data from a propvariant and return an newly allocated vector (free with CoTaskMemFree)
PSSTDAPI PropVariantToBooleanVectorAlloc(REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) BOOL **pprgf, __out ULONG *pcElem);
PSSTDAPI PropVariantToInt16VectorAlloc(REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) SHORT **pprgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToUInt16VectorAlloc(REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) USHORT **pprgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToInt32VectorAlloc(REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) LONG **pprgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToUInt32VectorAlloc(REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) ULONG **pprgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToInt64VectorAlloc(REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) LONGLONG **pprgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToUInt64VectorAlloc(REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) ULONGLONG **pprgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToDoubleVectorAlloc(REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) DOUBLE **pprgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToFileTimeVectorAlloc(REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) FILETIME **pprgft, __out ULONG *pcElem);
PSSTDAPI PropVariantToStringVectorAlloc(REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) PWSTR **pprgsz, __out ULONG *pcElem);

// Extract a single element from a propvariant.  If it is a VT_VECTOR or VT_ARRAY, returns the element you request.
// Otherwise iElem must equal 0 and the function will returns the value.
PSSTDAPI PropVariantGetBooleanElem(REFPROPVARIANT propvar, ULONG iElem, __out BOOL *pfVal);
PSSTDAPI PropVariantGetInt16Elem(REFPROPVARIANT propvar, ULONG iElem, __out SHORT *pnVal);
PSSTDAPI PropVariantGetUInt16Elem(REFPROPVARIANT propvar, ULONG iElem, __out USHORT *pnVal);
PSSTDAPI PropVariantGetInt32Elem(REFPROPVARIANT propvar, ULONG iElem, __out LONG *pnVal);
PSSTDAPI PropVariantGetUInt32Elem(REFPROPVARIANT propvar, ULONG iElem, __out ULONG *pnVal);
PSSTDAPI PropVariantGetInt64Elem(REFPROPVARIANT propvar, ULONG iElem, __out LONGLONG *pnVal);
PSSTDAPI PropVariantGetUInt64Elem(REFPROPVARIANT propvar, ULONG iElem, __out ULONGLONG *pnVal);
PSSTDAPI PropVariantGetDoubleElem(REFPROPVARIANT propvar, ULONG iElem, __out DOUBLE *pnVal);
PSSTDAPI PropVariantGetFileTimeElem(REFPROPVARIANT propvar, ULONG iElem, __out FILETIME *pftVal);
PSSTDAPI PropVariantGetStringElem(REFPROPVARIANT propvar, ULONG iElem, __deref_out PWSTR *ppszVal);
#ifdef __cplusplus
HRESULT  PropVariantGetElem(REFPROPVARIANT propvarIn, ULONG iElem, __out PROPVARIANT *ppropvar);
#endif

// Helpers
PSSTDAPI_(void) ClearPropVariantArray(__inout_ecount(cVars) PROPVARIANT *rgPropVar, UINT cVars);

typedef enum 
{
    PVCU_DEFAULT = 0,
    PVCU_SECOND  = 1,
    PVCU_MINUTE  = 2,
    PVCU_HOUR    = 3,
    PVCU_DAY     = 4,
    PVCU_MONTH   = 5,
    PVCU_YEAR    = 6
} PROPVAR_COMPARE_UNIT;

enum tagPROPVAR_COMPARE_FLAGS
{
    PVCF_DEFAULT                 = 0x00000000,   // When comparing strings, use StrCmpLogical
    PVCF_TREATEMPTYASGREATERTHAN = 0x00000001,   // Empty/null values are greater-than non-empty values
    PVCF_USESTRCMP               = 0x00000002,   // When comparing strings, use StrCmp
    PVCF_USESTRCMPC              = 0x00000004,   // When comparing strings, use StrCmpC
    PVCF_USESTRCMPI              = 0x00000008,   // When comparing strings, use StrCmpI
    PVCF_USESTRCMPIC             = 0x00000010,   // When comparing strings, use StrCmpIC
};
typedef int PROPVAR_COMPARE_FLAGS;

// Comparisons
PSSTDAPI_(int) PropVariantCompareEx(REFPROPVARIANT propvar1, REFPROPVARIANT propvar2, PROPVAR_COMPARE_UNIT unit, PROPVAR_COMPARE_FLAGS flags);
#ifdef __cplusplus
int PropVariantCompare(REFPROPVARIANT propvar1, REFPROPVARIANT propvar2);
#endif

enum tagPROPVAR_CHANGE_FLAGS
{
    PVCHF_DEFAULT           = 0x00000000,
    PVCHF_NOVALUEPROP       = 0x00000001,       // Maps to VARIANT_NOVALUEPROP for VariantChangeType
    PVCHF_ALPHABOOL         = 0x00000002,       // Maps to VARIANT_ALPHABOOL for VariantChangeType
    PVCHF_NOUSEROVERRIDE    = 0x00000004,       // Maps to VARIANT_NOUSEROVERRIDE for VariantChangeType
    PVCHF_LOCALBOOL         = 0x00000008,       // Maps to VARIANT_LOCALBOOL for VariantChangeType
    PVCHF_NOHEXSTRING       = 0x00000010,       // Don't convert a string that looks like hexadecimal (0xABCD) to the numerical equivalent
};
typedef int PROPVAR_CHANGE_FLAGS;

// Coersions
PSSTDAPI PropVariantChangeType(__out PROPVARIANT *ppropvarDest, REFPROPVARIANT propvarSrc, PROPVAR_CHANGE_FLAGS flags, VARTYPE vt);

// Conversions
PSSTDAPI PropVariantToVariant(__in const PROPVARIANT *pPropVar, __out VARIANT *pVar);
PSSTDAPI VariantToPropVariant(__in const VARIANT* pVar, __out PROPVARIANT* pPropVar);

// Stg functions
PSSTDAPI StgSerializePropVariant(
            __in const PROPVARIANT* ppropvar,
            __deref_out_bcount(*pcb) SERIALIZEDPROPERTYVALUE** ppProp,
            __out ULONG* pcb);
    
PSSTDAPI StgDeserializePropVariant(
            __in const SERIALIZEDPROPERTYVALUE* pprop,
            __in ULONG cbMax,
            __out PROPVARIANT* ppropvar);



//================
//
// Variant Helpers
//
//================

#ifdef __cplusplus
BOOL IsVarTypeFloat(VARTYPE vt);
BOOL IsVariantArray(REFVARIANT var);
BOOL IsVariantString(REFVARIANT var);
BOOL IsVarTypeNumber(VARTYPE vt);
BOOL IsVarTypeInteger(VARTYPE vt);
#endif

// Initialize a VARIANT
PSSTDAPI InitVariantFromResource(HINSTANCE hinst, UINT id, __out VARIANT *pvar);
PSSTDAPI InitVariantFromBuffer(__in_bcount(cb) const void *pv, UINT cb, __out VARIANT *pvar);
PSSTDAPI InitVariantFromGUIDAsString(REFGUID guid, __out VARIANT *pvar);
PSSTDAPI InitVariantFromFileTime(const FILETIME *pft, __out VARIANT *pvar);
PSSTDAPI InitVariantFromFileTimeArray(__in_ecount_opt(cElems) const FILETIME *prgft, ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromStrRet(__in STRRET *pstrret, PCUITEMID_CHILD pidl, __out VARIANT *pvar);
PSSTDAPI InitVariantFromVariantArrayElem(REFVARIANT varIn, ULONG iElem, __out VARIANT *pvar);
PSSTDAPI InitVariantFromBooleanArray(__in_ecount(cElems) const BOOL *prgf, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromInt16Array(__in_ecount(cElems) const SHORT *prgn, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromUInt16Array(__in_ecount(cElems) const USHORT *prgn, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromInt32Array(__in_ecount(cElems) const LONG *prgn, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromUInt32Array(__in_ecount(cElems) const ULONG *prgn, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromInt64Array(__in_ecount(cElems) const LONGLONG *prgn, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromUInt64Array(__in_ecount(cElems) const ULONGLONG *prgn, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromDoubleArray(__in_ecount(cElems) const DOUBLE *prgn, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromStringArray(__in_ecount(cElems) PCWSTR *prgsz, __in ULONG cElems, __out VARIANT *pvar);
#ifdef __cplusplus
HRESULT  InitVariantFromBoolean(BOOL fVal, __out VARIANT *pvar);
HRESULT  InitVariantFromInt16(SHORT iVal, __out VARIANT *pvar);
HRESULT  InitVariantFromUInt16(USHORT uiVal, __out VARIANT *pvar);
HRESULT  InitVariantFromInt32(LONG lVal, __out VARIANT *pvar);
HRESULT  InitVariantFromUInt32(ULONG ulVal, __out VARIANT *pvar);
HRESULT  InitVariantFromInt64(LONGLONG llVal, __out VARIANT *pvar);
HRESULT  InitVariantFromUInt64(ULONGLONG ullVal, __out VARIANT *pvar);
HRESULT  InitVariantFromDouble(DOUBLE dblVal, __out VARIANT *pvar);
HRESULT  InitVariantFromString(PCWSTR psz, __out VARIANT *pvar);
HRESULT  InitVariantFromDispatch(IDispatch* pdisp, __out VARIANT *pvar);
HRESULT  InitVariantFromDosDateTime(WORD wDate, WORD wTime, __out VARIANT *pvar);
HRESULT  InitVariantFromGUIDAsBuffer(REFGUID guid, __out VARIANT *pvar);
#endif

// Extract data from a VARIANT
PSSTDAPI_(BOOL)       VariantToBooleanWithDefault(REFVARIANT varIn, BOOL fDefault);
PSSTDAPI_(SHORT)      VariantToInt16WithDefault(REFVARIANT varIn, SHORT iDefault);
PSSTDAPI_(USHORT)     VariantToUInt16WithDefault(REFVARIANT varIn, USHORT uiDefault);
PSSTDAPI_(LONG)       VariantToInt32WithDefault(REFVARIANT varIn, LONG lDefault);
PSSTDAPI_(ULONG)      VariantToUInt32WithDefault(REFVARIANT varIn, ULONG ulDefault);
PSSTDAPI_(LONGLONG)   VariantToInt64WithDefault(REFVARIANT varIn, LONGLONG llDefault);
PSSTDAPI_(ULONGLONG)  VariantToUInt64WithDefault(REFVARIANT varIn, ULONGLONG ullDefault);
PSSTDAPI_(DOUBLE)     VariantToDoubleWithDefault(REFVARIANT varIn, DOUBLE dblDefault);
PSSTDAPI_(PCWSTR)     VariantToStringWithDefault(REFVARIANT varIn, __in_opt LPCWSTR pszDefault);

PSSTDAPI              VariantToBoolean(REFVARIANT varIn, __out BOOL *pfRet);
PSSTDAPI              VariantToInt16(REFVARIANT varIn, __out SHORT *piRet);
PSSTDAPI              VariantToUInt16(REFVARIANT varIn, __out USHORT *puiRet);
PSSTDAPI              VariantToInt32(REFVARIANT varIn, __out LONG *plRet);
PSSTDAPI              VariantToUInt32(REFVARIANT varIn, __out ULONG *pulRet);
PSSTDAPI              VariantToInt64(REFVARIANT varIn, __out LONGLONG *pllRet);
PSSTDAPI              VariantToUInt64(REFVARIANT varIn, __out ULONGLONG *pullRet);
PSSTDAPI              VariantToDouble(REFVARIANT varIn, __out DOUBLE *pdblRet);
PSSTDAPI              VariantToBuffer(REFVARIANT varIn, __out_bcount(cb) void *pv, UINT cb);
PSSTDAPI              VariantToGUID(REFVARIANT varIn, __out GUID *pguid);
PSSTDAPI              VariantToString(REFVARIANT varIn, __out_ecount(cchBuf) PWSTR pszBuf, UINT cchBuf);
PSSTDAPI              VariantToStringAlloc(REFVARIANT varIn, __deref_out PWSTR *ppszBuf);
PSSTDAPI              VariantToDosDateTime(REFVARIANT varIn, __out WORD *pwDate, __out WORD *pwTime);
PSSTDAPI              VariantToStrRet(REFVARIANT varIn, __out STRRET *pstrret);
PSSTDAPI              VariantToFileTime(REFVARIANT varIn, PSTIME_FLAGS stfOut, __out FILETIME* pftOut);

// Get the element count.  Returns number of elements for values of type VT_ARRAY; returns 1 otherwise.
PSSTDAPI_(ULONG) VariantGetElementCount(REFVARIANT varIn);

// Extract data from a VARIANT into a vector
PSSTDAPI VariantToBooleanArray(REFVARIANT var, __out_ecount_part(crgn, *pcElem) BOOL *prgf, ULONG crgn, __out ULONG *pcElem);
PSSTDAPI VariantToInt16Array(REFVARIANT var, __out_ecount_part(crgn, *pcElem) SHORT *prgn, ULONG crgn, __out ULONG *pcElem);
PSSTDAPI VariantToUInt16Array(REFVARIANT var, __out_ecount_part(crgn, *pcElem) USHORT *prgn, ULONG crgn, __out ULONG *pcElem);
PSSTDAPI VariantToInt32Array(REFVARIANT var, __out_ecount_part(crgn, *pcElem) LONG *prgn, ULONG crgn, __out ULONG *pcElem);
PSSTDAPI VariantToUInt32Array(REFVARIANT var, __out_ecount_part(crgn, *pcElem) ULONG *prgn, ULONG crgn, __out ULONG *pcElem);
PSSTDAPI VariantToInt64Array(REFVARIANT var, __out_ecount_part(crgn, *pcElem) LONGLONG *prgn, ULONG crgn, __out ULONG *pcElem);
PSSTDAPI VariantToUInt64Array(REFVARIANT var, __out_ecount_part(crgn, *pcElem) ULONGLONG *prgn, ULONG crgn, __out ULONG *pcElem);
PSSTDAPI VariantToDoubleArray(REFVARIANT var, __out_ecount_part(crgn, *pcElem) DOUBLE *prgn, ULONG crgn, __out ULONG *pcElem);
PSSTDAPI VariantToStringArray(REFVARIANT var, __out_ecount_part(crgsz, *pcElem) PWSTR *prgsz, ULONG crgsz, __out ULONG *pcElem);

// Extract data from a VARIANT into a newly allocated vector (use ClearVariantArray to release it)
PSSTDAPI VariantToBooleanArrayAlloc(REFVARIANT var, __deref_out_ecount(*pcElem) BOOL **pprgf, __out ULONG *pcElem);
PSSTDAPI VariantToInt16ArrayAlloc(REFVARIANT var, __deref_out_ecount(*pcElem) SHORT **pprgn, __out ULONG *pcElem);
PSSTDAPI VariantToUInt16ArrayAlloc(REFVARIANT var, __deref_out_ecount(*pcElem) USHORT **pprgn, __out ULONG *pcElem);
PSSTDAPI VariantToInt32ArrayAlloc(REFVARIANT var, __deref_out_ecount(*pcElem) LONG **pprgn, __out ULONG *pcElem);
PSSTDAPI VariantToUInt32ArrayAlloc(REFVARIANT var, __deref_out_ecount(*pcElem) ULONG **pprgn, __out ULONG *pcElem);
PSSTDAPI VariantToInt64ArrayAlloc(REFVARIANT var, __deref_out_ecount(*pcElem) LONGLONG **pprgn, __out ULONG *pcElem);
PSSTDAPI VariantToUInt64ArrayAlloc(REFVARIANT var, __deref_out_ecount(*pcElem) ULONGLONG **pprgn, __out ULONG *pcElem);
PSSTDAPI VariantToDoubleArrayAlloc(REFVARIANT var, __deref_out_ecount(*pcElem) DOUBLE **pprgn, __out ULONG *pcElem);
PSSTDAPI VariantToStringArrayAlloc(REFVARIANT var, __deref_out_ecount(*pcElem) PWSTR **pprgsz, __out ULONG *pcElem);

// Get a single element of a VARIANT.  If it is type VT_ARRAY, returns a the requested element.  Otherwise
// iElem must equal 0 and the function returns the value.
PSSTDAPI VariantGetBooleanElem(REFVARIANT var, ULONG iElem, __out BOOL *pfVal);
PSSTDAPI VariantGetInt16Elem(REFVARIANT var, ULONG iElem, __out SHORT *pnVal);
PSSTDAPI VariantGetUInt16Elem(REFVARIANT var, ULONG iElem, __out USHORT *pnVal);
PSSTDAPI VariantGetInt32Elem(REFVARIANT var, ULONG iElem, __out LONG *pnVal);
PSSTDAPI VariantGetUInt32Elem(REFVARIANT var, ULONG iElem, __out ULONG *pnVal);
PSSTDAPI VariantGetInt64Elem(REFVARIANT var, ULONG iElem, __out LONGLONG *pnVal);
PSSTDAPI VariantGetUInt64Elem(REFVARIANT var, ULONG iElem, __out ULONGLONG *pnVal);
PSSTDAPI VariantGetDoubleElem(REFVARIANT var, ULONG iElem, __out DOUBLE *pnVal);
PSSTDAPI VariantGetStringElem(REFVARIANT var, ULONG iElem, __deref_out PWSTR *ppszVal);
#ifdef __cplusplus
HRESULT  VariantGetElem(REFVARIANT varIn, ULONG iElem, __out VARIANT *pvar);
#endif

// Helpers
PSSTDAPI_(void) ClearVariantArray(__inout_ecount(cvars) VARIANT *pvars, UINT cvars);
PSSTDAPI_(int) VariantCompare(REFVARIANT var1, REFVARIANT var2);

//===========================
//
// Property-specific notions
//
//===========================


// The progress bar property control uses a specially formatted PROPVARIANT to convey the look of the progress bar
// propvar.vt = VT_UI4
// propvar.caul.pElems[0] = current progress
// propvar.caul.pElems[1] = total progress
// propvar.caul.pElems[2] = DRAWPROGRESSFLAGS (see below);
typedef enum DRAWPROGRESSFLAGS
{
    DPF_NONE                = 0x0,  // No progress flags.
    DPF_MARQUEE             = 0x1,  // The progress bar should draw in marquee mode.
    DPF_MARQUEE_COMPLETE    = 0x2,  // The marquee format progress bar has completed.
    DPF_ERROR               = 0x4,  // The progress bar should be drawn in the error state.
    DPF_WARNING             = 0x8,  // The progress bar should be drawn in the warning state.
    DPF_STOPPED             = 0x10, // The progress bar is stopped.
} DRAWPROGRESSFLAGS;

//================
//
// Inline Helpers
//
//================

#ifdef __cplusplus
inline HRESULT InitPropVariantFromBoolean(BOOL fVal, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_BOOL;
    ppropvar->boolVal = fVal ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

inline HRESULT InitPropVariantFromInt16(SHORT nVal, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_I2;
    ppropvar->iVal = nVal;
    return S_OK;
}

inline HRESULT InitPropVariantFromUInt16(USHORT uiVal, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_UI2;
    ppropvar->uiVal = uiVal;
    return S_OK;
}

inline HRESULT InitPropVariantFromInt32(LONG lVal, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_I4;
    ppropvar->lVal = lVal;
    return S_OK;
}

inline HRESULT InitPropVariantFromUInt32(ULONG ulVal, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_UI4;
    ppropvar->ulVal = ulVal;
    return S_OK;
}

inline HRESULT InitPropVariantFromInt64(LONGLONG llVal, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_I8;
    ppropvar->hVal.QuadPart = llVal;
    return S_OK;
}

inline HRESULT InitPropVariantFromUInt64(ULONGLONG ullVal, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_UI8;
    ppropvar->uhVal.QuadPart = ullVal;
    return S_OK;
}

inline HRESULT InitPropVariantFromDouble(DOUBLE dblVal, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_R8;
    ppropvar->dblVal = dblVal;
    return S_OK;
}

// Creates a VT_LPWSTR propvariant.
inline HRESULT InitPropVariantFromString(PCWSTR psz, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_LPWSTR;
    HRESULT hr = SHStrDupW(psz, &ppropvar->pwszVal);
    if (FAILED(hr))
    {
        PropVariantInit(ppropvar);
    }
    return hr;
}

// Creates a VT_VECTOR | VT_UI1 propvariant.
inline HRESULT InitPropVariantFromGUIDAsBuffer(REFGUID guid, __out PROPVARIANT *ppropvar)
{
    return InitPropVariantFromBuffer(&guid, sizeof(GUID), ppropvar);
}

inline BOOL IsPropVariantVector(REFPROPVARIANT propvar)
{
    return (propvar.vt & (VT_ARRAY | VT_VECTOR));
}

// If TRUE, propvar contains a unicode string.  Use PropVariantToStringWithDefault(propvar, NULL) to retrieve it.
inline BOOL IsPropVariantString(REFPROPVARIANT propvar)
{
    return (PropVariantToStringWithDefault(propvar, NULL) != NULL);
}

// Handles int instead of LONG
inline HRESULT PropVariantToInt32(REFPROPVARIANT propvarIn, __out int *piRet)
{
    return PropVariantToInt32(propvarIn, (LONG*)piRet);
}

// Handles UINT instead of ULONG
inline HRESULT PropVariantToUInt32(REFPROPVARIANT propvarIn, __out UINT *piRet)
{
    return PropVariantToUInt32(propvarIn, (ULONG*)piRet);
}

inline HRESULT PropVariantToCLSID(REFPROPVARIANT propvarIn, __out CLSID *pclsid)
{ 
    return PropVariantToGUID(propvarIn, (GUID*)pclsid);
}  


inline int PropVariantCompare(REFPROPVARIANT propvar1, REFPROPVARIANT propvar2)
{
    return PropVariantCompareEx(propvar1, propvar2, PVCU_DEFAULT, PVCF_DEFAULT);
}

inline HRESULT PropVariantGetElem(REFPROPVARIANT propvarIn, ULONG iElem, __out PROPVARIANT *ppropvar)
{
    return InitPropVariantFromPropVariantVectorElem(propvarIn, iElem, ppropvar);
}

inline HRESULT InitVariantFromBoolean(BOOL fVal, __out VARIANT *pvar)
{
    pvar->vt = VT_BOOL;
    pvar->boolVal = fVal ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

inline HRESULT InitVariantFromInt16(short iVal, __out VARIANT *pvar)
{
    pvar->vt = VT_I2;
    pvar->iVal = iVal;
    return S_OK;
}

inline HRESULT InitVariantFromUInt16(USHORT uiVal, __out VARIANT *pvar)
{
    pvar->vt = VT_UI2;
    pvar->uiVal = uiVal;
    return S_OK;
}

inline HRESULT InitVariantFromInt32(LONG lVal, __out VARIANT *pvar)
{
    pvar->vt = VT_I4;
    pvar->lVal = lVal;
    return S_OK;
}

inline HRESULT InitVariantFromUInt32(ULONG ulVal, __out VARIANT *pvar)
{
    pvar->vt = VT_UI4;
    pvar->ulVal = ulVal;
    return S_OK;
}

inline HRESULT InitVariantFromInt64(LONGLONG llVal, __out VARIANT *pvar)
{
    pvar->vt = VT_I8;
    pvar->llVal = llVal;
    return S_OK;
}

inline HRESULT InitVariantFromUInt64(ULONGLONG ullVal, __out VARIANT *pvar)
{
    pvar->vt = VT_UI8;
    pvar->ullVal = ullVal;
    return S_OK;
}

inline HRESULT InitVariantFromDouble(DOUBLE dblVal, __out VARIANT *pvar)
{
    pvar->vt = VT_R8;
    pvar->dblVal = dblVal;
    return S_OK;
}

inline HRESULT InitVariantFromString(PCWSTR psz, __out VARIANT *pvar)
{
    pvar->vt = VT_BSTR;
    pvar->bstrVal = SysAllocString(psz);
    HRESULT hr =  pvar->bstrVal ? S_OK : (psz ? S_OK : E_OUTOFMEMORY);
    if (FAILED(hr))
    {
        VariantInit(pvar);
    }
    return hr;
}

inline HRESULT InitVariantFromDispatch(IDispatch* pdisp, __out VARIANT *pvar)
{
    pvar->vt = VT_DISPATCH;
    pvar->pdispVal = pdisp;
    if (pvar->pdispVal)
    {
        (pvar->pdispVal)->AddRef();
    }
    return S_OK;
}

// Creates a VT_DATE variant
inline HRESULT InitVariantFromDosDateTime(WORD wDate, WORD wTime, __out VARIANT *pvar)
{
    pvar->vt = VT_DATE;
    return DosDateTimeToVariantTime(wDate, wTime, &pvar->date) ? S_OK : S_FALSE;
}

inline BOOL IsVarTypeFloat(VARTYPE vt)
{
    return (vt == VT_R4 || vt == VT_R8);
}

inline BOOL IsVariantArray(REFVARIANT var)
{
    return (var.vt & VT_ARRAY);
}

// if TRUE, you can use VariantToStringCast to obtain the string pointer
inline BOOL IsVariantString(REFVARIANT var)
{
    return (VariantToStringWithDefault(var, NULL) != NULL);
}

inline BOOL IsVarTypeNumber(VARTYPE vt)
{
    return IsVarTypeInteger(vt) || IsVarTypeFloat(vt);
}

inline BOOL IsVarTypeSignedInteger(VARTYPE vt)
{
    BOOL fRet = FALSE;
    switch (vt)
    {
        case VT_I1:
        case VT_I2:
        case VT_I4:
        case VT_I8:
        fRet = TRUE;
    }
    return fRet;
}

inline BOOL IsVarTypeUnsignedInteger(VARTYPE vt)
{
    BOOL fRet = FALSE;
    switch (vt)
    {
        case VT_UI1:
        case VT_UI2:
        case VT_UI4:
        case VT_UI8:
        fRet = TRUE;
    }
    return fRet;
}

inline BOOL IsVarTypeInteger(VARTYPE vt)
{
    return IsVarTypeSignedInteger(vt) || IsVarTypeUnsignedInteger(vt);
}

// Creates a VT_ARRAY | VT_UI1 variant.
inline HRESULT InitVariantFromGUIDAsBuffer(REFGUID guid, __out VARIANT *pvar)
{
    return InitVariantFromBuffer(&guid, sizeof(GUID), pvar);
}

// Handles int instead of LONG
inline HRESULT VariantToInt32(REFVARIANT varIn, __out int *piRet)
{
    return VariantToInt32(varIn, (LONG*)piRet);
}

// Handles UINT instead of ULONG
inline HRESULT VariantToUInt32(REFVARIANT varIn, __out UINT *piRet)
{
    return VariantToUInt32(varIn, (ULONG*)piRet);
}

inline HRESULT VariantGetElem(REFVARIANT varIn, ULONG iElem, __out VARIANT *pvar)
{
    return InitVariantFromVariantArrayElem(varIn, iElem, pvar);
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\prsht.inl ===
/* Copyright (c) 2001-2006, Microsoft Corp. All rights reserved. */

#if _MSC_VER > 1000
#pragma once
#endif

#if defined(__cplusplus)
extern "C" {
#endif


#if !defined(RC_INVOKED) /* RC complains about long symbols in #ifs */
#if defined(ISOLATION_AWARE_ENABLED) && (ISOLATION_AWARE_ENABLED != 0)


#if !defined(ISOLATION_AWARE_USE_STATIC_LIBRARY)
#define ISOLATION_AWARE_USE_STATIC_LIBRARY 0
#endif

#if !defined(ISOLATION_AWARE_BUILD_STATIC_LIBRARY)
#define ISOLATION_AWARE_BUILD_STATIC_LIBRARY 0
#endif

#if !defined(ISOLATION_AWARE_INLINE)
#if ISOLATION_AWARE_BUILD_STATIC_LIBRARY
#define ISOLATION_AWARE_INLINE /* nothing */
#else
#if defined(__cplusplus)
#define ISOLATION_AWARE_INLINE inline
#else
#define ISOLATION_AWARE_INLINE __inline
#endif
#endif
#endif

#if !ISOLATION_AWARE_USE_STATIC_LIBRARY
FARPROC IsolationAwarePrivatenCv PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY(LPCSTR pszProcName);

#endif /* ISOLATION_AWARE_USE_STATIC_LIBRARY */
HPROPSHEETPAGE IsolationAwarePrivatenCv IsolationAwareCreatePropertySheetPageA(LPCPROPSHEETPAGEA constPropSheetPagePointer);
HPROPSHEETPAGE IsolationAwarePrivatenCv IsolationAwareCreatePropertySheetPageW(LPCPROPSHEETPAGEW constPropSheetPagePointer);
BOOL IsolationAwarePrivatenCv IsolationAwareDestroyPropertySheetPage(HPROPSHEETPAGE unnamed1);
INT_PTR IsolationAwarePrivatenCv IsolationAwarePropertySheetA(LPCPROPSHEETHEADERA unnamed1);
INT_PTR IsolationAwarePrivatenCv IsolationAwarePropertySheetW(LPCPROPSHEETHEADERW unnamed1);

#if defined(UNICODE)

#define IsolationAwareCreatePropertySheetPage IsolationAwareCreatePropertySheetPageW
#define IsolationAwarePropertySheet IsolationAwarePropertySheetW

#else /* UNICODE */

#define IsolationAwareCreatePropertySheetPage IsolationAwareCreatePropertySheetPageA
#define IsolationAwarePropertySheet IsolationAwarePropertySheetA

#endif /* UNICODE */

#if !ISOLATION_AWARE_USE_STATIC_LIBRARY
ISOLATION_AWARE_INLINE HPROPSHEETPAGE IsolationAwarePrivatenCv IsolationAwareCreatePropertySheetPageA(LPCPROPSHEETPAGEA constPropSheetPagePointer)
{
    HPROPSHEETPAGE result = NULL;
    typedef HPROPSHEETPAGE (WINAPI* PFN)(LPCPROPSHEETPAGEA constPropSheetPagePointer);
    static PFN s_pfn;

    const LPPROPSHEETPAGEA_LATEST latestPropSheetPagePointer = (LPPROPSHEETPAGEA_LATEST)constPropSheetPagePointer;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return result;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("CreatePropertySheetPageA");
            if (s_pfn == NULL)
                __leave;
        }

#ifndef _WIN64
        if (IsolationAwarePrivateT_SqbjaYRiRY)
        {
            if ((latestPropSheetPagePointer->dwFlags & PSP_USEFUSIONCONTEXT) != 0)
            {
                latestPropSheetPagePointer->dwFlags &= ~PSP_USEFUSIONCONTEXT;
            }
        }
        else
#endif
        if ((   latestPropSheetPagePointer->dwFlags & PSP_USEFUSIONCONTEXT) == 0
                    && latestPropSheetPagePointer->dwSize >= sizeof(PROPSHEETPAGEA_V3)
                  )
        {
            latestPropSheetPagePointer->dwFlags |= PSP_USEFUSIONCONTEXT;
            latestPropSheetPagePointer->hActCtx = WinbaseIsolationAwarePrivateT_UnPgpgk;
        }
        result = s_pfn(constPropSheetPagePointer);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (result == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE HPROPSHEETPAGE IsolationAwarePrivatenCv IsolationAwareCreatePropertySheetPageW(LPCPROPSHEETPAGEW constPropSheetPagePointer)
{
    HPROPSHEETPAGE result = NULL;
    typedef HPROPSHEETPAGE (WINAPI* PFN)(LPCPROPSHEETPAGEW constPropSheetPagePointer);
    static PFN s_pfn;

    const LPPROPSHEETPAGEW_LATEST latestPropSheetPagePointer = (LPPROPSHEETPAGEW_LATEST)constPropSheetPagePointer;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return result;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("CreatePropertySheetPageW");
            if (s_pfn == NULL)
                __leave;
        }

#ifndef _WIN64
        if (IsolationAwarePrivateT_SqbjaYRiRY)
        {
            if ((latestPropSheetPagePointer->dwFlags & PSP_USEFUSIONCONTEXT) != 0)
            {
                latestPropSheetPagePointer->dwFlags &= ~PSP_USEFUSIONCONTEXT;
            }
        }
        else
#endif
        if ((   latestPropSheetPagePointer->dwFlags & PSP_USEFUSIONCONTEXT) == 0
                    && latestPropSheetPagePointer->dwSize >= sizeof(PROPSHEETPAGEW_V3)
                  )
        {
            latestPropSheetPagePointer->dwFlags |= PSP_USEFUSIONCONTEXT;
            latestPropSheetPagePointer->hActCtx = WinbaseIsolationAwarePrivateT_UnPgpgk;
        }
        result = s_pfn(constPropSheetPagePointer);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (result == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareDestroyPropertySheetPage(HPROPSHEETPAGE unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HPROPSHEETPAGE unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DestroyPropertySheetPage");
            if (s_pfn == NULL)
                __leave;
        }
        fResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE INT_PTR IsolationAwarePrivatenCv IsolationAwarePropertySheetA(LPCPROPSHEETHEADERA unnamed1)
{
    INT_PTR nResult = -1;
    typedef INT_PTR (WINAPI* PFN)(LPCPROPSHEETHEADERA unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("PropertySheetA");
            if (s_pfn == NULL)
                __leave;
        }
        nResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == -1);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE INT_PTR IsolationAwarePrivatenCv IsolationAwarePropertySheetW(LPCPROPSHEETHEADERW unnamed1)
{
    INT_PTR nResult = -1;
    typedef INT_PTR (WINAPI* PFN)(LPCPROPSHEETHEADERW unnamed1);
    static PFN s_pfn;
    ULONG_PTR  ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (s_pfn == NULL)
        {
            s_pfn = (PFN)PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("PropertySheetW");
            if (s_pfn == NULL)
                __leave;
        }
        nResult = s_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == -1);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE FARPROC IsolationAwarePrivatenCv PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY(LPCSTR pszProcName)
/* This function is shared by the other stubs in this header. */
{
    FARPROC proc = NULL;
    static HMODULE s_module;
    BOOL fActivateActCtxSuccess = FALSE;
    ULONG_PTR ulpCookie = 0;
#ifndef _M_CEE_PURE
    const static IsolationAwarePrivatepBAFGnAG_zBqHyr_vAsB
        c = { IsolationAwarePrivatezlybNQyVOeNelJ, L"Comctl32.dll"
#ifdef _M_IX86
             , IsolationAwarePrivatezlybNQyVOeNeln, "Comctl32.dll"
#endif
    };
#else
    static IsolationAwarePrivatepBAFGnAG_zBqHyr_vAsB c;
    c.WinbaseIsolationAwarePrivateybNQJ = IsolationAwarePrivatezlybNQyVOeNelJ;
    c.WinbaseIsolationAwarePrivateANZRJ = L"Comctl32.dll";
#ifdef _M_IX86
    c.WinbaseIsolationAwarePrivateybNQn = IsolationAwarePrivatezlybNQyVOeNeln;
    c.WinbaseIsolationAwarePrivateANZRn = "Comctl32.dll";
#endif
#endif
    static IsolationAwarePrivatezHGnoyr_zBqHyr_vAsB m;

    __try
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            fActivateActCtxSuccess = IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
            if (!fActivateActCtxSuccess)
                __leave;
        }
        proc = IsolationAwarePrivatezltRgCebPnQQeRff(&c, &m, pszProcName);
    }
    __finally
    {
        if (
#ifdef _M_IX86
            !IsolationAwarePrivateT_SqbjaYRiRY &&
#endif
            fActivateActCtxSuccess)
        {
            const DWORD dwLastError = (proc == NULL) ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (proc == NULL)
                SetLastError(dwLastError);
        }
    }
    return proc;
}

#endif /* ISOLATION_AWARE_USE_STATIC_LIBRARY */

#define CreatePropertySheetPageA IsolationAwareCreatePropertySheetPageA
#define CreatePropertySheetPageW IsolationAwareCreatePropertySheetPageW
#define DestroyPropertySheetPage IsolationAwareDestroyPropertySheetPage
#define PropertySheetA IsolationAwarePropertySheetA
#define PropertySheetW IsolationAwarePropertySheetW

#endif /* ISOLATION_AWARE_ENABLED */
#endif /* RC */


#if defined(__cplusplus)
} /* __cplusplus */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\PshPack1.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack1.h

Abstract:

    This file turns 1 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 && !defined(_M_I86)) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push,1)
#else
#pragma pack(1)
#endif
#else
#pragma pack(1)
#endif
#endif // ! (defined(lint) || defined(RC_INVOKED))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\Psapi.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1994-1999  Microsoft Corporation

Module Name:

    psapi.h

Abstract:

    Include file for APIs provided by PSAPI.DLL

Author:

    Richard Shupak   [richards]  06-Jan-1994

Revision History:

--*/

#ifndef _PSAPI_H_
#define _PSAPI_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define LIST_MODULES_DEFAULT 0x0  // This is the default one app would get without any flag.
#define LIST_MODULES_32BIT   0x01  // list 32bit modules in the target process.
#define LIST_MODULES_64BIT   0x02  // list all 64bit modules. 32bit exe will be stripped off.

// list all the modules
#define LIST_MODULES_ALL   (LIST_MODULES_32BIT | LIST_MODULES_64BIT)



BOOL
WINAPI
EnumProcesses (
    __out_bcount(cb) DWORD * lpidProcess,
    __in DWORD cb,
    __out LPDWORD lpcbNeeded
    );

BOOL
WINAPI
EnumProcessModules(
    __in  HANDLE hProcess,
    __out_bcount(cb) HMODULE *lphModule,
    __in  DWORD cb,
    __out LPDWORD lpcbNeeded
    );

BOOL
WINAPI
EnumProcessModulesEx(
    __in  HANDLE hProcess,
    __out_bcount(cb)  HMODULE *lphModule,
    __in  DWORD cb,
    __out  LPDWORD lpcbNeeded,
    __in  DWORD dwFilterFlag
    );

DWORD
WINAPI
GetModuleBaseNameA(
    __in HANDLE hProcess,
    __in_opt HMODULE hModule,
    __out_ecount(nSize) LPSTR lpBaseName,
    __in DWORD nSize
    );

DWORD
WINAPI
GetModuleBaseNameW(
    __in HANDLE hProcess,
    __in_opt HMODULE hModule,
    __out_ecount(nSize) LPWSTR lpBaseName,
    __in DWORD nSize
    );

#ifdef UNICODE
#define GetModuleBaseName  GetModuleBaseNameW
#else
#define GetModuleBaseName  GetModuleBaseNameA
#endif // !UNICODE


DWORD
WINAPI
GetModuleFileNameExA(
    __in HANDLE hProcess,
    __in_opt HMODULE hModule,
    __out_ecount(nSize) LPSTR lpFilename,
    __in DWORD nSize
    );

DWORD
WINAPI
GetModuleFileNameExW(
    __in HANDLE hProcess,
    __in_opt HMODULE hModule,
    __out_ecount(nSize) LPWSTR lpFilename,
    __in DWORD nSize
    );

#ifdef UNICODE
#define GetModuleFileNameEx  GetModuleFileNameExW
#else
#define GetModuleFileNameEx  GetModuleFileNameExA
#endif // !UNICODE


typedef struct _MODULEINFO {
    LPVOID lpBaseOfDll;
    DWORD SizeOfImage;
    LPVOID EntryPoint;
} MODULEINFO, *LPMODULEINFO;


BOOL
WINAPI
GetModuleInformation(
    __in HANDLE hProcess,
    __in HMODULE hModule,
    __out LPMODULEINFO lpmodinfo,
    __in DWORD cb
    );


BOOL
WINAPI
EmptyWorkingSet(
    __in HANDLE hProcess
    );

//
// Working set information structures. All non-specified bits are reserved.
//

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)   // unnamed struct
#pragma warning(disable:4214)   // bit fields other than int

typedef union _PSAPI_WORKING_SET_BLOCK {
    ULONG_PTR Flags;
    struct {
        ULONG_PTR Protection : 5;
        ULONG_PTR ShareCount : 3;
        ULONG_PTR Shared : 1;
        ULONG_PTR Reserved : 3;
#if defined(_WIN64)
        ULONG_PTR VirtualPage : 52;
#else
        ULONG_PTR VirtualPage : 20;
#endif
    };
} PSAPI_WORKING_SET_BLOCK, *PPSAPI_WORKING_SET_BLOCK;

typedef struct _PSAPI_WORKING_SET_INFORMATION {
    ULONG_PTR NumberOfEntries;
    PSAPI_WORKING_SET_BLOCK WorkingSetInfo[1];
} PSAPI_WORKING_SET_INFORMATION, *PPSAPI_WORKING_SET_INFORMATION;

typedef union _PSAPI_WORKING_SET_EX_BLOCK {
    ULONG_PTR Flags;
    struct {
        ULONG_PTR Valid : 1;        // The following fields are valid only if this bit is set
        ULONG_PTR ShareCount : 3;
        ULONG_PTR Win32Protection : 11;
        ULONG_PTR Shared : 1;
        ULONG_PTR Node : 6;
        ULONG_PTR Locked : 1;
        ULONG_PTR LargePage : 1;
    };
} PSAPI_WORKING_SET_EX_BLOCK, *PPSAPI_WORKING_SET_EX_BLOCK;

typedef struct _PSAPI_WORKING_SET_EX_INFORMATION {
    PVOID VirtualAddress;
    PSAPI_WORKING_SET_EX_BLOCK VirtualAttributes;
} PSAPI_WORKING_SET_EX_INFORMATION, *PPSAPI_WORKING_SET_EX_INFORMATION;

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4214)
#pragma warning(default:4201)
#endif

BOOL
WINAPI
QueryWorkingSet(
    __in HANDLE hProcess,
    __out_bcount(cb) PVOID pv,
    __in DWORD cb
    );

BOOL
WINAPI
QueryWorkingSetEx(
    __in HANDLE hProcess,
    __out_bcount(cb) PVOID pv,
    __in DWORD cb
    );

BOOL
WINAPI
InitializeProcessForWsWatch(
    __in HANDLE hProcess
    );

typedef struct _PSAPI_WS_WATCH_INFORMATION {
    LPVOID FaultingPc;
    LPVOID FaultingVa;
} PSAPI_WS_WATCH_INFORMATION, *PPSAPI_WS_WATCH_INFORMATION;

typedef struct _PSAPI_WS_WATCH_INFORMATION_EX {
    PSAPI_WS_WATCH_INFORMATION BasicInfo;
    ULONG_PTR FaultingThreadId;
    ULONG_PTR Flags;    // Reserved
} PSAPI_WS_WATCH_INFORMATION_EX, *PPSAPI_WS_WATCH_INFORMATION_EX;

BOOL
WINAPI
GetWsChanges(
    __in HANDLE hProcess,
    __out_bcount(cb) PPSAPI_WS_WATCH_INFORMATION lpWatchInfo,
    __in DWORD cb
    );

BOOL
WINAPI
GetWsChangesEx(
    __in HANDLE hProcess,
    __out_bcount_part(*cb, *cb) PPSAPI_WS_WATCH_INFORMATION_EX lpWatchInfoEx,
    __inout PDWORD cb
    );

DWORD
WINAPI
GetMappedFileNameW (
    __in HANDLE hProcess,
    __in LPVOID lpv,
    __out_ecount(nSize) LPWSTR lpFilename,
    __in DWORD nSize
    );

DWORD
WINAPI
GetMappedFileNameA (
    __in HANDLE hProcess,
    __in LPVOID lpv,
    __out_ecount(nSize) LPSTR lpFilename,
    __in DWORD nSize
    );

#ifdef UNICODE
#define GetMappedFileName  GetMappedFileNameW
#else
#define GetMappedFileName  GetMappedFileNameA
#endif // !UNICODE

BOOL
WINAPI
EnumDeviceDrivers (
    __out_bcount(cb) LPVOID *lpImageBase,
    __in DWORD cb,
    __out LPDWORD lpcbNeeded
    );


DWORD
WINAPI
GetDeviceDriverBaseNameA (
    __in LPVOID ImageBase,
    __out_ecount(nSize) LPSTR lpFilename,
    __in DWORD nSize
    );

DWORD
WINAPI
GetDeviceDriverBaseNameW (
    __in LPVOID ImageBase,
    __out_ecount(nSize) LPWSTR lpBaseName,
    __in DWORD nSize
    );

#ifdef UNICODE
#define GetDeviceDriverBaseName  GetDeviceDriverBaseNameW
#else
#define GetDeviceDriverBaseName  GetDeviceDriverBaseNameA
#endif // !UNICODE


DWORD
WINAPI
GetDeviceDriverFileNameA (
    __in LPVOID ImageBase,
    __out_ecount(nSize) LPSTR lpFilename,
    __in DWORD nSize
    );

DWORD
WINAPI
GetDeviceDriverFileNameW (
    __in LPVOID ImageBase,
    __out_ecount(nSize) LPWSTR lpFilename,
    __in DWORD nSize
    );

#ifdef UNICODE
#define GetDeviceDriverFileName  GetDeviceDriverFileNameW
#else
#define GetDeviceDriverFileName  GetDeviceDriverFileNameA
#endif // !UNICODE

// Structure for GetProcessMemoryInfo()

typedef struct _PROCESS_MEMORY_COUNTERS {
    DWORD cb;
    DWORD PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
} PROCESS_MEMORY_COUNTERS;
typedef PROCESS_MEMORY_COUNTERS *PPROCESS_MEMORY_COUNTERS;

#if (_WIN32_WINNT >= 0x0501)

typedef struct _PROCESS_MEMORY_COUNTERS_EX {
    DWORD cb;
    DWORD PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivateUsage;
} PROCESS_MEMORY_COUNTERS_EX;
typedef PROCESS_MEMORY_COUNTERS_EX *PPROCESS_MEMORY_COUNTERS_EX;

#endif

BOOL
WINAPI
GetProcessMemoryInfo(
    HANDLE Process,
    PPROCESS_MEMORY_COUNTERS ppsmemCounters,
    DWORD cb
    );

typedef struct _PERFORMANCE_INFORMATION {
    DWORD cb;
    SIZE_T CommitTotal;
    SIZE_T CommitLimit;
    SIZE_T CommitPeak;
    SIZE_T PhysicalTotal;
    SIZE_T PhysicalAvailable;
    SIZE_T SystemCache;
    SIZE_T KernelTotal;
    SIZE_T KernelPaged;
    SIZE_T KernelNonpaged;
    SIZE_T PageSize;
    DWORD HandleCount;
    DWORD ProcessCount;
    DWORD ThreadCount;
} PERFORMANCE_INFORMATION, *PPERFORMANCE_INFORMATION, PERFORMACE_INFORMATION, *PPERFORMACE_INFORMATION;

BOOL
WINAPI
GetPerformanceInfo (
    PPERFORMANCE_INFORMATION pPerformanceInformation,
    DWORD cb
    );

typedef struct _ENUM_PAGE_FILE_INFORMATION {
    DWORD cb;
    DWORD Reserved;
    SIZE_T TotalSize;
    SIZE_T TotalInUse;
    SIZE_T PeakUsage;
} ENUM_PAGE_FILE_INFORMATION, *PENUM_PAGE_FILE_INFORMATION;

typedef BOOL (*PENUM_PAGE_FILE_CALLBACKW) (LPVOID pContext, PENUM_PAGE_FILE_INFORMATION pPageFileInfo, LPCWSTR lpFilename);

typedef BOOL (*PENUM_PAGE_FILE_CALLBACKA) (LPVOID pContext, PENUM_PAGE_FILE_INFORMATION pPageFileInfo, LPCSTR lpFilename);

BOOL
WINAPI
EnumPageFilesW (
    PENUM_PAGE_FILE_CALLBACKW pCallBackRoutine,
    LPVOID pContext
    );

BOOL
WINAPI
EnumPageFilesA (
    PENUM_PAGE_FILE_CALLBACKA pCallBackRoutine,
    LPVOID pContext
    );

#ifdef UNICODE
#define PENUM_PAGE_FILE_CALLBACK PENUM_PAGE_FILE_CALLBACKW
#define EnumPageFiles EnumPageFilesW
#else
#define PENUM_PAGE_FILE_CALLBACK PENUM_PAGE_FILE_CALLBACKA
#define EnumPageFiles EnumPageFilesA
#endif // !UNICODE

DWORD
WINAPI
GetProcessImageFileNameA (
    __in HANDLE hProcess,
    __out_ecount(nSize) LPSTR lpImageFileName,
    __in DWORD nSize
    );

DWORD
WINAPI
GetProcessImageFileNameW (
    __in HANDLE hProcess,
    __out_ecount(nSize) LPWSTR lpImageFileName,
    __in DWORD nSize
    );

#ifdef UNICODE
#define GetProcessImageFileName  GetProcessImageFileNameW
#else
#define GetProcessImageFileName  GetProcessImageFileNameA
#endif // !UNICODE

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\PrSht.h ===
/*****************************************************************************\
*                                                                             *
* prsht.h - - Interface for the Windows Property Sheet Pages                  *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/

#ifndef _PRSHT_H_
#define _PRSHT_H_


//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINCOMMCTRLAPI
#if !defined(_COMCTL32_) && defined(_WIN32)
#define WINCOMMCTRLAPI DECLSPEC_IMPORT
#else
#define WINCOMMCTRLAPI
#endif
#endif // WINCOMMCTRLAPI

//
// For compilers that don't support nameless unions
//
#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME   u
#define DUMMYUNIONNAME2  u2
#define DUMMYUNIONNAME3  u3
#define DUMMYUNIONNAME4  u4
#define DUMMYUNIONNAME5  u5
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#define DUMMYUNIONNAME4
#define DUMMYUNIONNAME5
#endif
#endif // DUMMYUNIONNAME

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(push)
#pragma warning(disable:4201) /* nonstandard extension used : nameless struct/union */
#endif


#ifdef _WIN64
#include <pshpack8.h>
#else
#include <pshpack4.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif


#ifndef SNDMSG
#ifdef __cplusplus
#ifndef _MAC
#define SNDMSG ::SendMessage
#else
#define SNDMSG ::AfxSendMessage
#endif
#else
#ifndef _MAC
#define SNDMSG SendMessage
#else
#define SNDMSG AfxSendMessage
#endif
#endif
#endif // ifndef SNDMSG

#ifndef PSTMSG
#ifdef __cplusplus
#define PSTMSG ::PostMessage
#else
#define PSTMSG PostMessage
#endif
#endif // ifndef PSTMSG

#define MAXPROPPAGES            100

struct _PSP;
typedef struct _PSP * HPROPSHEETPAGE;

#ifndef MIDL_PASS
struct _PROPSHEETPAGEA;
struct _PROPSHEETPAGEW;
#endif

typedef UINT (CALLBACK *LPFNPSPCALLBACKA)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEA *ppsp);
typedef UINT (CALLBACK *LPFNPSPCALLBACKW)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEW *ppsp);

#ifdef UNICODE
#define LPFNPSPCALLBACK         LPFNPSPCALLBACKW
#else
#define LPFNPSPCALLBACK         LPFNPSPCALLBACKA
#endif

#define PSP_DEFAULT                0x00000000
#define PSP_DLGINDIRECT            0x00000001
#define PSP_USEHICON               0x00000002
#define PSP_USEICONID              0x00000004
#define PSP_USETITLE               0x00000008
#define PSP_RTLREADING             0x00000010

#define PSP_HASHELP                0x00000020
#define PSP_USEREFPARENT           0x00000040
#define PSP_USECALLBACK            0x00000080
#define PSP_PREMATURE              0x00000400

#if (_WIN32_IE >= 0x0400)
//----- New flags for wizard97 --------------
#define PSP_HIDEHEADER             0x00000800
#define PSP_USEHEADERTITLE         0x00001000
#define PSP_USEHEADERSUBTITLE      0x00002000
//-------------------------------------------
#endif
#if (_WIN32_WINNT >= 0x0501) || ISOLATION_AWARE_ENABLED
#define PSP_USEFUSIONCONTEXT       0x00004000
#endif


#if (_WIN32_IE >= 0x0500)
#define PSPCB_ADDREF            0
#endif
#define PSPCB_RELEASE           1
#define PSPCB_CREATE            2

#ifdef _WIN32
typedef LPCDLGTEMPLATE PROPSHEETPAGE_RESOURCE;
#else
typedef const VOID* PROPSHEETPAGE_RESOURCE;
#endif

#define PROPSHEETPAGEA_V1_FIELDS   \
    DWORD           dwSize;        \
    DWORD           dwFlags;       \
    HINSTANCE       hInstance;     \
    union                          \
    {                              \
        LPCSTR      pszTemplate;   \
        PROPSHEETPAGE_RESOURCE pResource; \
    } DUMMYUNIONNAME;              \
    union                          \
    {                              \
        HICON        hIcon;        \
        LPCSTR       pszIcon;      \
    } DUMMYUNIONNAME2;             \
    LPCSTR           pszTitle;     \
    DLGPROC          pfnDlgProc;   \
    LPARAM           lParam;       \
    LPFNPSPCALLBACKA pfnCallback;  \
    UINT             *pcRefParent; \

#define PROPSHEETPAGEW_V1_FIELDS   \
    DWORD           dwSize;        \
    DWORD           dwFlags;       \
    HINSTANCE       hInstance;     \
    union                          \
    {                              \
        LPCWSTR     pszTemplate;   \
        PROPSHEETPAGE_RESOURCE pResource; \
    } DUMMYUNIONNAME;              \
    union                          \
    {                              \
        HICON        hIcon;        \
        LPCWSTR      pszIcon;      \
    } DUMMYUNIONNAME2;             \
    LPCWSTR          pszTitle;     \
    DLGPROC          pfnDlgProc;   \
    LPARAM           lParam;       \
    LPFNPSPCALLBACKW pfnCallback;  \
    UINT             *pcRefParent; \

#if _WIN32_WINNT >= 0x0600
#define  _PROPSHEETPAGEA_V4 _PROPSHEETPAGEA
#define  _PROPSHEETPAGEW_V4 _PROPSHEETPAGEW
#elif (_WIN32_WINNT >= 0x0501) || ISOLATION_AWARE_ENABLED
#define  _PROPSHEETPAGEA_V3 _PROPSHEETPAGEA
#define  _PROPSHEETPAGEW_V3 _PROPSHEETPAGEW
#elif (_WIN32_IE >= 0x0400)
#define  _PROPSHEETPAGEA_V2 _PROPSHEETPAGEA
#define  _PROPSHEETPAGEW_V2 _PROPSHEETPAGEW
#else
#define  _PROPSHEETPAGEA_V1 _PROPSHEETPAGEA
#define  _PROPSHEETPAGEW_V1 _PROPSHEETPAGEW
#endif

typedef struct _PROPSHEETPAGEA_V1
{
    PROPSHEETPAGEA_V1_FIELDS
} PROPSHEETPAGEA_V1, *LPPROPSHEETPAGEA_V1;
typedef const PROPSHEETPAGEA_V1 *LPCPROPSHEETPAGEA_V1;

typedef struct _PROPSHEETPAGEA_V2
{
    PROPSHEETPAGEA_V1_FIELDS

    LPCSTR           pszHeaderTitle;    // this is displayed in the header
    LPCSTR           pszHeaderSubTitle; //
} PROPSHEETPAGEA_V2, *LPPROPSHEETPAGEA_V2;
typedef const PROPSHEETPAGEA_V2 *LPCPROPSHEETPAGEA_V2;

typedef struct _PROPSHEETPAGEA_V3
{
    PROPSHEETPAGEA_V1_FIELDS

    LPCSTR           pszHeaderTitle;    // this is displayed in the header
    LPCSTR           pszHeaderSubTitle; //

    HANDLE           hActCtx;
} PROPSHEETPAGEA_V3, *LPPROPSHEETPAGEA_V3;
typedef const PROPSHEETPAGEA_V3 *LPCPROPSHEETPAGEA_V3;

#if _WIN32_WINNT >= 0x0600
typedef struct _PROPSHEETPAGEA_V4
{
    PROPSHEETPAGEA_V1_FIELDS

    LPCSTR           pszHeaderTitle;    // this is displayed in the header
    LPCSTR           pszHeaderSubTitle; //

    HANDLE           hActCtx;

    union 
    {
        HBITMAP     hbmHeader;
        LPCSTR      pszbmHeader;
    } DUMMYUNIONNAME3;

} PROPSHEETPAGEA_V4, *LPPROPSHEETPAGEA_V4;
typedef const PROPSHEETPAGEA_V4 *LPCPROPSHEETPAGEA_V4;
#endif

typedef struct _PROPSHEETPAGEW_V1
{
    PROPSHEETPAGEW_V1_FIELDS
} PROPSHEETPAGEW_V1, *LPPROPSHEETPAGEW_V1;
typedef const PROPSHEETPAGEW_V1 *LPCPROPSHEETPAGEW_V1;

typedef struct _PROPSHEETPAGEW_V2
{
    PROPSHEETPAGEW_V1_FIELDS

    LPCWSTR           pszHeaderTitle;    // this is displayed in the header
    LPCWSTR           pszHeaderSubTitle; //
} PROPSHEETPAGEW_V2, *LPPROPSHEETPAGEW_V2;
typedef const PROPSHEETPAGEW_V2 *LPCPROPSHEETPAGEW_V2;

typedef struct _PROPSHEETPAGEW_V3
{
    PROPSHEETPAGEW_V1_FIELDS

    LPCWSTR           pszHeaderTitle;    // this is displayed in the header
    LPCWSTR           pszHeaderSubTitle; //

    HANDLE           hActCtx;
} PROPSHEETPAGEW_V3, *LPPROPSHEETPAGEW_V3;
typedef const PROPSHEETPAGEW_V3 *LPCPROPSHEETPAGEW_V3;

#if _WIN32_WINNT >= 0x0600
typedef struct _PROPSHEETPAGEW_V4
{
    PROPSHEETPAGEW_V1_FIELDS

    LPCWSTR           pszHeaderTitle;    // this is displayed in the header
    LPCWSTR           pszHeaderSubTitle; //

    HANDLE            hActCtx;

    union 
    {
        HBITMAP     hbmHeader;
        LPCWSTR     pszbmHeader;
    } DUMMYUNIONNAME3;

} PROPSHEETPAGEW_V4, *LPPROPSHEETPAGEW_V4;
typedef const PROPSHEETPAGEW_V4 *LPCPROPSHEETPAGEW_V4;
#endif

#define PROPSHEETPAGEA_V1_SIZE sizeof(PROPSHEETPAGEA_V1)
#define PROPSHEETPAGEW_V1_SIZE sizeof(PROPSHEETPAGEW_V1)

#define PROPSHEETPAGEA_V2_SIZE sizeof(PROPSHEETPAGEA_V2)
#define PROPSHEETPAGEW_V2_SIZE sizeof(PROPSHEETPAGEW_V2)

#define PROPSHEETPAGEA_V3_SIZE sizeof(PROPSHEETPAGEA_V3)
#define PROPSHEETPAGEW_V3_SIZE sizeof(PROPSHEETPAGEW_V3)

#if _WIN32_WINNT >= 0x0600
#define PROPSHEETPAGEA_V4_SIZE sizeof(PROPSHEETPAGEA_V4)
#define PROPSHEETPAGEW_V4_SIZE sizeof(PROPSHEETPAGEW_V4)
#endif


#if _WIN32_WINNT >= 0x0600
typedef    PROPSHEETPAGEA_V4    PROPSHEETPAGEA_LATEST;
typedef    PROPSHEETPAGEW_V4    PROPSHEETPAGEW_LATEST;
typedef  LPPROPSHEETPAGEA_V4  LPPROPSHEETPAGEA_LATEST;
typedef  LPPROPSHEETPAGEW_V4  LPPROPSHEETPAGEW_LATEST;
typedef LPCPROPSHEETPAGEA_V4 LPCPROPSHEETPAGEA_LATEST;
typedef LPCPROPSHEETPAGEW_V4 LPCPROPSHEETPAGEW_LATEST;
#else
typedef    PROPSHEETPAGEA_V3    PROPSHEETPAGEA_LATEST;
typedef    PROPSHEETPAGEW_V3    PROPSHEETPAGEW_LATEST;
typedef  LPPROPSHEETPAGEA_V3  LPPROPSHEETPAGEA_LATEST;
typedef  LPPROPSHEETPAGEW_V3  LPPROPSHEETPAGEW_LATEST;
typedef LPCPROPSHEETPAGEA_V3 LPCPROPSHEETPAGEA_LATEST;
typedef LPCPROPSHEETPAGEW_V3 LPCPROPSHEETPAGEW_LATEST;
#endif


#if _WIN32_WINNT >= 0x0600
typedef    PROPSHEETPAGEA_V4    PROPSHEETPAGEA;
typedef    PROPSHEETPAGEW_V4    PROPSHEETPAGEW;
typedef  LPPROPSHEETPAGEA_V4  LPPROPSHEETPAGEA;
typedef  LPPROPSHEETPAGEW_V4  LPPROPSHEETPAGEW;
typedef LPCPROPSHEETPAGEA_V4 LPCPROPSHEETPAGEA;
typedef LPCPROPSHEETPAGEW_V4 LPCPROPSHEETPAGEW;
#elif (_WIN32_WINNT >= 0x0501) || ISOLATION_AWARE_ENABLED
typedef    PROPSHEETPAGEA_V3    PROPSHEETPAGEA;
typedef    PROPSHEETPAGEW_V3    PROPSHEETPAGEW;
typedef  LPPROPSHEETPAGEA_V3  LPPROPSHEETPAGEA;
typedef  LPPROPSHEETPAGEW_V3  LPPROPSHEETPAGEW;
typedef LPCPROPSHEETPAGEA_V3 LPCPROPSHEETPAGEA;
typedef LPCPROPSHEETPAGEW_V3 LPCPROPSHEETPAGEW;
#elif (_WIN32_IE >= 0x0400)
typedef    PROPSHEETPAGEA_V2    PROPSHEETPAGEA;
typedef    PROPSHEETPAGEW_V2    PROPSHEETPAGEW;
typedef  LPPROPSHEETPAGEA_V2  LPPROPSHEETPAGEA;
typedef  LPPROPSHEETPAGEW_V2  LPPROPSHEETPAGEW;
typedef LPCPROPSHEETPAGEA_V2 LPCPROPSHEETPAGEA;
typedef LPCPROPSHEETPAGEW_V2 LPCPROPSHEETPAGEW;
#else
typedef    PROPSHEETPAGEA_V1    PROPSHEETPAGEA;
typedef    PROPSHEETPAGEW_V1    PROPSHEETPAGEW;
typedef  LPPROPSHEETPAGEA_V1  LPPROPSHEETPAGEA;
typedef  LPPROPSHEETPAGEW_V1  LPPROPSHEETPAGEW;
typedef LPCPROPSHEETPAGEA_V1 LPCPROPSHEETPAGEA;
typedef LPCPROPSHEETPAGEW_V1 LPCPROPSHEETPAGEW;
#endif

#if 0 // IEUNIX reserved.
/* Macros for the missing definitions.  */
/* Not all, because mostly used in C++. */
#if __STDC__ || defined(NONAMELESSUNION)
#   define PSP_pszTemplate(X) ((X).u.pszTemplate)
#else
#   define PSP_pszTemplate(X) ((X).pszTemplate)
#endif
#endif

#ifdef UNICODE
#define    PROPSHEETPAGE           PROPSHEETPAGEW
#define  LPPROPSHEETPAGE         LPPROPSHEETPAGEW
#define LPCPROPSHEETPAGE        LPCPROPSHEETPAGEW
#define    PROPSHEETPAGE_V1_SIZE   PROPSHEETPAGEW_V1_SIZE
#define    PROPSHEETPAGE_V2_SIZE   PROPSHEETPAGEW_V2_SIZE
#define    PROPSHEETPAGE_V1        PROPSHEETPAGEW_V1
#define  LPPROPSHEETPAGE_V1      LPPROPSHEETPAGEW_V1
#define LPCPROPSHEETPAGE_V1     LPCPROPSHEETPAGEW_V1
#define    PROPSHEETPAGE_V2        PROPSHEETPAGEW_V2
#define  LPPROPSHEETPAGE_V2      LPPROPSHEETPAGEW_V2
#define LPCPROPSHEETPAGE_V2     LPCPROPSHEETPAGEW_V2
#define    PROPSHEETPAGE_V3        PROPSHEETPAGEW_V3
#define  LPPROPSHEETPAGE_V3      LPPROPSHEETPAGEW_V3
#define LPCPROPSHEETPAGE_V3     LPCPROPSHEETPAGEW_V3
#if _WIN32_WINNT >= 0x0600
#define    PROPSHEETPAGE_V4        PROPSHEETPAGEW_V4
#define  LPPROPSHEETPAGE_V4      LPPROPSHEETPAGEW_V4
#define LPCPROPSHEETPAGE_V4     LPCPROPSHEETPAGEW_V4
#endif
#define    PROPSHEETPAGE_LATEST    PROPSHEETPAGEW_LATEST
#define  LPPROPSHEETPAGE_LATEST  LPPROPSHEETPAGEW_LATEST
#define LPCPROPSHEETPAGE_LATEST LPCPROPSHEETPAGEW_LATEST
#else
#define    PROPSHEETPAGE           PROPSHEETPAGEA
#define  LPPROPSHEETPAGE         LPPROPSHEETPAGEA
#define LPCPROPSHEETPAGE        LPCPROPSHEETPAGEA
#define    PROPSHEETPAGE_V1_SIZE   PROPSHEETPAGEA_V1_SIZE
#define    PROPSHEETPAGE_V2_SIZE   PROPSHEETPAGEA_V2_SIZE
#define    PROPSHEETPAGE_V1        PROPSHEETPAGEA_V1
#define  LPPROPSHEETPAGE_V1      LPPROPSHEETPAGEA_V1
#define LPCPROPSHEETPAGE_V1     LPCPROPSHEETPAGEA_V1
#define    PROPSHEETPAGE_V2        PROPSHEETPAGEA_V2
#define  LPPROPSHEETPAGE_V2      LPPROPSHEETPAGEA_V2
#define LPCPROPSHEETPAGE_V2     LPCPROPSHEETPAGEA_V2
#define    PROPSHEETPAGE_V3        PROPSHEETPAGEA_V3
#define  LPPROPSHEETPAGE_V3      LPPROPSHEETPAGEA_V3
#define LPCPROPSHEETPAGE_V3     LPCPROPSHEETPAGEA_V3
#if _WIN32_WINNT >= 0x0600
#define    PROPSHEETPAGE_V4        PROPSHEETPAGEA_V4
#define  LPPROPSHEETPAGE_V4      LPPROPSHEETPAGEA_V4
#define LPCPROPSHEETPAGE_V4     LPCPROPSHEETPAGEA_V4
#endif
#define    PROPSHEETPAGE_LATEST    PROPSHEETPAGEA_LATEST
#define  LPPROPSHEETPAGE_LATEST  LPPROPSHEETPAGEA_LATEST
#define LPCPROPSHEETPAGE_LATEST LPCPROPSHEETPAGEA_LATEST
#endif


//----- PropSheet Header related ---------

#define PSH_DEFAULT             0x00000000
#define PSH_PROPTITLE           0x00000001
#define PSH_USEHICON            0x00000002
#define PSH_USEICONID           0x00000004
#define PSH_PROPSHEETPAGE       0x00000008

#define PSH_WIZARDHASFINISH     0x00000010
#define PSH_WIZARD              0x00000020
#define PSH_USEPSTARTPAGE       0x00000040
#define PSH_NOAPPLYNOW          0x00000080

#define PSH_USECALLBACK         0x00000100
#define PSH_HASHELP             0x00000200
#define PSH_MODELESS            0x00000400
#define PSH_RTLREADING          0x00000800

#define PSH_WIZARDCONTEXTHELP   0x00001000

#if (_WIN32_IE >= 0x0400)
//----- New flags for wizard97 -----------
#if (_WIN32_IE < 0x0500)
#define PSH_WIZARD97            0x00002000
#else
#define PSH_WIZARD97            0x01000000
#endif
#define PSH_WATERMARK           0x00008000

#define PSH_USEHBMWATERMARK     0x00010000  // user pass in a hbmWatermark instead of pszbmWatermark
#define PSH_USEHPLWATERMARK     0x00020000  //
#define PSH_STRETCHWATERMARK    0x00040000  // stretchwatermark also applies for the header
#define PSH_HEADER              0x00080000

#define PSH_USEHBMHEADER        0x00100000
#define PSH_USEPAGELANG         0x00200000  // use frame dialog template matched to page
//----------------------------------------
#endif

#if (_WIN32_IE >= 0x0500)
//----- New flags for wizard-lite --------
#define PSH_WIZARD_LITE         0x00400000
#define PSH_NOCONTEXTHELP       0x02000000
//----------------------------------------
#endif


#if _WIN32_WINNT >= 0x0600
#define PSH_AEROWIZARD                          0x00004000

#define PSH_RESIZABLE                           0x04000000
#define PSH_HEADERBITMAP                        0x08000000
#define PSH_NOMARGIN                            0x10000000
#endif



typedef int (CALLBACK *PFNPROPSHEETCALLBACK)(HWND, UINT, LPARAM);

#define PROPSHEETHEADERA_V1_FIELDS      \
        DWORD           dwSize;         \
        DWORD           dwFlags;        \
        HWND            hwndParent;     \
        HINSTANCE       hInstance;      \
        union                           \
        {                               \
            HICON       hIcon;          \
            LPCSTR      pszIcon;        \
        } DUMMYUNIONNAME;               \
        LPCSTR          pszCaption;     \
        UINT            nPages;         \
        union                           \
        {                               \
            UINT        nStartPage;     \
            LPCSTR      pStartPage;     \
        } DUMMYUNIONNAME2;              \
        union                           \
        {                               \
            LPCPROPSHEETPAGEA ppsp;     \
            HPROPSHEETPAGE *phpage;     \
        } DUMMYUNIONNAME3;              \
        PFNPROPSHEETCALLBACK pfnCallback;   

typedef struct _PROPSHEETHEADERA_V1
{
    PROPSHEETHEADERA_V1_FIELDS
} PROPSHEETHEADERA_V1, *LPPROPSHEETHEADERA_V1;
typedef const PROPSHEETHEADERA_V1 *LPCPROPSHEETHEADERA_V1;

#if (_WIN32_IE >= 0x0400)
typedef struct _PROPSHEETHEADERA_V2
{
    PROPSHEETHEADERA_V1_FIELDS
    union 
    {
        HBITMAP hbmWatermark;
        LPCSTR pszbmWatermark;
    } DUMMYUNIONNAME4;
    HPALETTE hplWatermark;
    union 
    {
        HBITMAP hbmHeader;     // Header  bitmap shares the palette with watermark
        LPCSTR pszbmHeader;
    } DUMMYUNIONNAME5;
} PROPSHEETHEADERA_V2, *LPPROPSHEETHEADERA_V2;
typedef const PROPSHEETHEADERA_V2 *LPCPROPSHEETHEADERA_V2;
#endif

#define PROPSHEETHEADERW_V1_FIELDS      \
        DWORD           dwSize;         \
        DWORD           dwFlags;        \
        HWND            hwndParent;     \
        HINSTANCE       hInstance;      \
        union                           \
        {                               \
            HICON       hIcon;          \
            LPCWSTR     pszIcon;        \
        } DUMMYUNIONNAME;               \
        LPCWSTR         pszCaption;     \
        UINT            nPages;         \
        union                           \
        {                               \
            UINT        nStartPage;     \
            LPCWSTR     pStartPage;     \
        } DUMMYUNIONNAME2;              \
        union                           \
        {                               \
            LPCPROPSHEETPAGEW ppsp;     \
            HPROPSHEETPAGE *phpage;     \
        } DUMMYUNIONNAME3;              \
        PFNPROPSHEETCALLBACK pfnCallback;  

typedef struct _PROPSHEETHEADERW_V1
{
    PROPSHEETHEADERW_V1_FIELDS
} PROPSHEETHEADERW_V1, *LPPROPSHEETHEADERW_V1;
typedef const PROPSHEETHEADERW_V1 *LPCPROPSHEETHEADERW_V1;

#if (_WIN32_IE >= 0x0400)
typedef struct _PROPSHEETHEADERW_V2
{
    PROPSHEETHEADERW_V1_FIELDS
    union 
    {
        HBITMAP hbmWatermark;
        LPCWSTR pszbmWatermark;
    } DUMMYUNIONNAME4;
    HPALETTE hplWatermark;
    union 
    {
        HBITMAP hbmHeader;     // Header  bitmap shares the palette with watermark
        LPCWSTR pszbmHeader;
    } DUMMYUNIONNAME5;
} PROPSHEETHEADERW_V2, *LPPROPSHEETHEADERW_V2;
typedef const PROPSHEETHEADERW_V2 *LPCPROPSHEETHEADERW_V2;
#endif

#define PROPSHEETHEADERA_V1_SIZE sizeof(PROPSHEETHEADERA_V1)
#define PROPSHEETHEADERW_V1_SIZE sizeof(PROPSHEETHEADERW_V1)

#if (_WIN32_IE >= 0x400)
#define PROPSHEETHEADERA_V2_SIZE sizeof(PROPSHEETHEADERA_V2)
#define PROPSHEETHEADERW_V2_SIZE sizeof(PROPSHEETHEADERW_V2)
#endif


#if 0 //IEUNIX reserved.
/* Macros for the missing definitions.  */
/* Not all, because mostly used in C++. */
#if __STDC__ || defined(NONAMELESSUNION)
#   define PSH_nStartPage(X) ((X).u2.nStartPage)
#   define PSH_ppsp(X)       ((X).u3.ppsp)
#else
#   define PSH_nStartPage(X) ((X).nStartPage)
#   define PSH_ppsp(X)       ((X).ppsp)
#endif
#endif

#if (_WIN32_IE >= 0x400)
#define    _PROPSHEETHEADERA        PROPSHEETHEADERA_V2;
#define    _PROPSHEETHEADERW        PROPSHEETHEADERW_V2;
typedef    PROPSHEETHEADERA_V2      PROPSHEETHEADERA;
typedef    PROPSHEETHEADERW_V2      PROPSHEETHEADERW;
typedef  LPPROPSHEETHEADERA_V2      LPPROPSHEETHEADERA;
typedef  LPPROPSHEETHEADERW_V2      LPPROPSHEETHEADERW;
typedef LPCPROPSHEETHEADERA_V2      LPCPROPSHEETHEADERA;
typedef LPCPROPSHEETHEADERW_V2      LPCPROPSHEETHEADERW;
#else
#define    _PROPSHEETHEADERA        PROPSHEETHEADERA_V1;
#define    _PROPSHEETHEADERW        PROPSHEETHEADERW_V1;
typedef    PROPSHEETHEADERA_V1      PROPSHEETHEADERA;
typedef    PROPSHEETHEADERW_V1      PROPSHEETHEADERW;
typedef  LPPROPSHEETHEADERA_V1      LPPROPSHEETHEADERA;
typedef  LPPROPSHEETHEADERW_V1      LPPROPSHEETHEADERW;
typedef LPCPROPSHEETHEADERA_V1      LPCPROPSHEETHEADERA;
typedef LPCPROPSHEETHEADERW_V1      LPCPROPSHEETHEADERW;
#endif


#ifdef UNICODE
#define PROPSHEETHEADER         PROPSHEETHEADERW
#define LPPROPSHEETHEADER       LPPROPSHEETHEADERW
#define LPCPROPSHEETHEADER      LPCPROPSHEETHEADERW
#define PROPSHEETHEADER_V1_SIZE PROPSHEETHEADERW_V1_SIZE
#if (_WIN32_IE >= 0x400)
#define PROPSHEETHEADER_V2_SIZE PROPSHEETHEADERW_V2_SIZE
#endif
#else
#define PROPSHEETHEADER         PROPSHEETHEADERA
#define LPPROPSHEETHEADER       LPPROPSHEETHEADERA
#define LPCPROPSHEETHEADER      LPCPROPSHEETHEADERA
#define PROPSHEETHEADER_V1_SIZE PROPSHEETHEADERA_V1_SIZE
#if (_WIN32_IE >= 0x400)
#define PROPSHEETHEADER_V2_SIZE PROPSHEETHEADERA_V2_SIZE
#endif
#endif


#define PSCB_INITIALIZED  1
#define PSCB_PRECREATE    2

#if (_WIN32_IE >= 0x560)
// PSCB_BUTTONPRESSED will be sent when the user clicks a button in the
// property dialog (OK, Cancel, Apply, or Close).  The message will be sent
// to PROPSHEETHEADER's pfnCallback if the PSH_USECALLBACK flag was specified.
// The LPARAM will be equal to one of the following based on the button pressed:
// This message is only supported on comctl32 v6.
// PSBTN_FINISH (Close), PSBTN_OK, PSBTN_APPLYNOW, or PSBTN_CANCEL

#define PSCB_BUTTONPRESSED 3
#endif  // _WIN32_IE >= 0x560


WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreatePropertySheetPageA(LPCPROPSHEETPAGEA constPropSheetPagePointer);
WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreatePropertySheetPageW(LPCPROPSHEETPAGEW constPropSheetPagePointer);
WINCOMMCTRLAPI BOOL           WINAPI DestroyPropertySheetPage(HPROPSHEETPAGE);

WINCOMMCTRLAPI INT_PTR        WINAPI PropertySheetA(LPCPROPSHEETHEADERA);

WINCOMMCTRLAPI INT_PTR        WINAPI PropertySheetW(LPCPROPSHEETHEADERW);

#ifdef UNICODE
#define CreatePropertySheetPage  CreatePropertySheetPageW
#define PropertySheet            PropertySheetW
#else
#define CreatePropertySheetPage  CreatePropertySheetPageA
#define PropertySheet            PropertySheetA
#endif



typedef BOOL (CALLBACK *LPFNADDPROPSHEETPAGE)(HPROPSHEETPAGE, LPARAM);
typedef BOOL (CALLBACK *LPFNADDPROPSHEETPAGES)(LPVOID, LPFNADDPROPSHEETPAGE, LPARAM);


typedef struct _PSHNOTIFY
{
    NMHDR hdr;
    LPARAM lParam;
} PSHNOTIFY, *LPPSHNOTIFY;

#define PSN_FIRST               (0U-200U)
#define PSN_LAST                (0U-299U)


#define PSN_SETACTIVE           (PSN_FIRST-0)
#define PSN_KILLACTIVE          (PSN_FIRST-1)
// #define PSN_VALIDATE            (PSN_FIRST-1)
#define PSN_APPLY               (PSN_FIRST-2)
#define PSN_RESET               (PSN_FIRST-3)
// #define PSN_CANCEL              (PSN_FIRST-3)
#define PSN_HELP                (PSN_FIRST-5)
#define PSN_WIZBACK             (PSN_FIRST-6)
#define PSN_WIZNEXT             (PSN_FIRST-7)
#define PSN_WIZFINISH           (PSN_FIRST-8)
#define PSN_QUERYCANCEL         (PSN_FIRST-9)
#if (_WIN32_IE >= 0x0400)
#define PSN_GETOBJECT           (PSN_FIRST-10)
#endif // 0x0400
#if (_WIN32_IE >= 0x0500)
#define PSN_TRANSLATEACCELERATOR (PSN_FIRST-12)
#define PSN_QUERYINITIALFOCUS   (PSN_FIRST-13)
#endif // 0x0500

#define PSNRET_NOERROR              0
#define PSNRET_INVALID              1
#define PSNRET_INVALID_NOCHANGEPAGE 2
#define PSNRET_MESSAGEHANDLED       3

#define PSM_SETCURSEL           (WM_USER + 101)
#define PropSheet_SetCurSel(hDlg, hpage, index) \
        SNDMSG(hDlg, PSM_SETCURSEL, (WPARAM)(index), (LPARAM)(hpage))


#define PSM_REMOVEPAGE          (WM_USER + 102)
#define PropSheet_RemovePage(hDlg, index, hpage) \
        SNDMSG(hDlg, PSM_REMOVEPAGE, index, (LPARAM)(hpage))


#define PSM_ADDPAGE             (WM_USER + 103)
#define PropSheet_AddPage(hDlg, hpage) \
        SNDMSG(hDlg, PSM_ADDPAGE, 0, (LPARAM)(hpage))


#define PSM_CHANGED             (WM_USER + 104)
#define PropSheet_Changed(hDlg, hwnd) \
        SNDMSG(hDlg, PSM_CHANGED, (WPARAM)(hwnd), 0L)


#define PSM_RESTARTWINDOWS      (WM_USER + 105)
#define PropSheet_RestartWindows(hDlg) \
        SNDMSG(hDlg, PSM_RESTARTWINDOWS, 0, 0L)


#define PSM_REBOOTSYSTEM        (WM_USER + 106)
#define PropSheet_RebootSystem(hDlg) \
        SNDMSG(hDlg, PSM_REBOOTSYSTEM, 0, 0L)


#define PSM_CANCELTOCLOSE       (WM_USER + 107)
#define PropSheet_CancelToClose(hDlg) \
        PostMessage(hDlg, PSM_CANCELTOCLOSE, 0, 0L)


#define PSM_QUERYSIBLINGS       (WM_USER + 108)
#define PropSheet_QuerySiblings(hDlg, wParam, lParam) \
        SNDMSG(hDlg, PSM_QUERYSIBLINGS, wParam, lParam)


#define PSM_UNCHANGED           (WM_USER + 109)
#define PropSheet_UnChanged(hDlg, hwnd) \
        SNDMSG(hDlg, PSM_UNCHANGED, (WPARAM)(hwnd), 0L)


#define PSM_APPLY               (WM_USER + 110)
#define PropSheet_Apply(hDlg) \
        SNDMSG(hDlg, PSM_APPLY, 0, 0L)


#define PSM_SETTITLEA           (WM_USER + 111)
#define PSM_SETTITLEW           (WM_USER + 120)


#ifdef UNICODE
#define PSM_SETTITLE            PSM_SETTITLEW
#else
#define PSM_SETTITLE            PSM_SETTITLEA
#endif

#define PropSheet_SetTitle(hDlg, wStyle, lpszText)\
        SNDMSG(hDlg, PSM_SETTITLE, wStyle, (LPARAM)(LPCTSTR)(lpszText))


#define PSM_SETWIZBUTTONS       (WM_USER + 112)
#define PropSheet_SetWizButtons(hDlg, dwFlags) \
        PostMessage(hDlg, PSM_SETWIZBUTTONS, 0, (LPARAM)(dwFlags))


#define PSWIZB_BACK             0x00000001
#define PSWIZB_NEXT             0x00000002
#define PSWIZB_FINISH           0x00000004
#define PSWIZB_DISABLEDFINISH   0x00000008

#define PSWIZBF_ELEVATIONREQUIRED   0x00000001

#if _WIN32_WINNT >= 0x0600
// Only for PSH_AEROWIZARD - used in PSM_SHOWWIZBUTTONS
#define PSWIZB_CANCEL           0x00000010
#endif // 0x0605


#define PSM_PRESSBUTTON         (WM_USER + 113)
#define PropSheet_PressButton(hDlg, iButton) \
        PostMessage(hDlg, PSM_PRESSBUTTON, (WPARAM)(iButton), 0)


#define PSBTN_BACK              0
#define PSBTN_NEXT              1
#define PSBTN_FINISH            2
#define PSBTN_OK                3
#define PSBTN_APPLYNOW          4
#define PSBTN_CANCEL            5
#define PSBTN_HELP              6
#define PSBTN_MAX               6



#define PSM_SETCURSELID         (WM_USER + 114)
#define PropSheet_SetCurSelByID(hDlg, id) \
        SNDMSG(hDlg, PSM_SETCURSELID, 0, (LPARAM)(id))


#define PSM_SETFINISHTEXTA      (WM_USER + 115)
#define PSM_SETFINISHTEXTW      (WM_USER + 121)

#ifdef UNICODE
#define PSM_SETFINISHTEXT       PSM_SETFINISHTEXTW
#else
#define PSM_SETFINISHTEXT       PSM_SETFINISHTEXTA
#endif

#define PropSheet_SetFinishText(hDlg, lpszText) \
        SNDMSG(hDlg, PSM_SETFINISHTEXT, 0, (LPARAM)(lpszText))


#define PSM_GETTABCONTROL       (WM_USER + 116)
#define PropSheet_GetTabControl(hDlg) \
        (HWND)SNDMSG(hDlg, PSM_GETTABCONTROL, 0, 0)

#define PSM_ISDIALOGMESSAGE     (WM_USER + 117)
#define PropSheet_IsDialogMessage(hDlg, pMsg) \
        (BOOL)SNDMSG(hDlg, PSM_ISDIALOGMESSAGE, 0, (LPARAM)(pMsg))

#define PSM_GETCURRENTPAGEHWND  (WM_USER + 118)
#define PropSheet_GetCurrentPageHwnd(hDlg) \
        (HWND)SNDMSG(hDlg, PSM_GETCURRENTPAGEHWND, 0, 0L)

#define PSM_INSERTPAGE          (WM_USER + 119)
#define PropSheet_InsertPage(hDlg, index, hpage) \
        SNDMSG(hDlg, PSM_INSERTPAGE, (WPARAM)(index), (LPARAM)(hpage))

#if _WIN32_WINNT >= 0x0600
// Only for PSH_AEROWIZARD - used in PSM_SETHEADERTITLE
#define PSWIZF_SETCOLOR         ((UINT)(-1))
#endif

#if (_WIN32_IE >= 0x0500)
#define PSM_SETHEADERTITLEA     (WM_USER + 125)
#define PSM_SETHEADERTITLEW     (WM_USER + 126)

#ifdef UNICODE
#define PSM_SETHEADERTITLE      PSM_SETHEADERTITLEW
#else
#define PSM_SETHEADERTITLE      PSM_SETHEADERTITLEA
#endif

#define PropSheet_SetHeaderTitle(hDlg, index, lpszText) \
        SNDMSG(hDlg, PSM_SETHEADERTITLE, (WPARAM)(index), (LPARAM)(lpszText))


#define PSM_SETHEADERSUBTITLEA     (WM_USER + 127)
#define PSM_SETHEADERSUBTITLEW     (WM_USER + 128)

#ifdef UNICODE
#define PSM_SETHEADERSUBTITLE      PSM_SETHEADERSUBTITLEW
#else
#define PSM_SETHEADERSUBTITLE      PSM_SETHEADERSUBTITLEA
#endif

#define PropSheet_SetHeaderSubTitle(hDlg, index, lpszText) \
        SNDMSG(hDlg, PSM_SETHEADERSUBTITLE, (WPARAM)(index), (LPARAM)(lpszText))

#define PSM_HWNDTOINDEX            (WM_USER + 129)
#define PropSheet_HwndToIndex(hDlg, hwnd) \
        (int)SNDMSG(hDlg, PSM_HWNDTOINDEX, (WPARAM)(hwnd), 0)

#define PSM_INDEXTOHWND            (WM_USER + 130)
#define PropSheet_IndexToHwnd(hDlg, i) \
        (HWND)SNDMSG(hDlg, PSM_INDEXTOHWND, (WPARAM)(i), 0)

#define PSM_PAGETOINDEX            (WM_USER + 131)
#define PropSheet_PageToIndex(hDlg, hpage) \
        (int)SNDMSG(hDlg, PSM_PAGETOINDEX, 0, (LPARAM)(hpage))

#define PSM_INDEXTOPAGE            (WM_USER + 132)
#define PropSheet_IndexToPage(hDlg, i) \
        (HPROPSHEETPAGE)SNDMSG(hDlg, PSM_INDEXTOPAGE, (WPARAM)(i), 0)

#define PSM_IDTOINDEX              (WM_USER + 133)
#define PropSheet_IdToIndex(hDlg, id) \
        (int)SNDMSG(hDlg, PSM_IDTOINDEX, 0, (LPARAM)(id))

#define PSM_INDEXTOID              (WM_USER + 134)
#define PropSheet_IndexToId(hDlg, i) \
        SNDMSG(hDlg, PSM_INDEXTOID, (WPARAM)(i), 0)

#define PSM_GETRESULT              (WM_USER + 135)
#define PropSheet_GetResult(hDlg) \
        SNDMSG(hDlg, PSM_GETRESULT, 0, 0)

#define PSM_RECALCPAGESIZES        (WM_USER + 136)
#define PropSheet_RecalcPageSizes(hDlg) \
        SNDMSG(hDlg, PSM_RECALCPAGESIZES, 0, 0)
#endif // 0x0500


#if _WIN32_WINNT >= 0x0600
// Only UNICODE
// These messages are only for Aero Wizard style wizards. The Wizard author
// needs to specify the PSH_AEROWIZARD flag in the dwFlags member of the PROPSHEETHEADER
// structure to get this behavior.

#define PSM_SETNEXTTEXTW          (WM_USER + 137)
#define PSM_SETNEXTTEXT           PSM_SETNEXTTEXTW

#define PropSheet_SetNextText(hDlg, lpszText) \
        SNDMSG(hDlg, PSM_SETNEXTTEXT, 0, (LPARAM)(lpszText))

#define PSWIZB_SHOW                     0
#define PSWIZB_RESTORE                  1


#define PSM_SHOWWIZBUTTONS              (WM_USER + 138)
#define PropSheet_ShowWizButtons(hDlg, dwFlag, dwButton) \
        PSTMSG(hDlg, PSM_SHOWWIZBUTTONS, (WPARAM)(dwFlag), (LPARAM)(dwButton))


#define PSM_ENABLEWIZBUTTONS            (WM_USER + 139)
#define PropSheet_EnableWizButtons(hDlg, dwState, dwMask) \
        PSTMSG(hDlg, PSM_ENABLEWIZBUTTONS, (WPARAM)(dwState), (LPARAM)(dwMask))


#define PSM_SETBUTTONTEXTW         (WM_USER + 140)
#define PSM_SETBUTTONTEXT          PSM_SETBUTTONTEXTW
#define PropSheet_SetButtonText(hDlg, dwButton, lpszText) \
        SNDMSG(hDlg, PSM_SETBUTTONTEXT, (WPARAM)(dwButton), (LPARAM)(lpszText))

#endif // 0x0600


#define ID_PSRESTARTWINDOWS     0x2
#define ID_PSREBOOTSYSTEM       (ID_PSRESTARTWINDOWS | 0x1)


#define WIZ_CXDLG               276
#define WIZ_CYDLG               140

#define WIZ_CXBMP               80

#define WIZ_BODYX               92
#define WIZ_BODYCX              184

#define PROP_SM_CXDLG           212
#define PROP_SM_CYDLG           188

#define PROP_MED_CXDLG          227
#define PROP_MED_CYDLG          215

#define PROP_LG_CXDLG           252
#define PROP_LG_CYDLG           218

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif




#if !defined(RC_INVOKED) /* RC complains about long symbols in #ifs */
#if defined(ISOLATION_AWARE_ENABLED) && (ISOLATION_AWARE_ENABLED != 0)
#include "prsht.inl"
#endif /* ISOLATION_AWARE_ENABLED */
#endif /* RC */

#ifdef __cplusplus
}
#endif

#include <poppack.h>


#endif  // _PRSHT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\Qos.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    qos.h - QoS definitions for NDIS components.

Abstract:

    This module defines the Quality of Service structures and types used
    by Winsock applications.

WARNING:

    This api is deprecated and will be removed in a future release of Windows.
    Please use the QOS2.h api.

Revision History:

--*/

#ifndef __QOS_H_
#define __QOS_H_

#pragma once

/*
 *  Definitions for valued-based Service Type for each direction of data flow.
 */

typedef ULONG   SERVICETYPE;

#define SERVICETYPE_NOTRAFFIC               0x00000000  /* No data in this 
                                                         * direction */
#define SERVICETYPE_BESTEFFORT              0x00000001  /* Best Effort */
#define SERVICETYPE_CONTROLLEDLOAD          0x00000002  /* Controlled Load */
#define SERVICETYPE_GUARANTEED              0x00000003  /* Guaranteed */

#define SERVICETYPE_NETWORK_UNAVAILABLE     0x00000004  /* Used to notify 
                                                         * change to user */
#define SERVICETYPE_GENERAL_INFORMATION     0x00000005  /* corresponds to 
                                                         * "General Parameters"
                                                         * defined by IntServ */
#define SERVICETYPE_NOCHANGE                0x00000006  /* used to indicate
                                                         * that the flow spec
                                                         * contains no change
                                                         * from any previous
                                                         * one */
#define SERVICETYPE_NONCONFORMING           0x00000009  /* Non-Conforming Traffic */
#define SERVICETYPE_NETWORK_CONTROL         0x0000000A  /* Network Control traffic */
#define SERVICETYPE_QUALITATIVE             0x0000000D  /* Qualitative applications */ 



/*********  The usage of these is currently not supported.  ***************/
#define SERVICE_BESTEFFORT                  0x80010000
#define SERVICE_CONTROLLEDLOAD              0x80020000
#define SERVICE_GUARANTEED                  0x80040000
#define SERVICE_QUALITATIVE                 0x80200000
/* **************************** ***** ************************************ */



/*
 * Flags to control the usage of RSVP on this flow.
 */

/*
 * to turn off traffic control, 'OR' ( | ) this flag with the 
 * ServiceType field in the FLOWSPEC
 */
#define SERVICE_NO_TRAFFIC_CONTROL   0x81000000


/*
 * this flag can be used to prevent any rsvp signaling messages from being 
 * sent. Local traffic control will be invoked, but no RSVP Path messages 
 * will be sent.This flag can also be used in conjunction with a receiving 
 * flowspec to suppress the automatic generation of a Reserve message.  
 * The application would receive notification that a Path  message had arrived 
 * and would then need to alter the QOS by issuing WSAIoctl( SIO_SET_QOS ), 
 * to unset this flag and thereby causing Reserve messages to go out.
 */

#define SERVICE_NO_QOS_SIGNALING   0x40000000




/*
 *  Flow Specifications for each direction of data flow.
 */
typedef struct _flowspec
{
    ULONG       TokenRate;              /* In Bytes/sec */
    ULONG       TokenBucketSize;        /* In Bytes */
    ULONG       PeakBandwidth;          /* In Bytes/sec */
    ULONG       Latency;                /* In microseconds */
    ULONG       DelayVariation;         /* In microseconds */
    SERVICETYPE ServiceType;
    ULONG       MaxSduSize;             /* In Bytes */
    ULONG       MinimumPolicedSize;     /* In Bytes */

} FLOWSPEC, *PFLOWSPEC, * LPFLOWSPEC;

/*
 * this value can be used in the FLOWSPEC structure to instruct the Rsvp Service 
 * provider to derive the appropriate default value for the parameter.  Note 
 * that not all values in the FLOWSPEC structure can be defaults. In the
 * ReceivingFlowspec, all parameters can be defaulted except the ServiceType.  
 * In the SendingFlowspec, the MaxSduSize and MinimumPolicedSize can be
 * defaulted. Other defaults may be possible. Refer to the appropriate
 * documentation.
 */
#define QOS_NOT_SPECIFIED     0xFFFFFFFF

/*
 * define a value that can be used for the PeakBandwidth, which will map into 
 * positive infinity when the FLOWSPEC is converted into IntServ floating point 
 * format.  We can't use (-1) because that value was previously defined to mean
 * "select the default".
 */
#define   POSITIVE_INFINITY_RATE     0xFFFFFFFE



/*
 * the provider specific structure can have a number of objects in it.
 * Each next structure in the
 * ProviderSpecific will be the QOS_OBJECT_HDR struct that prefaces the actual
 * data with a type and length for that object.  This QOS_OBJECT struct can 
 * repeat several times if there are several objects.  This list of objects
 * terminates either when the buffer length has been reached ( WSABUF ) or
 * an object of type QOS_END_OF_LIST is encountered.
 */
typedef struct  {

    ULONG   ObjectType;
    ULONG   ObjectLength;  /* the length of object buffer INCLUDING 
                            * this header */

} QOS_OBJECT_HDR, *LPQOS_OBJECT_HDR;


/*
 * general QOS objects start at this offset from the base and have a range 
 * of 1000
 */
#define   QOS_GENERAL_ID_BASE                      2000

#define   QOS_OBJECT_END_OF_LIST                   (0x00000001 + QOS_GENERAL_ID_BASE) 
          /* QOS_End_of_list structure passed */
#define   QOS_OBJECT_SD_MODE                       (0x00000002 + QOS_GENERAL_ID_BASE) 
          /* QOS_ShapeDiscard structure passed */
#define   QOS_OBJECT_SHAPING_RATE	           (0x00000003 + QOS_GENERAL_ID_BASE)
          /* QOS_ShapingRate structure */
#define   QOS_OBJECT_DESTADDR                      (0x00000004 + QOS_GENERAL_ID_BASE)
          /* QOS_DestAddr structure (defined in qossp.h) */


/*
 * This structure is used to define the behaviour that the traffic
 * control packet shaper will apply to the flow.
 *
 * TC_NONCONF_BORROW - the flow will receive resources remaining 
 *  after all higher priority flows have been serviced. If a 
 *  TokenRate is specified, packets may be non-conforming and
 *  will be demoted to less than best-effort priority.
 *  
 * TC_NONCONF_SHAPE - TokenRate must be specified. Non-conforming
 *  packets will be retianed in the packet shaper until they become
 *  conforming.
 *
 * TC_NONCONF_DISCARD - TokenRate must be specified. Non-conforming
 *  packets will be discarded.
 *
 */

typedef struct _QOS_SD_MODE {

    QOS_OBJECT_HDR   ObjectHdr;
    ULONG            ShapeDiscardMode;

} QOS_SD_MODE, *LPQOS_SD_MODE;

#define TC_NONCONF_BORROW      0
#define TC_NONCONF_SHAPE       1
#define TC_NONCONF_DISCARD     2
#define TC_NONCONF_BORROW_PLUS 3 // Not supported currently


/*
 * This structure allows an app to specify a prorated "average token rate" using by
 * the traffic shaper under SHAPE modehaper queue. It is expressed in bytes per sec.
 *
 * ShapingRate (bytes per sec.)
 *
 */

typedef struct _QOS_SHAPING_RATE {

    QOS_OBJECT_HDR   ObjectHdr;
    ULONG            ShapingRate;

} QOS_SHAPING_RATE, *LPQOS_SHAPING_RATE;


#endif  /* __QOS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\PshPack4.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack4.h

Abstract:

    This file turns 4 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 && !defined(_M_I86)) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push,4)
#else
#pragma pack(4)
#endif
#else
#pragma pack(4)
#endif
#endif // ! (defined(lint) || defined(RC_INVOKED))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\PshPack2.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack2.h

Abstract:

    This file turns 2 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 && !defined(_M_I86)) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push,2)
#else
#pragma pack(2)
#endif
#else
#pragma pack(2)
#endif
#endif // ! (defined(lint) || defined(RC_INVOKED))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\QosPol.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    qospol.h - QOS policy elements

Abstract:

    This module defines QOS policy elements.

Revision History:

--*/

#ifndef __QOSPOL_H_
#define __QOSPOL_H_

#pragma once

#define PE_TYPE_APPID       3       // policy element contains Application Identity

// Policy Location attribute carries sub application attributes
#define PE_ATTRIB_TYPE_POLICY_LOCATOR            1

#define POLICY_LOCATOR_SUB_TYPE_ASCII_DN         1
#define POLICY_LOCATOR_SUB_TYPE_UNICODE_DN       2
#define POLICY_LOCATOR_SUB_TYPE_ASCII_DN_ENC     3
#define POLICY_LOCATOR_SUB_TYPE_UNICODE_DN_ENC   4


// Credentials attribute carries the application identity
#define PE_ATTRIB_TYPE_CREDENTIAL        2

#define CREDENTIAL_SUB_TYPE_ASCII_ID     1
#define CREDENTIAL_SUB_TYPE_UNICODE_ID   2
#define CREDENTIAL_SUB_TYPE_KERBEROS_TKT 3
#define CREDENTIAL_SUB_TYPE_X509_V3_CERT 4
#define CREDENTIAL_SUB_TYPE_PGP_CERT     5


// Identity Policy Element attribute structure
typedef struct _IDPE_ATTR {

    USHORT  PeAttribLength;
    
    UCHAR   PeAttribType;            // Use the #defines from above
    
    UCHAR   PeAttribSubType;        // Use the #defines from above
    
    UCHAR   PeAttribValue[4];
    
} IDPE_ATTR, *LPIDPE_ATTR;

#define IDPE_ATTR_HDR_LEN    (sizeof(USHORT)+sizeof(UCHAR)+sizeof(UCHAR))

#define RSVP_BYTE_MULTIPLE(x)       (((x+3) / 4) * 4)


#endif // __QOSPOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\PshPack8.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack8.h

Abstract:

    This file turns 8 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 && !defined(_M_I86)) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push,8)
#else
#pragma pack(8)
#endif
#else
#pragma pack(8)
#endif
#endif // ! (defined(lint) || defined(RC_INVOKED))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\qnetwork.h ===
/* This header file machine-generated by mktyplib.exe */
/* Interface to type library: QuartzNetTypeLib */

#ifndef _QuartzNetTypeLib_H_
#define _QuartzNetTypeLib_H_

DEFINE_GUID(LIBID_QuartzNetTypeLib,0x56A868B1L,0x0AD4,0x11CE,0xB0,0x3A,0x00,0x20,0xAF,0x0B,0xA7,0x70);
#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

DEFINE_GUID(IID_IAMNetShowConfig,0xFA2AA8F1L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMNetShowConfig */
#undef INTERFACE
#define INTERFACE IAMNetShowConfig

DECLARE_INTERFACE_(IAMNetShowConfig, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMNetShowConfig methods */
    STDMETHOD(get_BufferingTime)(THIS_ double FAR* pBufferingTime) PURE;
    STDMETHOD(put_BufferingTime)(THIS_ double BufferingTime) PURE;
    STDMETHOD(get_UseFixedUDPPort)(THIS_ VARIANT_BOOL FAR* pUseFixedUDPPort) PURE;
    STDMETHOD(put_UseFixedUDPPort)(THIS_ VARIANT_BOOL UseFixedUDPPort) PURE;
    STDMETHOD(get_FixedUDPPort)(THIS_ long FAR* pFixedUDPPort) PURE;
    STDMETHOD(put_FixedUDPPort)(THIS_ long FixedUDPPort) PURE;
    STDMETHOD(get_UseHTTPProxy)(THIS_ VARIANT_BOOL FAR* pUseHTTPProxy) PURE;
    STDMETHOD(put_UseHTTPProxy)(THIS_ VARIANT_BOOL UseHTTPProxy) PURE;
    STDMETHOD(get_EnableAutoProxy)(THIS_ VARIANT_BOOL FAR* pEnableAutoProxy) PURE;
    STDMETHOD(put_EnableAutoProxy)(THIS_ VARIANT_BOOL EnableAutoProxy) PURE;
    STDMETHOD(get_HTTPProxyHost)(THIS_ BSTR FAR* pbstrHTTPProxyHost) PURE;
    STDMETHOD(put_HTTPProxyHost)(THIS_ BSTR bstrHTTPProxyHost) PURE;
    STDMETHOD(get_HTTPProxyPort)(THIS_ long FAR* pHTTPProxyPort) PURE;
    STDMETHOD(put_HTTPProxyPort)(THIS_ long HTTPProxyPort) PURE;
    STDMETHOD(get_EnableMulticast)(THIS_ VARIANT_BOOL FAR* pEnableMulticast) PURE;
    STDMETHOD(put_EnableMulticast)(THIS_ VARIANT_BOOL EnableMulticast) PURE;
    STDMETHOD(get_EnableUDP)(THIS_ VARIANT_BOOL FAR* pEnableUDP) PURE;
    STDMETHOD(put_EnableUDP)(THIS_ VARIANT_BOOL EnableUDP) PURE;
    STDMETHOD(get_EnableTCP)(THIS_ VARIANT_BOOL FAR* pEnableTCP) PURE;
    STDMETHOD(put_EnableTCP)(THIS_ VARIANT_BOOL EnableTCP) PURE;
    STDMETHOD(get_EnableHTTP)(THIS_ VARIANT_BOOL FAR* pEnableHTTP) PURE;
    STDMETHOD(put_EnableHTTP)(THIS_ VARIANT_BOOL EnableHTTP) PURE;
};

DEFINE_GUID(IID_IAMChannelInfo,0xFA2AA8F2L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMChannelInfo */
#undef INTERFACE
#define INTERFACE IAMChannelInfo

DECLARE_INTERFACE_(IAMChannelInfo, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMChannelInfo methods */
    STDMETHOD(get_ChannelName)(THIS_ BSTR FAR* pbstrChannelName) PURE;
    STDMETHOD(get_ChannelDescription)(THIS_ BSTR FAR* pbstrChannelDescription) PURE;
    STDMETHOD(get_ChannelURL)(THIS_ BSTR FAR* pbstrChannelURL) PURE;
    STDMETHOD(get_ContactAddress)(THIS_ BSTR FAR* pbstrContactAddress) PURE;
    STDMETHOD(get_ContactPhone)(THIS_ BSTR FAR* pbstrContactPhone) PURE;
    STDMETHOD(get_ContactEmail)(THIS_ BSTR FAR* pbstrContactEmail) PURE;
};

DEFINE_GUID(IID_IAMNetworkStatus,0xFA2AA8F3L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMNetworkStatus */
#undef INTERFACE
#define INTERFACE IAMNetworkStatus

DECLARE_INTERFACE_(IAMNetworkStatus, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMNetworkStatus methods */
    STDMETHOD(get_ReceivedPackets)(THIS_ long FAR* pReceivedPackets) PURE;
    STDMETHOD(get_RecoveredPackets)(THIS_ long FAR* pRecoveredPackets) PURE;
    STDMETHOD(get_LostPackets)(THIS_ long FAR* pLostPackets) PURE;
    STDMETHOD(get_ReceptionQuality)(THIS_ long FAR* pReceptionQuality) PURE;
    STDMETHOD(get_BufferingCount)(THIS_ long FAR* pBufferingCount) PURE;
    STDMETHOD(get_IsBroadcast)(THIS_ VARIANT_BOOL FAR* pIsBroadcast) PURE;
    STDMETHOD(get_BufferingProgress)(THIS_ long FAR* pBufferingProgress) PURE;
};

typedef enum {
    AM_EXSEEK_CANSEEK = 1,
    AM_EXSEEK_CANSCAN = 2,
    AM_EXSEEK_MARKERSEEK = 4,
    AM_EXSEEK_SCANWITHOUTCLOCK = 8,
    AM_EXSEEK_NOSTANDARDREPAINT = 16,
    AM_EXSEEK_BUFFERING = 32,
    AM_EXSEEK_SENDS_VIDEOFRAMEREADY = 64
} AMExtendedSeekingCapabilities;

DEFINE_GUID(IID_IAMExtendedSeeking,0xFA2AA8F9L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMExtendedSeeking */
#undef INTERFACE
#define INTERFACE IAMExtendedSeeking

DECLARE_INTERFACE_(IAMExtendedSeeking, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMExtendedSeeking methods */
    STDMETHOD(get_ExSeekCapabilities)(THIS_ long FAR* pExCapabilities) PURE;
    STDMETHOD(get_MarkerCount)(THIS_ long FAR* pMarkerCount) PURE;
    STDMETHOD(get_CurrentMarker)(THIS_ long FAR* pCurrentMarker) PURE;
    STDMETHOD(GetMarkerTime)(THIS_ long MarkerNum, double FAR* pMarkerTime) PURE;
    STDMETHOD(GetMarkerName)(THIS_ long MarkerNum, BSTR FAR* pbstrMarkerName) PURE;
    STDMETHOD(put_PlaybackSpeed)(THIS_ double Speed) PURE;
    STDMETHOD(get_PlaybackSpeed)(THIS_ double FAR* pSpeed) PURE;
};

DEFINE_GUID(IID_IAMNetShowExProps,0xFA2AA8F5L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMNetShowExProps */
#undef INTERFACE
#define INTERFACE IAMNetShowExProps

DECLARE_INTERFACE_(IAMNetShowExProps, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMNetShowExProps methods */
    STDMETHOD(get_SourceProtocol)(THIS_ long FAR* pSourceProtocol) PURE;
    STDMETHOD(get_Bandwidth)(THIS_ long FAR* pBandwidth) PURE;
    STDMETHOD(get_ErrorCorrection)(THIS_ BSTR FAR* pbstrErrorCorrection) PURE;
    STDMETHOD(get_CodecCount)(THIS_ long FAR* pCodecCount) PURE;
    STDMETHOD(GetCodecInstalled)(THIS_ long CodecNum, VARIANT_BOOL FAR* pCodecInstalled) PURE;
    STDMETHOD(GetCodecDescription)(THIS_ long CodecNum, BSTR FAR* pbstrCodecDescription) PURE;
    STDMETHOD(GetCodecURL)(THIS_ long CodecNum, BSTR FAR* pbstrCodecURL) PURE;
    STDMETHOD(get_CreationDate)(THIS_ DATE FAR* pCreationDate) PURE;
    STDMETHOD(get_SourceLink)(THIS_ BSTR FAR* pbstrSourceLink) PURE;
};

DEFINE_GUID(IID_IAMExtendedErrorInfo,0xFA2AA8F6L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMExtendedErrorInfo */
#undef INTERFACE
#define INTERFACE IAMExtendedErrorInfo

DECLARE_INTERFACE_(IAMExtendedErrorInfo, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMExtendedErrorInfo methods */
    STDMETHOD(get_HasError)(THIS_ VARIANT_BOOL FAR* pHasError) PURE;
    STDMETHOD(get_ErrorDescription)(THIS_ BSTR FAR* pbstrErrorDescription) PURE;
    STDMETHOD(get_ErrorCode)(THIS_ long FAR* pErrorCode) PURE;
};

DEFINE_GUID(IID_IAMMediaContent,0xFA2AA8F4L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMMediaContent */
#undef INTERFACE
#define INTERFACE IAMMediaContent

DECLARE_INTERFACE_(IAMMediaContent, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMMediaContent methods */
    STDMETHOD(get_AuthorName)(THIS_ BSTR FAR* pbstrAuthorName) PURE;
    STDMETHOD(get_Title)(THIS_ BSTR FAR* pbstrTitle) PURE;
    STDMETHOD(get_Rating)(THIS_ BSTR FAR* pbstrRating) PURE;
    STDMETHOD(get_Description)(THIS_ BSTR FAR* pbstrDescription) PURE;
    STDMETHOD(get_Copyright)(THIS_ BSTR FAR* pbstrCopyright) PURE;
    STDMETHOD(get_BaseURL)(THIS_ BSTR FAR* pbstrBaseURL) PURE;
    STDMETHOD(get_LogoURL)(THIS_ BSTR FAR* pbstrLogoURL) PURE;
    STDMETHOD(get_LogoIconURL)(THIS_ BSTR FAR* pbstrLogoURL) PURE;
    STDMETHOD(get_WatermarkURL)(THIS_ BSTR FAR* pbstrWatermarkURL) PURE;
    STDMETHOD(get_MoreInfoURL)(THIS_ BSTR FAR* pbstrMoreInfoURL) PURE;
    STDMETHOD(get_MoreInfoBannerImage)(THIS_ BSTR FAR* pbstrMoreInfoBannerImage) PURE;
    STDMETHOD(get_MoreInfoBannerURL)(THIS_ BSTR FAR* pbstrMoreInfoBannerURL) PURE;
    STDMETHOD(get_MoreInfoText)(THIS_ BSTR FAR* pbstrMoreInfoText) PURE;
};

DEFINE_GUID(IID_IAMMediaContent2,0xCE8F78C1L,0x74D9,0x11D2,0xB0,0x9D,0x00,0xA0,0xC9,0xA8,0x11,0x17);

/* Definition of interface: IAMMediaContent2 */
#undef INTERFACE
#define INTERFACE IAMMediaContent2

DECLARE_INTERFACE_(IAMMediaContent2, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMMediaContent2 methods */
    STDMETHOD(get_MediaParameter)(THIS_ long EntryNum, BSTR bstrName, BSTR FAR* pbstrValue) PURE;
    STDMETHOD(get_MediaParameterName)(THIS_ long EntryNum, long Index, BSTR FAR* pbstrName) PURE;
    STDMETHOD(get_PlaylistCount)(THIS_ long FAR* pNumberEntries) PURE;
};

DEFINE_GUID(IID_IAMNetShowPreroll,0xAAE7E4E2L,0x6388,0x11D1,0x8D,0x93,0x00,0x60,0x97,0xC9,0xA2,0xB2);

/* Definition of interface: IAMNetShowPreroll */
#undef INTERFACE
#define INTERFACE IAMNetShowPreroll

DECLARE_INTERFACE_(IAMNetShowPreroll, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMNetShowPreroll methods */
    STDMETHOD(put_Preroll)(THIS_ VARIANT_BOOL fPreroll) PURE;
    STDMETHOD(get_Preroll)(THIS_ VARIANT_BOOL FAR* pfPreroll) PURE;
};

DEFINE_GUID(IID_IDShowPlugin,0x4746B7C8L,0x700E,0x11D1,0xBE,0xCC,0x00,0xC0,0x4F,0xB6,0xE9,0x37);

/* Definition of interface: IDShowPlugin */
#undef INTERFACE
#define INTERFACE IDShowPlugin

DECLARE_INTERFACE_(IDShowPlugin, IUnknown)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IDShowPlugin methods */
    STDMETHOD(get_URL)(THIS_ BSTR FAR* pURL) PURE;
    STDMETHOD(get_UserAgent)(THIS_ BSTR FAR* pUserAgent) PURE;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\qedit.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for qedit.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __qedit_h__
#define __qedit_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPropertySetter_FWD_DEFINED__
#define __IPropertySetter_FWD_DEFINED__
typedef interface IPropertySetter IPropertySetter;
#endif 	/* __IPropertySetter_FWD_DEFINED__ */


#ifndef __IDxtCompositor_FWD_DEFINED__
#define __IDxtCompositor_FWD_DEFINED__
typedef interface IDxtCompositor IDxtCompositor;
#endif 	/* __IDxtCompositor_FWD_DEFINED__ */


#ifndef __IDxtAlphaSetter_FWD_DEFINED__
#define __IDxtAlphaSetter_FWD_DEFINED__
typedef interface IDxtAlphaSetter IDxtAlphaSetter;
#endif 	/* __IDxtAlphaSetter_FWD_DEFINED__ */


#ifndef __IDxtJpeg_FWD_DEFINED__
#define __IDxtJpeg_FWD_DEFINED__
typedef interface IDxtJpeg IDxtJpeg;
#endif 	/* __IDxtJpeg_FWD_DEFINED__ */


#ifndef __IDxtKey_FWD_DEFINED__
#define __IDxtKey_FWD_DEFINED__
typedef interface IDxtKey IDxtKey;
#endif 	/* __IDxtKey_FWD_DEFINED__ */


#ifndef __IMediaLocator_FWD_DEFINED__
#define __IMediaLocator_FWD_DEFINED__
typedef interface IMediaLocator IMediaLocator;
#endif 	/* __IMediaLocator_FWD_DEFINED__ */


#ifndef __IMediaDet_FWD_DEFINED__
#define __IMediaDet_FWD_DEFINED__
typedef interface IMediaDet IMediaDet;
#endif 	/* __IMediaDet_FWD_DEFINED__ */


#ifndef __IGrfCache_FWD_DEFINED__
#define __IGrfCache_FWD_DEFINED__
typedef interface IGrfCache IGrfCache;
#endif 	/* __IGrfCache_FWD_DEFINED__ */


#ifndef __IRenderEngine_FWD_DEFINED__
#define __IRenderEngine_FWD_DEFINED__
typedef interface IRenderEngine IRenderEngine;
#endif 	/* __IRenderEngine_FWD_DEFINED__ */


#ifndef __IRenderEngine2_FWD_DEFINED__
#define __IRenderEngine2_FWD_DEFINED__
typedef interface IRenderEngine2 IRenderEngine2;
#endif 	/* __IRenderEngine2_FWD_DEFINED__ */


#ifndef __IFindCompressorCB_FWD_DEFINED__
#define __IFindCompressorCB_FWD_DEFINED__
typedef interface IFindCompressorCB IFindCompressorCB;
#endif 	/* __IFindCompressorCB_FWD_DEFINED__ */


#ifndef __ISmartRenderEngine_FWD_DEFINED__
#define __ISmartRenderEngine_FWD_DEFINED__
typedef interface ISmartRenderEngine ISmartRenderEngine;
#endif 	/* __ISmartRenderEngine_FWD_DEFINED__ */


#ifndef __IAMTimelineObj_FWD_DEFINED__
#define __IAMTimelineObj_FWD_DEFINED__
typedef interface IAMTimelineObj IAMTimelineObj;
#endif 	/* __IAMTimelineObj_FWD_DEFINED__ */


#ifndef __IAMTimelineEffectable_FWD_DEFINED__
#define __IAMTimelineEffectable_FWD_DEFINED__
typedef interface IAMTimelineEffectable IAMTimelineEffectable;
#endif 	/* __IAMTimelineEffectable_FWD_DEFINED__ */


#ifndef __IAMTimelineEffect_FWD_DEFINED__
#define __IAMTimelineEffect_FWD_DEFINED__
typedef interface IAMTimelineEffect IAMTimelineEffect;
#endif 	/* __IAMTimelineEffect_FWD_DEFINED__ */


#ifndef __IAMTimelineTransable_FWD_DEFINED__
#define __IAMTimelineTransable_FWD_DEFINED__
typedef interface IAMTimelineTransable IAMTimelineTransable;
#endif 	/* __IAMTimelineTransable_FWD_DEFINED__ */


#ifndef __IAMTimelineSplittable_FWD_DEFINED__
#define __IAMTimelineSplittable_FWD_DEFINED__
typedef interface IAMTimelineSplittable IAMTimelineSplittable;
#endif 	/* __IAMTimelineSplittable_FWD_DEFINED__ */


#ifndef __IAMTimelineTrans_FWD_DEFINED__
#define __IAMTimelineTrans_FWD_DEFINED__
typedef interface IAMTimelineTrans IAMTimelineTrans;
#endif 	/* __IAMTimelineTrans_FWD_DEFINED__ */


#ifndef __IAMTimelineSrc_FWD_DEFINED__
#define __IAMTimelineSrc_FWD_DEFINED__
typedef interface IAMTimelineSrc IAMTimelineSrc;
#endif 	/* __IAMTimelineSrc_FWD_DEFINED__ */


#ifndef __IAMTimelineTrack_FWD_DEFINED__
#define __IAMTimelineTrack_FWD_DEFINED__
typedef interface IAMTimelineTrack IAMTimelineTrack;
#endif 	/* __IAMTimelineTrack_FWD_DEFINED__ */


#ifndef __IAMTimelineVirtualTrack_FWD_DEFINED__
#define __IAMTimelineVirtualTrack_FWD_DEFINED__
typedef interface IAMTimelineVirtualTrack IAMTimelineVirtualTrack;
#endif 	/* __IAMTimelineVirtualTrack_FWD_DEFINED__ */


#ifndef __IAMTimelineComp_FWD_DEFINED__
#define __IAMTimelineComp_FWD_DEFINED__
typedef interface IAMTimelineComp IAMTimelineComp;
#endif 	/* __IAMTimelineComp_FWD_DEFINED__ */


#ifndef __IAMTimelineGroup_FWD_DEFINED__
#define __IAMTimelineGroup_FWD_DEFINED__
typedef interface IAMTimelineGroup IAMTimelineGroup;
#endif 	/* __IAMTimelineGroup_FWD_DEFINED__ */


#ifndef __IAMTimeline_FWD_DEFINED__
#define __IAMTimeline_FWD_DEFINED__
typedef interface IAMTimeline IAMTimeline;
#endif 	/* __IAMTimeline_FWD_DEFINED__ */


#ifndef __IXml2Dex_FWD_DEFINED__
#define __IXml2Dex_FWD_DEFINED__
typedef interface IXml2Dex IXml2Dex;
#endif 	/* __IXml2Dex_FWD_DEFINED__ */


#ifndef __IAMErrorLog_FWD_DEFINED__
#define __IAMErrorLog_FWD_DEFINED__
typedef interface IAMErrorLog IAMErrorLog;
#endif 	/* __IAMErrorLog_FWD_DEFINED__ */


#ifndef __IAMSetErrorLog_FWD_DEFINED__
#define __IAMSetErrorLog_FWD_DEFINED__
typedef interface IAMSetErrorLog IAMSetErrorLog;
#endif 	/* __IAMSetErrorLog_FWD_DEFINED__ */


#ifndef __ISampleGrabberCB_FWD_DEFINED__
#define __ISampleGrabberCB_FWD_DEFINED__
typedef interface ISampleGrabberCB ISampleGrabberCB;
#endif 	/* __ISampleGrabberCB_FWD_DEFINED__ */


#ifndef __ISampleGrabber_FWD_DEFINED__
#define __ISampleGrabber_FWD_DEFINED__
typedef interface ISampleGrabber ISampleGrabber;
#endif 	/* __ISampleGrabber_FWD_DEFINED__ */


#ifndef __IResize_FWD_DEFINED__
#define __IResize_FWD_DEFINED__
typedef interface IResize IResize;
#endif 	/* __IResize_FWD_DEFINED__ */


#ifndef __AMTimeline_FWD_DEFINED__
#define __AMTimeline_FWD_DEFINED__

#ifdef __cplusplus
typedef class AMTimeline AMTimeline;
#else
typedef struct AMTimeline AMTimeline;
#endif /* __cplusplus */

#endif 	/* __AMTimeline_FWD_DEFINED__ */


#ifndef __AMTimelineObj_FWD_DEFINED__
#define __AMTimelineObj_FWD_DEFINED__

#ifdef __cplusplus
typedef class AMTimelineObj AMTimelineObj;
#else
typedef struct AMTimelineObj AMTimelineObj;
#endif /* __cplusplus */

#endif 	/* __AMTimelineObj_FWD_DEFINED__ */


#ifndef __AMTimelineSrc_FWD_DEFINED__
#define __AMTimelineSrc_FWD_DEFINED__

#ifdef __cplusplus
typedef class AMTimelineSrc AMTimelineSrc;
#else
typedef struct AMTimelineSrc AMTimelineSrc;
#endif /* __cplusplus */

#endif 	/* __AMTimelineSrc_FWD_DEFINED__ */


#ifndef __AMTimelineTrack_FWD_DEFINED__
#define __AMTimelineTrack_FWD_DEFINED__

#ifdef __cplusplus
typedef class AMTimelineTrack AMTimelineTrack;
#else
typedef struct AMTimelineTrack AMTimelineTrack;
#endif /* __cplusplus */

#endif 	/* __AMTimelineTrack_FWD_DEFINED__ */


#ifndef __AMTimelineComp_FWD_DEFINED__
#define __AMTimelineComp_FWD_DEFINED__

#ifdef __cplusplus
typedef class AMTimelineComp AMTimelineComp;
#else
typedef struct AMTimelineComp AMTimelineComp;
#endif /* __cplusplus */

#endif 	/* __AMTimelineComp_FWD_DEFINED__ */


#ifndef __AMTimelineGroup_FWD_DEFINED__
#define __AMTimelineGroup_FWD_DEFINED__

#ifdef __cplusplus
typedef class AMTimelineGroup AMTimelineGroup;
#else
typedef struct AMTimelineGroup AMTimelineGroup;
#endif /* __cplusplus */

#endif 	/* __AMTimelineGroup_FWD_DEFINED__ */


#ifndef __AMTimelineTrans_FWD_DEFINED__
#define __AMTimelineTrans_FWD_DEFINED__

#ifdef __cplusplus
typedef class AMTimelineTrans AMTimelineTrans;
#else
typedef struct AMTimelineTrans AMTimelineTrans;
#endif /* __cplusplus */

#endif 	/* __AMTimelineTrans_FWD_DEFINED__ */


#ifndef __AMTimelineEffect_FWD_DEFINED__
#define __AMTimelineEffect_FWD_DEFINED__

#ifdef __cplusplus
typedef class AMTimelineEffect AMTimelineEffect;
#else
typedef struct AMTimelineEffect AMTimelineEffect;
#endif /* __cplusplus */

#endif 	/* __AMTimelineEffect_FWD_DEFINED__ */


#ifndef __RenderEngine_FWD_DEFINED__
#define __RenderEngine_FWD_DEFINED__

#ifdef __cplusplus
typedef class RenderEngine RenderEngine;
#else
typedef struct RenderEngine RenderEngine;
#endif /* __cplusplus */

#endif 	/* __RenderEngine_FWD_DEFINED__ */


#ifndef __SmartRenderEngine_FWD_DEFINED__
#define __SmartRenderEngine_FWD_DEFINED__

#ifdef __cplusplus
typedef class SmartRenderEngine SmartRenderEngine;
#else
typedef struct SmartRenderEngine SmartRenderEngine;
#endif /* __cplusplus */

#endif 	/* __SmartRenderEngine_FWD_DEFINED__ */


#ifndef __AudMixer_FWD_DEFINED__
#define __AudMixer_FWD_DEFINED__

#ifdef __cplusplus
typedef class AudMixer AudMixer;
#else
typedef struct AudMixer AudMixer;
#endif /* __cplusplus */

#endif 	/* __AudMixer_FWD_DEFINED__ */


#ifndef __Xml2Dex_FWD_DEFINED__
#define __Xml2Dex_FWD_DEFINED__

#ifdef __cplusplus
typedef class Xml2Dex Xml2Dex;
#else
typedef struct Xml2Dex Xml2Dex;
#endif /* __cplusplus */

#endif 	/* __Xml2Dex_FWD_DEFINED__ */


#ifndef __MediaLocator_FWD_DEFINED__
#define __MediaLocator_FWD_DEFINED__

#ifdef __cplusplus
typedef class MediaLocator MediaLocator;
#else
typedef struct MediaLocator MediaLocator;
#endif /* __cplusplus */

#endif 	/* __MediaLocator_FWD_DEFINED__ */


#ifndef __PropertySetter_FWD_DEFINED__
#define __PropertySetter_FWD_DEFINED__

#ifdef __cplusplus
typedef class PropertySetter PropertySetter;
#else
typedef struct PropertySetter PropertySetter;
#endif /* __cplusplus */

#endif 	/* __PropertySetter_FWD_DEFINED__ */


#ifndef __MediaDet_FWD_DEFINED__
#define __MediaDet_FWD_DEFINED__

#ifdef __cplusplus
typedef class MediaDet MediaDet;
#else
typedef struct MediaDet MediaDet;
#endif /* __cplusplus */

#endif 	/* __MediaDet_FWD_DEFINED__ */


#ifndef __SampleGrabber_FWD_DEFINED__
#define __SampleGrabber_FWD_DEFINED__

#ifdef __cplusplus
typedef class SampleGrabber SampleGrabber;
#else
typedef struct SampleGrabber SampleGrabber;
#endif /* __cplusplus */

#endif 	/* __SampleGrabber_FWD_DEFINED__ */


#ifndef __NullRenderer_FWD_DEFINED__
#define __NullRenderer_FWD_DEFINED__

#ifdef __cplusplus
typedef class NullRenderer NullRenderer;
#else
typedef struct NullRenderer NullRenderer;
#endif /* __cplusplus */

#endif 	/* __NullRenderer_FWD_DEFINED__ */


#ifndef __DxtCompositor_FWD_DEFINED__
#define __DxtCompositor_FWD_DEFINED__

#ifdef __cplusplus
typedef class DxtCompositor DxtCompositor;
#else
typedef struct DxtCompositor DxtCompositor;
#endif /* __cplusplus */

#endif 	/* __DxtCompositor_FWD_DEFINED__ */


#ifndef __DxtAlphaSetter_FWD_DEFINED__
#define __DxtAlphaSetter_FWD_DEFINED__

#ifdef __cplusplus
typedef class DxtAlphaSetter DxtAlphaSetter;
#else
typedef struct DxtAlphaSetter DxtAlphaSetter;
#endif /* __cplusplus */

#endif 	/* __DxtAlphaSetter_FWD_DEFINED__ */


#ifndef __DxtJpeg_FWD_DEFINED__
#define __DxtJpeg_FWD_DEFINED__

#ifdef __cplusplus
typedef class DxtJpeg DxtJpeg;
#else
typedef struct DxtJpeg DxtJpeg;
#endif /* __cplusplus */

#endif 	/* __DxtJpeg_FWD_DEFINED__ */


#ifndef __ColorSource_FWD_DEFINED__
#define __ColorSource_FWD_DEFINED__

#ifdef __cplusplus
typedef class ColorSource ColorSource;
#else
typedef struct ColorSource ColorSource;
#endif /* __cplusplus */

#endif 	/* __ColorSource_FWD_DEFINED__ */


#ifndef __DxtKey_FWD_DEFINED__
#define __DxtKey_FWD_DEFINED__

#ifdef __cplusplus
typedef class DxtKey DxtKey;
#else
typedef struct DxtKey DxtKey;
#endif /* __cplusplus */

#endif 	/* __DxtKey_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "dxtrans.h"
#include "amstream.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_qedit_0000_0000 */
/* [local] */ 

#pragma message("To compile qedit.h you must install the DirectX 9 SDK, to obtain the dxtrans.h header.")









typedef /* [public] */ 
enum __MIDL___MIDL_itf_qedit_0000_0000_0001
    {	DEXTERF_JUMP	= 0,
	DEXTERF_INTERPOLATE	= ( DEXTERF_JUMP + 1 ) 
    } 	DEXTERF;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_qedit_0000_0000_0002
    {
    BSTR Name;
    DISPID dispID;
    LONG nValues;
    } 	DEXTER_PARAM;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_qedit_0000_0000_0003
    {
    VARIANT v;
    REFERENCE_TIME rt;
    DWORD dwInterp;
    } 	DEXTER_VALUE;


enum __MIDL___MIDL_itf_qedit_0000_0000_0004
    {	DEXTER_AUDIO_JUMP	= 0,
	DEXTER_AUDIO_INTERPOLATE	= ( DEXTER_AUDIO_JUMP + 1 ) 
    } ;
typedef /* [public] */ struct __MIDL___MIDL_itf_qedit_0000_0000_0005
    {
    REFERENCE_TIME rtEnd;
    double dLevel;
    BOOL bMethod;
    } 	DEXTER_AUDIO_VOLUMEENVELOPE;


enum __MIDL___MIDL_itf_qedit_0000_0000_0006
    {	TIMELINE_INSERT_MODE_INSERT	= 1,
	TIMELINE_INSERT_MODE_OVERLAY	= 2
    } ;
typedef /* [public][public][public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_qedit_0000_0000_0007
    {	TIMELINE_MAJOR_TYPE_COMPOSITE	= 1,
	TIMELINE_MAJOR_TYPE_TRACK	= 2,
	TIMELINE_MAJOR_TYPE_SOURCE	= 4,
	TIMELINE_MAJOR_TYPE_TRANSITION	= 8,
	TIMELINE_MAJOR_TYPE_EFFECT	= 16,
	TIMELINE_MAJOR_TYPE_GROUP	= 128
    } 	TIMELINE_MAJOR_TYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_qedit_0000_0000_0008
    {	DEXTERF_BOUNDING	= -1,
	DEXTERF_EXACTLY_AT	= 0,
	DEXTERF_FORWARDS	= 1
    } 	DEXTERF_TRACK_SEARCH_FLAGS;

typedef struct _SCompFmt0
    {
    long nFormatId;
    AM_MEDIA_TYPE MediaType;
    } 	SCompFmt0;


enum __MIDL___MIDL_itf_qedit_0000_0000_0009
    {	RESIZEF_STRETCH	= 0,
	RESIZEF_CROP	= ( RESIZEF_STRETCH + 1 ) ,
	RESIZEF_PRESERVEASPECTRATIO	= ( RESIZEF_CROP + 1 ) ,
	RESIZEF_PRESERVEASPECTRATIO_NOLETTERBOX	= ( RESIZEF_PRESERVEASPECTRATIO + 1 ) 
    } ;

enum __MIDL___MIDL_itf_qedit_0000_0000_0010
    {	CONNECTF_DYNAMIC_NONE	= 0,
	CONNECTF_DYNAMIC_SOURCES	= 0x1,
	CONNECTF_DYNAMIC_EFFECTS	= 0x2
    } ;

enum __MIDL___MIDL_itf_qedit_0000_0000_0011
    {	SFN_VALIDATEF_CHECK	= 0x1,
	SFN_VALIDATEF_POPUP	= 0x2,
	SFN_VALIDATEF_TELLME	= 0x4,
	SFN_VALIDATEF_REPLACE	= 0x8,
	SFN_VALIDATEF_USELOCAL	= 0x10,
	SFN_VALIDATEF_NOFIND	= 0x20,
	SFN_VALIDATEF_IGNOREMUTED	= 0x40,
	SFN_VALIDATEF_END	= ( SFN_VALIDATEF_IGNOREMUTED + 1 ) 
    } ;

enum __MIDL___MIDL_itf_qedit_0000_0000_0012
    {	DXTKEY_RGB	= 0,
	DXTKEY_NONRED	= ( DXTKEY_RGB + 1 ) ,
	DXTKEY_LUMINANCE	= ( DXTKEY_NONRED + 1 ) ,
	DXTKEY_ALPHA	= ( DXTKEY_LUMINANCE + 1 ) ,
	DXTKEY_HUE	= ( DXTKEY_ALPHA + 1 ) 
    } ;


extern RPC_IF_HANDLE __MIDL_itf_qedit_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_qedit_0000_0000_v0_0_s_ifspec;

#ifndef __IPropertySetter_INTERFACE_DEFINED__
#define __IPropertySetter_INTERFACE_DEFINED__

/* interface IPropertySetter */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPropertySetter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AE9472BD-B0C3-11D2-8D24-00A0C9441E20")
    IPropertySetter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LoadXML( 
            /* [in] */ __RPC__in_opt IUnknown *pxml) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PrintXML( 
            /* [out] */ __RPC__out char *pszXML,
            /* [in] */ int cbXML,
            /* [out] */ __RPC__out int *pcbPrinted,
            /* [in] */ int indent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloneProps( 
            /* [out] */ __RPC__deref_out_opt IPropertySetter **ppSetter,
            /* [in] */ REFERENCE_TIME rtStart,
            /* [in] */ REFERENCE_TIME rtStop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddProp( 
            /* [in] */ DEXTER_PARAM Param,
            /* [in] */ __RPC__in DEXTER_VALUE *paValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProps( 
            /* [out] */ __RPC__out LONG *pcParams,
            /* [out] */ __RPC__deref_out_opt DEXTER_PARAM **paParam,
            /* [out] */ __RPC__deref_out_opt DEXTER_VALUE **paValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeProps( 
            /* [in] */ LONG cParams,
            /* [in] */ __RPC__in DEXTER_PARAM *paParam,
            /* [in] */ __RPC__in DEXTER_VALUE *paValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearProps( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveToBlob( 
            /* [out] */ __RPC__out LONG *pcSize,
            /* [out] */ __RPC__deref_out_opt BYTE **ppb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadFromBlob( 
            /* [in] */ LONG cSize,
            /* [in] */ __RPC__in BYTE *pb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProps( 
            /* [in] */ __RPC__in_opt IUnknown *pTarget,
            /* [in] */ REFERENCE_TIME rtNow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PrintXMLW( 
            /* [out] */ __RPC__out WCHAR *pszXML,
            /* [in] */ int cchXML,
            /* [out] */ __RPC__out int *pcchPrinted,
            /* [in] */ int indent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertySetterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertySetter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertySetter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertySetter * This);
        
        HRESULT ( STDMETHODCALLTYPE *LoadXML )( 
            IPropertySetter * This,
            /* [in] */ __RPC__in_opt IUnknown *pxml);
        
        HRESULT ( STDMETHODCALLTYPE *PrintXML )( 
            IPropertySetter * This,
            /* [out] */ __RPC__out char *pszXML,
            /* [in] */ int cbXML,
            /* [out] */ __RPC__out int *pcbPrinted,
            /* [in] */ int indent);
        
        HRESULT ( STDMETHODCALLTYPE *CloneProps )( 
            IPropertySetter * This,
            /* [out] */ __RPC__deref_out_opt IPropertySetter **ppSetter,
            /* [in] */ REFERENCE_TIME rtStart,
            /* [in] */ REFERENCE_TIME rtStop);
        
        HRESULT ( STDMETHODCALLTYPE *AddProp )( 
            IPropertySetter * This,
            /* [in] */ DEXTER_PARAM Param,
            /* [in] */ __RPC__in DEXTER_VALUE *paValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetProps )( 
            IPropertySetter * This,
            /* [out] */ __RPC__out LONG *pcParams,
            /* [out] */ __RPC__deref_out_opt DEXTER_PARAM **paParam,
            /* [out] */ __RPC__deref_out_opt DEXTER_VALUE **paValue);
        
        HRESULT ( STDMETHODCALLTYPE *FreeProps )( 
            IPropertySetter * This,
            /* [in] */ LONG cParams,
            /* [in] */ __RPC__in DEXTER_PARAM *paParam,
            /* [in] */ __RPC__in DEXTER_VALUE *paValue);
        
        HRESULT ( STDMETHODCALLTYPE *ClearProps )( 
            IPropertySetter * This);
        
        HRESULT ( STDMETHODCALLTYPE *SaveToBlob )( 
            IPropertySetter * This,
            /* [out] */ __RPC__out LONG *pcSize,
            /* [out] */ __RPC__deref_out_opt BYTE **ppb);
        
        HRESULT ( STDMETHODCALLTYPE *LoadFromBlob )( 
            IPropertySetter * This,
            /* [in] */ LONG cSize,
            /* [in] */ __RPC__in BYTE *pb);
        
        HRESULT ( STDMETHODCALLTYPE *SetProps )( 
            IPropertySetter * This,
            /* [in] */ __RPC__in_opt IUnknown *pTarget,
            /* [in] */ REFERENCE_TIME rtNow);
        
        HRESULT ( STDMETHODCALLTYPE *PrintXMLW )( 
            IPropertySetter * This,
            /* [out] */ __RPC__out WCHAR *pszXML,
            /* [in] */ int cchXML,
            /* [out] */ __RPC__out int *pcchPrinted,
            /* [in] */ int indent);
        
        END_INTERFACE
    } IPropertySetterVtbl;

    interface IPropertySetter
    {
        CONST_VTBL struct IPropertySetterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySetter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertySetter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertySetter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertySetter_LoadXML(This,pxml)	\
    ( (This)->lpVtbl -> LoadXML(This,pxml) ) 

#define IPropertySetter_PrintXML(This,pszXML,cbXML,pcbPrinted,indent)	\
    ( (This)->lpVtbl -> PrintXML(This,pszXML,cbXML,pcbPrinted,indent) ) 

#define IPropertySetter_CloneProps(This,ppSetter,rtStart,rtStop)	\
    ( (This)->lpVtbl -> CloneProps(This,ppSetter,rtStart,rtStop) ) 

#define IPropertySetter_AddProp(This,Param,paValue)	\
    ( (This)->lpVtbl -> AddProp(This,Param,paValue) ) 

#define IPropertySetter_GetProps(This,pcParams,paParam,paValue)	\
    ( (This)->lpVtbl -> GetProps(This,pcParams,paParam,paValue) ) 

#define IPropertySetter_FreeProps(This,cParams,paParam,paValue)	\
    ( (This)->lpVtbl -> FreeProps(This,cParams,paParam,paValue) ) 

#define IPropertySetter_ClearProps(This)	\
    ( (This)->lpVtbl -> ClearProps(This) ) 

#define IPropertySetter_SaveToBlob(This,pcSize,ppb)	\
    ( (This)->lpVtbl -> SaveToBlob(This,pcSize,ppb) ) 

#define IPropertySetter_LoadFromBlob(This,cSize,pb)	\
    ( (This)->lpVtbl -> LoadFromBlob(This,cSize,pb) ) 

#define IPropertySetter_SetProps(This,pTarget,rtNow)	\
    ( (This)->lpVtbl -> SetProps(This,pTarget,rtNow) ) 

#define IPropertySetter_PrintXMLW(This,pszXML,cchXML,pcchPrinted,indent)	\
    ( (This)->lpVtbl -> PrintXMLW(This,pszXML,cchXML,pcchPrinted,indent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertySetter_INTERFACE_DEFINED__ */


#ifndef __IDxtCompositor_INTERFACE_DEFINED__
#define __IDxtCompositor_INTERFACE_DEFINED__

/* interface IDxtCompositor */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDxtCompositor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BB44391E-6ABD-422f-9E2E-385C9DFF51FC")
    IDxtCompositor : public IDXEffect
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OffsetX( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OffsetX( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OffsetY( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OffsetY( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Height( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SrcOffsetX( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SrcOffsetX( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SrcOffsetY( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SrcOffsetY( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SrcWidth( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SrcWidth( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SrcHeight( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SrcHeight( 
            /* [in] */ long newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDxtCompositorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDxtCompositor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDxtCompositor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDxtCompositor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDxtCompositor * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDxtCompositor * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDxtCompositor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDxtCompositor * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDxtCompositor * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDxtCompositor * This,
            /* [retval][out] */ __RPC__out float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDxtCompositor * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDxtCompositor * This,
            /* [retval][out] */ __RPC__out float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDxtCompositor * This,
            /* [retval][out] */ __RPC__out float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDxtCompositor * This,
            /* [in] */ float newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OffsetX )( 
            IDxtCompositor * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OffsetX )( 
            IDxtCompositor * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OffsetY )( 
            IDxtCompositor * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OffsetY )( 
            IDxtCompositor * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Width )( 
            IDxtCompositor * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Width )( 
            IDxtCompositor * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Height )( 
            IDxtCompositor * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Height )( 
            IDxtCompositor * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SrcOffsetX )( 
            IDxtCompositor * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SrcOffsetX )( 
            IDxtCompositor * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SrcOffsetY )( 
            IDxtCompositor * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SrcOffsetY )( 
            IDxtCompositor * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SrcWidth )( 
            IDxtCompositor * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SrcWidth )( 
            IDxtCompositor * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SrcHeight )( 
            IDxtCompositor * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SrcHeight )( 
            IDxtCompositor * This,
            /* [in] */ long newVal);
        
        END_INTERFACE
    } IDxtCompositorVtbl;

    interface IDxtCompositor
    {
        CONST_VTBL struct IDxtCompositorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDxtCompositor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDxtCompositor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDxtCompositor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDxtCompositor_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDxtCompositor_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDxtCompositor_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDxtCompositor_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDxtCompositor_get_Capabilities(This,pVal)	\
    ( (This)->lpVtbl -> get_Capabilities(This,pVal) ) 

#define IDxtCompositor_get_Progress(This,pVal)	\
    ( (This)->lpVtbl -> get_Progress(This,pVal) ) 

#define IDxtCompositor_put_Progress(This,newVal)	\
    ( (This)->lpVtbl -> put_Progress(This,newVal) ) 

#define IDxtCompositor_get_StepResolution(This,pVal)	\
    ( (This)->lpVtbl -> get_StepResolution(This,pVal) ) 

#define IDxtCompositor_get_Duration(This,pVal)	\
    ( (This)->lpVtbl -> get_Duration(This,pVal) ) 

#define IDxtCompositor_put_Duration(This,newVal)	\
    ( (This)->lpVtbl -> put_Duration(This,newVal) ) 


#define IDxtCompositor_get_OffsetX(This,pVal)	\
    ( (This)->lpVtbl -> get_OffsetX(This,pVal) ) 

#define IDxtCompositor_put_OffsetX(This,newVal)	\
    ( (This)->lpVtbl -> put_OffsetX(This,newVal) ) 

#define IDxtCompositor_get_OffsetY(This,pVal)	\
    ( (This)->lpVtbl -> get_OffsetY(This,pVal) ) 

#define IDxtCompositor_put_OffsetY(This,newVal)	\
    ( (This)->lpVtbl -> put_OffsetY(This,newVal) ) 

#define IDxtCompositor_get_Width(This,pVal)	\
    ( (This)->lpVtbl -> get_Width(This,pVal) ) 

#define IDxtCompositor_put_Width(This,newVal)	\
    ( (This)->lpVtbl -> put_Width(This,newVal) ) 

#define IDxtCompositor_get_Height(This,pVal)	\
    ( (This)->lpVtbl -> get_Height(This,pVal) ) 

#define IDxtCompositor_put_Height(This,newVal)	\
    ( (This)->lpVtbl -> put_Height(This,newVal) ) 

#define IDxtCompositor_get_SrcOffsetX(This,pVal)	\
    ( (This)->lpVtbl -> get_SrcOffsetX(This,pVal) ) 

#define IDxtCompositor_put_SrcOffsetX(This,newVal)	\
    ( (This)->lpVtbl -> put_SrcOffsetX(This,newVal) ) 

#define IDxtCompositor_get_SrcOffsetY(This,pVal)	\
    ( (This)->lpVtbl -> get_SrcOffsetY(This,pVal) ) 

#define IDxtCompositor_put_SrcOffsetY(This,newVal)	\
    ( (This)->lpVtbl -> put_SrcOffsetY(This,newVal) ) 

#define IDxtCompositor_get_SrcWidth(This,pVal)	\
    ( (This)->lpVtbl -> get_SrcWidth(This,pVal) ) 

#define IDxtCompositor_put_SrcWidth(This,newVal)	\
    ( (This)->lpVtbl -> put_SrcWidth(This,newVal) ) 

#define IDxtCompositor_get_SrcHeight(This,pVal)	\
    ( (This)->lpVtbl -> get_SrcHeight(This,pVal) ) 

#define IDxtCompositor_put_SrcHeight(This,newVal)	\
    ( (This)->lpVtbl -> put_SrcHeight(This,newVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDxtCompositor_INTERFACE_DEFINED__ */


#ifndef __IDxtAlphaSetter_INTERFACE_DEFINED__
#define __IDxtAlphaSetter_INTERFACE_DEFINED__

/* interface IDxtAlphaSetter */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDxtAlphaSetter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4EE9EAD9-DA4D-43d0-9383-06B90C08B12B")
    IDxtAlphaSetter : public IDXEffect
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Alpha( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Alpha( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AlphaRamp( 
            /* [retval][out] */ __RPC__out double *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AlphaRamp( 
            /* [in] */ double newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDxtAlphaSetterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDxtAlphaSetter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDxtAlphaSetter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDxtAlphaSetter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDxtAlphaSetter * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDxtAlphaSetter * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDxtAlphaSetter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDxtAlphaSetter * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDxtAlphaSetter * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDxtAlphaSetter * This,
            /* [retval][out] */ __RPC__out float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDxtAlphaSetter * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDxtAlphaSetter * This,
            /* [retval][out] */ __RPC__out float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDxtAlphaSetter * This,
            /* [retval][out] */ __RPC__out float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDxtAlphaSetter * This,
            /* [in] */ float newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Alpha )( 
            IDxtAlphaSetter * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Alpha )( 
            IDxtAlphaSetter * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AlphaRamp )( 
            IDxtAlphaSetter * This,
            /* [retval][out] */ __RPC__out double *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AlphaRamp )( 
            IDxtAlphaSetter * This,
            /* [in] */ double newVal);
        
        END_INTERFACE
    } IDxtAlphaSetterVtbl;

    interface IDxtAlphaSetter
    {
        CONST_VTBL struct IDxtAlphaSetterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDxtAlphaSetter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDxtAlphaSetter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDxtAlphaSetter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDxtAlphaSetter_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDxtAlphaSetter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDxtAlphaSetter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDxtAlphaSetter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDxtAlphaSetter_get_Capabilities(This,pVal)	\
    ( (This)->lpVtbl -> get_Capabilities(This,pVal) ) 

#define IDxtAlphaSetter_get_Progress(This,pVal)	\
    ( (This)->lpVtbl -> get_Progress(This,pVal) ) 

#define IDxtAlphaSetter_put_Progress(This,newVal)	\
    ( (This)->lpVtbl -> put_Progress(This,newVal) ) 

#define IDxtAlphaSetter_get_StepResolution(This,pVal)	\
    ( (This)->lpVtbl -> get_StepResolution(This,pVal) ) 

#define IDxtAlphaSetter_get_Duration(This,pVal)	\
    ( (This)->lpVtbl -> get_Duration(This,pVal) ) 

#define IDxtAlphaSetter_put_Duration(This,newVal)	\
    ( (This)->lpVtbl -> put_Duration(This,newVal) ) 


#define IDxtAlphaSetter_get_Alpha(This,pVal)	\
    ( (This)->lpVtbl -> get_Alpha(This,pVal) ) 

#define IDxtAlphaSetter_put_Alpha(This,newVal)	\
    ( (This)->lpVtbl -> put_Alpha(This,newVal) ) 

#define IDxtAlphaSetter_get_AlphaRamp(This,pVal)	\
    ( (This)->lpVtbl -> get_AlphaRamp(This,pVal) ) 

#define IDxtAlphaSetter_put_AlphaRamp(This,newVal)	\
    ( (This)->lpVtbl -> put_AlphaRamp(This,newVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDxtAlphaSetter_INTERFACE_DEFINED__ */


#ifndef __IDxtJpeg_INTERFACE_DEFINED__
#define __IDxtJpeg_INTERFACE_DEFINED__

/* interface IDxtJpeg */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDxtJpeg;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DE75D011-7A65-11D2-8CEA-00A0C9441E20")
    IDxtJpeg : public IDXEffect
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MaskNum( 
            /* [retval][out] */ __RPC__out long *__MIDL__IDxtJpeg0000) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MaskNum( 
            /* [in] */ long __MIDL__IDxtJpeg0001) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MaskName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MaskName( 
            /* [in] */ __RPC__in BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ScaleX( 
            /* [retval][out] */ __RPC__out double *__MIDL__IDxtJpeg0002) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ScaleX( 
            /* [in] */ double __MIDL__IDxtJpeg0003) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ScaleY( 
            /* [retval][out] */ __RPC__out double *__MIDL__IDxtJpeg0004) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ScaleY( 
            /* [in] */ double __MIDL__IDxtJpeg0005) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OffsetX( 
            /* [retval][out] */ __RPC__out long *__MIDL__IDxtJpeg0006) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OffsetX( 
            /* [in] */ long __MIDL__IDxtJpeg0007) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OffsetY( 
            /* [retval][out] */ __RPC__out long *__MIDL__IDxtJpeg0008) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OffsetY( 
            /* [in] */ long __MIDL__IDxtJpeg0009) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReplicateX( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ReplicateX( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReplicateY( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ReplicateY( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BorderColor( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BorderColor( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BorderWidth( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BorderWidth( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BorderSoftness( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BorderSoftness( 
            /* [in] */ long newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyChanges( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadDefSettings( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDxtJpegVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDxtJpeg * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDxtJpeg * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDxtJpeg * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDxtJpeg * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDxtJpeg * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDxtJpeg * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDxtJpeg * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDxtJpeg * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDxtJpeg * This,
            /* [retval][out] */ __RPC__out float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDxtJpeg * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDxtJpeg * This,
            /* [retval][out] */ __RPC__out float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDxtJpeg * This,
            /* [retval][out] */ __RPC__out float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDxtJpeg * This,
            /* [in] */ float newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaskNum )( 
            IDxtJpeg * This,
            /* [retval][out] */ __RPC__out long *__MIDL__IDxtJpeg0000);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaskNum )( 
            IDxtJpeg * This,
            /* [in] */ long __MIDL__IDxtJpeg0001);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaskName )( 
            IDxtJpeg * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaskName )( 
            IDxtJpeg * This,
            /* [in] */ __RPC__in BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ScaleX )( 
            IDxtJpeg * This,
            /* [retval][out] */ __RPC__out double *__MIDL__IDxtJpeg0002);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ScaleX )( 
            IDxtJpeg * This,
            /* [in] */ double __MIDL__IDxtJpeg0003);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ScaleY )( 
            IDxtJpeg * This,
            /* [retval][out] */ __RPC__out double *__MIDL__IDxtJpeg0004);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ScaleY )( 
            IDxtJpeg * This,
            /* [in] */ double __MIDL__IDxtJpeg0005);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OffsetX )( 
            IDxtJpeg * This,
            /* [retval][out] */ __RPC__out long *__MIDL__IDxtJpeg0006);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OffsetX )( 
            IDxtJpeg * This,
            /* [in] */ long __MIDL__IDxtJpeg0007);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OffsetY )( 
            IDxtJpeg * This,
            /* [retval][out] */ __RPC__out long *__MIDL__IDxtJpeg0008);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OffsetY )( 
            IDxtJpeg * This,
            /* [in] */ long __MIDL__IDxtJpeg0009);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReplicateX )( 
            IDxtJpeg * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReplicateX )( 
            IDxtJpeg * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReplicateY )( 
            IDxtJpeg * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReplicateY )( 
            IDxtJpeg * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BorderColor )( 
            IDxtJpeg * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BorderColor )( 
            IDxtJpeg * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BorderWidth )( 
            IDxtJpeg * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BorderWidth )( 
            IDxtJpeg * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BorderSoftness )( 
            IDxtJpeg * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BorderSoftness )( 
            IDxtJpeg * This,
            /* [in] */ long newVal);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyChanges )( 
            IDxtJpeg * This);
        
        HRESULT ( STDMETHODCALLTYPE *LoadDefSettings )( 
            IDxtJpeg * This);
        
        END_INTERFACE
    } IDxtJpegVtbl;

    interface IDxtJpeg
    {
        CONST_VTBL struct IDxtJpegVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDxtJpeg_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDxtJpeg_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDxtJpeg_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDxtJpeg_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDxtJpeg_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDxtJpeg_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDxtJpeg_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDxtJpeg_get_Capabilities(This,pVal)	\
    ( (This)->lpVtbl -> get_Capabilities(This,pVal) ) 

#define IDxtJpeg_get_Progress(This,pVal)	\
    ( (This)->lpVtbl -> get_Progress(This,pVal) ) 

#define IDxtJpeg_put_Progress(This,newVal)	\
    ( (This)->lpVtbl -> put_Progress(This,newVal) ) 

#define IDxtJpeg_get_StepResolution(This,pVal)	\
    ( (This)->lpVtbl -> get_StepResolution(This,pVal) ) 

#define IDxtJpeg_get_Duration(This,pVal)	\
    ( (This)->lpVtbl -> get_Duration(This,pVal) ) 

#define IDxtJpeg_put_Duration(This,newVal)	\
    ( (This)->lpVtbl -> put_Duration(This,newVal) ) 


#define IDxtJpeg_get_MaskNum(This,__MIDL__IDxtJpeg0000)	\
    ( (This)->lpVtbl -> get_MaskNum(This,__MIDL__IDxtJpeg0000) ) 

#define IDxtJpeg_put_MaskNum(This,__MIDL__IDxtJpeg0001)	\
    ( (This)->lpVtbl -> put_MaskNum(This,__MIDL__IDxtJpeg0001) ) 

#define IDxtJpeg_get_MaskName(This,pVal)	\
    ( (This)->lpVtbl -> get_MaskName(This,pVal) ) 

#define IDxtJpeg_put_MaskName(This,newVal)	\
    ( (This)->lpVtbl -> put_MaskName(This,newVal) ) 

#define IDxtJpeg_get_ScaleX(This,__MIDL__IDxtJpeg0002)	\
    ( (This)->lpVtbl -> get_ScaleX(This,__MIDL__IDxtJpeg0002) ) 

#define IDxtJpeg_put_ScaleX(This,__MIDL__IDxtJpeg0003)	\
    ( (This)->lpVtbl -> put_ScaleX(This,__MIDL__IDxtJpeg0003) ) 

#define IDxtJpeg_get_ScaleY(This,__MIDL__IDxtJpeg0004)	\
    ( (This)->lpVtbl -> get_ScaleY(This,__MIDL__IDxtJpeg0004) ) 

#define IDxtJpeg_put_ScaleY(This,__MIDL__IDxtJpeg0005)	\
    ( (This)->lpVtbl -> put_ScaleY(This,__MIDL__IDxtJpeg0005) ) 

#define IDxtJpeg_get_OffsetX(This,__MIDL__IDxtJpeg0006)	\
    ( (This)->lpVtbl -> get_OffsetX(This,__MIDL__IDxtJpeg0006) ) 

#define IDxtJpeg_put_OffsetX(This,__MIDL__IDxtJpeg0007)	\
    ( (This)->lpVtbl -> put_OffsetX(This,__MIDL__IDxtJpeg0007) ) 

#define IDxtJpeg_get_OffsetY(This,__MIDL__IDxtJpeg0008)	\
    ( (This)->lpVtbl -> get_OffsetY(This,__MIDL__IDxtJpeg0008) ) 

#define IDxtJpeg_put_OffsetY(This,__MIDL__IDxtJpeg0009)	\
    ( (This)->lpVtbl -> put_OffsetY(This,__MIDL__IDxtJpeg0009) ) 

#define IDxtJpeg_get_ReplicateX(This,pVal)	\
    ( (This)->lpVtbl -> get_ReplicateX(This,pVal) ) 

#define IDxtJpeg_put_ReplicateX(This,newVal)	\
    ( (This)->lpVtbl -> put_ReplicateX(This,newVal) ) 

#define IDxtJpeg_get_ReplicateY(This,pVal)	\
    ( (This)->lpVtbl -> get_ReplicateY(This,pVal) ) 

#define IDxtJpeg_put_ReplicateY(This,newVal)	\
    ( (This)->lpVtbl -> put_ReplicateY(This,newVal) ) 

#define IDxtJpeg_get_BorderColor(This,pVal)	\
    ( (This)->lpVtbl -> get_BorderColor(This,pVal) ) 

#define IDxtJpeg_put_BorderColor(This,newVal)	\
    ( (This)->lpVtbl -> put_BorderColor(This,newVal) ) 

#define IDxtJpeg_get_BorderWidth(This,pVal)	\
    ( (This)->lpVtbl -> get_BorderWidth(This,pVal) ) 

#define IDxtJpeg_put_BorderWidth(This,newVal)	\
    ( (This)->lpVtbl -> put_BorderWidth(This,newVal) ) 

#define IDxtJpeg_get_BorderSoftness(This,pVal)	\
    ( (This)->lpVtbl -> get_BorderSoftness(This,pVal) ) 

#define IDxtJpeg_put_BorderSoftness(This,newVal)	\
    ( (This)->lpVtbl -> put_BorderSoftness(This,newVal) ) 

#define IDxtJpeg_ApplyChanges(This)	\
    ( (This)->lpVtbl -> ApplyChanges(This) ) 

#define IDxtJpeg_LoadDefSettings(This)	\
    ( (This)->lpVtbl -> LoadDefSettings(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDxtJpeg_INTERFACE_DEFINED__ */


#ifndef __IDxtKey_INTERFACE_DEFINED__
#define __IDxtKey_INTERFACE_DEFINED__

/* interface IDxtKey */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDxtKey;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3255de56-38fb-4901-b980-94b438010d7b")
    IDxtKey : public IDXEffect
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_KeyType( 
            /* [retval][out] */ __RPC__out int *__MIDL__IDxtKey0000) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_KeyType( 
            /* [in] */ int __MIDL__IDxtKey0001) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Hue( 
            /* [retval][out] */ __RPC__out int *__MIDL__IDxtKey0002) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Hue( 
            /* [in] */ int __MIDL__IDxtKey0003) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Luminance( 
            /* [retval][out] */ __RPC__out int *__MIDL__IDxtKey0004) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Luminance( 
            /* [in] */ int __MIDL__IDxtKey0005) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RGB( 
            /* [retval][out] */ __RPC__out DWORD *__MIDL__IDxtKey0006) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RGB( 
            /* [in] */ DWORD __MIDL__IDxtKey0007) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Similarity( 
            /* [retval][out] */ __RPC__out int *__MIDL__IDxtKey0008) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Similarity( 
            /* [in] */ int __MIDL__IDxtKey0009) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Invert( 
            /* [retval][out] */ __RPC__out BOOL *__MIDL__IDxtKey0010) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Invert( 
            /* [in] */ BOOL __MIDL__IDxtKey0011) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDxtKeyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDxtKey * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDxtKey * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDxtKey * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDxtKey * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDxtKey * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDxtKey * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDxtKey * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Capabilities )( 
            IDxtKey * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Progress )( 
            IDxtKey * This,
            /* [retval][out] */ __RPC__out float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Progress )( 
            IDxtKey * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StepResolution )( 
            IDxtKey * This,
            /* [retval][out] */ __RPC__out float *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IDxtKey * This,
            /* [retval][out] */ __RPC__out float *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            IDxtKey * This,
            /* [in] */ float newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeyType )( 
            IDxtKey * This,
            /* [retval][out] */ __RPC__out int *__MIDL__IDxtKey0000);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeyType )( 
            IDxtKey * This,
            /* [in] */ int __MIDL__IDxtKey0001);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Hue )( 
            IDxtKey * This,
            /* [retval][out] */ __RPC__out int *__MIDL__IDxtKey0002);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Hue )( 
            IDxtKey * This,
            /* [in] */ int __MIDL__IDxtKey0003);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Luminance )( 
            IDxtKey * This,
            /* [retval][out] */ __RPC__out int *__MIDL__IDxtKey0004);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Luminance )( 
            IDxtKey * This,
            /* [in] */ int __MIDL__IDxtKey0005);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RGB )( 
            IDxtKey * This,
            /* [retval][out] */ __RPC__out DWORD *__MIDL__IDxtKey0006);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RGB )( 
            IDxtKey * This,
            /* [in] */ DWORD __MIDL__IDxtKey0007);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Similarity )( 
            IDxtKey * This,
            /* [retval][out] */ __RPC__out int *__MIDL__IDxtKey0008);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Similarity )( 
            IDxtKey * This,
            /* [in] */ int __MIDL__IDxtKey0009);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Invert )( 
            IDxtKey * This,
            /* [retval][out] */ __RPC__out BOOL *__MIDL__IDxtKey0010);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Invert )( 
            IDxtKey * This,
            /* [in] */ BOOL __MIDL__IDxtKey0011);
        
        END_INTERFACE
    } IDxtKeyVtbl;

    interface IDxtKey
    {
        CONST_VTBL struct IDxtKeyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDxtKey_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDxtKey_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDxtKey_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDxtKey_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDxtKey_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDxtKey_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDxtKey_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDxtKey_get_Capabilities(This,pVal)	\
    ( (This)->lpVtbl -> get_Capabilities(This,pVal) ) 

#define IDxtKey_get_Progress(This,pVal)	\
    ( (This)->lpVtbl -> get_Progress(This,pVal) ) 

#define IDxtKey_put_Progress(This,newVal)	\
    ( (This)->lpVtbl -> put_Progress(This,newVal) ) 

#define IDxtKey_get_StepResolution(This,pVal)	\
    ( (This)->lpVtbl -> get_StepResolution(This,pVal) ) 

#define IDxtKey_get_Duration(This,pVal)	\
    ( (This)->lpVtbl -> get_Duration(This,pVal) ) 

#define IDxtKey_put_Duration(This,newVal)	\
    ( (This)->lpVtbl -> put_Duration(This,newVal) ) 


#define IDxtKey_get_KeyType(This,__MIDL__IDxtKey0000)	\
    ( (This)->lpVtbl -> get_KeyType(This,__MIDL__IDxtKey0000) ) 

#define IDxtKey_put_KeyType(This,__MIDL__IDxtKey0001)	\
    ( (This)->lpVtbl -> put_KeyType(This,__MIDL__IDxtKey0001) ) 

#define IDxtKey_get_Hue(This,__MIDL__IDxtKey0002)	\
    ( (This)->lpVtbl -> get_Hue(This,__MIDL__IDxtKey0002) ) 

#define IDxtKey_put_Hue(This,__MIDL__IDxtKey0003)	\
    ( (This)->lpVtbl -> put_Hue(This,__MIDL__IDxtKey0003) ) 

#define IDxtKey_get_Luminance(This,__MIDL__IDxtKey0004)	\
    ( (This)->lpVtbl -> get_Luminance(This,__MIDL__IDxtKey0004) ) 

#define IDxtKey_put_Luminance(This,__MIDL__IDxtKey0005)	\
    ( (This)->lpVtbl -> put_Luminance(This,__MIDL__IDxtKey0005) ) 

#define IDxtKey_get_RGB(This,__MIDL__IDxtKey0006)	\
    ( (This)->lpVtbl -> get_RGB(This,__MIDL__IDxtKey0006) ) 

#define IDxtKey_put_RGB(This,__MIDL__IDxtKey0007)	\
    ( (This)->lpVtbl -> put_RGB(This,__MIDL__IDxtKey0007) ) 

#define IDxtKey_get_Similarity(This,__MIDL__IDxtKey0008)	\
    ( (This)->lpVtbl -> get_Similarity(This,__MIDL__IDxtKey0008) ) 

#define IDxtKey_put_Similarity(This,__MIDL__IDxtKey0009)	\
    ( (This)->lpVtbl -> put_Similarity(This,__MIDL__IDxtKey0009) ) 

#define IDxtKey_get_Invert(This,__MIDL__IDxtKey0010)	\
    ( (This)->lpVtbl -> get_Invert(This,__MIDL__IDxtKey0010) ) 

#define IDxtKey_put_Invert(This,__MIDL__IDxtKey0011)	\
    ( (This)->lpVtbl -> put_Invert(This,__MIDL__IDxtKey0011) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDxtKey_INTERFACE_DEFINED__ */


#ifndef __IMediaLocator_INTERFACE_DEFINED__
#define __IMediaLocator_INTERFACE_DEFINED__

/* interface IMediaLocator */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMediaLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("288581E0-66CE-11d2-918F-00C0DF10D434")
    IMediaLocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindMediaFile( 
            __RPC__in BSTR Input,
            __RPC__in BSTR FilterString,
            __RPC__deref_in_opt BSTR *pOutput,
            long Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFoundLocation( 
            __RPC__in BSTR DirectoryName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaLocator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaLocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaLocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *FindMediaFile )( 
            IMediaLocator * This,
            __RPC__in BSTR Input,
            __RPC__in BSTR FilterString,
            __RPC__deref_in_opt BSTR *pOutput,
            long Flags);
        
        HRESULT ( STDMETHODCALLTYPE *AddFoundLocation )( 
            IMediaLocator * This,
            __RPC__in BSTR DirectoryName);
        
        END_INTERFACE
    } IMediaLocatorVtbl;

    interface IMediaLocator
    {
        CONST_VTBL struct IMediaLocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaLocator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaLocator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaLocator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaLocator_FindMediaFile(This,Input,FilterString,pOutput,Flags)	\
    ( (This)->lpVtbl -> FindMediaFile(This,Input,FilterString,pOutput,Flags) ) 

#define IMediaLocator_AddFoundLocation(This,DirectoryName)	\
    ( (This)->lpVtbl -> AddFoundLocation(This,DirectoryName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaLocator_INTERFACE_DEFINED__ */


#ifndef __IMediaDet_INTERFACE_DEFINED__
#define __IMediaDet_INTERFACE_DEFINED__

/* interface IMediaDet */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMediaDet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("65BD0710-24D2-4ff7-9324-ED2E5D3ABAFA")
    IMediaDet : public IUnknown
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Filter( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Filter( 
            /* [in] */ __RPC__in_opt IUnknown *newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OutputStreams( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentStream( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CurrentStream( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamType( 
            /* [retval][out] */ __RPC__out GUID *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamTypeB( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamLength( 
            /* [retval][out] */ __RPC__out double *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Filename( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Filename( 
            /* [in] */ __RPC__in BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetBitmapBits( 
            double StreamTime,
            __RPC__in long *pBufferSize,
            __RPC__in char *pBuffer,
            long Width,
            long Height) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WriteBitmapBits( 
            double StreamTime,
            long Width,
            long Height,
            __RPC__in BSTR Filename) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StreamMediaType( 
            /* [retval][out] */ __RPC__out AM_MEDIA_TYPE *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSampleGrabber( 
            /* [out] */ __RPC__deref_out_opt ISampleGrabber **ppVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FrameRate( 
            /* [retval][out] */ __RPC__out double *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnterBitmapGrabMode( 
            double SeekTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaDetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaDet * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaDet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaDet * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Filter )( 
            IMediaDet * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Filter )( 
            IMediaDet * This,
            /* [in] */ __RPC__in_opt IUnknown *newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OutputStreams )( 
            IMediaDet * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentStream )( 
            IMediaDet * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentStream )( 
            IMediaDet * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamType )( 
            IMediaDet * This,
            /* [retval][out] */ __RPC__out GUID *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamTypeB )( 
            IMediaDet * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamLength )( 
            IMediaDet * This,
            /* [retval][out] */ __RPC__out double *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Filename )( 
            IMediaDet * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Filename )( 
            IMediaDet * This,
            /* [in] */ __RPC__in BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetBitmapBits )( 
            IMediaDet * This,
            double StreamTime,
            __RPC__in long *pBufferSize,
            __RPC__in char *pBuffer,
            long Width,
            long Height);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *WriteBitmapBits )( 
            IMediaDet * This,
            double StreamTime,
            long Width,
            long Height,
            __RPC__in BSTR Filename);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StreamMediaType )( 
            IMediaDet * This,
            /* [retval][out] */ __RPC__out AM_MEDIA_TYPE *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSampleGrabber )( 
            IMediaDet * This,
            /* [out] */ __RPC__deref_out_opt ISampleGrabber **ppVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FrameRate )( 
            IMediaDet * This,
            /* [retval][out] */ __RPC__out double *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnterBitmapGrabMode )( 
            IMediaDet * This,
            double SeekTime);
        
        END_INTERFACE
    } IMediaDetVtbl;

    interface IMediaDet
    {
        CONST_VTBL struct IMediaDetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaDet_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaDet_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaDet_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaDet_get_Filter(This,pVal)	\
    ( (This)->lpVtbl -> get_Filter(This,pVal) ) 

#define IMediaDet_put_Filter(This,newVal)	\
    ( (This)->lpVtbl -> put_Filter(This,newVal) ) 

#define IMediaDet_get_OutputStreams(This,pVal)	\
    ( (This)->lpVtbl -> get_OutputStreams(This,pVal) ) 

#define IMediaDet_get_CurrentStream(This,pVal)	\
    ( (This)->lpVtbl -> get_CurrentStream(This,pVal) ) 

#define IMediaDet_put_CurrentStream(This,newVal)	\
    ( (This)->lpVtbl -> put_CurrentStream(This,newVal) ) 

#define IMediaDet_get_StreamType(This,pVal)	\
    ( (This)->lpVtbl -> get_StreamType(This,pVal) ) 

#define IMediaDet_get_StreamTypeB(This,pVal)	\
    ( (This)->lpVtbl -> get_StreamTypeB(This,pVal) ) 

#define IMediaDet_get_StreamLength(This,pVal)	\
    ( (This)->lpVtbl -> get_StreamLength(This,pVal) ) 

#define IMediaDet_get_Filename(This,pVal)	\
    ( (This)->lpVtbl -> get_Filename(This,pVal) ) 

#define IMediaDet_put_Filename(This,newVal)	\
    ( (This)->lpVtbl -> put_Filename(This,newVal) ) 

#define IMediaDet_GetBitmapBits(This,StreamTime,pBufferSize,pBuffer,Width,Height)	\
    ( (This)->lpVtbl -> GetBitmapBits(This,StreamTime,pBufferSize,pBuffer,Width,Height) ) 

#define IMediaDet_WriteBitmapBits(This,StreamTime,Width,Height,Filename)	\
    ( (This)->lpVtbl -> WriteBitmapBits(This,StreamTime,Width,Height,Filename) ) 

#define IMediaDet_get_StreamMediaType(This,pVal)	\
    ( (This)->lpVtbl -> get_StreamMediaType(This,pVal) ) 

#define IMediaDet_GetSampleGrabber(This,ppVal)	\
    ( (This)->lpVtbl -> GetSampleGrabber(This,ppVal) ) 

#define IMediaDet_get_FrameRate(This,pVal)	\
    ( (This)->lpVtbl -> get_FrameRate(This,pVal) ) 

#define IMediaDet_EnterBitmapGrabMode(This,SeekTime)	\
    ( (This)->lpVtbl -> EnterBitmapGrabMode(This,SeekTime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaDet_INTERFACE_DEFINED__ */


#ifndef __IGrfCache_INTERFACE_DEFINED__
#define __IGrfCache_INTERFACE_DEFINED__

/* interface IGrfCache */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IGrfCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AE9472BE-B0C3-11D2-8D24-00A0C9441E20")
    IGrfCache : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddFilter( 
            __RPC__in_opt IGrfCache *ChainedCache,
            LONGLONG ID,
            __RPC__in_opt const IBaseFilter *pFilter,
            __RPC__in LPCWSTR pName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConnectPins( 
            __RPC__in_opt IGrfCache *ChainedCache,
            LONGLONG PinID1,
            __RPC__in_opt const IPin *pPin1,
            LONGLONG PinID2,
            __RPC__in_opt const IPin *pPin2) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetGraph( 
            __RPC__in_opt const IGraphBuilder *pGraph) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoConnectionsNow( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGrfCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGrfCache * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGrfCache * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGrfCache * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGrfCache * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGrfCache * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGrfCache * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGrfCache * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddFilter )( 
            IGrfCache * This,
            __RPC__in_opt IGrfCache *ChainedCache,
            LONGLONG ID,
            __RPC__in_opt const IBaseFilter *pFilter,
            __RPC__in LPCWSTR pName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ConnectPins )( 
            IGrfCache * This,
            __RPC__in_opt IGrfCache *ChainedCache,
            LONGLONG PinID1,
            __RPC__in_opt const IPin *pPin1,
            LONGLONG PinID2,
            __RPC__in_opt const IPin *pPin2);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetGraph )( 
            IGrfCache * This,
            __RPC__in_opt const IGraphBuilder *pGraph);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DoConnectionsNow )( 
            IGrfCache * This);
        
        END_INTERFACE
    } IGrfCacheVtbl;

    interface IGrfCache
    {
        CONST_VTBL struct IGrfCacheVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGrfCache_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGrfCache_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGrfCache_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGrfCache_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IGrfCache_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IGrfCache_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IGrfCache_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IGrfCache_AddFilter(This,ChainedCache,ID,pFilter,pName)	\
    ( (This)->lpVtbl -> AddFilter(This,ChainedCache,ID,pFilter,pName) ) 

#define IGrfCache_ConnectPins(This,ChainedCache,PinID1,pPin1,PinID2,pPin2)	\
    ( (This)->lpVtbl -> ConnectPins(This,ChainedCache,PinID1,pPin1,PinID2,pPin2) ) 

#define IGrfCache_SetGraph(This,pGraph)	\
    ( (This)->lpVtbl -> SetGraph(This,pGraph) ) 

#define IGrfCache_DoConnectionsNow(This)	\
    ( (This)->lpVtbl -> DoConnectionsNow(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGrfCache_INTERFACE_DEFINED__ */


#ifndef __IRenderEngine_INTERFACE_DEFINED__
#define __IRenderEngine_INTERFACE_DEFINED__

/* interface IRenderEngine */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRenderEngine;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6BEE3A81-66C9-11d2-918F-00C0DF10D434")
    IRenderEngine : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetTimelineObject( 
            __RPC__in_opt IAMTimeline *pTimeline) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimelineObject( 
            /* [out] */ __RPC__deref_out_opt IAMTimeline **ppTimeline) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilterGraph( 
            /* [out] */ __RPC__deref_out_opt IGraphBuilder **ppFG) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFilterGraph( 
            __RPC__in_opt IGraphBuilder *pFG) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInterestRange( 
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInterestRange2( 
            double Start,
            double Stop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRenderRange( 
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRenderRange2( 
            double Start,
            double Stop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupOutputPin( 
            long Group,
            /* [out] */ __RPC__deref_out_opt IPin **ppRenderPin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ScrapIt( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenderOutputPins( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVendorString( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVendorID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectFrontEnd( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSourceConnectCallback( 
            __RPC__in_opt IGrfCache *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDynamicReconnectLevel( 
            long Level) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoSmartRecompression( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UseInSmartRecompressionGraph( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSourceNameValidation( 
            __RPC__in BSTR FilterString,
            __RPC__in_opt IMediaLocator *pOverride,
            LONG Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Decommit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCaps( 
            long Index,
            __RPC__in long *pReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRenderEngineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRenderEngine * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRenderEngine * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRenderEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimelineObject )( 
            IRenderEngine * This,
            __RPC__in_opt IAMTimeline *pTimeline);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimelineObject )( 
            IRenderEngine * This,
            /* [out] */ __RPC__deref_out_opt IAMTimeline **ppTimeline);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilterGraph )( 
            IRenderEngine * This,
            /* [out] */ __RPC__deref_out_opt IGraphBuilder **ppFG);
        
        HRESULT ( STDMETHODCALLTYPE *SetFilterGraph )( 
            IRenderEngine * This,
            __RPC__in_opt IGraphBuilder *pFG);
        
        HRESULT ( STDMETHODCALLTYPE *SetInterestRange )( 
            IRenderEngine * This,
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop);
        
        HRESULT ( STDMETHODCALLTYPE *SetInterestRange2 )( 
            IRenderEngine * This,
            double Start,
            double Stop);
        
        HRESULT ( STDMETHODCALLTYPE *SetRenderRange )( 
            IRenderEngine * This,
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop);
        
        HRESULT ( STDMETHODCALLTYPE *SetRenderRange2 )( 
            IRenderEngine * This,
            double Start,
            double Stop);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupOutputPin )( 
            IRenderEngine * This,
            long Group,
            /* [out] */ __RPC__deref_out_opt IPin **ppRenderPin);
        
        HRESULT ( STDMETHODCALLTYPE *ScrapIt )( 
            IRenderEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *RenderOutputPins )( 
            IRenderEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVendorString )( 
            IRenderEngine * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVendorID);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectFrontEnd )( 
            IRenderEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSourceConnectCallback )( 
            IRenderEngine * This,
            __RPC__in_opt IGrfCache *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *SetDynamicReconnectLevel )( 
            IRenderEngine * This,
            long Level);
        
        HRESULT ( STDMETHODCALLTYPE *DoSmartRecompression )( 
            IRenderEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *UseInSmartRecompressionGraph )( 
            IRenderEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSourceNameValidation )( 
            IRenderEngine * This,
            __RPC__in BSTR FilterString,
            __RPC__in_opt IMediaLocator *pOverride,
            LONG Flags);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IRenderEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *Decommit )( 
            IRenderEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCaps )( 
            IRenderEngine * This,
            long Index,
            __RPC__in long *pReturn);
        
        END_INTERFACE
    } IRenderEngineVtbl;

    interface IRenderEngine
    {
        CONST_VTBL struct IRenderEngineVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRenderEngine_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRenderEngine_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRenderEngine_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRenderEngine_SetTimelineObject(This,pTimeline)	\
    ( (This)->lpVtbl -> SetTimelineObject(This,pTimeline) ) 

#define IRenderEngine_GetTimelineObject(This,ppTimeline)	\
    ( (This)->lpVtbl -> GetTimelineObject(This,ppTimeline) ) 

#define IRenderEngine_GetFilterGraph(This,ppFG)	\
    ( (This)->lpVtbl -> GetFilterGraph(This,ppFG) ) 

#define IRenderEngine_SetFilterGraph(This,pFG)	\
    ( (This)->lpVtbl -> SetFilterGraph(This,pFG) ) 

#define IRenderEngine_SetInterestRange(This,Start,Stop)	\
    ( (This)->lpVtbl -> SetInterestRange(This,Start,Stop) ) 

#define IRenderEngine_SetInterestRange2(This,Start,Stop)	\
    ( (This)->lpVtbl -> SetInterestRange2(This,Start,Stop) ) 

#define IRenderEngine_SetRenderRange(This,Start,Stop)	\
    ( (This)->lpVtbl -> SetRenderRange(This,Start,Stop) ) 

#define IRenderEngine_SetRenderRange2(This,Start,Stop)	\
    ( (This)->lpVtbl -> SetRenderRange2(This,Start,Stop) ) 

#define IRenderEngine_GetGroupOutputPin(This,Group,ppRenderPin)	\
    ( (This)->lpVtbl -> GetGroupOutputPin(This,Group,ppRenderPin) ) 

#define IRenderEngine_ScrapIt(This)	\
    ( (This)->lpVtbl -> ScrapIt(This) ) 

#define IRenderEngine_RenderOutputPins(This)	\
    ( (This)->lpVtbl -> RenderOutputPins(This) ) 

#define IRenderEngine_GetVendorString(This,pVendorID)	\
    ( (This)->lpVtbl -> GetVendorString(This,pVendorID) ) 

#define IRenderEngine_ConnectFrontEnd(This)	\
    ( (This)->lpVtbl -> ConnectFrontEnd(This) ) 

#define IRenderEngine_SetSourceConnectCallback(This,pCallback)	\
    ( (This)->lpVtbl -> SetSourceConnectCallback(This,pCallback) ) 

#define IRenderEngine_SetDynamicReconnectLevel(This,Level)	\
    ( (This)->lpVtbl -> SetDynamicReconnectLevel(This,Level) ) 

#define IRenderEngine_DoSmartRecompression(This)	\
    ( (This)->lpVtbl -> DoSmartRecompression(This) ) 

#define IRenderEngine_UseInSmartRecompressionGraph(This)	\
    ( (This)->lpVtbl -> UseInSmartRecompressionGraph(This) ) 

#define IRenderEngine_SetSourceNameValidation(This,FilterString,pOverride,Flags)	\
    ( (This)->lpVtbl -> SetSourceNameValidation(This,FilterString,pOverride,Flags) ) 

#define IRenderEngine_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 

#define IRenderEngine_Decommit(This)	\
    ( (This)->lpVtbl -> Decommit(This) ) 

#define IRenderEngine_GetCaps(This,Index,pReturn)	\
    ( (This)->lpVtbl -> GetCaps(This,Index,pReturn) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRenderEngine_INTERFACE_DEFINED__ */


#ifndef __IRenderEngine2_INTERFACE_DEFINED__
#define __IRenderEngine2_INTERFACE_DEFINED__

/* interface IRenderEngine2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRenderEngine2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6BEE3A82-66C9-11d2-918F-00C0DF10D434")
    IRenderEngine2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetResizerGUID( 
            GUID ResizerGuid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRenderEngine2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRenderEngine2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRenderEngine2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRenderEngine2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetResizerGUID )( 
            IRenderEngine2 * This,
            GUID ResizerGuid);
        
        END_INTERFACE
    } IRenderEngine2Vtbl;

    interface IRenderEngine2
    {
        CONST_VTBL struct IRenderEngine2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRenderEngine2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRenderEngine2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRenderEngine2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRenderEngine2_SetResizerGUID(This,ResizerGuid)	\
    ( (This)->lpVtbl -> SetResizerGUID(This,ResizerGuid) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRenderEngine2_INTERFACE_DEFINED__ */


#ifndef __IFindCompressorCB_INTERFACE_DEFINED__
#define __IFindCompressorCB_INTERFACE_DEFINED__

/* interface IFindCompressorCB */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IFindCompressorCB;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F03FA8DE-879A-4d59-9B2C-26BB1CF83461")
    IFindCompressorCB : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCompressor( 
            __RPC__in AM_MEDIA_TYPE *pType,
            __RPC__in AM_MEDIA_TYPE *pCompType,
            /* [out] */ __RPC__deref_out_opt IBaseFilter **ppFilter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFindCompressorCBVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFindCompressorCB * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFindCompressorCB * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFindCompressorCB * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompressor )( 
            IFindCompressorCB * This,
            __RPC__in AM_MEDIA_TYPE *pType,
            __RPC__in AM_MEDIA_TYPE *pCompType,
            /* [out] */ __RPC__deref_out_opt IBaseFilter **ppFilter);
        
        END_INTERFACE
    } IFindCompressorCBVtbl;

    interface IFindCompressorCB
    {
        CONST_VTBL struct IFindCompressorCBVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFindCompressorCB_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFindCompressorCB_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFindCompressorCB_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFindCompressorCB_GetCompressor(This,pType,pCompType,ppFilter)	\
    ( (This)->lpVtbl -> GetCompressor(This,pType,pCompType,ppFilter) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFindCompressorCB_INTERFACE_DEFINED__ */


#ifndef __ISmartRenderEngine_INTERFACE_DEFINED__
#define __ISmartRenderEngine_INTERFACE_DEFINED__

/* interface ISmartRenderEngine */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISmartRenderEngine;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F03FA8CE-879A-4d59-9B2C-26BB1CF83461")
    ISmartRenderEngine : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetGroupCompressor( 
            long Group,
            __RPC__in_opt IBaseFilter *pCompressor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupCompressor( 
            long Group,
            __RPC__deref_in_opt IBaseFilter **pCompressor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFindCompressorCB( 
            __RPC__in_opt IFindCompressorCB *pCallback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISmartRenderEngineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISmartRenderEngine * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISmartRenderEngine * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISmartRenderEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetGroupCompressor )( 
            ISmartRenderEngine * This,
            long Group,
            __RPC__in_opt IBaseFilter *pCompressor);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupCompressor )( 
            ISmartRenderEngine * This,
            long Group,
            __RPC__deref_in_opt IBaseFilter **pCompressor);
        
        HRESULT ( STDMETHODCALLTYPE *SetFindCompressorCB )( 
            ISmartRenderEngine * This,
            __RPC__in_opt IFindCompressorCB *pCallback);
        
        END_INTERFACE
    } ISmartRenderEngineVtbl;

    interface ISmartRenderEngine
    {
        CONST_VTBL struct ISmartRenderEngineVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISmartRenderEngine_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISmartRenderEngine_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISmartRenderEngine_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISmartRenderEngine_SetGroupCompressor(This,Group,pCompressor)	\
    ( (This)->lpVtbl -> SetGroupCompressor(This,Group,pCompressor) ) 

#define ISmartRenderEngine_GetGroupCompressor(This,Group,pCompressor)	\
    ( (This)->lpVtbl -> GetGroupCompressor(This,Group,pCompressor) ) 

#define ISmartRenderEngine_SetFindCompressorCB(This,pCallback)	\
    ( (This)->lpVtbl -> SetFindCompressorCB(This,pCallback) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISmartRenderEngine_INTERFACE_DEFINED__ */


#ifndef __IAMTimelineObj_INTERFACE_DEFINED__
#define __IAMTimelineObj_INTERFACE_DEFINED__

/* interface IAMTimelineObj */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IAMTimelineObj;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("78530B77-61F9-11D2-8CAD-00A024580902")
    IAMTimelineObj : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStartStop( 
            REFERENCE_TIME *pStart,
            REFERENCE_TIME *pStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStartStop2( 
            REFTIME *pStart,
            REFTIME *pStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FixTimes( 
            REFERENCE_TIME *pStart,
            REFERENCE_TIME *pStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FixTimes2( 
            REFTIME *pStart,
            REFTIME *pStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStartStop( 
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStartStop2( 
            REFTIME Start,
            REFTIME Stop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPropertySetter( 
            /* [retval][out] */ IPropertySetter **pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPropertySetter( 
            IPropertySetter *newVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubObject( 
            /* [retval][out] */ IUnknown **pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSubObject( 
            IUnknown *newVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSubObjectGUID( 
            GUID newVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSubObjectGUIDB( 
            BSTR newVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubObjectGUID( 
            GUID *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubObjectGUIDB( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubObjectLoaded( 
            BOOL *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTimelineType( 
            TIMELINE_MAJOR_TYPE *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetTimelineType( 
            TIMELINE_MAJOR_TYPE newVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetUserID( 
            long *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetUserID( 
            long newVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetGenID( 
            long *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetUserName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetUserName( 
            BSTR newVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetUserData( 
            BYTE *pData,
            long *pSize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetUserData( 
            BYTE *pData,
            long Size) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMuted( 
            BOOL *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMuted( 
            BOOL newVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLocked( 
            BOOL *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetLocked( 
            BOOL newVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDirtyRange( 
            REFERENCE_TIME *pStart,
            REFERENCE_TIME *pStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDirtyRange2( 
            REFTIME *pStart,
            REFTIME *pStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDirtyRange( 
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDirtyRange2( 
            REFTIME Start,
            REFTIME Stop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ClearDirty( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Remove( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveAll( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimelineNoRef( 
            IAMTimeline **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupIBelongTo( 
            /* [out] */ IAMTimelineGroup **ppGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEmbedDepth( 
            long *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineObjVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimelineObj * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimelineObj * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimelineObj * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetStartStop )( 
            IAMTimelineObj * This,
            REFERENCE_TIME *pStart,
            REFERENCE_TIME *pStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetStartStop2 )( 
            IAMTimelineObj * This,
            REFTIME *pStart,
            REFTIME *pStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FixTimes )( 
            IAMTimelineObj * This,
            REFERENCE_TIME *pStart,
            REFERENCE_TIME *pStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FixTimes2 )( 
            IAMTimelineObj * This,
            REFTIME *pStart,
            REFTIME *pStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStartStop )( 
            IAMTimelineObj * This,
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStartStop2 )( 
            IAMTimelineObj * This,
            REFTIME Start,
            REFTIME Stop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPropertySetter )( 
            IAMTimelineObj * This,
            /* [retval][out] */ IPropertySetter **pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPropertySetter )( 
            IAMTimelineObj * This,
            IPropertySetter *newVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubObject )( 
            IAMTimelineObj * This,
            /* [retval][out] */ IUnknown **pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSubObject )( 
            IAMTimelineObj * This,
            IUnknown *newVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSubObjectGUID )( 
            IAMTimelineObj * This,
            GUID newVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSubObjectGUIDB )( 
            IAMTimelineObj * This,
            BSTR newVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubObjectGUID )( 
            IAMTimelineObj * This,
            GUID *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubObjectGUIDB )( 
            IAMTimelineObj * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubObjectLoaded )( 
            IAMTimelineObj * This,
            BOOL *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTimelineType )( 
            IAMTimelineObj * This,
            TIMELINE_MAJOR_TYPE *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetTimelineType )( 
            IAMTimelineObj * This,
            TIMELINE_MAJOR_TYPE newVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetUserID )( 
            IAMTimelineObj * This,
            long *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetUserID )( 
            IAMTimelineObj * This,
            long newVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetGenID )( 
            IAMTimelineObj * This,
            long *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetUserName )( 
            IAMTimelineObj * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetUserName )( 
            IAMTimelineObj * This,
            BSTR newVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetUserData )( 
            IAMTimelineObj * This,
            BYTE *pData,
            long *pSize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetUserData )( 
            IAMTimelineObj * This,
            BYTE *pData,
            long Size);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMuted )( 
            IAMTimelineObj * This,
            BOOL *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMuted )( 
            IAMTimelineObj * This,
            BOOL newVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetLocked )( 
            IAMTimelineObj * This,
            BOOL *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetLocked )( 
            IAMTimelineObj * This,
            BOOL newVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDirtyRange )( 
            IAMTimelineObj * This,
            REFERENCE_TIME *pStart,
            REFERENCE_TIME *pStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDirtyRange2 )( 
            IAMTimelineObj * This,
            REFTIME *pStart,
            REFTIME *pStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetDirtyRange )( 
            IAMTimelineObj * This,
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetDirtyRange2 )( 
            IAMTimelineObj * This,
            REFTIME Start,
            REFTIME Stop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ClearDirty )( 
            IAMTimelineObj * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IAMTimelineObj * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveAll )( 
            IAMTimelineObj * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimelineNoRef )( 
            IAMTimelineObj * This,
            IAMTimeline **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupIBelongTo )( 
            IAMTimelineObj * This,
            /* [out] */ IAMTimelineGroup **ppGroup);
        
        HRESULT ( STDMETHODCALLTYPE *GetEmbedDepth )( 
            IAMTimelineObj * This,
            long *pVal);
        
        END_INTERFACE
    } IAMTimelineObjVtbl;

    interface IAMTimelineObj
    {
        CONST_VTBL struct IAMTimelineObjVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimelineObj_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMTimelineObj_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMTimelineObj_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMTimelineObj_GetStartStop(This,pStart,pStop)	\
    ( (This)->lpVtbl -> GetStartStop(This,pStart,pStop) ) 

#define IAMTimelineObj_GetStartStop2(This,pStart,pStop)	\
    ( (This)->lpVtbl -> GetStartStop2(This,pStart,pStop) ) 

#define IAMTimelineObj_FixTimes(This,pStart,pStop)	\
    ( (This)->lpVtbl -> FixTimes(This,pStart,pStop) ) 

#define IAMTimelineObj_FixTimes2(This,pStart,pStop)	\
    ( (This)->lpVtbl -> FixTimes2(This,pStart,pStop) ) 

#define IAMTimelineObj_SetStartStop(This,Start,Stop)	\
    ( (This)->lpVtbl -> SetStartStop(This,Start,Stop) ) 

#define IAMTimelineObj_SetStartStop2(This,Start,Stop)	\
    ( (This)->lpVtbl -> SetStartStop2(This,Start,Stop) ) 

#define IAMTimelineObj_GetPropertySetter(This,pVal)	\
    ( (This)->lpVtbl -> GetPropertySetter(This,pVal) ) 

#define IAMTimelineObj_SetPropertySetter(This,newVal)	\
    ( (This)->lpVtbl -> SetPropertySetter(This,newVal) ) 

#define IAMTimelineObj_GetSubObject(This,pVal)	\
    ( (This)->lpVtbl -> GetSubObject(This,pVal) ) 

#define IAMTimelineObj_SetSubObject(This,newVal)	\
    ( (This)->lpVtbl -> SetSubObject(This,newVal) ) 

#define IAMTimelineObj_SetSubObjectGUID(This,newVal)	\
    ( (This)->lpVtbl -> SetSubObjectGUID(This,newVal) ) 

#define IAMTimelineObj_SetSubObjectGUIDB(This,newVal)	\
    ( (This)->lpVtbl -> SetSubObjectGUIDB(This,newVal) ) 

#define IAMTimelineObj_GetSubObjectGUID(This,pVal)	\
    ( (This)->lpVtbl -> GetSubObjectGUID(This,pVal) ) 

#define IAMTimelineObj_GetSubObjectGUIDB(This,pVal)	\
    ( (This)->lpVtbl -> GetSubObjectGUIDB(This,pVal) ) 

#define IAMTimelineObj_GetSubObjectLoaded(This,pVal)	\
    ( (This)->lpVtbl -> GetSubObjectLoaded(This,pVal) ) 

#define IAMTimelineObj_GetTimelineType(This,pVal)	\
    ( (This)->lpVtbl -> GetTimelineType(This,pVal) ) 

#define IAMTimelineObj_SetTimelineType(This,newVal)	\
    ( (This)->lpVtbl -> SetTimelineType(This,newVal) ) 

#define IAMTimelineObj_GetUserID(This,pVal)	\
    ( (This)->lpVtbl -> GetUserID(This,pVal) ) 

#define IAMTimelineObj_SetUserID(This,newVal)	\
    ( (This)->lpVtbl -> SetUserID(This,newVal) ) 

#define IAMTimelineObj_GetGenID(This,pVal)	\
    ( (This)->lpVtbl -> GetGenID(This,pVal) ) 

#define IAMTimelineObj_GetUserName(This,pVal)	\
    ( (This)->lpVtbl -> GetUserName(This,pVal) ) 

#define IAMTimelineObj_SetUserName(This,newVal)	\
    ( (This)->lpVtbl -> SetUserName(This,newVal) ) 

#define IAMTimelineObj_GetUserData(This,pData,pSize)	\
    ( (This)->lpVtbl -> GetUserData(This,pData,pSize) ) 

#define IAMTimelineObj_SetUserData(This,pData,Size)	\
    ( (This)->lpVtbl -> SetUserData(This,pData,Size) ) 

#define IAMTimelineObj_GetMuted(This,pVal)	\
    ( (This)->lpVtbl -> GetMuted(This,pVal) ) 

#define IAMTimelineObj_SetMuted(This,newVal)	\
    ( (This)->lpVtbl -> SetMuted(This,newVal) ) 

#define IAMTimelineObj_GetLocked(This,pVal)	\
    ( (This)->lpVtbl -> GetLocked(This,pVal) ) 

#define IAMTimelineObj_SetLocked(This,newVal)	\
    ( (This)->lpVtbl -> SetLocked(This,newVal) ) 

#define IAMTimelineObj_GetDirtyRange(This,pStart,pStop)	\
    ( (This)->lpVtbl -> GetDirtyRange(This,pStart,pStop) ) 

#define IAMTimelineObj_GetDirtyRange2(This,pStart,pStop)	\
    ( (This)->lpVtbl -> GetDirtyRange2(This,pStart,pStop) ) 

#define IAMTimelineObj_SetDirtyRange(This,Start,Stop)	\
    ( (This)->lpVtbl -> SetDirtyRange(This,Start,Stop) ) 

#define IAMTimelineObj_SetDirtyRange2(This,Start,Stop)	\
    ( (This)->lpVtbl -> SetDirtyRange2(This,Start,Stop) ) 

#define IAMTimelineObj_ClearDirty(This)	\
    ( (This)->lpVtbl -> ClearDirty(This) ) 

#define IAMTimelineObj_Remove(This)	\
    ( (This)->lpVtbl -> Remove(This) ) 

#define IAMTimelineObj_RemoveAll(This)	\
    ( (This)->lpVtbl -> RemoveAll(This) ) 

#define IAMTimelineObj_GetTimelineNoRef(This,ppResult)	\
    ( (This)->lpVtbl -> GetTimelineNoRef(This,ppResult) ) 

#define IAMTimelineObj_GetGroupIBelongTo(This,ppGroup)	\
    ( (This)->lpVtbl -> GetGroupIBelongTo(This,ppGroup) ) 

#define IAMTimelineObj_GetEmbedDepth(This,pVal)	\
    ( (This)->lpVtbl -> GetEmbedDepth(This,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMTimelineObj_INTERFACE_DEFINED__ */


#ifndef __IAMTimelineEffectable_INTERFACE_DEFINED__
#define __IAMTimelineEffectable_INTERFACE_DEFINED__

/* interface IAMTimelineEffectable */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMTimelineEffectable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EAE58537-622E-11d2-8CAD-00A024580902")
    IAMTimelineEffectable : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EffectInsBefore( 
            __RPC__in_opt IAMTimelineObj *pFX,
            long priority) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EffectSwapPriorities( 
            long PriorityA,
            long PriorityB) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EffectGetCount( 
            __RPC__in long *pCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetEffect( 
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppFx,
            long Which) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineEffectableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimelineEffectable * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimelineEffectable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimelineEffectable * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EffectInsBefore )( 
            IAMTimelineEffectable * This,
            __RPC__in_opt IAMTimelineObj *pFX,
            long priority);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EffectSwapPriorities )( 
            IAMTimelineEffectable * This,
            long PriorityA,
            long PriorityB);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EffectGetCount )( 
            IAMTimelineEffectable * This,
            __RPC__in long *pCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetEffect )( 
            IAMTimelineEffectable * This,
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppFx,
            long Which);
        
        END_INTERFACE
    } IAMTimelineEffectableVtbl;

    interface IAMTimelineEffectable
    {
        CONST_VTBL struct IAMTimelineEffectableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimelineEffectable_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMTimelineEffectable_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMTimelineEffectable_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMTimelineEffectable_EffectInsBefore(This,pFX,priority)	\
    ( (This)->lpVtbl -> EffectInsBefore(This,pFX,priority) ) 

#define IAMTimelineEffectable_EffectSwapPriorities(This,PriorityA,PriorityB)	\
    ( (This)->lpVtbl -> EffectSwapPriorities(This,PriorityA,PriorityB) ) 

#define IAMTimelineEffectable_EffectGetCount(This,pCount)	\
    ( (This)->lpVtbl -> EffectGetCount(This,pCount) ) 

#define IAMTimelineEffectable_GetEffect(This,ppFx,Which)	\
    ( (This)->lpVtbl -> GetEffect(This,ppFx,Which) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMTimelineEffectable_INTERFACE_DEFINED__ */


#ifndef __IAMTimelineEffect_INTERFACE_DEFINED__
#define __IAMTimelineEffect_INTERFACE_DEFINED__

/* interface IAMTimelineEffect */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMTimelineEffect;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BCE0C264-622D-11d2-8CAD-00A024580902")
    IAMTimelineEffect : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EffectGetPriority( 
            __RPC__in long *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineEffectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimelineEffect * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimelineEffect * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimelineEffect * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EffectGetPriority )( 
            IAMTimelineEffect * This,
            __RPC__in long *pVal);
        
        END_INTERFACE
    } IAMTimelineEffectVtbl;

    interface IAMTimelineEffect
    {
        CONST_VTBL struct IAMTimelineEffectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimelineEffect_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMTimelineEffect_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMTimelineEffect_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMTimelineEffect_EffectGetPriority(This,pVal)	\
    ( (This)->lpVtbl -> EffectGetPriority(This,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMTimelineEffect_INTERFACE_DEFINED__ */


#ifndef __IAMTimelineTransable_INTERFACE_DEFINED__
#define __IAMTimelineTransable_INTERFACE_DEFINED__

/* interface IAMTimelineTransable */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMTimelineTransable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("378FA386-622E-11d2-8CAD-00A024580902")
    IAMTimelineTransable : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TransAdd( 
            __RPC__in_opt IAMTimelineObj *pTrans) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TransGetCount( 
            __RPC__in long *pCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNextTrans( 
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppTrans,
            __RPC__in REFERENCE_TIME *pInOut) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNextTrans2( 
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppTrans,
            __RPC__in REFTIME *pInOut) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTransAtTime( 
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppObj,
            REFERENCE_TIME Time,
            long SearchDirection) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTransAtTime2( 
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppObj,
            REFTIME Time,
            long SearchDirection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineTransableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimelineTransable * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimelineTransable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimelineTransable * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TransAdd )( 
            IAMTimelineTransable * This,
            __RPC__in_opt IAMTimelineObj *pTrans);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TransGetCount )( 
            IAMTimelineTransable * This,
            __RPC__in long *pCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetNextTrans )( 
            IAMTimelineTransable * This,
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppTrans,
            __RPC__in REFERENCE_TIME *pInOut);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetNextTrans2 )( 
            IAMTimelineTransable * This,
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppTrans,
            __RPC__in REFTIME *pInOut);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTransAtTime )( 
            IAMTimelineTransable * This,
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppObj,
            REFERENCE_TIME Time,
            long SearchDirection);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTransAtTime2 )( 
            IAMTimelineTransable * This,
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppObj,
            REFTIME Time,
            long SearchDirection);
        
        END_INTERFACE
    } IAMTimelineTransableVtbl;

    interface IAMTimelineTransable
    {
        CONST_VTBL struct IAMTimelineTransableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimelineTransable_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMTimelineTransable_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMTimelineTransable_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMTimelineTransable_TransAdd(This,pTrans)	\
    ( (This)->lpVtbl -> TransAdd(This,pTrans) ) 

#define IAMTimelineTransable_TransGetCount(This,pCount)	\
    ( (This)->lpVtbl -> TransGetCount(This,pCount) ) 

#define IAMTimelineTransable_GetNextTrans(This,ppTrans,pInOut)	\
    ( (This)->lpVtbl -> GetNextTrans(This,ppTrans,pInOut) ) 

#define IAMTimelineTransable_GetNextTrans2(This,ppTrans,pInOut)	\
    ( (This)->lpVtbl -> GetNextTrans2(This,ppTrans,pInOut) ) 

#define IAMTimelineTransable_GetTransAtTime(This,ppObj,Time,SearchDirection)	\
    ( (This)->lpVtbl -> GetTransAtTime(This,ppObj,Time,SearchDirection) ) 

#define IAMTimelineTransable_GetTransAtTime2(This,ppObj,Time,SearchDirection)	\
    ( (This)->lpVtbl -> GetTransAtTime2(This,ppObj,Time,SearchDirection) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMTimelineTransable_INTERFACE_DEFINED__ */


#ifndef __IAMTimelineSplittable_INTERFACE_DEFINED__
#define __IAMTimelineSplittable_INTERFACE_DEFINED__

/* interface IAMTimelineSplittable */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMTimelineSplittable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A0F840A0-D590-11d2-8D55-00A0C9441E20")
    IAMTimelineSplittable : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SplitAt( 
            REFERENCE_TIME Time) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SplitAt2( 
            REFTIME Time) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineSplittableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimelineSplittable * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimelineSplittable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimelineSplittable * This);
        
        HRESULT ( STDMETHODCALLTYPE *SplitAt )( 
            IAMTimelineSplittable * This,
            REFERENCE_TIME Time);
        
        HRESULT ( STDMETHODCALLTYPE *SplitAt2 )( 
            IAMTimelineSplittable * This,
            REFTIME Time);
        
        END_INTERFACE
    } IAMTimelineSplittableVtbl;

    interface IAMTimelineSplittable
    {
        CONST_VTBL struct IAMTimelineSplittableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimelineSplittable_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMTimelineSplittable_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMTimelineSplittable_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMTimelineSplittable_SplitAt(This,Time)	\
    ( (This)->lpVtbl -> SplitAt(This,Time) ) 

#define IAMTimelineSplittable_SplitAt2(This,Time)	\
    ( (This)->lpVtbl -> SplitAt2(This,Time) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMTimelineSplittable_INTERFACE_DEFINED__ */


#ifndef __IAMTimelineTrans_INTERFACE_DEFINED__
#define __IAMTimelineTrans_INTERFACE_DEFINED__

/* interface IAMTimelineTrans */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMTimelineTrans;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BCE0C265-622D-11d2-8CAD-00A024580902")
    IAMTimelineTrans : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCutPoint( 
            __RPC__in REFERENCE_TIME *pTLTime) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCutPoint2( 
            __RPC__in REFTIME *pTLTime) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetCutPoint( 
            REFERENCE_TIME TLTime) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetCutPoint2( 
            REFTIME TLTime) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSwapInputs( 
            __RPC__in BOOL *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSwapInputs( 
            BOOL pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCutsOnly( 
            __RPC__in BOOL *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetCutsOnly( 
            BOOL pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineTransVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimelineTrans * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimelineTrans * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimelineTrans * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCutPoint )( 
            IAMTimelineTrans * This,
            __RPC__in REFERENCE_TIME *pTLTime);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCutPoint2 )( 
            IAMTimelineTrans * This,
            __RPC__in REFTIME *pTLTime);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetCutPoint )( 
            IAMTimelineTrans * This,
            REFERENCE_TIME TLTime);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetCutPoint2 )( 
            IAMTimelineTrans * This,
            REFTIME TLTime);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSwapInputs )( 
            IAMTimelineTrans * This,
            __RPC__in BOOL *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSwapInputs )( 
            IAMTimelineTrans * This,
            BOOL pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCutsOnly )( 
            IAMTimelineTrans * This,
            __RPC__in BOOL *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetCutsOnly )( 
            IAMTimelineTrans * This,
            BOOL pVal);
        
        END_INTERFACE
    } IAMTimelineTransVtbl;

    interface IAMTimelineTrans
    {
        CONST_VTBL struct IAMTimelineTransVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimelineTrans_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMTimelineTrans_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMTimelineTrans_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMTimelineTrans_GetCutPoint(This,pTLTime)	\
    ( (This)->lpVtbl -> GetCutPoint(This,pTLTime) ) 

#define IAMTimelineTrans_GetCutPoint2(This,pTLTime)	\
    ( (This)->lpVtbl -> GetCutPoint2(This,pTLTime) ) 

#define IAMTimelineTrans_SetCutPoint(This,TLTime)	\
    ( (This)->lpVtbl -> SetCutPoint(This,TLTime) ) 

#define IAMTimelineTrans_SetCutPoint2(This,TLTime)	\
    ( (This)->lpVtbl -> SetCutPoint2(This,TLTime) ) 

#define IAMTimelineTrans_GetSwapInputs(This,pVal)	\
    ( (This)->lpVtbl -> GetSwapInputs(This,pVal) ) 

#define IAMTimelineTrans_SetSwapInputs(This,pVal)	\
    ( (This)->lpVtbl -> SetSwapInputs(This,pVal) ) 

#define IAMTimelineTrans_GetCutsOnly(This,pVal)	\
    ( (This)->lpVtbl -> GetCutsOnly(This,pVal) ) 

#define IAMTimelineTrans_SetCutsOnly(This,pVal)	\
    ( (This)->lpVtbl -> SetCutsOnly(This,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMTimelineTrans_INTERFACE_DEFINED__ */


#ifndef __IAMTimelineSrc_INTERFACE_DEFINED__
#define __IAMTimelineSrc_INTERFACE_DEFINED__

/* interface IAMTimelineSrc */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMTimelineSrc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("78530B79-61F9-11D2-8CAD-00A024580902")
    IAMTimelineSrc : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMediaTimes( 
            __RPC__in REFERENCE_TIME *pStart,
            __RPC__in REFERENCE_TIME *pStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMediaTimes2( 
            __RPC__in REFTIME *pStart,
            __RPC__in REFTIME *pStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ModifyStopTime( 
            REFERENCE_TIME Stop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ModifyStopTime2( 
            REFTIME Stop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FixMediaTimes( 
            __RPC__in REFERENCE_TIME *pStart,
            __RPC__in REFERENCE_TIME *pStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FixMediaTimes2( 
            __RPC__in REFTIME *pStart,
            __RPC__in REFTIME *pStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMediaTimes( 
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMediaTimes2( 
            REFTIME Start,
            REFTIME Stop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMediaLength( 
            REFERENCE_TIME Length) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMediaLength2( 
            REFTIME Length) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMediaLength( 
            __RPC__in REFERENCE_TIME *pLength) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMediaLength2( 
            __RPC__in REFTIME *pLength) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMediaName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMediaName( 
            __RPC__in BSTR newVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SpliceWithNext( 
            __RPC__in_opt IAMTimelineObj *pNext) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStreamNumber( 
            __RPC__in long *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStreamNumber( 
            long Val) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsNormalRate( 
            __RPC__in BOOL *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDefaultFPS( 
            __RPC__in double *pFPS) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDefaultFPS( 
            double FPS) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStretchMode( 
            __RPC__in int *pnStretchMode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStretchMode( 
            int nStretchMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineSrcVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimelineSrc * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimelineSrc * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimelineSrc * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMediaTimes )( 
            IAMTimelineSrc * This,
            __RPC__in REFERENCE_TIME *pStart,
            __RPC__in REFERENCE_TIME *pStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMediaTimes2 )( 
            IAMTimelineSrc * This,
            __RPC__in REFTIME *pStart,
            __RPC__in REFTIME *pStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ModifyStopTime )( 
            IAMTimelineSrc * This,
            REFERENCE_TIME Stop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ModifyStopTime2 )( 
            IAMTimelineSrc * This,
            REFTIME Stop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FixMediaTimes )( 
            IAMTimelineSrc * This,
            __RPC__in REFERENCE_TIME *pStart,
            __RPC__in REFERENCE_TIME *pStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FixMediaTimes2 )( 
            IAMTimelineSrc * This,
            __RPC__in REFTIME *pStart,
            __RPC__in REFTIME *pStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMediaTimes )( 
            IAMTimelineSrc * This,
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMediaTimes2 )( 
            IAMTimelineSrc * This,
            REFTIME Start,
            REFTIME Stop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMediaLength )( 
            IAMTimelineSrc * This,
            REFERENCE_TIME Length);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMediaLength2 )( 
            IAMTimelineSrc * This,
            REFTIME Length);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMediaLength )( 
            IAMTimelineSrc * This,
            __RPC__in REFERENCE_TIME *pLength);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMediaLength2 )( 
            IAMTimelineSrc * This,
            __RPC__in REFTIME *pLength);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMediaName )( 
            IAMTimelineSrc * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMediaName )( 
            IAMTimelineSrc * This,
            __RPC__in BSTR newVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SpliceWithNext )( 
            IAMTimelineSrc * This,
            __RPC__in_opt IAMTimelineObj *pNext);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetStreamNumber )( 
            IAMTimelineSrc * This,
            __RPC__in long *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStreamNumber )( 
            IAMTimelineSrc * This,
            long Val);
        
        HRESULT ( STDMETHODCALLTYPE *IsNormalRate )( 
            IAMTimelineSrc * This,
            __RPC__in BOOL *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDefaultFPS )( 
            IAMTimelineSrc * This,
            __RPC__in double *pFPS);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetDefaultFPS )( 
            IAMTimelineSrc * This,
            double FPS);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetStretchMode )( 
            IAMTimelineSrc * This,
            __RPC__in int *pnStretchMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStretchMode )( 
            IAMTimelineSrc * This,
            int nStretchMode);
        
        END_INTERFACE
    } IAMTimelineSrcVtbl;

    interface IAMTimelineSrc
    {
        CONST_VTBL struct IAMTimelineSrcVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimelineSrc_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMTimelineSrc_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMTimelineSrc_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMTimelineSrc_GetMediaTimes(This,pStart,pStop)	\
    ( (This)->lpVtbl -> GetMediaTimes(This,pStart,pStop) ) 

#define IAMTimelineSrc_GetMediaTimes2(This,pStart,pStop)	\
    ( (This)->lpVtbl -> GetMediaTimes2(This,pStart,pStop) ) 

#define IAMTimelineSrc_ModifyStopTime(This,Stop)	\
    ( (This)->lpVtbl -> ModifyStopTime(This,Stop) ) 

#define IAMTimelineSrc_ModifyStopTime2(This,Stop)	\
    ( (This)->lpVtbl -> ModifyStopTime2(This,Stop) ) 

#define IAMTimelineSrc_FixMediaTimes(This,pStart,pStop)	\
    ( (This)->lpVtbl -> FixMediaTimes(This,pStart,pStop) ) 

#define IAMTimelineSrc_FixMediaTimes2(This,pStart,pStop)	\
    ( (This)->lpVtbl -> FixMediaTimes2(This,pStart,pStop) ) 

#define IAMTimelineSrc_SetMediaTimes(This,Start,Stop)	\
    ( (This)->lpVtbl -> SetMediaTimes(This,Start,Stop) ) 

#define IAMTimelineSrc_SetMediaTimes2(This,Start,Stop)	\
    ( (This)->lpVtbl -> SetMediaTimes2(This,Start,Stop) ) 

#define IAMTimelineSrc_SetMediaLength(This,Length)	\
    ( (This)->lpVtbl -> SetMediaLength(This,Length) ) 

#define IAMTimelineSrc_SetMediaLength2(This,Length)	\
    ( (This)->lpVtbl -> SetMediaLength2(This,Length) ) 

#define IAMTimelineSrc_GetMediaLength(This,pLength)	\
    ( (This)->lpVtbl -> GetMediaLength(This,pLength) ) 

#define IAMTimelineSrc_GetMediaLength2(This,pLength)	\
    ( (This)->lpVtbl -> GetMediaLength2(This,pLength) ) 

#define IAMTimelineSrc_GetMediaName(This,pVal)	\
    ( (This)->lpVtbl -> GetMediaName(This,pVal) ) 

#define IAMTimelineSrc_SetMediaName(This,newVal)	\
    ( (This)->lpVtbl -> SetMediaName(This,newVal) ) 

#define IAMTimelineSrc_SpliceWithNext(This,pNext)	\
    ( (This)->lpVtbl -> SpliceWithNext(This,pNext) ) 

#define IAMTimelineSrc_GetStreamNumber(This,pVal)	\
    ( (This)->lpVtbl -> GetStreamNumber(This,pVal) ) 

#define IAMTimelineSrc_SetStreamNumber(This,Val)	\
    ( (This)->lpVtbl -> SetStreamNumber(This,Val) ) 

#define IAMTimelineSrc_IsNormalRate(This,pVal)	\
    ( (This)->lpVtbl -> IsNormalRate(This,pVal) ) 

#define IAMTimelineSrc_GetDefaultFPS(This,pFPS)	\
    ( (This)->lpVtbl -> GetDefaultFPS(This,pFPS) ) 

#define IAMTimelineSrc_SetDefaultFPS(This,FPS)	\
    ( (This)->lpVtbl -> SetDefaultFPS(This,FPS) ) 

#define IAMTimelineSrc_GetStretchMode(This,pnStretchMode)	\
    ( (This)->lpVtbl -> GetStretchMode(This,pnStretchMode) ) 

#define IAMTimelineSrc_SetStretchMode(This,nStretchMode)	\
    ( (This)->lpVtbl -> SetStretchMode(This,nStretchMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMTimelineSrc_INTERFACE_DEFINED__ */


#ifndef __IAMTimelineTrack_INTERFACE_DEFINED__
#define __IAMTimelineTrack_INTERFACE_DEFINED__

/* interface IAMTimelineTrack */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMTimelineTrack;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EAE58538-622E-11d2-8CAD-00A024580902")
    IAMTimelineTrack : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SrcAdd( 
            __RPC__in_opt IAMTimelineObj *pSource) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNextSrc( 
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppSrc,
            __RPC__in REFERENCE_TIME *pInOut) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNextSrc2( 
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppSrc,
            __RPC__in REFTIME *pInOut) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MoveEverythingBy( 
            REFERENCE_TIME Start,
            REFERENCE_TIME MoveBy) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MoveEverythingBy2( 
            REFTIME Start,
            REFTIME MoveBy) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSourcesCount( 
            __RPC__in long *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AreYouBlank( 
            __RPC__in long *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSrcAtTime( 
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppSrc,
            REFERENCE_TIME Time,
            long SearchDirection) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSrcAtTime2( 
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppSrc,
            REFTIME Time,
            long SearchDirection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertSpace( 
            REFERENCE_TIME rtStart,
            REFERENCE_TIME rtEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertSpace2( 
            REFTIME rtStart,
            REFTIME rtEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ZeroBetween( 
            REFERENCE_TIME rtStart,
            REFERENCE_TIME rtEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ZeroBetween2( 
            REFTIME rtStart,
            REFTIME rtEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextSrcEx( 
            __RPC__in_opt IAMTimelineObj *pLast,
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppNext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineTrackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimelineTrack * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimelineTrack * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimelineTrack * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SrcAdd )( 
            IAMTimelineTrack * This,
            __RPC__in_opt IAMTimelineObj *pSource);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetNextSrc )( 
            IAMTimelineTrack * This,
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppSrc,
            __RPC__in REFERENCE_TIME *pInOut);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetNextSrc2 )( 
            IAMTimelineTrack * This,
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppSrc,
            __RPC__in REFTIME *pInOut);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *MoveEverythingBy )( 
            IAMTimelineTrack * This,
            REFERENCE_TIME Start,
            REFERENCE_TIME MoveBy);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *MoveEverythingBy2 )( 
            IAMTimelineTrack * This,
            REFTIME Start,
            REFTIME MoveBy);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSourcesCount )( 
            IAMTimelineTrack * This,
            __RPC__in long *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AreYouBlank )( 
            IAMTimelineTrack * This,
            __RPC__in long *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSrcAtTime )( 
            IAMTimelineTrack * This,
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppSrc,
            REFERENCE_TIME Time,
            long SearchDirection);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSrcAtTime2 )( 
            IAMTimelineTrack * This,
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppSrc,
            REFTIME Time,
            long SearchDirection);
        
        HRESULT ( STDMETHODCALLTYPE *InsertSpace )( 
            IAMTimelineTrack * This,
            REFERENCE_TIME rtStart,
            REFERENCE_TIME rtEnd);
        
        HRESULT ( STDMETHODCALLTYPE *InsertSpace2 )( 
            IAMTimelineTrack * This,
            REFTIME rtStart,
            REFTIME rtEnd);
        
        HRESULT ( STDMETHODCALLTYPE *ZeroBetween )( 
            IAMTimelineTrack * This,
            REFERENCE_TIME rtStart,
            REFERENCE_TIME rtEnd);
        
        HRESULT ( STDMETHODCALLTYPE *ZeroBetween2 )( 
            IAMTimelineTrack * This,
            REFTIME rtStart,
            REFTIME rtEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextSrcEx )( 
            IAMTimelineTrack * This,
            __RPC__in_opt IAMTimelineObj *pLast,
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppNext);
        
        END_INTERFACE
    } IAMTimelineTrackVtbl;

    interface IAMTimelineTrack
    {
        CONST_VTBL struct IAMTimelineTrackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimelineTrack_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMTimelineTrack_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMTimelineTrack_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMTimelineTrack_SrcAdd(This,pSource)	\
    ( (This)->lpVtbl -> SrcAdd(This,pSource) ) 

#define IAMTimelineTrack_GetNextSrc(This,ppSrc,pInOut)	\
    ( (This)->lpVtbl -> GetNextSrc(This,ppSrc,pInOut) ) 

#define IAMTimelineTrack_GetNextSrc2(This,ppSrc,pInOut)	\
    ( (This)->lpVtbl -> GetNextSrc2(This,ppSrc,pInOut) ) 

#define IAMTimelineTrack_MoveEverythingBy(This,Start,MoveBy)	\
    ( (This)->lpVtbl -> MoveEverythingBy(This,Start,MoveBy) ) 

#define IAMTimelineTrack_MoveEverythingBy2(This,Start,MoveBy)	\
    ( (This)->lpVtbl -> MoveEverythingBy2(This,Start,MoveBy) ) 

#define IAMTimelineTrack_GetSourcesCount(This,pVal)	\
    ( (This)->lpVtbl -> GetSourcesCount(This,pVal) ) 

#define IAMTimelineTrack_AreYouBlank(This,pVal)	\
    ( (This)->lpVtbl -> AreYouBlank(This,pVal) ) 

#define IAMTimelineTrack_GetSrcAtTime(This,ppSrc,Time,SearchDirection)	\
    ( (This)->lpVtbl -> GetSrcAtTime(This,ppSrc,Time,SearchDirection) ) 

#define IAMTimelineTrack_GetSrcAtTime2(This,ppSrc,Time,SearchDirection)	\
    ( (This)->lpVtbl -> GetSrcAtTime2(This,ppSrc,Time,SearchDirection) ) 

#define IAMTimelineTrack_InsertSpace(This,rtStart,rtEnd)	\
    ( (This)->lpVtbl -> InsertSpace(This,rtStart,rtEnd) ) 

#define IAMTimelineTrack_InsertSpace2(This,rtStart,rtEnd)	\
    ( (This)->lpVtbl -> InsertSpace2(This,rtStart,rtEnd) ) 

#define IAMTimelineTrack_ZeroBetween(This,rtStart,rtEnd)	\
    ( (This)->lpVtbl -> ZeroBetween(This,rtStart,rtEnd) ) 

#define IAMTimelineTrack_ZeroBetween2(This,rtStart,rtEnd)	\
    ( (This)->lpVtbl -> ZeroBetween2(This,rtStart,rtEnd) ) 

#define IAMTimelineTrack_GetNextSrcEx(This,pLast,ppNext)	\
    ( (This)->lpVtbl -> GetNextSrcEx(This,pLast,ppNext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMTimelineTrack_INTERFACE_DEFINED__ */


#ifndef __IAMTimelineVirtualTrack_INTERFACE_DEFINED__
#define __IAMTimelineVirtualTrack_INTERFACE_DEFINED__

/* interface IAMTimelineVirtualTrack */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMTimelineVirtualTrack;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A8ED5F80-C2C7-11d2-8D39-00A0C9441E20")
    IAMTimelineVirtualTrack : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TrackGetPriority( 
            __RPC__in long *pPriority) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetTrackDirty( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineVirtualTrackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimelineVirtualTrack * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimelineVirtualTrack * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimelineVirtualTrack * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TrackGetPriority )( 
            IAMTimelineVirtualTrack * This,
            __RPC__in long *pPriority);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetTrackDirty )( 
            IAMTimelineVirtualTrack * This);
        
        END_INTERFACE
    } IAMTimelineVirtualTrackVtbl;

    interface IAMTimelineVirtualTrack
    {
        CONST_VTBL struct IAMTimelineVirtualTrackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimelineVirtualTrack_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMTimelineVirtualTrack_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMTimelineVirtualTrack_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMTimelineVirtualTrack_TrackGetPriority(This,pPriority)	\
    ( (This)->lpVtbl -> TrackGetPriority(This,pPriority) ) 

#define IAMTimelineVirtualTrack_SetTrackDirty(This)	\
    ( (This)->lpVtbl -> SetTrackDirty(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMTimelineVirtualTrack_INTERFACE_DEFINED__ */


#ifndef __IAMTimelineComp_INTERFACE_DEFINED__
#define __IAMTimelineComp_INTERFACE_DEFINED__

/* interface IAMTimelineComp */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMTimelineComp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EAE58536-622E-11d2-8CAD-00A024580902")
    IAMTimelineComp : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE VTrackInsBefore( 
            __RPC__in_opt IAMTimelineObj *pVirtualTrack,
            long Priority) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE VTrackSwapPriorities( 
            long VirtualTrackA,
            long VirtualTrackB) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE VTrackGetCount( 
            __RPC__in long *pVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVTrack( 
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppVirtualTrack,
            long Which) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCountOfType( 
            __RPC__in long *pVal,
            __RPC__in long *pValWithComps,
            TIMELINE_MAJOR_TYPE MajorType) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetRecursiveLayerOfType( 
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppVirtualTrack,
            long WhichLayer,
            TIMELINE_MAJOR_TYPE Type) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetRecursiveLayerOfTypeI( 
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppVirtualTrack,
            /* [out][in] */ __RPC__inout long *pWhichLayer,
            TIMELINE_MAJOR_TYPE Type) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextVTrack( 
            __RPC__in_opt IAMTimelineObj *pVirtualTrack,
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppNextVirtualTrack) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineCompVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimelineComp * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimelineComp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimelineComp * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *VTrackInsBefore )( 
            IAMTimelineComp * This,
            __RPC__in_opt IAMTimelineObj *pVirtualTrack,
            long Priority);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *VTrackSwapPriorities )( 
            IAMTimelineComp * This,
            long VirtualTrackA,
            long VirtualTrackB);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *VTrackGetCount )( 
            IAMTimelineComp * This,
            __RPC__in long *pVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetVTrack )( 
            IAMTimelineComp * This,
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppVirtualTrack,
            long Which);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCountOfType )( 
            IAMTimelineComp * This,
            __RPC__in long *pVal,
            __RPC__in long *pValWithComps,
            TIMELINE_MAJOR_TYPE MajorType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetRecursiveLayerOfType )( 
            IAMTimelineComp * This,
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppVirtualTrack,
            long WhichLayer,
            TIMELINE_MAJOR_TYPE Type);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetRecursiveLayerOfTypeI )( 
            IAMTimelineComp * This,
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppVirtualTrack,
            /* [out][in] */ __RPC__inout long *pWhichLayer,
            TIMELINE_MAJOR_TYPE Type);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextVTrack )( 
            IAMTimelineComp * This,
            __RPC__in_opt IAMTimelineObj *pVirtualTrack,
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppNextVirtualTrack);
        
        END_INTERFACE
    } IAMTimelineCompVtbl;

    interface IAMTimelineComp
    {
        CONST_VTBL struct IAMTimelineCompVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimelineComp_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMTimelineComp_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMTimelineComp_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMTimelineComp_VTrackInsBefore(This,pVirtualTrack,Priority)	\
    ( (This)->lpVtbl -> VTrackInsBefore(This,pVirtualTrack,Priority) ) 

#define IAMTimelineComp_VTrackSwapPriorities(This,VirtualTrackA,VirtualTrackB)	\
    ( (This)->lpVtbl -> VTrackSwapPriorities(This,VirtualTrackA,VirtualTrackB) ) 

#define IAMTimelineComp_VTrackGetCount(This,pVal)	\
    ( (This)->lpVtbl -> VTrackGetCount(This,pVal) ) 

#define IAMTimelineComp_GetVTrack(This,ppVirtualTrack,Which)	\
    ( (This)->lpVtbl -> GetVTrack(This,ppVirtualTrack,Which) ) 

#define IAMTimelineComp_GetCountOfType(This,pVal,pValWithComps,MajorType)	\
    ( (This)->lpVtbl -> GetCountOfType(This,pVal,pValWithComps,MajorType) ) 

#define IAMTimelineComp_GetRecursiveLayerOfType(This,ppVirtualTrack,WhichLayer,Type)	\
    ( (This)->lpVtbl -> GetRecursiveLayerOfType(This,ppVirtualTrack,WhichLayer,Type) ) 

#define IAMTimelineComp_GetRecursiveLayerOfTypeI(This,ppVirtualTrack,pWhichLayer,Type)	\
    ( (This)->lpVtbl -> GetRecursiveLayerOfTypeI(This,ppVirtualTrack,pWhichLayer,Type) ) 

#define IAMTimelineComp_GetNextVTrack(This,pVirtualTrack,ppNextVirtualTrack)	\
    ( (This)->lpVtbl -> GetNextVTrack(This,pVirtualTrack,ppNextVirtualTrack) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMTimelineComp_INTERFACE_DEFINED__ */


#ifndef __IAMTimelineGroup_INTERFACE_DEFINED__
#define __IAMTimelineGroup_INTERFACE_DEFINED__

/* interface IAMTimelineGroup */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMTimelineGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EED4F00-B8A6-11d2-8023-00C0DF10D434")
    IAMTimelineGroup : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetTimeline( 
            __RPC__in_opt IAMTimeline *pTimeline) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTimeline( 
            /* [out] */ __RPC__deref_out_opt IAMTimeline **ppTimeline) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPriority( 
            __RPC__in long *pPriority) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMediaType( 
            /* [out] */ __RPC__out AM_MEDIA_TYPE *__MIDL__IAMTimelineGroup0000) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMediaType( 
            /* [in] */ __RPC__in AM_MEDIA_TYPE *__MIDL__IAMTimelineGroup0001) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetOutputFPS( 
            double FPS) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetOutputFPS( 
            __RPC__in double *pFPS) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetGroupName( 
            __RPC__in BSTR pGroupName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetGroupName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pGroupName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPreviewMode( 
            BOOL fPreview) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPreviewMode( 
            __RPC__in BOOL *pfPreview) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMediaTypeForVB( 
            /* [in] */ long Val) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetOutputBuffering( 
            /* [out] */ __RPC__out int *pnBuffer) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetOutputBuffering( 
            /* [in] */ int nBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSmartRecompressFormat( 
            __RPC__in long *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSmartRecompressFormat( 
            __RPC__deref_in_opt long **ppFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSmartRecompressFormatSet( 
            __RPC__in BOOL *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRecompressFormatDirty( 
            __RPC__in BOOL *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearRecompressFormatDirty( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRecompFormatFromSource( 
            __RPC__in_opt IAMTimelineSrc *pSource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimelineGroup * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimelineGroup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimelineGroup * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetTimeline )( 
            IAMTimelineGroup * This,
            __RPC__in_opt IAMTimeline *pTimeline);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTimeline )( 
            IAMTimelineGroup * This,
            /* [out] */ __RPC__deref_out_opt IAMTimeline **ppTimeline);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPriority )( 
            IAMTimelineGroup * This,
            __RPC__in long *pPriority);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMediaType )( 
            IAMTimelineGroup * This,
            /* [out] */ __RPC__out AM_MEDIA_TYPE *__MIDL__IAMTimelineGroup0000);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            IAMTimelineGroup * This,
            /* [in] */ __RPC__in AM_MEDIA_TYPE *__MIDL__IAMTimelineGroup0001);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetOutputFPS )( 
            IAMTimelineGroup * This,
            double FPS);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetOutputFPS )( 
            IAMTimelineGroup * This,
            __RPC__in double *pFPS);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetGroupName )( 
            IAMTimelineGroup * This,
            __RPC__in BSTR pGroupName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetGroupName )( 
            IAMTimelineGroup * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pGroupName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPreviewMode )( 
            IAMTimelineGroup * This,
            BOOL fPreview);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPreviewMode )( 
            IAMTimelineGroup * This,
            __RPC__in BOOL *pfPreview);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMediaTypeForVB )( 
            IAMTimelineGroup * This,
            /* [in] */ long Val);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetOutputBuffering )( 
            IAMTimelineGroup * This,
            /* [out] */ __RPC__out int *pnBuffer);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetOutputBuffering )( 
            IAMTimelineGroup * This,
            /* [in] */ int nBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *SetSmartRecompressFormat )( 
            IAMTimelineGroup * This,
            __RPC__in long *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetSmartRecompressFormat )( 
            IAMTimelineGroup * This,
            __RPC__deref_in_opt long **ppFormat);
        
        HRESULT ( STDMETHODCALLTYPE *IsSmartRecompressFormatSet )( 
            IAMTimelineGroup * This,
            __RPC__in BOOL *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *IsRecompressFormatDirty )( 
            IAMTimelineGroup * This,
            __RPC__in BOOL *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *ClearRecompressFormatDirty )( 
            IAMTimelineGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetRecompFormatFromSource )( 
            IAMTimelineGroup * This,
            __RPC__in_opt IAMTimelineSrc *pSource);
        
        END_INTERFACE
    } IAMTimelineGroupVtbl;

    interface IAMTimelineGroup
    {
        CONST_VTBL struct IAMTimelineGroupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimelineGroup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMTimelineGroup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMTimelineGroup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMTimelineGroup_SetTimeline(This,pTimeline)	\
    ( (This)->lpVtbl -> SetTimeline(This,pTimeline) ) 

#define IAMTimelineGroup_GetTimeline(This,ppTimeline)	\
    ( (This)->lpVtbl -> GetTimeline(This,ppTimeline) ) 

#define IAMTimelineGroup_GetPriority(This,pPriority)	\
    ( (This)->lpVtbl -> GetPriority(This,pPriority) ) 

#define IAMTimelineGroup_GetMediaType(This,__MIDL__IAMTimelineGroup0000)	\
    ( (This)->lpVtbl -> GetMediaType(This,__MIDL__IAMTimelineGroup0000) ) 

#define IAMTimelineGroup_SetMediaType(This,__MIDL__IAMTimelineGroup0001)	\
    ( (This)->lpVtbl -> SetMediaType(This,__MIDL__IAMTimelineGroup0001) ) 

#define IAMTimelineGroup_SetOutputFPS(This,FPS)	\
    ( (This)->lpVtbl -> SetOutputFPS(This,FPS) ) 

#define IAMTimelineGroup_GetOutputFPS(This,pFPS)	\
    ( (This)->lpVtbl -> GetOutputFPS(This,pFPS) ) 

#define IAMTimelineGroup_SetGroupName(This,pGroupName)	\
    ( (This)->lpVtbl -> SetGroupName(This,pGroupName) ) 

#define IAMTimelineGroup_GetGroupName(This,pGroupName)	\
    ( (This)->lpVtbl -> GetGroupName(This,pGroupName) ) 

#define IAMTimelineGroup_SetPreviewMode(This,fPreview)	\
    ( (This)->lpVtbl -> SetPreviewMode(This,fPreview) ) 

#define IAMTimelineGroup_GetPreviewMode(This,pfPreview)	\
    ( (This)->lpVtbl -> GetPreviewMode(This,pfPreview) ) 

#define IAMTimelineGroup_SetMediaTypeForVB(This,Val)	\
    ( (This)->lpVtbl -> SetMediaTypeForVB(This,Val) ) 

#define IAMTimelineGroup_GetOutputBuffering(This,pnBuffer)	\
    ( (This)->lpVtbl -> GetOutputBuffering(This,pnBuffer) ) 

#define IAMTimelineGroup_SetOutputBuffering(This,nBuffer)	\
    ( (This)->lpVtbl -> SetOutputBuffering(This,nBuffer) ) 

#define IAMTimelineGroup_SetSmartRecompressFormat(This,pFormat)	\
    ( (This)->lpVtbl -> SetSmartRecompressFormat(This,pFormat) ) 

#define IAMTimelineGroup_GetSmartRecompressFormat(This,ppFormat)	\
    ( (This)->lpVtbl -> GetSmartRecompressFormat(This,ppFormat) ) 

#define IAMTimelineGroup_IsSmartRecompressFormatSet(This,pVal)	\
    ( (This)->lpVtbl -> IsSmartRecompressFormatSet(This,pVal) ) 

#define IAMTimelineGroup_IsRecompressFormatDirty(This,pVal)	\
    ( (This)->lpVtbl -> IsRecompressFormatDirty(This,pVal) ) 

#define IAMTimelineGroup_ClearRecompressFormatDirty(This)	\
    ( (This)->lpVtbl -> ClearRecompressFormatDirty(This) ) 

#define IAMTimelineGroup_SetRecompFormatFromSource(This,pSource)	\
    ( (This)->lpVtbl -> SetRecompFormatFromSource(This,pSource) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMTimelineGroup_INTERFACE_DEFINED__ */


#ifndef __IAMTimeline_INTERFACE_DEFINED__
#define __IAMTimeline_INTERFACE_DEFINED__

/* interface IAMTimeline */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMTimeline;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("78530B74-61F9-11D2-8CAD-00A024580902")
    IAMTimeline : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateEmptyNode( 
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppObj,
            TIMELINE_MAJOR_TYPE Type) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddGroup( 
            __RPC__in_opt IAMTimelineObj *pGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemGroupFromList( 
            __RPC__in_opt IAMTimelineObj *pGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroup( 
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppGroup,
            long WhichGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupCount( 
            __RPC__in long *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearAllGroups( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInsertMode( 
            __RPC__in long *pMode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInsertMode( 
            long Mode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnableTransitions( 
            BOOL fEnabled) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TransitionsEnabled( 
            __RPC__in BOOL *pfEnabled) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnableEffects( 
            BOOL fEnabled) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EffectsEnabled( 
            __RPC__in BOOL *pfEnabled) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInterestRange( 
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDuration( 
            __RPC__in REFERENCE_TIME *pDuration) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDuration2( 
            __RPC__in double *pDuration) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDefaultFPS( 
            double FPS) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDefaultFPS( 
            __RPC__in double *pFPS) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsDirty( 
            __RPC__in BOOL *pDirty) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDirtyRange( 
            __RPC__in REFERENCE_TIME *pStart,
            __RPC__in REFERENCE_TIME *pStop) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCountOfType( 
            long Group,
            __RPC__in long *pVal,
            __RPC__in long *pValWithComps,
            TIMELINE_MAJOR_TYPE MajorType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ValidateSourceNames( 
            long ValidateFlags,
            __RPC__in_opt IMediaLocator *pOverride,
            LONG_PTR NotifyEventHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultTransition( 
            __RPC__in GUID *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultTransition( 
            __RPC__in GUID *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultEffect( 
            __RPC__in GUID *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultEffect( 
            __RPC__in GUID *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultTransitionB( 
            __RPC__in BSTR pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultTransitionB( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultEffectB( 
            __RPC__in BSTR pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultEffectB( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pGuid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimelineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimeline * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimeline * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimeline * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateEmptyNode )( 
            IAMTimeline * This,
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppObj,
            TIMELINE_MAJOR_TYPE Type);
        
        HRESULT ( STDMETHODCALLTYPE *AddGroup )( 
            IAMTimeline * This,
            __RPC__in_opt IAMTimelineObj *pGroup);
        
        HRESULT ( STDMETHODCALLTYPE *RemGroupFromList )( 
            IAMTimeline * This,
            __RPC__in_opt IAMTimelineObj *pGroup);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroup )( 
            IAMTimeline * This,
            /* [out] */ __RPC__deref_out_opt IAMTimelineObj **ppGroup,
            long WhichGroup);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupCount )( 
            IAMTimeline * This,
            __RPC__in long *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *ClearAllGroups )( 
            IAMTimeline * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInsertMode )( 
            IAMTimeline * This,
            __RPC__in long *pMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetInsertMode )( 
            IAMTimeline * This,
            long Mode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnableTransitions )( 
            IAMTimeline * This,
            BOOL fEnabled);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TransitionsEnabled )( 
            IAMTimeline * This,
            __RPC__in BOOL *pfEnabled);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnableEffects )( 
            IAMTimeline * This,
            BOOL fEnabled);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EffectsEnabled )( 
            IAMTimeline * This,
            __RPC__in BOOL *pfEnabled);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetInterestRange )( 
            IAMTimeline * This,
            REFERENCE_TIME Start,
            REFERENCE_TIME Stop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDuration )( 
            IAMTimeline * This,
            __RPC__in REFERENCE_TIME *pDuration);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDuration2 )( 
            IAMTimeline * This,
            __RPC__in double *pDuration);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetDefaultFPS )( 
            IAMTimeline * This,
            double FPS);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDefaultFPS )( 
            IAMTimeline * This,
            __RPC__in double *pFPS);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsDirty )( 
            IAMTimeline * This,
            __RPC__in BOOL *pDirty);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDirtyRange )( 
            IAMTimeline * This,
            __RPC__in REFERENCE_TIME *pStart,
            __RPC__in REFERENCE_TIME *pStop);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCountOfType )( 
            IAMTimeline * This,
            long Group,
            __RPC__in long *pVal,
            __RPC__in long *pValWithComps,
            TIMELINE_MAJOR_TYPE MajorType);
        
        HRESULT ( STDMETHODCALLTYPE *ValidateSourceNames )( 
            IAMTimeline * This,
            long ValidateFlags,
            __RPC__in_opt IMediaLocator *pOverride,
            LONG_PTR NotifyEventHandle);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultTransition )( 
            IAMTimeline * This,
            __RPC__in GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultTransition )( 
            IAMTimeline * This,
            __RPC__in GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultEffect )( 
            IAMTimeline * This,
            __RPC__in GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultEffect )( 
            IAMTimeline * This,
            __RPC__in GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultTransitionB )( 
            IAMTimeline * This,
            __RPC__in BSTR pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultTransitionB )( 
            IAMTimeline * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultEffectB )( 
            IAMTimeline * This,
            __RPC__in BSTR pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultEffectB )( 
            IAMTimeline * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pGuid);
        
        END_INTERFACE
    } IAMTimelineVtbl;

    interface IAMTimeline
    {
        CONST_VTBL struct IAMTimelineVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimeline_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMTimeline_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMTimeline_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMTimeline_CreateEmptyNode(This,ppObj,Type)	\
    ( (This)->lpVtbl -> CreateEmptyNode(This,ppObj,Type) ) 

#define IAMTimeline_AddGroup(This,pGroup)	\
    ( (This)->lpVtbl -> AddGroup(This,pGroup) ) 

#define IAMTimeline_RemGroupFromList(This,pGroup)	\
    ( (This)->lpVtbl -> RemGroupFromList(This,pGroup) ) 

#define IAMTimeline_GetGroup(This,ppGroup,WhichGroup)	\
    ( (This)->lpVtbl -> GetGroup(This,ppGroup,WhichGroup) ) 

#define IAMTimeline_GetGroupCount(This,pCount)	\
    ( (This)->lpVtbl -> GetGroupCount(This,pCount) ) 

#define IAMTimeline_ClearAllGroups(This)	\
    ( (This)->lpVtbl -> ClearAllGroups(This) ) 

#define IAMTimeline_GetInsertMode(This,pMode)	\
    ( (This)->lpVtbl -> GetInsertMode(This,pMode) ) 

#define IAMTimeline_SetInsertMode(This,Mode)	\
    ( (This)->lpVtbl -> SetInsertMode(This,Mode) ) 

#define IAMTimeline_EnableTransitions(This,fEnabled)	\
    ( (This)->lpVtbl -> EnableTransitions(This,fEnabled) ) 

#define IAMTimeline_TransitionsEnabled(This,pfEnabled)	\
    ( (This)->lpVtbl -> TransitionsEnabled(This,pfEnabled) ) 

#define IAMTimeline_EnableEffects(This,fEnabled)	\
    ( (This)->lpVtbl -> EnableEffects(This,fEnabled) ) 

#define IAMTimeline_EffectsEnabled(This,pfEnabled)	\
    ( (This)->lpVtbl -> EffectsEnabled(This,pfEnabled) ) 

#define IAMTimeline_SetInterestRange(This,Start,Stop)	\
    ( (This)->lpVtbl -> SetInterestRange(This,Start,Stop) ) 

#define IAMTimeline_GetDuration(This,pDuration)	\
    ( (This)->lpVtbl -> GetDuration(This,pDuration) ) 

#define IAMTimeline_GetDuration2(This,pDuration)	\
    ( (This)->lpVtbl -> GetDuration2(This,pDuration) ) 

#define IAMTimeline_SetDefaultFPS(This,FPS)	\
    ( (This)->lpVtbl -> SetDefaultFPS(This,FPS) ) 

#define IAMTimeline_GetDefaultFPS(This,pFPS)	\
    ( (This)->lpVtbl -> GetDefaultFPS(This,pFPS) ) 

#define IAMTimeline_IsDirty(This,pDirty)	\
    ( (This)->lpVtbl -> IsDirty(This,pDirty) ) 

#define IAMTimeline_GetDirtyRange(This,pStart,pStop)	\
    ( (This)->lpVtbl -> GetDirtyRange(This,pStart,pStop) ) 

#define IAMTimeline_GetCountOfType(This,Group,pVal,pValWithComps,MajorType)	\
    ( (This)->lpVtbl -> GetCountOfType(This,Group,pVal,pValWithComps,MajorType) ) 

#define IAMTimeline_ValidateSourceNames(This,ValidateFlags,pOverride,NotifyEventHandle)	\
    ( (This)->lpVtbl -> ValidateSourceNames(This,ValidateFlags,pOverride,NotifyEventHandle) ) 

#define IAMTimeline_SetDefaultTransition(This,pGuid)	\
    ( (This)->lpVtbl -> SetDefaultTransition(This,pGuid) ) 

#define IAMTimeline_GetDefaultTransition(This,pGuid)	\
    ( (This)->lpVtbl -> GetDefaultTransition(This,pGuid) ) 

#define IAMTimeline_SetDefaultEffect(This,pGuid)	\
    ( (This)->lpVtbl -> SetDefaultEffect(This,pGuid) ) 

#define IAMTimeline_GetDefaultEffect(This,pGuid)	\
    ( (This)->lpVtbl -> GetDefaultEffect(This,pGuid) ) 

#define IAMTimeline_SetDefaultTransitionB(This,pGuid)	\
    ( (This)->lpVtbl -> SetDefaultTransitionB(This,pGuid) ) 

#define IAMTimeline_GetDefaultTransitionB(This,pGuid)	\
    ( (This)->lpVtbl -> GetDefaultTransitionB(This,pGuid) ) 

#define IAMTimeline_SetDefaultEffectB(This,pGuid)	\
    ( (This)->lpVtbl -> SetDefaultEffectB(This,pGuid) ) 

#define IAMTimeline_GetDefaultEffectB(This,pGuid)	\
    ( (This)->lpVtbl -> GetDefaultEffectB(This,pGuid) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMTimeline_INTERFACE_DEFINED__ */


#ifndef __IXml2Dex_INTERFACE_DEFINED__
#define __IXml2Dex_INTERFACE_DEFINED__

/* interface IXml2Dex */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IXml2Dex;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18C628ED-962A-11D2-8D08-00A0C9441E20")
    IXml2Dex : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateGraphFromFile( 
            /* [out] */ __RPC__deref_out_opt IUnknown **ppGraph,
            __RPC__in_opt IUnknown *pTimeline,
            __RPC__in BSTR Filename) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WriteGrfFile( 
            __RPC__in_opt IUnknown *pGraph,
            __RPC__in BSTR FileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WriteXMLFile( 
            __RPC__in_opt IUnknown *pTimeline,
            __RPC__in BSTR FileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReadXMLFile( 
            __RPC__in_opt IUnknown *pTimeline,
            __RPC__in BSTR XMLName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( 
            __RPC__in_opt IUnknown *pTimeline,
            double dStart,
            double dEnd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WriteXMLPart( 
            __RPC__in_opt IUnknown *pTimeline,
            double dStart,
            double dEnd,
            __RPC__in BSTR FileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PasteXMLFile( 
            __RPC__in_opt IUnknown *pTimeline,
            double dStart,
            __RPC__in BSTR FileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CopyXML( 
            __RPC__in_opt IUnknown *pTimeline,
            double dStart,
            double dEnd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PasteXML( 
            __RPC__in_opt IUnknown *pTimeline,
            double dStart) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReadXML( 
            __RPC__in_opt IUnknown *pTimeline,
            __RPC__in_opt IUnknown *pXML) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WriteXML( 
            __RPC__in_opt IUnknown *pTimeline,
            __RPC__deref_in_opt BSTR *pbstrXML) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXml2DexVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXml2Dex * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXml2Dex * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXml2Dex * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXml2Dex * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXml2Dex * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXml2Dex * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXml2Dex * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateGraphFromFile )( 
            IXml2Dex * This,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppGraph,
            __RPC__in_opt IUnknown *pTimeline,
            __RPC__in BSTR Filename);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *WriteGrfFile )( 
            IXml2Dex * This,
            __RPC__in_opt IUnknown *pGraph,
            __RPC__in BSTR FileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *WriteXMLFile )( 
            IXml2Dex * This,
            __RPC__in_opt IUnknown *pTimeline,
            __RPC__in BSTR FileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ReadXMLFile )( 
            IXml2Dex * This,
            __RPC__in_opt IUnknown *pTimeline,
            __RPC__in BSTR XMLName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IXml2Dex * This,
            __RPC__in_opt IUnknown *pTimeline,
            double dStart,
            double dEnd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *WriteXMLPart )( 
            IXml2Dex * This,
            __RPC__in_opt IUnknown *pTimeline,
            double dStart,
            double dEnd,
            __RPC__in BSTR FileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PasteXMLFile )( 
            IXml2Dex * This,
            __RPC__in_opt IUnknown *pTimeline,
            double dStart,
            __RPC__in BSTR FileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyXML )( 
            IXml2Dex * This,
            __RPC__in_opt IUnknown *pTimeline,
            double dStart,
            double dEnd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PasteXML )( 
            IXml2Dex * This,
            __RPC__in_opt IUnknown *pTimeline,
            double dStart);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IXml2Dex * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ReadXML )( 
            IXml2Dex * This,
            __RPC__in_opt IUnknown *pTimeline,
            __RPC__in_opt IUnknown *pXML);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *WriteXML )( 
            IXml2Dex * This,
            __RPC__in_opt IUnknown *pTimeline,
            __RPC__deref_in_opt BSTR *pbstrXML);
        
        END_INTERFACE
    } IXml2DexVtbl;

    interface IXml2Dex
    {
        CONST_VTBL struct IXml2DexVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXml2Dex_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXml2Dex_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXml2Dex_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXml2Dex_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IXml2Dex_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IXml2Dex_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IXml2Dex_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IXml2Dex_CreateGraphFromFile(This,ppGraph,pTimeline,Filename)	\
    ( (This)->lpVtbl -> CreateGraphFromFile(This,ppGraph,pTimeline,Filename) ) 

#define IXml2Dex_WriteGrfFile(This,pGraph,FileName)	\
    ( (This)->lpVtbl -> WriteGrfFile(This,pGraph,FileName) ) 

#define IXml2Dex_WriteXMLFile(This,pTimeline,FileName)	\
    ( (This)->lpVtbl -> WriteXMLFile(This,pTimeline,FileName) ) 

#define IXml2Dex_ReadXMLFile(This,pTimeline,XMLName)	\
    ( (This)->lpVtbl -> ReadXMLFile(This,pTimeline,XMLName) ) 

#define IXml2Dex_Delete(This,pTimeline,dStart,dEnd)	\
    ( (This)->lpVtbl -> Delete(This,pTimeline,dStart,dEnd) ) 

#define IXml2Dex_WriteXMLPart(This,pTimeline,dStart,dEnd,FileName)	\
    ( (This)->lpVtbl -> WriteXMLPart(This,pTimeline,dStart,dEnd,FileName) ) 

#define IXml2Dex_PasteXMLFile(This,pTimeline,dStart,FileName)	\
    ( (This)->lpVtbl -> PasteXMLFile(This,pTimeline,dStart,FileName) ) 

#define IXml2Dex_CopyXML(This,pTimeline,dStart,dEnd)	\
    ( (This)->lpVtbl -> CopyXML(This,pTimeline,dStart,dEnd) ) 

#define IXml2Dex_PasteXML(This,pTimeline,dStart)	\
    ( (This)->lpVtbl -> PasteXML(This,pTimeline,dStart) ) 

#define IXml2Dex_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IXml2Dex_ReadXML(This,pTimeline,pXML)	\
    ( (This)->lpVtbl -> ReadXML(This,pTimeline,pXML) ) 

#define IXml2Dex_WriteXML(This,pTimeline,pbstrXML)	\
    ( (This)->lpVtbl -> WriteXML(This,pTimeline,pbstrXML) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXml2Dex_INTERFACE_DEFINED__ */


#ifndef __IAMErrorLog_INTERFACE_DEFINED__
#define __IAMErrorLog_INTERFACE_DEFINED__

/* interface IAMErrorLog */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMErrorLog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E43E73A2-0EFA-11d3-9601-00A0C9441E20")
    IAMErrorLog : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LogError( 
            long Severity,
            __RPC__in BSTR pErrorString,
            long ErrorCode,
            long hresult,
            /* [in] */ __RPC__in VARIANT *pExtraInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMErrorLogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMErrorLog * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMErrorLog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMErrorLog * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *LogError )( 
            IAMErrorLog * This,
            long Severity,
            __RPC__in BSTR pErrorString,
            long ErrorCode,
            long hresult,
            /* [in] */ __RPC__in VARIANT *pExtraInfo);
        
        END_INTERFACE
    } IAMErrorLogVtbl;

    interface IAMErrorLog
    {
        CONST_VTBL struct IAMErrorLogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMErrorLog_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMErrorLog_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMErrorLog_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMErrorLog_LogError(This,Severity,pErrorString,ErrorCode,hresult,pExtraInfo)	\
    ( (This)->lpVtbl -> LogError(This,Severity,pErrorString,ErrorCode,hresult,pExtraInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMErrorLog_INTERFACE_DEFINED__ */


#ifndef __IAMSetErrorLog_INTERFACE_DEFINED__
#define __IAMSetErrorLog_INTERFACE_DEFINED__

/* interface IAMSetErrorLog */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAMSetErrorLog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("963566DA-BE21-4eaf-88E9-35704F8F52A1")
    IAMSetErrorLog : public IUnknown
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorLog( 
            /* [retval][out] */ __RPC__deref_out_opt IAMErrorLog **pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ErrorLog( 
            /* [in] */ __RPC__in_opt IAMErrorLog *newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMSetErrorLogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMSetErrorLog * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMSetErrorLog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMSetErrorLog * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorLog )( 
            IAMSetErrorLog * This,
            /* [retval][out] */ __RPC__deref_out_opt IAMErrorLog **pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ErrorLog )( 
            IAMSetErrorLog * This,
            /* [in] */ __RPC__in_opt IAMErrorLog *newVal);
        
        END_INTERFACE
    } IAMSetErrorLogVtbl;

    interface IAMSetErrorLog
    {
        CONST_VTBL struct IAMSetErrorLogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMSetErrorLog_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMSetErrorLog_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMSetErrorLog_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMSetErrorLog_get_ErrorLog(This,pVal)	\
    ( (This)->lpVtbl -> get_ErrorLog(This,pVal) ) 

#define IAMSetErrorLog_put_ErrorLog(This,newVal)	\
    ( (This)->lpVtbl -> put_ErrorLog(This,newVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMSetErrorLog_INTERFACE_DEFINED__ */


#ifndef __ISampleGrabberCB_INTERFACE_DEFINED__
#define __ISampleGrabberCB_INTERFACE_DEFINED__

/* interface ISampleGrabberCB */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_ISampleGrabberCB;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0579154A-2B53-4994-B0D0-E773148EFF85")
    ISampleGrabberCB : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SampleCB( 
            double SampleTime,
            IMediaSample *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BufferCB( 
            double SampleTime,
            BYTE *pBuffer,
            long BufferLen) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISampleGrabberCBVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISampleGrabberCB * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISampleGrabberCB * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISampleGrabberCB * This);
        
        HRESULT ( STDMETHODCALLTYPE *SampleCB )( 
            ISampleGrabberCB * This,
            double SampleTime,
            IMediaSample *pSample);
        
        HRESULT ( STDMETHODCALLTYPE *BufferCB )( 
            ISampleGrabberCB * This,
            double SampleTime,
            BYTE *pBuffer,
            long BufferLen);
        
        END_INTERFACE
    } ISampleGrabberCBVtbl;

    interface ISampleGrabberCB
    {
        CONST_VTBL struct ISampleGrabberCBVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISampleGrabberCB_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISampleGrabberCB_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISampleGrabberCB_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISampleGrabberCB_SampleCB(This,SampleTime,pSample)	\
    ( (This)->lpVtbl -> SampleCB(This,SampleTime,pSample) ) 

#define ISampleGrabberCB_BufferCB(This,SampleTime,pBuffer,BufferLen)	\
    ( (This)->lpVtbl -> BufferCB(This,SampleTime,pBuffer,BufferLen) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISampleGrabberCB_INTERFACE_DEFINED__ */


#ifndef __ISampleGrabber_INTERFACE_DEFINED__
#define __ISampleGrabber_INTERFACE_DEFINED__

/* interface ISampleGrabber */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_ISampleGrabber;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6B652FFF-11FE-4fce-92AD-0266B5D7C78F")
    ISampleGrabber : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetOneShot( 
            BOOL OneShot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMediaType( 
            const AM_MEDIA_TYPE *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectedMediaType( 
            AM_MEDIA_TYPE *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBufferSamples( 
            BOOL BufferThem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentBuffer( 
            /* [out][in] */ long *pBufferSize,
            /* [out] */ long *pBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSample( 
            /* [retval][out] */ IMediaSample **ppSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCallback( 
            ISampleGrabberCB *pCallback,
            long WhichMethodToCallback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISampleGrabberVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISampleGrabber * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISampleGrabber * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISampleGrabber * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetOneShot )( 
            ISampleGrabber * This,
            BOOL OneShot);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            ISampleGrabber * This,
            const AM_MEDIA_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectedMediaType )( 
            ISampleGrabber * This,
            AM_MEDIA_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *SetBufferSamples )( 
            ISampleGrabber * This,
            BOOL BufferThem);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentBuffer )( 
            ISampleGrabber * This,
            /* [out][in] */ long *pBufferSize,
            /* [out] */ long *pBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSample )( 
            ISampleGrabber * This,
            /* [retval][out] */ IMediaSample **ppSample);
        
        HRESULT ( STDMETHODCALLTYPE *SetCallback )( 
            ISampleGrabber * This,
            ISampleGrabberCB *pCallback,
            long WhichMethodToCallback);
        
        END_INTERFACE
    } ISampleGrabberVtbl;

    interface ISampleGrabber
    {
        CONST_VTBL struct ISampleGrabberVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISampleGrabber_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISampleGrabber_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISampleGrabber_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISampleGrabber_SetOneShot(This,OneShot)	\
    ( (This)->lpVtbl -> SetOneShot(This,OneShot) ) 

#define ISampleGrabber_SetMediaType(This,pType)	\
    ( (This)->lpVtbl -> SetMediaType(This,pType) ) 

#define ISampleGrabber_GetConnectedMediaType(This,pType)	\
    ( (This)->lpVtbl -> GetConnectedMediaType(This,pType) ) 

#define ISampleGrabber_SetBufferSamples(This,BufferThem)	\
    ( (This)->lpVtbl -> SetBufferSamples(This,BufferThem) ) 

#define ISampleGrabber_GetCurrentBuffer(This,pBufferSize,pBuffer)	\
    ( (This)->lpVtbl -> GetCurrentBuffer(This,pBufferSize,pBuffer) ) 

#define ISampleGrabber_GetCurrentSample(This,ppSample)	\
    ( (This)->lpVtbl -> GetCurrentSample(This,ppSample) ) 

#define ISampleGrabber_SetCallback(This,pCallback,WhichMethodToCallback)	\
    ( (This)->lpVtbl -> SetCallback(This,pCallback,WhichMethodToCallback) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISampleGrabber_INTERFACE_DEFINED__ */



#ifndef __DexterLib_LIBRARY_DEFINED__
#define __DexterLib_LIBRARY_DEFINED__

/* library DexterLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DexterLib;

#ifndef __IResize_INTERFACE_DEFINED__
#define __IResize_INTERFACE_DEFINED__

/* interface IResize */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IResize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4ada63a0-72d5-11d2-952a-0060081840bc")
    IResize : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_Size( 
            /* [out] */ __RPC__out int *piHeight,
            /* [out] */ __RPC__out int *piWidth,
            /* [out] */ __RPC__out long *pFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_InputSize( 
            /* [out] */ __RPC__out int *piHeight,
            /* [out] */ __RPC__out int *piWidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Size( 
            /* [in] */ int Height,
            /* [in] */ int Width,
            /* [in] */ long Flag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_MediaType( 
            /* [out] */ __RPC__out AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_MediaType( 
            /* [in] */ __RPC__in const AM_MEDIA_TYPE *pmt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResizeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IResize * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IResize * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IResize * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_Size )( 
            IResize * This,
            /* [out] */ __RPC__out int *piHeight,
            /* [out] */ __RPC__out int *piWidth,
            /* [out] */ __RPC__out long *pFlag);
        
        HRESULT ( STDMETHODCALLTYPE *get_InputSize )( 
            IResize * This,
            /* [out] */ __RPC__out int *piHeight,
            /* [out] */ __RPC__out int *piWidth);
        
        HRESULT ( STDMETHODCALLTYPE *put_Size )( 
            IResize * This,
            /* [in] */ int Height,
            /* [in] */ int Width,
            /* [in] */ long Flag);
        
        HRESULT ( STDMETHODCALLTYPE *get_MediaType )( 
            IResize * This,
            /* [out] */ __RPC__out AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *put_MediaType )( 
            IResize * This,
            /* [in] */ __RPC__in const AM_MEDIA_TYPE *pmt);
        
        END_INTERFACE
    } IResizeVtbl;

    interface IResize
    {
        CONST_VTBL struct IResizeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResize_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IResize_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IResize_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IResize_get_Size(This,piHeight,piWidth,pFlag)	\
    ( (This)->lpVtbl -> get_Size(This,piHeight,piWidth,pFlag) ) 

#define IResize_get_InputSize(This,piHeight,piWidth)	\
    ( (This)->lpVtbl -> get_InputSize(This,piHeight,piWidth) ) 

#define IResize_put_Size(This,Height,Width,Flag)	\
    ( (This)->lpVtbl -> put_Size(This,Height,Width,Flag) ) 

#define IResize_get_MediaType(This,pmt)	\
    ( (This)->lpVtbl -> get_MediaType(This,pmt) ) 

#define IResize_put_MediaType(This,pmt)	\
    ( (This)->lpVtbl -> put_MediaType(This,pmt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IResize_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_AMTimeline;

#ifdef __cplusplus

class DECLSPEC_UUID("78530B75-61F9-11D2-8CAD-00A024580902")
AMTimeline;
#endif

EXTERN_C const CLSID CLSID_AMTimelineObj;

#ifdef __cplusplus

class DECLSPEC_UUID("78530B78-61F9-11D2-8CAD-00A024580902")
AMTimelineObj;
#endif

EXTERN_C const CLSID CLSID_AMTimelineSrc;

#ifdef __cplusplus

class DECLSPEC_UUID("78530B7A-61F9-11D2-8CAD-00A024580902")
AMTimelineSrc;
#endif

EXTERN_C const CLSID CLSID_AMTimelineTrack;

#ifdef __cplusplus

class DECLSPEC_UUID("8F6C3C50-897B-11d2-8CFB-00A0C9441E20")
AMTimelineTrack;
#endif

EXTERN_C const CLSID CLSID_AMTimelineComp;

#ifdef __cplusplus

class DECLSPEC_UUID("74D2EC80-6233-11d2-8CAD-00A024580902")
AMTimelineComp;
#endif

EXTERN_C const CLSID CLSID_AMTimelineGroup;

#ifdef __cplusplus

class DECLSPEC_UUID("F6D371E1-B8A6-11d2-8023-00C0DF10D434")
AMTimelineGroup;
#endif

EXTERN_C const CLSID CLSID_AMTimelineTrans;

#ifdef __cplusplus

class DECLSPEC_UUID("74D2EC81-6233-11d2-8CAD-00A024580902")
AMTimelineTrans;
#endif

EXTERN_C const CLSID CLSID_AMTimelineEffect;

#ifdef __cplusplus

class DECLSPEC_UUID("74D2EC82-6233-11d2-8CAD-00A024580902")
AMTimelineEffect;
#endif

EXTERN_C const CLSID CLSID_RenderEngine;

#ifdef __cplusplus

class DECLSPEC_UUID("64D8A8E0-80A2-11d2-8CF3-00A0C9441E20")
RenderEngine;
#endif

EXTERN_C const CLSID CLSID_SmartRenderEngine;

#ifdef __cplusplus

class DECLSPEC_UUID("498B0949-BBE9-4072-98BE-6CCAEB79DC6F")
SmartRenderEngine;
#endif

EXTERN_C const CLSID CLSID_AudMixer;

#ifdef __cplusplus

class DECLSPEC_UUID("036A9790-C153-11d2-9EF7-006008039E37")
AudMixer;
#endif

EXTERN_C const CLSID CLSID_Xml2Dex;

#ifdef __cplusplus

class DECLSPEC_UUID("18C628EE-962A-11D2-8D08-00A0C9441E20")
Xml2Dex;
#endif

EXTERN_C const CLSID CLSID_MediaLocator;

#ifdef __cplusplus

class DECLSPEC_UUID("CC1101F2-79DC-11D2-8CE6-00A0C9441E20")
MediaLocator;
#endif

EXTERN_C const CLSID CLSID_PropertySetter;

#ifdef __cplusplus

class DECLSPEC_UUID("ADF95821-DED7-11d2-ACBE-0080C75E246E")
PropertySetter;
#endif

EXTERN_C const CLSID CLSID_MediaDet;

#ifdef __cplusplus

class DECLSPEC_UUID("65BD0711-24D2-4ff7-9324-ED2E5D3ABAFA")
MediaDet;
#endif

EXTERN_C const CLSID CLSID_SampleGrabber;

#ifdef __cplusplus

class DECLSPEC_UUID("C1F400A0-3F08-11d3-9F0B-006008039E37")
SampleGrabber;
#endif

EXTERN_C const CLSID CLSID_NullRenderer;

#ifdef __cplusplus

class DECLSPEC_UUID("C1F400A4-3F08-11d3-9F0B-006008039E37")
NullRenderer;
#endif

EXTERN_C const CLSID CLSID_DxtCompositor;

#ifdef __cplusplus

class DECLSPEC_UUID("BB44391D-6ABD-422f-9E2E-385C9DFF51FC")
DxtCompositor;
#endif

EXTERN_C const CLSID CLSID_DxtAlphaSetter;

#ifdef __cplusplus

class DECLSPEC_UUID("506D89AE-909A-44f7-9444-ABD575896E35")
DxtAlphaSetter;
#endif

EXTERN_C const CLSID CLSID_DxtJpeg;

#ifdef __cplusplus

class DECLSPEC_UUID("DE75D012-7A65-11D2-8CEA-00A0C9441E20")
DxtJpeg;
#endif

EXTERN_C const CLSID CLSID_ColorSource;

#ifdef __cplusplus

class DECLSPEC_UUID("0cfdd070-581a-11d2-9ee6-006008039e37")
ColorSource;
#endif

EXTERN_C const CLSID CLSID_DxtKey;

#ifdef __cplusplus

class DECLSPEC_UUID("C5B19592-145E-11d3-9F04-006008039E37")
DxtKey;
#endif
#endif /* __DexterLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_qedit_0001_0097 */
/* [local] */ 


enum __MIDL___MIDL_itf_qedit_0001_0097_0001
    {	E_NOTINTREE	= 0x80040400,
	E_RENDER_ENGINE_IS_BROKEN	= 0x80040401,
	E_MUST_INIT_RENDERER	= 0x80040402,
	E_NOTDETERMINED	= 0x80040403,
	E_NO_TIMELINE	= 0x80040404,
	S_WARN_OUTPUTRESET	= 40404
    } ;
#define DEX_IDS_BAD_SOURCE_NAME    1400
#define DEX_IDS_BAD_SOURCE_NAME2    1401
#define DEX_IDS_MISSING_SOURCE_NAME    1402
#define DEX_IDS_UNKNOWN_SOURCE    1403
#define DEX_IDS_INSTALL_PROBLEM    1404
#define DEX_IDS_NO_SOURCE_NAMES    1405
#define DEX_IDS_BAD_MEDIATYPE    1406
#define DEX_IDS_STREAM_NUMBER    1407
#define DEX_IDS_OUTOFMEMORY        1408
#define DEX_IDS_DIBSEQ_NOTALLSAME    1409
#define DEX_IDS_CLIPTOOSHORT        1410
#define DEX_IDS_INVALID_DXT        1411
#define DEX_IDS_INVALID_DEFAULT_DXT    1412
#define DEX_IDS_NO_3D        1413
#define DEX_IDS_BROKEN_DXT        1414
#define DEX_IDS_NO_SUCH_PROPERTY    1415
#define DEX_IDS_ILLEGAL_PROPERTY_VAL    1416
#define DEX_IDS_INVALID_XML        1417
#define DEX_IDS_CANT_FIND_FILTER    1418
#define DEX_IDS_DISK_WRITE_ERROR    1419
#define DEX_IDS_INVALID_AUDIO_FX    1420
#define DEX_IDS_CANT_FIND_COMPRESSOR 1421
#define DEX_IDS_TIMELINE_PARSE    1426
#define DEX_IDS_GRAPH_ERROR        1427
#define DEX_IDS_GRID_ERROR        1428
#define DEX_IDS_INTERFACE_ERROR    1429
EXTERN_GUID(CLSID_VideoEffects1Category, 0xcc7bfb42, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59);
EXTERN_GUID(CLSID_VideoEffects2Category, 0xcc7bfb43, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59);
EXTERN_GUID(CLSID_AudioEffects1Category, 0xcc7bfb44, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59);
EXTERN_GUID(CLSID_AudioEffects2Category, 0xcc7bfb45, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59);


extern RPC_IF_HANDLE __MIDL_itf_qedit_0001_0097_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_qedit_0001_0097_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\qos2.h ===
/*++

Copyright (c) 2004  Microsoft Corporation

Module Name:

    qos2.h

Abstract:

    This module contains QOS structures and function headers

--*/

#pragma once

#include <ws2tcpip.h>
#include <mstcpip.h>

//
// Support calls from C++
//
#if defined(__cplusplus)
    #define ExternC extern "C"
#else
    #define ExternC
#endif

//
// Each admitted flow has a unique Flow ID. This ID is valid only
// in the process which called QOSAddSocketToFlow() for that flow
// with the handle returned from QOSCreateHandle
//
typedef ULONG QOS_FLOWID, *PQOS_FLOWID;

//
// Definitions of various traffic types. Application identifies
// each flow as being of a certain type. This enables the QOS
// subsystem to apply user-specified per-type policies to flows
//
// QOSTrafficTypeBestEffort:
//      
//      This service type requests the same network priority to the traffic 
//      as regular traffic not associated to the qWave api. For home scenarios, 
//      this is DLNA class DLNAQOS_1.
//
// QOSTrafficTypeBackground:
//
//      This service type requests a network priority to the traffic lower than 
//      traffic of type QOSTrafficTypeBestEffort. For example, this service 
//      could be used for traffic of applications doing data backups. For home 
//      scenarios, this is DLNA class DLNAQOS_0.
//
// QOSTrafficTypeExcellentEffort:
//
//      This service type requests a network priority to the traffic higher than 
//      QOSTrafficTypeBestEffort. This service type should be used for data 
//      traffic that, although not A/V, is more important than normal end-user 
//      scenarios. For example, email traffic. This service type is not part of 
//      the DLNA specification.
//
// QOSTrafficTypeAudioVideo:
//
//      This service type should be used for A/V streaming scenarios such as 
//      MPEG2 streaming. For home scenarios, this is DLNA class DLNAQOS_2.
//
// QOSTrafficTypeVoice:
//
//      This service type should be used for realtime voice streams such as 
//      VoIP. This service type is not part of the DLNA specification.
//
// QOSTrafficTypeControl:
//
//      This service type should only be used for the most critical data. For 
//      example, you might use it for data carrying user inputs to an A/V 
//      experience, e.g. play, pause, FF, RW, etc. The A/V traffic however 
//      should use QOSTrafficTypeAudioVideo. For home scenarios, this is DLNA 
//      class DLNAQOS_3.
//
typedef enum _QOS_TRAFFIC_TYPE 
{
    QOSTrafficTypeBestEffort        = 0,
    QOSTrafficTypeBackground        = 1,
    QOSTrafficTypeExcellentEffort   = 2,
    QOSTrafficTypeAudioVideo        = 3,
    QOSTrafficTypeVoice             = 4,
    QOSTrafficTypeControl           = 5
} QOS_TRAFFIC_TYPE, *PQOS_TRAFFIC_TYPE;

//
// This enum lists the operations that may be given to the QOSSetFlow API.
//
// QOSSetTrafficType: 
//
//      Allows an application to change the traffic type of its 
//      flow. For example, this may be useful if you are alternating between 
//      best effort and other types.
//
//      This must be accompanied by a QOS_TRAFFIC_TYPE value.
//
// QOSSetOutgoingRate:
//
//      This allows an application to define the characteristics of the 
//      outgoing traffic on its flow. This may be used to shape the outgoing 
//      traffic or to create a contract linking packet marking to packet 
//      shaping. Such a contract is required for environments were policy uses 
//      admission control. The traffic type will not be respected until a 
//      shaping rate is in place.
//
//      Must be accompagnied by a QOS_FLOWRATE_OUTGOING structure.
//
typedef enum _QOS_SET_FLOW
{
    QOSSetTrafficType           = 0,
    QOSSetOutgoingRate          = 1
} QOS_SET_FLOW, *PQOS_SET_FLOW;

//
// This structure is returned by QOSQueryFlow and allows the application to
// verify what priority markings (or tags) are applied to its traffic. These
// values may change as the flow changes or policies get updated.
//
typedef struct _QOS_PACKET_PRIORITY
{
    ULONG   ConformantDSCPValue;    // the DSCP marking used for the flow's 
                                    // traffic that respects the flow rate 
                                    // specified

    ULONG   NonConformantDSCPValue; // the DSCP marking used for the flow's 
                                    // traffic that exceeds the flow rate 
                                    // specified. Applicable only if shaping 
                                    // behavior is set to 
                                    // QOSUseNonConformantMarkings

    ULONG   ConformantL2Value;      // the L2 tag used for the flow's traffic 
                                    // that respects the flow rate specified

    ULONG   NonConformantL2Value;   // the L2 tag used for the flow's traffic 
                                    // that respects the flow rate specified.
                                    // Applicable only if shaping behavior is 
                                    // set to QOSUseNonConformantMarkings
} QOS_PACKET_PRIORITY, *PQOS_PACKET_PRIORITY;

typedef struct _QOS_FLOW_FUNDAMENTALS
{
    BOOL    BottleneckBandwidthSet; // TRUE if the BottleneckBandwidth field
                                    // contains a value.
    UINT64  BottleneckBandwidth;    // In units of bits/s ; does not include 
                                    // layer 3

    BOOL    AvailableBandwidthSet;  // TRUE if the AvailableBandwidth field
                                    // contains a value.
    UINT64  AvailableBandwidth;     // In units of bits/s ; does not include 
                                    // layer 3

    BOOL    RTTSet;                 // TRUE if the RTT field
                                    // contains a value.
    UINT32  RTT;                    // RTT is in microseconds. 
} QOS_FLOW_FUNDAMENTALS, *PQOS_FLOW_FUNDAMENTALS;

typedef enum _QOS_FLOWRATE_REASON
{
    QOSFlowRateNotApplicable            = 0,
    QOSFlowRateContentChange            = 1,
    QOSFlowRateCongestion               = 2,
    QOSFlowRateHigherContentEncoding    = 3,
    QOSFlowRateUserCaused               = 4
} QOS_FLOWRATE_REASON, *PQOS_FLOWRATE_REASON;

//
// This enum is used to define the shaping behavior. Remember that, if policy
// demands admission control, packet priority is only applied through a contract 
// with the application. This enum allows you to define how the contract is 
// enforced.
//
// QOSShapeOnly: if the flow is set to shape only, qWave will use Window's 
// scheduler to enforce the flow rate requested. Any data packet that would 
// exceed the rate will be delayed until appropriate. Packets will be marked
// as best effort packets.
//
// QOSShapeAndMark: if the flow is set to shape, qWave will use Window's 
// scheduler to enforce the flow rate requested. Any data packet that would 
// exceed the rate will be delayed until appropriate. Packets will always 
// receive conformant priority values.
//
// QOSUseNonConformantMarkings: if the flow is set to use non conformant values,
// qWave will not enforce the flow rate requested. If sending a data packet 
// would exceed the flow rate, this packet will be receive a priority value 
// indicating it is non-conformant. Such packets will receive the lowest 
// possible priority treatment from network equipment. This may lead to lost 
// packets and/or re-ordered packets.
//
typedef enum _QOS_SHAPING{
    QOSShapeOnly                        = 0,
    QOSShapeAndMark                     = 1,
    QOSUseNonConformantMarkings         = 2
} QOS_SHAPING, *PQOS_SHAPING;

#define QOS_OUTGOING_DEFAULT_MINIMUM_BANDWIDTH  0xFFFFFFFF

//
// This struct describes the information required by qWave to accept a flowrate
// from the application. We recommend that you read the description for
// QOS_ADD_OVERHEAD and QOS_SUBTRACT_OVERHEAD before using this structure.
//
// Bandwidth: the rate (in bits/s) you expect to send your traffic at. As a 
// warning, you should note that traffic on the network is measured at the IP 
// level and not at the application level. Thus, the rate you specify should 
// account for the IP and protocol headers. Although there are various ways
// to estimate this final rate, you may wish to use the QOS_ADD_OVERHEAD and
// QOS_SUBTRACT_OVERHEAD functions for these calculations.
//
// If you are unsure what bandwidth value you need but expect to use very little
// use QOS_OUTGOING_DEFAULT_MINIMUM_BANDWIDTH. The system will allocate you
// a small amount of bandwidth for your operations.
//
// ShapingBehavior: how the contract for admission control will be enforced
//
// Reason: if a rate change has occured, this reason should indicate why.
typedef struct _QOS_FLOWRATE_OUTGOING
{
    UINT64                  Bandwidth;      // In units of bits/s
    QOS_SHAPING             ShapingBehavior;// Shaping behavior
    QOS_FLOWRATE_REASON     Reason;         // Optional field for the 
                                            // application to indicate why it's 
                                            // changing a flow's data rate
} QOS_FLOWRATE_OUTGOING, *PQOS_FLOWRATE_OUTGOING;

//
// When using the enum QOSQueryOutgoingRate you should expect the returned rate
// to measure bandwidth at layer 3. If you wish to adjust this rate, based on 
// your application's characteristics, for the IP header and protocol header
// overhead, you should review the QOS_SUBTRACT_OVERHEAD inlined function.
typedef enum _QOS_QUERY_FLOW
{
    QOSQueryFlowFundamentals    = 0,
    QOSQueryPacketPriority      = 1,
    QOSQueryOutgoingRate        = 2
} QOS_QUERY_FLOW, *PQOS_QUERY_FLOW;

typedef enum _QOS_NOTIFY_FLOW
{
    QOSNotifyCongested          = 0,
    QOSNotifyUncongested        = 1,       
    QOSNotifyAvailable          = 2       
} QOS_NOTIFY_FLOW, *PQOS_NOTIFY_FLOW;

//
// The type for QOS protocol version numbers.
// For Vista, the version should be
// MajorVersion: 1
// MinorVersion: 0

typedef struct _QOS_VERSION
{
    USHORT MajorVersion;
    USHORT MinorVersion;
} QOS_VERSION, *PQOS_VERSION;

#define QOS_QUERYFLOW_FRESH         0x00000001
#define QOS_NON_ADAPTIVE_FLOW       0x00000002

__inline
INT
QOS_HEADER_OVERHEAD(
    __in    INT     af, 
    __in    INT     protocol
){
    UINT32 overhead;

    if (af == AF_INET)
        overhead = 20;                          // IPv4 header overhead in bytes
    else
        overhead = 40;                          // IPv6 header overhead in bytes

    if (protocol == IPPROTO_TCP)
        overhead += 20;                         // TCP header overhead in bytes
    else
        overhead += 8;                          // UDP header overhead in bytes

    return overhead;    
}


//
// Description:
//
//  API to calculate the impact of IP and protocol header overhead on a data 
//  rate.
//
// Arguments:
//
//      .af             - Address family used to create the socket. Please 
//                        review the socket and WSASocket documentation. This 
//                        should be AF_INET or AF_INET6
//
//      .protocol       - Protocol type used to create the socket. Please review 
//                        the socket and WSASocket documentation. This should 
//                        be IPPROTO_TCP or IPPROTO_UDP
//
//      .targetDataPacketSize
//                      - This is the expected packet size of your data stream.
//                        ***See note below on targetDataPacketSize***
//
//      .dataRate       - Your dataRate in bits/s.
//
// Note on targetDataPacketSize: 
//
//  If you're using a TCP socket on IPv4 and will be making large sends then you 
//  would expect the data packet size to be 1460 bytes: Ethernet has an MTU of 
//  1500 bytes and the overhead of an IPv4 header is typically 20 bytes 
//  while a TCP header is also 20 bytes.
//
//  If you're using a UDP socket and your packet size varies, you may wish to 
//  pass in a reasonnable minimal value. This would adjust your rate for the
//  worst case.
//
//  The value 0 is an invalid parameter which will result in a division by 0.
//
// Return Values:
//
//  This call will return the data rate, in bits/s, augmented by the overhead
//  on each packet given the address family and the protocol you've created your
//  socket with.
//
__inline
UINT64
QOS_ADD_OVERHEAD(
    __in    INT     af, 
    __in    INT     protocol, 
    __in    UINT32  targetDataPacketSize, 
    __in    UINT64  dataRate
){
    UINT32 overhead;
    double d;
    UINT64 r;

    //
    // Calculate the header overhead
    overhead = QOS_HEADER_OVERHEAD(af, protocol);

    //
    // Convert overhead and dataRate to bits
    overhead *= 8;
    targetDataPacketSize *= 8;

    //
    // The adjustment is:
    //
    //                         (       dataRate                  )
    // returnRate = dataRate + ( -------------------- * overhead )
    //                         ( targetDataPacketSize            )
    //
    // For each packet we expect to see go out, we need to add the 
    // overhead
    d = (double) overhead;
    d /= (double) targetDataPacketSize;
    d *= (double) dataRate;

    r = dataRate;
    r += (UINT64) d;

    return r;
}

//
// Description:
//
//  API to calculate the impact of IP and protocol header overhead on a data 
//  rate.
//
// Arguments:
//
//      .af             - Address family used to create the socket. Please 
//                        review the socket and WSASocket documentation. This 
//                        should be AF_INET or AF_INET6
//
//      .protocol       - Protocol type used to create the socket. Please review 
//                        the socket and WSASocket documentation. This should 
//                        be IPPROTO_TCP or IPPROTO_UDP
//
//      .targetDataPacketSize
//                      - This is the expected packet size of your data stream.
//                        ***See note below on targetDataPacketSize***
//
//      .dataRate       - Your dataRate in bits/s.
//
// Note on targetDataPacketSize: 
//
//  If you're using a TCP socket on IPv4 and will be making large sends then you 
//  would expect the data packet size to be 1460 bytes: Ethernet has an MTU of 
//  1500 bytes and that the overhead of an IPv4 header is typically 20 bytes 
//  while a TCP header is also 20 bytes.
//
//  If you're using a UDP socket and your packet size varies, you may wish to 
//  pass in a reasonnable minimal value. This would adjust your rate for the
//  worst case.
//
// Return Values:
//
//  This call will return the data rate, in bits/s, reduced by the overhead
//  on each packet given the address family and the protocol you've created your
//  socket with.
//
__inline
UINT64
QOS_SUBTRACT_OVERHEAD(
    __in    INT     af, 
    __in    INT     protocol, 
    __in    UINT32  targetDataPacketSize, 
    __in    UINT64  dataRate
){
    UINT32 overhead;
    double d;
    UINT64 r;

    //
    // Calculate the header overhead
    overhead = QOS_HEADER_OVERHEAD(af, protocol);

    //
    // Convert overhead and dataRate to bits
    overhead *= 8;
    targetDataPacketSize *= 8;

    //
    // The adjustment is:
    //
    //                         (            dataRate                        )
    // returnRate = dataRate - ( ------------------------------- * overhead )
    //                         ( targetDataPacketSize + overhead            )
    //
    // For each packet we expect to see go out, we need to add the 
    // overhead
    d = (double) overhead;
    d /= (double) targetDataPacketSize + overhead;
    d *= (double) dataRate;

    r = dataRate;
    r -= (UINT64) d;

    return r;
}

//
// Description:
//
//  API to initialize QOS subsystem. Every process intending to use
//  QOS must first make the QOSCreateHandle call.
//
//  The handle returned by this call is useful for performing
//  overlapped IO. For example, it can be associated with a
//  IOCP to receive overlapped completion notifications.
//
//  Although a single QOSHandle would be sufficient for most applications,
//  applications have the option of calling QOSCreateHandle multiple times
//  to obtain multiple handles
//
//      .Version        - Specifies what version of this API you wish to use.
//                        This parameter must be of type QOS_VERSION. For Vista
//                        the only valid value is 1.0
//
//      .QOSHandle      - On output, if the call is successful, this will return
//                        a file handle to the QOS subsystem. This handle should
//                        be closed with QOSCloseHandle.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError. Here are some of the errors possible.
//  This list is not exhaustive.
//
//      ERROR_SERVICE_DEPENDENCY_FAIL
//          One of the dependencies of the service is unavailable. The qWave
//          service could not be started.
//
//      ERROR_RESOURCE_DISABLED
//          One of the resources required by the service is unavailable. This 
//          error may be returned if the user has not enabled the firewall
//          exception for the qWave service. Please see the developer guidelines 
//          and MSFT firewall documentation for more details.
//
ExternC
BOOL
WINAPI
QOSCreateHandle(
    __in    PQOS_VERSION    Version,
    __out   PHANDLE         QOSHandle
);

//
// Description:
//
//  API to close a handle returned by QOSCreateHandle
//
//  When closing a handle, all flows added on this handle are immediately 
//  removed from the system. Any traffic going out a socket used to create these 
//  flows will no longer be marked. Moreover, any pending operations for these 
//  flows are completed with ERROR_ABORTED.
//
//  If any clients were tracked through this handle, the subsystem will continue
//  tracking these for some limited amount of time. This can be stopped by 
//  calling either QOSStopTrackingClient on this handle before closing it or 
//  through another handle once this one has been closed.
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError.
//
ExternC
BOOL
WINAPI
QOSCloseHandle(
    __in    HANDLE         QOSHandle
);

//
// Description:
//
//  API to inform the QOS subsystem of the existence of a new client. 
//  The QOS subsystem will start gathering statistics about this client device. 
//  This call is NOT required to add a flow, but it is recommended for adaptive
//  flows.
//
//  Ideally, an application would make this API call as soon as it is aware of a 
//  possible client device with which it may need to create a QOS flow. By using
//  this call, you increase the likelihood that qWave will have gathered 
//  sufficient information on the network path to assist you when you attempt to
//  set the flow rate.
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .DestAddr       - IP address of the client device. Note that a client 
//                        is identified strictly by it's IP address and address 
//                        family. A port number is not required and will be 
//                        ignored.
//
//      .Flags          - Used to modify the behavior of the 
//                        QOSStartTrackingClient call. Reserved for future use.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError. Here are some of the errors possible.
//  This list is not exhaustive.
//
//      ERROR_BAD_NET_NAME
//          qWave was unable to reach the host specified. Specifically, address
//          resolution failed.
//
//      ERROR_HOST_UNREACHABLE
//          The qWave service was unable to communicate with the peer host to
//          run qWave experiments. This could be a sign that there is no 
//          qWave sink on the remote host or that a firewall is blocking 
//          communication.
//
//      ERROR_NOT_SUPPORTED
//          The qWave subsystem cannot track information about the destination
//          you've specified. It could be that the other host does does not 
//          have the required components or that it is not on the same link.
//
ExternC
BOOL
WINAPI
QOSStartTrackingClient(
    __in        HANDLE          QOSHandle,
    __in        PSOCKADDR       DestAddr,
    __reserved  DWORD           Flags
);

//
// Description:
//
//  API to remove a client. The QOS subsystem will stop gathering statistics
//  about this client device. This call will only be accepted if 
//  QOSStartTrackingClient was previously called on the host. If a flow is 
//  currently in progress, this will not affect the flow.
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .DestAddr       - IP address of the client device
//
//      .Flags          - Used to modify the behavior of the 
//                        QOSStopTrackingClient call. Reserved for future use.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError.
//
ExternC
BOOL
WINAPI
QOSStopTrackingClient(
    __in        HANDLE          QOSHandle,
    __in        PSOCKADDR       DestAddr,
    __reserved  DWORD           Flags
);

//
// Description:
//
//  API to enumerate all the existing flows. This call requires administrative 
//  rights. Through it the caller can obtain the list of current flow IDs on the 
//  system. Using QOSQueryFlow, one can then query the flows.
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .Size           - On input represents the size in bytes of the buffer. 
//                        On output, if successful, the amount of bytes copied 
//                        in the buffer. If the call fails with 
//                        ERROR_INSUFFICIENT_BUFFER, the parameter size will 
//                        indicate the minimum required buffer size.
//
//      .Buffer         - On output contains an array of QOS_FLOWID.
//
// Note: 
//
//  One cannot modify flows from another process.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError. Here are some of the errors possible.
//  This list is not exhaustive.
//
//      ERROR_ACCESS_DENIED
//          The caller does not have the administrator rights required 
//          to perform this call.
//
ExternC
BOOL
WINAPI
QOSEnumerateFlows(
    __in                HANDLE      QOSHandle,
    __inout             PULONG      Size,
    __out_bcount(*Size) PVOID       Buffer
);

//
// Description:
//
//  API to add a new flow. Note that the flow's traffic is not affected through
//  this call. There are two categories of applications that will use this api:
//  adaptive and non-adaptive. An adaptive application will make use of 
//  notifications and information in QOS_FLOW_FUNDAMENTALS to adapt to changing
//  network characteristics (such as congestion). qWAVE utilizes Link Layer
//  Topology Discovery (LLTD) QoS extensions for adaptive flows, which may be
//  present on the destination. A non-adaptive application either does not 
//  desire to adapt to changing network characteristics (priority marking and/or
//  throttling only), or is sending traffic to an endpoint that does not support
//  this capability as indicated by ERROR_NOT_SUPPORTED. For adaptive 
//  applications, the caller should immediately call QOSSetFlow with the 
//  QOSSetOutgoingRate parameter. Non-adaptive applications or applications 
//  creating non-adaptive flows should call this api with the 
//  QOS_NON_ADAPTIVE_FLOW flag set.
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .Socket         - The socket the application will use to source traffic. 
//                        ***See note below on Socket***
//
//      .DestAddr       - The destination address the application will send 
//                        traffic to. A  destination port must be specified. 
//                        This parameter is optional for connected sockets. See 
//                        the note below.
//
//      .TrafficType    - Describes the type of traffic your flow will be used 
//                        for. This parameter will be ignored when adding a 
//                        socket to an existing flow. 
//
//      .Flags          - Used to modify the behavior of the QOSAddSocketToFlow
//                        call. 
//                        ***See note below on Flags***
//
//      .FlowId         - On input *FlowId MUST be 0 to create a new flow. On 
//                        output, if the call is successful, a flow ID is 
//                        generated and placed in *FlowId. 
//
//                        If you are adding a socket to an existing flow, 
//                        *FlowId will be the flow ID of the existing flow.
//                        ***See note below on Flags***
//
// Note on Socket: 
//
//  If the app wishes to use a different interface to source its data
//  than the one favored by the routing table, it should bind its socket 
//  before calling QOSAddSocketToFlow.
//
// Note on the DestAddr parameter:
//
//  The DestAddr parameter is optional. Since the Qwave api must always 
//  know the destination host (and IP port) to which your traffic will be 
//  sent here are the ramifications:
//
//      1) If your socket is not connected, you MUST specify this parameter. 
//      2) If your socket is connected, you do not need to specify this 
//         parameter however, if you do, the destination host and port must 
//         match that use in the socket's connect call.
//      3) Since, for TCP, the connect call incurs a delay (dependent on  
//         network conditions and the peer host) you may start qWave experiments
//         beforehand. You would call QOSAddSocketToFlow passing in the  
//         application's peer IP address and port.
//
// Note on TrafficType: 
// 
//  Its worth noting that traffic types, if policy allows, will map to a 
//  protocol level tagging of your traffic. For example, the traffic types 
//  equivalent to DLNA may result in the DSCP markings specified in DLNA 
//  being applied. Whether marking is applied, and if so which value, is 
//  controlled by the policy system. In effect this is a request which may,
//  or may not, as appropriate for the network infrastructure, be honored.
//
//  Policy may also require that you run through some form of admission 
//  control and bind yourself to a contract. This is useful to prevent
//  applications from swamping the network. Such admission control will
//  rely on both your traffic type and the flow rate of your traffic. When 
//  possible, you should specify the flow rate of your application using the
//  QOSSetFlow call with the QOSSetOutgoingRate operation.
//
// Note on Flags:
//
//  Only one flag is currently supported for QOSAddSocketToFlow.
//
//      QOS_NON_ADAPTIVE_FLOW - If specified, the QOS subsystem will not gather
//                              data about the network path for this flow. As a 
//                              result, APIs which rely on bandwidth estimation
//                              techniques will not be available. For example, 
//                              this would block QOSQueryFlow with 
//                              QOSQueryFlowFundamentals and QOSNotifyFlow with
//                              QOSNotifyCongested, QOSNotifyUncongested or
//                              QOSNotifyAvailable.
//
//                              An application should use this flag if it does
//                              not intent to adapt its flow to changes in the
//                              state of the network be it because of its
//                              scenario, type of network or capabilities of
//                              the receiving host.
//
//                              You can only add multiple sockets to the same 
//                              flow if the flow is not adaptive. You must also 
//                              specify this flag when you call to add a socket
//                              to an existing flow.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError. Here are some of the errors possible.
//  This list is not exhaustive.
//
//      ERROR_BAD_NET_NAME
//          qWave was unable to reach the host specified. Specifically, address
//          resolution failed.
//
//      ERROR_CONNECTION_REFUSED
//          QOS could not connect to destination device. The remote host
//          rejected the connection.
//
//      ERROR_HOST_UNREACHABLE
//          The host is not reachable given the current network configuration. 
//          If the host was previously reachable, you should confirm that there
//          hasn't been a PnP state change
//
//      ERROR_NOT_SUPPORTED
//          The qWave subsystem cannot track information about the destination
//          you've specified. It could be that the other host does does not 
//          have the required components or that it is not on the same link.
//
ExternC
BOOL
WINAPI
QOSAddSocketToFlow(
    __in        HANDLE              QOSHandle,          
    __in        SOCKET              Socket,
    __in_opt    PSOCKADDR           DestAddr,
    __in        QOS_TRAFFIC_TYPE    TrafficType,
    __in_opt    DWORD               Flags,
    __inout     PQOS_FLOWID         FlowId
);

//
// Description:
//
//  API used by app to notify QOS subsystem that a previously admitted flow has 
//  been terminated by the app. QOS subsystem uses this call to update its 
//  internal information
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .Socket         - Socket to be removed from the flow
//                        ***See note below on Socket***
//
//      .FlowId         - The flow which the app is interested in modifying. 
//                        This is obtained through QOSAddSocketToFlow.
//
//      .Flags          - Used to modify the behavior of the 
//                        QOSRemoveSocketFromFlow call. This is currently 
//                        reserved for future use.
//
// Note: 
//
//  Closing a QOSHandle will automatically abort all pending operations issued 
//  on that QOSHandle. If the handle is closed while a QOSRemoveSocketFromFlow 
//  call is still in progress, the call will complete with 
//  ERROR_OPERATION_ABORTED. 
//
// Note on Socket: 
// 
//  Only flows created with the QOS_NON_ADAPTIVE_FLOW flag may have multiple
//  sockets added to the same flow. By passing a socket parameter in this
//  api call you can remove each of these individually. 
//
//  If you do not pass a socket, the flow will be destroyed.
//
//  If only one socket was attached to the flow, passing this socket as a 
//  parameter to this api and passing NULL as a socket are equivalent calls.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError. Here are some of the errors possible.
//  This list is not exhaustive.
//
//      ERROR_NOT_FOUND
//          Invalid FlowId specified
//
ExternC
BOOL
WINAPI
QOSRemoveSocketFromFlow(
    __in        HANDLE              QOSHandle,
    __in_opt    SOCKET              Socket,
    __in        QOS_FLOWID          FlowId,
    __reserved  DWORD               Flags
);

//
// Description:
//
//  This API is used by the app to inform the QOS subsystem of change in a flow.
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .FlowId         - The flow which the app is interested in modifying 
//                        This is obtained through QOSAddSocketToFlow.
//
//      .Operation      - What modification on the flow you are trying to 
//                        apply. This must be of the type QOS_SET_FLOW. The 
//                        input parameter should match the requested flow 
//                        information.
//                        ***See note below on Operation***
//
//      .Size           - The length, in bytes, of Buffer. You should specify 
//                        the correct buffer length for the structure you
//                        specify in Buffer.
//                        ***See note below on Operation***
//
//      .Buffer         - Pointer to the buffer to describe the modication.
//                        ***See note below on Operation***
//
//      .Flags          - Used to modify the behavior of the QOSSetFlow call.
//                        This is currently reserved for future use.
//
//      .Overlapped     - Pointer to an OVERLAPPED structure. 
//
// Note on Operation:
//
//  Given the input parameter for operation, the content of the buffer passed in 
//  will differ. Here is the mapping:
//
//      QOSSetTrafficType           - QOS_TRAFFIC_TYPE
//      QOSSetOutgoingRate          - QOS_FLOWRATE_OUTGOING
//
//  Specific to QOS_FLOWRATE_OUTGOING structure:
//
//      Bandwidth is defined as number of bits per second. It should include 
//      Layer 3 overhead (e.g. IPv4 header, UDP, etc.). You may want to use the 
//      macro QOS_ADD_OVERHEAD to help you estimate the overhead.
//
//      Using Bandwidth == 0 disables shaping and stops affecting the flow (e.g. 
//      the traffic is not marked anymore). MinPacketSize will be ignored.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError. Here are some of the errors possible.
//  This list is not exhaustive.
//
//      ERROR_ACCESS_DISABLED_BY_POLICY
//          The QOS subsystem is currently configured by policy to not allow 
//          this operation on the network path between this host and 
//          your destination host.
//
//      ERROR_BUSY
//          Indicates that the QOS subsystem has not had enough CPU cycles to
//          estimate the network characteristics of the path.
//
//      ERROR_IO_PENDING          
//          Indicates that update flow request was successfully initiated
//          (results will be returned during overlapped completion)
//      
//      ERROR_NETWORK_BUSY
//          Indicates that the requested flow properties were not available
//          on this path. The network currently cannot support the 
//          characteristics you requested
//
//      ERROR_NOT_FOUND
//          Invalid FlowId specified
//
//      ERROR_NOT_SUPPORTED
//          The operation you're trying to do requires information about the
//          network which the qWave subsystem does not have. Obtaining this
//          information on your network is currently not supported.
//
//      ERROR_RETRY
//          There is currently insufficient data about networking conditions
//          to answer your query. This is typically a transient state where
//          qWave has erred on the side of caution as it waits for more data
//          before ascertaining the state of the network.
//
ExternC
BOOL
WINAPI
QOSSetFlow(
    __in                HANDLE          QOSHandle,          
    __in                QOS_FLOWID      FlowId,             
    __in                QOS_SET_FLOW    Operation,
    __in                ULONG           Size,
    __in_bcount(Size)   PVOID           Buffer,  
    __reserved          DWORD           Flags,
    __out_opt           LPOVERLAPPED    Overlapped
);

//
// Description:
//
//  API to query information about a flow. 
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .FlowId         - The flow which the app is interested in receiving 
//                        information about. This is obtained through 
//                        QOSAddSocketToFlow.
//
//      .Operation      - What information about the flow you are trying to 
//                        obtain. This must be of the type QOS_QUERY_FLOW. The 
//                        input parameter should match the requested flow 
//                        information.
//                        ***See note below on Operation***
//
//      .Size           - The length, in bytes, of Buffer. If the buffer 
//                        specified is too small, the call will fail with error
//                        ERROR_INSUFFICIENT_BUFFER and this parameter will 
//                        be updated the appropriate buffer size.
//                        ***See note below on Operation***
//
//      .Buffer         - Pointer to the buffer to receive the queried data.
//                        ***See note below on Operation***
//
//      .Flags          - Used to modify the behavior of the QOSQueryFlow call.
//                        ***See note below on Flags***
//
//      .Overlapped     - Pointer to an OVERLAPPED structure. 
//
// Note on Operation:
//
//  Given the input parameter for operation, the buffer passed in will differ.
//  Here is the mapping.
//
//      QOSQueryFlowFundamentals    - QOS_FLOW_FUNDAMENTALS
//
//      QOSQueryPacketPriority      - QOS_PACKET_PRIORITY
//
//                                    This structure will return the actual
//                                    priority markings applied to your traffic
//                                    by the QOS subsystem given your asks and
//                                    the policy subsystem.
//
//      QOSQueryOutgoingRate        - UINT64
//
// Note on Flags:
//
//  Only one flag is currently supported for QOSQueryFlow.
//
//      QOS_QUERYFLOW_FRESH -   If specified, the QOS subsystem will only return 
//                              once fresh data is available. If fresh data is 
//                              unavailable, it will try to obtain such data. 
//                              If this is not possible, the call will fail 
//                              with ERROR_RETRY.
//
//                              This flag is only valid for 
//                              QOSQueryFlowFundamentals.
//                              Note, this parameter is ignored if the caller is
//                              not the owner of the flow.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError. Here are some of the errors possible.
//  This list is not exhaustive.
//
//      ERROR_ACCESS_DISABLED_BY_POLICY
//          The QOS subsystem is currently configured by policy to not allow 
//          this operation on the network path between this host and 
//          your destination host.
//
//      ERROR_BUSY
//          Indicates that the QOS subsystem has not had enough CPU cycles to
//          estimate the network characteristics of the path.
//
//      ERROR_HOST_UNREACHABLE
//          The host is not reachable given the current network configuration. 
//          If the host was previously reachable, you should confirm that there
//          hasn't been a PnP state change
//
//      ERROR_INSUFFICIENT_BUFFER
//          The buffer length, as specified through Size, is not sufficient
//          for the queried data. Size now contains the required size.
//
//      ERROR_IO_PENDING          
//          Indicates that update flow request was successfully initiated
//          (results will be returned during overlapped completion)
//      
//      ERROR_NOT_FOUND
//          Invalid FlowId specified
//
//      ERROR_NOT_SUPPORTED
//          The operation you're trying to do requires information about the
//          network which the qWave subsystem does not have. Obtaining this
//          information on your network is currently not supported.
//
//      ERROR_RETRY
//          There is currently insufficient data about networking conditions
//          to answer your query. This is typically a transient state where
//          qWave has erred on the side of caution as it waits for more data
//          before ascertaining the state of the network.
//
ExternC
BOOL
WINAPI
QOSQueryFlow(
    __in                HANDLE              QOSHandle,
    __in                QOS_FLOWID          FlowId,
    __in                QOS_QUERY_FLOW      Operation,
    __inout             PULONG              Size,
    __out_bcount(*Size) PVOID               Buffer,  
    __in_opt            DWORD               Flags,
    __out_opt           LPOVERLAPPED        Overlapped
);

//
// Description:
//
//  API to receive notification of change of network characteristics.
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .FlowId         - The flow which the app is interested in receiving 
//                        notifications on changes. This is obtained through 
//                        QOSAddSocketToFlow.
//
//      .Operation      - What notification about the flow you are trying to 
//                        obtain. This must be of the type QOS_NOTIFY_FLOW. The 
//                        input parameter should match the requested flow 
//                        information.
//
//      .Size           - The length, in bytes, of Buffer. You should specify 
//                        the correct buffer length for the structure you
//                        specify in Buffer.
//                        ***See note below on Operation***
//
//      .Buffer         - Pointer to the buffer to receive the queried data.
//                        ***See note below on Operation***
//
//      .Flags          - Used to modify the behavior of the QOSNotifyFlow call.
//                        This is currently reserved for future use.
//
//      .Overlapped     - Pointer to an OVERLAPPED structure. 
//
//
// Note on Operation:
//
//  The following notification may be supported.
//
//  1)  QOSNotifyCongested
//
//      QOSNotifyCongested will complete the operation when the network path
//      is congested. If the path is presently congested, the operation may 
//      complete immediately.
//
//      NOTE: The optional parameters Size and Buffer must be NULL.
//
//  2)  QOSNotifyUncongested
//
//      QOSNotifyUncongested will complete the operation when the network path
//      is not congested. If the path is not presently congested, the operation 
//      may complete immediately.
//
//      NOTE: The optional parameters Size and Buffer must be NULL.
//
//  2)  QOSNotifyAvailable
//
//      QOSNotifyAvailable will complete when available capacity is sufficient 
//      to allow an existing flow to be upgraded from its currently admitted
//      bandwidth to the specified bandwidth. This should be used to upgrade a 
//      transrated flow back to full bandwidth.
//      Requested bandwidth should include Layer 3 overhead. Please use the 
//      QOS_ADD_OVERHEAD function inlined in this header file as a starting 
//      point for your calculations.
//
//      The Buffer parameter should point to a UINT64 value with the requested
//      bandwidth. This value should be the target bandwidth of the flow.
//      For example, if your flow is using 3 Mb but you want to increase that 
//      by 2 Mb, the parameter Buffer should point to a UINT64 with the value
//      5 Mb.
//
//      UINT64    Requested bandwidth
//
//      The call will fail if the requested bandwidth is less than or equal 
//      to the bandwidth the flow is already using.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError. Here are some of the errors possible.
//  This list is not exhaustive.
//
//      ERROR_ACCESS_DISABLED_BY_POLICY
//          The QOS subsystem is currently configured by policy to not allow 
//          this operation on the network path between this host and 
//          your destination host.
//
//      ERROR_ALREADY_EXISTS
//          There is already a request for notification of the same type pending
//          on this flow.
//
//      ERROR_HOST_UNREACHABLE
//          The host is not reachable given the current network configuration. 
//          If the host was previously reachable, you should confirm that there
//          hasn't been a PnP state change
//
//      ERROR_IO_PENDING          
//          Indicates that update flow request was successfully initiated
//          (results will be returned during overlapped completion)
//      
//      ERROR_NOT_FOUND
//          Invalid FlowId specified
//
//      ERROR_NOT_SUPPORTED
//          The operation you're trying to do requires information about the
//          network which the qWave subsystem does not have. Obtaining this
//          information on your network is currently not supported.
//
ExternC
BOOL
WINAPI
QOSNotifyFlow(
    __in                        HANDLE          QOSHandle,
    __in                        QOS_FLOWID      FlowId,
    __in                        QOS_NOTIFY_FLOW Operation,
    __inout_opt                 PULONG          Size,
    __inout_bcount_opt(*Size)   PVOID           Buffer,
    __reserved                  DWORD           Flags,
    __out_opt                   LPOVERLAPPED    Overlapped
);

//
// Description:
//
//  API to cancel a pending operation like QOSSetFlow.
// 
//  Closing a QOSHandle will automatically abort all pending
//  operations issued on that QOSHandle. If the handle is closed while
//  a QOSCancel call is still in progress, the call will complete 
//  with ERROR_OPERATION_ABORTED. 
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .Overlapped     - Pointer to an OVERLAPPED structure. This is the 
//                        OVERLAPPED structure used in the original operation.
//
// Note: 
//
//  The QOSCancel call must be made in the same process from
//  which the original to-be-cancelled call was made.
// 
// Return Values:
//
//  If the function can successfully initiate cancellation of the specified 
//  operation, the return value is nonzero. The cancelled operation completes 
//  via its completion mechanism and indicates ERROR_OPERATION_ABORTED as the 
//  completion code.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError.
//
ExternC
BOOL
WINAPI
QOSCancel(
    __in    HANDLE          QOSHandle,          
    __in    LPOVERLAPPED    Overlapped
);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\qmgr.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for qmgr.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __qmgr_h__
#define __qmgr_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IBackgroundCopyJob1_FWD_DEFINED__
#define __IBackgroundCopyJob1_FWD_DEFINED__
typedef interface IBackgroundCopyJob1 IBackgroundCopyJob1;
#endif 	/* __IBackgroundCopyJob1_FWD_DEFINED__ */


#ifndef __IEnumBackgroundCopyJobs1_FWD_DEFINED__
#define __IEnumBackgroundCopyJobs1_FWD_DEFINED__
typedef interface IEnumBackgroundCopyJobs1 IEnumBackgroundCopyJobs1;
#endif 	/* __IEnumBackgroundCopyJobs1_FWD_DEFINED__ */


#ifndef __IBackgroundCopyGroup_FWD_DEFINED__
#define __IBackgroundCopyGroup_FWD_DEFINED__
typedef interface IBackgroundCopyGroup IBackgroundCopyGroup;
#endif 	/* __IBackgroundCopyGroup_FWD_DEFINED__ */


#ifndef __IEnumBackgroundCopyGroups_FWD_DEFINED__
#define __IEnumBackgroundCopyGroups_FWD_DEFINED__
typedef interface IEnumBackgroundCopyGroups IEnumBackgroundCopyGroups;
#endif 	/* __IEnumBackgroundCopyGroups_FWD_DEFINED__ */


#ifndef __IBackgroundCopyCallback1_FWD_DEFINED__
#define __IBackgroundCopyCallback1_FWD_DEFINED__
typedef interface IBackgroundCopyCallback1 IBackgroundCopyCallback1;
#endif 	/* __IBackgroundCopyCallback1_FWD_DEFINED__ */


#ifndef __IBackgroundCopyQMgr_FWD_DEFINED__
#define __IBackgroundCopyQMgr_FWD_DEFINED__
typedef interface IBackgroundCopyQMgr IBackgroundCopyQMgr;
#endif 	/* __IBackgroundCopyQMgr_FWD_DEFINED__ */


#ifndef __BackgroundCopyQMgr_FWD_DEFINED__
#define __BackgroundCopyQMgr_FWD_DEFINED__

#ifdef __cplusplus
typedef class BackgroundCopyQMgr BackgroundCopyQMgr;
#else
typedef struct BackgroundCopyQMgr BackgroundCopyQMgr;
#endif /* __cplusplus */

#endif 	/* __BackgroundCopyQMgr_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "ocidl.h"
#include "docobj.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_qmgr_0000_0000 */
/* [local] */ 

// Background Copy QMgr Public Interface
#define  QM_NOTIFY_FILE_DONE         0x00000001
#define  QM_NOTIFY_JOB_DONE          0x00000002
#define  QM_NOTIFY_GROUP_DONE        0x00000004
#define  QM_NOTIFY_DISABLE_NOTIFY    0x00000040
#define  QM_NOTIFY_USE_PROGRESSEX    0x00000080
#define  QM_STATUS_FILE_COMPLETE     0x00000001
#define  QM_STATUS_FILE_INCOMPLETE   0x00000002
#define  QM_STATUS_JOB_COMPLETE      0x00000004
#define  QM_STATUS_JOB_INCOMPLETE    0x00000008
#define  QM_STATUS_JOB_ERROR         0x00000010
#define  QM_STATUS_JOB_FOREGROUND    0x00000020
#define  QM_STATUS_GROUP_COMPLETE    0x00000040
#define  QM_STATUS_GROUP_INCOMPLETE  0x00000080
#define  QM_STATUS_GROUP_SUSPENDED   0x00000100
#define  QM_STATUS_GROUP_ERROR       0x00000200
#define  QM_STATUS_GROUP_FOREGROUND  0x00000400
#define  QM_PROTOCOL_HTTP            1
#define  QM_PROTOCOL_FTP             2
#define  QM_PROTOCOL_SMB             3
#define  QM_PROTOCOL_CUSTOM          4
#define  QM_PROGRESS_PERCENT_DONE    1
#define  QM_PROGRESS_TIME_DONE       2
#define  QM_PROGRESS_SIZE_DONE       3
#define  QM_E_INVALID_STATE          0x81001001
#define  QM_E_SERVICE_UNAVAILABLE    0x81001002
#define  QM_E_DOWNLOADER_UNAVAILABLE 0x81001003
#define  QM_E_ITEM_NOT_FOUND         0x81001004


extern RPC_IF_HANDLE __MIDL_itf_qmgr_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_qmgr_0000_0000_v0_0_s_ifspec;

#ifndef __IBackgroundCopyJob1_INTERFACE_DEFINED__
#define __IBackgroundCopyJob1_INTERFACE_DEFINED__

/* interface IBackgroundCopyJob1 */
/* [object][helpstring][uuid] */ 

typedef struct _FILESETINFO
    {
    BSTR bstrRemoteFile;
    BSTR bstrLocalFile;
    DWORD dwSizeHint;
    } 	FILESETINFO;


EXTERN_C const IID IID_IBackgroundCopyJob1;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("59f5553c-2031-4629-bb18-2645a6970947")
    IBackgroundCopyJob1 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CancelJob( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProgress( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__out DWORD *pdwProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ __RPC__out DWORD *pdwStatus,
            /* [out] */ __RPC__out DWORD *pdwWin32Result,
            /* [out] */ __RPC__out DWORD *pdwTransportResult,
            /* [out] */ __RPC__out DWORD *pdwNumOfRetries) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFiles( 
            /* [in] */ ULONG cFileCount,
            /* [size_is][in] */ __RPC__in_ecount_full(cFileCount) FILESETINFO **ppFileSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFile( 
            /* [in] */ ULONG cFileIndex,
            /* [out] */ __RPC__out FILESETINFO *pFileInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileCount( 
            /* [out] */ __RPC__out DWORD *pdwFileCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SwitchToForeground( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_JobID( 
            /* [out] */ __RPC__out GUID *pguidJobID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBackgroundCopyJob1Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBackgroundCopyJob1 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBackgroundCopyJob1 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBackgroundCopyJob1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CancelJob )( 
            IBackgroundCopyJob1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProgress )( 
            IBackgroundCopyJob1 * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__out DWORD *pdwProgress);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IBackgroundCopyJob1 * This,
            /* [out] */ __RPC__out DWORD *pdwStatus,
            /* [out] */ __RPC__out DWORD *pdwWin32Result,
            /* [out] */ __RPC__out DWORD *pdwTransportResult,
            /* [out] */ __RPC__out DWORD *pdwNumOfRetries);
        
        HRESULT ( STDMETHODCALLTYPE *AddFiles )( 
            IBackgroundCopyJob1 * This,
            /* [in] */ ULONG cFileCount,
            /* [size_is][in] */ __RPC__in_ecount_full(cFileCount) FILESETINFO **ppFileSet);
        
        HRESULT ( STDMETHODCALLTYPE *GetFile )( 
            IBackgroundCopyJob1 * This,
            /* [in] */ ULONG cFileIndex,
            /* [out] */ __RPC__out FILESETINFO *pFileInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileCount )( 
            IBackgroundCopyJob1 * This,
            /* [out] */ __RPC__out DWORD *pdwFileCount);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToForeground )( 
            IBackgroundCopyJob1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_JobID )( 
            IBackgroundCopyJob1 * This,
            /* [out] */ __RPC__out GUID *pguidJobID);
        
        END_INTERFACE
    } IBackgroundCopyJob1Vtbl;

    interface IBackgroundCopyJob1
    {
        CONST_VTBL struct IBackgroundCopyJob1Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBackgroundCopyJob1_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBackgroundCopyJob1_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBackgroundCopyJob1_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBackgroundCopyJob1_CancelJob(This)	\
    ( (This)->lpVtbl -> CancelJob(This) ) 

#define IBackgroundCopyJob1_GetProgress(This,dwFlags,pdwProgress)	\
    ( (This)->lpVtbl -> GetProgress(This,dwFlags,pdwProgress) ) 

#define IBackgroundCopyJob1_GetStatus(This,pdwStatus,pdwWin32Result,pdwTransportResult,pdwNumOfRetries)	\
    ( (This)->lpVtbl -> GetStatus(This,pdwStatus,pdwWin32Result,pdwTransportResult,pdwNumOfRetries) ) 

#define IBackgroundCopyJob1_AddFiles(This,cFileCount,ppFileSet)	\
    ( (This)->lpVtbl -> AddFiles(This,cFileCount,ppFileSet) ) 

#define IBackgroundCopyJob1_GetFile(This,cFileIndex,pFileInfo)	\
    ( (This)->lpVtbl -> GetFile(This,cFileIndex,pFileInfo) ) 

#define IBackgroundCopyJob1_GetFileCount(This,pdwFileCount)	\
    ( (This)->lpVtbl -> GetFileCount(This,pdwFileCount) ) 

#define IBackgroundCopyJob1_SwitchToForeground(This)	\
    ( (This)->lpVtbl -> SwitchToForeground(This) ) 

#define IBackgroundCopyJob1_get_JobID(This,pguidJobID)	\
    ( (This)->lpVtbl -> get_JobID(This,pguidJobID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBackgroundCopyJob1_INTERFACE_DEFINED__ */


#ifndef __IEnumBackgroundCopyJobs1_INTERFACE_DEFINED__
#define __IEnumBackgroundCopyJobs1_INTERFACE_DEFINED__

/* interface IEnumBackgroundCopyJobs1 */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumBackgroundCopyJobs1;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8baeba9d-8f1c-42c4-b82c-09ae79980d25")
    IEnumBackgroundCopyJobs1 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) GUID *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumBackgroundCopyJobs1 **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *puCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumBackgroundCopyJobs1Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumBackgroundCopyJobs1 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumBackgroundCopyJobs1 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumBackgroundCopyJobs1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumBackgroundCopyJobs1 * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) GUID *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumBackgroundCopyJobs1 * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumBackgroundCopyJobs1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumBackgroundCopyJobs1 * This,
            /* [out] */ __RPC__deref_out_opt IEnumBackgroundCopyJobs1 **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumBackgroundCopyJobs1 * This,
            /* [out] */ __RPC__out ULONG *puCount);
        
        END_INTERFACE
    } IEnumBackgroundCopyJobs1Vtbl;

    interface IEnumBackgroundCopyJobs1
    {
        CONST_VTBL struct IEnumBackgroundCopyJobs1Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumBackgroundCopyJobs1_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumBackgroundCopyJobs1_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumBackgroundCopyJobs1_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumBackgroundCopyJobs1_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumBackgroundCopyJobs1_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumBackgroundCopyJobs1_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumBackgroundCopyJobs1_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#define IEnumBackgroundCopyJobs1_GetCount(This,puCount)	\
    ( (This)->lpVtbl -> GetCount(This,puCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumBackgroundCopyJobs1_INTERFACE_DEFINED__ */


#ifndef __IBackgroundCopyGroup_INTERFACE_DEFINED__
#define __IBackgroundCopyGroup_INTERFACE_DEFINED__

/* interface IBackgroundCopyGroup */
/* [object][helpstring][uuid] */ 

typedef 
enum GROUPPROP
    {	GROUPPROP_PRIORITY	= 0,
	GROUPPROP_REMOTEUSERID	= 1,
	GROUPPROP_REMOTEUSERPWD	= 2,
	GROUPPROP_LOCALUSERID	= 3,
	GROUPPROP_LOCALUSERPWD	= 4,
	GROUPPROP_PROTOCOLFLAGS	= 5,
	GROUPPROP_NOTIFYFLAGS	= 6,
	GROUPPROP_NOTIFYCLSID	= 7,
	GROUPPROP_PROGRESSSIZE	= 8,
	GROUPPROP_PROGRESSPERCENT	= 9,
	GROUPPROP_PROGRESSTIME	= 10,
	GROUPPROP_DISPLAYNAME	= 11,
	GROUPPROP_DESCRIPTION	= 12
    } 	GROUPPROP;


EXTERN_C const IID IID_IBackgroundCopyGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1ded80a7-53ea-424f-8a04-17fea9adc4f5")
    IBackgroundCopyGroup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProp( 
            /* [in] */ GROUPPROP propID,
            /* [out] */ __RPC__out VARIANT *pvarVal) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetProp( 
            /* [in] */ GROUPPROP propID,
            /* [in] */ VARIANT *pvarVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProgress( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__out DWORD *pdwProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ __RPC__out DWORD *pdwStatus,
            /* [out] */ __RPC__out DWORD *pdwJobIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetJob( 
            /* [in] */ GUID jobID,
            /* [out] */ __RPC__deref_out_opt IBackgroundCopyJob1 **ppJob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SuspendGroup( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeGroup( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelGroup( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Size( 
            /* [out] */ __RPC__out DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_GroupID( 
            /* [out] */ __RPC__out GUID *pguidGroupID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateJob( 
            /* [in] */ GUID guidJobID,
            /* [out] */ __RPC__deref_out_opt IBackgroundCopyJob1 **ppJob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumJobs( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IEnumBackgroundCopyJobs1 **ppEnumJobs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SwitchToForeground( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryNewJobInterface( 
            /* [in] */ __RPC__in REFIID iid,
            /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **pUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNotificationPointer( 
            /* [in] */ __RPC__in REFIID iid,
            /* [in] */ __RPC__in_opt IUnknown *pUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBackgroundCopyGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBackgroundCopyGroup * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBackgroundCopyGroup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBackgroundCopyGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProp )( 
            IBackgroundCopyGroup * This,
            /* [in] */ GROUPPROP propID,
            /* [out] */ __RPC__out VARIANT *pvarVal);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetProp )( 
            IBackgroundCopyGroup * This,
            /* [in] */ GROUPPROP propID,
            /* [in] */ VARIANT *pvarVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetProgress )( 
            IBackgroundCopyGroup * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__out DWORD *pdwProgress);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IBackgroundCopyGroup * This,
            /* [out] */ __RPC__out DWORD *pdwStatus,
            /* [out] */ __RPC__out DWORD *pdwJobIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetJob )( 
            IBackgroundCopyGroup * This,
            /* [in] */ GUID jobID,
            /* [out] */ __RPC__deref_out_opt IBackgroundCopyJob1 **ppJob);
        
        HRESULT ( STDMETHODCALLTYPE *SuspendGroup )( 
            IBackgroundCopyGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeGroup )( 
            IBackgroundCopyGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *CancelGroup )( 
            IBackgroundCopyGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_Size )( 
            IBackgroundCopyGroup * This,
            /* [out] */ __RPC__out DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *get_GroupID )( 
            IBackgroundCopyGroup * This,
            /* [out] */ __RPC__out GUID *pguidGroupID);
        
        HRESULT ( STDMETHODCALLTYPE *CreateJob )( 
            IBackgroundCopyGroup * This,
            /* [in] */ GUID guidJobID,
            /* [out] */ __RPC__deref_out_opt IBackgroundCopyJob1 **ppJob);
        
        HRESULT ( STDMETHODCALLTYPE *EnumJobs )( 
            IBackgroundCopyGroup * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IEnumBackgroundCopyJobs1 **ppEnumJobs);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToForeground )( 
            IBackgroundCopyGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryNewJobInterface )( 
            IBackgroundCopyGroup * This,
            /* [in] */ __RPC__in REFIID iid,
            /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **pUnk);
        
        HRESULT ( STDMETHODCALLTYPE *SetNotificationPointer )( 
            IBackgroundCopyGroup * This,
            /* [in] */ __RPC__in REFIID iid,
            /* [in] */ __RPC__in_opt IUnknown *pUnk);
        
        END_INTERFACE
    } IBackgroundCopyGroupVtbl;

    interface IBackgroundCopyGroup
    {
        CONST_VTBL struct IBackgroundCopyGroupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBackgroundCopyGroup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBackgroundCopyGroup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBackgroundCopyGroup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBackgroundCopyGroup_GetProp(This,propID,pvarVal)	\
    ( (This)->lpVtbl -> GetProp(This,propID,pvarVal) ) 

#define IBackgroundCopyGroup_SetProp(This,propID,pvarVal)	\
    ( (This)->lpVtbl -> SetProp(This,propID,pvarVal) ) 

#define IBackgroundCopyGroup_GetProgress(This,dwFlags,pdwProgress)	\
    ( (This)->lpVtbl -> GetProgress(This,dwFlags,pdwProgress) ) 

#define IBackgroundCopyGroup_GetStatus(This,pdwStatus,pdwJobIndex)	\
    ( (This)->lpVtbl -> GetStatus(This,pdwStatus,pdwJobIndex) ) 

#define IBackgroundCopyGroup_GetJob(This,jobID,ppJob)	\
    ( (This)->lpVtbl -> GetJob(This,jobID,ppJob) ) 

#define IBackgroundCopyGroup_SuspendGroup(This)	\
    ( (This)->lpVtbl -> SuspendGroup(This) ) 

#define IBackgroundCopyGroup_ResumeGroup(This)	\
    ( (This)->lpVtbl -> ResumeGroup(This) ) 

#define IBackgroundCopyGroup_CancelGroup(This)	\
    ( (This)->lpVtbl -> CancelGroup(This) ) 

#define IBackgroundCopyGroup_get_Size(This,pdwSize)	\
    ( (This)->lpVtbl -> get_Size(This,pdwSize) ) 

#define IBackgroundCopyGroup_get_GroupID(This,pguidGroupID)	\
    ( (This)->lpVtbl -> get_GroupID(This,pguidGroupID) ) 

#define IBackgroundCopyGroup_CreateJob(This,guidJobID,ppJob)	\
    ( (This)->lpVtbl -> CreateJob(This,guidJobID,ppJob) ) 

#define IBackgroundCopyGroup_EnumJobs(This,dwFlags,ppEnumJobs)	\
    ( (This)->lpVtbl -> EnumJobs(This,dwFlags,ppEnumJobs) ) 

#define IBackgroundCopyGroup_SwitchToForeground(This)	\
    ( (This)->lpVtbl -> SwitchToForeground(This) ) 

#define IBackgroundCopyGroup_QueryNewJobInterface(This,iid,pUnk)	\
    ( (This)->lpVtbl -> QueryNewJobInterface(This,iid,pUnk) ) 

#define IBackgroundCopyGroup_SetNotificationPointer(This,iid,pUnk)	\
    ( (This)->lpVtbl -> SetNotificationPointer(This,iid,pUnk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_InternalSetProp_Proxy( 
    IBackgroundCopyGroup * This,
    /* [in] */ GROUPPROP propID,
    /* [in] */ __RPC__in VARIANT *pvarVal);


void __RPC_STUB IBackgroundCopyGroup_InternalSetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBackgroundCopyGroup_INTERFACE_DEFINED__ */


#ifndef __IEnumBackgroundCopyGroups_INTERFACE_DEFINED__
#define __IEnumBackgroundCopyGroups_INTERFACE_DEFINED__

/* interface IEnumBackgroundCopyGroups */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumBackgroundCopyGroups;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d993e603-4aa4-47c5-8665-c20d39c2ba4f")
    IEnumBackgroundCopyGroups : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) GUID *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumBackgroundCopyGroups **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *puCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumBackgroundCopyGroupsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumBackgroundCopyGroups * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumBackgroundCopyGroups * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumBackgroundCopyGroups * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumBackgroundCopyGroups * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) GUID *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumBackgroundCopyGroups * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumBackgroundCopyGroups * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumBackgroundCopyGroups * This,
            /* [out] */ __RPC__deref_out_opt IEnumBackgroundCopyGroups **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumBackgroundCopyGroups * This,
            /* [out] */ __RPC__out ULONG *puCount);
        
        END_INTERFACE
    } IEnumBackgroundCopyGroupsVtbl;

    interface IEnumBackgroundCopyGroups
    {
        CONST_VTBL struct IEnumBackgroundCopyGroupsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumBackgroundCopyGroups_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumBackgroundCopyGroups_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumBackgroundCopyGroups_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumBackgroundCopyGroups_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumBackgroundCopyGroups_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumBackgroundCopyGroups_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumBackgroundCopyGroups_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#define IEnumBackgroundCopyGroups_GetCount(This,puCount)	\
    ( (This)->lpVtbl -> GetCount(This,puCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumBackgroundCopyGroups_INTERFACE_DEFINED__ */


#ifndef __IBackgroundCopyCallback1_INTERFACE_DEFINED__
#define __IBackgroundCopyCallback1_INTERFACE_DEFINED__

/* interface IBackgroundCopyCallback1 */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IBackgroundCopyCallback1;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("084f6593-3800-4e08-9b59-99fa59addf82")
    IBackgroundCopyCallback1 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStatus( 
            /* [in] */ __RPC__in_opt IBackgroundCopyGroup *pGroup,
            /* [in] */ __RPC__in_opt IBackgroundCopyJob1 *pJob,
            /* [in] */ DWORD dwFileIndex,
            /* [in] */ DWORD dwStatus,
            /* [in] */ DWORD dwNumOfRetries,
            /* [in] */ DWORD dwWin32Result,
            /* [in] */ DWORD dwTransportResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ DWORD ProgressType,
            /* [in] */ __RPC__in_opt IBackgroundCopyGroup *pGroup,
            /* [in] */ __RPC__in_opt IBackgroundCopyJob1 *pJob,
            /* [in] */ DWORD dwFileIndex,
            /* [in] */ DWORD dwProgressValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnProgressEx( 
            /* [in] */ DWORD ProgressType,
            /* [in] */ __RPC__in_opt IBackgroundCopyGroup *pGroup,
            /* [in] */ __RPC__in_opt IBackgroundCopyJob1 *pJob,
            /* [in] */ DWORD dwFileIndex,
            /* [in] */ DWORD dwProgressValue,
            /* [in] */ DWORD dwByteArraySize,
            /* [size_is][in] */ __RPC__in_ecount_full(dwByteArraySize) BYTE *pByte) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBackgroundCopyCallback1Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBackgroundCopyCallback1 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBackgroundCopyCallback1 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBackgroundCopyCallback1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStatus )( 
            IBackgroundCopyCallback1 * This,
            /* [in] */ __RPC__in_opt IBackgroundCopyGroup *pGroup,
            /* [in] */ __RPC__in_opt IBackgroundCopyJob1 *pJob,
            /* [in] */ DWORD dwFileIndex,
            /* [in] */ DWORD dwStatus,
            /* [in] */ DWORD dwNumOfRetries,
            /* [in] */ DWORD dwWin32Result,
            /* [in] */ DWORD dwTransportResult);
        
        HRESULT ( STDMETHODCALLTYPE *OnProgress )( 
            IBackgroundCopyCallback1 * This,
            /* [in] */ DWORD ProgressType,
            /* [in] */ __RPC__in_opt IBackgroundCopyGroup *pGroup,
            /* [in] */ __RPC__in_opt IBackgroundCopyJob1 *pJob,
            /* [in] */ DWORD dwFileIndex,
            /* [in] */ DWORD dwProgressValue);
        
        HRESULT ( STDMETHODCALLTYPE *OnProgressEx )( 
            IBackgroundCopyCallback1 * This,
            /* [in] */ DWORD ProgressType,
            /* [in] */ __RPC__in_opt IBackgroundCopyGroup *pGroup,
            /* [in] */ __RPC__in_opt IBackgroundCopyJob1 *pJob,
            /* [in] */ DWORD dwFileIndex,
            /* [in] */ DWORD dwProgressValue,
            /* [in] */ DWORD dwByteArraySize,
            /* [size_is][in] */ __RPC__in_ecount_full(dwByteArraySize) BYTE *pByte);
        
        END_INTERFACE
    } IBackgroundCopyCallback1Vtbl;

    interface IBackgroundCopyCallback1
    {
        CONST_VTBL struct IBackgroundCopyCallback1Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBackgroundCopyCallback1_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBackgroundCopyCallback1_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBackgroundCopyCallback1_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBackgroundCopyCallback1_OnStatus(This,pGroup,pJob,dwFileIndex,dwStatus,dwNumOfRetries,dwWin32Result,dwTransportResult)	\
    ( (This)->lpVtbl -> OnStatus(This,pGroup,pJob,dwFileIndex,dwStatus,dwNumOfRetries,dwWin32Result,dwTransportResult) ) 

#define IBackgroundCopyCallback1_OnProgress(This,ProgressType,pGroup,pJob,dwFileIndex,dwProgressValue)	\
    ( (This)->lpVtbl -> OnProgress(This,ProgressType,pGroup,pJob,dwFileIndex,dwProgressValue) ) 

#define IBackgroundCopyCallback1_OnProgressEx(This,ProgressType,pGroup,pJob,dwFileIndex,dwProgressValue,dwByteArraySize,pByte)	\
    ( (This)->lpVtbl -> OnProgressEx(This,ProgressType,pGroup,pJob,dwFileIndex,dwProgressValue,dwByteArraySize,pByte) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBackgroundCopyCallback1_INTERFACE_DEFINED__ */


#ifndef __IBackgroundCopyQMgr_INTERFACE_DEFINED__
#define __IBackgroundCopyQMgr_INTERFACE_DEFINED__

/* interface IBackgroundCopyQMgr */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IBackgroundCopyQMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("16f41c69-09f5-41d2-8cd8-3c08c47bc8a8")
    IBackgroundCopyQMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateGroup( 
            /* [in] */ GUID guidGroupID,
            /* [out] */ __RPC__deref_out_opt IBackgroundCopyGroup **ppGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroup( 
            /* [in] */ GUID groupID,
            /* [out] */ __RPC__deref_out_opt IBackgroundCopyGroup **ppGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumGroups( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IEnumBackgroundCopyGroups **ppEnumGroups) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBackgroundCopyQMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBackgroundCopyQMgr * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBackgroundCopyQMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBackgroundCopyQMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateGroup )( 
            IBackgroundCopyQMgr * This,
            /* [in] */ GUID guidGroupID,
            /* [out] */ __RPC__deref_out_opt IBackgroundCopyGroup **ppGroup);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroup )( 
            IBackgroundCopyQMgr * This,
            /* [in] */ GUID groupID,
            /* [out] */ __RPC__deref_out_opt IBackgroundCopyGroup **ppGroup);
        
        HRESULT ( STDMETHODCALLTYPE *EnumGroups )( 
            IBackgroundCopyQMgr * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IEnumBackgroundCopyGroups **ppEnumGroups);
        
        END_INTERFACE
    } IBackgroundCopyQMgrVtbl;

    interface IBackgroundCopyQMgr
    {
        CONST_VTBL struct IBackgroundCopyQMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBackgroundCopyQMgr_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBackgroundCopyQMgr_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBackgroundCopyQMgr_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBackgroundCopyQMgr_CreateGroup(This,guidGroupID,ppGroup)	\
    ( (This)->lpVtbl -> CreateGroup(This,guidGroupID,ppGroup) ) 

#define IBackgroundCopyQMgr_GetGroup(This,groupID,ppGroup)	\
    ( (This)->lpVtbl -> GetGroup(This,groupID,ppGroup) ) 

#define IBackgroundCopyQMgr_EnumGroups(This,dwFlags,ppEnumGroups)	\
    ( (This)->lpVtbl -> EnumGroups(This,dwFlags,ppEnumGroups) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBackgroundCopyQMgr_INTERFACE_DEFINED__ */



#ifndef __BackgroundCopyQMgr_LIBRARY_DEFINED__
#define __BackgroundCopyQMgr_LIBRARY_DEFINED__

/* library BackgroundCopyQMgr */
/* [version][lcid][helpstring][uuid] */ 


EXTERN_C const IID LIBID_BackgroundCopyQMgr;

EXTERN_C const CLSID CLSID_BackgroundCopyQMgr;

#ifdef __cplusplus

class DECLSPEC_UUID("69AD4AEE-51BE-439b-A92C-86AE490E8B30")
BackgroundCopyQMgr;
#endif
#endif /* __BackgroundCopyQMgr_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     unsigned long *, VARIANT * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_SetProp_Proxy( 
    IBackgroundCopyGroup * This,
    /* [in] */ GROUPPROP propID,
    /* [in] */ VARIANT *pvarVal);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_SetProp_Stub( 
    IBackgroundCopyGroup * This,
    /* [in] */ GROUPPROP propID,
    /* [in] */ __RPC__in VARIANT *pvarVal);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\pstore.h ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    pstore.h

Abstract:

    This module defines the Protected Storage COM interface and associated
    data structures.

Author:

    Scott Field (sfield)    13-Mar-97

--*/

#ifndef __PSTORE_H__
#define __PSTORE_H__

#if _MSC_VER > 1000
#pragma once
#endif

/*
    Typedefs, values
*/

// provider flags

// provider capabilities
typedef DWORD PST_PROVIDERCAPABILITIES;

#define PST_PC_PFX              0x00000001
#define PST_PC_HARDWARE         0x00000002
#define PST_PC_SMARTCARD        0x00000004
#define PST_PC_PCMCIA           0x00000008
#define PST_PC_MULTIPLE_REPOSITORIES    0x00000010
#define PST_PC_ROAMABLE         0x00000020


// NYI (not yet implemented)
typedef DWORD PST_REPOSITORYCAPABILITIES;

#define PST_RC_REMOVABLE        0x80000000


// provider storage area
typedef DWORD PST_KEY;

#define PST_KEY_CURRENT_USER    0x00000000
#define PST_KEY_LOCAL_MACHINE   0x00000001



/*
    dwDefaultConfirmationStyle flags
*/

//
// allows user to choose confirmation style
//
#define     PST_CF_DEFAULT              0x00000000

//
// forces silent item creation
//
#define     PST_CF_NONE                 0x00000001



/*
    dwPromptFlags
*/

//
// app forces confirmation to be shown
//
#define     PST_PF_ALWAYS_SHOW          0x00000001


//
// RSABase rqmt: determine if item has ui attached
//
#define     PST_PF_NEVER_SHOW           0x00000002

/*
    dwFlags values
*/

//
// Allows caller to specify creation not overwrite
// of item during WriteItem call
//
#define     PST_NO_OVERWRITE            0x00000002

//
// specifies insecure data stream to be written/read
// there is no protection or guarantees for this data
// flag only valid during item read/write calls
// default: item calls are secure
//
#define     PST_UNRESTRICTED_ITEMDATA   0x00000004


//
// on ReadItem call
// return value on success without UI on item is PST_E_OK
// return value on success with UI on item is PST_E_ITEM_EXISTS
// return value on failure is a different error code
//
#define     PST_PROMPT_QUERY            0x00000008

//
// on ReadItem, DeleteItem, for data migration purposes:
// Avoid displaying UI on ReadItem unless a custom password is required (highsecurity).
// Avoid displaying UI on DeleteItem, period.
//
#define     PST_NO_UI_MIGRATION         0x00000010



/*
    Security masks, rule modifiers
*/

//
// models access after NT access mask
//

// read, write
typedef DWORD PST_ACCESSMODE;

#define     PST_READ                0x0001
#define     PST_WRITE               0x0002


// PST_ACCESSCLAUSETYPE

// memhash, diskhash, authenticode, etc
typedef DWORD PST_ACCESSCLAUSETYPE;

//
// pbClauseData points to PST_AUTHENTICODEDATA structure.
//
#define     PST_AUTHENTICODE            1

//
// pbClauseData points to PST_BINARYCHECKDATA structure.
//
#define     PST_BINARY_CHECK            2

//
// pbClauseData points to valid Windows NT security descriptor.
// note that performance is improved on Set operations if the security
// descriptor is in self-relative format, with valid owner and group Sids
// (non-NULL).
//
#define     PST_SECURITY_DESCRIPTOR     4

//
// pbClauseData is in self-relative format
// (for internal use only)
//
#define     PST_SELF_RELATIVE_CLAUSE    0x80000000L

//
// currently access clause modifiers - NOT to be or'd together
//


//
// specified image is the immediate caller, and is an application (.exe)
//

#define     PST_AC_SINGLE_CALLER        0

//
// specified image is not necessary the immediate caller, and is an
// application (.exe)
//

#define     PST_AC_TOP_LEVEL_CALLER     1

//
// specified image is the immediate caller.  May be
// an application (.exe) or a .dll
//

#define     PST_AC_IMMEDIATE_CALLER     2


/*
    Provider Parameters
*/
//
// flush the internal cache of passwords -- temporary?
//
#define     PST_PP_FLUSH_PW_CACHE       0x1




/*
    Provider Defns
*/

//
// Microsoft Base Provider (MS_BASE_PSTPROVIDER...)
//
#define MS_BASE_PSTPROVIDER_NAME            L"System Protected Storage"

// {8A078C30-3755-11d0-A0BD-00AA0061426A}
#define MS_BASE_PSTPROVIDER_ID              { 0x8a078c30, 0x3755, 0x11d0, { 0xa0, 0xbd, 0x0, 0xaa, 0x0, 0x61, 0x42, 0x6a } }
#define MS_BASE_PSTPROVIDER_SZID            L"8A078C30-3755-11d0-A0BD-00AA0061426A"

//
// Microsoft PFX Provider (MS_PFX_PSTPROVIDER...)
//
#define MS_PFX_PSTPROVIDER_NAME             L"PFX Storage Provider"

// {3ca94f30-7ac1-11d0-8c42-00c04fc299eb}
#define MS_PFX_PSTPROVIDER_ID               { 0x3ca94f30, 0x7ac1, 0x11d0, {0x8c, 0x42, 0x00, 0xc0, 0x4f, 0xc2, 0x99, 0xeb} }
#define MS_PFX_PSTPROVIDER_SZID             L"3ca94f30-7ac1-11d0-8c42-00c04fc299eb"



/*
    Globally registered Type/Subtype guid/name pairs
*/

#define PST_CONFIGDATA_TYPE_STRING              L"Configuration Data"
// 8ec99652-8909-11d0-8c4d-00c04fc297eb
#define PST_CONFIGDATA_TYPE_GUID                        \
{   0x8ec99652,                                         \
    0x8909,                                             \
    0x11d0,                                             \
    {0x8c, 0x4d, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb}    \
}

#define PST_PROTECTEDSTORAGE_SUBTYPE_STRING     L"Protected Storage"
// d3121b8e-8a7d-11d0-8c4f-00c04fc297eb
#define PST_PROTECTEDSTORAGE_SUBTYPE_GUID               \
{   0xd3121b8e,                                         \
    0x8a7d,                                             \
    0x11d0,                                             \
    {0x8c, 0x4f, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb}    \
}


#define PST_PSTORE_PROVIDERS_SUBTYPE_STRING     L"Protected Storage Provider List"
// 8ed17a64-91d0-11d0-8c43-00c04fc2c621
#define PST_PSTORE_PROVIDERS_SUBTYPE_GUID               \
{                                                       \
    0x8ed17a64,                                         \
    0x91d0,                                             \
    0x11d0,                                             \
    {0x8c, 0x43, 0x00, 0xc0, 0x4f, 0xc2, 0xc6, 0x21}    \
}


//
// error codes
//


#ifndef PST_E_OK
#define PST_E_OK                        _HRESULT_TYPEDEF_(0x00000000L)


#define PST_E_FAIL                      _HRESULT_TYPEDEF_(0x800C0001L)
#define PST_E_PROV_DLL_NOT_FOUND        _HRESULT_TYPEDEF_(0x800C0002L)
#define PST_E_INVALID_HANDLE            _HRESULT_TYPEDEF_(0x800C0003L)
#define PST_E_TYPE_EXISTS               _HRESULT_TYPEDEF_(0x800C0004L)
#define PST_E_TYPE_NO_EXISTS            _HRESULT_TYPEDEF_(0x800C0005L)
#define PST_E_INVALID_RULESET           _HRESULT_TYPEDEF_(0x800C0006L)
#define PST_E_NO_PERMISSIONS            _HRESULT_TYPEDEF_(0x800C0007L)
#define PST_E_STORAGE_ERROR             _HRESULT_TYPEDEF_(0x800C0008L)
#define PST_E_CALLER_NOT_VERIFIED       _HRESULT_TYPEDEF_(0x800C0009L)
#define PST_E_WRONG_PASSWORD            _HRESULT_TYPEDEF_(0x800C000AL)
#define PST_E_DISK_IMAGE_MISMATCH       _HRESULT_TYPEDEF_(0x800C000BL)
// 000C pending
#define PST_E_UNKNOWN_EXCEPTION         _HRESULT_TYPEDEF_(0x800C000DL)
#define PST_E_BAD_FLAGS                 _HRESULT_TYPEDEF_(0x800C000EL)
#define PST_E_ITEM_EXISTS               _HRESULT_TYPEDEF_(0x800C000FL)
#define PST_E_ITEM_NO_EXISTS            _HRESULT_TYPEDEF_(0x800C0010L)
#define PST_E_SERVICE_UNAVAILABLE       _HRESULT_TYPEDEF_(0x800C0011L)
#define PST_E_NOTEMPTY                  _HRESULT_TYPEDEF_(0x800C0012L)
#define PST_E_INVALID_STRING            _HRESULT_TYPEDEF_(0x800C0013L)
#define PST_E_STATE_INVALID             _HRESULT_TYPEDEF_(0x800C0014L)
#define PST_E_NOT_OPEN                  _HRESULT_TYPEDEF_(0x800C0015L)
#define PST_E_ALREADY_OPEN              _HRESULT_TYPEDEF_(0x800C0016L)
#define PST_E_NYI                       _HRESULT_TYPEDEF_(0x800C0F00L)


#define MIN_PST_ERROR                   0x800C0001
#define MAX_PST_ERROR                   0x800C0F00

#endif  // !PST_OK



/* this ALWAYS GENERATED file contains the definitions for the interfaces */

//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifdef __cplusplus
extern "C"{
#endif

/* Forward Declarations */

/* header files for imported files */
#include "wtypes.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Wed Apr 23 23:56:10 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */


typedef DWORD PST_PROVIDERCAPABILITIES;

typedef DWORD PST_REPOSITORYCAPABILITIES;

typedef DWORD PST_KEY;

typedef DWORD PST_ACCESSMODE;

typedef DWORD PST_ACCESSCLAUSETYPE;

typedef GUID UUID;

typedef ULARGE_INTEGER PST_PROVIDER_HANDLE;

typedef GUID PST_PROVIDERID;

typedef PST_PROVIDERID __RPC_FAR *PPST_PROVIDERID;

typedef struct  _PST_PROVIDERINFO
    {
    DWORD cbSize;
    PST_PROVIDERID ID;
    PST_PROVIDERCAPABILITIES Capabilities;
    LPWSTR szProviderName;
    }   PST_PROVIDERINFO;

typedef struct _PST_PROVIDERINFO __RPC_FAR *PPST_PROVIDERINFO;

typedef struct  _PST_TYPEINFO
    {
    DWORD cbSize;
    LPWSTR szDisplayName;
    }   PST_TYPEINFO;

typedef struct _PST_TYPEINFO __RPC_FAR *PPST_TYPEINFO;

typedef struct  _PST_PROMPTINFO
    {
    DWORD cbSize;
    DWORD dwPromptFlags;
    HWND  hwndApp;
    LPCWSTR szPrompt;
    }   PST_PROMPTINFO;

typedef struct _PST_PROMPTINFO __RPC_FAR *PPST_PROMPTINFO;

typedef struct  _PST_ACCESSCLAUSE
    {
    DWORD cbSize;
    PST_ACCESSCLAUSETYPE ClauseType;
    DWORD cbClauseData;
    /* [size_is] */ VOID __RPC_FAR *pbClauseData;
    }   PST_ACCESSCLAUSE;

typedef struct _PST_ACCESSCLAUSE __RPC_FAR *PPST_ACCESSCLAUSE;

typedef struct  _PST_ACCESSRULE
    {
    DWORD cbSize;
    PST_ACCESSMODE AccessModeFlags;
    DWORD cClauses;
    /* [size_is] */ PST_ACCESSCLAUSE __RPC_FAR *rgClauses;
    }   PST_ACCESSRULE;

typedef struct _PST_ACCESSRULE __RPC_FAR *PPST_ACCESSRULE;

typedef struct  _PST_ACCESSRULESET
    {
    DWORD cbSize;
    DWORD cRules;
    /* [size_is] */ PST_ACCESSRULE __RPC_FAR *rgRules;
    }   PST_ACCESSRULESET;

typedef struct _PST_ACCESSRULESET __RPC_FAR *PPST_ACCESSRULESET;

typedef struct  _PST_AUTHENTICODEDATA
    {
    DWORD cbSize;
    DWORD dwModifiers;
    LPCWSTR szRootCA;
    LPCWSTR szIssuer;
    LPCWSTR szPublisher;
    LPCWSTR szProgramName;
    }   PST_AUTHENTICODEDATA;

typedef struct _PST_AUTHENTICODEDATA __RPC_FAR *PPST_AUTHENTICODEDATA;

typedef struct _PST_AUTHENTICODEDATA __RPC_FAR *LPPST_AUTHENTICODEDATA;

typedef struct  _PST_BINARYCHECKDATA
    {
    DWORD cbSize;
    DWORD dwModifiers;
    LPCWSTR szFilePath;
    }   PST_BINARYCHECKDATA;

typedef struct _PST_BINARYCHECKDATA __RPC_FAR *PPST_BINARYCHECKDATA;

typedef struct _PST_BINARYCHECKDATA __RPC_FAR *LPPST_BINARYCHECKDATA;



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif



/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Wed Apr 23 23:56:14 1997
 */
/* Compiler settings for pstorec.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifdef __cplusplus
extern "C"{
#endif

/* Forward Declarations */

#ifndef __IEnumPStoreItems_FWD_DEFINED__
#define __IEnumPStoreItems_FWD_DEFINED__
typedef interface IEnumPStoreItems IEnumPStoreItems;
#endif  /* __IEnumPStoreItems_FWD_DEFINED__ */


#ifndef __IEnumPStoreTypes_FWD_DEFINED__
#define __IEnumPStoreTypes_FWD_DEFINED__
typedef interface IEnumPStoreTypes IEnumPStoreTypes;
#endif  /* __IEnumPStoreTypes_FWD_DEFINED__ */


#ifndef __IPStore_FWD_DEFINED__
#define __IPStore_FWD_DEFINED__
typedef interface IPStore IPStore;
#endif  /* __IPStore_FWD_DEFINED__ */


#ifndef __IEnumPStoreProviders_FWD_DEFINED__
#define __IEnumPStoreProviders_FWD_DEFINED__
typedef interface IEnumPStoreProviders IEnumPStoreProviders;
#endif  /* __IEnumPStoreProviders_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

#ifndef __IEnumPStoreItems_INTERFACE_DEFINED__
#define __IEnumPStoreItems_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumPStoreItems
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IEnumPStoreItems;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IEnumPStoreItems : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ DWORD celt,
            /* [out] */ LPWSTR __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ DWORD celt) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum) = 0;

    };

#else   /* C style interface */

    typedef struct IEnumPStoreItemsVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IEnumPStoreItems __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IEnumPStoreItems __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IEnumPStoreItems __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IEnumPStoreItems __RPC_FAR * This,
            /* [in] */ DWORD celt,
            /* [out] */ LPWSTR __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IEnumPStoreItems __RPC_FAR * This,
            /* [in] */ DWORD celt);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IEnumPStoreItems __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IEnumPStoreItems __RPC_FAR * This,
            /* [out] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);

        END_INTERFACE
    } IEnumPStoreItemsVtbl;

    interface IEnumPStoreItems
    {
        CONST_VTBL struct IEnumPStoreItemsVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IEnumPStoreItems_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPStoreItems_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IEnumPStoreItems_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IEnumPStoreItems_Next(This,celt,rgelt,pceltFetched) \
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumPStoreItems_Skip(This,celt)    \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumPStoreItems_Reset(This)    \
    (This)->lpVtbl -> Reset(This)

#define IEnumPStoreItems_Clone(This,ppenum) \
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Next_Proxy(
    IEnumPStoreItems __RPC_FAR * This,
    /* [in] */ DWORD celt,
    /* [out] */ LPWSTR __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumPStoreItems_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Skip_Proxy(
    IEnumPStoreItems __RPC_FAR * This,
    /* [in] */ DWORD celt);


void __RPC_STUB IEnumPStoreItems_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Reset_Proxy(
    IEnumPStoreItems __RPC_FAR * This);


void __RPC_STUB IEnumPStoreItems_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Clone_Proxy(
    IEnumPStoreItems __RPC_FAR * This,
    /* [out] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumPStoreItems_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumPStoreItems_INTERFACE_DEFINED__ */


#ifndef __IEnumPStoreTypes_INTERFACE_DEFINED__
#define __IEnumPStoreTypes_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumPStoreTypes
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IEnumPStoreTypes;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IEnumPStoreTypes : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ DWORD celt,
            /* [out][size_is] */ GUID __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ DWORD celt) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum) = 0;

    };

#else   /* C style interface */

    typedef struct IEnumPStoreTypesVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IEnumPStoreTypes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IEnumPStoreTypes __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IEnumPStoreTypes __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IEnumPStoreTypes __RPC_FAR * This,
            /* [in] */ DWORD celt,
            /* [out][size_is] */ GUID __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IEnumPStoreTypes __RPC_FAR * This,
            /* [in] */ DWORD celt);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IEnumPStoreTypes __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IEnumPStoreTypes __RPC_FAR * This,
            /* [out] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);

        END_INTERFACE
    } IEnumPStoreTypesVtbl;

    interface IEnumPStoreTypes
    {
        CONST_VTBL struct IEnumPStoreTypesVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IEnumPStoreTypes_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPStoreTypes_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IEnumPStoreTypes_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IEnumPStoreTypes_Next(This,celt,rgelt,pceltFetched) \
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumPStoreTypes_Skip(This,celt)    \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumPStoreTypes_Reset(This)    \
    (This)->lpVtbl -> Reset(This)

#define IEnumPStoreTypes_Clone(This,ppenum) \
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Next_Proxy(
    IEnumPStoreTypes __RPC_FAR * This,
    /* [in] */ DWORD celt,
    /* [out][size_is] */ GUID __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumPStoreTypes_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Skip_Proxy(
    IEnumPStoreTypes __RPC_FAR * This,
    /* [in] */ DWORD celt);


void __RPC_STUB IEnumPStoreTypes_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Reset_Proxy(
    IEnumPStoreTypes __RPC_FAR * This);


void __RPC_STUB IEnumPStoreTypes_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Clone_Proxy(
    IEnumPStoreTypes __RPC_FAR * This,
    /* [out] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumPStoreTypes_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumPStoreTypes_INTERFACE_DEFINED__ */


#ifndef __IPStore_INTERFACE_DEFINED__
#define __IPStore_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPStore
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IPStore;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IPStore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInfo(
            /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppProperties) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetProvParam(
            /* [in] */ DWORD dwParam,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetProvParam(
            /* [in] */ DWORD dwParam,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE CreateType(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteType(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE CreateSubtype(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetSubtypeInfo(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteSubtype(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ReadAccessRuleset(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_ACCESSRULESET __RPC_FAR *ppRules,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE WriteAccessRuleset(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumTypes(
            /* [in] */ PST_KEY Key,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumSubtypes(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ReadItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE WriteItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwDefaultConfirmationStyle,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE OpenItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PST_ACCESSMODE ModeFlags,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE CloseItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumItems(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum) = 0;

    };

#else   /* C style interface */

    typedef struct IPStoreVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IPStore __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IPStore __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IPStore __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfo )(
            IPStore __RPC_FAR * This,
            /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppProperties);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProvParam )(
            IPStore __RPC_FAR * This,
            /* [in] */ DWORD dwParam,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProvParam )(
            IPStore __RPC_FAR * This,
            /* [in] */ DWORD dwParam,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateType )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteType )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateSubtype )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSubtypeInfo )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteSubtype )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadAccessRuleset )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_ACCESSRULESET __RPC_FAR *ppRules,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteAccessRuleset )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumTypes )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumSubtypes )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwDefaultConfirmationStyle,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PST_ACCESSMODE ModeFlags,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumItems )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);

        END_INTERFACE
    } IPStoreVtbl;

    interface IPStore
    {
        CONST_VTBL struct IPStoreVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IPStore_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPStore_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IPStore_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IPStore_GetInfo(This,ppProperties)  \
    (This)->lpVtbl -> GetInfo(This,ppProperties)

#define IPStore_GetProvParam(This,dwParam,pcbData,ppbData,dwFlags)  \
    (This)->lpVtbl -> GetProvParam(This,dwParam,pcbData,ppbData,dwFlags)

#define IPStore_SetProvParam(This,dwParam,cbData,pbData,dwFlags)    \
    (This)->lpVtbl -> SetProvParam(This,dwParam,cbData,pbData,dwFlags)

#define IPStore_CreateType(This,Key,pType,pInfo,dwFlags)    \
    (This)->lpVtbl -> CreateType(This,Key,pType,pInfo,dwFlags)

#define IPStore_GetTypeInfo(This,Key,pType,ppInfo,dwFlags)  \
    (This)->lpVtbl -> GetTypeInfo(This,Key,pType,ppInfo,dwFlags)

#define IPStore_DeleteType(This,Key,pType,dwFlags)  \
    (This)->lpVtbl -> DeleteType(This,Key,pType,dwFlags)

#define IPStore_CreateSubtype(This,Key,pType,pSubtype,pInfo,pRules,dwFlags) \
    (This)->lpVtbl -> CreateSubtype(This,Key,pType,pSubtype,pInfo,pRules,dwFlags)

#define IPStore_GetSubtypeInfo(This,Key,pType,pSubtype,ppInfo,dwFlags)  \
    (This)->lpVtbl -> GetSubtypeInfo(This,Key,pType,pSubtype,ppInfo,dwFlags)

#define IPStore_DeleteSubtype(This,Key,pType,pSubtype,dwFlags)  \
    (This)->lpVtbl -> DeleteSubtype(This,Key,pType,pSubtype,dwFlags)

#define IPStore_ReadAccessRuleset(This,Key,pType,pSubtype,ppRules,dwFlags)  \
    (This)->lpVtbl -> ReadAccessRuleset(This,Key,pType,pSubtype,ppRules,dwFlags)

#define IPStore_WriteAccessRuleset(This,Key,pType,pSubtype,pRules,dwFlags)  \
    (This)->lpVtbl -> WriteAccessRuleset(This,Key,pType,pSubtype,pRules,dwFlags)

#define IPStore_EnumTypes(This,Key,dwFlags,ppenum)  \
    (This)->lpVtbl -> EnumTypes(This,Key,dwFlags,ppenum)

#define IPStore_EnumSubtypes(This,Key,pType,dwFlags,ppenum) \
    (This)->lpVtbl -> EnumSubtypes(This,Key,pType,dwFlags,ppenum)

#define IPStore_DeleteItem(This,Key,pItemType,pItemSubtype,szItemName,pPromptInfo,dwFlags)  \
    (This)->lpVtbl -> DeleteItem(This,Key,pItemType,pItemSubtype,szItemName,pPromptInfo,dwFlags)

#define IPStore_ReadItem(This,Key,pItemType,pItemSubtype,szItemName,pcbData,ppbData,pPromptInfo,dwFlags)    \
    (This)->lpVtbl -> ReadItem(This,Key,pItemType,pItemSubtype,szItemName,pcbData,ppbData,pPromptInfo,dwFlags)

#define IPStore_WriteItem(This,Key,pItemType,pItemSubtype,szItemName,cbData,pbData,pPromptInfo,dwDefaultConfirmationStyle,dwFlags)  \
    (This)->lpVtbl -> WriteItem(This,Key,pItemType,pItemSubtype,szItemName,cbData,pbData,pPromptInfo,dwDefaultConfirmationStyle,dwFlags)

#define IPStore_OpenItem(This,Key,pItemType,pItemSubtype,szItemName,ModeFlags,pPromptInfo,dwFlags)  \
    (This)->lpVtbl -> OpenItem(This,Key,pItemType,pItemSubtype,szItemName,ModeFlags,pPromptInfo,dwFlags)

#define IPStore_CloseItem(This,Key,pItemType,pItemSubtype,szItemName,dwFlags)   \
    (This)->lpVtbl -> CloseItem(This,Key,pItemType,pItemSubtype,szItemName,dwFlags)

#define IPStore_EnumItems(This,Key,pItemType,pItemSubtype,dwFlags,ppenum)   \
    (This)->lpVtbl -> EnumItems(This,Key,pItemType,pItemSubtype,dwFlags,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IPStore_GetInfo_Proxy(
    IPStore __RPC_FAR * This,
    /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppProperties);


void __RPC_STUB IPStore_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_GetProvParam_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ DWORD dwParam,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_GetProvParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_SetProvParam_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ DWORD dwParam,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE __RPC_FAR *pbData,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_SetProvParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_CreateType_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ PPST_TYPEINFO pInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_CreateType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_GetTypeInfo_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_GetTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_DeleteType_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_DeleteType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_CreateSubtype_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ PPST_TYPEINFO pInfo,
    /* [in] */ PPST_ACCESSRULESET pRules,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_CreateSubtype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_GetSubtypeInfo_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_GetSubtypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_DeleteSubtype_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_DeleteSubtype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_ReadAccessRuleset_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [out] */ PPST_ACCESSRULESET __RPC_FAR *ppRules,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_ReadAccessRuleset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_WriteAccessRuleset_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ PPST_ACCESSRULESET pRules,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_WriteAccessRuleset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_EnumTypes_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IPStore_EnumTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_EnumSubtypes_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IPStore_EnumSubtypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_DeleteItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_DeleteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_ReadItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_ReadItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_WriteItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE __RPC_FAR *pbData,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwDefaultConfirmationStyle,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_WriteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_OpenItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PST_ACCESSMODE ModeFlags,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_OpenItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_CloseItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_CloseItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_EnumItems_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IPStore_EnumItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IPStore_INTERFACE_DEFINED__ */


#ifndef __IEnumPStoreProviders_INTERFACE_DEFINED__
#define __IEnumPStoreProviders_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumPStoreProviders
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IEnumPStoreProviders;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IEnumPStoreProviders : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ DWORD celt,
            /* [out][size_is] */ PST_PROVIDERINFO __RPC_FAR *__RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ DWORD celt) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum) = 0;

    };

#else   /* C style interface */

    typedef struct IEnumPStoreProvidersVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IEnumPStoreProviders __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IEnumPStoreProviders __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IEnumPStoreProviders __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IEnumPStoreProviders __RPC_FAR * This,
            /* [in] */ DWORD celt,
            /* [out][size_is] */ PST_PROVIDERINFO __RPC_FAR *__RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IEnumPStoreProviders __RPC_FAR * This,
            /* [in] */ DWORD celt);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IEnumPStoreProviders __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IEnumPStoreProviders __RPC_FAR * This,
            /* [out] */ IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum);

        END_INTERFACE
    } IEnumPStoreProvidersVtbl;

    interface IEnumPStoreProviders
    {
        CONST_VTBL struct IEnumPStoreProvidersVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IEnumPStoreProviders_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPStoreProviders_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IEnumPStoreProviders_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IEnumPStoreProviders_Next(This,celt,rgelt,pceltFetched) \
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumPStoreProviders_Skip(This,celt)    \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumPStoreProviders_Reset(This)    \
    (This)->lpVtbl -> Reset(This)

#define IEnumPStoreProviders_Clone(This,ppenum) \
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Next_Proxy(
    IEnumPStoreProviders __RPC_FAR * This,
    /* [in] */ DWORD celt,
    /* [out][size_is] */ PST_PROVIDERINFO __RPC_FAR *__RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumPStoreProviders_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Skip_Proxy(
    IEnumPStoreProviders __RPC_FAR * This,
    /* [in] */ DWORD celt);


void __RPC_STUB IEnumPStoreProviders_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Reset_Proxy(
    IEnumPStoreProviders __RPC_FAR * This);


void __RPC_STUB IEnumPStoreProviders_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Clone_Proxy(
    IEnumPStoreProviders __RPC_FAR * This,
    /* [out] */ IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumPStoreProviders_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumPStoreProviders_INTERFACE_DEFINED__ */



#ifndef __PSTORECLib_LIBRARY_DEFINED__
#define __PSTORECLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: PSTORECLib
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [helpstring][version][uuid] */



EXTERN_C const IID LIBID_PSTORECLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CPStore;

class CPStore;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CEnumTypes;

class CEnumTypes;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CEnumItems;

class CEnumItems;
#endif
#endif /* __PSTORECLib_LIBRARY_DEFINED__ */

/****************************************
 * Generated header for interface: __MIDL__intf_0080
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */


HRESULT __stdcall PStoreCreateInstance(
    IPStore __RPC_FAR *__RPC_FAR *ppProvider,
    PST_PROVIDERID __RPC_FAR *pProviderID,
    void __RPC_FAR *pReserved,
    DWORD dwFlags);

HRESULT __stdcall PStoreEnumProviders(
    DWORD dwFlags,
    IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum);



extern RPC_IF_HANDLE __MIDL__intf_0080_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0080_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif // PSTORE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\Qossp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    qos.h - QoS definitions for NDIS components.

Abstract:

    This module defines the type of objects that can go into the 
    ProviderSpecific buffer in the QOS structure.

Revision History:

--*/

#ifndef __QOSSP_H_
#define __QOSSP_H_

#pragma once

/*
 * Definition of object Types
 *
 *
 * define the values for ObjectType above - RSVP Objects ids start at an 
 * offset from zero to allow for ATM objects that might be defined in the 
 * lower number range.
 */
#define   RSVP_OBJECT_ID_BASE         1000
#define   RSVP_OBJECT_STATUS_INFO     (0x00000000 + RSVP_OBJECT_ID_BASE)
          /* RSVP_STATUS_INFO structure passed */
#define   RSVP_OBJECT_RESERVE_INFO    (0x00000001 + RSVP_OBJECT_ID_BASE)
          /* RSVP_RESERVE_INFO structure passed */
#define   RSVP_OBJECT_ADSPEC          (0x00000002 + RSVP_OBJECT_ID_BASE)
          /* RSVP_ADSPEC structure passed */
#define   RSVP_OBJECT_POLICY_INFO     (0x00000003 + RSVP_OBJECT_ID_BASE)
          /* RSVP POLICY ELEMENT(S) retrieved */
#define   RSVP_OBJECT_FILTERSPEC_LIST (0x00000004 + RSVP_OBJECT_ID_BASE)
          /* RSVP SENDER LIST returned */


/* 
 * IPV4 addressing for RSVP FILTERSPECS
 */
typedef union _IN_ADDR_IPV4 {

    ULONG  Addr;
    UCHAR  AddrBytes[4];

} IN_ADDR_IPV4, *LPIN_ADDR_IPV4;

/*
 * IPV6 addressing for RSVP FILTERSPECS
 */
typedef struct _IN_ADDR_IPV6 {

    UCHAR  Addr[16];               //IPV6 address

} IN_ADDR_IPV6, *LPIN_ADDR_IPV6;

typedef const IN_ADDR_IPV6  *LPCIN_ADDR_IPV6;

/*
 * IPV4 addressing for RSVP FILTERSPECS
 */
typedef struct _RSVP_FILTERSPEC_V4 {

    IN_ADDR_IPV4    Address;
    USHORT          Unused;
    USHORT          Port;

} RSVP_FILTERSPEC_V4, *LPRSVP_FILTERSPEC_V4;

typedef struct _RSVP_FILTERSPEC_V6 {

    IN_ADDR_IPV6    Address;
    USHORT          UnUsed;
    USHORT          Port;

} RSVP_FILTERSPEC_V6, *LPRSVP_FILTERSPEC_V6;


typedef struct _RSVP_FILTERSPEC_V6_FLOW {

    IN_ADDR_IPV6    Address;
    UCHAR           UnUsed;
    UCHAR           FlowLabel[3];

} RSVP_FILTERSPEC_V6_FLOW, *LPRSVP_FILTERSPEC_V6_FLOW;

typedef struct _RSVP_FILTERSPEC_V4_GPI {

    IN_ADDR_IPV4    Address;
    ULONG           GeneralPortId;

} RSVP_FILTERSPEC_V4_GPI, *LPRSVP_FILTERSPEC_V4_GPI;

typedef struct _RSVP_FILTERSPEC_V6_GPI {

    IN_ADDR_IPV6    Address;
    ULONG           GeneralPortId;

} RSVP_FILTERSPEC_V6_GPI, *LPRSVP_FILTERSPEC_V6_GPI;


/*
 * FILTERSPEC TYPES used in making reservations.
 */
typedef enum {

        FILTERSPECV4 = 1,
        FILTERSPECV6,
        FILTERSPECV6_FLOW,
        FILTERSPECV4_GPI,
        FILTERSPECV6_GPI,
        FILTERSPEC_END

} FilterType;

typedef struct _RSVP_FILTERSPEC {

    FilterType   Type;

    union {
        RSVP_FILTERSPEC_V4      FilterSpecV4;
        RSVP_FILTERSPEC_V6      FilterSpecV6;
        RSVP_FILTERSPEC_V6_FLOW FilterSpecV6Flow;
        RSVP_FILTERSPEC_V4_GPI  FilterSpecV4Gpi;
        RSVP_FILTERSPEC_V6_GPI  FilterSpecV6Gpi;
    };

} RSVP_FILTERSPEC, *LPRSVP_FILTERSPEC;

/*
 * FLOWDESCRIPTOR Structure used for specifying one or more
 * Filters per Flowspec.
 */
typedef struct _FLOWDESCRIPTOR {

    FLOWSPEC            FlowSpec;
    ULONG               NumFilters;
    LPRSVP_FILTERSPEC   FilterList;

} FLOWDESCRIPTOR, *LPFLOWDESCRIPTOR;

/*
 * RSVP_POLICY contains undefined policy data.  RSVP transports this
 * data on behalf of the Policy Control component.
 */
typedef struct _RSVP_POLICY {
    USHORT  Len;         /* total length of this element object */
    USHORT  Type;
    UCHAR   Info[4];
} RSVP_POLICY, *LPRSVP_POLICY;

typedef const RSVP_POLICY *LPCRSVP_POLICY;
#define RSVP_POLICY_HDR_LEN    ( sizeof(USHORT) + sizeof(USHORT) )

/*
 * RSVP_POLICY_INFO contains undefined policy element(s) retrieved from RSVP.  
 */
typedef struct _RSVP_POLICY_INFO  {

    QOS_OBJECT_HDR     ObjectHdr;
    ULONG              NumPolicyElement;         /* count of the 
                                                  * number of policy elements */
    RSVP_POLICY        PolicyElement[1];         /* a list of the policy 
                                                  * elements retrieved */

} RSVP_POLICY_INFO, *LPRSVP_POLICY_INFO;

/*
 * RSVP_RESERVE_INFO Structure used for storing RSVP specific
 * information for fine tuning interaction via the Winsock2
 * Generic QoS API via the provider specific buffer. This structure
 * includes the QOS_OBJECT_HDR structure directly
 */

typedef struct _RSVP_RESERVE_INFO {

    QOS_OBJECT_HDR      ObjectHdr;            /* type and length of this object */
    ULONG               Style;                /* RSVP Style (FF,WF,SE) */
    ULONG               ConfirmRequest;       /* Non Zero for Confirm Request (receive only) */
    LPRSVP_POLICY_INFO  PolicyElementList;    /* Points to the set of policy elements */
    ULONG               NumFlowDesc;          /* Number of FlowDesc */
    LPFLOWDESCRIPTOR    FlowDescList;         /* Points to the FlowDesc list */

} RSVP_RESERVE_INFO, *LPRSVP_RESERVE_INFO;

typedef const RSVP_RESERVE_INFO *LPCRSVP_RESERVE_INFO;

/*
 * definitions for the ulStyle in the previous structure
 */
#define RSVP_DEFAULT_STYLE            0x00000000
#define RSVP_WILDCARD_STYLE           0x00000001
#define RSVP_FIXED_FILTER_STYLE       0x00000002
#define RSVP_SHARED_EXPLICIT_STYLE    0x00000003

/*
 * RSVP_STATUS_INFO Structure used for storing RSVP specific
 * error of status indications.  This also serves as a header
 * for additional objects in the provider specific buffer when
 * interacting via Winsock2 Generic QoS API. This structure includes
 * the QOS_OBJECT_COUNT and QOS_OBJECT_HDR structures directly It is
 * expected to be the first structure in the provider specific structure
 * since it includes the QOS_OBJECT_COUNT
 */

typedef struct _RSVP_STATUS_INFO {

    QOS_OBJECT_HDR      ObjectHdr;      /* Object Hdr */
    ULONG               StatusCode;     /* Error or Status Information see 
                                         * Winsock2.h */
    ULONG               ExtendedStatus1;/* Provider specific status extension */
    ULONG               ExtendedStatus2;/* Provider specific status extension */

} RSVP_STATUS_INFO, *LPRSVP_STATUS_INFO;

typedef const RSVP_STATUS_INFO *LPCRSVP_STATUS_INFO;


/*
 * QOS_DestAddr structure -- used for WSAIoctl(SIO_SET_QOS) when we
 * do not want to issue a connect for a sending socket.  The destination
 * address is required so we can generate the session information for
 * RSVP signalling.
*/

typedef struct _QOS_DESTADDR {
    QOS_OBJECT_HDR ObjectHdr;                     /* Object header */
    const struct sockaddr *  SocketAddress;       /* Destination socket address */
    ULONG                    SocketAddressLength; /* Length of the address structure */
} QOS_DESTADDR, *LPQOS_DESTADDR;

typedef const QOS_DESTADDR * LPCQOS_DESTADDR;



/*
 * this structure defines the "General Characterization Parameters" contained in
 * the RSVP Adspec object
 */
typedef struct _AD_GENERAL_PARAMS{

    ULONG       IntServAwareHopCount;   /* number of hops that conform to
                                         * Integrated Services requirements */
    ULONG       PathBandwidthEstimate;  /* minimum bandwidth available from 
                                         * sender to receiver */
    ULONG       MinimumLatency;         /* sum of minimum latency of the packet
                                         * forwarding process in routers 
                                         * (in usec)*/
    ULONG       PathMTU;                /* max transmission unit end to end that
                                         * will not incur fragmentation */
    ULONG       Flags;                  /* used to hold break bits.*/

} AD_GENERAL_PARAMS, *LPAD_GENERAL_PARAMS;

/*
 * Minimum Latency may be set to this "undefined" value
 */
#define INDETERMINATE_LATENCY   0xFFFFFFFF;

/*
 * This Flag is used to indicate the existence of a network element not 
 * supporting  QoS control services somewhere in the data path. If this bit 
 * is set in the specific service override then it indicates that that
 * service was not supported at at least one hop.
 */
#define AD_FLAG_BREAK_BIT    0x00000001

/*
 * this structure describes the Guaranteed service parameters
 */
typedef struct _AD_GUARANTEED {

    ULONG       CTotal;
    ULONG       DTotal;
    ULONG       CSum;
    ULONG       DSum;

} AD_GUARANTEED, *LPAD_GUARANTEED;

/*
 * this structure describes the format of the parameter buffer that can be
 * included in the Service_Type structure below.  This structure allows an
 * application to include any valid Int Serv service parameter in the Buffer 
 * value, after providing the Int Serv parameter id in the ParameterId field.
 */
typedef struct _PARAM_BUFFER {

    ULONG   ParameterId;    /* Int Server parameter ID */
    ULONG   Length;         /* total length of this structure 
                             * ( 8 bytes + length of Buffer ) */
    UCHAR   Buffer[1];      /* Paramter itself */

} PARAM_BUFFER, *LPPARAM_BUFFER;

/*
 * this structure contains the service types supported
 */
typedef struct _CONTROL_SERVICE {

    /*
     * the length of this entire structure including the following buffer.  
     * This length value can be added to the ptr to the structure to get the ptr
     * to the next SERVICE_TYPE structure in the list, until the
     * NumberOfServices count has been exhausted.
     */
    ULONG               Length;

    SERVICETYPE         Service;
    AD_GENERAL_PARAMS   Overrides;

    /*
     * service specific information ( controlled load has no service specific 
     * info here )
     */
    union {
        AD_GUARANTEED   Guaranteed;
        PARAM_BUFFER    ParamBuffer[1];     /* allows for other services down 
                                             * the road */
    };

} CONTROL_SERVICE, *LPCONTROL_SERVICE;

/*
 * This structure defines the information which is carried in the Rsvp 
 * Adspec.  This Rsvp object typically indicates which service types are 
 * available ( Controlled Load and/or Guaranteed Service ), if a non-Rsvp
 * hop has been encountered by the Path message, and the minumum MTU along 
 * the path. The services array indicates which services are supported
 */
typedef struct _RSVP_ADSPEC  {

    QOS_OBJECT_HDR     ObjectHdr;
    AD_GENERAL_PARAMS  GeneralParams;      /* contains the general 
                                            * characterization paramters */
    ULONG              NumberOfServices;   /* count of the number of services */
    CONTROL_SERVICE    Services[1];        /* a list of the services 
                                            * supported/requested */

} RSVP_ADSPEC, *LPRSVP_ADSPEC;


//
// Opcode for the SIO_CHK_QOS ioctl
// (specific for the Microsoft QOS Service Provider
//
// Bascially:
//
// SIO_CHK_QOS = _WSAIORW(IOC_VENDOR,1)
//             = mIOC_IN | mIOC_OUT | mIOC_VENDOR | mCOMPANY | ioctl_code
//    where
//         mIOC_IN     = 0x80000000
//         mIOC_OUT    = 0x40000000
//         mIOC_VENDOR = 0x04000000
//         mCOMPANY    = 0x18000000
//         ioctl_code  = 0x00000001
//         
// See WSAIoctl man page for details.
//

#define    mIOC_IN       0x80000000
#define    mIOC_OUT      0x40000000
#define    mIOC_VENDOR   0x04000000
#define    mCOMPANY      0x18000000
#define    ioctl_code    0x00000001

#define SIO_CHK_QOS   (mIOC_IN | mIOC_OUT | mIOC_VENDOR | mCOMPANY | ioctl_code)

//
// The following may be specified in the input buffer 
// of the SIO_CHK_IOCTL ioctl call 
//

#define QOSSPBASE           50000

#define ALLOWED_TO_SEND_DATA  (QOSSPBASE+1)     // query the SBM/BEST_EFFORT limit 
                                                //   -- result is based on a comparison between
                                                //      the user-specified token rate and the
                                                //      SBM/BEST_EFFORT bandwidth parameters in
                                                //      the system
                                                //   -- result is a YES(1) or NO(0) answer
                                                //      in the output buffer 

#define ABLE_TO_RECV_RSVP     (QOSSPBASE+2)     // query the SBM/BEST_EFFORT limit 
                                                //   -- result is based on a comparison between
                                                //      the user-specified token rate and the
                                                //      SBM/BEST_EFFORT bandwidth parameters in
                                                //      the system
                                                //   -- result is a YES(1) or NO(0) answer
                                                //      in the output buffer 

#define LINE_RATE             (QOSSPBASE+3)     // query the interface capacity 
                                                //   -- result returned in the output buffer
                                                //      in kilo-bits per second

#define LOCAL_TRAFFIC_CONTROL (QOSSPBASE+4)     // check if Kernel Traffic Control is available or not
                                                //   -- 0 if not available
                                                //   -- 1 if avaiable
                                                //   -- INFO_NOT_AVAILABLE if there is no way to check

#define LOCAL_QOSABILITY      (QOSSPBASE+5)     // The followings are for 
                                                // the Discovery of Local QOSability
                                                //   -- 0 if no local QOS support
                                                //   -- 1 if local QOS support available
                                                //   -- INFO_NOT_AVAILABLE if there is no way to check

#define END_TO_END_QOSABILITY (QOSSPBASE+6)     // The followings are for 
                                                // the Discovery of End-to-End QOSability
                                                //   -- 0 if no end-to-end QOS support
                                                //   -- 1 if end-to-end QOS support available
                                                //   -- INFO_NOT_AVAILABLE if there is no way to check

#define INFO_NOT_AVAILABLE  0xFFFFFFFF          // used when LINE_RATE is not known


#define ANY_DEST_ADDR       0xFFFFFFFF          // for QOS_OBJECT_DEST_ADDR


// The followings are for Guaranteed_Service+Latency -> ISSLOW_Traffic_Class Mapping

#define MODERATELY_DELAY_SENSITIVE   0xFFFFFFFD  

#define HIGHLY_DELAY_SENSITIVE       0xFFFFFFFE

//
// QOSSP Error Code/Value
//

#define QOSSP_ERR_BASE                                 (QOSSPBASE+6000)

// No error
#define GQOS_NO_ERRORCODE                              (0)

#define GQOS_NO_ERRORVALUE                             (0)

// Unknown error
#define GQOS_ERRORCODE_UNKNOWN                         (0xFFFFFFFF)

#define GQOS_ERRORVALUE_UNKNOWN                        (0xFFFFFFFF)

// Admission (Resource) Error
#define GQOS_NET_ADMISSION                             (QOSSP_ERR_BASE+100)

#define GQOS_OTHER                                     (QOSSP_ERR_BASE+100+1)
#define GQOS_DELAYBND                                  (QOSSP_ERR_BASE+100+2)
#define GQOS_BANDWIDTH                                 (QOSSP_ERR_BASE+100+3)
#define GQOS_MTU                                       (QOSSP_ERR_BASE+100+4)
#define GQOS_FLOW_RATE                                 (QOSSP_ERR_BASE+100+5)
#define GQOS_PEAK_RATE                                 (QOSSP_ERR_BASE+100+6)
#define GQOS_AGG_PEAK_RATE                             (QOSSP_ERR_BASE+100+7)

// Policy Error
#define GQOS_NET_POLICY                                (QOSSP_ERR_BASE+200)

#define GQOS_POLICY_ERROR_UNKNOWN                      (QOSSP_ERR_BASE+200+0)

#define GQOS_POLICY_GLOBAL_DEF_FLOW_COUNT              (QOSSP_ERR_BASE+200+1)
#define GQOS_POLICY_GLOBAL_GRP_FLOW_COUNT              (QOSSP_ERR_BASE+200+2)
#define GQOS_POLICY_GLOBAL_USER_FLOW_COUNT             (QOSSP_ERR_BASE+200+3)
#define GQOS_POLICY_GLOBAL_UNK_USER_FLOW_COUNT         (QOSSP_ERR_BASE+200+4)
#define GQOS_POLICY_SUBNET_DEF_FLOW_COUNT              (QOSSP_ERR_BASE+200+5)
#define GQOS_POLICY_SUBNET_GRP_FLOW_COUNT              (QOSSP_ERR_BASE+200+6)
#define GQOS_POLICY_SUBNET_USER_FLOW_COUNT             (QOSSP_ERR_BASE+200+7)
#define GQOS_POLICY_SUBNET_UNK_USER_FLOW_COUNT         (QOSSP_ERR_BASE+200+8)

#define GQOS_POLICY_GLOBAL_DEF_FLOW_DURATION           (QOSSP_ERR_BASE+200+9)
#define GQOS_POLICY_GLOBAL_GRP_FLOW_DURATION           (QOSSP_ERR_BASE+200+10)
#define GQOS_POLICY_GLOBAL_USER_FLOW_DURATION          (QOSSP_ERR_BASE+200+11)
#define GQOS_POLICY_GLOBAL_UNK_USER_FLOW_DURATION      (QOSSP_ERR_BASE+200+12)
#define GQOS_POLICY_SUBNET_DEF_FLOW_DURATION           (QOSSP_ERR_BASE+200+13)
#define GQOS_POLICY_SUBNET_GRP_FLOW_DURATION           (QOSSP_ERR_BASE+200+14) 
#define GQOS_POLICY_SUBNET_USER_FLOW_DURATION          (QOSSP_ERR_BASE+200+15)
#define GQOS_POLICY_SUBNET_UNK_USER_FLOW_DURATION      (QOSSP_ERR_BASE+200+16)

#define GQOS_POLICY_GLOBAL_DEF_FLOW_RATE               (QOSSP_ERR_BASE+200+17)
#define GQOS_POLICY_GLOBAL_GRP_FLOW_RATE               (QOSSP_ERR_BASE+200+18)
#define GQOS_POLICY_GLOBAL_USER_FLOW_RATE              (QOSSP_ERR_BASE+200+19)
#define GQOS_POLICY_GLOBAL_UNK_USER_FLOW_RATE          (QOSSP_ERR_BASE+200+20)
#define GQOS_POLICY_SUBNET_DEF_FLOW_RATE               (QOSSP_ERR_BASE+200+21)
#define GQOS_POLICY_SUBNET_GRP_FLOW_RATE               (QOSSP_ERR_BASE+200+22)
#define GQOS_POLICY_SUBNET_USER_FLOW_RATE              (QOSSP_ERR_BASE+200+23)
#define GQOS_POLICY_SUBNET_UNK_USER_FLOW_RATE          (QOSSP_ERR_BASE+200+24)

#define GQOS_POLICY_GLOBAL_DEF_PEAK_RATE               (QOSSP_ERR_BASE+200+25)
#define GQOS_POLICY_GLOBAL_GRP_PEAK_RATE               (QOSSP_ERR_BASE+200+26)
#define GQOS_POLICY_GLOBAL_USER_PEAK_RATE              (QOSSP_ERR_BASE+200+27)
#define GQOS_POLICY_GLOBAL_UNK_USER_PEAK_RATE          (QOSSP_ERR_BASE+200+28)
#define GQOS_POLICY_SUBNET_DEF_PEAK_RATE               (QOSSP_ERR_BASE+200+29)
#define GQOS_POLICY_SUBNET_GRP_PEAK_RATE               (QOSSP_ERR_BASE+200+30)
#define GQOS_POLICY_SUBNET_USER_PEAK_RATE              (QOSSP_ERR_BASE+200+31)
#define GQOS_POLICY_SUBNET_UNK_USER_PEAK_RATE          (QOSSP_ERR_BASE+200+32)

#define GQOS_POLICY_GLOBAL_DEF_SUM_FLOW_RATE           (QOSSP_ERR_BASE+200+33)
#define GQOS_POLICY_GLOBAL_GRP_SUM_FLOW_RATE           (QOSSP_ERR_BASE+200+34)
#define GQOS_POLICY_GLOBAL_USER_SUM_FLOW_RATE          (QOSSP_ERR_BASE+200+35)
#define GQOS_POLICY_GLOBAL_UNK_USER_SUM_FLOW_RATE      (QOSSP_ERR_BASE+200+36)
#define GQOS_POLICY_SUBNET_DEF_SUM_FLOW_RATE           (QOSSP_ERR_BASE+200+37)
#define GQOS_POLICY_SUBNET_GRP_SUM_FLOW_RATE           (QOSSP_ERR_BASE+200+38)
#define GQOS_POLICY_SUBNET_USER_SUM_FLOW_RATE          (QOSSP_ERR_BASE+200+39)
#define GQOS_POLICY_SUBNET_UNK_USER_SUM_FLOW_RATE      (QOSSP_ERR_BASE+200+40)

#define GQOS_POLICY_GLOBAL_DEF_SUM_PEAK_RATE           (QOSSP_ERR_BASE+200+41)
#define GQOS_POLICY_GLOBAL_GRP_SUM_PEAK_RATE           (QOSSP_ERR_BASE+200+42)
#define GQOS_POLICY_GLOBAL_USER_SUM_PEAK_RATE          (QOSSP_ERR_BASE+200+43)
#define GQOS_POLICY_GLOBAL_UNK_USER_SUM_PEAK_RATE      (QOSSP_ERR_BASE+200+44)
#define GQOS_POLICY_SUBNET_DEF_SUM_PEAK_RATE           (QOSSP_ERR_BASE+200+45)
#define GQOS_POLICY_SUBNET_GRP_SUM_PEAK_RATE           (QOSSP_ERR_BASE+200+46)
#define GQOS_POLICY_SUBNET_USER_SUM_PEAK_RATE          (QOSSP_ERR_BASE+200+47)
#define GQOS_POLICY_SUBNET_UNK_USER_SUM_PEAK_RATE      (QOSSP_ERR_BASE+200+48)

#define GQOS_POLICY_UNKNOWN_USER                       (QOSSP_ERR_BASE+200+49)
#define GQOS_POLICY_NO_PRIVILEGES                      (QOSSP_ERR_BASE+200+50)
#define GQOS_POLICY_EXPIRED_USER_TOKEN                 (QOSSP_ERR_BASE+200+51)
#define GQOS_POLICY_NO_RESOURCES                       (QOSSP_ERR_BASE+200+52)
#define GQOS_POLICY_PRE_EMPTED                         (QOSSP_ERR_BASE+200+53)
#define GQOS_POLICY_USER_CHANGED                       (QOSSP_ERR_BASE+200+54)
#define GQOS_POLICY_NO_ACCEPTS                         (QOSSP_ERR_BASE+200+55)
#define GQOS_POLICY_NO_MEMORY                          (QOSSP_ERR_BASE+200+56)
#define GQOS_POLICY_CRAZY_FLOWSPEC                     (QOSSP_ERR_BASE+200+57)

#define GQOS_POLICY_NO_MORE_INFO                       (QOSSP_ERR_BASE+200+58)
#define GQOS_POLICY_UNSUPPORTED_CREDENTIAL_TYPE        (QOSSP_ERR_BASE+200+59)
#define GQOS_POLICY_INSUFFICIENT_PRIVILEGES            (QOSSP_ERR_BASE+200+60)
#define GQOS_POLICY_EXPIRED_CREDENTIAL                 (QOSSP_ERR_BASE+200+61)
#define GQOS_POLICY_IDENTITY_CHANGED                   (QOSSP_ERR_BASE+200+62)
#define GQOS_POLICY_NO_QOS_PROVIDED                    (QOSSP_ERR_BASE+200+63)
#define GQOS_POLICY_DO_NOT_SEND                        (QOSSP_ERR_BASE+200+64)

#define GQOS_POLICY_ERROR_USERID                       (QOSSP_ERR_BASE+200+99)

// RSVP Error
#define GQOS_RSVP                                      (QOSSP_ERR_BASE+300)

#define GQOS_NO_PATH                                   (QOSSP_ERR_BASE+300+1)
#define GQOS_NO_SENDER                                 (QOSSP_ERR_BASE+300+2)
#define GQOS_BAD_STYLE                                 (QOSSP_ERR_BASE+300+3)
#define GQOS_UNKNOWN_STYLE                             (QOSSP_ERR_BASE+300+4)
#define GQOS_BAD_DSTPORT                               (QOSSP_ERR_BASE+300+5) 
#define GQOS_BAD_SNDPORT                               (QOSSP_ERR_BASE+300+6)
#define GQOS_AMBIG_FILTER                              (QOSSP_ERR_BASE+300+7)
#define GQOS_PREEMPTED                                 (QOSSP_ERR_BASE+300+8)
#define GQOS_UNKN_OBJ_CLASS                            (QOSSP_ERR_BASE+300+9)
#define GQOS_UNKNOWN_CTYPE                             (QOSSP_ERR_BASE+300+10)
#define GQOS_INVALID                                   (QOSSP_ERR_BASE+300+11)

// API Error
#define GQOS_API                                       (QOSSP_ERR_BASE+400)

#define GQOS_API_BADSEND                               (QOSSP_ERR_BASE+400+1) /* Sender addr not my interface */
#define GQOS_API_BADRECV                               (QOSSP_ERR_BASE+400+2) /* Recv addr not my interface */
#define GQOS_API_BADSPORT                              (QOSSP_ERR_BASE+400+3) /* Sport !=0 but Dport == 0 */

// TC System Error
#define GQOS_KERNEL_TC_SYS                             (QOSSP_ERR_BASE+500)

#define GQOS_TC_GENERIC                                (QOSSP_ERR_BASE+500+1)
#define GQOS_TC_INVALID                                (QOSSP_ERR_BASE+500+2)
#define GQOS_NO_MEMORY                                 (QOSSP_ERR_BASE+500+3)
#define GQOS_BAD_ADDRESSTYPE                           (QOSSP_ERR_BASE+500+4) 
#define GQOS_BAD_DUPLICATE                             (QOSSP_ERR_BASE+500+5)
#define GQOS_CONFLICT                                  (QOSSP_ERR_BASE+500+6)
#define GQOS_NOTREADY                                  (QOSSP_ERR_BASE+500+7)
#define GQOS_WOULDBLOCK                                (QOSSP_ERR_BASE+500+8)
#define GQOS_INCOMPATIBLE                              (QOSSP_ERR_BASE+500+9)
#define GQOS_BAD_SDMODE                                (QOSSP_ERR_BASE+500+10)
#define GQOS_BAD_QOSPRIORITY                           (QOSSP_ERR_BASE+500+11)
#define GQOS_BAD_TRAFFICCLASS                          (QOSSP_ERR_BASE+500+12)
#define GQOS_NO_SYS_RESOURCES                          (QOSSP_ERR_BASE+500+13)

// RSVP System Error
#define GQOS_RSVP_SYS                                  (QOSSP_ERR_BASE+600)

#define GQOS_OTHER_SYS                                 (QOSSP_ERR_BASE+600+1)
#define GQOS_MEMORY_SYS                                (QOSSP_ERR_BASE+600+2)
#define GQOS_API_SYS                                   (QOSSP_ERR_BASE+600+3)
#define GQOS_SETQOS_NO_LOCAL_APPS                      (QOSSP_ERR_BASE+600+4)

// TC Error
#define GQOS_KERNEL_TC                                 (QOSSP_ERR_BASE+700)

#define GQOS_CONFLICT_SERV                             (QOSSP_ERR_BASE+700+1)
#define GQOS_NO_SERV                                   (QOSSP_ERR_BASE+700+2)
#define GQOS_BAD_FLOWSPEC                              (QOSSP_ERR_BASE+700+3)
#define GQOS_BAD_TSPEC                                 (QOSSP_ERR_BASE+700+4)
#define GQOS_BAD_ADSPEC                                (QOSSP_ERR_BASE+700+5)

// GQOS API ERRORS

// WSAIoctl Error

#define GQOS_IOCTL_SYSTEMFAILURE                       (QOSSP_ERR_BASE+800+1)
#define GQOS_IOCTL_NOBYTESRETURNED                     (QOSSP_ERR_BASE+800+2)
#define GQOS_IOCTL_INVALIDSOCKET                       (QOSSP_ERR_BASE+800+3)
#define GQOS_IOCTL_INV_FUNCPTR                         (QOSSP_ERR_BASE+800+4)
#define GQOS_IOCTL_INV_OVERLAPPED                      (QOSSP_ERR_BASE+800+5)

// SIO_SET_QOS error

#define GQOS_SETQOS_BADINBUFFER                        (QOSSP_ERR_BASE+810+1)
#define GQOS_SETQOS_BADFLOWSPEC                        (QOSSP_ERR_BASE+810+2)
#define GQOS_SETQOS_COLLISION                          (QOSSP_ERR_BASE+810+3)
#define GQOS_SETQOS_BADPROVSPECBUF                     (QOSSP_ERR_BASE+810+4)
#define GQOS_SETQOS_ILLEGALOP                          (QOSSP_ERR_BASE+810+5)
#define GQOS_SETQOS_INVALIDADDRESS                     (QOSSP_ERR_BASE+810+6)
#define GQOS_SETQOS_OUTOFMEMORY                        (QOSSP_ERR_BASE+810+7)
#define GQOS_SETQOS_EXCEPTION                          (QOSSP_ERR_BASE+810+8)
#define GQOS_SETQOS_BADADDRLEN                         (QOSSP_ERR_BASE+810+9)
#define GQOS_SETQOS_NOSOCKNAME                         (QOSSP_ERR_BASE+810+10)
#define GQOS_SETQOS_IPTOSFAIL                          (QOSSP_ERR_BASE+810+11)
#define GQOS_SETQOS_OPENSESSIONFAIL                    (QOSSP_ERR_BASE+810+12)
#define GQOS_SETQOS_SENDFAIL                           (QOSSP_ERR_BASE+810+13)
#define GQOS_SETQOS_RECVFAIL                           (QOSSP_ERR_BASE+810+14)
#define GQOS_SETQOS_BADPOLICYOBJECT                    (QOSSP_ERR_BASE+810+15)
#define GQOS_SETQOS_UNKNOWNFILTEROBJ                   (QOSSP_ERR_BASE+810+16)
#define GQOS_SETQOS_BADFILTERTYPE                      (QOSSP_ERR_BASE+810+17)
#define GQOS_SETQOS_BADFILTERCOUNT                     (QOSSP_ERR_BASE+810+18)
#define GQOS_SETQOS_BADOBJLENGTH                       (QOSSP_ERR_BASE+810+19)
#define GQOS_SETQOS_BADFLOWCOUNT                       (QOSSP_ERR_BASE+810+20)
#define GQOS_SETQOS_UNKNOWNPSOBJ                       (QOSSP_ERR_BASE+810+21)
#define GQOS_SETQOS_BADPOLICYOBJ                       (QOSSP_ERR_BASE+810+22)
#define GQOS_SETQOS_BADFLOWDESC                        (QOSSP_ERR_BASE+810+23)
#define GQOS_SETQOS_BADPROVSPECOBJ                     (QOSSP_ERR_BASE+810+24)
#define GQOS_SETQOS_NOLOOPBACK                         (QOSSP_ERR_BASE+810+25)
#define GQOS_SETQOS_MODENOTSUPPORTED                   (QOSSP_ERR_BASE+810+26)
#define GQOS_SETQOS_MISSINGFLOWDESC                    (QOSSP_ERR_BASE+810+27)

// SIO_GET_QOS error

#define GQOS_GETQOS_BADOUTBUFFER                       (QOSSP_ERR_BASE+840+1)
#define GQOS_GETQOS_SYSTEMFAILURE                      (QOSSP_ERR_BASE+840+2)
#define GQOS_GETQOS_EXCEPTION                          (QOSSP_ERR_BASE+840+3)
#define GQOS_GETQOS_INTERNALFAILURE                    (QOSSP_ERR_BASE+840+4)

// SIO_CHK_QOS error

#define GQOS_CHKQOS_BADINBUFFER                        (QOSSP_ERR_BASE+850+1)
#define GQOS_CHKQOS_BADOUTBUFFER                       (QOSSP_ERR_BASE+850+2)
#define GQOS_CHKQOS_SYSTEMFAILURE                      (QOSSP_ERR_BASE+850+3)
#define GQOS_CHKQOS_INTERNALFAILURE                    (QOSSP_ERR_BASE+850+4)
#define GQOS_CHKQOS_BADPARAMETER                       (QOSSP_ERR_BASE+850+5)
#define GQOS_CHKQOS_EXCEPTION                          (QOSSP_ERR_BASE+850+6)

#endif  /* __QOSSP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\Query.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for query.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __query_h__
#define __query_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISearchQueryHits_FWD_DEFINED__
#define __ISearchQueryHits_FWD_DEFINED__
typedef interface ISearchQueryHits ISearchQueryHits;
#endif 	/* __ISearchQueryHits_FWD_DEFINED__ */


#ifndef __IRowsetQueryStatus_FWD_DEFINED__
#define __IRowsetQueryStatus_FWD_DEFINED__
typedef interface IRowsetQueryStatus IRowsetQueryStatus;
#endif 	/* __IRowsetQueryStatus_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "filter.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IQueryStructures_INTERFACE_DEFINED__
#define __IQueryStructures_INTERFACE_DEFINED__

/* interface IQueryStructures */
/* [unique][uuid] */ 

#define DBQUERYGUID  { 0x49691C90, \
                       0x7E17, 0x101A, \
                       0xA9, 0x1C, 0x08, 0x00, 0x2B, \
                       0x2E, 0xCD, 0xA9 } 
#define	DISPID_QUERY_RANKVECTOR	( 2 )

#define	DISPID_QUERY_RANK	( 3 )

#define	DISPID_QUERY_HITCOUNT	( 4 )

#define	DISPID_QUERY_WORKID	( 5 )

#define	DISPID_QUERY_ALL	( 6 )

#define	DISPID_QUERY_UNFILTERED	( 7 )

#define	DISPID_QUERY_REVNAME	( 8 )

#define	DISPID_QUERY_VIRTUALPATH	( 9 )

#define	DISPID_QUERY_LASTSEENTIME	( 10 )

#define	CQUERYDISPIDS	( 11 )

#define PSGUID_QUERY_METADATA { 0x624C9360, \
                                0x93D0, 0x11CF, \
                                0xA7, 0x87, 0x00, 0x00, 0x4C, \
                                0x75, 0x27, 0x52 } 
#define	DISPID_QUERY_METADATA_VROOTUSED	( 2 )

#define	DISPID_QUERY_METADATA_VROOTAUTOMATIC	( 3 )

#define	DISPID_QUERY_METADATA_VROOTMANUAL	( 4 )

#define	DISPID_QUERY_METADATA_PROPGUID	( 5 )

#define	DISPID_QUERY_METADATA_PROPDISPID	( 6 )

#define	DISPID_QUERY_METADATA_PROPNAME	( 7 )

#define	DISPID_QUERY_METADATA_STORELEVEL	( 8 )

#define	DISPID_QUERY_METADATA_PROPMODIFIABLE	( 9 )

#define	CQUERYMETADISPIDS	( 10 )

#define DBBMKGUID { 0xC8B52232L, \
                 0x5CF3, 0x11CE, \
                 {0xAD, 0xE5, 0x00, 0xAA, 0x00, \
                  0x44, 0x77, 0x3D } }
#define	PROPID_DBBMK_BOOKMARK	( 2 )

#define	PROPID_DBBMK_CHAPTER	( 3 )

#define	CDBBMKDISPIDS	( 8 )

#define DBSELFGUID {0xc8b52231,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
#define	PROPID_DBSELF_SELF	( 2 )

#define	CDBSELFDISPIDS	( 8 )

#define	CDBCOLDISPIDS	( 28 )

#define	CQUERYPROPERTY	( 64 )

#define PSGUID_CHARACTERIZATION { 0x560c36c0, \
                                  0x503a, 0x11cf, \
                                  0xba, 0xa1, 0x00, 0x00, \
                                  0x4c, 0x75, 0x2a, 0x9a } 
#define	QUERY_VALIDBITS	( 3 )

#define	RTNone	( 0 )

#define	RTAnd	( 1 )

#define	RTOr	( 2 )

#define	RTNot	( 3 )

#define	RTContent	( 4 )

#define	RTProperty	( 5 )

#define	RTProximity	( 6 )

#define	RTVector	( 7 )

#define	RTNatLanguage	( 8 )

typedef struct tagRESTRICTION RESTRICTION;

typedef struct tagNOTRESTRICTION
    {
    RESTRICTION *pRes;
    } 	NOTRESTRICTION;

typedef struct tagNODERESTRICTION
    {
    ULONG cRes;
    RESTRICTION **paRes;
    ULONG reserved;
    } 	NODERESTRICTION;

#define	VECTOR_RANK_MIN	( 0 )

#define	VECTOR_RANK_MAX	( 1 )

#define	VECTOR_RANK_INNER	( 2 )

#define	VECTOR_RANK_DICE	( 3 )

#define	VECTOR_RANK_JACCARD	( 4 )

typedef struct tagVECTORRESTRICTION
    {
    NODERESTRICTION Node;
    ULONG RankMethod;
    } 	VECTORRESTRICTION;

#define	GENERATE_METHOD_EXACT	( 0 )

#define	GENERATE_METHOD_PREFIXMATCH	( 1 )

#define	GENERATE_METHOD_STEMMED	( 2 )

typedef struct tagCONTENTRESTRICTION
    {
    FULLPROPSPEC prop;
    WCHAR *pwcsPhrase;
    LCID lcid;
    ULONG ulGenerateMethod;
    } 	CONTENTRESTRICTION;

typedef struct tagNATLANGUAGERESTRICTION
    {
    FULLPROPSPEC prop;
    WCHAR *pwcsPhrase;
    LCID lcid;
    } 	NATLANGUAGERESTRICTION;

#define	PRLT	( 0 )

#define	PRLE	( 1 )

#define	PRGT	( 2 )

#define	PRGE	( 3 )

#define	PREQ	( 4 )

#define	PRNE	( 5 )

#define	PRRE	( 6 )

#define	PRAllBits	( 7 )

#define	PRSomeBits	( 8 )

#define	PRAll	( 0x100 )

#define	PRAny	( 0x200 )

typedef struct tagPROPERTYRESTRICTION
    {
    ULONG rel;
    FULLPROPSPEC prop;
    PROPVARIANT prval;
    } 	PROPERTYRESTRICTION;


struct tagRESTRICTION
    {
    ULONG rt;
    ULONG weight;
    union _URes
        {
        NODERESTRICTION ar;
        NODERESTRICTION or;
        NODERESTRICTION pxr;
        VECTORRESTRICTION vr;
        NOTRESTRICTION nr;
        CONTENTRESTRICTION cr;
        NATLANGUAGERESTRICTION nlr;
        PROPERTYRESTRICTION pr;
         /* Empty union arm */ 
        } 	res;
    } ;
typedef struct tagCOLUMNSET
    {
    ULONG cCol;
    FULLPROPSPEC *aCol;
    } 	COLUMNSET;

#define	QUERY_SORTASCEND	( 0 )

#define	QUERY_SORTDESCEND	( 1 )

#define	QUERY_SORTXASCEND	( 2 )

#define	QUERY_SORTXDESCEND	( 3 )

#define	QUERY_SORTDEFAULT	( 4 )

typedef struct tagSORTKEY
    {
    FULLPROPSPEC propColumn;
    ULONG dwOrder;
    LCID locale;
    } 	SORTKEY;

typedef struct tagSORTSET
    {
    ULONG cCol;
    SORTKEY *aCol;
    } 	SORTSET;

#define	CATEGORIZE_UNIQUE	( 0 )

#define	CATEGORIZE_CLUSTER	( 1 )

#define	CATEGORIZE_BUCKETS	( 2 )

#define	BUCKET_LINEAR	( 0 )

#define	BUCKET_EXPONENTIAL	( 1 )

typedef struct tagBUCKETCATEGORIZE
    {
    ULONG cBuckets;
    ULONG Distribution;
    } 	BUCKETCATEGORIZE;

#define	CATEGORIZE_RANGE	( 3 )

typedef struct tagRANGECATEGORIZE
    {
    ULONG cRange;
    PROPVARIANT *aRangeBegin;
    } 	RANGECATEGORIZE;

typedef struct tagCATEGORIZATION
    {
    ULONG ulCatType;
    union 
        {
        ULONG cClusters;
        BUCKETCATEGORIZE bucket;
        RANGECATEGORIZE range;
         /* Empty union arm */ 
        } 	;
    COLUMNSET csColumns;
    } 	CATEGORIZATION;

typedef struct tagCATEGORIZATIONSET
    {
    ULONG cCat;
    CATEGORIZATION *aCat;
    } 	CATEGORIZATIONSET;

typedef unsigned long OCCURRENCE;

#define	OCC_INVALID	( 0xffffffff )

#define	MAX_QUERY_RANK	( 1000 )



extern RPC_IF_HANDLE IQueryStructures_v0_0_c_ifspec;
extern RPC_IF_HANDLE IQueryStructures_v0_0_s_ifspec;
#endif /* __IQueryStructures_INTERFACE_DEFINED__ */

#ifndef __ISearchQueryHits_INTERFACE_DEFINED__
#define __ISearchQueryHits_INTERFACE_DEFINED__

/* interface ISearchQueryHits */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_ISearchQueryHits;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ed8ce7e0-106c-11ce-84e2-00aa004b9986")
    ISearchQueryHits : public IUnknown
    {
    public:
        virtual SCODE STDMETHODCALLTYPE Init( 
            /* [in] */ IFilter *pflt,
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual SCODE STDMETHODCALLTYPE NextHitMoniker( 
            /* [out][in] */ ULONG *pcMnk,
            /* [size_is][out] */ IMoniker ***papMnk) = 0;
        
        virtual SCODE STDMETHODCALLTYPE NextHitOffset( 
            /* [out][in] */ ULONG *pcRegion,
            /* [size_is][out] */ FILTERREGION **paRegion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISearchQueryHitsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISearchQueryHits * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISearchQueryHits * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISearchQueryHits * This);
        
        SCODE ( STDMETHODCALLTYPE *Init )( 
            ISearchQueryHits * This,
            /* [in] */ IFilter *pflt,
            /* [in] */ ULONG ulFlags);
        
        SCODE ( STDMETHODCALLTYPE *NextHitMoniker )( 
            ISearchQueryHits * This,
            /* [out][in] */ ULONG *pcMnk,
            /* [size_is][out] */ IMoniker ***papMnk);
        
        SCODE ( STDMETHODCALLTYPE *NextHitOffset )( 
            ISearchQueryHits * This,
            /* [out][in] */ ULONG *pcRegion,
            /* [size_is][out] */ FILTERREGION **paRegion);
        
        END_INTERFACE
    } ISearchQueryHitsVtbl;

    interface ISearchQueryHits
    {
        CONST_VTBL struct ISearchQueryHitsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchQueryHits_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISearchQueryHits_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISearchQueryHits_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISearchQueryHits_Init(This,pflt,ulFlags)	\
    ( (This)->lpVtbl -> Init(This,pflt,ulFlags) ) 

#define ISearchQueryHits_NextHitMoniker(This,pcMnk,papMnk)	\
    ( (This)->lpVtbl -> NextHitMoniker(This,pcMnk,papMnk) ) 

#define ISearchQueryHits_NextHitOffset(This,pcRegion,paRegion)	\
    ( (This)->lpVtbl -> NextHitOffset(This,pcRegion,paRegion) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISearchQueryHits_INTERFACE_DEFINED__ */


#ifndef __IRowsetQueryStatus_INTERFACE_DEFINED__
#define __IRowsetQueryStatus_INTERFACE_DEFINED__

/* interface IRowsetQueryStatus */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IRowsetQueryStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a7ac77ed-f8d7-11ce-a798-0020f8008024")
    IRowsetQueryStatus : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ DWORD *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusEx( 
            /* [out] */ DWORD *pdwStatus,
            /* [out] */ DWORD *pcFilteredDocuments,
            /* [out] */ DWORD *pcDocumentsToFilter,
            /* [out] */ ULONG_PTR *pdwRatioFinishedDenominator,
            /* [out] */ ULONG_PTR *pdwRatioFinishedNumerator,
            /* [in] */ ULONG_PTR cbBmk,
            /* [size_is][in] */ const BYTE *pBmk,
            /* [out] */ ULONG_PTR *piRowBmk,
            /* [out] */ ULONG_PTR *pcRowsTotal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetQueryStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRowsetQueryStatus * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRowsetQueryStatus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRowsetQueryStatus * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IRowsetQueryStatus * This,
            /* [out] */ DWORD *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatusEx )( 
            IRowsetQueryStatus * This,
            /* [out] */ DWORD *pdwStatus,
            /* [out] */ DWORD *pcFilteredDocuments,
            /* [out] */ DWORD *pcDocumentsToFilter,
            /* [out] */ ULONG_PTR *pdwRatioFinishedDenominator,
            /* [out] */ ULONG_PTR *pdwRatioFinishedNumerator,
            /* [in] */ ULONG_PTR cbBmk,
            /* [size_is][in] */ const BYTE *pBmk,
            /* [out] */ ULONG_PTR *piRowBmk,
            /* [out] */ ULONG_PTR *pcRowsTotal);
        
        END_INTERFACE
    } IRowsetQueryStatusVtbl;

    interface IRowsetQueryStatus
    {
        CONST_VTBL struct IRowsetQueryStatusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowsetQueryStatus_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRowsetQueryStatus_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRowsetQueryStatus_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRowsetQueryStatus_GetStatus(This,pdwStatus)	\
    ( (This)->lpVtbl -> GetStatus(This,pdwStatus) ) 

#define IRowsetQueryStatus_GetStatusEx(This,pdwStatus,pcFilteredDocuments,pcDocumentsToFilter,pdwRatioFinishedDenominator,pdwRatioFinishedNumerator,cbBmk,pBmk,piRowBmk,pcRowsTotal)	\
    ( (This)->lpVtbl -> GetStatusEx(This,pdwStatus,pcFilteredDocuments,pcDocumentsToFilter,pdwRatioFinishedDenominator,pdwRatioFinishedNumerator,cbBmk,pBmk,piRowBmk,pcRowsTotal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRowsetQueryStatus_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_query_0000_0003 */
/* [local] */ 

#include <indexsrv.h>


extern RPC_IF_HANDLE __MIDL_itf_query_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_query_0000_0003_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\Ras.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ras.h

Abstract:

    Remote Access external API

    WINVER values in this file:
        WINVER < 0x400 = Windows NT 3.5, Windows NT 3.51
        WINVER = 0x400 = Windows 95, Windows98, Windows NT4 (default)
        WINVER > 0x400 = Windows NT4 enhancements
        WINVER = 0x500 = Windows 2000

--*/

#ifndef _RAS_H_
#define _RAS_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef UNLEN
#include <lmcons.h>
#endif

// To use Quarantine APIs, applications should explicitly 
// define USES_RAS_QUARANTINE_APIS.
#ifdef USES_RAS_QUARANTINE_APIS
#include <naptypes.h>

#define RASNAP_ProbationTime            0x00000001

typedef struct _tagRasNapState
{
    DWORD          dwSize;
    DWORD          dwFlags;
    IsolationState isolationState;
    ProbationTime  probationTime;
} RASNAPSTATE, *LPRASNAPSTATE;
#endif // USES_RAS_QUARANTINE_APIS

#include <pshpack4.h>
#include <in6addr.h>


#define RAS_MaxDeviceType     16
#define RAS_MaxPhoneNumber    128
#define RAS_MaxIpAddress      15
#define RAS_MaxIpxAddress     21

#if (WINVER >= 0x400)
#define RAS_MaxEntryName      256
#define RAS_MaxDeviceName     128
#define RAS_MaxCallbackNumber RAS_MaxPhoneNumber
#else
#define RAS_MaxEntryName      20
#define RAS_MaxDeviceName     32
#define RAS_MaxCallbackNumber 48
#endif

#define RAS_MaxAreaCode       10
#define RAS_MaxPadType        32
#define RAS_MaxX25Address     200
#define RAS_MaxFacilities     200
#define RAS_MaxUserData       200
#define RAS_MaxReplyMessage   1024
#define RAS_MaxDnsSuffix      256

DECLARE_HANDLE( HRASCONN );
#define LPHRASCONN HRASCONN*

#if (WINVER >= 0x501)
#define RASCF_AllUsers	      0x00000001
#define RASCF_GlobalCreds     0x00000002
#define RASCF_OwnerKnown      0x00000004
#define RASCF_OwnerMatch      0x00000008

#define RASCF_IsOwner(rascFlags)    (((rascFlags) & (RASCF_OwnerKnown | RASCF_OwnerMatch)) == (RASCF_OwnerKnown | RASCF_OwnerMatch))
#define RASCF_IsNotOwner(rascFlags) (((rascFlags) & (RASCF_OwnerKnown | RASCF_OwnerMatch)) == (RASCF_OwnerKnown))
#endif

/* Identifies an active RAS connection.  (See RasEnumConnections)
*/
#define RASCONNW struct tagRASCONNW
RASCONNW
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    WCHAR    szEntryName[ RAS_MaxEntryName + 1 ];

#if (WINVER >= 0x400)
    WCHAR    szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR    szDeviceName[ RAS_MaxDeviceName + 1 ];
#endif
#if (WINVER >= 0x401)
    WCHAR    szPhonebook [ MAX_PATH ];
    DWORD    dwSubEntry;
#endif
#if (WINVER >= 0x500)
    GUID     guidEntry;
#endif
#if (WINVER >= 0x501)
    DWORD    dwFlags;
    LUID     luid;
#endif
#if (WINVER >= 0x600)
    GUID     guidCorrelationId;
#endif
};

#define RASCONNA struct tagRASCONNA
RASCONNA
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    CHAR     szEntryName[ RAS_MaxEntryName + 1 ];

#if (WINVER >= 0x400)
    CHAR     szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR     szDeviceName[ RAS_MaxDeviceName + 1 ];
#endif
#if (WINVER >= 0x401)
    CHAR     szPhonebook [ MAX_PATH ];
    DWORD    dwSubEntry;
#endif
#if (WINVER >= 0x500)
    GUID     guidEntry;
#endif
#if (WINVER >= 0x501)
    DWORD    dwFlags;
    LUID     luid;
#endif
#if (WINVER >= 0x600)
    GUID     guidCorrelationId;
#endif
};

#ifdef UNICODE
#define RASCONN RASCONNW
#else
#define RASCONN RASCONNA
#endif

#define LPRASCONNW RASCONNW*
#define LPRASCONNA RASCONNA*
#define LPRASCONN  RASCONN*


/* Enumerates intermediate states to a connection.  (See RasDial)
*/
#define RASCS_PAUSED 0x1000
#define RASCS_DONE   0x2000

#define RASCONNSTATE enum tagRASCONNSTATE
RASCONNSTATE
{
    RASCS_OpenPort = 0,
    RASCS_PortOpened,
    RASCS_ConnectDevice,
    RASCS_DeviceConnected,
    RASCS_AllDevicesConnected,
    RASCS_Authenticate,
    RASCS_AuthNotify,
    RASCS_AuthRetry,
    RASCS_AuthCallback,
    RASCS_AuthChangePassword,
    RASCS_AuthProject,
    RASCS_AuthLinkSpeed,
    RASCS_AuthAck,
    RASCS_ReAuthenticate,
    RASCS_Authenticated,
    RASCS_PrepareForCallback,
    RASCS_WaitForModemReset,
    RASCS_WaitForCallback,
    RASCS_Projected,

#if (WINVER >= 0x400)
    RASCS_StartAuthentication,
    RASCS_CallbackComplete,
    RASCS_LogonNetwork,
#endif
    RASCS_SubEntryConnected,
    RASCS_SubEntryDisconnected,

    RASCS_Interactive = RASCS_PAUSED,
    RASCS_RetryAuthentication,
    RASCS_CallbackSetByCaller,
    RASCS_PasswordExpired,
#if (WINVER >= 0x500)
    RASCS_InvokeEapUI,
#endif

    RASCS_Connected = RASCS_DONE,
    RASCS_Disconnected
};

#define LPRASCONNSTATE RASCONNSTATE*


/* Describes the status of a RAS connection.  (See RasConnectionStatus)
*/
#define RASCONNSTATUSW struct tagRASCONNSTATUSW
RASCONNSTATUSW
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    WCHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
#if (WINVER >= 0x401)
    WCHAR        szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
#endif
};

#define RASCONNSTATUSA struct tagRASCONNSTATUSA
RASCONNSTATUSA
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    CHAR         szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR         szDeviceName[ RAS_MaxDeviceName + 1 ];
#if (WINVER >= 0x401)
    CHAR         szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
#endif
};

#ifdef UNICODE
#define RASCONNSTATUS RASCONNSTATUSW
#else
#define RASCONNSTATUS RASCONNSTATUSA
#endif

#define LPRASCONNSTATUSW RASCONNSTATUSW*
#define LPRASCONNSTATUSA RASCONNSTATUSA*
#define LPRASCONNSTATUS  RASCONNSTATUS*

/* Describes connection establishment parameters.  (See RasDial)
*/
#define RASDIALPARAMSW struct tagRASDIALPARAMSW
RASDIALPARAMSW
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
    WCHAR szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    WCHAR szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
#if (WINVER >= 0x401)
    DWORD dwSubEntry;
    ULONG_PTR dwCallbackId;
#endif
};

#define RASDIALPARAMSA struct tagRASDIALPARAMSA
RASDIALPARAMSA
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];
    CHAR  szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    CHAR  szUserName[ UNLEN + 1 ];
    CHAR  szPassword[ PWLEN + 1 ];
    CHAR  szDomain[ DNLEN + 1 ];
#if (WINVER >= 0x401)
    DWORD dwSubEntry;
    ULONG_PTR dwCallbackId;
#endif
};

#ifdef UNICODE
#define RASDIALPARAMS RASDIALPARAMSW
#else
#define RASDIALPARAMS RASDIALPARAMSA
#endif

#define LPRASDIALPARAMSW RASDIALPARAMSW*
#define LPRASDIALPARAMSA RASDIALPARAMSA*
#define LPRASDIALPARAMS  RASDIALPARAMS*

#if (WINVER >= 0x500)

#define RASEAPINFO struct tagRASEAPINFO
RASEAPINFO
{
    DWORD dwSizeofEapInfo;
    BYTE  *pbEapInfo;
};

#endif

/* Describes extended connection establishment options.  (See RasDial)
*/
#define RASDIALEXTENSIONS struct tagRASDIALEXTENSIONS
RASDIALEXTENSIONS
{
    DWORD      dwSize;
    DWORD      dwfOptions;
    HWND       hwndParent;
    ULONG_PTR  reserved;
#if (WINVER >= 0x500)
    ULONG_PTR  reserved1;
    RASEAPINFO RasEapInfo;
#endif
};

#define LPRASDIALEXTENSIONS RASDIALEXTENSIONS*

/* 'dwfOptions' bit flags.
*/
#define RDEOPT_UsePrefixSuffix           0x00000001
#define RDEOPT_PausedStates              0x00000002
#define RDEOPT_IgnoreModemSpeaker        0x00000004
#define RDEOPT_SetModemSpeaker           0x00000008
#define RDEOPT_IgnoreSoftwareCompression 0x00000010
#define RDEOPT_SetSoftwareCompression    0x00000020
#define RDEOPT_DisableConnectedUI        0x00000040
#define RDEOPT_DisableReconnectUI        0x00000080
#define RDEOPT_DisableReconnect          0x00000100
#define RDEOPT_NoUser                    0x00000200
#define RDEOPT_PauseOnScript             0x00000400
#define RDEOPT_Router                    0x00000800

#if (WINVER >= 0x500)
#define RDEOPT_CustomDial                0x00001000
#endif

#if (WINVER >= 0x501)
#define RDEOPT_UseCustomScripting        0x00002000
#endif


//
// This flag when set in the RASENTRYNAME structure
// indicates that the phonebook to which this entry
// belongs is a system phonebook.
//
#define REN_User                         0x00000000
#define REN_AllUsers                     0x00000001


/* Describes an enumerated RAS phone book entry name.  (See RasEntryEnum)
*/
#define RASENTRYNAMEW struct tagRASENTRYNAMEW
RASENTRYNAMEW
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];

#if (WINVER >= 0x500)
    //
    // If this flag is REN_AllUsers then its a
    // system phonebook.
    //
    DWORD dwFlags;
    WCHAR szPhonebookPath[MAX_PATH + 1];
#endif
};

#define RASENTRYNAMEA struct tagRASENTRYNAMEA
RASENTRYNAMEA
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];

#if (WINVER >= 0x500)
    DWORD dwFlags;
    CHAR  szPhonebookPath[MAX_PATH + 1];
#endif

};

#ifdef UNICODE
#define RASENTRYNAME RASENTRYNAMEW
#else
#define RASENTRYNAME RASENTRYNAMEA
#endif

#define LPRASENTRYNAMEW RASENTRYNAMEW*
#define LPRASENTRYNAMEA RASENTRYNAMEA*
#define LPRASENTRYNAME  RASENTRYNAME*


/* Protocol code to projection data structure mapping.
*/
#define RASPROJECTION enum tagRASPROJECTION
RASPROJECTION
{
    RASP_Amb = 0x10000,
    RASP_PppNbf = 0x803F,
    RASP_PppIpx = 0x802B,
    RASP_PppIp = 0x8021,
#if (WINVER >= 0x500)
    RASP_PppCcp = 0x80FD,
#endif
    RASP_PppLcp = 0xC021,
#if (WINVER >= 0x600)
    RASP_PppIpv6 = 0x8057,   // To get Ipv6 projection information
#endif
#if (WINVER < 0x600) // SLIP
    RASP_Slip = 0x20000
#endif // (WINVER < 0x600) // SLIP
};

#define LPRASPROJECTION RASPROJECTION*


/* Describes the result of a RAS AMB (Authentication Message Block)
** projection.  This protocol is used with NT 3.1 and OS/2 1.3 downlevel
** RAS servers.
*/
#define RASAMBW struct tagRASAMBW
RASAMBW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#define RASAMBA struct tagRASAMBA
RASAMBA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#ifdef UNICODE
#define RASAMB RASAMBW
#else
#define RASAMB RASAMBA
#endif

#define LPRASAMBW RASAMBW*
#define LPRASAMBA RASAMBA*
#define LPRASAMB  RASAMB*


/* Describes the result of a PPP NBF (NetBEUI) projection.
*/
#define RASPPPNBFW struct tagRASPPPNBFW
RASPPPNBFW
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwNetBiosError;
    WCHAR szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    WCHAR szWorkstationName[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#define RASPPPNBFA struct tagRASPPPNBFA
RASPPPNBFA
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwNetBiosError;
    CHAR  szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    CHAR  szWorkstationName[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#ifdef UNICODE
#define RASPPPNBF RASPPPNBFW
#else
#define RASPPPNBF RASPPPNBFA
#endif

#define LPRASPPPNBFW RASPPPNBFW*
#define LPRASPPPNBFA RASPPPNBFA*
#define LPRASPPPNBF  RASPPPNBF*


/* Describes the results of a PPP IPX (Internetwork Packet Exchange)
** projection.
*/
#define RASPPPIPXW struct tagRASIPXW
RASPPPIPXW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpxAddress[ RAS_MaxIpxAddress + 1 ];
};


#define RASPPPIPXA struct tagRASPPPIPXA
RASPPPIPXA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpxAddress[ RAS_MaxIpxAddress + 1 ];
};

#ifdef UNICODE
#define RASPPPIPX RASPPPIPXW
#else
#define RASPPPIPX RASPPPIPXA
#endif

#define LPRASPPPIPXW RASPPPIPXW*
#define LPRASPPPIPXA RASPPPIPXA*
#define LPRASPPPIPX  RASPPPIPX*


/* Describes the results of a PPP IP (Internet) projection.
*/

#if (WINVER >= 0x500)

/* RASPPPIP 'dwOptions' and 'dwServerOptions' flags.
*/
#define RASIPO_VJ       0x00000001

#endif

#define RASPPPIPW struct tagRASPPPIPW
RASPPPIPW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpAddress[ RAS_MaxIpAddress + 1 ];

#ifndef WINNT35COMPATIBLE

    /* This field was added between Windows NT 3.51 beta and Windows NT 3.51
    ** final, and between Windows 95 M8 beta and Windows 95 final.  If you do
    ** not require the server address and wish to retrieve PPP IP information
    ** from Windows NT 3.5 or early Windows NT 3.51 betas, or on early Windows
    ** 95 betas, define WINNT35COMPATIBLE.
    **
    ** The server IP address is not provided by all PPP implementations,
    ** though Windows NT server's do provide it.
    */
    WCHAR szServerIpAddress[ RAS_MaxIpAddress + 1 ];

#endif
#if (WINVER >= 0x500)
    DWORD dwOptions;
    DWORD dwServerOptions;
#endif
};

#define RASPPPIPA struct tagRASPPPIPA
RASPPPIPA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpAddress[ RAS_MaxIpAddress + 1 ];

#ifndef WINNT35COMPATIBLE

    /* See RASPPPIPW comment.
    */
    CHAR  szServerIpAddress[ RAS_MaxIpAddress + 1 ];

#endif
#if (WINVER >= 0x500)
    DWORD dwOptions;
    DWORD dwServerOptions;
#endif
};

#ifdef UNICODE
#define RASPPPIP RASPPPIPW
#else
#define RASPPPIP RASPPPIPA
#endif

#define LPRASPPPIPW RASPPPIPW*
#define LPRASPPPIPA RASPPPIPA*
#define LPRASPPPIP  RASPPPIP*

/* Describes the results of a Ipv6 projection info
*/
#if (WINVER >= 0x600)

#define RASPPPIPV6 struct tagRASPPPIPV6
RASPPPIPV6
{
    DWORD dwSize;
    DWORD dwError;
    BYTE  bLocalInterfaceIdentifier[8];
    BYTE  bPeerInterfaceIdentifier[8];
    BYTE  bLocalCompressionProtocol[2];
    BYTE  bPeerCompressionProtocol[2];
};

#define LPRASPPPIPV6  RASPPPIPV6*
#endif
  

/* Describes the results of a PPP LCP/multi-link negotiation.
*/

#if (WINVER >= 0x500)

/* RASPPPLCP 'dwAuthenticatonProtocol' values.
*/
#define RASLCPAP_PAP          0xC023
#define RASLCPAP_SPAP         0xC027
#define RASLCPAP_CHAP         0xC223
#define RASLCPAP_EAP          0xC227

/* RASPPPLCP 'dwAuthenticatonData' values.
*/
#define RASLCPAD_CHAP_MD5     0x05
#define RASLCPAD_CHAP_MS      0x80
#define RASLCPAD_CHAP_MSV2    0x81

/* RASPPPLCP 'dwOptions' and 'dwServerOptions' flags.
*/
#define RASLCPO_PFC           0x00000001
#define RASLCPO_ACFC          0x00000002
#define RASLCPO_SSHF          0x00000004
#define RASLCPO_DES_56        0x00000008
#define RASLCPO_3_DES         0x00000010

#if (WINVER >= 0x600)
#define RASLCPO_AES_128	      0x00000020
#define RASLCPO_AES_256	      0x00000040
#endif /* WINVER >= 0x0600 */

#endif


#define RASPPPLCPW struct tagRASPPPLCPW
RASPPPLCPW
{
    DWORD dwSize;
    BOOL  fBundled;

#if (WINVER >= 0x500)
    DWORD dwError;
    DWORD dwAuthenticationProtocol;
    DWORD dwAuthenticationData;
    DWORD dwEapTypeId;
    DWORD dwServerAuthenticationProtocol;
    DWORD dwServerAuthenticationData;
    DWORD dwServerEapTypeId;
    BOOL  fMultilink;
    DWORD dwTerminateReason;
    DWORD dwServerTerminateReason;
    WCHAR szReplyMessage[RAS_MaxReplyMessage];
    DWORD dwOptions;
    DWORD dwServerOptions;
#endif

};

#define RASPPPLCPA struct tagRASPPPLCPA
RASPPPLCPA
{
    DWORD dwSize;
    BOOL  fBundled;

#if (WINVER >= 0x500)
    DWORD dwError;
    DWORD dwAuthenticationProtocol;
    DWORD dwAuthenticationData;
    DWORD dwEapTypeId;
    DWORD dwServerAuthenticationProtocol;
    DWORD dwServerAuthenticationData;
    DWORD dwServerEapTypeId;
    BOOL  fMultilink;
    DWORD dwTerminateReason;
    DWORD dwServerTerminateReason;
    CHAR  szReplyMessage[RAS_MaxReplyMessage];
    DWORD dwOptions;
    DWORD dwServerOptions;
#endif

};


#ifdef UNICODE
#define RASPPPLCP RASPPPLCPW
#else
#define RASPPPLCP RASPPPLCPA
#endif

#define LPRASPPPLCPW RASPPPLCPW*
#define LPRASPPPLCPA RASPPPLCPA*
#define LPRASPPPLCP  RASPPPLCP*

#if (WINVER < 0x600) // SLIP

/* Describes the results of a SLIP (Serial Line IP) projection.
*/
#define RASSLIPW struct tagRASSLIPW
RASSLIPW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpAddress[ RAS_MaxIpAddress + 1 ];
};


#define RASSLIPA struct tagRASSLIPA
RASSLIPA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpAddress[ RAS_MaxIpAddress + 1 ];
};

#ifdef UNICODE
#define RASSLIP RASSLIPW
#else
#define RASSLIP RASSLIPA
#endif

#define LPRASSLIPW RASSLIPW*
#define LPRASSLIPA RASSLIPA*
#define LPRASSLIP  RASSLIP*

#endif // SLIP

#if (WINVER >= 0x500)

/* Describes the results of a PPP CCP (Compression Control Protocol)
projection.
*/

/* RASPPPCCP 'dwCompressionAlgorithm' values.
*/
#define RASCCPCA_MPPC             0x00000006
#define RASCCPCA_STAC             0x00000005

/* RASPPPCCP 'dwOptions' values.
*/
#define RASCCPO_Compression       0x00000001
#define RASCCPO_HistoryLess       0x00000002
#define RASCCPO_Encryption56bit   0x00000010
#define RASCCPO_Encryption40bit   0x00000020
#define RASCCPO_Encryption128bit  0x00000040

#define RASPPPCCP struct tagRASPPPCCP
RASPPPCCP
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwCompressionAlgorithm;
    DWORD dwOptions;
    DWORD dwServerCompressionAlgorithm;
    DWORD dwServerOptions;
};

#define LPRASPPPCCP  RASPPPCCP*

#endif

/* If using RasDial message notifications, get the notification message code
** by passing this string to the RegisterWindowMessageA() API.
** WM_RASDIALEVENT is used only if a unique message cannot be registered.
*/
#define RASDIALEVENT    "RasDialEvent"
#define WM_RASDIALEVENT 0xCCCD

/* Prototypes for caller's RasDial callback handler.  Arguments are the
** message ID (currently always WM_RASDIALEVENT), the current RASCONNSTATE and
** the error that has occurred (or 0 if none).  Extended arguments are the
** handle of the RAS connection and an extended error code.
**
** For RASDIALFUNC2, subsequent callback notifications for all
** subentries can be cancelled by returning FALSE.
*/
typedef VOID (WINAPI *RASDIALFUNC)( UINT, RASCONNSTATE, DWORD );
typedef VOID (WINAPI *RASDIALFUNC1)( HRASCONN, UINT, RASCONNSTATE, DWORD, DWORD );
typedef DWORD (WINAPI *RASDIALFUNC2)( ULONG_PTR, DWORD, HRASCONN, UINT, RASCONNSTATE, DWORD, DWORD );


/* Information describing a RAS-capable device.
*/
#define RASDEVINFOW struct tagRASDEVINFOW
RASDEVINFOW
{
    DWORD    dwSize;
    WCHAR    szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR    szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#define RASDEVINFOA struct tagRASDEVINFOA
RASDEVINFOA
{
    DWORD    dwSize;
    CHAR     szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR     szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#ifdef UNICODE
#define RASDEVINFO RASDEVINFOW
#else
#define RASDEVINFO RASDEVINFOA
#endif

#define LPRASDEVINFOW RASDEVINFOW*
#define LPRASDEVINFOA RASDEVINFOA*
#define LPRASDEVINFO  RASDEVINFO*

/* RAS country information (currently retrieved from TAPI).
*/
#define RASCTRYINFO struct RASCTRYINFO
RASCTRYINFO
{
    DWORD   dwSize;
    DWORD   dwCountryID;
    DWORD   dwNextCountryID;
    DWORD   dwCountryCode;
    DWORD   dwCountryNameOffset;
};

/* There is currently no difference between
** RASCTRYINFOA and RASCTRYINFOW.  This may
** change in the future.
*/
#define RASCTRYINFOW   RASCTRYINFO
#define RASCTRYINFOA   RASCTRYINFO

#define LPRASCTRYINFOW RASCTRYINFOW*
#define LPRASCTRYINFOA RASCTRYINFOW*
#define LPRASCTRYINFO  RASCTRYINFO*

/* A RAS IP address.
*/
#define RASIPADDR struct RASIPADDR
RASIPADDR
{
    BYTE a;
    BYTE b;
    BYTE c;
    BYTE d;
};

#if (WINVER >= 0x600)

/* A RAS IPv6 address.
*/
typedef struct in6_addr RASIPV6ADDR;
#endif

#if (WINVER >= 0x500)

#define ET_None         0  // No encryption
#define ET_Require      1  // Require Encryption
#define ET_RequireMax   2  // Require max encryption
#define ET_Optional     3  // Do encryption if possible. None Ok.

#endif

#define VS_Default      0   // default (PPTP for now)
#define VS_PptpOnly     1   // Only PPTP is attempted.
#define VS_PptpFirst    2   // PPTP is tried first.
#define VS_L2tpOnly     3   // Only L2TP is attempted.
#define VS_L2tpFirst    4   // L2TP is tried first.

/* A RAS phone book entry.
*/
#define RASENTRYA struct tagRASENTRYA
RASENTRYA
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number.
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    CHAR        szAreaCode[ RAS_MaxAreaCode + 1 ];
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    CHAR        szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    CHAR        szAutodialDll[ MAX_PATH ];
    CHAR        szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    CHAR        szX25PadType[ RAS_MaxPadType + 1 ];
    CHAR        szX25Address[ RAS_MaxX25Address + 1 ];
    CHAR        szX25Facilities[ RAS_MaxFacilities + 1 ];
    CHAR        szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
#if (WINVER >= 0x401)
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
#endif

#if (WINVER >= 0x500)

    //
    // Entry Type
    //
    DWORD       dwType;

    //
    // Encryption type
    //
    DWORD       dwEncryptionType;

    //
    // CustomAuthKey to be used for EAP
    //
    DWORD       dwCustomAuthKey;

    //
    // Guid of the connection
    //
    GUID        guidId;

    //
    // Custom Dial Dll
    //
    CHAR        szCustomDialDll[MAX_PATH];

    //
    // DwVpnStrategy
    //
    DWORD       dwVpnStrategy;
#endif

#if (WINVER >= 0x501)
    //
    // More RASEO_* options
    //
    DWORD       dwfOptions2;

    //
    // For future use
    //
    DWORD       dwfOptions3;

    CHAR        szDnsSuffix[RAS_MaxDnsSuffix];

    DWORD       dwTcpWindowSize;

    CHAR        szPrerequisitePbk[MAX_PATH];

    CHAR        szPrerequisiteEntry[RAS_MaxEntryName + 1];

    DWORD       dwRedialCount;

    DWORD       dwRedialPause;
#endif
    //
    // PPP/IPv6
    //
#if (WINVER >= 0x600)
    RASIPV6ADDR   ipv6addrDns;
    RASIPV6ADDR   ipv6addrDnsAlt;
    DWORD         dwIPv4InterfaceMetric;
    DWORD         dwIPv6InterfaceMetric;
#endif
};

#define RASENTRYW struct tagRASENTRYW
RASENTRYW
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    WCHAR       szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    WCHAR       szAutodialDll[ MAX_PATH ];
    WCHAR       szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
    WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
#if (WINVER >= 0x401)
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
#endif

#if (WINVER >= 0x500)
    //
    // Entry Type
    //
    DWORD       dwType;

    //
    // EncryptionType
    //
    DWORD       dwEncryptionType;

    //
    // CustomAuthKey to be used for EAP
    //
    DWORD       dwCustomAuthKey;

    //
    // Guid of the connection
    //
    GUID        guidId;

    //
    // Custom Dial Dll
    //
    WCHAR       szCustomDialDll[MAX_PATH];

    //
    // Vpn Strategy
    //
    DWORD       dwVpnStrategy;
#endif

#if (WINVER >= 0x501)
    //
    // More RASEO_* options
    //
    DWORD       dwfOptions2;

    //
    // For future use
    //
    DWORD       dwfOptions3;

    WCHAR       szDnsSuffix[RAS_MaxDnsSuffix];

    DWORD       dwTcpWindowSize;

    WCHAR       szPrerequisitePbk[MAX_PATH];

    WCHAR       szPrerequisiteEntry[RAS_MaxEntryName + 1];

    DWORD       dwRedialCount;

    DWORD       dwRedialPause;
#endif
    //
    // PPP/IPv6
    //
#if (WINVER >= 0x600)
    RASIPV6ADDR   ipv6addrDns;
    RASIPV6ADDR   ipv6addrDnsAlt;
    DWORD         dwIPv4InterfaceMetric;
    DWORD         dwIPv6InterfaceMetric;
#endif
};

#ifdef UNICODE
#define RASENTRY RASENTRYW
#else
#define RASENTRY RASENTRYA
#endif

#define LPRASENTRYW RASENTRYW*
#define LPRASENTRYA RASENTRYA*
#define LPRASENTRY  RASENTRY*

/* RASENTRY 'dwfOptions' bit flags.
*/
#define RASEO_UseCountryAndAreaCodes    0x00000001
#define RASEO_SpecificIpAddr            0x00000002
#define RASEO_SpecificNameServers       0x00000004
#define RASEO_IpHeaderCompression       0x00000008
#define RASEO_RemoteDefaultGateway      0x00000010
#define RASEO_DisableLcpExtensions      0x00000020
#define RASEO_TerminalBeforeDial        0x00000040
#define RASEO_TerminalAfterDial         0x00000080
#define RASEO_ModemLights               0x00000100
#define RASEO_SwCompression             0x00000200
#define RASEO_RequireEncryptedPw        0x00000400
#define RASEO_RequireMsEncryptedPw      0x00000800
#define RASEO_RequireDataEncryption     0x00001000
#define RASEO_NetworkLogon              0x00002000
#define RASEO_UseLogonCredentials       0x00004000
#define RASEO_PromoteAlternates         0x00008000

#if (WINVER >= 0x401)
#define RASEO_SecureLocalFiles          0x00010000
#endif

#if (WINVER >= 0x500)
#define RASEO_RequireEAP                0x00020000
#define RASEO_RequirePAP                0x00040000
#define RASEO_RequireSPAP               0x00080000
#define RASEO_Custom                    0x00100000

#define RASEO_PreviewPhoneNumber        0x00200000
#define RASEO_SharedPhoneNumbers        0x00800000
#define RASEO_PreviewUserPw             0x01000000
#define RASEO_PreviewDomain             0x02000000
#define RASEO_ShowDialingProgress       0x04000000
#define RASEO_RequireCHAP               0x08000000
#define RASEO_RequireMsCHAP             0x10000000
#define RASEO_RequireMsCHAP2            0x20000000
#define RASEO_RequireW95MSCHAP          0x40000000
#define RASEO_CustomScript              0x80000000
#endif

#if (WINVER >= 0x501)
//
// RASENTRY dwfOptions2 bit flags
//
#define RASEO2_SecureFileAndPrint       0x00000001
#define RASEO2_SecureClientForMSNet     0x00000002
#define RASEO2_DontNegotiateMultilink   0x00000004
#define RASEO2_DontUseRasCredentials    0x00000008
#define RASEO2_UsePreSharedKey          0x00000010
#define RASEO2_Internet                 0x00000020
#define RASEO2_DisableNbtOverIP         0x00000040
#define RASEO2_UseGlobalDeviceSettings  0x00000080
#define RASEO2_ReconnectIfDropped       0x00000100
#define RASEO2_SharePhoneNumbers        0x00000200
#endif

#if (WINVER >= 0x600)
#define RASEO2_SecureRoutingCompartment     0x00000400
#define RASEO2_UseTypicalSettings           0x00000800
#define RASEO2_IPv6SpecificNameServers      0x00001000
#define RASEO2_IPv6RemoteDefaultGateway     0x00002000
#define RASEO2_RegisterIpWithDNS            0x00004000
#define RASEO2_UseDNSSuffixForRegistration  0x00008000
#define RASEO2_IPv4ExplicitMetric           0x00010000
#define RASEO2_IPv6ExplicitMetric           0x00020000
#define RASEO2_DisableIKENameEkuCheck  0x00040000
#endif

/* RASENTRY 'dwProtocols' bit flags.
*/
#define RASNP_NetBEUI                   0x00000001
#define RASNP_Ipx                       0x00000002
#define RASNP_Ip                        0x00000004
#if (WINVER >= 0x600)
#define RASNP_Ipv6                      0x00000008
#endif

/* RASENTRY 'dwFramingProtocols' bit flags.
*/
#define RASFP_Ppp                       0x00000001
#define RASFP_Slip                      0x00000002
#define RASFP_Ras                       0x00000004

/* RASENTRY 'szDeviceType' default strings.
*/
#define RASDT_Modem                     TEXT("modem")
#define RASDT_Isdn                      TEXT("isdn")
#define RASDT_X25                       TEXT("x25")
#define RASDT_Vpn                       TEXT("vpn")
#define RASDT_Pad                       TEXT("pad")
#define RASDT_Generic                   TEXT("GENERIC")
#define RASDT_Serial                    TEXT("SERIAL")
#define RASDT_FrameRelay                TEXT("FRAMERELAY")
#define RASDT_Atm                       TEXT("ATM")
#define RASDT_Sonet                     TEXT("SONET")
#define RASDT_SW56                      TEXT("SW56")
#define RASDT_Irda                      TEXT("IRDA")
#define RASDT_Parallel                  TEXT("PARALLEL")
#if (WINVER >= 0x501)
#define RASDT_PPPoE                     TEXT("PPPoE")
#endif


// The entry type used to determine which UI properties
// are to be presented to user.  This generally corresponds
// to a Connections "add" wizard selection.
//
#define RASET_Phone     1  // Phone lines: modem, ISDN, X.25, etc
#define RASET_Vpn       2  // Virtual private network

#if (WINVER < 0x600)
#define RASET_Direct    3  // Direct connect: serial, parallel
#endif // (WINVER < 0x600)

#define RASET_Internet  4  // BaseCamp internet
#if (WINVER >= 0x501)
#define RASET_Broadband 5  // Broadband
#endif

/* Old AutoDial DLL function prototype.
**
** This prototype is documented for backward-compatibility
** purposes only.  It is superceded by the RASADFUNCA
** and RASADFUNCW definitions below.  DO NOT USE THIS
** PROTOTYPE IN NEW CODE.  SUPPORT FOR IT MAY BE REMOVED
** IN FUTURE VERSIONS OF RAS.
*/
typedef BOOL (WINAPI *ORASADFUNC)( HWND, LPSTR, DWORD, LPDWORD );

#if (WINVER >= 0x400)

/* Flags for RasConnectionNotification().
*/
#define RASCN_Connection        0x00000001
#define RASCN_Disconnection     0x00000002
#define RASCN_BandwidthAdded    0x00000004
#define RASCN_BandwidthRemoved  0x00000008

#endif

#if (WINVER >= 0x401)
/* RASENTRY 'dwDialMode' values.
*/
#define RASEDM_DialAll                  1
#define RASEDM_DialAsNeeded             2

/* RASENTRY 'dwIdleDisconnectSeconds' constants.
*/
#define RASIDS_Disabled                 0xffffffff
#define RASIDS_UseGlobalValue           0

/* AutoDial DLL function parameter block.
*/
#define RASADPARAMS struct tagRASADPARAMS
RASADPARAMS
{
    DWORD       dwSize;
    HWND        hwndOwner;
    DWORD       dwFlags;
    LONG        xDlg;
    LONG        yDlg;
};

#define LPRASADPARAMS RASADPARAMS*

/* AutoDial DLL function parameter block 'dwFlags.'
*/
#define RASADFLG_PositionDlg            0x00000001

/* Prototype AutoDial DLL function.
*/
typedef BOOL (WINAPI *RASADFUNCA)( LPSTR, LPSTR, LPRASADPARAMS, LPDWORD );
typedef BOOL (WINAPI *RASADFUNCW)( LPWSTR, LPWSTR, LPRASADPARAMS, LPDWORD );

#ifdef UNICODE
#define RASADFUNC RASADFUNCW
#else
#define RASADFUNC RASADFUNCA
#endif

/* A RAS phone book multilinked sub-entry.
*/
#define RASSUBENTRYA struct tagRASSUBENTRYA
RASSUBENTRYA
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#define RASSUBENTRYW struct tagRASSUBENTRYW
RASSUBENTRYW
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#ifdef UNICODE
#define RASSUBENTRY RASSUBENTRYW
#else
#define RASSUBENTRY RASSUBENTRYA
#endif

#define LPRASSUBENTRYW RASSUBENTRYW*
#define LPRASSUBENTRYA RASSUBENTRYA*
#define LPRASSUBENTRY  RASSUBENTRY*

/* Ras{Get,Set}Credentials structure.  These calls
** supercede Ras{Get,Set}EntryDialParams.
*/
#define RASCREDENTIALSA struct tagRASCREDENTIALSA
RASCREDENTIALSA
{
    DWORD dwSize;
    DWORD dwMask;
    CHAR  szUserName[ UNLEN + 1 ];
    CHAR  szPassword[ PWLEN + 1 ];
    CHAR  szDomain[ DNLEN + 1 ];
};

#define RASCREDENTIALSW struct tagRASCREDENTIALSW
RASCREDENTIALSW
{
    DWORD dwSize;
    DWORD dwMask;
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
};

#ifdef UNICODE
#define RASCREDENTIALS RASCREDENTIALSW
#else
#define RASCREDENTIALS RASCREDENTIALSA
#endif

#define LPRASCREDENTIALSW RASCREDENTIALSW*
#define LPRASCREDENTIALSA RASCREDENTIALSA*
#define LPRASCREDENTIALS  RASCREDENTIALS*

/* RASCREDENTIALS 'dwMask' values.
*/
#define RASCM_UserName           0x00000001
#define RASCM_Password           0x00000002
#define RASCM_Domain             0x00000004
#if (WINVER >= 501)
#define RASCM_DefaultCreds       0x00000008
#define RASCM_PreSharedKey       0x00000010
#define RASCM_ServerPreSharedKey 0x00000020
#define RASCM_DDMPreSharedKey    0x00000040
#endif

/* AutoDial address properties.
*/
#define RASAUTODIALENTRYA struct tagRASAUTODIALENTRYA
RASAUTODIALENTRYA
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    CHAR szEntry[ RAS_MaxEntryName + 1 ];
};

#define RASAUTODIALENTRYW struct tagRASAUTODIALENTRYW
RASAUTODIALENTRYW
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    WCHAR szEntry[ RAS_MaxEntryName + 1 ];
};

#ifdef UNICODE
#define RASAUTODIALENTRY RASAUTODIALENTRYW
#else
#define RASAUTODIALENTRY RASAUTODIALENTRYA
#endif

#define LPRASAUTODIALENTRYW RASAUTODIALENTRYW*
#define LPRASAUTODIALENTRYA RASAUTODIALENTRYA*
#define LPRASAUTODIALENTRY  RASAUTODIALENTRY*

/* AutoDial control parameter values for
** Ras{Get,Set}AutodialParam.
*/
#define RASADP_DisableConnectionQuery           0
#define RASADP_LoginSessionDisable              1
#define RASADP_SavedAddressesLimit              2
#define RASADP_FailedConnectionTimeout          3
#define RASADP_ConnectionQueryTimeout           4

#endif // (WINVER >= 0x401)

#if (WINVER >= 0x500)

/* RasGetEapUserIdentity bit flags.
** These have the same values as the RAS_EAP_FLAG_ flags in raseapif.h
*/
#define RASEAPF_NonInteractive          0x00000002
#define RASEAPF_Logon                   0x00000004
#define RASEAPF_Preview                 0x00000008

/* RasGetEapUserIdentity structure.
*/
#define RASEAPUSERIDENTITYA struct tagRASEAPUSERIDENTITYA
RASEAPUSERIDENTITYA
{
    CHAR        szUserName[ UNLEN + 1 ];
    DWORD       dwSizeofEapInfo;
    BYTE        pbEapInfo[ 1 ];
};

#define RASEAPUSERIDENTITYW struct tagRASEAPUSERIDENTITYW
RASEAPUSERIDENTITYW
{
    WCHAR       szUserName[ UNLEN + 1 ];
    DWORD       dwSizeofEapInfo;
    BYTE        pbEapInfo[ 1 ];
};

#ifdef UNICODE
#define RASEAPUSERIDENTITY RASEAPUSERIDENTITYW
#else
#define RASEAPUSERIDENTITY RASEAPUSERIDENTITYA
#endif

#define LPRASEAPUSERIDENTITYW RASEAPUSERIDENTITYW*
#define LPRASEAPUSERIDENTITYA RASEAPUSERIDENTITYA*

#define LPRASEAPUSERIDENTITY  RASEAPUSERIDENTITY*

typedef DWORD (WINAPI *PFNRASGETBUFFER) (
                            PBYTE *ppBuffer,
                            PDWORD pdwSize
                            );

typedef DWORD (WINAPI *PFNRASFREEBUFFER) (
                            PBYTE pBufer);

typedef DWORD (WINAPI *PFNRASSENDBUFFER) (
                            HANDLE hPort,
                            PBYTE  pBuffer,
                            DWORD  dwSize
                            );

typedef DWORD (WINAPI *PFNRASRECEIVEBUFFER) (
                            HANDLE hPort,
                            PBYTE pBuffer,
                            PDWORD pdwSize,
                            DWORD  dwTimeOut,
                            HANDLE hEvent
                            );

typedef DWORD (WINAPI *PFNRASRETRIEVEBUFFER) (
                            HANDLE hPort,
                            PBYTE pBuffer,
                            PDWORD pdwSize
                            );

typedef  DWORD (WINAPI *RasCustomScriptExecuteFn) (
                            HANDLE hPort,
                            LPCWSTR lpszPhonebook,
                                    LPCWSTR lpszEntryName,
                                    PFNRASGETBUFFER pfnRasGetBuffer,
                                    PFNRASFREEBUFFER pfnRasFreeBuffer,
                                    PFNRASSENDBUFFER pfnRasSendBuffer,
                                    PFNRASRECEIVEBUFFER pfnRasReceiveBuffer,
                                    PFNRASRETRIEVEBUFFER pfnRasRetrieveBuffer,
                            HWND hWnd,
                            RASDIALPARAMS *pRasDialParams,
                            PVOID pvReserved
                            );
                            
                            
                            
                            

#endif // (WINVER >= 0x500)

#if (WINVER >= 0x0501)

#define RASCOMMSETTINGS struct tagRASCOMMSETTINGS
RASCOMMSETTINGS
{
    DWORD     dwSize;
    BYTE      bParity;
    BYTE      bStop;
    BYTE      bByteSize;
    BYTE      bAlign;
};

typedef DWORD (WINAPI *PFNRASSETCOMMSETTINGS) (
                                            HANDLE hPort,
                                            RASCOMMSETTINGS *pRasCommSettings,
                            PVOID  pvReserved
                            );

#define RASCUSTOMSCRIPTEXTENSIONS struct tagRASCUSTOMSCRIPTEXTENSIONS
RASCUSTOMSCRIPTEXTENSIONS
{
    DWORD                 dwSize;
    PFNRASSETCOMMSETTINGS pfnRasSetCommSettings;
};

#endif


/* External RAS API function prototypes.
*/
DWORD APIENTRY RasDialA( LPRASDIALEXTENSIONS, LPCSTR, LPRASDIALPARAMSA, DWORD,
                         LPVOID, LPHRASCONN );

DWORD APIENTRY RasDialW( LPRASDIALEXTENSIONS, LPCWSTR, LPRASDIALPARAMSW, DWORD,
                         LPVOID, LPHRASCONN );

DWORD APIENTRY RasEnumConnectionsA( LPRASCONNA, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumConnectionsW( LPRASCONNW, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumEntriesA( LPCSTR, LPCSTR, LPRASENTRYNAMEA, LPDWORD,
                                LPDWORD );

DWORD APIENTRY RasEnumEntriesW( LPCWSTR, LPCWSTR, LPRASENTRYNAMEW, LPDWORD,
                                LPDWORD );

DWORD APIENTRY RasGetConnectStatusA( HRASCONN, LPRASCONNSTATUSA );

DWORD APIENTRY RasGetConnectStatusW( HRASCONN, LPRASCONNSTATUSW );

DWORD APIENTRY RasGetErrorStringA( UINT uErrorValue, __inout_bcount(cBufSize) LPSTR lpszErrorString, DWORD  cBufSize);

DWORD APIENTRY RasGetErrorStringW( UINT ResourceId, __out_ecount(InBufSize) LPWSTR lpszString, DWORD  InBufSize);

DWORD APIENTRY RasHangUpA( HRASCONN );

DWORD APIENTRY RasHangUpW( HRASCONN );

DWORD APIENTRY RasGetProjectionInfoA( HRASCONN, RASPROJECTION, LPVOID,
                                      LPDWORD );

DWORD APIENTRY RasGetProjectionInfoW( HRASCONN, RASPROJECTION, LPVOID,
                                      LPDWORD );

DWORD APIENTRY RasCreatePhonebookEntryA( HWND, LPCSTR );

DWORD APIENTRY RasCreatePhonebookEntryW( HWND, LPCWSTR );

DWORD APIENTRY RasEditPhonebookEntryA( HWND, LPCSTR, LPCSTR );

DWORD APIENTRY RasEditPhonebookEntryW( HWND, LPCWSTR, LPCWSTR );

DWORD APIENTRY RasSetEntryDialParamsA( LPCSTR, LPRASDIALPARAMSA, BOOL );

DWORD APIENTRY RasSetEntryDialParamsW( LPCWSTR, LPRASDIALPARAMSW, BOOL );

DWORD APIENTRY RasGetEntryDialParamsA( LPCSTR, LPRASDIALPARAMSA, LPBOOL );

DWORD APIENTRY RasGetEntryDialParamsW( LPCWSTR, LPRASDIALPARAMSW, LPBOOL );

DWORD APIENTRY RasEnumDevicesA( LPRASDEVINFOA, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumDevicesW( LPRASDEVINFOW, LPDWORD, LPDWORD );

DWORD APIENTRY RasGetCountryInfoA( LPRASCTRYINFOA, LPDWORD );

DWORD APIENTRY RasGetCountryInfoW( LPRASCTRYINFOW, LPDWORD );

DWORD APIENTRY RasGetEntryPropertiesA( LPCSTR, LPCSTR, LPRASENTRYA, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasGetEntryPropertiesW( LPCWSTR, LPCWSTR, LPRASENTRYW, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasSetEntryPropertiesA( LPCSTR, LPCSTR, LPRASENTRYA, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasSetEntryPropertiesW( LPCWSTR, LPCWSTR, LPRASENTRYW, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasRenameEntryA( LPCSTR, LPCSTR, LPCSTR );

DWORD APIENTRY RasRenameEntryW( LPCWSTR, LPCWSTR, LPCWSTR );

DWORD APIENTRY RasDeleteEntryA( LPCSTR, LPCSTR );

DWORD APIENTRY RasDeleteEntryW( LPCWSTR, LPCWSTR );

DW