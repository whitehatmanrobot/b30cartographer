y.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthBasic {
            get {
                if ((curObj["AuthBasic"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthBasic"]));
            }
            set {
                curObj["AuthBasic"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthChangeDisableNull {
            get {
                if ((curObj["AuthChangeDisable"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthChangeDisable {
            get {
                if ((curObj["AuthChangeDisable"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthChangeDisable"]));
            }
            set {
                curObj["AuthChangeDisable"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthChangeUnsecureNull {
            get {
                if ((curObj["AuthChangeUnsecure"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthChangeUnsecure {
            get {
                if ((curObj["AuthChangeUnsecure"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthChangeUnsecure"]));
            }
            set {
                curObj["AuthChangeUnsecure"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthFlagsNull {
            get {
                if ((curObj["AuthFlags"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AuthFlags {
            get {
                if ((curObj["AuthFlags"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AuthFlags"]));
            }
            set {
                curObj["AuthFlags"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthMD5Null {
            get {
                if ((curObj["AuthMD5"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthMD5 {
            get {
                if ((curObj["AuthMD5"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthMD5"]));
            }
            set {
                curObj["AuthMD5"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthNTLMNull {
            get {
                if ((curObj["AuthNTLM"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthNTLM {
            get {
                if ((curObj["AuthNTLM"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthNTLM"]));
            }
            set {
                curObj["AuthNTLM"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthPassportNull {
            get {
                if ((curObj["AuthPassport"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthPassport {
            get {
                if ((curObj["AuthPassport"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthPassport"]));
            }
            set {
                curObj["AuthPassport"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthPersistenceNull {
            get {
                if ((curObj["AuthPersistence"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AuthPersistence {
            get {
                if ((curObj["AuthPersistence"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AuthPersistence"]));
            }
            set {
                curObj["AuthPersistence"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthPersistSingleRequestNull {
            get {
                if ((curObj["AuthPersistSingleRequest"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthPersistSingleRequest {
            get {
                if ((curObj["AuthPersistSingleRequest"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthPersistSingleRequest"]));
            }
            set {
                curObj["AuthPersistSingleRequest"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAzEnableNull {
            get {
                if ((curObj["AzEnable"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AzEnable {
            get {
                if ((curObj["AzEnable"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AzEnable"]));
            }
            set {
                curObj["AzEnable"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAzImpersonationLevelNull {
            get {
                if ((curObj["AzImpersonationLevel"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AzImpersonationLevel {
            get {
                if ((curObj["AzImpersonationLevel"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AzImpersonationLevel"]));
            }
            set {
                curObj["AzImpersonationLevel"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AzScopeName {
            get {
                return ((string)(curObj["AzScopeName"]));
            }
            set {
                curObj["AzScopeName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AzStoreName {
            get {
                return ((string)(curObj["AzStoreName"]));
            }
            set {
                curObj["AzStoreName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string CacheControlCustom {
            get {
                return ((string)(curObj["CacheControlCustom"]));
            }
            set {
                curObj["CacheControlCustom"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCacheControlMaxAgeNull {
            get {
                if ((curObj["CacheControlMaxAge"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int CacheControlMaxAge {
            get {
                if ((curObj["CacheControlMaxAge"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["CacheControlMaxAge"]));
            }
            set {
                curObj["CacheControlMaxAge"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCacheControlNoCacheNull {
            get {
                if ((curObj["CacheControlNoCache"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool CacheControlNoCache {
            get {
                if ((curObj["CacheControlNoCache"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["CacheControlNoCache"]));
            }
            set {
                curObj["CacheControlNoCache"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCacheISAPINull {
            get {
                if ((curObj["CacheISAPI"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool CacheISAPI {
            get {
                if ((curObj["CacheISAPI"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["CacheISAPI"]));
            }
            set {
                curObj["CacheISAPI"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Caption {
            get {
                return ((string)(curObj["Caption"]));
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCertCheckModeNull {
            get {
                if ((curObj["CertCheckMode"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int CertCheckMode {
            get {
                if ((curObj["CertCheckMode"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["CertCheckMode"]));
            }
            set {
                curObj["CertCheckMode"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCGITimeoutNull {
            get {
                if ((curObj["CGITimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int CGITimeout {
            get {
                if ((curObj["CGITimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["CGITimeout"]));
            }
            set {
                curObj["CGITimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsClusterEnabledNull {
            get {
                if ((curObj["ClusterEnabled"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool ClusterEnabled {
            get {
                if ((curObj["ClusterEnabled"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["ClusterEnabled"]));
            }
            set {
                curObj["ClusterEnabled"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsConnectionTimeoutNull {
            get {
                if ((curObj["ConnectionTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int ConnectionTimeout {
            get {
                if ((curObj["ConnectionTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["ConnectionTimeout"]));
            }
            set {
                curObj["ConnectionTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsContentIndexedNull {
            get {
                if ((curObj["ContentIndexed"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool ContentIndexed {
            get {
                if ((curObj["ContentIndexed"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["ContentIndexed"]));
            }
            set {
                curObj["ContentIndexed"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCreateCGIWithNewConsoleNull {
            get {
                if ((curObj["CreateCGIWithNewConsole"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool CreateCGIWithNewConsole {
            get {
                if ((curObj["CreateCGIWithNewConsole"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["CreateCGIWithNewConsole"]));
            }
            set {
                curObj["CreateCGIWithNewConsole"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCreateProcessAsUserNull {
            get {
                if ((curObj["CreateProcessAsUser"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool CreateProcessAsUser {
            get {
                if ((curObj["CreateProcessAsUser"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["CreateProcessAsUser"]));
            }
            set {
                curObj["CreateProcessAsUser"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string DefaultDoc {
            get {
                return ((string)(curObj["DefaultDoc"]));
            }
            set {
                curObj["DefaultDoc"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string DefaultDocFooter {
            get {
                return ((string)(curObj["DefaultDocFooter"]));
            }
            set {
                curObj["DefaultDocFooter"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string DefaultLogonDomain {
            get {
                return ((string)(curObj["DefaultLogonDomain"]));
            }
            set {
                curObj["DefaultLogonDomain"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Description {
            get {
                return ((string)(curObj["Description"]));
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDirBrowseFlagsNull {
            get {
                if ((curObj["DirBrowseFlags"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int DirBrowseFlags {
            get {
                if ((curObj["DirBrowseFlags"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["DirBrowseFlags"]));
            }
            set {
                curObj["DirBrowseFlags"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDirBrowseShowDateNull {
            get {
                if ((curObj["DirBrowseShowDate"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DirBrowseShowDate {
            get {
                if ((curObj["DirBrowseShowDate"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DirBrowseShowDate"]));
            }
            set {
                curObj["DirBrowseShowDate"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDirBrowseShowExtensionNull {
            get {
                if ((curObj["DirBrowseShowExtension"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DirBrowseShowExtension {
            get {
                if ((curObj["DirBrowseShowExtension"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DirBrowseShowExtension"]));
            }
            set {
                curObj["DirBrowseShowExtension"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDirBrowseShowLongDateNull {
            get {
                if ((curObj["DirBrowseShowLongDate"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DirBrowseShowLongDate {
            get {
                if ((curObj["DirBrowseShowLongDate"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DirBrowseShowLongDate"]));
            }
            set {
                curObj["DirBrowseShowLongDate"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDirBrowseShowSizeNull {
            get {
                if ((curObj["DirBrowseShowSize"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DirBrowseShowSize {
            get {
                if ((curObj["DirBrowseShowSize"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DirBrowseShowSize"]));
            }
            set {
                curObj["DirBrowseShowSize"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDirBrowseShowTimeNull {
            get {
                if ((curObj["DirBrowseShowTime"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DirBrowseShowTime {
            get {
                if ((curObj["DirBrowseShowTime"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DirBrowseShowTime"]));
            }
            set {
                curObj["DirBrowseShowTime"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDisableSocketPoolingNull {
            get {
                if ((curObj["DisableSocketPooling"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DisableSocketPooling {
            get {
                if ((curObj["DisableSocketPooling"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DisableSocketPooling"]));
            }
            set {
                curObj["DisableSocketPooling"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDisableStaticFileCacheNull {
            get {
                if ((curObj["DisableStaticFileCache"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DisableStaticFileCache {
            get {
                if ((curObj["DisableStaticFileCache"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DisableStaticFileCache"]));
            }
            set {
                curObj["DisableStaticFileCache"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDoDynamicCompressionNull {
            get {
                if ((curObj["DoDynamicCompression"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DoDynamicCompression {
            get {
                if ((curObj["DoDynamicCompression"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DoDynamicCompression"]));
            }
            set {
                curObj["DoDynamicCompression"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDontLogNull {
            get {
                if ((curObj["DontLog"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DontLog {
            get {
                if ((curObj["DontLog"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DontLog"]));
            }
            set {
                curObj["DontLog"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDoStaticCompressionNull {
            get {
                if ((curObj["DoStaticCompression"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DoStaticCompression {
            get {
                if ((curObj["DoStaticCompression"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DoStaticCompression"]));
            }
            set {
                curObj["DoStaticCompression"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsEnableDefaultDocNull {
            get {
                if ((curObj["EnableDefaultDoc"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool EnableDefaultDoc {
            get {
                if ((curObj["EnableDefaultDoc"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["EnableDefaultDoc"]));
            }
            set {
                curObj["EnableDefaultDoc"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsEnableDirBrowsingNull {
            get {
                if ((curObj["EnableDirBrowsing"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool EnableDirBrowsing {
            get {
                if ((curObj["EnableDirBrowsing"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["EnableDirBrowsing"]));
            }
            set {
                curObj["EnableDirBrowsing"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsEnableDocFooterNull {
            get {
                if ((curObj["EnableDocFooter"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool EnableDocFooter {
            get {
                if ((curObj["EnableDocFooter"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["EnableDocFooter"]));
            }
            set {
                curObj["EnableDocFooter"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsEnableReverseDnsNull {
            get {
                if ((curObj["EnableReverseDns"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool EnableReverseDns {
            get {
                if ((curObj["EnableReverseDns"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["EnableReverseDns"]));
            }
            set {
                curObj["EnableReverseDns"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsFrontPageWebNull {
            get {
                if ((curObj["FrontPageWeb"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool FrontPageWeb {
            get {
                if ((curObj["FrontPageWeb"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["FrontPageWeb"]));
            }
            set {
                curObj["FrontPageWeb"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject[] HttpCustomHeaders {
            get {
                return ((System.Management.ManagementBaseObject[])(curObj["HttpCustomHeaders"]));
            }
            set {
                curObj["HttpCustomHeaders"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject[] HttpErrors {
            get {
                return ((System.Management.ManagementBaseObject[])(curObj["HttpErrors"]));
            }
            set {
                curObj["HttpErrors"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string HttpExpires {
            get {
                return ((string)(curObj["HttpExpires"]));
            }
            set {
                curObj["HttpExpires"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string[] HttpPics {
            get {
                return ((string[])(curObj["HttpPics"]));
            }
            set {
                curObj["HttpPics"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileBytesRecvNull {
            get {
                if ((curObj["LogExtFileBytesRecv"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileBytesRecv {
            get {
                if ((curObj["LogExtFileBytesRecv"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileBytesRecv"]));
            }
            set {
                curObj["LogExtFileBytesRecv"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileBytesSentNull {
            get {
                if ((curObj["LogExtFileBytesSent"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileBytesSent {
            get {
                if ((curObj["LogExtFileBytesSent"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileBytesSent"]));
            }
            set {
                curObj["LogExtFileBytesSent"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileClientIpNull {
            get {
                if ((curObj["LogExtFileClientIp"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileClientIp {
            get {
                if ((curObj["LogExtFileClientIp"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileClientIp"]));
            }
            set {
                curObj["LogExtFileClientIp"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileComputerNameNull {
            get {
                if ((curObj["LogExtFileComputerName"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileComputerName {
            get {
                if ((curObj["LogExtFileComputerName"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileComputerName"]));
            }
            set {
                curObj["LogExtFileComputerName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileCookieNull {
            get {
                if ((curObj["LogExtFileCookie"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileCookie {
            get {
                if ((curObj["LogExtFileCookie"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileCookie"]));
            }
            set {
                curObj["LogExtFileCookie"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileDateNull {
            get {
                if ((curObj["LogExtFileDate"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileDate {
            get {
                if ((curObj["LogExtFileDate"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileDate"]));
            }
            set {
                curObj["LogExtFileDate"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileFlagsNull {
            get {
                if ((curObj["LogExtFileFlags"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int LogExtFileFlags {
            get {
                if ((curObj["LogExtFileFlags"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["LogExtFileFlags"]));
            }
            set {
                curObj["LogExtFileFlags"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileHostNull {
            get {
                if ((curObj["LogExtFileHost"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileHost {
            get {
                if ((curObj["LogExtFileHost"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileHost"]));
            }
            set {
                curObj["LogExtFileHost"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileHttpStatusNull {
            get {
                if ((curObj["LogExtFileHttpStatus"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileHttpStatus {
            get {
                if ((curObj["LogExtFileHttpStatus"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileHttpStatus"]));
            }
            set {
                curObj["LogExtFileHttpStatus"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileHttpSubStatusNull {
            get {
                if ((curObj["LogExtFileHttpSubStatus"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileHttpSubStatus {
            get {
                if ((curObj["LogExtFileHttpSubStatus"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileHttpSubStatus"]));
            }
            set {
                curObj["LogExtFileHttpSubStatus"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileMethodNull {
            get {
                if ((curObj["LogExtFileMethod"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileMethod {
            get {
                if ((curObj["LogExtFileMethod"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileMethod"]));
            }
            set {
                curObj["LogExtFileMethod"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileProtocolVersionNull {
            get {
                if ((curObj["LogExtFileProtocolVersion"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileProtocolVersion {
            get {
                if ((curObj["LogExtFileProtocolVersion"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileProtocolVersion"]));
            }
            set {
                curObj["LogExtFileProtocolVersion"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileRefererNull {
            get {
                if ((curObj["LogExtFileReferer"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileReferer {
            get {
                if ((curObj["LogExtFileReferer"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileReferer"]));
            }
            set {
                curObj["LogExtFileReferer"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileServerIpNull {
            get {
                if ((curObj["LogExtFileServerIp"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileServerIp {
            get {
                if ((curObj["LogExtFileServerIp"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileServerIp"]));
            }
            set {
                curObj["LogExtFileServerIp"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileServerPortNull {
            get {
                if ((curObj["LogExtFileServerPort"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileServerPort {
            get {
                if ((curObj["LogExtFileServerPort"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileServerPort"]));
            }
            set {
                curObj["LogExtFileServerPort"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileSiteNameNull {
            get {
                if ((curObj["LogExtFileSiteName"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileSiteName {
            get {
                if ((curObj["LogExtFileSiteName"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileSiteName"]));
            }
            set {
                curObj["LogExtFileSiteName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileTimeNull {
            get {
                if ((curObj["LogExtFileTime"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileTime {
            get {
                if ((curObj["LogExtFileTime"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileTime"]));
            }
            set {
                curObj["LogExtFileTime"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileTimeTakenNull {
            get {
                if ((curObj["LogExtFileTimeTaken"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileTimeTaken {
            get {
                if ((curObj["LogExtFileTimeTaken"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileTimeTaken"]));
            }
            set {
                curObj["LogExtFileTimeTaken"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileUriQueryNull {
            get {
                if ((curObj["LogExtFileUriQuery"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileUriQuery {
            get {
                if ((curObj["LogExtFileUriQuery"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileUriQuery"]));
            }
            set {
                curObj["LogExtFileUriQuery"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileUriStemNull {
            get {
                if ((curObj["LogExtFileUriStem"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileUriStem {
            get {
                if ((curObj["LogExtFileUriStem"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileUriStem"]));
            }
            set {
                curObj["LogExtFileUriStem"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileUserAgentNull {
            get {
                if ((curObj["LogExtFileUserAgent"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileUserAgent {
            get {
                if ((curObj["LogExtFileUserAgent"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileUserAgent"]));
            }
            set {
                curObj["LogExtFileUserAgent"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileUserNameNull {
            get {
                if ((curObj["LogExtFileUserName"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileUserName {
            get {
                if ((curObj["LogExtFileUserName"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileUserName"]));
            }
            set {
                curObj["LogExtFileUserName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileWin32StatusNull {
            get {
                if ((curObj["LogExtFileWin32Status"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileWin32Status {
            get {
                if ((curObj["LogExtFileWin32Status"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileWin32Status"]));
            }
            set {
                curObj["LogExtFileWin32Status"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string LogFileDirectory {
            get {
                return ((string)(curObj["LogFileDirectory"]));
            }
            set {
                curObj["LogFileDirectory"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogFileLocaltimeRolloverNull {
            get {
                if ((curObj["LogFileLocaltimeRollover"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogFileLocaltimeRollover {
            get {
                if ((curObj["LogFileLocaltimeRollover"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogFileLocaltimeRollover"]));
            }
            set {
                curObj["LogFileLocaltimeRollover"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogFilePeriodNull {
            get {
                if ((curObj["LogFilePeriod"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int LogFilePeriod {
            get {
                if ((curObj["LogFilePeriod"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["LogFilePeriod"]));
            }
            set {
                curObj["LogFilePeriod"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogFileTruncateSizeNull {
            get {
                if ((curObj["LogFileTruncateSize"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int LogFileTruncateSize {
            get {
                if ((curObj["LogFileTruncateSize"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["LogFileTruncateSize"]));
            }
            set {
                curObj["LogFileTruncateSize"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string LogOdbcDataSource {
            get {
                return ((string)(curObj["LogOdbcDataSource"]));
            }
            set {
                curObj["LogOdbcDataSource"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string LogOdbcPassword {
            get {
                return ((string)(curObj["LogOdbcPassword"]));
            }
            set {
                curObj["LogOdbcPassword"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string LogOdbcTableName {
            get {
                return ((string)(curObj["LogOdbcTableName"]));
            }
            set {
                curObj["LogOdbcTableName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string LogOdbcUserName {
            get {
                return ((string)(curObj["LogOdbcUserName"]));
            }
            set {
                curObj["LogOdbcUserName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogonMethodNull {
            get {
                if ((curObj["LogonMethod"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int LogonMethod {
            get {
                if ((curObj["LogonMethod"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["LogonMethod"]));
            }
            set {
                curObj["LogonMethod"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string LogPluginClsid {
            get {
                return ((string)(curObj["LogPluginClsid"]));
            }
            set {
                curObj["LogPluginClsid"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogTypeNull {
            get {
                if ((curObj["LogType"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int LogType {
            get {
                if ((curObj["LogType"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["LogType"]));
            }
            set {
                curObj["LogType"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsMaxBandwidthNull {
            get {
                if ((curObj["MaxBandwidth"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int MaxBandwidth {
            get {
                if ((curObj["MaxBandwidth"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["MaxBandwidth"]));
            }
            set {
                curObj["MaxBandwidth"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsMaxBandwidthBlockedNull {
            get {
                if ((curObj["MaxBandwidthBlocked"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int MaxBandwidthBlocked {
            get {
                if ((curObj["MaxBandwidthBlocked"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["MaxBandwidthBlocked"]));
            }
            set {
                curObj["MaxBandwidthBlocked"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsMaxConnectionsNull {
            get {
                if ((curObj["MaxConnections"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int MaxConnections {
            get {
                if ((curObj["MaxConnections"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["MaxConnections"]));
            }
            set {
                curObj["MaxConnections"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsMaxEndpointConnectionsNull {
            get {
                if ((curObj["MaxEndpointConnections"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int MaxEndpointConnections {
            get {
                if ((curObj["MaxEndpointConnections"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["MaxEndpointConnections"]));
            }
            set {
                curObj["MaxEndpointConnections"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsMaxRequestEntityAllowedNull {
            get {
                if ((curObj["MaxRequestEntityAllowed"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int MaxRequestEntityAllowed {
            get {
                if ((curObj["MaxRequestEntityAllowed"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["MaxRequestEntityAllowed"]));
            }
            set {
                curObj["MaxRequestEntityAllowed"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject[] MimeMap {
            get {
                return ((System.Management.ManagementBaseObject[])(curObj["MimeMap"]));
            }
            set {
                curObj["MimeMap"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Name {
            get {
                return ((string)(curObj["Name"]));
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string NTAuthenticationProviders {
            get {
                return ((string)(curObj["NTAuthenticationProviders"]));
            }
            set {
                curObj["NTAuthenticationProviders"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPassportRequireADMappingNull {
            get {
                if ((curObj["PassportRequireADMapping"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PassportRequireADMapping {
            get {
                if ((curObj["PassportRequireADMapping"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PassportRequireADMapping"]));
            }
            set {
                curObj["PassportRequireADMapping"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPasswordCacheTTLNull {
            get {
                if ((curObj["PasswordCacheTTL"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PasswordCacheTTL {
            get {
                if ((curObj["PasswordCacheTTL"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PasswordCacheTTL"]));
            }
            set {
                curObj["PasswordCacheTTL"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPasswordChangeFlagsNull {
            get {
                if ((curObj["PasswordChangeFlags"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PasswordChangeFlags {
            get {
                if ((curObj["PasswordChangeFlags"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PasswordChangeFlags"]));
            }
            set {
                curObj["PasswordChangeFlags"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPasswordExpirePrenotifyDaysNull {
            get {
                if ((curObj["PasswordExpirePrenotifyDays"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PasswordExpirePrenotifyDays {
            get {
                if ((curObj["PasswordExpirePrenotifyDays"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PasswordExpirePrenotifyDays"]));
            }
            set {
                curObj["PasswordExpirePrenotifyDays"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPoolIdcTimeoutNull {
            get {
                if ((curObj["PoolIdcTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PoolIdcTimeout {
            get {
                if ((curObj["PoolIdcTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PoolIdcTimeout"]));
            }
            set {
                curObj["PoolIdcTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsProcessNTCRIfLoggedOnNull {
            get {
                if ((curObj["ProcessNTCRIfLoggedOn"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool ProcessNTCRIfLoggedOn {
            get {
                if ((curObj["ProcessNTCRIfLoggedOn"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["ProcessNTCRIfLoggedOn"]));
            }
            set {
                curObj["ProcessNTCRIfLoggedOn"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Realm {
            get {
                return ((string)(curObj["Realm"]));
            }
            set {
                curObj["Realm"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string[] RedirectHeaders {
            get {
                return ((string[])(curObj["RedirectHeaders"]));
            }
            set {
                curObj["RedirectHeaders"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsRevocationFreshnessTimeNull {
            get {
                if ((curObj["RevocationFreshnessTime"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int RevocationFreshnessTime {
            get {
                if ((curObj["RevocationFreshnessTime"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["RevocationFreshnessTime"]));
            }
            set {
                curObj["RevocationFreshnessTime"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsRevocationURLRetrievalTimeoutNull {
            get {
                if ((curObj["RevocationURLRetrievalTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int RevocationURLRetrievalTimeout {
            get {
                if ((curObj["RevocationURLRetrievalTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["RevocationURLRetrievalTimeout"]));
            }
            set {
                curObj["RevocationURLRetrievalTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject[] ScriptMaps {
            get {
                return ((System.Management.ManagementBaseObject[])(curObj["ScriptMaps"]));
            }
            set {
                curObj["ScriptMaps"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject[] SecureBindings {
            get {
                return ((System.Management.ManagementBaseObject[])(curObj["SecureBindings"]));
            }
            set {
                curObj["SecureBindings"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsServerAutoStartNull {
            get {
                if ((curObj["ServerAutoStart"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool ServerAutoStart {
            get {
                if ((curObj["ServerAutoStart"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["ServerAutoStart"]));
            }
            set {
                curObj["ServerAutoStart"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject[] ServerBindings {
            get {
                return ((System.Management.ManagementBaseObject[])(curObj["ServerBindings"]));
            }
            set {
                curObj["ServerBindings"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsServerCommandNull {
            get {
                if ((curObj["ServerCommand"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int ServerCommand {
            get {
                if ((curObj["ServerCommand"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["ServerCommand"]));
            }
            set {
                curObj["ServerCommand"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string ServerComment {
            get {
                return ((string)(curObj["ServerComment"]));
            }
            set {
                curObj["ServerComment"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string ServerID {
            get {
                return ((string)(curObj["ServerID"]));
            }
            set {
                curObj["ServerID"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsServerListenBacklogNull {
            get {
                if ((curObj["ServerListenBacklog"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int ServerListenBacklog {
            get {
                if ((curObj["ServerListenBacklog"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["ServerListenBacklog"]));
            }
            set {
                curObj["ServerListenBacklog"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsServerListenTimeoutNull {
            get {
                if ((curObj["ServerListenTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int ServerListenTimeout {
            get {
                if ((curObj["ServerListenTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["ServerListenTimeout"]));
            }
            set {
                curObj["ServerListenTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsServerSizeNull {
            get {
                if ((curObj["ServerSize"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int ServerSize {
            get {
                if ((curObj["ServerSize"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["ServerSize"]));
            }
            set {
                curObj["ServerSize"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string SetHostName {
            get {
                return ((string)(curObj["SetHostName"]));
            }
            set {
                curObj["SetHostName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string SettingID {
            get {
                return ((string)(curObj["SettingID"]));
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsShutdownTimeLimitNull {
            get {
                if ((curObj["ShutdownTimeLimit"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int ShutdownTimeLimit {
            get {
                if ((curObj["ShutdownTimeLimit"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["ShutdownTimeLimit"]));
            }
            set {
                curObj["ShutdownTimeLimit"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSSIExecDisableNull {
            get {
                if ((curObj["SSIExecDisable"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool SSIExecDisable {
            get {
                if ((curObj["SSIExecDisable"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["SSIExecDisable"]));
            }
            set {
                curObj["SSIExecDisable"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSSLAlwaysNegoClientCertNull {
            get {
                if ((curObj["SSLAlwaysNegoClientCert"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool SSLAlwaysNegoClientCert {
            get {
                if ((curObj["SSLAlwaysNegoClientCert"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["SSLAlwaysNegoClientCert"]));
            }
            set {
                curObj["SSLAlwaysNegoClientCert"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string SslCtlIdentifier {
            get {
                return ((string)(curObj["SslCtlIdentifier"]));
            }
            set {
                curObj["SslCtlIdentifier"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string SslCtlStoreName {
            get {
                return ((string)(curObj["SslCtlStoreName"]));
            }
            set {
                curObj["SslCtlStoreName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string SSLStoreName {
            get {
                return ((string)(curObj["SSLStoreName"]));
            }
            set {
                curObj["SSLStoreName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string[] TraceUriPrefix {
            get {
                return ((string[])(curObj["TraceUriPrefix"]));
            }
            set {
                curObj["TraceUriPrefix"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsUploadReadAheadSizeNull {
            get {
                if ((curObj["UploadReadAheadSize"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int UploadReadAheadSize {
            get {
                if ((curObj["UploadReadAheadSize"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["UploadReadAheadSize"]));
            }
            set {
                curObj["UploadReadAheadSize"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsUseDigestSSPNull {
            get {
                if ((curObj["UseDigestSSP"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool UseDigestSSP {
            get {
                if ((curObj["UseDigestSSP"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["UseDigestSSP"]));
            }
            set {
                curObj["UseDigestSSP"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsUseHostNameNull {
            get {
                if ((curObj["UseHostName"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool UseHostName {
            get {
                if ((curObj["UseHostName"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["UseHostName"]));
            }
            set {
                curObj["UseHostName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsWebDAVMaxAttributesPerElementNull {
            get {
                if ((curObj["WebDAVMaxAttributesPerElement"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int WebDAVMaxAttributesPerElement {
            get {
                if ((curObj["WebDAVMaxAttributesPerElement"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["WebDAVMaxAttributesPerElement"]));
            }
            set {
                curObj["WebDAVMaxAttributesPerElement"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsWin32ErrorNull {
            get {
                if ((curObj["Win32Error"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int Win32Error {
            get {
                if ((curObj["Win32Error"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["Win32Error"]));
            }
            set {
                curObj["Win32Error"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions OptionsParam) {
            if (((path != null) 
                        && (System.String.Compare(path.ClassName, ManagementClassName, true, CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                return CheckIfProperClass(new System.Management.ManagementObject(mgmtScope, path, OptionsParam));
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementBaseObject theObj) {
            if (((theObj != null) 
                        && (System.String.Compare(((string)(theObj["__CLASS"])), ManagementClassName, true, CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                System.Array parentClasses = ((System.Array)(theObj["__DERIVATION"]));
                if ((parentClasses != null)) {
                    Int32 count = 0;
                    for (count = 0; (count < parentClasses.Length); count = (count + 1)) {
                        if ((System.String.Compare(((string)(parentClasses.GetValue(count))), ManagementClassName, true, CultureInfo.InvariantCulture) == 0)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        private bool ShouldSerializeAccessExecute() {
            if ((IsAccessExecuteNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessExecute() {
            curObj["AccessExecute"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessFlags() {
            if ((IsAccessFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessFlags() {
            curObj["AccessFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessNoPhysicalDir() {
            if ((IsAccessNoPhysicalDirNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessNoPhysicalDir() {
            curObj["AccessNoPhysicalDir"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessNoRemoteExecute() {
            if ((IsAccessNoRemoteExecuteNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessNoRemoteExecute() {
            curObj["AccessNoRemoteExecute"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessNoRemoteRead() {
            if ((IsAccessNoRemoteReadNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessNoRemoteRead() {
            curObj["AccessNoRemoteRead"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessNoRemoteScript() {
            if ((IsAccessNoRemoteScriptNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessNoRemoteScript() {
            curObj["AccessNoRemoteScript"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessNoRemoteWrite() {
            if ((IsAccessNoRemoteWriteNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessNoRemoteWrite() {
            curObj["AccessNoRemoteWrite"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessRead() {
            if ((IsAccessReadNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessRead() {
            curObj["AccessRead"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessScript() {
            if ((IsAccessScriptNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessScript() {
            curObj["AccessScript"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSource() {
            if ((IsAccessSourceNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSource() {
            curObj["AccessSource"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSL() {
            if ((IsAccessSSLNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSL() {
            curObj["AccessSSL"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSL128() {
            if ((IsAccessSSL128Null == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSL128() {
            curObj["AccessSSL128"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSLFlags() {
            if ((IsAccessSSLFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSLFlags() {
            curObj["AccessSSLFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSLMapCert() {
            if ((IsAccessSSLMapCertNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSLMapCert() {
            curObj["AccessSSLMapCert"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSLNegotiateCert() {
            if ((IsAccessSSLNegotiateCertNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSLNegotiateCert() {
            curObj["AccessSSLNegotiateCert"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSLRequireCert() {
            if ((IsAccessSSLRequireCertNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSLRequireCert() {
            curObj["AccessSSLRequireCert"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessWrite() {
            if ((IsAccessWriteNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessWrite() {
            curObj["AccessWrite"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAdminACLBin() {
            curObj["AdminACLBin"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAllowKeepAlive() {
            if ((IsAllowKeepAliveNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAllowKeepAlive() {
            curObj["AllowKeepAlive"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAllowPathInfoForScriptMappings() {
            if ((IsAllowPathInfoForScriptMappingsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAllowPathInfoForScriptMappings() {
            curObj["AllowPathInfoForScriptMappings"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAnonymousPasswordSync() {
            if ((IsAnonymousPasswordSyncNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAnonymousPasswordSync() {
            curObj["AnonymousPasswordSync"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAnonymousUserName() {
            curObj["AnonymousUserName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAnonymousUserPass() {
            curObj["AnonymousUserPass"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppAllowClientDebug() {
            if ((IsAppAllowClientDebugNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppAllowClientDebug() {
            curObj["AppAllowClientDebug"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppAllowDebugging() {
            if ((IsAppAllowDebuggingNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppAllowDebugging() {
            curObj["AppAllowDebugging"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAppFriendlyName() {
            curObj["AppFriendlyName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppOopRecoverLimit() {
            if ((IsAppOopRecoverLimitNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppOopRecoverLimit() {
            curObj["AppOopRecoverLimit"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAppPoolId() {
            curObj["AppPoolId"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAppWamClsid() {
            curObj["AppWamClsid"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspAllowOutOfProcComponents() {
            if ((IsAspAllowOutOfProcComponentsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspAllowOutOfProcComponents() {
            curObj["AspAllowOutOfProcComponents"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspAllowSessionState() {
            if ((IsAspAllowSessionStateNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspAllowSessionState() {
            curObj["AspAllowSessionState"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspAppServiceFlags() {
            if ((IsAspAppServiceFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspAppServiceFlags() {
            curObj["AspAppServiceFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspBufferingLimit() {
            if ((IsAspBufferingLimitNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspBufferingLimit() {
            curObj["AspBufferingLimit"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspBufferingOn() {
            if ((IsAspBufferingOnNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspBufferingOn() {
            curObj["AspBufferingOn"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspCalcLineNumber() {
            if ((IsAspCalcLineNumberNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspCalcLineNumber() {
            curObj["AspCalcLineNumber"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspCodepage() {
            if ((IsAspCodepageNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspCodepage() {
            curObj["AspCodepage"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAspDiskTemplateCacheDirectory() {
            curObj["AspDiskTemplateCacheDirectory"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableApplicationRestart() {
            if ((IsAspEnableApplicationRestartNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableApplicationRestart() {
            curObj["AspEnableApplicationRestart"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableAspHtmlFallback() {
            if ((IsAspEnableAspHtmlFallbackNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableAspHtmlFallback() {
            curObj["AspEnableAspHtmlFallback"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableChunkedEncoding() {
            if ((IsAspEnableChunkedEncodingNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableChunkedEncoding() {
            curObj["AspEnableChunkedEncoding"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableParentPaths() {
            if ((IsAspEnableParentPathsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableParentPaths() {
            curObj["AspEnableParentPaths"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableSxs() {
            if ((IsAspEnableSxsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableSxs() {
            curObj["AspEnableSxs"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableTracker() {
            if ((IsAspEnableTrackerNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableTracker() {
            curObj["AspEnableTracker"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableTypelibCache() {
            if ((IsAspEnableTypelibCacheNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableTypelibCache() {
            curObj["AspEnableTypelibCache"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspErrorsToNTLog() {
            if ((IsAspErrorsToNTLogNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspErrorsToNTLog() {
            curObj["AspErrorsToNTLog"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspExceptionCatchEnable() {
            if ((IsAspExceptionCatchEnableNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspExceptionCatchEnable() {
            curObj["AspExceptionCatchEnable"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspExecuteInMTA() {
            if ((IsAspExecuteInMTANull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspExecuteInMTA() {
            curObj["AspExecuteInMTA"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspKeepSessionIDSecure() {
            if ((IsAspKeepSessionIDSecureNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspKeepSessionIDSecure() {
            curObj["AspKeepSessionIDSecure"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspLCID() {
            if ((IsAspLCIDNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspLCID() {
            curObj["AspLCID"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspLogErrorRequests() {
            if ((IsAspLogErrorRequestsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspLogErrorRequests() {
            curObj["AspLogErrorRequests"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspMaxDiskTemplateCacheFiles() {
            if ((IsAspMaxDiskTemplateCacheFilesNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspMaxDiskTemplateCacheFiles() {
            curObj["AspMaxDiskTemplateCacheFiles"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspMaxRequestEntityAllowed() {
            if ((IsAspMaxRequestEntityAllowedNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspMaxRequestEntityAllowed() {
            curObj["AspMaxRequestEntityAllowed"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAspPartitionID() {
            curObj["AspPartitionID"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspProcessorThreadMax() {
            if ((IsAspProcessorThreadMaxNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspProcessorThreadMax() {
            curObj["AspProcessorThreadMax"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspQueueConnectionTestTime() {
            if ((IsAspQueueConnectionTestTimeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspQueueConnectionTestTime() {
            curObj["AspQueueConnectionTestTime"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspQueueTimeout() {
            if ((IsAspQueueTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspQueueTimeout() {
            curObj["AspQueueTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspRequestQueueMax() {
            if ((IsAspRequestQueueMaxNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspRequestQueueMax() {
            curObj["AspRequestQueueMax"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspRunOnEndAnonymously() {
            if ((IsAspRunOnEndAnonymouslyNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspRunOnEndAnonymously() {
            curObj["AspRunOnEndAnonymously"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspScriptEngineCacheMax() {
            if ((IsAspScriptEngineCacheMaxNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspScriptEngineCacheMax() {
            curObj["AspScriptEngineCacheMax"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAspScriptErrorMessage() {
            curObj["AspScriptErrorMessage"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspScriptErrorSentToBrowser() {
            if ((IsAspScriptErrorSentToBrowserNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspScriptErrorSentToBrowser() {
            curObj["AspScriptErrorSentToBrowser"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspScriptFileCacheSize() {
            if ((IsAspScriptFileCacheSizeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspScriptFileCacheSize() {
            curObj["AspScriptFileCacheSize"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAspScriptLanguage() {
            curObj["AspScriptLanguage"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspScriptTimeout() {
            if ((IsAspScriptTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspScriptTimeout() {
            curObj["AspScriptTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspSessionMax() {
            if ((IsAspSessionMaxNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspSessionMax() {
            curObj["AspSessionMax"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspSessionTimeout() {
            if ((IsAspSessionTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspSessionTimeout() {
            curObj["AspSessionTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAspSxsName() {
            curObj["AspSxsName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspTrackThreadingModel() {
            if ((IsAspTrackThreadingModelNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspTrackThreadingModel() {
            curObj["AspTrackThreadingModel"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspUsePartition() {
            if ((IsAspUsePartitionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspUsePartition() {
            curObj["AspUsePartition"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthAdvNotifyDisable() {
            if ((IsAuthAdvNotifyDisableNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthAdvNotifyDisable() {
            curObj["AuthAdvNotifyDisable"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthAnonymous() {
            if ((IsAuthAnonymousNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthAnonymous() {
            curObj["AuthAnonymous"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthBasic() {
            if ((IsAuthBasicNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthBasic() {
            curObj["AuthBasic"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthChangeDisable() {
            if ((IsAuthChangeDisableNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthChangeDisable() {
            curObj["AuthChangeDisable"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthChangeUnsecure() {
            if ((IsAuthChangeUnsecureNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthChangeUnsecure() {
            curObj["AuthChangeUnsecure"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthFlags() {
            if ((IsAuthFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthFlags() {
            curObj["AuthFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthMD5() {
            if ((IsAuthMD5Null == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthMD5() {
            curObj["AuthMD5"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthNTLM() {
            if ((IsAuthNTLMNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthNTLM() {
            curObj["AuthNTLM"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthPassport() {
            if ((IsAuthPassportNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthPassport() {
            curObj["AuthPassport"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthPersistence() {
            if ((IsAuthPersistenceNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthPersistence() {
            curObj["AuthPersistence"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthPersistSingleRequest() {
            if ((IsAuthPersistSingleRequestNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthPersistSingleRequest() {
            curObj["AuthPersistSingleRequest"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAzEnable() {
            if ((IsAzEnableNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAzEnable() {
            curObj["AzEnable"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAzImpersonationLevel() {
            if ((IsAzImpersonationLevelNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAzImpersonationLevel() {
            curObj["AzImpersonationLevel"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAzScopeName() {
            curObj["AzScopeName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAzStoreName() {
            curObj["AzStoreName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetCacheControlCustom() {
            curObj["CacheControlCustom"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCacheControlMaxAge() {
            if ((IsCacheControlMaxAgeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCacheControlMaxAge() {
            curObj["CacheControlMaxAge"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCacheControlNoCache() {
            if ((IsCacheControlNoCacheNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCacheControlNoCache() {
            curObj["CacheControlNoCache"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCacheISAPI() {
            if ((IsCacheISAPINull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCacheISAPI() {
            curObj["CacheISAPI"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCertCheckMode() {
            if ((IsCertCheckModeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCertCheckMode() {
            curObj["CertCheckMode"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCGITimeout() {
            if ((IsCGITimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCGITimeout() {
            curObj["CGITimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeClusterEnabled() {
            if ((IsClusterEnabledNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetClusterEnabled() {
            curObj["ClusterEnabled"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeConnectionTimeout() {
            if ((IsConnectionTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetConnectionTimeout() {
            curObj["ConnectionTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeContentIndexed() {
            if ((IsContentIndexedNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetContentIndexed() {
            curObj["ContentIndexed"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCreateCGIWithNewConsole() {
            if ((IsCreateCGIWithNewConsoleNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCreateCGIWithNewConsole() {
            curObj["CreateCGIWithNewConsole"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCreateProcessAsUser() {
            if ((IsCreateProcessAsUserNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCreateProcessAsUser() {
            curObj["CreateProcessAsUser"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetDefaultDoc() {
            curObj["DefaultDoc"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetDefaultDocFooter() {
            curObj["DefaultDocFooter"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetDefaultLogonDomain() {
            curObj["DefaultLogonDomain"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDirBrowseFlags() {
            if ((IsDirBrowseFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDirBrowseFlags() {
            curObj["DirBrowseFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDirBrowseShowDate() {
            if ((IsDirBrowseShowDateNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDirBrowseShowDate() {
            curObj["DirBrowseShowDate"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDirBrowseShowExtension() {
            if ((IsDirBrowseShowExtensionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDirBrowseShowExtension() {
            curObj["DirBrowseShowExtension"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDirBrowseShowLongDate() {
            if ((IsDirBrowseShowLongDateNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDirBrowseShowLongDate() {
            curObj["DirBrowseShowLongDate"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDirBrowseShowSize() {
            if ((IsDirBrowseShowSizeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDirBrowseShowSize() {
            curObj["DirBrowseShowSize"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDirBrowseShowTime() {
            if ((IsDirBrowseShowTimeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDirBrowseShowTime() {
            curObj["DirBrowseShowTime"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDisableSocketPooling() {
            if ((IsDisableSocketPoolingNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDisableSocketPooling() {
            curObj["DisableSocketPooling"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDisableStaticFileCache() {
            if ((IsDisableStaticFileCacheNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDisableStaticFileCache() {
            curObj["DisableStaticFileCache"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDoDynamicCompression() {
            if ((IsDoDynamicCompressionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDoDynamicCompression() {
            curObj["DoDynamicCompression"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDontLog() {
            if ((IsDontLogNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDontLog() {
            curObj["DontLog"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDoStaticCompression() {
            if ((IsDoStaticCompressionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDoStaticCompression() {
            curObj["DoStaticCompression"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeEnableDefaultDoc() {
            if ((IsEnableDefaultDocNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetEnableDefaultDoc() {
            curObj["EnableDefaultDoc"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeEnableDirBrowsing() {
            if ((IsEnableDirBrowsingNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetEnableDirBrowsing() {
            curObj["EnableDirBrowsing"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeEnableDocFooter() {
            if ((IsEnableDocFooterNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetEnableDocFooter() {
            curObj["EnableDocFooter"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeEnableReverseDns() {
            if ((IsEnableReverseDnsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetEnableReverseDns() {
            curObj["EnableReverseDns"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeFrontPageWeb() {
            if ((IsFrontPageWebNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetFrontPageWeb() {
            curObj["FrontPageWeb"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetHttpCustomHeaders() {
            curObj["HttpCustomHeaders"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetHttpErrors() {
            curObj["HttpErrors"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetHttpExpires() {
            curObj["HttpExpires"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetHttpPics() {
            curObj["HttpPics"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileBytesRecv() {
            if ((IsLogExtFileBytesRecvNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileBytesRecv() {
            curObj["LogExtFileBytesRecv"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileBytesSent() {
            if ((IsLogExtFileBytesSentNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileBytesSent() {
            curObj["LogExtFileBytesSent"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileClientIp() {
            if ((IsLogExtFileClientIpNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileClientIp() {
            curObj["LogExtFileClientIp"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileComputerName() {
            if ((IsLogExtFileComputerNameNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileComputerName() {
            curObj["LogExtFileComputerName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileCookie() {
            if ((IsLogExtFileCookieNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileCookie() {
            curObj["LogExtFileCookie"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileDate() {
            if ((IsLogExtFileDateNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileDate() {
            curObj["LogExtFileDate"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileFlags() {
            if ((IsLogExtFileFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileFlags() {
            curObj["LogExtFileFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileHost() {
            if ((IsLogExtFileHostNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileHost() {
            curObj["LogExtFileHost"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileHttpStatus() {
            if ((IsLogExtFileHttpStatusNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileHttpStatus() {
            curObj["LogExtFileHttpStatus"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileHttpSubStatus() {
            if ((IsLogExtFileHttpSubStatusNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileHttpSubStatus() {
            curObj["LogExtFileHttpSubStatus"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileMethod() {
            if ((IsLogExtFileMethodNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileMethod() {
            curObj["LogExtFileMethod"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileProtocolVersion() {
            if ((IsLogExtFileProtocolVersionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileProtocolVersion() {
            curObj["LogExtFileProtocolVersion"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileReferer() {
            if ((IsLogExtFileRefererNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileReferer() {
            curObj["LogExtFileReferer"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileServerIp() {
            if ((IsLogExtFileServerIpNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileServerIp() {
            curObj["LogExtFileServerIp"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileServerPort() {
            if ((IsLogExtFileServerPortNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileServerPort() {
            curObj["LogExtFileServerPort"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileSiteName() {
            if ((IsLogExtFileSiteNameNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileSiteName() {
            curObj["LogExtFileSiteName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileTime() {
            if ((IsLogExtFileTimeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileTime() {
            curObj["LogExtFileTime"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileTimeTaken() {
            if ((IsLogExtFileTimeTakenNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileTimeTaken() {
            curObj["LogExtFileTimeTaken"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileUriQuery() {
            if ((IsLogExtFileUriQueryNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileUriQuery() {
            curObj["LogExtFileUriQuery"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileUriStem() {
            if ((IsLogExtFileUriStemNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileUriStem() {
            curObj["LogExtFileUriStem"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileUserAgent() {
            if ((IsLogExtFileUserAgentNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileUserAgent() {
            curObj["LogExtFileUserAgent"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileUserName() {
            if ((IsLogExtFileUserNameNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileUserName() {
            curObj["LogExtFileUserName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileWin32Status() {
            if ((IsLogExtFileWin32StatusNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileWin32Status() {
            curObj["LogExtFileWin32Status"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetLogFileDirectory() {
            curObj["LogFileDirectory"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogFileLocaltimeRollover() {
            if ((IsLogFileLocaltimeRolloverNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogFileLocaltimeRollover() {
            curObj["LogFileLocaltimeRollover"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogFilePeriod() {
            if ((IsLogFilePeriodNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogFilePeriod() {
            curObj["LogFilePeriod"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogFileTruncateSize() {
            if ((IsLogFileTruncateSizeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogFileTruncateSize() {
            curObj["LogFileTruncateSize"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetLogOdbcDataSource() {
            curObj["LogOdbcDataSource"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetLogOdbcPassword() {
            curObj["LogOdbcPassword"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetLogOdbcTableName() {
            curObj["LogOdbcTableName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetLogOdbcUserName() {
            curObj["LogOdbcUserName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogonMethod() {
            if ((IsLogonMethodNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogonMethod() {
            curObj["LogonMethod"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetLogPluginClsid() {
            curObj["LogPluginClsid"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogType() {
            if ((IsLogTypeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogType() {
            curObj["LogType"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxBandwidth() {
            if ((IsMaxBandwidthNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxBandwidth() {
            curObj["MaxBandwidth"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxBandwidthBlocked() {
            if ((IsMaxBandwidthBlockedNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxBandwidthBlocked() {
            curObj["MaxBandwidthBlocked"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxConnections() {
            if ((IsMaxConnectionsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxConnections() {
            curObj["MaxConnections"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxEndpointConnections() {
            if ((IsMaxEndpointConnectionsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxEndpointConnections() {
            curObj["MaxEndpointConnections"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxRequestEntityAllowed() {
            if ((IsMaxRequestEntityAllowedNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxRequestEntityAllowed() {
            curObj["MaxRequestEntityAllowed"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetMimeMap() {
            curObj["MimeMap"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetNTAuthenticationProviders() {
            curObj["NTAuthenticationProviders"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePassportRequireADMapping() {
            if ((IsPassportRequireADMappingNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPassportRequireADMapping() {
            curObj["PassportRequireADMapping"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePasswordCacheTTL() {
            if ((IsPasswordCacheTTLNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPasswordCacheTTL() {
            curObj["PasswordCacheTTL"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePasswordChangeFlags() {
            if ((IsPasswordChangeFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPasswordChangeFlags() {
            curObj["PasswordChangeFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePasswordExpirePrenotifyDays() {
            if ((IsPasswordExpirePrenotifyDaysNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPasswordExpirePrenotifyDays() {
            curObj["PasswordExpirePrenotifyDays"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePoolIdcTimeout() {
            if ((IsPoolIdcTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPoolIdcTimeout() {
            curObj["PoolIdcTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeProcessNTCRIfLoggedOn() {
            if ((IsProcessNTCRIfLoggedOnNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetProcessNTCRIfLoggedOn() {
            curObj["ProcessNTCRIfLoggedOn"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetRealm() {
            curObj["Realm"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetRedirectHeaders() {
            curObj["RedirectHeaders"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeRevocationFreshnessTime() {
            if ((IsRevocationFreshnessTimeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetRevocationFreshnessTime() {
            curObj["RevocationFreshnessTime"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeRevocationURLRetrievalTimeout() {
            if ((IsRevocationURLRetrievalTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetRevocationURLRetrievalTimeout() {
            curObj["RevocationURLRetrievalTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetScriptMaps() {
            curObj["ScriptMaps"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetSecureBindings() {
            curObj["SecureBindings"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeServerAutoStart() {
            if ((IsServerAutoStartNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetServerAutoStart() {
            curObj["ServerAutoStart"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetServerBindings() {
            curObj["ServerBindings"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeServerCommand() {
            if ((IsServerCommandNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetServerCommand() {
            curObj["ServerCommand"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetServerComment() {
            curObj["ServerComment"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetServerID() {
            curObj["ServerID"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeServerListenBacklog() {
            if ((IsServerListenBacklogNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetServerListenBacklog() {
            curObj["ServerListenBacklog"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeServerListenTimeout() {
            if ((IsServerListenTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetServerListenTimeout() {
            curObj["ServerListenTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeServerSize() {
            if ((IsServerSizeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetServerSize() {
            curObj["ServerSize"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetSetHostName() {
            curObj["SetHostName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeShutdownTimeLimit() {
            if ((IsShutdownTimeLimitNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetShutdownTimeLimit() {
            curObj["ShutdownTimeLimit"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSSIExecDisable() {
            if ((IsSSIExecDisableNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSSIExecDisable() {
            curObj["SSIExecDisable"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSSLAlwaysNegoClientCert() {
            if ((IsSSLAlwaysNegoClientCertNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSSLAlwaysNegoClientCert() {
            curObj["SSLAlwaysNegoClientCert"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetSslCtlIdentifier() {
            curObj["SslCtlIdentifier"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetSslCtlStoreName() {
            curObj["SslCtlStoreName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetSSLStoreName() {
            curObj["SSLStoreName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetTraceUriPrefix() {
            curObj["TraceUriPrefix"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeUploadReadAheadSize() {
            if ((IsUploadReadAheadSizeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetUploadReadAheadSize() {
            curObj["UploadReadAheadSize"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeUseDigestSSP() {
            if ((IsUseDigestSSPNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetUseDigestSSP() {
            curObj["UseDigestSSP"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeUseHostName() {
            if ((IsUseHostNameNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetUseHostName() {
            curObj["UseHostName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeWebDAVMaxAttributesPerElement() {
            if ((IsWebDAVMaxAttributesPerElementNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetWebDAVMaxAttributesPerElement() {
            curObj["WebDAVMaxAttributesPerElement"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeWin32Error() {
            if ((IsWin32ErrorNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetWin32Error() {
            curObj["Win32Error"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        [Browsable(true)]
        public void CommitObject() {
            if ((isEmbedded == false)) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private static string ConstructPath(string keyName) {
            string strPath = "ROOT\\MicrosoftIISv2:IIsWebServerSetting";
            strPath = (strPath 
                        + (".Name=" 
                        + ("\"" 
                        + (keyName + "\""))));
            return strPath;
        }
        
        // Different overloads of GetInstances() help in enumerating instances of the WMI class.
        public static IIsWebServerSettingCollection GetInstances() {
            return GetInstances(((System.Management.ManagementScope)(null)), ((System.Management.EnumerationOptions)(null)));
        }
        
        public static IIsWebServerSettingCollection GetInstances(string condition) {
            return GetInstances(null, condition, null);
        }
        
        public static IIsWebServerSettingCollection GetInstances(System.String [] selectedProperties) {
            return GetInstances(null, null, selectedProperties);
        }
        
        public static IIsWebServerSettingCollection GetInstances(string condition, System.String [] selectedProperties) {
            return GetInstances(null, condition, selectedProperties);
        }
        
        public static IIsWebServerSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, System.Management.EnumerationOptions enumOptions) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementPath pathObj = new System.Management.ManagementPath();
            pathObj.ClassName = "IIsWebServerSetting";
            pathObj.NamespacePath = "root\\MicrosoftIISv2";
            System.Management.ManagementClass clsObject = new System.Management.ManagementClass(mgmtScope, pathObj, null);
            if ((enumOptions == null)) {
                enumOptions = new System.Management.EnumerationOptions();
                enumOptions.EnsureLocatable = true;
            }
            return new IIsWebServerSettingCollection(clsObject.GetInstances(enumOptions));
        }
        
        public static IIsWebServerSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition) {
            return GetInstances(mgmtScope, condition, null);
        }
        
        public static IIsWebServerSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, System.String [] selectedProperties) {
            return GetInstances(mgmtScope, null, selectedProperties);
        }
        
        public static IIsWebServerSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition, System.String [] selectedProperties) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementObjectSearcher ObjectSearcher = new System.Management.ManagementObjectSearcher(mgmtScope, new SelectQuery("IIsWebServerSetting", condition, selectedProperties));
            System.Management.EnumerationOptions enumOptions = new System.Management.EnumerationOptions();
            enumOptions.EnsureLocatable = true;
            ObjectSearcher.Options = enumOptions;
            return new IIsWebServerSettingCollection(ObjectSearcher.Get());
        }
        
        [Browsable(true)]
        public static IIsWebServerSetting CreateInstance() {
            System.Management.ManagementScope mgmtScope = null;
            if ((statMgmtScope == null)) {
                mgmtScope = new System.Management.ManagementScope();
                mgmtScope.Path.NamespacePath = CreatedWmiNamespace;
            }
            else {
                mgmtScope = statMgmtScope;
            }
            System.Management.ManagementPath mgmtPath = new System.Management.ManagementPath(CreatedClassName);
            return new IIsWebServerSetting(new System.Management.ManagementClass(mgmtScope, mgmtPath, null).CreateInstance());
        }
        
        [Browsable(true)]
        public void Delete() {
            PrivateLateBoundObject.Delete();
        }
        
        // Enumerator implementation for enumerating instances of the class.
        public class IIsWebServerSettingCollection : object, ICollection {
            
            private ManagementObjectCollection ObjectCollection;
            
            public IIsWebServerSettingCollection(ManagementObjectCollection objCollection) {
                ObjectCollection = objCollection;
            }
            
            public int Count {
                get {
                    return ObjectCollection.Count;
                }
            }
            
            public bool IsSynchronized {
                get {
                    return ObjectCollection.IsSynchronized;
                }
            }
            
            public object SyncRoot {
                get {
                    return this;
                }
            }
            
            public void CopyTo(System.Array array, int index) {
                ObjectCollection.CopyTo(array, index);
                int nCtr;
                for (nCtr = 0; (nCtr < array.Length); nCtr = (nCtr + 1)) {
                    array.SetValue(new IIsWebServerSetting(((System.Management.ManagementObject)(array.GetValue(nCtr)))), nCtr);
                }
            }
            
            public System.Collections.IEnumerator GetEnumerator() {
                return new IIsWebServerSettingEnumerator(ObjectCollection.GetEnumerator());
            }
            
            public class IIsWebServerSettingEnumerator : object, System.Collections.IEnumerator {
                
                private ManagementObjectCollection.ManagementObjectEnumerator ObjectEnumerator;
                
                public IIsWebServerSettingEnumerator(ManagementObjectCollection.ManagementObjectEnumerator objEnum) {
                    ObjectEnumerator = objEnum;
                }
                
                public object Current {
                    get {
                        return new IIsWebServerSetting(((System.Management.ManagementObject)(ObjectEnumerator.Current)));
                    }
                }
                
                public bool MoveNext() {
                    return ObjectEnumerator.MoveNext();
                }
                
                public void Reset() {
                    ObjectEnumerator.Reset();
                }
            }
        }
        
        // TypeConverter to handle null values for ValueType properties
        public class WMIValueTypeConverter : TypeConverter {
            
            private TypeConverter baseConverter;
            
            public WMIValueTypeConverter(System.Type baseType) {
                baseConverter = TypeDescriptor.GetConverter(baseType);
            }
            
            public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Type srcType) {
                return baseConverter.CanConvertFrom(context, srcType);
            }
            
            public override bool CanConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Type destinationType) {
                return baseConverter.CanConvertTo(context, destinationType);
            }
            
            public override object ConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value) {
                return baseConverter.ConvertFrom(context, culture, value);
            }
            
            public override object CreateInstance(System.ComponentModel.ITypeDescriptorContext context, System.Collections.IDictionary dictionary) {
                return baseConverter.CreateInstance(context, dictionary);
            }
            
            public override bool GetCreateInstanceSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetCreateInstanceSupported(context);
            }
            
            public override PropertyDescriptorCollection GetProperties(System.ComponentModel.ITypeDescriptorContext context, object value, System.Attribute[] attributeVar) {
                return baseConverter.GetProperties(context, value, attributeVar);
            }
            
            public override bool GetPropertiesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetPropertiesSupported(context);
            }
            
            public override System.ComponentModel.TypeConverter.StandardValuesCollection GetStandardValues(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValues(context);
            }
            
            public override bool GetStandardValuesExclusive(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesExclusive(context);
            }
            
            public override bool GetStandardValuesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesSupported(context);
            }
            
            public override object ConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, System.Type destinationType) {
                if ((context != null)) {
                    if ((context.PropertyDescriptor.ShouldSerializeValue(context.Instance) == false)) {
                        return "";
                    }
                }
                return baseConverter.ConvertTo(context, culture, value, destinationType);
            }
        }
        
        // Embedded class to represent WMI system Properties.
        [TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))]
        public class ManagementSystemProperties {
            
            private System.Management.ManagementBaseObject PrivateLateBoundObject;
            
            public ManagementSystemProperties(System.Management.ManagementBaseObject ManagedObject) {
                PrivateLateBoundObject = ManagedObject;
            }
            
            [Browsable(true)]
            public int GENUS {
                get {
                    return ((int)(PrivateLateBoundObject["__GENUS"]));
                }
            }
            
            [Browsable(true)]
            public string CLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__CLASS"]));
                }
            }
            
            [Browsable(true)]
            public string SUPERCLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__SUPERCLASS"]));
                }
            }
            
            [Browsable(true)]
            public string DYNASTY {
                get {
                    return ((string)(PrivateLateBoundObject["__DYNASTY"]));
                }
            }
            
            [Browsable(true)]
            public string RELPATH {
                get {
                    return ((string)(PrivateLateBoundObject["__RELPATH"]));
                }
            }
            
            [Browsable(true)]
            public int PROPERTY_COUNT {
                get {
                    return ((int)(PrivateLateBoundObject["__PROPERTY_COUNT"]));
                }
            }
            
            [Browsable(true)]
            public string[] DERIVATION {
                get {
                    return ((string[])(PrivateLateBoundObject["__DERIVATION"]));
                }
            }
            
            [Browsable(true)]
            public string SERVER {
                get {
                    return ((string)(PrivateLateBoundObject["__SERVER"]));
                }
            }
            
            [Browsable(true)]
            public string NAMESPACE {
                get {
                    return ((string)(PrivateLateBoundObject["__NAMESPACE"]));
                }
            }
            
            [Browsable(true)]
            public string PATH {
                get {
                    return ((string)(PrivateLateBoundObject["__PATH"]));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\WstRunner\Log.cs ===
/*******************************************************************
 *    FILE:         Log.cs
 *
 *    DESCRIPTION:  
 *
 *    OWNER:        gamagev
 *
 *    HISTORY:      04/08/2004      gamagev    Created
 *
 *    Copyright <cp> 2004 Microsoft Corporation.  All Rights Reserved.
 ********************************************************************
 */
using System;
using System.Text;

namespace xonline.tools.wstrunner.core
{
    public enum LogLevel
    {
        Error = 0,
        Warning = 1,
        Info = 2,
        Verbose = 3
    }

    /// <summary>
    /// Summary description for Log.
    /// </summary>
    public sealed class Log
    {
        private LogLevel _verbosity = LogLevel.Error;

        Log() 
        {
        }

        /// <summary>
        /// Need to make sure we have closed our file when we are finilized
        /// </summary>
        ~Log()
        {
        }

        public event EventHandler<LoggingEventArgs> OnMessage;

        public LogLevel Verbosity
        {
            get { return _verbosity; }
            set { _verbosity = value; }
        }

        /// <summary>
        /// Contains the static instance of us. This way is both 
        /// thread safe and lazy load.
        /// </summary>
        class InternalLogClass
        {
            InternalLogClass()
            {
            }

            internal static readonly Log instance = new Log();    
        }
        
        /// <summary>
        /// We are a singelton so this is the only way to get 
        /// an instance
        /// </summary>
        /// <returns>The singelton Log object</returns>
        public static Log GetInstance()
        {
            return InternalLogClass.instance;
        }

        public void Message(LogLevel level, string message)
        {
            //Trim Message to MaxEvent Log message size
            if (message.Length > 32000)
            {
                message = "Trimmed Message : " + message.Substring(0, 10000);
            }


            if (_verbosity >= level)
            {
                OnMessage(this, new LoggingEventArgs(level, message));
            }
        }
        public void Message(LogLevel level, string message, params Object[] args)
        {
            StringBuilder msg = new StringBuilder();
            msg.AppendFormat(message, args);

            Message(level, msg.ToString());        
        }

        public void WriteLine(string message)
        {
            Message(LogLevel.Verbose, message + "\r\n");           
        }

        public void WriteLine(string message, params Object[] args)
        {
            StringBuilder msg = new StringBuilder();
            msg.AppendFormat(message, args);

            WriteLine(msg.ToString());        
        }

        public void Write(string message)
        {
            Message(LogLevel.Verbose, message);
        }

        public void Write(string message, params Object[] args)
        {
            StringBuilder msg = new StringBuilder();
            msg.AppendFormat(message, args);

            Write(msg.ToString());        
        }
       

        public void Error(string message, params Object[] args)
        {
            StringBuilder msg = new StringBuilder();
            msg.AppendFormat(message, args);

            Error(msg.ToString());        
        }

        public void Error(string errorMessage)
        {
            Message(LogLevel.Error, errorMessage);
        }

        //public void Error(bool color, string errorMessage)
        //{
        //    if (color)
        //        ConsoleColor.SetForeGroundColor(ConsoleColor.ForeGroundColor.Red, true);

        //    Console.WriteLine(errorMessage);
        //    if (logStream != null)
        //        logStream.WriteLine(errorMessage);
 
        //    if (color)
        //        ConsoleColor.SetToDefaultForeGroundColor();
        //}

        //public void xmlValidationError(string errorMessage)
        //{
        //    ConsoleColor.SetForeGroundColor(ConsoleColor.ForeGroundColor.Red, true);
            
        //    Console.WriteLine("\nXML Validation Error");
        //    if (logStream != null)
        //        logStream.WriteLine("\nXML Validation Error");
            
        //    ConsoleColor.SetToDefaultForeGroundColor();
            
        //    Console.WriteLine("\nDetail: \n\t" + errorMessage);
        //    if (logStream != null)
        //        logStream.WriteLine("\nDetail: \n\t" + errorMessage);
        //}


    }

    /// <summary>
    /// 
    /// </summary>
    public class LoggingEventArgs : EventArgs
    {
        private readonly string _message;
        private readonly LogLevel _level;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="level">
        /// </param>
        /// <param name="message"></param>
        public LoggingEventArgs(LogLevel level, string message)
        {
            _level = level;
            _message = message;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Message
        {
            get { return _message; }
        }

        public LogLevel Level
        {
            get { return _level; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\WstRunner\temp.cs ===
using System;
using System.IO;
using System.Reflection;
using System.Text;

namespace xonline.tools.wstrunner.core
{
    /// <summary>
    /// Summary description for Class1
    /// </summary>
    public class Temp
    {
        private readonly DirectoryInfo _directory;

        public Temp()
            : this(String.Empty)
        {
        }

        public Temp(string SubDirectoryName)
        {
            if (SubDirectoryName.Length == 0)
            {
                DateTime time = DateTime.Now;
                _directory = new DirectoryInfo(Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), time.ToString("yyyy-MM-dd_HH.mm.ss")));
            }
            else
                _directory = new DirectoryInfo(Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), SubDirectoryName));

            if (!_directory.Exists)
            {
                _directory.Create();
                _directory.Refresh();
            }
        }

        public DirectoryInfo Directory
        {
            get
            { return _directory; }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public string GetTempFileName()
        {
            return GetTempFileName("log");
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="extension"></param>
        /// <returns></returns>
        public string GetTempFileName(string extension)
        {
            StringBuilder fileName = new StringBuilder();
            DateTime time = DateTime.Now;

            fileName.AppendFormat("{0}\\{1}_{2}.{3}"
                , _directory.FullName
                , _directory.Name
                , time.ToString("yyyy-MM-dd_HH.mm.ss")
                , extension);

            return fileName.ToString();
        }

        public string GetTempFileName(string prefix, string extension)
        {
            string filePrefix;

            StringBuilder fileName = new StringBuilder();
            DateTime time = DateTime.Now;

            if (prefix == null)
                filePrefix = _directory.Name;
            else
                filePrefix = prefix;

            fileName.AppendFormat("{0}\\{1}_{2}.{3}"
                , _directory.FullName
                , filePrefix
                , time.ToString("yyyy-MM-dd_HH.mm.ss")
                , extension);

            return fileName.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\WstRunner\WmoFailSafeSet.cs ===
/*******************************************************************
 *    FILE:         WmoFailSafeSet.cs
 *
 *    DESCRIPTION:  IFailSafeSet wrapper for WmoCommandFailSafeSet class.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      7-18-2008   - Created 
 *
 *    Copyright <cp> 2008 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

using System;
using Microsoft.Webstore.Common;
using Microsoft.Webstore.Management.Wmo;

namespace xonline.tools.wstrunner.core
{
    public class WmoFailSafeSetFactory : IFailSafeSetFactory
    {
        public BaseFailSafeSet CreateInstance()
        {
            return WmoFailSafeSet.CreateInstance();
        }
    }
    
    public abstract class BaseFailSafeSet : IFailSafeSet
    {
        #region IFailSafeSet Members

        public abstract string DeploymentName { get; set; }
        public abstract int SQLFSSNum { get; set; }

        public abstract void Demote();
        public abstract void Offline();
        public abstract void DropRepl();

        #endregion
    }

    /// <summary>
    /// Wrap the WmoCommandDatabase class in a pass-through interface layer 
    /// for the purpose of mocking this in unit tests.
    /// </summary>
    public class WmoFailSafeSet : BaseFailSafeSet
    {
        private readonly WmoCommandFailSafeSet wmoFailSafeSet = new WmoCommandFailSafeSet();
        private string deploymentName;
        private int sqlFSSNum;
        private readonly Log log = Log.GetInstance();

        public static WmoFailSafeSet CreateInstance()
        {
            return new WmoFailSafeSet();
        }

        private WmoFailSafeSet()
        {
            wmoFailSafeSet.WmoStatusEvent += StatusEventHandler;
        }

        //  Properties

        //  Methods

        public void StatusEventHandler(Object sender, WmoStatusEventArgs eventArgs)
        {
            log.WriteLine(string.Format("{0}", eventArgs));
        }

        // IDatabase

        public override string DeploymentName
        {
            get
            {
                return deploymentName;
            }
            set
            {
                deploymentName = value;
            }
        }

        public override int SQLFSSNum
        {
            get
            {
                return sqlFSSNum;
            }
            set
            {
                sqlFSSNum = value;
            }
        }

        public override void Demote()
        {
            wmoFailSafeSet.DeploymentName = deploymentName;
            wmoFailSafeSet.SQLFSSNum = sqlFSSNum;
            wmoFailSafeSet.Demote();
        }

        public override void Offline()
        {
            wmoFailSafeSet.DeploymentName = deploymentName;
            wmoFailSafeSet.SQLFSSNum = sqlFSSNum;
            wmoFailSafeSet.Offline();
        }

        public override void DropRepl()
        {
            wmoFailSafeSet.DeploymentName = deploymentName;
            wmoFailSafeSet.SQLFSSNum = sqlFSSNum;
            wmoFailSafeSet.DropRepl();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\WstRunner\WstRunner.cs ===
/*******************************************************************
 *    FILE:         WstRunner.cs
 *
 *    DESCRIPTION:  Main WstRunner class.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      10-22-2007   - Created 
 *
 *    Copyright <cp> 2007 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

using Microsoft.SqlServer.Management.Smo;
using Microsoft.SqlServer.Management.Smo.Agent;
using System;
using System.Collections.Generic;
using System.IO;
using Microsoft.Webstore.MetaData;
using Microsoft.Webstore.WstClient;
using System.Threading;

namespace xonline.tools.wstrunner.core
{
    /// <summary>
    /// Provides the entry point for the WstRunner components.
    /// </summary>
    /// <remarks>
    ///  
    ///</remarks>
    public class WstRunner : IWstRunner
    {
        #region Members

        private readonly string _workingPath;
        private readonly string _manifestFile;
        private readonly string _deploymentFile;
        private readonly Log _log = Log.GetInstance();
        private IOracleFactory oracleFactory = new WebstoreOracleFactory();
        private IManifestFactory manifestFactory = new WmoManifestFactory();
        private IDeploymentFactory deploymentFactory = new WmoDeploymentFactory();
        private IDatabaseTemplateFactory databaseTemplateFactory = new WmoDatabaseTemplateFactory();
        private IFailSafeSetFactory failSafeSetFactory = new WmoFailSafeSetFactory();

        public enum SetupAction
        {
            None,
            Install,
            Upgrade
        } ;

        #endregion

        #region Constructors

        public static WstRunner CreateInstance(
            string workingPath,
            string manifestFile,
            string deploymentFile
            )
        {
            return new WstRunner(workingPath, manifestFile, deploymentFile);
        }

        /// <summary>
        /// Initializes a new instance of the WstRunner class.
        /// </summary>
        /// <param name="workingPath">
        /// The path to the directory that will be used as the base directory 
        /// for any relative paths to files defined in the manifest.  Passing 
        /// null or an empty string will result in an ArgumentNullException
        /// being thrown.  It is expected that this directory contains the
        /// manifest file and all .sql files that comprise this webstore
        /// application.  The webstore deployment file will be generated in
        /// this directory as well.
        /// </param>
        /// <param name="manifestFile">
        /// The name of the manifest file, sans path information.  This file
        /// must exist in workingPath, as must all files referenced by the
        /// manifest file.
        /// </param>
        /// <param name="deploymentFile">
        /// The name of the deployment file, sans path information.  This file
        /// must exist in workingPath.
        /// </param>
        /// <exception cref="ArgumentNullException">
        /// One of the arguments passed
        /// was null.
        /// </exception>
        private WstRunner(
            string workingPath,
            string manifestFile,
            string deploymentFile
            )
        {
            //
            //  Working path validation
            //

            if (string.IsNullOrEmpty(workingPath))
            {
                throw new ArgumentNullException("workingPath");
            }

            workingPath = workingPath.Trim();

            if (Path.GetExtension(workingPath) != String.Empty)
            {
                throw new ArgumentException("Filename passed in for working directory.", workingPath);
            }

            if (!Directory.Exists(workingPath))
            {
                throw new DirectoryNotFoundException("Directory not found: \"" + workingPath + "\"");
            }

            //
            //  Manifest file validation.
            //

            if (string.IsNullOrEmpty(manifestFile))
            {
                throw new ArgumentNullException("manifestFile");
            }

            if (Path.GetDirectoryName(manifestFile) != String.Empty)
            {
                throw new ArgumentException("The manifestFile parameter must not contain path information.", manifestFile);
            }

            if (!File.Exists(Path.Combine(workingPath, manifestFile)))
            {
                throw new FileNotFoundException("File not found: \"" + Path.Combine(workingPath, manifestFile));
            }

            //
            //  Deployment file validation
            //

            if (string.IsNullOrEmpty(deploymentFile))
            {
                throw new ArgumentNullException("deploymentFile");
            }

            if (Path.GetDirectoryName(deploymentFile) != String.Empty)
            {
                throw new ArgumentException("The deploymentFile parameter must not contain path information.", deploymentFile);
            }

            if (!File.Exists(Path.Combine(workingPath, deploymentFile)))
            {
                throw new FileNotFoundException("File not found: \"" + Path.Combine(workingPath, deploymentFile));
            }

            //
            //  Save values.
            //

            _workingPath = workingPath;
            _manifestFile = Path.Combine(workingPath, manifestFile);
            _deploymentFile = Path.Combine(workingPath, deploymentFile);
        }

        #endregion

        #region Properties

        /// <summary>
        /// The path to the directory that will be used as the base directory 
        /// for any relative paths to files defined in children steps.
        /// </summary>
        /// <remarks>
        /// Setting this property to null or an empty string will default this
        /// property to the current working directory.  If the path contains a
        /// file, the file name will be removed from the path and the directory
        /// containing the passed file will be used as the working path.       
        /// </remarks>
        /// <exception cref="ArgumentException">
        /// The WorkingPath was set to a value containing characters that are 
        /// not valid in a path specification
        /// </exception>
        /// <exception cref="FileNotFoundException">
        /// An attempt was made to set the WorkingPath to a non-existant 
        /// directory.
        /// </exception>
        public string WorkingPath
        {
            get { return _workingPath; }
        }

        public string ManifestFile
        {
            get { return _manifestFile; }
        }

        public string DeploymentFile
        {
            get { return _deploymentFile; }
        }
        public IManifestFactory ManifestFactory
        {
            set { manifestFactory = value; }
        }

        public IDeploymentFactory DeploymentFactory
        {
            set { deploymentFactory = value; }
        }

        public IFailSafeSetFactory FailSafeSetFactory
        {
            set { failSafeSetFactory = value; }
        }

        public IDatabaseTemplateFactory DatabaseTemplateFactory
        {
            set { databaseTemplateFactory = value; }
        }

        public IOracleFactory OracleFactory
        {
            set { oracleFactory = value; }
        }

        #endregion

        #region Methods

        private SetupAction GetSetupAction()
        {
            SetupAction action;

            BaseManifest wmoManifest = manifestFactory.CreateInstance();
            IOracle oracle = oracleFactory.CreateInstance();
            Manifest manifest = new Manifest(wmoManifest, oracle, _manifestFile);
            _log.WriteLine(string.Format("Loaded version {0} of manifest \"{1}\" from \"{2}\".", manifest.Version, manifest.Name, _manifestFile));

            if (oracle.IsManifestImported(manifest.Name, manifest.Version))
            {
                action = SetupAction.None;
            }
            else if (oracle.IsManifestImported(manifest.Name))
            {
                action = SetupAction.Upgrade;
            }
            else
            {
                action = SetupAction.Install;
            }

            return action;
        }

        /// <summary>
        /// This method will do an add or upgrade as appropriate, based on the
        /// manifest provided.
        /// </summary>
        public void Setup(SetupAction sAction, bool isRollingUpgrade, bool replTearDown)
        {
            switch (sAction)
            {
                case SetupAction.Install:
                    _log.WriteLine("Performing initial database installation.");
                    Add();
                    _log.WriteLine("Installation complete.");
                    break;

                case SetupAction.Upgrade:
                    _log.WriteLine("Detected existing database installation with lower version, proceeding with upgrade.");
                    Upgrade(isRollingUpgrade, replTearDown);
                    _log.WriteLine("Upgrade complete.");
                    break;

                case SetupAction.None:
                    _log.WriteLine("Detected existing database installation with current version, no action required.");
                    break;
            }
        }
        /// <summary>
        /// Repairs the primary first and then the secondary
        /// </summary>
        /// <returns></returns>
        protected void Repair(Database db,bool isForce)
        {
            
            WmoDatabase wmoDatabase = WmoDatabase.CreateInstance();
            wmoDatabase.Database = db.Name;
            wmoDatabase.Server = db.Server;
            wmoDatabase.Repair(isForce);
           
        }
        protected void Online(Database db)
        {
          
            WmoDatabase wmoDatabase = WmoDatabase.CreateInstance();
            wmoDatabase.Database = db.Name;
            wmoDatabase.Server = db.Server;
            wmoDatabase.MarkOnline();
         
        }
        /// <summary>
        /// Promotes the Database
        /// </summary>
        /// <param name="db"></param>
        protected void Promote(Database db)
        {
            WmoDatabase wmoDatabase = WmoDatabase.CreateInstance();
            wmoDatabase.Database = db.Name;
            wmoDatabase.Server = db.Server;
            wmoDatabase.Promote();
        }

        private List<Database> GetDeploymentDatabases(string dbIdentifier)
        {
            IOracle oracle = oracleFactory.CreateInstance();
            List<Database> databases;
            BaseDeployment wmoDeployment = deploymentFactory.CreateInstance();
            BaseDatabaseTemplate wmoDatabaseTemplate = databaseTemplateFactory.CreateInstance();
            Deployment deployment = new Deployment(wmoDeployment, wmoDatabaseTemplate, oracle, _deploymentFile);
            switch (dbIdentifier)
            {
                case "pri":
                    databases= deployment.PrimaryDatabases;
                    break;
               case "sec":
                    databases= deployment.SecondaryDatabases;
                    break;
                case "all":
                    databases= deployment.Databases;
                    break;
                default:
                    return null;
            }
            return databases;
        }

        private Database GetDeploymentDefaultPrimary()
        {
            IOracle oracle = oracleFactory.CreateInstance();
            BaseDeployment wmoDeployment = deploymentFactory.CreateInstance();
            BaseDatabaseTemplate wmoDatabaseTemplate = databaseTemplateFactory.CreateInstance();
            Deployment deployment = new Deployment(wmoDeployment, wmoDatabaseTemplate, oracle, _deploymentFile);
            return deployment.DefaultPrimary;
        }
        private List<Database> GetDeploymentPrimaryDatabases()
        {
            return GetDeploymentDatabases("pri");
        }
        private List<Database> GetDeploymentSecondaryDatabases()
        {
            return GetDeploymentDatabases("sec");
        }
        private List<Database> GetDeploymentAllDatabase()
        {
            return GetDeploymentDatabases("all");
        }
        public void RepairwithOnlinePromote()
        {
            
            Database defaultPrimary = GetDeploymentDefaultPrimary();
            if (defaultPrimary != null)
            {
                if (!defaultPrimary.Status.Equals("online"))
                {
                    Repair(defaultPrimary,true);
                    Online(defaultPrimary);
                    Promote(defaultPrimary);
                }
            }
            //sleep for webstore polling period
            WaitForPollingPeriod();
            if (GetDeploymentPrimaryDatabases().Count > 0)
            {
                List<Database> secondaryDatabases = GetDeploymentSecondaryDatabases();
                foreach (Database db in secondaryDatabases.ToArray())
                {
                    Repair(db,false);
                }
                secondaryDatabases = GetDeploymentSecondaryDatabases();
                foreach (Database db in secondaryDatabases.ToArray())
                {
                    Online(db);
                }
            }
        }
        protected void WaitForPollingPeriod()
        {
            // wait for polling period
            WebstoreEnvironmentSettings env = WebstoreMetaData.Instance.DefaultConfig.EnvironmentSettings;
            int sleepinterval = env.PollingIntervalService * 1000;
            Thread.Sleep(sleepinterval);
        }
        /// <summary>
        /// Marks the secondaries and the primaries as Needs repair
        /// </summary>
        public void MarkNeedsRepair()
        {
            List<Database> secondaryDatabases = GetDeploymentSecondaryDatabases();
            List<Database> primaryDatabases = GetDeploymentPrimaryDatabases();
            //Mark the Secondary as needs repair
            if (secondaryDatabases != null)
            {
                foreach (Database db in secondaryDatabases.ToArray())
                {
                    WmoDatabase wmoDatabase = WmoDatabase.CreateInstance();
                    wmoDatabase.Database = db.Name;
                    wmoDatabase.Server = db.Server;
                    wmoDatabase.NeedsRepair();
                }
            }
               if (primaryDatabases != null)
                {
                    //Mark the primary as needs repair
                    foreach (Database db in primaryDatabases.ToArray())
                    {
                        WmoDatabase wmoDatabase = WmoDatabase.CreateInstance();
                        wmoDatabase.Database = db.Name;
                        wmoDatabase.Server = db.Server;
                        wmoDatabase.NeedsRepair();
                    }
                }
        }
        /// <summary>
        /// 
        /// </summary>
        protected void Upgrade(bool isRollingUpgrade, bool replTearDown)
        {
            IOracle oracle = oracleFactory.CreateInstance();

            BaseManifest wmoManifest = manifestFactory.CreateInstance();
            Manifest manifest = new Manifest(wmoManifest, oracle, _manifestFile);
            string manifestVersion = manifest.Version;
            manifest.Import();

            BaseDeployment wmoDeployment = deploymentFactory.CreateInstance();
            BaseDatabaseTemplate wmoDatabaseTemplate = databaseTemplateFactory.CreateInstance();
            Deployment deployment = new Deployment(wmoDeployment, wmoDatabaseTemplate, oracle, _deploymentFile);

            if (oracle.GetVersionForDeployment(deployment.Name) != manifestVersion)
                deployment.UpdateVersion(manifestVersion);

            deployment.Upgrade(isRollingUpgrade, replTearDown, false);
        }
        /// <summary>
        /// Add a new webstore application.  This is a first-time install
        /// scenario.
        /// </summary>
        protected void Add()
        {
            IOracle oracle = oracleFactory.CreateInstance();

            BaseManifest wmoManifest = manifestFactory.CreateInstance();
            Manifest manifest = new Manifest(wmoManifest, oracle, _manifestFile);

            //  Import the manifest.
            manifest.Import();

            BaseDeployment wmoDeployment = deploymentFactory.CreateInstance();
            BaseDatabaseTemplate wmoDatabaseTemplate = databaseTemplateFactory.CreateInstance();
            Deployment deployment = new Deployment(wmoDeployment, wmoDatabaseTemplate, oracle, _deploymentFile);

            //  Create and import the deployment file.
            deployment.Import();

            //  Setup the deployment.
            deployment.Setup();
        }

        /// <summary>
        /// Remove a webstore application, and drop the underlying databases.
        /// </summary>
        /// <param name="removeDatabase"></param>
        public void Remove(bool removeDatabase)
        {
            if (!removeDatabase)
            {
                return;
            }

            IOracle oracle = oracleFactory.CreateInstance();

            BaseManifest wmoManifest = manifestFactory.CreateInstance();
            BaseDeployment wmoDeployment = deploymentFactory.CreateInstance();
            BaseDatabaseTemplate wmoDatabaseTemplate = databaseTemplateFactory.CreateInstance();
            List<Database> databasesToRemove = new List<Database>();

            //
            //  Try to get manifest and deployment files from Webstore config db.
            //  If they're not imported, just use the versions of the files that
            //  currently reside on the hard disk.
            //

            Manifest manifest = new Manifest(wmoManifest, oracle, _manifestFile);

            Deployment deployment = new Deployment(wmoDeployment, wmoDatabaseTemplate, oracle, _deploymentFile);
            if (oracle.IsDeploymentImported(deployment.Name))
            {
                deployment = new Deployment(
                    wmoDeployment,
                    wmoDatabaseTemplate,
                    oracle,
                    oracle.ExportDeployment(deployment.Name).FullName);
            }

            //
            //  Before we do any of the replication teardown stuff,
            //  build up the list of databases.
            //

            foreach (Database database in deployment.Databases)
            {
                databasesToRemove.Add(database);
            }

            //
            //  Now loop through the failsafe sets, performing
            //  the replication teardown operations.
            //

            if (oracle.IsDeploymentImported(deployment.Name))
            {
                BaseFailSafeSet failSafeSet = failSafeSetFactory.CreateInstance();
                using (WstConnection connection = new WstConnection(deployment.Name))
                {
                    connection.Open();

                    WebstoreSQLFssCollection collection = connection.SqlPartitions;
                    foreach (WebstoreSQLFss partition in collection)
                    {
                        //
                        //  Step 1.  Demote FSS.
                        //

                        failSafeSet.DeploymentName = deployment.Name;
                        failSafeSet.SQLFSSNum = partition.FssId;
                        failSafeSet.Demote();

                        //
                        //  Step 2.  Offline FSS.
                        //

                        failSafeSet.DeploymentName = deployment.Name;
                        failSafeSet.SQLFSSNum = partition.FssId;
                        failSafeSet.Offline();

                        //
                        //  Step 3.  Drop replication on FSS.
                        //

                        failSafeSet.DeploymentName = deployment.Name;
                        failSafeSet.SQLFSSNum = partition.FssId;
                        failSafeSet.DropRepl();
                    }
                }

                deployment.Drop();
            }

            //  Make sure we don't infinite loop trying to purge the same
            //  manifest over and over.
            string previousVersionSeen = "";
            while (oracle.IsManifestImported(manifest.Name))
            {
                if (oracle.ManifestVersions(manifest.Name)[0] == previousVersionSeen)
                {
                    _log.WriteLine(string.Format("Unable to purge all manifest versions for manifest {0}.",
                                                 manifest.Name));
                    break;
                }

                previousVersionSeen = oracle.ManifestVersions(manifest.Name)[0];
                Manifest manifestToPurge = new Manifest(
                    wmoManifest,
                    oracle,
                    oracle.ExportManifest(manifest.Name, previousVersionSeen,
                                          false, false).FullName);
                manifestToPurge.Purge();

                oracle.Refresh();
            }

            //
            //  Purge templates
            //

            wmoDatabaseTemplate.Purge();

            //
            //  Now remove the databases and any jobs from SQL
            //

            //  Get the list of jobs to remove from the manifest.

            string[] jobsToRemove = manifest.Jobs;

            //  Now loop through all the database servers, dropping
            //  databases and jobs.

            foreach (Database database in databasesToRemove)
            {
                Server s = new Server(database.Server);

                //  Drop all jobs specified by the manifest.

                JobServer jobServer = s.JobServer;
                if (jobServer != null)
                {
                    foreach (string jobName in jobsToRemove)
                    {
                        Job job = jobServer.Jobs[jobName];

                        if (job != null)
                        {
                            job.Drop();
                            _log.WriteLine(string.Format("Removed job \"{0}\" from {1}.", jobName,
                                                         database.Name));
                        }
                    }
                }

                //  Now drop the database itself.

                if (s.Databases.Contains(database.Name))
                {
                    s.Databases["master"].ExecuteNonQuery(
                        string.Format("ALTER DATABASE {0} SET SINGLE_USER with ROLLBACK IMMEDIATE",
                                      database.Name));
                    s.Databases[database.Name].Drop();
                    _log.WriteLine(string.Format("Dropped database {0}.", database.Name));
                }
            }
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\WstRunner\xonline.tools.wstrunner.core.Resources.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1433
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace xonline.tools.wstrunner.core {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("xonline.tools.wstrunner.core.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &lt;Account Name=&quot;#ACCOUNT_NAME#&quot; xmlns=&quot;urn:WebstoreDeploymentSchema.xsd&quot;&gt;
        ///    &lt;Role&gt;#ROLE_NAME#&lt;/Role&gt;
        ///&lt;/Account&gt;
        ///.
        /// </summary>
        internal static string account_template {
            get {
                return ResourceManager.GetString("account_template", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &lt;Database Name=&quot;#DATABASE_NAME#&quot; DataServer=&quot;#SERVER_NAME#&quot; xmlns=&quot;urn:WebstoreDeploymentSchema.xsd&quot;&gt;
        ///    &lt;Status&gt;NotDeployed&lt;/Status&gt;
        ///    &lt;DefaultStatus&gt;Online&lt;/DefaultStatus&gt;
        ///&lt;/Database&gt;
        ///.
        /// </summary>
        internal static string database_template {
            get {
                return ResourceManager.GetString("database_template", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &lt;DataPartition Number=&quot;#PARTITION_NUMBER#&quot; xmlns=&quot;urn:WebstoreDeploymentSchema.xsd&quot;&gt;
        ///    &lt;SqlFailSafeSetNumber&gt;#FSS_NUMBER#&lt;/SqlFailSafeSetNumber&gt;
        ///    &lt;Status&gt;ReadWrite&lt;/Status&gt;
        ///&lt;/DataPartition&gt;
        ///.
        /// </summary>
        internal static string datapartition_template {
            get {
                return ResourceManager.GetString("datapartition_template", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &lt;Webstore xmlns=&quot;urn:WebstoreDeploymentSchema.xsd&quot;&gt;
        ///    &lt;DatabaseTemplates&gt;
        ///        &lt;DatabaseTemplate Name=&quot;#DISTRIBUTION_TEMPLATE_NAME#&quot;&gt;
        ///            &lt;Description/&gt;
        ///            &lt;IsDistributionOnly&gt;true&lt;/IsDistributionOnly&gt;
        ///            &lt;DataFileGroups&gt;
        ///                &lt;FileGroup Name=&quot;Primary&quot;&gt;
        ///                    &lt;LogicalFiles&gt;
        ///                        &lt;LogicalFile Name=&quot;DataFile&quot;&gt;
        ///                            &lt;Path&gt;#DATA_FILE_PATH#&lt;/Path&gt;
        ///                            &lt;Size&gt;10MB&lt;/Size&gt;
        ///             [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string deployment_template {
            get {
                return ResourceManager.GetString("deployment_template", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &lt;Server Name=&quot;#SERVER_NAME#&quot; ClusterName=&quot;DefaultCluster&quot; xmlns=&quot;urn:WebstoreDeploymentSchema.xsd&quot;&gt;
        ///    &lt;DataCenter Name=&quot;DefaultDataCenter&quot; /&gt;
        ///    &lt;DistributionDatabaseTemplate Name=&quot;#DISTRIBUTION_TEMPLATE_NAME#&quot; /&gt;
        ///    &lt;ServerRoles&gt;
        ///        &lt;ServerRole&gt;#SERVER_ROLE#&lt;/ServerRole&gt;
        ///    &lt;/ServerRoles&gt;
        ///&lt;/Server&gt;
        ///.
        /// </summary>
        internal static string server {
            get {
                return ResourceManager.GetString("server", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &lt;SqlFailSafeSet Number=&quot;&quot; xmlns=&quot;urn:WebstoreDeploymentSchema.xsd&quot;&gt;
        ///    &lt;DatabaseTemplate Name=&quot;#DATABASE_TEMPLATE_NAME#&quot; /&gt;
        ///    &lt;Databases&gt;
        ///    &lt;/Databases&gt;
        ///    &lt;DefaultPrimaryDatabase Database=&quot;#DATABASE_NAME#&quot; DataServer=&quot;#PRIMARY_SERVER_NAME#&quot; /&gt;
        ///    &lt;PrimaryDatabase Database=&quot;#DATABASE_NAME#&quot; DataServer=&quot;#PRIMARY_SERVER_NAME#&quot; /&gt;
        ///&lt;/SqlFailSafeSet&gt;
        ///.
        /// </summary>
        internal static string sqlfailsafeset_template {
            get {
                return ResourceManager.GetString("sqlfailsafeset_template", resourceCulture);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\WstRunner\WstRunnerProdRestorePrep.cs ===
﻿//=======================================================================
// ProdRestorePrep portion of the wst runner command
//
// Parse ProdRestorePrep command params, run ProdRestorePrep processing
//=======================================================================

using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;

using xonline.tools.wstrunner.core;

namespace xonline.tools.wstrunner.console
{

    public partial class WstRunnerCmd
    {
        /// <summary>
        /// Handles parsing of the command line arguments for ProdRestrorePrep
        /// </summary>
        /// <param name="args">The arguments to process.</param>
        public bool ParseProdRestorePrepCommandLine(string[] args)
        {
            int numberOfArgs = args.Length;
            string currentArg;

            for (int currentArgIndex = 2; currentArgIndex < numberOfArgs; currentArgIndex++)
            {
                currentArg = args[currentArgIndex];

                if (String.Compare(currentArg, "/buildRoot", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.buildRoot = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/webRootDir", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.webRootDir = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/installDir", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.installDir = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/environment", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.environment = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/databaseName", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.databaseName = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/upgradePath", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.upgradePath = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/bakFile", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.bakFile = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/userAccount", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.userAccount = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/prodPath", true) == 0)
                {   //REQURIED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.prodPath = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/manifestPath", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.manifestPath = args[++currentArgIndex];
                }
            }

            //Output the name arguments
            Console.WriteLine("buildRoot=            '" + wstConfig.buildRoot + "'");
            Console.WriteLine("webRootDir=           '" + wstConfig.webRootDir + "'");
            Console.WriteLine("installDir=           '" + wstConfig.installDir + "'");
            Console.WriteLine("environment=          '" + wstConfig.environment + "'");
            Console.WriteLine("databaseName=         '" + wstConfig.databaseName + "'");
            Console.WriteLine("upgradePath=          '" + wstConfig.upgradePath + "'");
            Console.WriteLine("bakFile=              '" + wstConfig.bakFile + "'");
            Console.WriteLine("userAccount=          '" + wstConfig.userAccount + "'");
            Console.WriteLine("prodPath=             '" + wstConfig.prodPath + "'");
            Console.WriteLine("manifestPath=         '" + wstConfig.manifestPath + "'");
            Console.WriteLine();

            //check if we have all the required params
            if (wstConfig.buildRoot == null
                || wstConfig.webRootDir == null
                || wstConfig.installDir == null
                || wstConfig.environment == null
                || wstConfig.databaseName == null
                || wstConfig.upgradePath == null
                || wstConfig.bakFile == null
                || wstConfig.userAccount == null
                || wstConfig.prodPath == null)
            {
                Console.WriteLine("ERROR: Required parameters for Install are missing.");
                Console.WriteLine("Type \"WstRunner /?\" for usage help.");
                return false;
            }

            return true;
        }

        /// <summary>
        /// Process the command parameter data
        /// </summary>
        /// <returns></returns>
        public bool ProcessProdRestorePrep()
        {
            if (wstConfig.bakFile != "")
            {
                string appLine = null;
                string cmdLine = null;

                // BUG# 49649 - dstDir can be null.
                // This should be sanitized and use Path.Combine()
                string deploymentXml = wstConfig.dstDir + "deployment.xml";
                wstConfig.deploymentFilename = deploymentXml;

                if (!File.Exists(wstConfig.bakFile))
                {
                    Console.WriteLine("backup file " + wstConfig.bakFile + " is invalid/not present");
                    return false;
                }

                if (!Directory.Exists(wstConfig.buildRoot))
                {
                    Console.WriteLine("Folder \"" + wstConfig.buildRoot + "\" does not exist.");
                    return false;
                }

                if (wstConfig.manifestPath == null || wstConfig.manifestPath.Length == 0)
                {
                    wstConfig.manifestPath = "manifest.xml";
                }

                wstConfig.srcDir = wstConfig.buildRoot + "\\database\\" + wstConfig.upgradePath + "\\" + wstConfig.databaseName;
                wstConfig.prodPath = wstConfig.buildRoot + "\\database\\" + wstConfig.prodPath + "\\" + wstConfig.databaseName;
                wstConfig.dstDir = wstConfig.webRootDir + "\\" + wstConfig.installDir;

                wstConfig.upgradeInstallDir = wstConfig.webRootDir + "\\" + wstConfig.databaseName + "_" + wstConfig.upgradePath;

                if (!Directory.Exists(wstConfig.dstDir))
                {
                    Directory.CreateDirectory(wstConfig.dstDir);
                }

                WstRunnerConfig.WSTVersion upgradeVersion = GetVersionFromManifest(wstConfig.srcDir + "\\" + wstConfig.manifestPath);

                string reason = null;

                InstallPolicy installCheck = ShouldInstallDatabaseAtVersion(wstConfig.databaseName, upgradeVersion, out reason);

                if (installCheck != InstallPolicy.OKToInstall)
                {
                    Console.WriteLine("Upgrade not performed -> " + reason);

                    //Broke the previous install
                    if (installCheck == InstallPolicy.DoNotInstall)
                        return false;

                    return true;
                }

                //  Copy utils.dll
                string srcFile = wstConfig.buildRoot + "\\" + "tools\\utils.dll";
                string dstFile = wstConfig.dstDir + "\\utils.dll";

                if (File.Exists(srcFile))
                {
                    if (CopyFile(srcFile, dstFile, true))
                    {
                        Console.WriteLine("Copied utils.dll.");
                    }
                    else
                    {
                        Console.WriteLine("Failed to copy utils.dll.");
                        return false;
                    }
                }
                else
                {
                    Console.WriteLine("File \"" + srcFile + "\" not found. Deployment cannot continue.");
                    return false;
                }

                srcFile = wstConfig.buildRoot + "\\tools\\TokenReplacer.exe";
                dstFile = wstConfig.dstDir + "\\TokenReplacer.exe";

                if (File.Exists(srcFile))
                {
                    if (CopyFile(srcFile, dstFile, true))
                    {
                        Console.WriteLine("Copied TokenReplacer.exe.");
                    }
                    else
                    {
                        Console.WriteLine("Failed to copy TokenReplacer.exe.");
                        return false;
                    }
                }
                else
                {
                    Console.WriteLine("File \"" + srcFile + "\" not found. Deployment cannot continue.");
                    return false;
                }

                wstConfig.installVersion = GetVersionFromManifest(wstConfig.srcDir + "\\" + wstConfig.manifestPath);

                if (wstConfig.installVersion == null)
                {
                    Console.WriteLine("ERROR unable to determine manifest version.");
                    return false;
                }

                // if same or higher version number then skip upgrade
                if (wstConfig.manifestVersion != null && wstConfig.failSafeVersion != null)
                {
                    if (compare(wstConfig.failSafeVersion, wstConfig.manifestVersion) > 0)
                    {
                        Console.WriteLine("upgraded to same or higher version, skipping pre-upgrade.");
                        Console.WriteLine("\tExisting version = " + wstConfig.failSafeVersion.strVersion);
                        Console.WriteLine("\tInstall version  = " + wstConfig.manifestVersion.strVersion);
                        return false;
                    }
                }

                //If the source directory does not exist, we're done.
                //Check and copy the deployment manifest
                //No deployment file copy/existence check for xblob
                if (wstConfig.environment.ToLower() != EnvironmentNames.livenoob)
                {
                    if (!Directory.Exists(wstConfig.prodPath))
                    {
                        Console.WriteLine("Folder \"" + wstConfig.prodPath + "\" does not exist.");
                        return false;
                    }

                    srcFile = wstConfig.prodPath + "\\deployment_" + wstConfig.environment + ".xml";
                    Console.WriteLine(srcFile);

                    if (File.Exists(srcFile))
                    {
                        dstFile = wstConfig.dstDir + "\\deployment.xml";
                        if (CopyFile(srcFile, dstFile, true))
                        {
                            Console.WriteLine("Copied the deployment manifest.");
                        }
                        else
                        {
                            Console.WriteLine("Failed to copy \"" + srcFile + " to " + dstFile);
                            return false;
                        }
                    }
                    else
                    {
                        Console.WriteLine("Database deployment repair failed. Deployment file not present.");
                        return false;
                    }

                    //Check and copy the manifest
                    //No manifest copy for xblob
                    srcFile = wstConfig.srcDir + "\\" + wstConfig.manifestPath;
                    Console.WriteLine(srcFile);
                    if (File.Exists(srcFile))
                    {
                        dstFile = wstConfig.dstDir + "\\" + wstConfig.manifestPath;

                        if (CopyFile(srcFile, dstFile, true))
                        {
                            Console.WriteLine("Copied the manifest.");
                        }
                        else
                        {
                            Console.WriteLine("Copying of manifest from \"" + srcFile + " to " + dstFile + " failed.");
                            return false;
                        }
                    }
                    else
                    {
                        Console.WriteLine("Database deployment repair failed. Manifest file not present.");
                        return false;
                    }

                    //Execute the Command Line to set to needsrepair
                    //No mark needs repair for Xblob
                    action = WstRunnerAction.MarkNeedsRepair;

                    if (MarkNeedsRepair() != 0)
                    {
                        Console.WriteLine("Failed to mark database as needing repair.");
                        return false;
                    }
                }

                //Take down the database to offline state(closes any existing connections)
                appLine = "sqlcmd";
                cmdLine = " -S (local) -Q " + "\"" + "ALTER DATABASE  " + wstConfig.databaseName + " SET OFFLINE WITH ROLLBACK IMMEDIATE" + "\"" + " -E";
                Console.WriteLine(appLine + cmdLine);

                if (!DoExec(appLine, cmdLine))
                {
                    Console.WriteLine("Taking down the database to offline failed to execute.");
                    return false;
                }

                //Restore from backup
                cmdLine = " -S (local) -Q " + "\"" + "RESTORE DATABASE " + wstConfig.databaseName + " FROM DISK = '" + wstConfig.bakFile + "' with REPLACE\"" + "  -b";
                Console.WriteLine(appLine + cmdLine);

                if (!DoExec(appLine, cmdLine))
                {
                    Console.WriteLine("Restore from backup did not execute.");
                    return false;
                }

                //Bring the database online
                cmdLine = " -S (local) -Q " + "\"" + "ALTER DATABASE " + wstConfig.databaseName + " SET ONLINE WITH ROLLBACK IMMEDIATE" + "\"" + " -E";
                Console.WriteLine(appLine + cmdLine);

                if (!DoExec(appLine, cmdLine))
                {
                    Console.WriteLine("Failed to execute bringing database back online.");
                    return false;
                }

                //#BUG 50402 - should no longer set the compatibility mode of the database
                //Set the Compatibility Mode to sql 2008
                //cmdLine = " -S (local) -Q " + "\"" + "ALTER DATABASE " + wstConfig.databaseName + " SET COMPATIBILITY_LEVEL=100" + "\"" + " -E";
                //Console.WriteLine(appLine + cmdLine);

                //if (!DoExec(appLine, cmdLine))
                //{
                //    Console.WriteLine("Failed to execute setting of compatibility mode.");
                //    return false;
                //}

                //No repairs for xblob 
                if (wstConfig.environment != EnvironmentNames.livenoob)
                {
                    action = WstRunnerAction.Repair;

                    if (Repair() != 0)
                    {
                        Console.WriteLine("Failed to repair database");
                        return false;
                    }
                }
            }
            else
            {
                Console.WriteLine("No Backup File specified");
            }

            return true;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\WstRunner\WstRunnerConfig.cs ===
﻿using System;
using System.IO;
using System.Collections.Generic;
using System.Text;

namespace xonline.tools.wstrunner.core
{
    public class WstRunnerConfig
    {
        public class WSTVersion
        {
            public int major                = 0;
            public int minor                = 0;
            public int build                = 0;
            public int dot                  = 0;
            public string strVersion        = null;
        };

        //install
        public string jobType               = null;
        public string buildRoot             = null;
        public string webRootDir            = null;
        public string installDir            = null;
        public string environment           = null;
        public string databaseName          = null;
        public string upgradePath           = null;
        public string deployEnabled         = null;
        public string configServiceUri      = null;
        public string logRootDir            = null;
        public string userAccount           = null;
        public string adminAccount          = null;
        public string dataFilesDir          = null;
        public string logFilesDir           = null;
        public string dataServerList        = null;
        public uint   partitionCount        = 0;
        public uint   failSafeSetsPerServer = 1;
        public string accountRoleMap        = null;
        public string skipInterfaceConfig   = null;
        public string interfaceName         = null;
        public string componentName         = null;
        public string manifestPath          = null;
        public WstRunner.SetupAction setAction = WstRunner.SetupAction.None;
        public bool isRollingUpgrade        = false;
        public bool replTearDown            = true;

        //install internal
        public string srcDir                    = null;
        public WSTVersion manifestVersion       = null;
        public WSTVersion failSafeVersion       = null;
        public bool failSafeSetDifferent        = false;
        public int fssNumber                    = 0;
        public WSTVersion installVersion        = null;
        public string deployVersion             = null;
        public string srcDirProdbaseDDL         = null;
        public string dstDirDDL                 = null;
        public string srcDirProdbaseDML         = null;
        public string dstDirDML                 = null;
        public string srcDirProdbaseOther       = null;
        public string dstDirOther               = null;
        public string dataDir                   = null;
        public string envDir                    = null;
        public string srcFile                   = null;
        public string dstFile                   = null;
        public FileInfo deploymentFile          = null;

        //uninstall internal
        public string dstDir                = null;
        public string computerName          = null;

        //ProdRestorePrep internal
        public string bakFile               = null;
        public string prodPath              = null;
        public string upgradeInstallDir     = null;

        //DisableAndStopJob internal
        public string sqlJobName            = null;

        public string deploymentFilename = null;
        public bool isUpgrade            = false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\WstRunner\WstRunnerInstall.cs ===
﻿//====================================================
// Install portion of the wst runner command
//
// Parse install command params, run install processing
//=====================================================

using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using xonline.tools.wstrunner.core;

namespace xonline.tools.wstrunner.console
{

    public partial class WstRunnerCmd
    {
        internal const string UpgradeReasonString = "Installed Version is lower than new version";

        enum InstallPolicy {
            OKToInstall, DoNotInstall, InstallNotNecessary
        }

        /// <summary>
        /// Handles parsing of the command line arguments for installs
        /// </summary>
        /// <param name="args">The arguments to process.</param>
        public bool ParseInstallCommandLine(string[] args)
        {
            int numberOfArgs = args.Length;
            string currentArg;

            //we can skip the first two arguments which should have been the /job arg
            for (int currentArgIndex = 2; currentArgIndex < numberOfArgs; currentArgIndex++)
            {
                currentArg = args[currentArgIndex];

                if (String.Compare(currentArg, "/buildRoot", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.buildRoot = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/webRootDir", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.webRootDir = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/installDir", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.installDir = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/environment", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.environment = args[++currentArgIndex].ToLower();
                }
                else if (String.Compare(currentArg, "/databaseName", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.databaseName = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/upgradePath", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.upgradePath = args[++currentArgIndex].ToLower();
                }
                else if (String.Compare(currentArg, "/deployEnabled", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.deployEnabled = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/configSvcUri", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.configServiceUri = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/logRootDir", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.logRootDir = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/userAccount", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.userAccount = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/adminAccount", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.adminAccount = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/dataFilesDir", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.dataFilesDir = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/logFilesDir", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.logFilesDir = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/dataServerList", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.dataServerList = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/partitionCount", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.partitionCount = Convert.ToUInt32(args[++currentArgIndex]);
                }
                else if (String.Compare(currentArg, "/failSafeSetsPerServer", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.failSafeSetsPerServer = Convert.ToUInt32(args[++currentArgIndex]);
                }
                else if (String.Compare(currentArg, "/accountRoleMap", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.accountRoleMap = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/skipInterfaceConfig", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.skipInterfaceConfig = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/interfaceName", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.interfaceName = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/componentName", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.componentName = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/manifestPath", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.manifestPath = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/rollingUpgrade", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    string checkRolling = args[++currentArgIndex];
                    if ((String.Compare(checkRolling, "1") == 0) || (String.Compare(checkRolling, "true", true) == 0))
                    {
                        wstConfig.isRollingUpgrade = true;
                    }
                    else
                    {
                        wstConfig.isRollingUpgrade = false;
                    }
                }
                else if (String.Compare(currentArg, "/replTearDown", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    string checkReplTearDown = args[++currentArgIndex];
                    wstConfig.replTearDown = checkReplTearDown.Equals("1") || checkReplTearDown.Equals("true", StringComparison.CurrentCultureIgnoreCase);
                }
            }

            //Output the name arguments
            Console.WriteLine("buildRoot=            '" + wstConfig.buildRoot + "'");
            Console.WriteLine("webRootDir=           '" + wstConfig.webRootDir + "'");
            Console.WriteLine("installDir=           '" + wstConfig.installDir + "'");
            Console.WriteLine("environment=          '" + wstConfig.environment + "'");
            Console.WriteLine("databaseName=         '" + wstConfig.databaseName + "'");
            Console.WriteLine("upgradePath=          '" + wstConfig.upgradePath + "'");
            Console.WriteLine("deployEnabled=        '" + wstConfig.deployEnabled + "'");
            Console.WriteLine("configSvcUri=         '" + wstConfig.configServiceUri + "'");
            Console.WriteLine("userAccount=          '" + wstConfig.userAccount + "'");
            Console.WriteLine("adminAccount=         '" + wstConfig.adminAccount + "'");
            Console.WriteLine("dataFilesDir=         '" + wstConfig.dataFilesDir + "'");
            Console.WriteLine("logFilesDir=          '" + wstConfig.logFilesDir + "'");
            Console.WriteLine("dataServerList=       '" + wstConfig.dataServerList + "'");
            Console.WriteLine("partitionCount=       '" + wstConfig.partitionCount + "'");
            Console.WriteLine("failSafeSetsPerServer='" + wstConfig.failSafeSetsPerServer + "'");
            Console.WriteLine("accountRoleMap=       '" + wstConfig.accountRoleMap + "'");
            Console.WriteLine("skipInterfaceConfig=  '" + wstConfig.skipInterfaceConfig + "'");
            Console.WriteLine("interfaceName=        '" + wstConfig.interfaceName + "'");
            Console.WriteLine("componentName=        '" + wstConfig.componentName + "'");
            Console.WriteLine("manifestPath=         '" + wstConfig.manifestPath + "'");
            Console.WriteLine("rollingUpgrade=       '" + wstConfig.isRollingUpgrade.ToString() + "'");
            Console.WriteLine("replTearDown=         '" + wstConfig.replTearDown.ToString() + "'");
            Console.WriteLine();

            //check if we have all the required params
            if (wstConfig.buildRoot == null
                || wstConfig.webRootDir == null
                || wstConfig.installDir == null
                || wstConfig.environment == null
                || wstConfig.databaseName == null
                || wstConfig.upgradePath == null
                || wstConfig.deployEnabled == null)
            {
                Console.WriteLine("ERROR: Required parameters for Install are missing.");
                Console.WriteLine("Type \"WstRunner /?\" for usage help.");
                return false;
            }

            return true;
        }

        /// <summary>
        /// Determines the policy for installations based on fail safe set numbers.
        /// We deny deployment if, based on information describing the fail safe sets, we can reasonably
        /// believe that a deployment before this one failed.
        /// </summary>
        /// <param name="versionToInstall">The version that will be installed should setup proceed</param>
        /// <param name="deploymentName">The name of the deployment which will be installed.</param>
        /// <param name="reason">If the database should not be installed, a message explaining why. Otherwise an empty string.</param>
        /// <returns>Whether or not setup should be allowed to proceed.</returns>
        InstallPolicy ShouldInstallDatabaseAtVersion(string deploymentName, WstRunnerConfig.WSTVersion versionToInstall, out string reason)
        {
            InstallPolicy installPolicy = InstallPolicy.OKToInstall;
            reason = String.Empty; // silence the C# compiler -- we never use reason when it's okay to install.

            WstRunnerConfig.WSTVersion inProgressDeploymentVersion = GetVersionOfInProgressDeployment(deploymentName);
            WstRunnerConfig.WSTVersion actualDeploymentVersion = GetVersionFromDeployment(deploymentName);

            if ((inProgressDeploymentVersion != null) && (compare(inProgressDeploymentVersion, versionToInstall) < 0))
            {
                    reason = String.Format("A previous database deployment, versioned {0}, did not complete successfully. " +
                                           "Automated database deployment can not continue.", inProgressDeploymentVersion.strVersion);
                    installPolicy = InstallPolicy.DoNotInstall;
            }
            else if (actualDeploymentVersion != null)
            {
                // all versions are the same. Are they higher than or equal to ours?
                if (compare(versionToInstall, actualDeploymentVersion) < 0)
                {
                    reason = String.Format("No installation is necessary. The version of the currently deployed database, {0}, is higher than " +
                                           "the one that would be installed, {1}.", actualDeploymentVersion.strVersion, versionToInstall.strVersion);
                    installPolicy = InstallPolicy.InstallNotNecessary;
                }
                else if ((inProgressDeploymentVersion == null) && (compare(versionToInstall, actualDeploymentVersion) == 0))
                {
                    reason = String.Format("No installation is necessary. The deployed database is already at version {0}.", versionToInstall.strVersion);
                    installPolicy = InstallPolicy.InstallNotNecessary;
                }
                else if (compare(versionToInstall, actualDeploymentVersion) > 0)
                {
                    reason = String.Format(UpgradeReasonString);
                }
            }

            return installPolicy;
        }

        /// <summary>
        /// Initializes InterfaceName, manifestPath, skipInterfaceConfig, computerName
        /// Checks whether the buildRoot exists and sets the srcDir
        /// Checks whether the srcDir exists.
        /// Reads the manifest version of the source material
        /// </summary>
        /// <returns></returns>
        public bool ValidateInstallSourceForProcessInstall()
        {
            wstConfig.upgradePath = wstConfig.upgradePath.ToLower();

            if (wstConfig.skipInterfaceConfig == null)
            {
                wstConfig.skipInterfaceConfig = "false";
            }

            if (wstConfig.interfaceName == null || wstConfig.interfaceName.Length == 0)
            {
                wstConfig.interfaceName = wstConfig.databaseName;
            }

            if (wstConfig.manifestPath == null || wstConfig.manifestPath.Length == 0)
            {
                wstConfig.manifestPath = "manifest.xml";
            }

            wstConfig.computerName = Environment.MachineName;

            if (!Directory.Exists(wstConfig.buildRoot))
            {
                Console.WriteLine("Folder \"" + wstConfig.buildRoot + "\" does not exist.");
                return false;
            }

            wstConfig.srcDir = wstConfig.buildRoot + "\\sql\\" + wstConfig.upgradePath + "\\" + wstConfig.databaseName;

            if (!Directory.Exists(wstConfig.srcDir))
            {
                Console.WriteLine("Folder \"" + wstConfig.srcDir + "\" does not exist.");
                return false;
            }

            wstConfig.installVersion = GetVersionFromManifest(wstConfig.srcDir + "\\" + wstConfig.manifestPath);

            if (wstConfig.installVersion == null)
            {
                Console.WriteLine("ERROR unable to determine manifest version.");
                return false;
            }

            wstConfig.dstDir = wstConfig.webRootDir + "\\" + wstConfig.installDir;

            // This will need to go away but it is just here for now
            if (wstConfig.environment == EnvironmentNames.livenoob)
            {
                if (wstConfig.userAccount == null)
                {
                    Console.WriteLine("ERROR xblob environment requires useraccount to be defined");
                    return false;
                }
            }

            if (wstConfig.accountRoleMap == null)
            {
                wstConfig.accountRoleMap = wstConfig.userAccount + "=ClientLib";
            }

            return true;
        }

        /// <summary>
        /// Process the command parameter data
        /// </summary>
        /// <returns></returns>
        public bool ProcessInstall()
        {
            if (!ValidateInstallSourceForProcessInstall())
            {
                return false;
            }

            //Check our policy for fail safe sets and see if install should be allowed to proceed.
                
            string reason;
            InstallPolicy policy = ShouldInstallDatabaseAtVersion(wstConfig.databaseName, wstConfig.installVersion, out reason);
            
            if (policy == InstallPolicy.DoNotInstall) 
            {
                Console.WriteLine("ERROR {0}", reason);
                return false;
            }
            else if (policy == InstallPolicy.InstallNotNecessary)
            {
                Console.WriteLine(reason);
                return true;
            }

            if (!Directory.Exists(wstConfig.webRootDir))
            {
                Console.WriteLine("WARNING : webRootDir -> " + wstConfig.webRootDir + " did not exist, creating it.");
                Directory.CreateDirectory(wstConfig.dstDir);
            }

            if (Directory.Exists(wstConfig.dstDir))
            {
                // if prodbase is database name already installed
                if (wstConfig.upgradePath == "prodbase" && wstConfig.manifestVersion != null && wstConfig.failSafeVersion != null)
                {
                    if (compare(wstConfig.failSafeVersion, wstConfig.manifestVersion) > 0)
                    {
                        Console.WriteLine(wstConfig.databaseName + " is already installed.");
                        return false;
                    }
                }

#if SUPPORT_UNINSTALL_ON_SETUP
                // if prodbase is database an old version? if so uninstall
                if (wstConfig.upgradePath == "prodbase")
                {
                    if ((wstConfig.failSafeVersion == null) || (compare(wstConfig.failSafeVersion, wstConfig.manifestVersion) < 0))
                    {
                        Console.WriteLine(wstConfig.databaseName + " is old. Uninstalling...");

                        if (!UninstallDatabase())
                        {
                            return false;
                        }

                        Directory.CreateDirectory(wstConfig.dstDir);
                    }
                }
#endif //SUPPORT_UNINSTALL_ON_SETUP
            }
            else
            {
                Directory.CreateDirectory(wstConfig.dstDir);
            }

#if NOT_USED
            //  Copy the entire set of database files.  If this is an upgrade,
            //  then we need to copy prodbase DDL first, then upgrade.
            if (wstConfig.upgradePath != "prodbase")
            {
                //  If we are trying to upgrade over an existing upgrade, make sure we're coming
                //  in with a higher version number, otherwise it's a no-op.

                // if same or higher version number then skip upgrade
                if (wstConfig.manifestVersion != null && wstConfig.failSafeVersion != null)
                {
                    if (compare(wstConfig.failSafeVersion, wstConfig.manifestVersion) > 0)
                    {
                        Console.WriteLine("Same or higher existing version found, skipping upgrade.");
                        Console.WriteLine("\tExisting version = " + wstConfig.failSafeVersion.strVersion);
                        Console.WriteLine("\tInstall version  = " + wstConfig.manifestVersion.strVersion);
                        return false;
                    }
                }

                wstConfig.srcDirProdbaseDDL = wstConfig.buildRoot + "\\database\\prodbase\\" + wstConfig.databaseName + "\\ddl";
                wstConfig.dstDirDDL = wstConfig.dstDir + "\\ddl";

                if (Directory.Exists(wstConfig.srcDirProdbaseDDL))
                {
                    if (CopyDirectories(wstConfig.srcDirProdbaseDDL, wstConfig.dstDirDDL, true))
                    {
                        Console.WriteLine("Copied \"" + wstConfig.srcDirProdbaseDDL + "\" to \"" + wstConfig.dstDirDDL + "\".");
                    }
                    else
                    {
                        Console.WriteLine("FAILED Copying \"" + wstConfig.srcDirProdbaseDDL + "\" to \"" + wstConfig.dstDirDDL + "\".");
                        return false;
                    }
                }

                // BUG# 49600 - WstRuner wants to generate a deploymentxml file but there isn't one.
                string pathToProdbaseDeployment = wstConfig.buildRoot + "\\database\\prodbase\\" + wstConfig.databaseName + "\\deployment_" + wstConfig.environment + ".xml";
                string destinationForProdbaseDeployment = wstConfig.dstDir + "\\deployment.xml";

                if (File.Exists(pathToProdbaseDeployment))
                {
                    if (this.CopyFile(pathToProdbaseDeployment, destinationForProdbaseDeployment, true))
                    {
                        Console.WriteLine("Copied \"" + pathToProdbaseDeployment + "\" to \"" + destinationForProdbaseDeployment + "\".");
                    }
                    else
                    {
                        Console.WriteLine("FAILED Copying \"" + pathToProdbaseDeployment + "\" to \"" + destinationForProdbaseDeployment + "\".");
                        return false;
                    }
                }
                // END BUG# 49600


                if (wstConfig.databaseName.ToLower() == "rawcatalogdb")
                {
                    wstConfig.srcDirProdbaseDML = wstConfig.buildRoot + "\\database\\prodbase\\" + wstConfig.databaseName + "\\dml";
                    wstConfig.dstDirDML = wstConfig.dstDir + "\\dml";

                    if (Directory.Exists(wstConfig.srcDirProdbaseDML))
                    {
                        if (CopyDirectories(wstConfig.srcDirProdbaseDML, wstConfig.dstDirDML, true))
                        {
                            Console.WriteLine("Copied \"" + wstConfig.srcDirProdbaseDML + "\" to \"" + wstConfig.dstDirDML + "\".");
                        }
                        else
                        {
                            Console.WriteLine("FAILED Copying \"" + wstConfig.srcDirProdbaseDML + "\" to \"" + wstConfig.dstDirDML + "\".");
                            return false;
                        }

                    }

                    wstConfig.srcDirProdbaseOther = wstConfig.buildRoot + "\\database\\prodbase\\" + wstConfig.databaseName + "\\other";
                    wstConfig.dstDirOther = wstConfig.dstDir + "\\other";

                    if (Directory.Exists(wstConfig.srcDirProdbaseOther))
                    {
                        if (CopyDirectories(wstConfig.srcDirProdbaseOther, wstConfig.dstDirOther, true))
                        {
                            Console.WriteLine("Copied \"" + wstConfig.srcDirProdbaseOther + "\" to \"" + wstConfig.dstDirOther + "\".");
                        }
                        else
                        {
                            Console.WriteLine("FAILED Copying \"" + wstConfig.srcDirProdbaseOther + "\" to \"" + wstConfig.dstDirOther + "\".");
                            return false;
                        }
                    }
                }
            }

            if (wstConfig.upgradePath != "prodbase" && wstConfig.upgradePath != "upgrade")
            {
                wstConfig.srcDirProdbaseDDL = wstConfig.buildRoot + "\\database\\upgrade\\" + wstConfig.databaseName + "\\ddl";
                wstConfig.dstDirDDL = wstConfig.dstDir + "\\ddl";

                if (Directory.Exists(wstConfig.srcDirProdbaseDDL))
                {
                    if (CopyDirectories(wstConfig.srcDirProdbaseDDL, wstConfig.dstDirDDL, true))
                    {
                        Console.WriteLine("Copied \"" + wstConfig.srcDirProdbaseDDL + "\" to \"" + wstConfig.dstDirDDL + "\".");
                    }
                    else
                    {
                        Console.WriteLine("FAILED Copying \"" + wstConfig.srcDirProdbaseDDL + "\" to \"" + wstConfig.dstDirDDL + "\".");
                        return false;
                    }
                }

                if (wstConfig.databaseName.ToLower() == "rawcatalogdb")
                {
                    wstConfig.srcDirProdbaseDML = wstConfig.buildRoot + "\\database\\prodbase\\" + wstConfig.databaseName + "\\dml";
                    wstConfig.dstDirDML = wstConfig.dstDir + "\\dml";

                    if (Directory.Exists(wstConfig.srcDirProdbaseDML))
                    {
                        if (CopyDirectories(wstConfig.srcDirProdbaseDML, wstConfig.dstDirDML, true))
                        {
                            Console.WriteLine("Copied \"" + wstConfig.srcDirProdbaseDML + "\" to \"" + wstConfig.dstDirDML + "\".");
                        }
                        else
                        {
                            Console.WriteLine("FAILED Copying \"" + wstConfig.srcDirProdbaseDML + "\" to \"" + wstConfig.dstDirDML + "\".");
                            return false;
                        }
                    }

                    wstConfig.srcDirProdbaseOther = wstConfig.buildRoot + "\\database\\prodbase\\" + wstConfig.databaseName + "\\other";
                    wstConfig.dstDirOther = wstConfig.dstDir + "\\other";

                    if (Directory.Exists(wstConfig.srcDirProdbaseOther))
                    {
                        if (CopyDirectories(wstConfig.srcDirProdbaseOther, wstConfig.dstDirOther, true))
                        {
                            Console.WriteLine("Copied \"" + wstConfig.srcDirProdbaseOther + "\" to \"" + wstConfig.dstDirOther + "\".");
                        }
                        else
                        {
                            Console.WriteLine("FAILED Copying \"" + wstConfig.srcDirProdbaseOther + "\" to \"" + wstConfig.dstDirOther + "\".");
                            return false;
                        }
                    }
                }
            }
#endif // NOT_USED

            if (CopyDirectories(wstConfig.srcDir, wstConfig.dstDir, true))
            {
                Console.WriteLine("Copied \"" + wstConfig.srcDir + "\" to \"" + wstConfig.dstDir + "\".");
            }

#if DML
            //  If the database has specific files for the environment specified, copies those
            //  files into the correct location.
            wstConfig.dataDir = wstConfig.dstDir + "\\dml\\data\\";
            wstConfig.envDir = Path.Combine(wstConfig.dataDir, wstConfig.environment);

            if (Directory.Exists(wstConfig.envDir))
            {             
               DirectoryInfo envDirInfo = new DirectoryInfo(wstConfig.envDir);

               foreach (FileInfo fileInfo in envDirInfo.GetFiles("*.sql"))
                {             
                    CopyFile(fileInfo.FullName, Path.Combine(wstConfig.dataDir, fileInfo.Name), true);
                    Console.WriteLine("Copied SQL file from \"" + fileInfo.FullName + "\" to \"" + wstConfig.dataDir + "\".");
                }

            }

            //  Copy SetupLauncher.exe
            wstConfig.srcFile = wstConfig.buildRoot + "\\" + "tools\\SetupLauncher.exe";
            wstConfig.dstFile = wstConfig.dstDir + "\\" + "SetupLauncher.exe";

            if (File.Exists(wstConfig.srcFile))
            {
                if (!Directory.Exists(wstConfig.dstDir))
                {
                    //destination directory is not available, attempt to create it
                    try
                    {
                        Directory.CreateDirectory(wstConfig.dstDir);
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("FAILED to create directory -> " + wstConfig.dstDir + " with error -> " + e.ToString());
                        return false;
                    }
                }
                CopyFile(wstConfig.srcFile, wstConfig.dstFile, true);
                Console.WriteLine("Copied SetupLauncher.exe.");
            }
            else
            {
                Console.WriteLine("File \"" + wstConfig.srcFile + "\" not found.  Deployment cannot continue.");
                return false;
            }

            //  Copy TokenReplacer.exe
            wstConfig.srcFile = wstConfig.buildRoot + "\\" + "tools\\TokenReplacer.exe";
            wstConfig.dstFile = wstConfig.dstDir + "\\" + "TokenReplacer.exe";

            if (File.Exists(wstConfig.srcFile))
            {

                CopyFile(wstConfig.srcFile, wstConfig.dstFile, true);
                Console.WriteLine("Copied TokenReplacer.exe.");
            }
            else
            {
                Console.WriteLine("File \"" + wstConfig.srcFile + "\" not found.  Deployment cannot continue.");
                return false;
            }

            //  Copy utils.dll
            wstConfig.srcFile = wstConfig.buildRoot + "\\" + "tools\\utils.dll";
            wstConfig.dstFile = wstConfig.dstDir + "\\" + "utils.dll";

            if (File.Exists(wstConfig.srcFile))
            {
                CopyFile(wstConfig.srcFile, wstConfig.dstFile, true);
                Console.WriteLine("Copied utils.dll.");
            }
            else
            {
                Console.WriteLine("File \"" + wstConfig.srcFile + "\" not found.  Deployment cannot continue.");
                return false;
            }

            //  Copy XblConfig.dll
            wstConfig.srcFile = wstConfig.buildRoot + "\\" + "tools\\XblConfig.dll";
            wstConfig.dstFile = wstConfig.dstDir + "\\" + "XblConfig.dll";

            if (File.Exists(wstConfig.srcFile))
            {
                CopyFile(wstConfig.srcFile, wstConfig.dstFile, true);
                Console.WriteLine("Copied XblConfig.dll.");
            }
            else
            {
                Console.WriteLine("File \"" + wstConfig.srcFile + "\" not found.  Deployment cannot continue.");
                return false;
            }

            //  Copy confnpdb.exe
            wstConfig.srcFile = wstConfig.buildRoot + "\\tools\\confnpdb.exe";
            wstConfig.dstFile = wstConfig.dstDir + "\\confnpdb.exe";

            if (File.Exists(wstConfig.srcFile))
            {
                CopyFile(wstConfig.srcFile, wstConfig.dstFile, true);
                Console.WriteLine("Copied confnpdb.exe.");
            }
            else
            {
                Console.WriteLine("File \"" + wstConfig.srcFile + "\" not found.  Deployment cannot continue.");
                return false;
            }

            //  Copy xonline.tools.confnpdb.common.dll
            wstConfig.srcFile = wstConfig.buildRoot + "\\" + "tools\\xonline.tools.confnpdb.common.dll";
            wstConfig.dstFile = wstConfig.dstDir + "\\" + "xonline.tools.confnpdb.common.dll";

            if (File.Exists(wstConfig.srcFile))
            {
                CopyFile(wstConfig.srcFile, wstConfig.dstFile, true);
                Console.WriteLine("Copied xonline.tools.confnpdb.common.dll.");
            }
            else
            {
                Console.WriteLine("File \"" + wstConfig.srcFile + "\" not found.  Deployment cannot continue.");
                return false;
            }

            Console.WriteLine();

            string appLine;
            string cmdLine;
            //  Set Config Service reg key
            // TODO:  Commenting out this call for now, because confnpdb.exe needs to
            // support register-config.
            //appLine = wstConfig.dstDir + "\\confnpdb.exe";
            //cmdLine = " register-config " + wstConfig.configServiceUri;

            //if (!DoExec(appLine, cmdLine))
            //{
            //    return false;
            //}

            //  If this is XBLOB, we need to do token-replacement.
            //  Copy over the relevant tools to get this done.
            if (wstConfig.environment.ToLower() == EnvironmentNames.livenoob && Directory.Exists(wstConfig.dataDir))
            {
                //  Generate tokens file
                Console.WriteLine("Generating token file.");

                appLine = wstConfig.dstDir + "\\SetupLauncher.exe";
                cmdLine = " /Command GetNetworkInfo" + " SERVER=" + wstConfig.computerName + " OUTPUTFILE=" + wstConfig.databaseName + "_tokens.txt";

                if (!DoExec(appLine, cmdLine))
                {
                    return false;
                }

                //  Token-replace _gen_data.sql and _gen_data_delete.sql.
                //  Token-replace all .sql files in the data directory.

                Console.WriteLine("Token-replacing sql data files.");

                string[] fileList = Directory.GetFiles(wstConfig.dataDir, "*.sql");
                appLine = wstConfig.dstDir + "\\TokenReplacer.exe";

                if (fileList.Length > 0)
                {
                    foreach (string sFile in fileList)
                    {
                        Console.WriteLine("Token-replacing " + sFile);

                        cmdLine = " /inputFile \"" + sFile + "\"" +
                                    " /outputFile \"" + sFile + "\"" +
                                    " /tokenFile " + wstConfig.databaseName + "_tokens.txt" +
                                    " #XBLOB_MACHINE#=" + wstConfig.computerName +
                                    " #XBLOB_USER_FQDN#=" + wstConfig.userAccount +
                                    " #XBLOB_ADMIN_FQDN#=" + wstConfig.adminAccount +
                                    " #XBLOB_USER#=" + wstConfig.userAccount.Split('\\')[1] +
                                    " #XBLOB_ADMIN#=" + wstConfig.adminAccount.Split('\\')[1] +
                                    " \"#XBLOB_WEBROOT#=" + wstConfig.webRootDir + "\"" +
                                    " \"#XBLOB_LOGROOT#=" + wstConfig.logRootDir + "\"" +
                                    " \"#XBLOB_DBROOT#=" + wstConfig.dataFilesDir + "\"" +
                                    " \"#XBLOB_DB_ROOT#=" + wstConfig.dataFilesDir + "\"";

                        if (!DoExec(appLine, cmdLine))
                        {
                            return false;
                        }
                    }

                }
                else
                {
                    Console.WriteLine("No SQL files found to do Token-replacing on \"" + wstConfig.dataDir + "\".");
                }
            }
#else //DML
            //string appLine;
            //string cmdLine;
#endif

            //  Determine install or update here.
            //
            //  Check to see if there's a deployment file that we should be using.
            //  We should have already obtained the deployment file from calling get
            wstConfig.srcFile = wstConfig.srcDir + "\\deployment_" + wstConfig.environment + ".xml";
            wstConfig.setAction = WstRunner.SetupAction.Install;

            if (!string.IsNullOrEmpty(reason) && reason == WstRunnerCmd.UpgradeReasonString)
            {
                wstConfig.setAction = WstRunner.SetupAction.Upgrade;
                wstConfig.isUpgrade = true;
            }

            if (File.Exists(wstConfig.srcFile))
            {
                wstConfig.dstFile = wstConfig.dstDir + "\\deployment.xml";
                CopyFile(wstConfig.srcFile, wstConfig.dstFile, true);

#if SUPPORT_LOOSE_DEPLOYMENT_XML
                //Catalog has deployment files with Token
                if (wstConfig.environment.ToLower() == EnvironmentNames.livenoob)
                {
                    appLine = wstConfig.dstDir + "\\TokenReplacer.exe";
                    cmdLine = " /inputFile " + "\"" + wstConfig.dstDir + "\\deployment.xml\"" + " /outputFile " + "\"" +
                              wstConfig.dstDir + "\\deployment.xml\"" + " #XBLOB_MACHINE#=" + wstConfig.computerName +
                              " #XBLOB_USER#=" + wstConfig.userAccount + " #SQLDATADIR#=" + wstConfig.dataFilesDir +
                              " #SQLLOGDIR#=" + wstConfig.logFilesDir;

                    Console.WriteLine(appLine + cmdLine);

                    if (!DoExec(appLine, cmdLine))
                    {
                        return false;
                    }
                }
#endif //SUPPORT_LOOSE_DEPLOYMENT_XML

                action = WstRunnerAction.Setup;

                // OLD Call
                //cmdLine = "\"" + dstDir + "\\WstRunner.exe\" /setup" +
                //          " /M \"" + dstDir + "\\" + manifestPath + "\"" +
                //          " /D \"" + dstDir + "\\deployment.xml\"";
            }
            else
            {
                string accountRoleMap = null;

                if (wstConfig.accountRoleMap != null && wstConfig.accountRoleMap != "")
                {
                    accountRoleMap = wstConfig.accountRoleMap;
                }
                else
                {
                    accountRoleMap = wstConfig.userAccount + "=ClientLib";
                }

                action = WstRunnerAction.Setup;

                // OLD Call
                //cmdLine = "\"" + dstDir + "\\WstRunner.exe\" /setup" +
                //         " /M \"" + dstDir + "\\" + manifestPath + "\"" +
                //         " /V \"dataFilePath=" + namedArgs.Item("dataFilesDir") + "\"" +
                //         " /V \"logFilePath=" + namedArgs.Item("logFilesDir") + "\"" +
                //         " /V configServerList=" + network.ComputerName +
                //         " /V dataServerList=" + namedArgs.Item("dataServerList") +
                //         " /V accountRoleMap=" + accountRoleMap +
                //         " /V databaseName=" + namedArgs.Item("databaseName") +
                //         " /V partitionCount=" + namedArgs.Item("partitionCount");

            }

            if (wstConfig.failSafeSetsPerServer != 0)
            {
                // OLD Call
                //cmdLine = cmdLine + " /V failSafeSetsPerServer=" + namedArgs.Item("failSafeSetsPerServer");
            }

            if (wstConfig.upgradePath != "prodbase")
            {
                // OLD Call
                // cmdLine = cmdLine + "/upgrade";

                wstConfig.isUpgrade = true;
                wstConfig.setAction = WstRunner.SetupAction.Upgrade;
            }

            if (wstConfig.deployEnabled == "1")
            {
                Console.WriteLine("Commencing database deployment.\r\n");

                if (RunIt() != 0)
                {
                    Console.WriteLine("Database deployment failed.");
                    return false;
                }

                // OLD Call
                //if (DoExec(cmdLine) != 0)
                //{
                //    WriteLine("Database deployment failed.");

                //    if (fso.FileExists(resultsFileName))
                //    {
                //        var resultsFile = fso.GetFile(resultsFileName);
                //        resultsFile.Attributes = 0;
                //        fso.DeleteFile(resultsFileName);
                //    }
                //
                //    WScript.Quit(1);
                //}
                Console.WriteLine("Database deployment complete.");
            }
            else
            {
                Console.WriteLine("Deployment skipped.");
            }

            return true;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public bool PostProcessInstall()
        {
            Console.WriteLine("Running Post Install Steps.");

            //  Copy SetupLauncher.exe
            wstConfig.srcFile = wstConfig.buildRoot + "\\" + "tools\\SetupLauncher.exe";
            wstConfig.dstFile = wstConfig.dstDir + "\\" + "SetupLauncher.exe";
            if (!File.Exists(wstConfig.dstFile))
            {
                if (File.Exists(wstConfig.srcFile))
                {
                    if (!Directory.Exists(wstConfig.dstDir))
                    {
                        //destination directory is not available, attempt to create it
                        try
                        {
                            Directory.CreateDirectory(wstConfig.dstDir);
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine("FAILED to create directory -> " + wstConfig.dstDir + " with error -> " + e.ToString());
                            return false;
                        }
                    }

                    CopyFile(wstConfig.srcFile, wstConfig.dstFile, true);
                    Console.WriteLine("Copied SetupLauncher.exe.");
                }
                else
                {
                    Console.WriteLine("File \"" + wstConfig.srcFile + "\" not found.  Deployment cannot continue.");
                    return false;
                }
            }

            //Configure catalog to point to RawCatalogDB
            if (wstConfig.environment.ToLower() == EnvironmentNames.livenoob && wstConfig.databaseName.ToLower() == "rawcatalogdb")
            {
                Console.WriteLine("Running post install to Update the Catalog Interface in NPDB");
                Console.WriteLine("!!!WARNING!!! Interface update not functional pending WstRunner.exe change. !!!WARNING!!!");
                
                // TODO:  This needs to be changed to set this data via the configuration service instead of
                // direct SQL manipulation.

                // the configuration service.
                //string appLine = "sqlcmd";
                //string cmdLine = " -S " + wstConfig.npdbServer + " -d " + wstConfig.npdbDatabase + " -b -i " + "\"" + wstConfig.dstDir + "\\UpdateInterface.sql\"";

                //if (!DoExec(appLine, cmdLine))
                //{
                //    return false;
                //}
                //Console.WriteLine("Updated the Catalog Interface in NPDB");
            }

            //
            //  Now we need to add the interface to NPDB
            //
            if (wstConfig.skipInterfaceConfig == "false")
            {
                Console.WriteLine("Configuring interface:");

                string appLine = wstConfig.dstDir + "\\setuplauncher.exe";
                string cmdLine = " /Command AddServerConfigFromDeploymentXml" +
                          " ENVIRONMENT=" + wstConfig.environment +
                          " INTERFACE=" + wstConfig.interfaceName +
                          " COMPONENT=\"\"" +
                          " DEPLOYMENTXML=\"" + wstConfig.dstDir + "\\" + "deployment.xml" + "\"";

                if (!DoExec(appLine, cmdLine))
                {
                    Console.WriteLine("Adding server interface to NPDB failed.");

                    return false;
                }
            }
            else
            {
                Console.WriteLine("Skipping interface configuration.");
            }

            Console.WriteLine("Post process install complete.");

            return true;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\WstRunner\WstRunnerFactory.cs ===
namespace xonline.tools.wstrunner.core
{
    public class WstRunnerFactory : IWstRunnerFactory
    {
        private IOracleFactory oracleFactory = new WebstoreOracleFactory();
        private IManifestFactory manifestFactory = new WmoManifestFactory();
        private IDeploymentFactory deploymentFactory = new WmoDeploymentFactory();
        private IDatabaseTemplateFactory databaseTemplateFactory = new WmoDatabaseTemplateFactory();
        private IFailSafeSetFactory failSafeSetFactory = new WmoFailSafeSetFactory();

        public IOracleFactory OracleFactory
        {
            set { oracleFactory = value; }
        }

        public IManifestFactory ManifestFactory
        {
            set { manifestFactory = value; }
        }

        public IDeploymentFactory DeploymentFactory
        {
            set { deploymentFactory = value; }
        }

        public IDatabaseTemplateFactory DatabaseTemplateFactory
        {
            set { databaseTemplateFactory = value; }
        }

        public IFailSafeSetFactory FailSafeSetFactory
        {
            set { failSafeSetFactory = value; }
        }

        public IWstRunner CreateInstance(
            string workingPath,
            string manifestFile,
            string deploymentFile)
        {
            WstRunner runner = WstRunner.CreateInstance(workingPath, manifestFile, deploymentFile);
            runner.OracleFactory = oracleFactory;
            runner.ManifestFactory = manifestFactory;
            runner.DeploymentFactory = deploymentFactory;
            runner.DatabaseTemplateFactory = databaseTemplateFactory;
            runner.FailSafeSetFactory = failSafeSetFactory;

            return runner;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\WstRunner\WstRunnerUninstall.cs ===
﻿//====================================================
// Uninstall portion of the wst runner command
//
// Parse uninstall command params, run uninstall processing
//=====================================================

using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;

using xonline.tools.wstrunner.core;

namespace xonline.tools.wstrunner.console
{

    public partial class WstRunnerCmd
    {
        /// <summary>
        /// Handles parsing of the command line arguments for uninstall
        /// </summary>
        /// <param name="args">The arguments to process.</param>
        public bool ParseUninstallCommandLine(string[] args)
        {
            int numberOfArgs = args.Length;
            string currentArg;

            for (int currentArgIndex = 2; currentArgIndex < numberOfArgs; currentArgIndex++)
            {
                currentArg = args[currentArgIndex];

                if (String.Compare(currentArg, "/webRootDir", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.webRootDir = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/installDir", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.installDir = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/upgradePath", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.upgradePath = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/databaseName", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.databaseName = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/environment", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.environment = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/deployEnabled", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.deployEnabled = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/computerName", true) == 0)
                {   
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.computerName = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/skipInterfaceConfig", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.skipInterfaceConfig = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/interfaceName", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.interfaceName = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/manifestPath", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.manifestPath = args[++currentArgIndex];
                }
            }

            //Output the name arguments
            Console.WriteLine("webRootDir=           '" + wstConfig.webRootDir + "'");
            Console.WriteLine("installDir=           '" + wstConfig.installDir + "'");
            Console.WriteLine("environment=          '" + wstConfig.environment + "'");
            Console.WriteLine("databaseName=         '" + wstConfig.databaseName + "'");
            Console.WriteLine("upgradePath=          '" + wstConfig.upgradePath + "'");
            Console.WriteLine("deployEnabled=        '" + wstConfig.deployEnabled + "'");
            Console.WriteLine("skipInterfaceConfig=  '" + wstConfig.skipInterfaceConfig + "'");
            Console.WriteLine("interfaceName=        '" + wstConfig.interfaceName + "'");
            // NEW parameter
            Console.WriteLine("computerName=         '" + wstConfig.computerName + "'");  
            Console.WriteLine();

            //check if we have all the required params
            if (wstConfig.webRootDir == null
                || wstConfig.installDir == null
                || wstConfig.upgradePath == null
                || wstConfig.databaseName == null
                || wstConfig.environment == null
                || wstConfig.deployEnabled == null)
            {
                Console.WriteLine("ERROR: Required parameters for UnInstall are missing.");
                Console.WriteLine("Type \"WstRunner /?\" for usage help.");
                return false;
            }

            if (wstConfig.computerName == null)
            {
                wstConfig.computerName = Environment.MachineName;
            }

            return true;
        }

        /// <summary>
        /// Process the command parameter data
        /// </summary>
        /// <returns></returns>
        public bool ProcessUnInstall()
        {
            wstConfig.upgradePath = wstConfig.upgradePath.ToLower();

            if (wstConfig.skipInterfaceConfig == null)
            {
                wstConfig.skipInterfaceConfig = "false";
            }

            if (wstConfig.interfaceName == null || wstConfig.interfaceName.Length == 0)
            {
                wstConfig.interfaceName = wstConfig.databaseName;
            }

            if (wstConfig.manifestPath == null || wstConfig.manifestPath.Length == 0)
            {
                wstConfig.manifestPath = "manifest.xml";
            }

            wstConfig.dstDir = wstConfig.webRootDir + "\\" + wstConfig.installDir;

            if (!Directory.Exists(wstConfig.dstDir))
            {
                Console.WriteLine("WARNING Folder \"" + wstConfig.dstDir + "\" does not exist.");
                //return true;
            }

            if (!UninstallDatabase())
            {
                return false;
            }

            return true;
        }

        public bool UninstallDatabase()
        {
            Console.WriteLine("Attempting to remove any existing deployment bits.");
            Console.WriteLine("Any existing database deployment will be dropped, and");
            Console.WriteLine("the installation folder will be removed.");

            string setupLauncherPath = wstConfig.dstDir + "\\setuplauncher.exe";
            string manifestXml = wstConfig.dstDir + "\\" + wstConfig.manifestPath;
            string deploymentXml = wstConfig.dstDir + "\\deployment.xml";
            string appLine = null;
            string cmdLine = null;

            if (!File.Exists(manifestXml))
            {
                Console.WriteLine("WARNING Uninstall manifest file does not exist ->" + manifestXml);
            }

            if (!File.Exists(deploymentXml))
            {
                Console.WriteLine("WARNING Uninstall deployment file does not exist ->" + deploymentXml);
            }

            if (File.Exists(manifestXml) && File.Exists(deploymentXml) && wstConfig.deployEnabled == "1")
            {
                Console.WriteLine("Commencing uninstall of " + wstConfig.databaseName + ".");
                Console.WriteLine();

                //Catalog has deployment files with Token and needs replacement
                if (wstConfig.environment.ToLower() == EnvironmentNames.livenoob)
                {
                    appLine = wstConfig.dstDir + "\\TokenReplacer.exe";
                    cmdLine = " /inputFile " + "\"" + wstConfig.dstDir + "\\deployment.xml\"" + " /outputFile " + "\"" + wstConfig.dstDir + "\\deployment.xml\"" + " #XBLOB_MACHINE#=" + wstConfig.computerName;

                    if (!DoExec(appLine, cmdLine))
                    {
                        return false;
                    }
                }
                //  In this case we should have a complete old copy, including tools.
                //  Let's try to rollback any existing database before we start.        
                action = WstRunnerAction.Drop;

                if (wstConfig.upgradePath != "prodbase")
                {
                    wstConfig.isUpgrade = true;
                }
                else
                {
                    wstConfig.isUpgrade = false;
                }

                wstConfig.manifestPath = manifestXml;
                wstConfig.deploymentFilename = deploymentXml;

                if (RunDrop() != 0)
                {
                    Console.WriteLine("Failed to uninstall database.");
                    return false;
                }
            }
            
            //  Remove the interface from npdb
            if (File.Exists(setupLauncherPath) &&
                File.Exists(deploymentXml) &&
                wstConfig.skipInterfaceConfig == "false" &&
                wstConfig.deployEnabled == "1")
            {
                appLine = wstConfig.dstDir + "\\SetupLauncher.exe";
                cmdLine = " /Command RemoveServerConfigFromDeploymentXml ENVIRONMENT=" + wstConfig.environment
                                                                                       + " INTERFACE=" + wstConfig.interfaceName
                                                                                       + " COMPONENT=\"\""
                                                                                       + " DEPLOYMENTXML=\"" + wstConfig.dstDir + "\\deployment.xml";
                if (!DoExec(appLine, cmdLine))
                {
                    Console.WriteLine("Failed to remove interface from npdb.");
                    return false;
                }
            }

            if (Directory.GetParent(wstConfig.dstDir).Exists)
            {
                if (Directory.Exists(wstConfig.dstDir))
                {
                    DirectoryInfo DirInfo = new DirectoryInfo(wstConfig.dstDir);

                    if (DirInfo.Exists)
                    {
                        //Clean up file attributes make sure read only is removed 
                        //so we can delete the directory
                        SetFileAttributesNormal(DirInfo);

                        Directory.Delete(wstConfig.dstDir, true);
                        Console.WriteLine("Removed folder \"" + wstConfig.dstDir + "\".");
                    }
                    else
                    {
                        Console.WriteLine("WARNING Directory -> " + wstConfig.dstDir + " did not exist, nothing to delete");
                    }
                }
                else
                {
                    Console.WriteLine("WARNING directory ->" + wstConfig.dstDir + " does not exist for removal");
                }
            }

            Console.WriteLine("uninstall complete.");

            return true;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\WstRunner\WstRunnerDisableAndStopJob.cs ===
﻿//=======================================================================
// DisableAndStopJob portion of the wst runner command
//
// Parse DisableAndStopJob command params, run DisableAndStopJob processing
//=======================================================================

using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;

using xonline.tools.wstrunner.core;

namespace xonline.tools.wstrunner.console
{

    public partial class WstRunnerCmd
    {
        /// <summary>
        /// Handles parsing of the command line arguments for DisableAndStopJobs
        /// </summary>
        /// <param name="args">The arguments to process.</param>
        public bool ParseDisableAndStopJobCommandLine(string[] args)
        {
            int numberOfArgs = args.Length;
            string currentArg;

            for (int currentArgIndex = 2; currentArgIndex < numberOfArgs; currentArgIndex++)
            {
                currentArg = args[currentArgIndex];

                if (String.Compare(currentArg, "/buildRoot", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.buildRoot = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/webRootDir", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.webRootDir = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/installDir", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.installDir = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/sqlJobName", true) == 0)
                {   //REQUIRED
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    wstConfig.sqlJobName = args[++currentArgIndex];
                }

            }

            //Output the name arguments
            Console.WriteLine("buildRoot=            '" + wstConfig.buildRoot + "'");
            Console.WriteLine("webRootDir=           '" + wstConfig.webRootDir + "'");
            Console.WriteLine("installDir=           '" + wstConfig.installDir + "'");
            Console.WriteLine("sqlJobName=           '" + wstConfig.sqlJobName + "'");
            Console.WriteLine();

            //check if we have all the required params
            if (wstConfig.buildRoot == null
                || wstConfig.webRootDir == null
                || wstConfig.installDir == null
                || wstConfig.sqlJobName == null)
            {
                Console.WriteLine("ERROR: Required parameters for Install are missing.");
                Console.WriteLine("Type \"WstRunner /?\" for usage help.");
                return false;
            }

            return true;
        }


        /// <summary>
        /// Process the command parameter data
        /// </summary>
        /// <returns></returns>
        public bool ProcessDisableAndStopJob()
        {
            wstConfig.dstDir = wstConfig.webRootDir + "\\" + wstConfig.installDir;

            if (!Directory.Exists(wstConfig.dstDir))
            {
                Console.WriteLine("Directory \"" + wstConfig.dstDir + "\" does not exist, uninstall is not necessary.");
                return true;
            }

            //Copy over DisableJobs.sql file.
            string srcFile = wstConfig.buildRoot + "\\database\\DisableAndStopJob.sql";
            string dstFile = wstConfig.dstDir + "\\DisbleAndStopJob.sql";

            if (File.Exists(srcFile))
            {
                if (CopyFile(srcFile, dstFile, true))
                {
                    Console.WriteLine("Copied DisableAndStopJob script");
                }
                else
                {
                    Console.WriteLine("Copied of DisableAndStopJob failed from -> " + srcFile + " to -> " + dstFile);
                    return false;
                }
            }
            else
            {
                Console.WriteLine("File \"" + srcFile + "\" not found. Uinstall cannot continue.");
                return false;
            }

            // Disable the sql jobs so that they do not start or will not restart after being stopped
            // Stop any sql jobs that are running.
            string appLine = "sqlcmd";
            string cmdLine = " -S (local) -b -i \"" + dstFile + "\" -v SqlJobName=" + wstConfig.sqlJobName;

            if (!DoExec(appLine, cmdLine))
            {
                Console.WriteLine("ERROR failed to execute DisableAndStopJob script.");
                return false;
            }

            Console.WriteLine("Disabled and stopped sql job " + wstConfig.sqlJobName);

            return true;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\WstRunner\WstRunnerCmd.cs ===
/*******************************************************************
 *    FILE:         WstRunnerCmd.cs
 *
 *    DESCRIPTION:  WstRunner.exe console code.
 *
 *    OWNER:        darrenan
 *
 *    HISTORY:      11-8-2007   - Created 
 *
 *    Copyright <cp> 2008 Microsoft Corporation.  All Rights Reserved.
 *******************************************************************/

using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using System.Diagnostics;

using xonline.tools.wstrunner.core;
using System.Runtime.InteropServices;
using System.ComponentModel;

namespace xonline.tools.wstrunner.console
{
    public class WstRunnerException : Exception
    {
        public WstRunnerException() : base() { }
        public WstRunnerException(string message) : base(message) { }
        public WstRunnerException(string message, Exception innerException) : base(message, innerException) { }        
    }

	/// <summary>
	/// Provides a command line interface to the core WstRunner functionality.
	/// </summary>
	public partial class WstRunnerCmd
	{
        private enum WstRunnerAction
        {
            None,
            Help,
            Setup,
            Drop,
            MarkNeedsRepair,
            Repair
        }

        private WstRunnerAction action = WstRunnerAction.None;
        private IWstRunnerFactory wstRunnerFactory = new WstRunnerFactory();
	    private IDeploymentFileFactory deploymentFactory = new DeploymentFileFactory();
        private IOracleFactory oracleFactory = new WebstoreOracleFactory();
        private readonly Dictionary<string, string> properties = new Dictionary<string, string>();
        private static readonly Log _log = Log.GetInstance();
        private WstRunnerConfig wstConfig = new WstRunnerConfig();

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[MTAThread]
		static int Main(string[] args)
		{
            // Fix for backslash escapes on double quotes
            string commandLine = Environment.CommandLine;
            
            // Replace \" with \\"
            commandLine = commandLine.Replace("\\\"", "\\\\\"");

            // Split string and put back into args array
            string[] splittedArgs = SplitArgs(commandLine);
            args = new string[splittedArgs.Length - 1];
            Array.Copy(splittedArgs, 1, args, 0, args.Length);

            _log.Verbosity = LogLevel.Verbose;
		    _log.OnMessage += loggingEventHandler;
            WstRunnerCmd theCmd = new WstRunnerCmd();

            if (!theCmd.ParseCommandLine(args))
            {
                return 1;
            }

            return 0;
        }

        #region Properties

        public IWstRunnerFactory WstRunnerFactory
        {
            set { wstRunnerFactory = value; }
        }

        public IDeploymentFileFactory DeploymentFactory
        {
            set { deploymentFactory = value; }
        }

        #endregion

        #region Methods
    
        /// <summary>
        /// Handles parsing of the command line arguments, setting member variables 
        /// based on the options and arguments specified.
        /// </summary>
        /// <param name="args">The arguments to process.</param>
        public bool ParseCommandLine(string[] args)
        {
            bool result = false;

            try
            {
                Console.WriteLine();
                Console.WriteLine("WstRunner started processing at " + DateTime.Now);

                int numberOfArgs = args.Length;

                //First argument must be the /job param
                string currentArg = args[0];
                if (String.Compare(currentArg, "/job", true) == 0)
                {
                    VerifyParameter(currentArg, 0, args.Length);
                    wstConfig.jobType = args[1].ToLower();
                }
                else
                {
                    if (String.Compare(currentArg, "/?", true) == 0)
                    {
                        RunHelp();
                        return true;
                    }
                    else
                    {
                        Console.WriteLine("ERROR: /job is required for first parameter.");
                        Console.WriteLine("Type \"WstRunner /?\" for usage help.");
                    }
                    return false;
                }


                //Job types are install, uninstall, ProdRestorePrep, DisableAndStopJob
                switch (wstConfig.jobType)
                {
                    case "install":
                        {
                            result = ParseInstallCommandLine(args);
                            if (result)
                            {
                                result = ProcessInstall();
                            }
#if SUPPORT_POST_PROCESSING
                            if (result)
                            {

                                result = PostProcessInstall();
                            }
#endif // SUPPORT_POST_PROCESSING

                        } break;

                    case "uninstall":
                        {
                            result = ParseUninstallCommandLine(args);
                            if (result)
                            {
                                result = ProcessUnInstall();
                            }
                        } break;

                    case "ProdRestorePrep":
                        {
                            result = ParseProdRestorePrepCommandLine(args);
                            if (result)
                            {
                                result = ProcessProdRestorePrep();
                            }
                        } break;

                    case "DisableAndStopJob":
                        {
                            result = ParseDisableAndStopJobCommandLine(args);
                            if (result)
                            {
                                result = ProcessDisableAndStopJob();
                            }
                        } break;

                    default:
                        {
                            Console.WriteLine("ERROR: A valid job type is required.");
                            Console.WriteLine("Type \"WstRunner /?\" for usage help.");
                        } break;
                }
            }
            catch (WstRunnerException)
            {
                result = false;
            }

            return result;
        }

        private static void VerifyParameter(string currentArg, int currentArgIndex, int numberOfArgs)
        {
            if (currentArgIndex + 1 >= numberOfArgs)
            {
                Console.WriteLine("ERROR: Option " + currentArg + " requires a value to be specified.");
                Console.WriteLine("Type \"WstRunner /?\" for usage help.");
                throw new WstRunnerException();
            }
        }

        /// <summary>
        /// Displays information about this program and its command line agruments. 
        /// </summary>
        public void ShowUsageInfo()
        {
            //                |----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
            Console.WriteLine("WstRunner /job install ");
            Console.WriteLine("WstRunner /job uninstall ");
            Console.WriteLine("WstRunner /job ProdRestorePrep ");
            Console.WriteLine("WstRunner /job DisableAndStopJob ");
            Console.WriteLine();
            Console.WriteLine("Description:");
            Console.WriteLine("    Installs or uninstalls the webstore application defined by the manifest");
            Console.WriteLine("    file.");
            Console.WriteLine("    All files needed for the deployment are assumed to be in the same");
            Console.WriteLine("    directory as the manifest file.  If the manifestFile does not contain");
            Console.WriteLine("    directory information, then the current directory will be used.");
            Console.WriteLine();
            Console.WriteLine("Parameter List:");
            Console.WriteLine("     [install]");
            Console.WriteLine("         /buildRoot     [required]   [Location of the build to install]");
            Console.WriteLine("         /webRootDir    [required]   [Root directory of the installation.]");
            Console.WriteLine("         /installDir    [required]   [Root directory for this component.]");
            Console.WriteLine("         /environment   [required]   [Environment being installed to.]");
            Console.WriteLine("         /databaseName  [required]   [Database being installed.]");
            Console.WriteLine("         /upgradePath   [required]   [Is this a database upgrade operation?]");
            Console.WriteLine("         /deployEnabled [required]   [Should webstore deployment occur?]");
            Console.WriteLine("         /configSvcUri               [Path to the configuration service.]");
            Console.WriteLine("         /logRootDir                 [Application log files directory. (XBLOB)]");
            Console.WriteLine("         /userAccount                [User Account.]");
            Console.WriteLine("         /adminAccount               [Admin Account.]");
            Console.WriteLine("         /dataFilesDir               [Database data files directory.]");
            Console.WriteLine("         /logFilesDir                [Database log files directory.]");
            Console.WriteLine("         /dataServerList             [Semi-colon separated list of database servers.]");
            Console.WriteLine("         /partitionCount             [Number of logical partitions.]");
            Console.WriteLine("         /failSafeSetsPerServer      [Number of fail safe sets to create on each physical server.  Default is 1.]");
            Console.WriteLine("         /accountRoleMap             [Account to role mappings.  If not provided, defaults to 'userAccount=ClientLib']");
            Console.WriteLine("         /skipInterfaceConfig        [Pass in 'true' if you don't want interface configuration to happen.]");
            Console.WriteLine("         /interfaceName              [Pass in the interface name to be configured]");
            Console.WriteLine("         /manifestPath               [Pass in the name of the webstore manifest file]");
            Console.WriteLine("         /rollingUpgrade             [Is this a rolling upgrade or not?]");
            Console.WriteLine();
            Console.WriteLine("     [uninstall]");
            Console.WriteLine("         /webRootDir    [required]   [Root directory of the installation.]");
            Console.WriteLine("         /installDir    [required]   [Root directory for this component.]");
            Console.WriteLine("         /upgradePath   [required]   [Is this a database upgrade operation?]");
            Console.WriteLine("         /databaseName  [required]   [Database being installed.]");
            Console.WriteLine("         /environment   [required]   [Environment being installed to.]");
            Console.WriteLine("         /skipInterfaceConfig        [Pass in 'true' if you don't want interface configuration to happen.]");
            Console.WriteLine("         /deployEnabled [required]   [Should webstore deployment occur?]");
            Console.WriteLine("         /interfaceName              [Pass in the interface name to be configured]");
            Console.WriteLine("         /manifestPath               [Pass in the name of the webstore manifest file]");
            Console.WriteLine();
            Console.WriteLine("     [ProdRestorePrep]");
            Console.WriteLine("         /buildRoot     [required]   [Location of the build to install]");
            Console.WriteLine("         /webRootDir    [required]   [Root directory of the installation.]");
            Console.WriteLine("         /installDir    [required]   [Root directory for this component.]");
            Console.WriteLine("         /environment   [required]   [Environment being installed to.]");
            Console.WriteLine("         /databaseName  [required]   [Database being installed.]");
            Console.WriteLine("         /upgradePath   [required]   [Is this a database upgrade operation?]");
            Console.WriteLine("         /bakFile       [required]   [Back up file location.]");
            Console.WriteLine("         /userAccount   [required]   [User Account.]");
            Console.WriteLine("         /prodPath      [required]   [Foler name for the Prodbase.]");
            Console.WriteLine("         /manifestPath               [Pass in the name of the webstore manifest file]");
            Console.WriteLine();
            Console.WriteLine("     [DisableAndStopJob]");
            Console.WriteLine("         /webRootDir    [required]   [Root directory of the installation.]");
            Console.WriteLine("         /installDir    [required]   [Root directory for this component.]");
            Console.WriteLine("         /buildRoot     [required]   [Location of the build to install]");
            Console.WriteLine("         /sqlJobName    [required]   [The name of the sql job to disable and stop.]");
            Console.WriteLine();
            Console.WriteLine("Examples:");
            Console.WriteLine("    WstRunner /job install /buildRoot [SourceLocation] /webRootDir [Webroot]");             
            Console.WriteLine("              /installDir npdb_upgrade /databaseName npdb /environment xblob /upgradePath upgrade /userAccount [userAccount]"); 
            Console.WriteLine("              /adminAccount [adminAccount] /dataFilesDir [SqlDataDir] /logFilesDir [logFileDir]");
            Console.WriteLine("              /dataServerList HXXBLOBLKG001 /partitionCount 24 /deployEnabled 1 /configSvcUri http://[computerName]"); 
            Console.WriteLine("              /logRootDir [logRootDir] /skipInterfaceConfig true");
            Console.WriteLine();
            //                |----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
        }

        /// <summary>
        /// Creates a WstRunnerStep object, configuring it based on the command line arguments,
        /// and executes it. 
        /// </summary>
        /// <returns>
        /// The errorlevel value that should be returned to the cmd environment.
        /// Returns 0 on success, 2 on failure. 
        ///</returns>
        public int RunIt()
        {
            Console.WriteLine();
            Console.WriteLine("WstRunner started processing at " + DateTime.Now);

            switch(action)
            {
                case WstRunnerAction.Setup:
                    return RunSetup();

                case WstRunnerAction.Drop:
                    return RunDrop();

                case WstRunnerAction.MarkNeedsRepair:
                    return MarkNeedsRepair();


                case WstRunnerAction.Repair:
                    return Repair();

                default:
                    return RunHelp();
            }
        }

        private int Repair()
        {
            FileInfo manifestFileInfo = new FileInfo(Path.Combine(wstConfig.dstDir, wstConfig.manifestPath));
            FileInfo deploymentFileInfo = new FileInfo(Path.Combine(wstConfig.dstDir, wstConfig.deploymentFilename));

            Console.WriteLine("     Manifest File = \"" + manifestFileInfo.FullName + "\"");
            Console.WriteLine("     Deployment File = \"" + deploymentFileInfo.FullName + "\"");
            Console.WriteLine();

            string workingPath;

            if (manifestFileInfo.DirectoryName.Length != 0 && Directory.Exists(manifestFileInfo.DirectoryName))
            {
                workingPath = manifestFileInfo.DirectoryName;
            }
            else if (deploymentFileInfo.DirectoryName.Length != 0 &&
                     Directory.Exists(deploymentFileInfo.DirectoryName))
            {
                workingPath = deploymentFileInfo.DirectoryName;
            }
            else
            {
                workingPath = Environment.CurrentDirectory;
            }

            IWstRunner runner = wstRunnerFactory.CreateInstance(
                    workingPath,
                    manifestFileInfo.Name,
                    deploymentFileInfo.Name);
            try
            {

                runner.RepairwithOnlinePromote();
            }

            catch (Exception e)
            {
                Console.WriteLine();
                Console.WriteLine();
                Console.WriteLine("ERROR: Exception encountered executing WstRunner. - " + e.Message);
                Console.WriteLine();
                Console.WriteLine();
                Console.WriteLine(e.ToString());
                Console.WriteLine();

                return 2;
            }
                Console.WriteLine();
                Console.WriteLine("WstRunner processing of '" + wstConfig.manifestPath + "' completed at " + DateTime.Now);
                Console.WriteLine();
                return 0;
            
        }
        /// <summary>
        /// Marks the databases as Needsrepair starting from secondary to primary
        /// </summary>
        /// <returns></returns>
        private int MarkNeedsRepair()
        {
            FileInfo manifestFileInfo = new FileInfo(Path.Combine(wstConfig.dstDir, wstConfig.manifestPath));
            FileInfo deploymentFileInfo = new FileInfo(Path.Combine(wstConfig.dstDir, wstConfig.deploymentFilename));

            Console.WriteLine("     Manifest File = \"" + manifestFileInfo.FullName + "\"");
            Console.WriteLine("     Deployment File = \"" + deploymentFileInfo.FullName + "\"");
            Console.WriteLine();

            string workingPath;

            if (manifestFileInfo.DirectoryName.Length != 0 && Directory.Exists(manifestFileInfo.DirectoryName))
            {
                workingPath = manifestFileInfo.DirectoryName;
            }
            else if (deploymentFileInfo.DirectoryName.Length != 0 &&
                     Directory.Exists(deploymentFileInfo.DirectoryName))
            {
                workingPath = deploymentFileInfo.DirectoryName;
            }
            else
            {
                workingPath = Environment.CurrentDirectory;
            }
            

            IWstRunner runner = wstRunnerFactory.CreateInstance(
                    workingPath,
                    manifestFileInfo.Name,
                    deploymentFileInfo.Name);

            try
            {
                runner.MarkNeedsRepair();
            }

            catch (Exception e)
            {
                Console.WriteLine();
                Console.WriteLine();
                Console.WriteLine("ERROR: Exception encountered executing WstRunner. - " + e.Message);
                Console.WriteLine();
                Console.WriteLine();
                Console.WriteLine(e.ToString());
                Console.WriteLine();

                return 2;
            }
           
                Console.WriteLine();
                Console.WriteLine("WstRunner processing of '" + wstConfig.manifestPath + "' completed at " + DateTime.Now);
                Console.WriteLine();
                return 0;
        }

        private int RunSetup()
        {
            string workingPath;
            FileInfo manifestFileInfo;
            FileInfo deploymentFileInfo;

            if (wstConfig.manifestPath == null || wstConfig.manifestPath.Length == 0)
            {
                Console.WriteLine("Manifest file name was not provided.  Exiting.");
                return 2;
            }

            manifestFileInfo = new FileInfo(Path.Combine(wstConfig.srcDir, wstConfig.manifestPath));
            Console.WriteLine("     Manifest File = \"" + wstConfig.manifestPath + "\"");

            if (wstConfig.deploymentFilename == null || wstConfig.deploymentFilename.Length == 0)
            {
                wstConfig.deploymentFilename = Path.Combine(Path.GetDirectoryName(wstConfig.dstDir + "\\" + wstConfig.databaseName), "deployment.xml");
            }
            Console.WriteLine("     Deployment File = \"" + wstConfig.deploymentFilename + "\"");

            deploymentFileInfo = new FileInfo(wstConfig.deploymentFilename);

            if (!deploymentFileInfo.Exists)
            {

                if (wstConfig.environment.ToLower() == EnvironmentNames.livenoob)
                {
                    Console.WriteLine("    Deployment File for xblob environment does not exist, auto-generating it now.");

                    deploymentFileInfo = deploymentFactory.CreateDeployment(
                        manifestFileInfo,
                        deploymentFileInfo.FullName,
                        wstConfig.dataFilesDir,          //properties["dataFilePath"],
                        wstConfig.logFilesDir,           //properties["logFilePath"],
                        wstConfig.computerName,          //properties["configServerList"],
                        wstConfig.dataServerList,        //properties["dataServerList"],
                        wstConfig.failSafeSetsPerServer, //properties.ContainsKey("failSafeSetsPerServer") ? UInt32.Parse(properties["failSafeSetsPerServer"]) : 1,
                        wstConfig.accountRoleMap,        //properties["accountRoleMap"],
                        wstConfig.partitionCount,        //UInt32.Parse(properties["partitionCount"]),
                        wstConfig.databaseName);         //properties["databaseName"]);
                }

                if (deploymentFileInfo == null || !deploymentFileInfo.Exists)
                {
                    Console.WriteLine("Deployment File does not exist.  Exiting.");
                    return 2;
                }
            }

            //we need to get the manifest into the same directory as the deployment file
            //so that the working path for both files is the same
            if (manifestFileInfo.Exists)
            {
                if (!File.Exists(deploymentFileInfo.DirectoryName + "\\" + manifestFileInfo.Name))
                {
                    //CopyFile(manifestFileInfo.FullName, Path.Combine(deploymentFileInfo.DirectoryName, manifestFileInfo.Name));
                    Console.WriteLine("Manifest file did not get copied to -> " + deploymentFileInfo.DirectoryName + "\\" + manifestFileInfo.Name);
                    return 2;
                }
            }

            workingPath = deploymentFileInfo.DirectoryName;

            try
            {
                IWstRunner runner = wstRunnerFactory.CreateInstance(
                    workingPath,
                    manifestFileInfo.Name,
                    deploymentFileInfo.Name);

                runner.Setup(wstConfig.setAction, wstConfig.isRollingUpgrade, wstConfig.replTearDown);
            }
            catch (Exception e)
            {
                Console.WriteLine();
                Console.WriteLine();
                Console.WriteLine("ERROR: Exception encountered executing WstRunner. - " + e.Message);
                Console.WriteLine();
                Console.WriteLine();
                Console.WriteLine(e.ToString());
                Console.WriteLine();

                return 2;
            }

            Console.WriteLine();
            Console.WriteLine("WstRunner processing of '" + wstConfig.manifestPath + "' completed at " + DateTime.Now);
            Console.WriteLine();
            return 0;
        }

        private int RunDrop()
        {
            try
            {
                Console.WriteLine("     Manifest File = \"" + wstConfig.manifestPath + "\"");
                Console.WriteLine("     Deployment File = \"" + wstConfig.deploymentFilename + "\"");
                Console.WriteLine();

                FileInfo manifestFileInfo = new FileInfo(wstConfig.manifestPath);

                if (wstConfig.deploymentFilename == null)
                {
                    wstConfig.deploymentFilename = "deployment.xml";
                }

                FileInfo deploymentFileInfo = new FileInfo(wstConfig.deploymentFilename);
                string workingPath;

                if (manifestFileInfo.DirectoryName.Length != 0 && Directory.Exists(manifestFileInfo.DirectoryName))
                {
                    workingPath = manifestFileInfo.DirectoryName;
                }
                else if (deploymentFileInfo.DirectoryName.Length != 0 &&
                         Directory.Exists(deploymentFileInfo.DirectoryName))
                {
                    workingPath = deploymentFileInfo.DirectoryName;
                }
                else
                {
                    workingPath = Environment.CurrentDirectory;
                }

                IWstRunner runner = wstRunnerFactory.CreateInstance(
                    workingPath,
                    manifestFileInfo.Name,
                    deploymentFileInfo.Name);

                if (wstConfig.upgradePath != "prodbase")
                {
                    wstConfig.isUpgrade = true;
                }
                else
                {
                    wstConfig.isUpgrade = false;
                }

                runner.Remove(!wstConfig.isUpgrade);
            }
            catch(Exception e)
            {
                Console.WriteLine();
                Console.WriteLine();
                Console.WriteLine("ERROR: Exception encountered executing WstRunner. - " + e.Message);
                Console.WriteLine();
                Console.WriteLine();
                Console.WriteLine(e.ToString());
                return 2;
            }

            Console.WriteLine();
            Console.WriteLine("WstRunner processing completed at " + DateTime.Now);
            Console.WriteLine();
            return 0;
        }

        private int RunHelp()
        {
            ShowUsageInfo();
            return 0;
        }

        /// <summary>
        /// Event handler for WstRunnerStep's Message event which writes the message to the console.
        /// </summary>
        /// <param name="sender">The WstRunnerStep generating the event.</param>
        /// <param name="e">The MessageEventArgs sent by the event.</param>
        public static void loggingEventHandler(object sender, LoggingEventArgs e)
        {
            if(e == null)
                return;

            Console.WriteLine(e.Message);
        }

        /// <summary>
        /// Returns a list of the versions of the fail safe sets for the specified deployment
        /// </summary>
        /// <param name="deploymentName">The list of fail safe set version numbers or null if deploymentName references a non-existent deployment</param>
        /// <returns></returns>
        public WstRunnerConfig.WSTVersion GetVersionOfInProgressDeployment(string deploymentName)
        {            
            IOracle oracle = oracleFactory.CreateInstanceWithoutRefresh();
            if (!oracle.IsDeploymentImported(deploymentName))
                return null;

            WstRunnerConfig.WSTVersion returnVersion = null;

            string outputFile = Path.GetTempFileName();
            FileInfo deploymentStatusFileInfo = oracle.ExportDeploymentStatus(deploymentName, outputFile, false);

            if (deploymentStatusFileInfo != null && deploymentStatusFileInfo.Exists)
            {
                XmlDocument xmlDep = new XmlDocument();

                xmlDep.Load(deploymentStatusFileInfo.FullName);

                XmlNode manifestVersionNode = xmlDep.SelectSingleNode("Webstore/DeploymentStatus/Deployment/@ManifestVersion");
                if (manifestVersionNode != null)
                {
                    bool allVersionsConsistent = true;
                    XmlNodeList failSafeSetVersionNodes = xmlDep.SelectNodes("Webstore/DeploymentStatus/Deployment/SqlFailSafeSets/SqlFailSafeSet/@ManifestVersion");
                    foreach (XmlNode versionNode in failSafeSetVersionNodes)
                    {
                        if (versionNode.Value != manifestVersionNode.Value)
                            allVersionsConsistent = false;
                    }

                    if (!allVersionsConsistent) 
                    {
                        //format as version
                        string[] verComp = manifestVersionNode.Value.Split('.');

                        if (verComp.Length != 4)
                        {
                            Console.WriteLine("Fail Safe Version string \"" + manifestVersionNode.InnerText + "\" does not have four components.  Version strings must be in the form major.minor.build.dot.");
                        }
                        returnVersion = new WstRunnerConfig.WSTVersion();
                        returnVersion.major = Convert.ToInt32(verComp[0]);
                        returnVersion.minor = Convert.ToInt32(verComp[1]);
                        returnVersion.build = Convert.ToInt32(verComp[2]);
                        returnVersion.dot = Convert.ToInt32(verComp[3]);
                        returnVersion.strVersion = manifestVersionNode.Value;
                    }
                }
            }

            return returnVersion;
        }

        public WstRunnerConfig.WSTVersion GetVersionFromManifest(string manifestFileName)
        {
            XmlDocument xmlDoc = new XmlDocument();

            if (!File.Exists(manifestFileName))
            {
                Console.WriteLine("ERROR manifest file ->" + manifestFileName + " not found");
                return null;
            }

            xmlDoc.Load(manifestFileName);

            XmlNodeList nList = xmlDoc.GetElementsByTagName("Version");
            WstRunnerConfig.WSTVersion manifestVersion = null;
            if (nList.Count > 0)
            {
                //format as version
                string[] verComponents = nList[0].InnerText.Split('.');

                if (verComponents.Length != 4)
                {
                    Console.WriteLine("Manifest Version string \"" + nList[0].InnerText + "\" does not have four components.  Version strings must be in the form major.minor.build.dot.");
                    return null;
                }

                manifestVersion = new WstRunnerConfig.WSTVersion();

                manifestVersion.major = Convert.ToInt32(verComponents[0]);
                manifestVersion.minor = Convert.ToInt32(verComponents[1]);
                manifestVersion.build = Convert.ToInt32(verComponents[2]);
                manifestVersion.dot   = Convert.ToInt32(verComponents[3]);
                manifestVersion.strVersion = nList[0].InnerText;
            }

            return manifestVersion;
        }

        public WstRunnerConfig.WSTVersion GetVersionFromDeployment(string deploymentName)
        {
            IOracle oracle = oracleFactory.CreateInstanceWithoutRefresh();

            if (!oracle.IsDeploymentImported(deploymentName))
                return null;

            string deploymentVersionString = oracle.GetVersionForDeployment(deploymentName);
            string[] verComponents = oracle.GetVersionForDeployment(deploymentName).Split('.');

            if (verComponents.Length != 4)
            {
                Console.WriteLine("Deployment Version string \"" + deploymentVersionString + "\" does not have four components.  Version strings must be in the form major.minor.build.dot.");
                return null;
            }

            WstRunnerConfig.WSTVersion deploymentVersion = new WstRunnerConfig.WSTVersion();

            deploymentVersion.major = Convert.ToInt32(verComponents[0]);
            deploymentVersion.minor = Convert.ToInt32(verComponents[1]);
            deploymentVersion.build = Convert.ToInt32(verComponents[2]);
            deploymentVersion.dot = Convert.ToInt32(verComponents[3]);
            deploymentVersion.strVersion = deploymentVersionString;

            return deploymentVersion;
        }

        /// <summary>
        /// For shelling out and running external programs
        /// </summary>
        /// <param name="appLine"></param>
        /// <param name="cmdLine"></param>
        /// <returns></returns>
        public bool DoExec(string appLine, string cmdLine)
        {
            appLine = appLine.Trim();

            Console.WriteLine(appLine + cmdLine);
            Console.WriteLine();

            try
            {
                ProcessStartInfo startInfo = new ProcessStartInfo(appLine, cmdLine);
                startInfo.UseShellExecute = true;

                using (Process exeProcess = Process.Start(startInfo))
                {
                    exeProcess.WaitForExit();
                }
            }
            catch (System.IO.FileNotFoundException e)
            {
                Console.WriteLine("ERROR file not found -> " + appLine + " e -> " + e.Message.ToString());
                return false;
            }
            catch (Exception e)
            {
                Console.WriteLine("ERROR trying to execute -> " + appLine + " with these params -> " + cmdLine);
                Console.WriteLine(e.ToString());
                return false;
            }

            return true;
        }

        public bool CopyFile(string src, string dst)
        {
            return CopyFile(src, dst, false);
        }

        public bool CopyFile(string src, string dst, bool overWrite)
        {
            try
            {
                if (!Directory.Exists(dst))
                    Directory.CreateDirectory(Path.GetDirectoryName(dst));

                File.Copy(src, dst, overWrite);
            }
            catch (Exception e)
            {
                Console.WriteLine("Failed to copy \"" + src + "\" to \"" + dst + "\". Exception = \"" + e.Message.ToString() + "\".");
                throw new WstRunnerException();
            }

            return true;
        }

        public bool CopyDirectories(string src, string dst, bool overwrite)
        {
            try
            {
                if (!Directory.Exists(dst))
                {
                    Directory.CreateDirectory(dst);
                }

                string[] files = Directory.GetFiles(src);

                foreach (string file in files)
                {
                    string name = Path.GetFileName(file);
                    string dest = Path.Combine(dst, name);
                    File.Copy(file, dest, overwrite);
                }
                string[] folders = Directory.GetDirectories(src);

                foreach (string folder in folders)
                {
                    string name = Path.GetFileName(folder);
                    string dest = Path.Combine(dst, name);
                    CopyDirectories(folder, dest, overwrite);
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Failed to copy \"" + src + "\" to \"" + dst + "\". Exception = \"" + e.Message.ToString() + "\".");
                return false;
            }

            return true;
        }

        /// <summary>
        /// Iterate through a directory and remove all read only
        /// and hidden attributes
        /// </summary>
        /// <param name="dir"></param>
        public void SetFileAttributesNormal(DirectoryInfo dir)
        {
            // Remove flags from the current directory
            dir.Attributes = FileAttributes.Normal;

            // Remove flags from all files in the current directory
            foreach (FileInfo file in dir.GetFiles())
            {
                file.Attributes = FileAttributes.Normal;
            }

            // Do the same for all subdirectories
            foreach (DirectoryInfo subDir in dir.GetDirectories())
            {
                SetFileAttributesNormal(subDir);
            }
        }


        /// <summary>
        /// This function return -1, 0, or 1 depending
        /// on the two versions.  0 means they are equal.
        /// </summary>
        /// <param name="version1"></param>
        /// <param name="version2"></param>
        /// <returns></returns>
        public int compare(WstRunnerConfig.WSTVersion version1, WstRunnerConfig.WSTVersion version2)
        {
            if (version1.major < version2.major) return -1;
            if (version1.major > version2.major) return 1;
            if (version1.minor < version2.minor) return -1;
            if (version1.minor > version2.minor) return 1;
            if (version1.build < version2.build) return -1;
            if (version1.build > version2.build) return 1;
            if (version1.dot < version2.dot) return -1;
            if (version1.dot > version2.dot) return 1;
            return 0;    
        }

        static string[] SplitArgs(string unsplitArgumentLine)
        {
            int numberOfArgs;
            IntPtr ptrToSplitArgs;
            string[] splitArgs;

            ptrToSplitArgs = CommandLineToArgvW(unsplitArgumentLine, out numberOfArgs);

            // CommandLineToArgvW returns NULL upon failure.
            if (ptrToSplitArgs == IntPtr.Zero)
                throw new ArgumentException("Unable to split argument.", new Win32Exception());

            // Make sure the memory ptrToSplitArgs to is freed, even upon failure.
            try
            {
                splitArgs = new string[numberOfArgs];

                // ptrToSplitArgs is an array of pointers to null terminated Unicode strings.
                // Copy each of these strings into our split argument array.
                for (int i = 0; i < numberOfArgs; i++)
                    splitArgs[i] = Marshal.PtrToStringUni(
                        Marshal.ReadIntPtr(ptrToSplitArgs, i * IntPtr.Size));

                return splitArgs;
            }
            finally
            {
                // Free memory obtained by CommandLineToArgW.
                LocalFree(ptrToSplitArgs);
            }
        }

        [DllImport("shell32.dll", SetLastError = true)]
        static extern IntPtr CommandLineToArgvW(
           [MarshalAs(UnmanagedType.LPWStr)] string lpCmdLine,
           out int pNumArgs);

        [DllImport("kernel32.dll")]
        static extern IntPtr LocalFree(IntPtr hMem);

        #endregion

        #region Properties

	    public string ManifestFileName
	    {
            get { return wstConfig.manifestPath; }
	    }

	    public string DeploymentFileName
	    {
            get { return wstConfig.deploymentFilename; }
	    }

	    public IDictionary<string,string> Properties
	    {
	        get { return properties; }
	    }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\WstRunner\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("WstRunner")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft")]
//[assembly: AssemblyProduct("WstRunner")]
//[assembly: AssemblyCopyright("Copyright © Microsoft 2010")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("552060c3-6149-4c93-b21e-911a833ae1d2")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\WstRunner\Properties\Resources.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace xonline.tools.wstrunner.core.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("xonline.tools.wstrunner.core.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &lt;Account Name=&quot;#ACCOUNT_NAME#&quot; xmlns=&quot;urn:WebstoreDeploymentSchema.xsd&quot;&gt;
        ///    &lt;Role&gt;#ROLE_NAME#&lt;/Role&gt;
        ///&lt;/Account&gt;
        ///.
        /// </summary>
        internal static string account_template {
            get {
                return ResourceManager.GetString("account_template", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &lt;Database Name=&quot;#DATABASE_NAME#&quot; DataServer=&quot;#SERVER_NAME#&quot; xmlns=&quot;urn:WebstoreDeploymentSchema.xsd&quot;&gt;
        ///    &lt;Status&gt;NotDeployed&lt;/Status&gt;
        ///    &lt;DefaultStatus&gt;Online&lt;/DefaultStatus&gt;
        ///&lt;/Database&gt;
        ///.
        /// </summary>
        internal static string database_template {
            get {
                return ResourceManager.GetString("database_template", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &lt;DataPartition Number=&quot;#PARTITION_NUMBER#&quot; xmlns=&quot;urn:WebstoreDeploymentSchema.xsd&quot;&gt;
        ///    &lt;SqlFailSafeSetNumber&gt;#FSS_NUMBER#&lt;/SqlFailSafeSetNumber&gt;
        ///    &lt;Status&gt;ReadWrite&lt;/Status&gt;
        ///&lt;/DataPartition&gt;
        ///.
        /// </summary>
        internal static string datapartition_template {
            get {
                return ResourceManager.GetString("datapartition_template", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &lt;Webstore xmlns=&quot;urn:WebstoreDeploymentSchema.xsd&quot;&gt;
        ///    &lt;DatabaseTemplates&gt;
        ///        &lt;DatabaseTemplate Name=&quot;#DATABASE_TEMPLATE_NAME#&quot;&gt;
        ///            &lt;Description/&gt;
        ///            &lt;IsDistributionOnly&gt;false&lt;/IsDistributionOnly&gt;
        ///            &lt;DataFileGroups&gt;
        ///                &lt;FileGroup Name=&quot;Primary&quot;&gt;
        ///                    &lt;LogicalFiles&gt;
        ///                        &lt;LogicalFile Name=&quot;DataFile&quot;&gt;
        ///                            &lt;Path&gt;#DATA_FILE_PATH#&lt;/Path&gt;
        ///                            &lt;Size&gt;100MB&lt;/Size&gt;
        ///               [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string deployment_template {
            get {
                return ResourceManager.GetString("deployment_template", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &lt;Server Name=&quot;#SERVER_NAME#&quot; ClusterName=&quot;DefaultCluster&quot; xmlns=&quot;urn:WebstoreDeploymentSchema.xsd&quot;&gt;
        ///    &lt;DataCenter Name=&quot;DefaultDataCenter&quot; /&gt;
        ///    &lt;DistributionDatabaseTemplate Name=&quot;#DISTRIBUTION_TEMPLATE_NAME#&quot; /&gt;
        ///    &lt;ServerRoles&gt;
        ///        &lt;ServerRole&gt;#SERVER_ROLE#&lt;/ServerRole&gt;
        ///    &lt;/ServerRoles&gt;
        ///&lt;/Server&gt;
        ///.
        /// </summary>
        internal static string server {
            get {
                return ResourceManager.GetString("server", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to &lt;SqlFailSafeSet Number=&quot;&quot; xmlns=&quot;urn:WebstoreDeploymentSchema.xsd&quot;&gt;
        ///    &lt;DatabaseTemplate Name=&quot;#DATABASE_TEMPLATE_NAME#&quot; /&gt;
        ///    &lt;Databases&gt;
        ///    &lt;/Databases&gt;
        ///    &lt;DefaultPrimaryDatabase Database=&quot;#DATABASE_NAME#&quot; DataServer=&quot;#PRIMARY_SERVER_NAME#&quot; /&gt;
        ///    &lt;PrimaryDatabase Database=&quot;#DATABASE_NAME#&quot; DataServer=&quot;#PRIMARY_SERVER_NAME#&quot; /&gt;
        ///&lt;/SqlFailSafeSet&gt;
        ///.
        /// </summary>
        internal static string sqlfailsafeset_template {
            get {
                return ResourceManager.GetString("sqlfailsafeset_template", resourceCulture);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\XmlSequencer\InMemoryMessageLog.cs ===
using System;
using System.Collections;

namespace Leet.Tools.Setup.XmlSequencer
{
    /// <summary>
    /// Provides a MessageLog helper class that stores XmlSequencer generated messages to an
    /// ArrayList.
    /// </summary>
    public class InMemoryMessageLog
    {
        private RootStepContainer rootContext = null;

        /// <summary>
        /// The array of messages that have been captured.
        /// </summary>
        public ArrayList Messages = new ArrayList();

        private void myRoot_OnMessage(object sender, MessageEventArgs e)
        {
            Messages.Add(e.Message);
        }

        /// <summary>
        /// Connects the MessageLog to the passed RootStepContainer and starts
        /// the collecting of messages. Any current messages will be discarded.
        /// </summary>
        /// <param name="root">The RootStepContainer to start collecting messages from.</param>
        public void StartListening(RootStepContainer root)
        {
            if (rootContext != null)
            {
                StopListening();
            }

            rootContext = root;

            Messages.Clear();
            rootContext.OnMessage += new MessageEventHandler(myRoot_OnMessage);
        }

        /// <summary>
        /// Stops this message log from collecting any more messages from the current source.
        /// </summary>
        public void StopListening()
        {
            if (rootContext != null)
            {
                rootContext.OnMessage -= new MessageEventHandler(myRoot_OnMessage);
            }
            
            rootContext = null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\XmlSequencer\ElementTypeMapping.cs ===
using System;
using System.Collections;

namespace Leet.Tools.Setup.XmlSequencer
{
    /// <summary>
    /// 
    /// </summary>
	public class ElementTypeMapping : DictionaryBase  
	{
        /// <summary>
        /// 
        /// </summary>
        public System.Type this[ String key ]  
		{
			get  
			{
				return( (System.Type) Dictionary[key] );
			}
			set  
			{
				Dictionary[key] = value;
			}
		}

        /// <summary>
        /// 
        /// </summary>
		public ICollection Keys  
		{
			get  
			{
				return( Dictionary.Keys );
			}
		}

        /// <summary>
        /// 
        /// </summary>
		public ICollection Values  
		{
			get  
			{
				return( Dictionary.Values );
			}
		}

        /// <summary>
        /// 
        /// </summary>
        /// <param name="key"></param>
        /// <param name="value"></param>
		public void Add( String key, System.Type value )  
		{
			Dictionary.Add( key, value );
		}

        /// <summary>
        /// 
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
		public bool Contains( String key )  
		{
			return( Dictionary.Contains( key ) );
		}

        /// <summary>
        /// 
        /// </summary>
        /// <param name="key"></param>
		public void Remove( String key )  
		{
			Dictionary.Remove( key );
		}

        /// <summary>
        /// 
        /// </summary>
        /// <param name="key"></param>
        /// <param name="value"></param>
		protected override void OnValidate( Object key, Object value )  
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}

			if ( key.GetType() != Type.GetType("System.String") )
			{
				throw new ArgumentException( "key must be of type String.", "key" );
			}

			if (value == null)
			{
				throw new ArgumentNullException("value");
			}

			System.Type testType = Type.GetType("System.Type");
			if ( !testType.IsAssignableFrom(value.GetType()))
			{
				throw new ArgumentException( "value must be of type System.Type.", "value" );
			}

			testType = Type.GetType("Leet.Tools.Setup.XmlSequencer.Step");
			if (!testType.IsAssignableFrom((System.Type) value))
			{
				throw new ArgumentException( "The type passed must be derrived from Leet.Tools.Setup.XmlSequencer.Step.", "value" );
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\XmlSequencer\ConfigurationStore.cs ===
using System;
using System.Collections.Generic;
using Microsoft.Win32;

namespace Leet.Tools.Setup.XmlSequencer
{
    /// <summary>
    /// Provides a mechanism to record and persist items used in configuration transforms and then later
    /// perform configuration transforms based on the persisted values.
    /// Typically used to record values during an installation so the same values will be available when
    /// doing an uninstall.
    /// </summary>
    public class ConfigurationStore
    {
        private List<string> registryPath = new List<string>() { "SOFTWARE", "Microsoft", "XboxLive" };

        public ConfigurationStore(string applicationName, string instanceName)
        {
            if (String.IsNullOrEmpty(applicationName))
            {
                throw new ArgumentNullException("applicationName");
            }

            if (String.IsNullOrEmpty(instanceName))
            {
                throw new ArgumentNullException("instanceName");
            }

            registryPath.Add(applicationName);
            registryPath.Add(instanceName);
        }

        public void LoadConfiguration(Dictionary<string, string> configurationDictionary)
        {
            using (RegistryKey regKey = GetConfigurationRegistryKey(false))
            {
                if (regKey != null)
                {
                    string[] names = regKey.GetValueNames();

                    foreach (string name in names)
                    {
                        if (regKey.GetValueKind(name) == RegistryValueKind.String)
                        {
                            string value = regKey.GetValue(name) as string;

                            if (!String.IsNullOrEmpty(value))
                            {
                                configurationDictionary[name] = value;
                            }
                        }
                    }
                }
            }
        }

        public void SaveConfiguration(Dictionary<string, string> configurationDictionary)
        {
            using (RegistryKey regKey = GetConfigurationRegistryKey(true))
            {
                if (regKey != null)
                {
                    string[] names = regKey.GetValueNames();

                    foreach (string name in names)
                    {
                        regKey.DeleteValue(name);
                    }

                    foreach (KeyValuePair<string, string> kvp in configurationDictionary)
                    {
                        if ((kvp.Key.EndsWith(".password", StringComparison.OrdinalIgnoreCase)) ||
                            (kvp.Key.EndsWith("pwd", StringComparison.OrdinalIgnoreCase)))
                        {
                            // Passwords will not be persisted in the registry for security purposes
                            regKey.SetValue(kvp.Key, "##########", RegistryValueKind.String);
                        }
                        else
                        {
                            regKey.SetValue(kvp.Key, kvp.Value, RegistryValueKind.String);
                        }
                    }
                }
            }
        }

        private RegistryKey GetConfigurationRegistryKey(bool writable)
        {
            RegistryKey currentKey = Registry.LocalMachine;

            foreach (string key in registryPath)
            {
                RegistryKey nextKey = currentKey.OpenSubKey(key, writable);

                if (nextKey == null)
                {
                    if (writable)
                    {
                        nextKey = currentKey.CreateSubKey(key);
                    }
                    else
                    {
                        return null;
                    }
                }

                currentKey.Close();
                currentKey = nextKey;
            }

            return currentKey;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\XmlSequencer\RootStepContainer.cs ===
using System;
using System.Xml;
using System.Reflection;

namespace Leet.Tools.Setup.XmlSequencer
{
	/// <summary>
	/// Represents the root of a StepContainer/Step hierarchy.
	/// </summary>
	/// <remarks>
	/// This class defines the root of a StepContainer/Step object hierarchy. In addition to
	/// implementing a StepContainer, it provides the following additional functionality.
	/// <list type="bullet">
	/// <item><description>
	/// Provides a method that other Steps and StepContainers can use to send text messages 
	/// to subscribing objects through the root <c>Message</c> event.
	/// </description></item>
	/// <item><description>
	/// Provides a mechanism to map XML element names to the .NET types that will be instantiated
	/// when the named XML element is encountered when processing the XML.
	/// </description></item>
	/// </list>
	/// </remarks>
	public class RootStepContainer : StepContainer
	{
        private XmlNamespaceManager namespaceManager = null;
        private ElementTypeMapping typeMap = new ElementTypeMapping();


		/// <summary>
		/// 
		/// </summary>
		/// <param name="rootStepElement"></param>
		public RootStepContainer(XmlElement rootStepElement) : base(rootStepElement)
		{
            if (BaseXmlElement.NamespaceURI != Namespace)
            {
                throw new InvalidOperationException(BaseXmlElement.Name + " element must belong to the " + Namespace + " namespace.");
            }

            InitializeTypeMap();
        }

        private void InitializeTypeMap()
        {
            TypeMap.Clear();
            
            Assembly assembly = Assembly.GetExecutingAssembly();
            Type[] allTypes = assembly.GetExportedTypes();

            foreach (Type type in allTypes)
            {
                if (type.IsSubclassOf(typeof(Step)) || (type == typeof(Step)))
                {
                    object[] attributes = type.GetCustomAttributes(false);

                    foreach (object attribute in attributes)
                    {
                        StepElementAttribute stepElement = attribute as StepElementAttribute;

                        if ((stepElement != null) && (stepElement.ElementName.Length > 0))
                        {
                            TypeMap.Add(stepElement.ElementName, type);
                        }

                    }
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public virtual string Namespace
        {
            get {return "http://www.xbox.com/xmlsequencer.xsd";}
        }
        
        /// <summary>
        /// 
        /// </summary>
        public XmlNamespaceManager NamespaceManager
        {
            get
            {
                if (namespaceManager == null)
                {
                    namespaceManager = new XmlNamespaceManager(BaseXmlElement.OwnerDocument.NameTable);
                    namespaceManager.AddNamespace("sequencens", this.Namespace);
                    namespaceManager.PushScope();
                }

                return namespaceManager;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public ElementTypeMapping TypeMap
		{
			get {return typeMap;}
		}

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public void LogMessage(string message)
		{
			MessageEventArgs e = new MessageEventArgs(message);
			OnMessageNotifier(e);
		}

        /// <summary>
        /// 
        /// </summary>
		public event MessageEventHandler OnMessage;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="e"></param>
		protected virtual void OnMessageNotifier(MessageEventArgs e)
		{
			if (OnMessage != null) 
			{
				// Invokes the delegates. 
				OnMessage(this, e);
			}
		}
	}

    /// <summary>
    /// 
    /// </summary>
	public delegate void MessageEventHandler(object sender, MessageEventArgs e);

    /// <summary>
    /// 
    /// </summary>
	public class MessageEventArgs : EventArgs
	{
        private string message = "";

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
		public MessageEventArgs(string message)
		{
			Message = message;
		}

        /// <summary>
        /// 
        /// </summary>
		public string Message
		{
			get {return message;}
			set
			{
				if (value == null)
				{
					message = "";
				}
				else
				{
					message = value;
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\XmlSequencer\Step.cs ===
using System;
using System.IO;
using System.Xml;

namespace Leet.Tools.Setup.XmlSequencer
{
    /// <summary>
    /// Provides the base class that all steps will inherit from. 
    /// </summary>
    /// <remarks>
    /// <para>
    /// A step is the fundamental piece of XML Sequencing. In the source XML file, elements will get assoicated with
    /// a step type, which provides the implementation to process the step.
    /// </para>
    /// <para>
    /// While the step class can be used directly as a step type, the only functionality it provides is to log messages
    /// to the message log. To provide further functionality, you need to create a derived class that overrides one or more
    /// of the <see cref="Step.Validate"/>, <see cref="Step.OnBeforeExecute" />, <see cref="Step.OnExecute"/>, or 
    /// <see cref="Step.OnAfterExecute" /> methods. Within those methods, you can access the data in the step's element
    /// through the <see cref="Step.BaseXmlElement"/> property.
    /// </para>
    /// <para>
    /// Note that a Step is used for steps that do not have children steps. To implement a step that will have
    /// child steps, you need to derrive from the <see cref="StepContainer"/> class.
    /// </para>
    /// <para>
    /// The following table lists the attributes supported by the <c>&lt;Step&gt;</c> element
    /// and a brief description of their meaning. Note that these attributes are available for any steps that derrive from this class.
    /// </para>
    /// <list type="table">
    /// <listheader>
    ///     <term>Attribute</term>
    ///     <description>Description</description>
    /// </listheader>
    /// <item>
    ///     <term>message</term>
    ///     <description>A message to send to the message log when this step is processed.</description>
    /// </item>
    /// </list> 
    /// </remarks>
    [StepElement("Log")]
    public class Step
    {
        private XmlElement baseXmlElement = null;
        private StepContainer parent = null;
        private RootStepContainer root = null;

        /// <summary>
        /// Initializes a new instance of the Step class from an XML element, and its parent StepContainer.
        /// </summary>
        /// <param name="stepElement">The XML element that contains the information needed to initialize this object.</param>
        /// <param name="parent">
        /// The StepContainer object that contains this step.
        /// </param>
        /// <exception cref="ArgumentNullException">A null stepElement or parent was passed.</exception>
        public Step(XmlElement stepElement, StepContainer parent)
            : this(stepElement)
        {
            if (parent == null)
            {
                throw new ArgumentNullException("parent");
            }
            this.parent = parent;

        }

        /// <summary>
        /// Initializes a new instance of the Step class from and XML element. This version of the
        /// constructor should only be called by a RootStepContainer, since it is the only type that
        /// does not have a parent.
        /// </summary>
        /// <param name="stepElement">The XML element that contains the information needed to initialize this object.</param>
        /// <exception cref="ArgumentNullException">A null stepElement or parent was passed.</exception>
        protected Step(XmlElement stepElement)
        {
            if (stepElement == null)
            {
                throw new ArgumentNullException("stepElement");
            }

            baseXmlElement = stepElement;
        }

        /// <summary>
        /// 
        /// </summary>
        public XmlElement BaseXmlElement
        {
            get
            {
                return baseXmlElement;
            }
        }

        protected bool? GetBoolAttribute(string attributeName)
        {
            if (attributeName == null)
            {
                throw new ArgumentNullException("attributeName");
            }

            string value = BaseXmlElement.GetAttribute(attributeName);

            if (String.IsNullOrEmpty(value))
            {
                return null;
            }

            bool boolValue;

            if (!bool.TryParse(value, out boolValue))
            {
                throw new ArgumentOutOfRangeException(
                    attributeName,
                    String.Format("Attribute '{0}' of element '{1}' must be a valid string representation of a boolean. Instead got '{2}'.", attributeName, BaseXmlElement.Name, value));
            }


            return boolValue;
        }

        protected int? GetIntAttribute(string attributeName)
        {
            if (attributeName == null)
            {
                throw new ArgumentNullException("attributeName");
            }

            string value = BaseXmlElement.GetAttribute(attributeName);

            if (String.IsNullOrEmpty(value))
            {
                return null;
            }

            int intValue;

            if (!int.TryParse(value, out intValue))
            {
                throw new ArgumentOutOfRangeException(
                    attributeName,
                    String.Format("Attribute '{0}' of element '{1}' must be a valid integer. Instead got '{2}'.", attributeName, BaseXmlElement.Name, value));
            }

            return intValue;
        }

        /// <summary>
        /// Gets the parent StepContainer for this step in the XmlSequencer hierarchy.
        /// </summary>
        public StepContainer Parent
        {
            get { return parent; }
        }

        /// <summary>
        /// Gets the RootStepContainer for this step in the XmlSequencer hierarchy.
        /// </summary>
        public RootStepContainer Root
        {
            get
            {
                if (root == null)
                {
                    if (Parent == null)
                    {
                        root = (RootStepContainer)this;
                    }
                    else
                    {
                        root = Parent.Root;
                    }
                }
                return root;
            }
        }

        /// <summary>
        /// Tells the step to execute itself.
        /// </summary>
        /// <remarks>
        /// This method calls the <see cref="Step.OnBeforeExecute" />, <see cref="Step.OnExecute"/>, and 
        /// <see cref="Step.OnAfterExecute" /> methods, in that order, for the current step. If either
        /// OnBeforeExecute or OnExecute generate an exception, the OnAfterExecute will still get called.
        /// </remarks>
        public void Execute()
        {
            try
            {
                OnBeforeExecute();
                OnExecute();
            }
            finally
            {
                OnAfterExecute();
            }
        }

        /// <summary>
        /// Called by the <see cref="Step.Execute"/> method before the <see cref="Step.OnExecute"/>
        /// method.
        /// </summary>
        /// <remarks>
        /// Override this method in your derived class to perform any initialization or setup that needs to be 
        /// performed before the main execution path begins.  
        /// </remarks>
        protected virtual void OnBeforeExecute()
        {
            string message = BaseXmlElement.GetAttribute("message");

            if (message.Length > 0)
            {
                Root.LogMessage(message);
            }
        }

        /// <summary>
        /// Called by the <see cref="Step.Execute"/> method before the <see cref="Step.OnAfterExecute"/>
        /// method.
        /// </summary>
        /// <remarks>
        /// Override this method in your derived class to perform the action of your step.  
        /// </remarks>
        protected virtual void OnExecute()
        {
        }

        /// <summary>
        /// Called by the <see cref="Step.Execute"/> method after the <see cref="Step.OnExecute"/>
        /// method.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Override this method in your derived class to perform any cleanup for your step.
        /// </para>
        /// <para>
        /// This method will get called even if an exception is generated in the <see cref="Step.OnBeforeExecute"/>
        /// or <see cref="Step.OnExecute"/> methods.
        /// </para>  
        /// </remarks>
        protected virtual void OnAfterExecute()
        {
        }

        /// <summary>
        /// Provides a method that can be overridden to validate that this Step could execute
        /// based on the information in its XML element. 
        /// </summary>
        /// <remarks>
        /// <para>
        /// When the XML Sequencer is executed, it is typically done in two passes. The validation pass
        /// calls this method for each step. Only when validation has completed successfully for all steps
        /// will the steps be executed. 
        /// </para>
        /// <para>
        /// This method should be overridden in you derived classes if there is any validation that
        /// can be performed without side effects. This includes verifying that any required 
        /// attributes have been provided, any external resources (such as files) specified in the XML
        /// attributes exist, etc. You should throw an exception if your step fails validation. 
        /// </para>
        /// </remarks>
        public virtual void Validate()
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ouput"></param>
        public virtual void GenerateWix(XmlTextWriter ouput)
        {
        }
    }

    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = true)]
    public class StepElementAttribute : System.Attribute
    {
        private string elementName = "";

        public StepElementAttribute(string elementName)
        {
            this.elementName = elementName;
        }

        public string ElementName
        {
            get { return elementName; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\XmlSequencer\ConfigurationTransform.cs ===
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;


namespace Leet.Tools.Setup.XmlSequencer
{

    /// <summary>
    /// Summary description for ConfigurationTransform.
    /// </summary>
    public class ConfigurationTransform
    {
        public const string Namespace = "http://www.xbox.com/configurationTransform.xsd";
        private Dictionary<string, string> overrideVariableCollection = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

        /// <summary>
        /// 
        /// </summary>
        public Dictionary<string, string> OverrideVariableCollection
        {
            get { return overrideVariableCollection; }
        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="xmlDoc"></param>
        public void TransformDocument(XmlDocument xmlDoc)
        {
            if (xmlDoc == null)
            {
                throw new ArgumentNullException("xmlDoc");
            }

            XmlNamespaceManager namespaceManager = new XmlNamespaceManager(xmlDoc.NameTable);
            namespaceManager.AddNamespace("configurationTransform", Namespace);
            namespaceManager.PushScope();

            TransformElements(xmlDoc.DocumentElement, namespaceManager);
        }

        private void TransformElements(XmlElement currentElement, XmlNamespaceManager namespaceManager)
        {
            while (true)
            {
                XmlElement nextElement = (XmlElement)currentElement.SelectSingleNode("descendant::configurationTransform:*", namespaceManager);

                ProcessElementAvailability(currentElement, ref nextElement);
                if (nextElement == null)
                {
                    break;
                }

                TransformElements(nextElement, namespaceManager);
            }

            if (currentElement.NamespaceURI == Namespace)
            {
                TransformElement(currentElement);
            }
        }

        private void ProcessElementAvailability(XmlElement currentElement, ref XmlElement nextElement)
        {
            switch (currentElement.LocalName.ToLower())
            {
                case "includeifexists":
                    ProcessIncludeIfExistsTransform(ref currentElement, ref nextElement);
                    break;

                case "includeifnotexists":
                    ProcessIncludeIfNotExistsTransform(ref currentElement, ref nextElement);
                    break;
            }
        }

        private void ProcessIncludeIfExistsTransform(ref XmlElement currentElement, ref XmlElement nextElement)
        {
            if (ConfigValueExists(currentElement))
            {
                while (currentElement.ChildNodes.Count > 0)
                {
                    XmlNode firstChild = currentElement.FirstChild;
                    currentElement.RemoveChild(firstChild);
                    currentElement.ParentNode.InsertBefore(firstChild, currentElement);
                }
            }
            else
            {
                nextElement = null;
            }
            if (currentElement.ParentNode != null)
            {
                currentElement.ParentNode.RemoveChild(currentElement);
            }
        }

        private void ProcessIncludeIfNotExistsTransform(ref XmlElement currentElement, ref XmlElement nextElement)
        {
            if (!ConfigValueExists(currentElement))
            {
                while (currentElement.ChildNodes.Count > 0)
                {
                    XmlNode firstChild = currentElement.FirstChild;
                    currentElement.RemoveChild(firstChild);
                    currentElement.ParentNode.InsertBefore(firstChild, currentElement);
                }
            }
            else
            {
                nextElement = null;
            }

            if (currentElement.ParentNode != null)
            {
                currentElement.ParentNode.RemoveChild(currentElement);
            }
        }

        private bool ConfigValueExists(XmlElement currentElement)
        {
            string value = null;
            try
            {
                value = GetConfigurationValue(currentElement);
            }
            catch (ApplicationException)
            {
            }

            return !String.IsNullOrEmpty(value);
        }

        private void TransformElement(XmlElement currentElement)
        {
            switch (currentElement.LocalName.ToLower())
            {
                case "inline":
                    ProcessInlineTransform(currentElement);
                    break;

                case "setattribute":
                    ProcessSetAttributeTransform(currentElement);
                    break;

                case "includeifmatches":
                    ProcessIncludeIfMatchesTransform(currentElement);
                    break;

                case "includeifexists":
                case "includeifnotexists":
                    break;

                default:
                    throw new InvalidOperationException("Unknown element " + currentElement.Name + " specified in the '" + Namespace + "' namespace.");
            }
        }

        private void ProcessInlineTransform(XmlElement currentElement)
        {
            string newValue = GetConfigurationValue(currentElement);

            XmlText textNode = currentElement.OwnerDocument.CreateTextNode(newValue);
            currentElement.ParentNode.InsertBefore(textNode, currentElement);
            currentElement.ParentNode.RemoveChild(currentElement);
        }

        private void ProcessSetAttributeTransform(XmlElement currentElement)
        {
            string name = currentElement.GetAttribute("name");
            if (name.Length == 0)
            {
                throw new InvalidOperationException("Required attribute 'name' not specified in <setAttribute> element.");
            }

            ((XmlElement)currentElement.ParentNode).SetAttribute(name, currentElement.InnerText.Trim());
            currentElement.ParentNode.RemoveChild(currentElement);
        }

        private void ProcessIncludeIfMatchesTransform(XmlElement currentElement)
        {
            string pattern = currentElement.GetAttribute("pattern");
            if (pattern.Length == 0)
            {
                throw new InvalidOperationException("Required attribute 'pattern' not specified in <includeIfMatches> element.");
            }

            string value = GetConfigurationValue(currentElement);
            Regex conditional = new Regex(pattern, RegexOptions.IgnoreCase);

            if (conditional.IsMatch(value))
            {
                while (currentElement.ChildNodes.Count > 0)
                {
                    XmlNode firstChild = currentElement.FirstChild;
                    currentElement.RemoveChild(firstChild);
                    currentElement.ParentNode.InsertBefore(firstChild, currentElement);
                }
            }

            currentElement.ParentNode.RemoveChild(currentElement);
        }

        private string GetConfigurationKey(XmlElement configurationElement)
        {
            StringBuilder key = new StringBuilder();
            string name = GetRequiredAttribute(configurationElement, "name");
            string type = GetRequiredAttribute(configurationElement, "type");

            if (!String.Equals(type, "env", StringComparison.OrdinalIgnoreCase))
            {
                key.Append(type);
                key.Append(".");
            }

            switch (type.ToLower())
            {
                case "config.component":
                    key.Append(GetRequiredAttribute(configurationElement, "component"));
                    key.Append(".");
                    break;

                case "config.interface":
                    string interfaceName = GetRequiredAttribute(configurationElement, "interface");
                    key.Append(interfaceName);
                    key.Append(".");

                    string computerName = configurationElement.GetAttribute("computer");
                    if (!string.IsNullOrEmpty(computerName))
                    {
                        key.Append(computerName);
                        key.Append(".");
                    }
                    break;

                case "config.virtualinterface":
                    string virtualInterfaceName = GetRequiredAttribute(configurationElement, "virtualInterface");
                    key.Append(virtualInterfaceName);
                    key.Append(".");
                    break;
            }

            key.Append(name);
            return key.ToString();
        }

        private string GetConfigurationValue(XmlElement configurationElement)
        {
            string name = GetRequiredAttribute(configurationElement, "name");
            string type = GetRequiredAttribute(configurationElement, "type");

            string key = GetConfigurationKey(configurationElement);
            string value = null;

            if (OverrideVariableCollection.TryGetValue(key, out value))
            {
                return value;
            }

            var configProvider = Container.Instance.GetComponent<IConfigurationProvider>();
            switch (type.ToLower())
            {
                case "env":
                    value = Environment.GetEnvironmentVariable(name);

                    //BUGBUG quick dirty fix for 4748, remove this once we can find a better solution. 
                    if (string.Compare(name, "CPW") == 0)
                    {
                        value = "";
                    }

                    if (value == null)
                    {
                        throw new ArgumentException("No environment variable named '" + name + "' is defined.", "name");
                    }

                    break;

                case "config.setting":
                    value = configProvider.GetSetting(name);
                    break;

                case "config.interface":
                    value = GetInterfaceInformation(name, configurationElement);
                    break;

                case "config.virtualinterface":
                    value = GetVirtualInterfaceInformation(name, configurationElement);
                    break;

                case "config.environment":
                    value = configProvider.Environment;
                    break;

                default:
                    throw new ArgumentException("'" + type + "' is not a valid type for a configuration transform.", "type");
            }

            OverrideVariableCollection[key] = value;
            return value;
        }

        public string GetInterfaceInformation(string propertyName, XmlElement configurationElement)
        {
            string interfaceName = GetRequiredAttribute(configurationElement, "interface");

            string computerName = configurationElement.GetAttribute("computer");
            if (computerName.Length == 0)
            {
                computerName = Environment.MachineName;
            }

            IInterfaceInfo interfaceInfo = null;

            var configProvider = Container.Instance.GetComponent<IConfigurationProvider>();
            if (computerName.ToLower() == "single")
            {
                interfaceInfo = configProvider.GetSingleInterface(interfaceName);
            }
            else
            {
                interfaceInfo = configProvider.GetInterface(computerName, interfaceName);
            }

            PropertyInfo requestedProperty = (typeof(IInterfaceInfo)).GetProperty(propertyName);

            if (requestedProperty == null)
            {
                throw new ArgumentException("No interface property name '" + propertyName + "' is available.");
            }

            string propertyValue;
            try
            {
                propertyValue = requestedProperty.GetValue(interfaceInfo, null).ToString();
            }
            catch (Exception ex)
            {
                throw new ApplicationException("Error reading property " + propertyName + " from interface " + interfaceName, ex);
            }

            if (String.Compare(propertyName, "username", true) == 0)
            {
                // transform any %COMPUTERNAME% tokens in the username field to be the current machine name.
                // this allows us to use local machine accounts, changing the username to always reference
                // the local instance of the account.
                propertyValue = propertyValue.Replace("%COMPUTERNAME%", Environment.MachineName);
            }

            return propertyValue;
        }

        public string GetVirtualInterfaceInformation(string propertyName, XmlElement configurationElement)
        {
            string interfaceName = GetRequiredAttribute(configurationElement, "virtualInterface");

            string interfaceType = interfaceName;
            IVirtualInterfaceInfo interfaceInfo = null;

            var configProvider = Container.Instance.GetComponent<IConfigurationProvider>();
            interfaceInfo = configProvider.GetVirtualInterface(interfaceType);

            PropertyInfo requestedProperty = (typeof(IVirtualInterfaceInfo)).GetProperty(propertyName);

            if (requestedProperty == null)
            {
                throw new ArgumentException("No virtual interface property name '" + propertyName + "' is available.");
            }

            string propertyValue;
            try
            {
                propertyValue = requestedProperty.GetValue(interfaceInfo, null).ToString();
            }
            catch (Exception ex)
            {
                throw new ApplicationException("Error reading property " + propertyName + " from virtual interface " + interfaceType.ToString(), ex);
            }

            return propertyValue;
        }

        private string GetElementText(XmlElement element)
        {
            System.Text.StringBuilder elementText = new System.Text.StringBuilder();

            elementText.Append("<");
            elementText.Append(element.Name);

            foreach (XmlAttribute attribute in element.Attributes)
            {
                elementText.Append(" ");
                elementText.Append(attribute.OuterXml);
            }

            elementText.Append(" >");

            return elementText.ToString();
        }

        private string GetRequiredAttribute(XmlElement element, string name)
        {
            if (element == null)
            {
                throw new ArgumentNullException("element");
            }

            if (String.IsNullOrEmpty(name))
            {
                throw new ArgumentNullException("name");
            }

            string value = element.GetAttribute(name);
            if (String.IsNullOrEmpty(value))
            {
                throw new InvalidOperationException(String.Format("Required attribute '{0}' not specified in <{1}> element.", name, element.Name));
            }

            return value;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\setup\XmlSequencer\StepContainer.cs ===
using System;
using System.Xml;
using System.Reflection;

namespace Leet.Tools.Setup.XmlSequencer
{
	/// <summary>
	/// Summary description for StepContainer.
	/// </summary>
	public class StepContainer : Step
	{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
		public StepContainer(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
		}

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
		protected StepContainer(XmlElement stepElement) : base(stepElement)
		{
		}

        /// <summary>
        /// 
        /// </summary>
		protected override void OnExecute()
		{
			XmlNodeList childElements = BaseXmlElement.SelectNodes("sequencens:*", Root.NamespaceManager);

			foreach (XmlNode childNode in childElements)
			{
				Step childStep = InstantiateChild(childNode);
				childStep.Execute();
			}
		}

        /// <summary>
        /// 
        /// </summary>
        public override void Validate()
        {
            XmlNodeList childElements = BaseXmlElement.SelectNodes("*");

            foreach (XmlNode childNode in childElements)
            {
                Step childStep = InstantiateChild(childNode);
                childStep.Validate();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="output"></param>
        public override void GenerateWix(XmlTextWriter output)
        {
            XmlNodeList childElements = BaseXmlElement.SelectNodes("*");

            foreach (XmlNode childNode in childElements)
            {
                Step childStep = InstantiateChild(childNode);
                childStep.GenerateWix(output);
            }
        }

        private Step InstantiateChild(XmlNode childNode)
        {
            XmlElement child = (XmlElement) childNode;
            System.Type childType = null;

            childType = Root.TypeMap[child.Name];
            if (childType == null)
            {
                throw new InvalidOperationException("Encountered XML element " + child.Name + " with no matching entry in TypeMap.");
            }

            System.Type[] constructorPrototype = {child.GetType(), this.GetType()};
            ConstructorInfo ctor = childType.GetConstructor(constructorPrototype);
				
            object[] constructorParameters = {child, this};
            return (Step) ctor.Invoke(constructorParameters);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\WxsMaker\FileElement.cs ===
﻿using System.Configuration;

namespace WxsMaker
{
    public class FileElement : ConfigurationElement
    {
        public static string ElementName = "File";

        [ConfigurationProperty("Name", IsRequired = true)]
        public string Name
        {
            get { return ((string)base["Name"]); }
            set { base["Name"] = value; }
        }

        [ConfigurationProperty("Exclude", IsRequired = false)]
        public string Exclude
        {
            get { return ((string)base["Exclude"]); }
            set { base["Exclude"] = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\WxsMaker\FoldersCollection.cs ===
﻿using System.Configuration;

namespace WxsMaker
{
    public class FoldersCollection : ConfigurationElementCollection
    {
        public FolderElement this[int index]
        {
            get { return (FolderElement)base.BaseGet(index); }
            set
            {
                if (base.BaseGet(index) != null)
                    base.BaseRemoveAt(index);
                this.BaseAdd(index, value);
            }
        }

        protected override bool IsElementName(string elementName)
        {
            if ((string.IsNullOrEmpty(elementName)) || (elementName != FolderElement.ElementName))
                return false;
            return true;
        }

        public override ConfigurationElementCollectionType CollectionType
        {
            get { return ConfigurationElementCollectionType.BasicMapAlternate; }
        }

        protected override object GetElementKey(ConfigurationElement element)
        {
            return FolderElement.ElementName;
        }

        protected override ConfigurationElement CreateNewElement()
        {
            return new FolderElement();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\WxsMaker\FilesCollection.cs ===
﻿using System.Configuration;

namespace WxsMaker
{
    public class FilesCollection : ConfigurationElementCollection
    {
        public FileElement this[int index]
        {
            get { return (FileElement )base.BaseGet(index); }
            set
            {
                if (base.BaseGet(index) != null)
                    base.BaseRemoveAt(index);
                this.BaseAdd(index, value);
            }
        }

        protected override bool IsElementName(string elementName)
        {
            if ((string.IsNullOrEmpty(elementName)) || (elementName != FileElement.ElementName))
                return false;
            return true;
        }

        public override ConfigurationElementCollectionType CollectionType
        {
            get { return ConfigurationElementCollectionType.BasicMapAlternate; }
        }

        protected override object GetElementKey(ConfigurationElement element)
        {
            return FileElement.ElementName;
        }

        protected override ConfigurationElement CreateNewElement()
        {
            return new FileElement();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\WxsMaker\FolderElement.cs ===
﻿using System.Collections.Generic;
using System.Configuration;
using System.Xml;

namespace WxsMaker
{
    public class FolderElement : ConfigurationElement
    {
        public static string ElementName = "Folder";

        private string _Path = null;
        [ConfigurationProperty("Path", DefaultValue = "", IsKey = false, IsRequired = true)]
        public string Path
        {
            get { return (_Path ?? ((string)(base["Path"])).TrimEnd('/', '\\').Replace('/', '\\')); }
            set { _Path = value; }
        }
        [ConfigurationProperty("IncludeRegEx", DefaultValue = "", IsKey = false, IsRequired = false)]
        public string IncludeRegEx
        {
            get { return ((string)(base["IncludeRegEx"])); }
            set { base["IncludeRegEx"] = value; }
        }
        [ConfigurationProperty("ExcludeRegEx", DefaultValue = "", IsKey = false, IsRequired = false)]
        public string ExcludeRegEx
        {
            get { return ((string)(base["ExcludeRegEx"])); }
            set { base["ExcludeRegEx"] = value; }
        }
        [ConfigurationProperty("Recursive", DefaultValue = "false", IsKey = false, IsRequired = false)]
        public bool Recursive
        {
            get { return ((bool)(base["Recursive"])); }
            set { base["Recursive"] = value; }
        }
        [ConfigurationProperty("TargetRelativePath", DefaultValue = "", IsKey = false, IsRequired = false)]
        public string TargetRelativePath
        {
            get { return ((string)(base["TargetRelativePath"])).Trim('/', '\\').Replace('/', '\\'); }
            set { base["TargetRelativePath"] = value; }
        }
        [ConfigurationProperty("DirectoryId", DefaultValue = "", IsKey = false, IsRequired = false)]
        public string DirectoryId
        {
            get { return ((string)(base["DirectoryId"])); }
            set { base["DirectoryId"] = value; }
        }
        [ConfigurationProperty("Mode", DefaultValue = "", IsKey = false, IsRequired = false)]
        public string Modes
        {
            get { return ((string)(base["Mode"])); }
            set { base["Mode"] = value; }
        }
        [ConfigurationProperty("", DefaultValue = null, IsDefaultCollection = true, IsKey = false, IsRequired = false)]
        public FilesCollection FileItems
        {
            get { return ((FilesCollection)(base[""])); }
        }

        public bool HasAnyOfModes(List<string> modes)
        {
            if (string.IsNullOrEmpty(Modes))
                return true;
            string[] folderModes = Modes.Split(';');
            foreach (var mode in modes)
            {
                foreach (var folderMode in folderModes)
                {
                    if (folderMode.ToLower().Trim() == mode.ToLower().Trim())
                        return true;
                }
            }
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\WxsMaker\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Configuration;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;

namespace WxsMaker
{
    class Program
    {
        /// <summary>
        /// It keeps track of created Components and Direcories
        /// Keys is encoded folder name
        /// Value is number of times the folder is used
        /// </summary>
        private static readonly Dictionary<string, int> IdTracker = new Dictionary<string, int>();
        /// <summary>Keeps tracks of what files are copied to where to avoid duplicates (same file in same target folder) in output WXS</summary>
        private static readonly Dictionary<string, int> FileTracker = new Dictionary<string, int>();
        /// <summary>Keeps all component Ids created in a WXS file</summary>
        private static List<string> Components;
        private const string DefaultNameSpace = "http://schemas.microsoft.com/wix/2006/wi";
        private const string ErrorLogFileName = "WxsMaker.log";
        private static bool IsLogOpen = false;
        private static TextWriter tw = null;

        static int Main(string[] args)
        {
            int ret = 0;
            
            if (File.Exists(ErrorLogFileName))
            {
                File.Delete(ErrorLogFileName);
            }

            var modes = new List<string>();
            var placeholders = new Dictionary<string, string>();
            string configFile = null;
            if (args != null && args.Length > 0)
            {
                for (int i = 0; i < args.Length; i++)
                {
                    args[i] = args[i].ToLower();
                    if (args[i].StartsWith("mode="))
                    {
                        string[] split = args[i].Substring(5).Split(';');
                        for (int j = 0; j < split.Length; j++)
                        {
                            split[j] = split[j].Trim();
                            if (split[j].Length > 0)
                            {
                                modes.Add(split[j]);
                            }
                        }
                    }
                    else if (args[i].StartsWith("configfile="))
                    {
                        configFile = args[i].Substring("configfile=".Length);
                    }
                    else if (Regex.IsMatch(args[i], "[0-9a-zA-Z_-]+="))
                    {
                        int idx = args[i].IndexOf('=');
                        string key = args[i].Substring(0, idx);
                        string value = args[i].Substring(idx + 1);
                        placeholders.Add(key, value);
                    }
                }
            }

            WxsMakerConfiguration section = ReadConfiguration(configFile);

            XmlWriter w;
            foreach (WxsFileElement wxs in section.WxsItems)
            {
                Components = new List<string>();
                var settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.Encoding = Encoding.ASCII;
                w = XmlWriter.Create(wxs.FilePath, settings);
                if (w != null)
                {
                    try
                    {
                        w.WriteStartDocument();

                        WriteStartPart(w, wxs.DirectoryRef);

                        foreach (FolderElement folder in wxs.FolderItems)
                        {
                            if (folder.HasAnyOfModes(modes))
                            {
                                folder.Path = ResolvePrefixes(folder.Path, placeholders);
                                WriteMiddlePart(w, folder, wxs.DirectoryRef);
                            }
                        }

                        WriteEndPart(w, wxs.ComponentGroupName);
                        w.Close();
                    }
                    catch (Exception ex)
                    {
                        ErrorLog(ex.ToString());
                        ret = 1;
                    }
                }
                else
                {
                    const string errorMsg = "Couldn't create WXS file!";
                    ErrorLog(errorMsg);
                    ret = 1;
                }
            }
            if (tw != null) // some errors were logged
            {
                tw.Close();
                return 1;
            }
            return ret;
        }

        private static WxsMakerConfiguration ReadConfiguration(string configFile)
        {
            Configuration configuration;
            if (configFile == null)
            {
                configuration = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);
            }
            else
            {
                var exeConfigMap = new ExeConfigurationFileMap() { ExeConfigFilename = configFile };
                configuration = ConfigurationManager.OpenMappedExeConfiguration(exeConfigMap, ConfigurationUserLevel.None);
            }
            return (WxsMakerConfiguration)configuration.GetSection("WxsMaker");
        }

        private static string ResolvePrefixes(string path, IDictionary<string, string> placeholders)
        {
            int e = 0;
            int s = path.IndexOf('%', e);
            while (s != -1) // there is a prefix in the path
            {
                e = path.IndexOf('%', s+1);
                if (e == -1)
                {
                    string msg = "Path \"" + path + "\" is in unexpected format (no second %)";
                    ErrorLog(msg);
                    throw new Exception(msg);
                }
                string key = path.Substring(s+1, e-1);
                string value;
                if (placeholders.TryGetValue(key.ToLower(), out value))
                {
                    path = path.Replace("%" + key + "%", value);
                }
                else
                {
                    string msg = "Path \"" + path + "\" has undefined placeholder";
                    ErrorLog(msg);
                    throw new Exception(msg);
                }
                s = path.IndexOf('%', e);
            }
            return path;
        }

        private static void WriteStartPart(XmlWriter w, string directoryRef)
        {
            w.WriteStartElement("Wix", DefaultNameSpace);
                w.WriteStartElement("Fragment");
                    w.WriteStartElement("DirectoryRef");
                    w.WriteAttributeString("Id", directoryRef);
        }

        private static void WriteEndPart(XmlWriter w, string componentGroupName)
        {
                    w.WriteEndElement();
                w.WriteEndElement();
                w.WriteStartElement("Fragment");
                w.WriteStartElement("ComponentGroup");
                w.WriteAttributeString("Id",componentGroupName);
                    foreach (string componentName in Components)
                    {
                        w.WriteStartElement("ComponentRef");
                        w.WriteAttributeString("Id",componentName);
                        w.WriteEndElement();
                    }
                    w.WriteEndElement();
                w.WriteEndElement();
            w.WriteEndElement();
        }

        private static void WriteMiddlePart(XmlWriter w, FolderElement folder, string directoryRef)
        {
            if (!string.IsNullOrEmpty(folder.TargetRelativePath)) // nesting dir structure should be created first
            {
                string[] dirs = folder.TargetRelativePath.Split('\\');
                string currentDir = directoryRef;
                for (int i = 0; i < dirs.Length; i++)
                {
                    currentDir += @"\" + dirs[i];
                    string dirId = GetDirectoryId(currentDir);
                    //<Directory Id='en_us.dir2' Name='en-us'>
                    w.WriteStartElement("Directory");
                    if (i == dirs.Length - 1 && !string.IsNullOrEmpty(folder.DirectoryId)) // the last one and DirectoryId is provided so let's use it
                    {
                        w.WriteAttributeString("Id", folder.DirectoryId);
                    }
                    else
                    {
                        w.WriteAttributeString("Id", dirId);
                    }
                    w.WriteAttributeString("Name", dirs[i]);
                }
                
                WriteFilesInDirectory(w, folder.Path, folder.FileItems, folder.ExcludeRegEx, folder.IncludeRegEx, folder.Recursive, currentDir);

                for (int i = 0; i < dirs.Length; i++)
                {
                    w.WriteEndElement();
                }
            }
            else
            {
                WriteFilesInDirectory(w, folder.Path, folder.FileItems, folder.ExcludeRegEx, folder.IncludeRegEx, folder.Recursive, directoryRef);    
            }
        }

        private static void WriteFilesInDirectory(XmlWriter w, string path, FilesCollection files, string excludeRegExList, string includeRegExList, bool recursive, string targetDirFull)
        {
            WriteComponent(w, path, files, excludeRegExList, includeRegExList, targetDirFull);
            if (recursive)
            {
                string[] dirs = Directory.GetDirectories(path);
                foreach (string dir in dirs)
                {
                    string dirId = GetDirectoryId(path);
                    //<Directory Id='en_us.dir2' Name='en-us'>
                    w.WriteStartElement("Directory");
                    w.WriteAttributeString("Id", dirId);
                    string dirName = dir.Substring(dir.LastIndexOf('\\') + 1);
                    w.WriteAttributeString("Name", dirName);

                    WriteFilesInDirectory(w, dir, null, excludeRegExList, includeRegExList, true, targetDirFull + @"\" + dirName);

                    w.WriteEndElement();
                }
            }
        }

        private static void WriteComponent(XmlWriter w, string path, FilesCollection fileItems, string excludeRegExList, string includeRegExList, string targetDirFull)
        {
            var sb = new StringBuilder();
            var stringWriter = new StringWriter(sb);
            var xmlNodeWriter = new XmlTextWriter(stringWriter);
            bool hasFiles = false;
            List<string> excludeList = new List<string>();

            string[] files = CheckInclueExcludeExtensions(path, excludeRegExList, includeRegExList);
            if (files != null && files.Length > 0 || fileItems != null && fileItems.Count > 0)
            {
                //<Component Id="Component3" Guid="27706A72-7496-498A-930D-79714C5C9a1C">
                xmlNodeWriter.WriteStartElement("Component");
                string componentId = GetComponentId(path);
                xmlNodeWriter.WriteAttributeString("Id", componentId);
                xmlNodeWriter.WriteAttributeString("Guid", Guid.NewGuid().ToString());
                if (fileItems != null && fileItems.Count > 0) // File elements should be processed first since they are explicitly defined. This way they will not be overwritten later
                {
                    foreach (FileElement file in fileItems)
                    {
                        string filePath = Path.Combine(path, file.Name);
                        filePath = Path.GetFullPath(filePath);
                       
                        if (!string.IsNullOrEmpty(file.Exclude) && (string.Compare(file.Exclude, "yes", true) == 0))
                        {
                            excludeList.Add(file.Name);
                        }
                        else
                        {
                            hasFiles = WriteFiles(xmlNodeWriter, filePath, targetDirFull, hasFiles);
                        }
                    }
                }
                if (files != null && files.Length > 0)
                {
                    foreach (string file in files)
                    {
                        string fileName = Path.GetFileName(file);

                        if(!excludeList.Contains(fileName))
                            hasFiles = WriteFiles(xmlNodeWriter, file, targetDirFull, hasFiles);
                    }
                }
                xmlNodeWriter.WriteEndElement();
                if (hasFiles)
                {
                    WriteNode(w, xmlNodeWriter, sb.ToString());
                    Components.Add(componentId);
                }
            }
        }

        private static bool WriteFiles(XmlTextWriter xmlNodeWriter, string fullPath, string targetDirFull, bool hasFiles)
        {
            string fileName = Path.GetFileName(fullPath);
            if (!FileTracker.ContainsKey((fullPath + ">>" + targetDirFull).ToLower()))
            {
                if (!FileTracker.ContainsKey((fileName + ">>" + targetDirFull).ToLower()))
                {
                    FileTracker.Add((fileName + ">>" + targetDirFull).ToLower(), 0);
                    FileTracker.Add((fullPath + ">>" + targetDirFull).ToLower(), 0);
                    string fileId = GetFileId(fullPath);
                    //<File Id="help.aspx" Name="help.aspx" Vital="yes" Source="d:\Enlistments\ballroom\Source\Zone\server\web\messenger\en-us\dimi\help.aspx"/>
                    xmlNodeWriter.WriteStartElement("File");
                    xmlNodeWriter.WriteAttributeString("Id", fileId);
                    xmlNodeWriter.WriteAttributeString("Name", fileName);
                    xmlNodeWriter.WriteAttributeString("Vital", "yes");
                    xmlNodeWriter.WriteAttributeString("Source", fullPath);
                    xmlNodeWriter.WriteEndElement();
                    hasFiles = true;
                }
                else
                {
                    ErrorLog(fileName, targetDirFull);
                }
            }
            return hasFiles;
        }

        private static void WriteNode(XmlWriter targetNode, XmlTextWriter nodeWriter, string node)
        {
            nodeWriter.Flush();
            TextReader tr = new StringReader(node);
                    
            var nameTable = new NameTable();
            var namespaceManager = new XmlNamespaceManager(nameTable);
            namespaceManager.AddNamespace("", DefaultNameSpace);
            var readerSettings = new XmlReaderSettings();
            readerSettings.ConformanceLevel = ConformanceLevel.Fragment;
            var parserContext = new XmlParserContext(nameTable, namespaceManager, nodeWriter.XmlLang, nodeWriter.XmlSpace);

            var xtr = XmlReader.Create(tr, readerSettings, parserContext);
            targetNode.WriteNode(xtr, false);
            nodeWriter.Close();
        }

        private static string[] CheckInclueExcludeExtensions(string path, string excludeRegExList, string includeRegExList)
        {
            string[] files = Directory.GetFiles(path);
            var includeFiles = new List<string>();
            if (string.IsNullOrEmpty(excludeRegExList)) // nothing to exclude
            {
                includeFiles.AddRange(files);
            }
            else
            {
                foreach (string file in files)
                {
                    bool toInclude = true;
                    foreach (string excludeRegEx in GetArrayFromList(excludeRegExList))
                    {
                        if (!String.IsNullOrEmpty(excludeRegEx))
                        {
                            if (Regex.IsMatch(Path.GetFileName(file), excludeRegEx, RegexOptions.IgnoreCase))
                            {
                                toInclude = false;
                                break;
                            }
                        }
                    }
                    if (toInclude)
                    {
                        includeFiles.Add(file);
                    }
                }
            }
            if (!string.IsNullOrEmpty(includeRegExList))
            {
                files = includeFiles.ToArray();
                includeFiles.Clear();
                foreach (string file in files)
                {
                    foreach (string includeRegEx in GetArrayFromList(includeRegExList))
                    {
                        if (!String.IsNullOrEmpty(includeRegEx))
                        {
                            if (Regex.IsMatch(Path.GetFileName(file), includeRegEx, RegexOptions.IgnoreCase))
                            {
                                includeFiles.Add(file);
                            }
                        }
                    }
                }
            }
            return includeFiles.ToArray();
        }

        public static void ErrorLog(string fileName, string targetDirFull)
        {
            ErrorLog("File " + fileName + " is already added to " + targetDirFull);
        }

        public static void ErrorLog(string line)
        {
            if(!IsLogOpen)
            {
                FileStream fs = new FileStream(ErrorLogFileName, FileMode.CreateNew, FileAccess.Write, FileShare.None);
                tw = new StreamWriter(fs);
                IsLogOpen = true;
            }
            tw.WriteLine(line);
            Console.WriteLine(line);
        }

        #region Getting Ids for Directories, Components and Files

        private static string PathEncoder(string path)
        {
            path = path.Replace('\\', '.').Replace('/', '.');
            path = Regex.Replace(path, "[^a-zA-Z0-9_.]", "_");
            return path;
        }
        private static string[] GetArrayFromList(string list)
        {
            if (string.IsNullOrEmpty(list)) return new string[0];
            return list.Split(';');
        }
        private static string GetDirectoryId(string path)
        {
            path = Path.GetDirectoryName(path); // Gets parent folder name. The directory name goes to Name attribute of <Directory> element
            return "D." + GetUniqueId(path);
        }
        private static string GetComponentId(string path)
        {
            return "C." + GetUniqueId(path);
        }
        private static string GetFileId(string path)
        {
            path = Path.GetDirectoryName(path); // Gets folder name where the file resides. The file name goes to Name attribute of <File> element
            return "F." + GetUniqueId(path);
        }
        private static string GetUniqueId(string path)
        {
            string ret = PathEncoder(path);
            if (ret.Length > 35) // let's limit Id with first and last 16 chars of path + duplicate resolving number
            {
                ret = ret.Substring(0, 16) + "..." + ret.Substring(ret.Length - 16);
            }
            int count = 0;
            if (IdTracker.TryGetValue(ret, out count))
            {
                count++;
            }
            IdTracker[ret] = count;

            return ret + "." + count;
        }

        #endregion Getting Ids for Directories, Components and Files
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\WxsMaker\WixMakerConfiguration.cs ===
﻿using System.Configuration;

namespace WxsMaker
{
    public class WxsMakerConfiguration : ConfigurationSection
    {
        [ConfigurationProperty("", DefaultValue = null, IsDefaultCollection = true, IsKey = false, IsRequired = false)]
        public WxsCollection WxsItems
        {
            get { return ((WxsCollection)(base[""])); }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\WxsMaker\WxsFileElement.cs ===
﻿using System.Configuration;

namespace WxsMaker
{
    public class WxsFileElement: ConfigurationElement
    {
        public static string ElementName = "WxsFile";

        [ConfigurationProperty("FilePath", DefaultValue = "", IsKey = true, IsRequired = true)]
        public string FilePath
        {
            get { return ((string)(base["FilePath"])); }
            set { base["FilePath"] = value; }
        }
        [ConfigurationProperty("ComponentGroupName", DefaultValue = "", IsKey = false, IsRequired = true)]
        public string ComponentGroupName
        {
            get { return ((string)(base["ComponentGroupName"])); }
            set { base["ComponentGroupName"] = value; }
        }
        [ConfigurationProperty("DirectoryRef", DefaultValue = "", IsKey = false, IsRequired = true)]
        public string DirectoryRef
        {
            get { return ((string)(base["DirectoryRef"])); }
            set { base["DirectoryRef"] = value; }
        }
        [ConfigurationProperty("", DefaultValue = null, IsDefaultCollection = true, IsKey = false, IsRequired = false)]
        public FoldersCollection FolderItems
        {
            get { return ((FoldersCollection)(base[""])); }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\tools\WxsMaker\WxsCollection.cs ===
﻿using System.Configuration;

namespace WxsMaker
{
    public class WxsCollection : ConfigurationElementCollection
    {
        public WxsFileElement this[int index]
        {
            get { return (WxsFileElement)base.BaseGet(index); }
            set
            {
                if (base.BaseGet(index) != null)
                    base.BaseRemoveAt(index);
                this.BaseAdd(index, value);
            }
        }

        protected override bool IsElementName(string elementName)
        {
            if ((string.IsNullOrEmpty(elementName)) || (elementName != WxsFileElement.ElementName))
                return false;
            return true;
        }

        public override ConfigurationElementCollectionType CollectionType
        {
            get { return ConfigurationElementCollectionType.BasicMapAlternate; }
        }

        protected override object GetElementKey(ConfigurationElement element)
        {
            return WxsFileElement.ElementName;
        }

        protected override ConfigurationElement CreateNewElement()
        {
            return new WxsFileElement();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\AvatarServiceTests.cs ===
﻿using System;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Cache;
using System.Text;
using System.Xml.Linq;
using Avatar.Services.ManifestRead.Library;
using Avatar.Services.ManifestWrite.Library;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Avatar.Test.AvatarProxy;
using CloudServices.Test.Common.Authorization;
using Authorization = CloudServices.Test.Common.Authorization.Authorization;
using CloudServices.Test.Common.Configuration;

namespace Test.Avatar.Functional.AvatarServiceTests
{
    /// <summary>
    /// Summary description for AvatarServiceTests
    /// </summary>
    [TestClass]
    public class ManifestReadTests
    {
        public ManifestReadTests() { }

        public TestContext TestContext { get; set; }

        [TestMethod]
        public void BVT_ManifestRead_SingleGamertag()
        {
            //todo(michperr): Figure out how to take these in via config
            string[] targetGamertags = new string[] { "canned" };
            
            ManifestReadProxy mrp = new ManifestReadProxy();
            AvatarManifests m_TargetAvatarManifests = mrp.GetManifest(targetGamertags);

            Assert.AreEqual<int>(targetGamertags.Length, m_TargetAvatarManifests.Manifests.Length);

            for (int i = 0; i < targetGamertags.Length; i++)
            {
                //TODO(MICHPERR): add validation of the manifest here.
                Assert.AreEqual<string>(targetGamertags[i], m_TargetAvatarManifests.Manifests[i].Gamertag);
                Assert.AreEqual<int>(2000, m_TargetAvatarManifests.Manifests[i].Manifest.Length);
                //---
            }
        }

        [TestMethod]
        public void BVT_ManifestRead_MultipleGamertags_Dupes()
        {
            //todo(michperr): Figure out hwo to take these in via config
            ManifestReadProxy mrp = new ManifestReadProxy();
            AvatarManifests m_TargetAvatarManifests = mrp.GetManifest(new string[] { "canned", "canned" });

            Assert.AreEqual<int>(1, m_TargetAvatarManifests.Manifests.Length);
            Assert.AreEqual<string>("canned", m_TargetAvatarManifests.Manifests[0].Gamertag);
            Assert.AreEqual<int>(2000, m_TargetAvatarManifests.Manifests[0].Manifest.Length);
        }

        [TestMethod]
        public void BVT_ManifestRead_MultipleGamertags_Dupes_DifferentCase()
        {
            //todo(michperr): Figure out hwo to take these in via config
            ManifestReadProxy mrp = new ManifestReadProxy(Config.Environment.ManifestReadService);
            AvatarManifests m_TargetAvatarManifests = mrp.GetManifest(new string[] { "canned", RandomizeCase("canned") });
            
            Assert.AreEqual<int>(1, m_TargetAvatarManifests.Manifests.Length);
            Assert.AreEqual<string>("canned", m_TargetAvatarManifests.Manifests[0].Gamertag);
            Assert.AreEqual<int>(2000, m_TargetAvatarManifests.Manifests[0].Manifest.Length);
        }

        [TestMethod]
        public void BVT_ManifestRead_MultipleGamertags()
        {
            //todo(michperr): Remove hardcoded strings
            //string[] targetGamertags = new string[] { "angelmex02","angelmex10" };
            string[] targetGamertags = new string[] { "canned", Config.Environment.UserSettings[0].Gamertag };
            ManifestReadProxy mrp = new ManifestReadProxy();
            AvatarManifests m_TargetAvatarManifests = mrp.GetManifest(targetGamertags);

            Assert.AreEqual<int>(targetGamertags.Length, m_TargetAvatarManifests.Manifests.Length);

            for (int i = 0; i < targetGamertags.Length; i++)
            {
                //TODO(MICHPERR): add validation of the manifest here.
                Assert.AreEqual<string>(targetGamertags[i], m_TargetAvatarManifests.Manifests[i].Gamertag);
                Assert.AreEqual<int>(2000, m_TargetAvatarManifests.Manifests[i].Manifest.Length);
                //---
            }
        }

        //omits the '?gt='
        [TestMethod]
        public void BVT_ManifestRead_Null()
        {
            //make sure that null returns a list of 0 items.
            ManifestReadProxy mrp = new ManifestReadProxy();
            AvatarManifests m_TargetAvatarManifests = mrp.GetManifest((string)null);
            Assert.AreEqual<int>(0, m_TargetAvatarManifests.Manifests.Length);
        }

        //has a query string of 'gt='
        [TestMethod]
        public void BVT_ManifestRead_Empty()
        {
            ManifestReadProxy mrp = new ManifestReadProxy();
            AvatarManifests m_TargetAvatarManifests = mrp.GetManifest(new string[] { string.Empty });
            Assert.AreEqual<int>(0, m_TargetAvatarManifests.Manifests.Length);
        }

        [TestMethod]
        public void Functional_ManifestRead_InvalidGamertag()
        {
            ManifestReadProxy mrp = new ManifestReadProxy();
            AvatarManifests m = mrp.GetManifest(new string[] { "!nvalidGame|2Tag" });
            Assert.AreEqual<int>(0, m.Manifests.Length);
        }

        [TestMethod]
        public void Test_ManWrite()
        {
            string manifestStr = "00000000BF8000003F80000000100000031B0003C1C8F109A19CB2E00008000003270003C1C8F109A19CB2E000200000033A0003C1C8F109A19CB2E00000800002FD0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002C80003C1C8F109A19CB2E03F8000000000000000000000000000000000400002690003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFA87D3FFF682618FFFD6A68FF88B049FF682618FF5395CAFF682618FFAD5F47FFAD5F470000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402230003C1C8F109A19CB2E0000400000000000000000000000000000000002001040002C1C8F109A19CB2E00020000000000000000000000000000000800218017F0002C1C8F109A19CB2E00218000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001040002C1C8F109A19CB2E00020000000000000000000000000000000000010015A0002C1C8F109A19CB2E00010000000000000000000000000000000000008012A0002C1C8F109A19CB2E0000800000000000000000000000000000000000402230003C1C8F109A19CB2E000040000000000000000000000000000E000107248A7CBF8000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

            ManifestWritePrivateProxy mp = new ManifestWritePrivateProxy(
                Config.Environment.UserSettings[0].Membername,
                Config.Environment.UserSettings[0].Password);

            //grab the xuid from the ticket
            ulong xuid = ulong.Parse(Authorization.GetXuid(
                AuthorizationCache.GetStsToken(
                Config.Environment.UserSettings[0].Membername,
                Config.Environment.UserSettings[0].Password)));

            //todo(michperr): Do a manifest read and make sure this is not the assigned manifest
            mp.UpdateManifest(
                new UpdateManifestRequest()
                {
                    Manifest = manifestStr,
                    Xuid = xuid
                });


            ManifestReadProxy mrp = new ManifestReadProxy();
            AvatarManifests am = mrp.GetManifest(Config.Environment.UserSettings[0].Gamertag);


        }
        //todo(michperr): Figure out how to make this repeatable
        public string RandomizeCase(string s)
        {
            Random r = new Random();

            StringBuilder sb = new StringBuilder(s.Length);
            foreach (char c in s)
            {
                sb.Append((r.Next(2) >= 1) ? char.ToUpper(c) : char.ToLower(c));
            }
            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\CommonCode.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Threading;
using AvatarServices.Test.Common;
using AvatarServices.Test.UserCache;
using LiveN.Test.Users;
using Leet.Core.TestService;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.XboxLive.Avatars.Internal;
using LiveN.Test.Avatar;

using LiveNew.Test;

namespace AvatarServices.Tests
{
    /// <summary>
    /// Code used by all the tests within this project
    /// </summary>
    public static class CommonCode
    {
        /// <summary>
        /// Const required for Focal Joint. Taken from: $DEPOT$\LEST_MAIN_DEV\product\Source\AvatarServices\Avatar.Services.ManifestWrite.Library\GamerPicUpdater.cs
        /// </summary>
        public const int AVATAR_HEAD_JOINT = 19;

        /// <summary>
        /// Test Service installed with the rest of the product and is used to communicate with the product directly. 
        /// </summary>
        public static ISSRService SSRTestService = TestHookFactory.Instance.SSRService;

        /// <summary>
        /// Default blacklist location within the Assembly
        /// </summary>
        public const string DEFUALT_BLACK_LIST = "AvatarServices.Tests.Resources.BlackListedAssets.xml";

        /// <summary>
        /// Fixed list of awardable assets that the testnet users will have been awarded.
        /// </summary>
        public static List<AwardableAsset> testAwardableList = new List<AwardableAsset>()
                                                                {
                                                                   new AwardableAsset(new Guid("00000008-0001-4101-c111-0123ffffbaaa"), "Male shirt name", 0, 0, 11, 13),
                                                                   new AwardableAsset(new Guid("00000008-0001-4102-c111-0123ffffbaaa"), "Female shirt name", 0, 0, 12, 13),
                                                                   new AwardableAsset(new Guid("00000040-0002-4103-c111-0123ffffbaaa"), "Totally awesome hat", 0, 0, 14, 15)
                                                                };

        /// <summary>
        /// Fixed list of marketplace assets that the testnet users will have purchased.
        /// </summary>
        public static List<MarketplaceAsset> testMarketplaceList = new List<MarketplaceAsset>()
                                                                    {
                                                                       new MarketplaceAsset(new Guid("00000ffc-68b8-32a2-cbe7-b13d5553083b"), new Guid("011f0010-0000-4000-8000-00005553083b"), "Altaïr Outfit", 400, 0, string.Empty), 
                                                                       new MarketplaceAsset(new Guid("00000040-0b12-82f2-c85f-b2c75553083b"), new Guid("011f0015-0000-4000-8000-00005553083b"), "Animus Logo Baseball Cap", 80, 0, string.Empty)
                                                                    };

        /// <summary>
        /// Get if the current environment that this is running on is TestNet
        /// </summary>
        public static bool isEnvironmentTestNet
        {
            get
            {
                if (!Config.Environment.Name.Equals("testnet", StringComparison.OrdinalIgnoreCase))
                {
                    return false;
                }

                return true;
            }
        }

        /// <summary>
        /// Get if the current environment that this is running On a One Box Locally
        /// </summary>
        public static bool isEnvironmentLocalRun
        {
            get
            {
                if (!Config.Environment.Name.Equals("local", StringComparison.OrdinalIgnoreCase))
                {
                    return false;
                }

                return true;
            }
        }

        /// <summary>
        /// Gets the environment that currently active based off the Projects App.config
        /// </summary>
        public static LiveNew.Test.EnvironmentElement RunningEnvironment
        {
            get
            {
                string environmentName;

                if (_RunningEnvironment != null)
                {
                    return _RunningEnvironment;
                }

                environmentName = Config.EnvironmentSettings.SelectedEnvironment.Name;

                // Set the Selected Environment based off the Selected Base Environment
                _RunningEnvironment = CurrentEnvironmentSettings.AllEnvironmentSettings.Environments[environmentName];
                if (_RunningEnvironment == null)
                {
                    throw new Exception("Count not find Environment name '" + environmentName + "' within the config.");
                }

                return _RunningEnvironment;
            }
        }
        private static LiveNew.Test.EnvironmentElement _RunningEnvironment;

        #region Validate Events

        public static DateTime TestStartTime;

        /// <summary>
        /// Verify that no unexpected events were thrown during the execution of the test
        /// </summary>
        public static void ValidateEvents()
        {
            List<EventLogEntry> foundEvents = new List<EventLogEntry>();

            // TODO convert the last x seconds of events with a start time and end time. By pulling the exect time of the machine you looking for the logs on.
            foundEvents.AddRange(SSRTestService.GetEntriesBySourceContainsWithinTimeSpan("avatarsvcs_", (int)DateTime.Now.Subtract(TestStartTime).TotalSeconds + 1, null));

            if (foundEvents.Count > 0)
            {
                foreach (EventLogEntry entry in foundEvents)
                {
                    if ((entry.EntryType == EventLogEntryType.Error) || (entry.EntryType == EventLogEntryType.Warning) || (entry.EntryType == EventLogEntryType.FailureAudit))
                    {
                        Trace.WriteLine("EVENT FOUND: \r\n**********\r\nEvent ID:  " + entry.InstanceId.ToString() + "\r\nSource:  " + entry.Source + "\r\nLevel:  " + entry.EntryType.ToString() + "\r\nWrite Time: " + entry.TimeWritten.ToString() + "\r\nDescription:\r\n" + entry.Message + "\r\n**********\r\n");
                    }
                    else
                    {
                        // Currently we do not care about any other events.
                    }
                }

                Thread.Sleep(1000); // If there were any events found, sleep 1 second to make sure the next test doesn't pick up previous events.
            }
        }

        /// <summary>
        /// Verify that a specific event showed up within the event viewer. Does not matter how many times.
        /// </summary>
        /// <param name="eventID">Event Id to be found</param>
        public static void ValidateEvents(EventIDs eventID)
        {
            AssertEventFound(eventID, -1);
        }

        /// <summary>
        /// Verify that a specific event showed up X number of times.
        /// </summary>
        /// <param name="eventID">Event Id to be found</param>
        /// <param name="count">Total count of expected event. Set to -1 for any number of occurrences.</param>
        public static void ValidateEvents(EventIDs eventID, int count)
        {
            AssertEventFound(eventID, count);
        }

        public static void ValidateMultipleEvents(EventIDs[] eventIDs, int[] counts)
        {
            if (eventIDs.Length != counts.Length)
            {
                throw new ArgumentException("Number of events and the total count of those events has to be the same. Events: " + eventIDs.Length.ToString() + " Counts: " + counts.ToString());
            }

            for (int i = 0; i < eventIDs.Length; i++)
            {
                AssertEventFound(eventIDs[i], counts[i]);
            }
        }

        private static void AssertEventFound(EventIDs eventID, int numEvents)
        {
            bool eventPass = true;
            List<EventLogEntry> events;

            for (int retry = 10; retry > 0; retry--)
            {
                eventPass = true;
                events = SSRTestService.GetEntriesByIdWithinTimeSpan((int)eventID, (int)DateTime.Now.Subtract(TestStartTime).TotalSeconds + 1, null);

                // numEvents == -1 mean you don't care how many times it shows up
                if ( (numEvents != -1) && (numEvents != events.Count) )
                {
                    string errorMSG;

                    eventPass = false;
                    errorMSG = string.Format("FAILED: Expected {0} events of type " + eventID.ToString() + " ID: " + (int)eventID + ", but found {1} events.", numEvents, events.Count);

                    if (numEvents < events.Count)
                    {
                        // Found to many of the passed in event. No need to wait any longer for more to show up.
                        Assert.Fail(errorMSG);
                    }

                    Trace.WriteLine(errorMSG);
                }

                if (eventPass)
                {
                    break;
                }

                System.Threading.Thread.Sleep(500);
            }

            if (!eventPass)
            {
                Assert.Fail("Unexpected Event was thrown.");
            }
        }
        #endregion

        /// <summary>
        /// Compare the passed in images against eachother. 
        /// </summary>
        /// <param name="Expected">Expected image</param>
        /// <param name="Actual">Actual image</param>
        /// <returns>If they are different, then false is return. Else true is returned.</returns>
        public static bool CompareImages(byte[] Expected, byte[] Actual)
        {
            string actualPixel;
            string expectedPixel;
            Bitmap actualImage;
            Bitmap expectedImage;

            if ((Expected == null) || (Actual == null))
            {
                throw new ArgumentNullException("Expecting to have real images to compare.");
            }

            actualImage = new Bitmap(new MemoryStream(Actual));
            expectedImage = new Bitmap(new MemoryStream(Expected));

            if ((expectedImage.Width != actualImage.Width) ||
                 (expectedImage.Height != actualImage.Height)
               )
            {
                // Not the same size. So they can not be equal
                return false;
            }

            for (int w = 0; w < expectedImage.Width; w++)
            {
                for (int h = 0; h < expectedImage.Height; h++)
                {
                    expectedPixel = expectedImage.GetPixel(w, h).ToString();
                    actualPixel = actualImage.GetPixel(w, h).ToString();

                    if (expectedPixel != actualPixel)
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        #region Testnet user data because you can't award avatar assets in testnet


        public static TestUserData GetUserWithAwardAndMarketplace(bool hasAward, bool hasMarketplace)
        {
            TestUserData userData = new TestUserData();

            try
            {
                if (isEnvironmentTestNet)
                {
                    if (hasMarketplace && !hasAward) // Purchasing only marketplace asset works in testnet
                    {
                        User user = UserCache.Instance.GetUsers(1, AvatarGender.Both, 0, 0)[0];
                        user.PurchaseAssets(testMarketplaceList);

                        userData.User = user;
                        userData.Email = user.Email;
                        userData.Password = user.Password;
                        userData.Gamertag = user.Gamertag;
                        userData.AwardList = user.AwardList;
                        userData.PurchaseList = user.PurchaseList;
                    }
                    else if (!hasMarketplace) // Awardable doesn't work in testnet, so we use hardcoded user values.
                    {
                        userData.Email = "achonly@xboxtest.com";
                        userData.Password = "supersecret";
                        userData.AwardList = new List<AwardableAsset>();
                        userData.Gamertag = "achonly";
                        userData.AwardList = testAwardableList;
                        userData.PurchaseList = new List<MarketplaceAsset>();

                        RecoverAccount(userData.Email, userData.Password, true);
                    }
                    else
                    {
                        userData.Email = "achmkt@xboxtest.com";
                        userData.Password = "supersecret";
                        userData.Gamertag = "achmkt";
                        userData.AwardList = new List<AwardableAsset>();
                        userData.AwardList = testAwardableList;
                        userData.PurchaseList = testMarketplaceList;

                        RecoverAccount(userData.Email, userData.Password, true);
                    }
                }
                else
                {
                    User user = UserCache.Instance.GetUsers(1, AvatarGender.Both, 0, 0)[0];

                    if (hasAward)
                    {
                        user.AwardAssets(testAwardableList);
                    }

                    if (hasMarketplace)
                    {
                        user.PurchaseAssets(testMarketplaceList);
                    }

                    userData.User = user;
                    userData.Email = user.Email;
                    userData.Password = user.Password;
                    userData.Gamertag = user.Gamertag;
                    userData.AwardList = user.AwardList;
                    userData.PurchaseList = user.PurchaseList;
                }
            }
            catch (Exception exc)
            {
                if (exc.ToString().Contains("XOFF_E_INVALID_OFFER_ID") ||
                    exc.ToString().Contains("XONLINE_E_ACCOUNTS_ADD_PAYMENT_INSTRUMENT_ERROR"))
                {
                    Assert.Inconclusive("KNOWN ISSUE: One or more of the Asset(s) could not be found within the environment you are going against.\r\nException:\r\n:" + exc.ToString());
                }

                throw exc;
            }

            return userData;
        }

        public static bool RecoverAccount(string email, string password, bool exitTest)
        {
            try
            {
                Account account = new Account(email, password);
                return true;
            }
            catch (Exception ex)
            {
                if (exitTest)
                {
                    Assert.Inconclusive(string.Format("Failed to recover user {0}. Cannot continue test that require this user. Error details: {1}", email, ex.ToString()));
                }
                else
                {
                    Trace.WriteLine(string.Format("Failed to recover user {0}. Continuing test. Error details: {1}", email, ex.ToString()));
                }
            }
            return false;
        }
        #endregion

        #region Blacklist helper classes
            /// <summary>
            /// Contains Target Types used within the Target field of the Blacklist
            /// </summary>
            public static class TargetTypes
            {
                public const string Global = "global";
                public const string Platform = "platform";
                public const string TitleID = "titleid";
            }

            /// <summary>
            /// Default location of the Blacklist
            /// </summary>
            public static string lest_AvatarAssetFilterFileFullPath;

            /// <summary>
            /// Default interval of how often the Blacklist filter gets updated
            /// </summary>
            public static int lest_AvatarAssetFilterUpdateIntervalInSeconds;

            /// <summary>
            /// Default location of the Blacklist
            /// </summary>
            public static string AvatarAssetFilterFileFullPath; // TODO tie directly to DB get and update

            /// <summary>
            /// Default interval of how often the Blacklist filter gets updated
            /// </summary>
            public static int AvatarAssetFilterUpdateIntervalInSeconds; // TODO tie directly to DB get and update

            /// <summary>
            /// Quickly generate a blacklist based off the information passed in
            /// </summary>
            /// <param name="target">Target Filter Name</param>
            /// <param name="value">Value of the Target</param>
            /// <returns>Newly created BlackList structure</returns>
            public static BlacklistedAssets QuickCreateBlacklist(string target, string value)
            {
                BlacklistedAssets blacklist = new BlacklistedAssets();

                blacklist.Add(target, value);

                return blacklist;
            }

            /// <summary>
            /// Quickly generate a blacklist based off the information passed in
            /// </summary>
            /// <param name="target">Target Filter Name</param>
            /// <param name="value">Value of the Target</param>
            /// <param name="AssetGuid">Guid of the Asset to be added to the BlackList</param>
            /// <returns>Newly created BlackList structure</returns>
            public static BlacklistedAssets QuickCreateBlacklist(string target, string value, string AssetGuid)
            {
                BlacklistedAssets blacklist = new BlacklistedAssets();

                blacklist.Add(target, value);

                blacklist.Assets[0].Add(AssetGuid);

                return blacklist;
            }

            /// <summary>
            /// Update the Blacklist file and ensure it gets picked up by the service
            /// </summary>
            /// <param name="blacklist">Blacklist to be written</param>
            public static void UpdateBlacklist(BlacklistedAssets blacklist)
            {
                string xmlOutput;

                xmlOutput = blacklist.SerializeToXmlString();

                UpdateBlacklist(xmlOutput);
            }

            /// <summary>
            /// Update the Blacklist file and ensure it gets picked up by the service
            /// </summary>
            /// <param name="blacklistXML">Blacklist xml to be written</param>
            public static void UpdateBlacklist(string blacklistXML)
            {
                int retry = 3;
                StreamWriter sw;

                if (blacklistXML == null)
                {
                    throw new ArgumentNullException("blacklist");
                }

                while (true)
                {
                    try
                    {
                        using (sw = new StreamWriter(AvatarAssetFilterFileFullPath, false))
                        {
                            sw.Write(blacklistXML);
                        }

                        break;
                    }
                    catch (Exception exc)
                    {
                        retry--;
                        if (retry <= 0)
                        {
                            throw new Exception("Had trouble writing the blacklist file. File: '" + AvatarAssetFilterFileFullPath + "' \r\nException:\r\n" + exc.ToString());
                        }

                        Thread.Sleep(200);
                    }
                }

                // File has been written, now wait for the file to be picked up by the service
                Thread.Sleep(AvatarAssetFilterUpdateIntervalInSeconds * 1000);
            }
        #endregion Blacklist helper classes
    }

    public class TestUserData
    {
        public User User;
        public string Email;
        public string Password;
        public string Gamertag;
        public List<AwardableAsset> AwardList;
        public List<MarketplaceAsset> PurchaseList;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\EnvironmentTests_BVT.cs ===
﻿using System;
using AvatarServices.Test.AvatarProxy;
using Microsoft.XboxLive.Avatars.Internal;
using AvatarServices.Test.Common;
using AvatarServices.Test.UserCache;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace AvatarServices.Tests
{
    /// <summary>
    /// Tests used to ensure that the environment that the test are run against is up and running with the nessasary configurtion in place 
    /// </summary>
    [TestClass]
    public partial class EnvironmentTests
    {
        [TestMethod]
        [Owner("rsnyder")]
        [Description("Ensures that test's can get an STS tocken")]
        public void EnvironmentTests_BVT_STS_Token()
        {
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];
            ManifestReadPartProxy proxy = new ManifestReadPartProxy(user.Email, user.Password, true);

            try
            {
                proxy.GetManifest();

                // PASSED: Proxy was able to connect to the service without any issues. The is setup correctly.
            }
            catch (Exception exc)
            {
                if (exc.Message.Contains("Error getting STS"))
                {
                    // This is a known Environment issue
                    Assert.Fail("KNOWN ENVIRONMENT ISSUE: Unable to generate a STS token. This will cause a large number of tests to fail. SOLUTION: ? \r\nException:\r\n" + exc.ToString());
                }

                Assert.Fail("UNKNOWN ISSUE: Failed to connect to the Manifest Read Proxy. Investigate the issue and add approriate verification to ensure the issue and soultion is provided within this test. \r\nException:\r\n" + exc.ToString());
            }
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Ensures that test's can get users from LiveCache")]
        public void EnvironmentTests_BVT_GetUserFromLiveCache()
        {
            try
            {
                UserCache.Instance.CreateUsers(1, AvatarGender.Both, 0, 0);

                // PASSED
            }
            catch (Microsoft.XboxLive.Avatars.Internal.AvatarException exc)
            {
                Assert.Fail("KNOWN ENVIRONMENT ISSUE: Failed to create a manifest. \r\n" +
                            "POSSABLE ISSUE: The asset share is not available or configured incorrectly. \r\n" +
                            "\r\nEXCEPTION: \r\n" + exc.ToString()); 
            }
            catch(Exception exc)
            {
                if (exc.ToString().Contains("XErrFailedException"))
                {
                    if (exc.ToString().Contains("XONLINE_E_PASSPORT_ERROR"))
                    {
                        Assert.Fail("KNOWN ENVIRONMENT ISSUE: Passort service is down and test will not be able to log in. \r\n" +
                                    "POSSABLE ISSUE: Last time this happen, service magically just started working against with no intervention from us. \r\n" +
                                    "\r\nEXCEPTION: \r\n" + exc.ToString());
                    }

                    Assert.Fail("KNOWN ENVIRONMENT ISSUE: This is a 'catch all' error from LiveCache. But for this particular test, it failed to be able to Create a user via LiveCache. \r\n" +
                                "POSSABLE ISSUE: The 'Xbox Live ProfileCache Server' or 'Xbox Live Vortex Front Door' services are not started. \r\n" +
                                "POSSABLE ISSUE: There may be 'Accidental Catalog/Data Deletion' going on within the XBlob. \r\n" +
                                "\r\nEXCEPTION: \r\n" + exc.ToString());
                }

                Assert.Fail("UNKNOWN ISSUE: This is a 'catch all' error from LiveCache. Failed to be able to create a user via LiveCache. This will cause a large number of tests to fail. SOLUTION: ? \r\nException:\r\n" + exc.ToString());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\BlacklistTool_XML\BlacklistTool_XML_Tests.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.IO;
using System.Xml;
using System.Diagnostics;
using System.Xml.Linq;
using AvatarServices.Test.Common;
using AvatarServices.Test.BlacklistTool;
using Microsoft.XmlDiffPatch;

namespace AvatarServices.Tests.BlacklistTool_XML
{
    /// <summary>
    /// Summary description for BlacklistToo_XML
    /// </summary>
    [TestClass]
    public class BlacklistTool_XML_Tests
    {
        public BlacklistTool_XML_Tests()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        //copy BlackListedAssets.xml and Blocklist.xlsx to <internal> directory of output folder
        [DeploymentItem("BlackListedAssets.xml", "internal"), DeploymentItem("Blocklist.xlsx", "internal"), TestMethod]
        [Owner("srkalyan")]
        [Description(@"Verifies if <Internal_Drops\Avatars\BlockList\BlackListedAssets.xml> match the Excel <Internal_Drops\Avatars\BlockList\Blocklist.xlsx>")]
        public void BlacklistTool_XML_Check_Internal_Drop()
        {
            bool bIdentical = false;
            string internal_xml =  @"internal\BlackListedAssets.xml";
            string internal_excel = @"internal\Blocklist.xlsx";
            string Blacklist_Tool = "AvatarServices.Test.BlacklistTool.exe";

            if (!File.Exists(Blacklist_Tool) || !File.Exists(internal_xml) || !File.Exists(internal_excel))
            {
                Assert.Fail("One of the following files mising <BlackListedAssets.xml, Blocklist.xlsx, AvatarServices.Test.BlacklistTool.exe>");
            }            

            //Call the blacklist tool to generate the XML file

            // Use ProcessStartInfo class
            ProcessStartInfo startInfo = new ProcessStartInfo();
            startInfo.WorkingDirectory = Directory.GetCurrentDirectory();
            startInfo.CreateNoWindow = false;
            startInfo.UseShellExecute = false;
            startInfo.FileName = Blacklist_Tool;
            startInfo.WindowStyle = ProcessWindowStyle.Hidden;
            startInfo.Arguments = internal_excel;
            startInfo.RedirectStandardOutput = true;

            try
            {
                // Start the process with the info we specified.
                // Call WaitForExit and then the using statement will close.
                using (Process exeProcess = Process.Start(startInfo))
                {
                    exeProcess.WaitForExit();                    
                }
            }
            catch (Exception e)
            {
                Assert.Fail("Exception when invoking {0} \n"+e, Blacklist_Tool);
            }

            System.Threading.Thread.Sleep(5000);
            string xml_file_generated = "BlackListedAssets.xml";
            string copy_xml = @"internal\xml_generated.xml";

            if (File.Exists(xml_file_generated))
            {                
                File.Copy(xml_file_generated, copy_xml);

                MemoryStream diffgram = new MemoryStream();
                XmlTextWriter diffgramWriter = new XmlTextWriter(new StreamWriter(diffgram));

                XmlDiff xmlDiff = new XmlDiff(XmlDiffOptions.IgnoreComments);
                bIdentical = xmlDiff.Compare(internal_xml, xml_file_generated, false, diffgramWriter);
            }
            else
            {
                Assert.Fail("Output file BlackListedAssets.xml was not generated");
            }

            Assert.IsTrue(bIdentical, "The internal checked-in XML file <{0}> do match the expected XML file <{1}>. Internal checked-in excel file is <{2}>", internal_xml, copy_xml, internal_excel);

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\Closet\ClosetTests.cs ===
﻿using System;
using Avatar.Services.Closet.Library;
using AvatarServices.Test.AvatarProxy;
using AvatarServices.Test.Common;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.XboxLive.Avatars;
using Microsoft.XboxLive.Avatars.Internal;
using System.Collections.Generic;
using System.Net;
using LiveN.Test.Avatar;
using AvatarServices.Test.UserCache;

using LiveN.Test;

namespace AvatarServices.Tests
{
    [TestClass]
    public partial class ClosetTests
    {
        /// <summary>
        /// Static user used to ensure the user exists and can make requests using them
        /// </summary>
        private static User staticDefaultUser;

        [ClassInitialize]
        public static void myClassInitialize(TestContext testContext)
        {
            BlacklistedAssets blacklist;

            if (CommonCode.isEnvironmentLocalRun)
            {
                CommonCode.AvatarAssetFilterFileFullPath = @"C:\BlackList\BlackListedAssets.xml";

                // Make sure that no Assets get blocked because of them being filtered
                blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0");
                CommonCode.UpdateBlacklist(blacklist);
            }

            staticDefaultUser = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Ensure the Closet service is working as expected when called with Partner Token")]
        public void ClosetTests_Partner_PartnerToken_BVT()
        {
            ClosetPartnerClientResponse response;
            ClosetPartnerClientRequest closetClient;

            closetClient = new ClosetPartnerClientRequest(
                                                CommonCode.RunningEnvironment,
                                                CommonCode.RunningEnvironment.UserSettings[0].UserEmail,
                                                CommonCode.RunningEnvironment.UserSettings[0].Password);

            // Set the Requested Token to be a Partner Token
            closetClient.RequestedToken = RequestedTokenEnum.PartnerToken;

            response = closetClient.MakeARequest();

            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, "Incorrect status code.");
            Assert.IsTrue(response.Body.Contains("<ClosetAssets"), "Response did not contain a ClosetAssets xml field. Response Body: \r\n" + response.Body);
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Ensure the Closet service is working as expected when called with User Token")]
        public void ClosetTests_Partner_UserToken_BVT()
        {
            ClosetPartnerClientResponse response;
            ClosetPartnerClientRequest closetClient;

            closetClient = new ClosetPartnerClientRequest(
                                                CommonCode.RunningEnvironment,
                                                CommonCode.RunningEnvironment.UserSettings[0].UserEmail,
                                                CommonCode.RunningEnvironment.UserSettings[0].Password);

            // Set the Requested Token to be a User Token
            closetClient.RequestedToken = RequestedTokenEnum.UserToken;

            response = closetClient.MakeARequest();

            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, "Incorrect status code.");
            Assert.IsTrue(response.Body.Contains("<ClosetAssets"), "Response did not contain a ClosetAssets xml field. Response Body: \r\n" + response.Body);
        }

        [TestMethod]
        public void ClosetTests_Returns_Valid_Marketplace_Asset_Partner()
        {
            TestUserData user = CommonCode.GetUserWithAwardAndMarketplace(false, true);
            ClosetPartProxy proxy = new ClosetPartProxy(user.Email, user.Password);
            ClosetTests_Returns_Valid_Assets(proxy, user);
        }

        [TestMethod]
        public void ClosetTests_Returns_Valid_Awardable_Asset_Partner()
        {
            TestUserData user = CommonCode.GetUserWithAwardAndMarketplace(true, false);
            ClosetPartProxy proxy = new ClosetPartProxy(user.Email, user.Password);

            try
            {
                ClosetTests_Returns_Valid_Assets(proxy, user);
            }
            catch (Exception exc)
            {
                try
                {
                    CommonCode.ValidateEvents(EventIDs.LIVECACHE_UnknownError);
                }
                catch
                {
                    // Unknow issue
                    throw exc;
                }

                Assert.Inconclusive("KNOWN ISSUE: One or more of the Asset(s) could not be found within the environment you are going against.\r\nException:\r\n:" + exc.ToString());
            }
        }

        [TestMethod]
        public void ClosetTests_Returns_Multiple_Assets_Partner()
        {
            TestUserData user = CommonCode.GetUserWithAwardAndMarketplace(false, true);
            ClosetPartProxy proxy = new ClosetPartProxy(user.Email, user.Password);
            ClosetTests_Returns_Valid_Assets(proxy, user);
        }

        private void ClosetTests_Returns_Valid_Assets(ClosetProxy proxy, TestUserData user)
        {
            ClosetAssets assets = proxy.GetAssets();
            AssertAssetCollectionsAreEqual(user, assets);
        }

        [TestMethod]
        public void ClosetTests_Invalid_Locale_Partner()
        {
            string culture = "xx-XX";
            ClosetPartProxy proxy = new ClosetPartProxy(staticDefaultUser.Email, staticDefaultUser.Password, culture, Config.Environment.StsSettings.PlatformType);

            // Invalid culture should not throw any errors
            proxy.GetAssets();
        }

        [TestMethod]
        public void ClosetTests_Locale_Wrong_Size_Partner()
        {
            string culture = "en-USA";
            ClosetPartProxy proxy = new ClosetPartProxy(staticDefaultUser.Email, staticDefaultUser.Password, culture, Config.Environment.StsSettings.PlatformType);

            // Invalid culture should not throw any errors
            proxy.GetAssets();
        }

        [TestMethod]
        public void ClosetTests_Missing_Locale_Partner()
        {
            ClosetPartProxy proxy = new ClosetPartProxy(staticDefaultUser.Email, staticDefaultUser.Password, null, Config.Environment.StsSettings.PlatformType);

            // Invalid culture should not throw any errors
            proxy.GetAssets();
        }

        [TestMethod]
        [WorkItem(8451)]
        [Owner("rsnyder")]
        [Description("Sending up a different Locale then the users Billing Info has")]
        public void ClosetTests_DifferentLocales()
        {
            TestUserData userData = CommonCode.GetUserWithAwardAndMarketplace(false, true);
            ClosetPartProxy proxy = new ClosetPartProxy(userData.Email, userData.Password, "fr-FR", Config.Environment.StsSettings.PlatformType);

            ClosetTests_Returns_Valid_Assets(proxy, userData);
        }

        private void AssertAssetCollectionsAreEqual(TestUserData user, ClosetAssets closetAssets)
        {
            bool found = false;
            List<MarketplaceAsset> userMarketplaceAssets = user.PurchaseList;
            List<AwardableAsset> userAwardableAssets = user.AwardList;
            int totalExpectedAssetCount = userMarketplaceAssets.Count + userAwardableAssets.Count;

            if ((CommonCode.isEnvironmentTestNet) && (userMarketplaceAssets.Count > 0))
            {
                // One of the Market Place Items is filtered out within TestNet. 
                Assert.AreEqual(totalExpectedAssetCount - 1, closetAssets.assets.Length, "Expected {0} Assets, but Closet only returned {1} assets", totalExpectedAssetCount, closetAssets.assets.Length);
            }
            else
            {
                Assert.AreEqual(totalExpectedAssetCount, closetAssets.assets.Length, "Expected {0} Assets, but Closet only returned {1} assets", totalExpectedAssetCount, closetAssets.assets.Length);
            }
            
            foreach (Asset closetAsset in closetAssets.assets)
            {
                found = false;

                foreach (MarketplaceAsset mpAsset in userMarketplaceAssets)
                {
                    if (String.Compare(mpAsset.Id.ToString(),closetAsset.id, true) == 0)
                    {
                        found = true;
                        Assert.AreEqual(mpAsset.Description, closetAsset.title, "Expected Title of {0}. Received Title of {1}", mpAsset.Description, closetAsset.title);
                        break;
                    }
                }

                if (!found)
                {
                    foreach (AwardableAsset awardAsset in userAwardableAssets)
                    {
                        if (String.Compare(awardAsset.Id.ToString(), closetAsset.id, true) == 0)
                        {
                            found = true;
                            Assert.AreEqual(awardAsset.Title, closetAsset.title, "Expected Title of {0}. Received Title of {1}", awardAsset.Title, closetAsset.title);
                            Assert.AreEqual(awardAsset.Description, closetAsset.description, "Expected Description of {0}. Received Description of {1}", awardAsset.Description, closetAsset.description);
                            break;
                        }
                    }
                }

                if(!found)
                {
                    Assert.Fail("Closet service returned asset named {0}, but the user did not contain this asset", closetAsset.title);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\EventLog\EventLogTests.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Collections;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Threading;
using LiveN.Test.Common;
using Leet.Core.Diagnostics;
using Leet.Core.IoCCo;
using Leet.Core.Configuration;
using Leet.Core.IO;
using LiveN.Test.Framework.LiveN_NPDB;

namespace AvatarServices.Tests.EventLogs
{
    /// <summary>
    /// TestEvent class is the test class used to test events
    /// </summary>

    public class TestEvent : BaseEvent
    {
        public TestEvent() :
            base(7007, TraceEventType.Error, "The TestEvent has initialized")
        { }

        public TestEvent(int event_id, TraceEventType type, string message) :
            base(event_id, type, message)
        { }

    }

    /// <summary>
    /// Summary description for EventLogTests
    /// </summary>
    [TestClass]
    public class EventLogTests
    {
        ILogging Logger;
        string machine;
        string source;
        string log;
        const int Test_EventID = 7007;

        public EventLogTests()
        {                       
            //set the machine, source and log values
            machine = "."; 
            log = "Application";
            source= "avatarsvcs_closet_part"; // We need to use one of existing registered source names for Looging to work and using this value

            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<ILogging, Logging>();
            Container.Instance.AddService<ILogFormatter, LogFormatter>();
            ConfigurationSelector.RegisterProvider(source, "LEET");

            Logger = Container.Instance.GetComponent<ILogging>();
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        [Owner("srkalyan")]
        [Description("Verifies if TraceEventType.Critical gets logged into Eventlogs")]
        public void TestEvent_TraceCritial_LogError()
        {
            EventViewer e = new EventViewer(machine, log, source);           
            Logger.LogEvent(new TestEvent(Test_EventID, TraceEventType.Critical, "Test1"));

            int count = e.SearchtEvent(Test_EventID, EventLogEntryType.Error, "Test1");

            if (0 == count)
            {
                Assert.Fail("Event ID: {0}, Type: {1}, Message: {2} not found", Test_EventID, EventLogEntryType.Error, "Test1");
            }
            else if (1 < count)
            {
                Assert.Fail("Event ID: {0} found more than once, total count =  {1}", Test_EventID, count);
            }
        }

        [TestMethod]
        [Owner("srkalyan")]
        [Description("Verifies if TraceEventType.Error gets logged into Eventlogs")]
        public void TestEvent_TraceError_LogError()
        {
            EventViewer e = new EventViewer(machine, log, source);                        
            Logger.LogEvent(new TestEvent(Test_EventID, TraceEventType.Error, "Test1"));

            int count = e.SearchtEvent(Test_EventID, EventLogEntryType.Error, "Test1");

            if (0 == count)
            {
                Assert.Fail("Event ID: {0}, Type: {1}, Message: {2} not found", Test_EventID, EventLogEntryType.Error, "Test1");
            }
            else if (1 < count)
            {
                Assert.Fail("Event ID: {0} found more than once, total count =  {1}", Test_EventID, count);
            }
        }

        [TestMethod]
        [Owner("srkalyan")]
        [Description("Verifies if TraceEventType.Information gets logged into Eventlogs")]
        public void TestEvent_TraceInformation_LogInformation()
        {
            EventViewer e = new EventViewer(machine, log, source);            
            Logger.LogEvent(new TestEvent(Test_EventID, TraceEventType.Information, "Test1"));

            int count = e.SearchtEvent(Test_EventID, EventLogEntryType.Information, "Test1");

            if (0 == count)
            {
                Assert.Fail("Event ID: {0}, Type: {1}, Message: {2} not found", Test_EventID, EventLogEntryType.Information, "Test1");
            }
            else if (1 < count)
            {
                Assert.Fail("Event ID: {0} found more than once, total count =  {1}", Test_EventID, count);
            }
        }

        [TestMethod]
        [Owner("srkalyan")]
        [Description("Verifies if TraceEventType.Resume gets logged into Eventlogs")]
        public void TestEvent_TraceResume_LogInformation()
        {
            EventViewer e = new EventViewer(machine, log, source);

            Logger = Container.Instance.GetComponent<ILogging>();
            Logger.LogEvent(new TestEvent(Test_EventID, TraceEventType.Resume, "Test1"));

            int count = e.SearchtEvent(Test_EventID, EventLogEntryType.Information, "Test1");

            if (0 == count)
            {
                Assert.Fail("Event ID: {0}, Type: {1}, Message: {2} not found", Test_EventID, EventLogEntryType.Information, "Test1");
            }
            else if (1 < count)
            {
                Assert.Fail("Event ID: {0} found more than once, total count =  {1}", Test_EventID, count);
            }
        }

        [TestMethod]
        [Owner("srkalyan")]
        [Description("Verifies if TraceEventType.Start gets logged into Eventlogs")]
        public void TestEvent_TraceStart_LogInformation()
        {
            EventViewer e = new EventViewer(machine, log, source);

            Logger = Container.Instance.GetComponent<ILogging>();
            Logger.LogEvent(new TestEvent(Test_EventID, TraceEventType.Start, "Test1"));

            int count = e.SearchtEvent(Test_EventID, EventLogEntryType.Information, "Test1");

            if (0 == count)
            {
                Assert.Fail("Event ID: {0}, Type: {1}, Message: {2} not found", Test_EventID, EventLogEntryType.Information, "Test1");
            }
            else if (1 < count)
            {
                Assert.Fail("Event ID: {0} found more than once, total count =  {1}", Test_EventID, count);
            }
        }

        [TestMethod]
        [Owner("srkalyan")]
        [Description("Verifies if TraceEventType.Stop gets logged into Eventlogs")]
        public void TestEvent_TraceStop_LogInformation()
        {
            EventViewer e = new EventViewer(machine, log, source);

            Logger = Container.Instance.GetComponent<ILogging>();
            Logger.LogEvent(new TestEvent(Test_EventID, TraceEventType.Stop, "Test1"));           

            int count = e.SearchtEvent(Test_EventID, EventLogEntryType.Information, "Test1");

            if (0 == count)
            {
                Assert.Fail("Event ID: {0}, Type: {1}, Message: {2} not found", Test_EventID, EventLogEntryType.Information, "Test1");
            }
            else if (1 < count)
            {
                Assert.Fail("Event ID: {0} found more than once, total count =  {1}", Test_EventID, count);
            }
        }

        [TestMethod]
        [Owner("srkalyan")]
        [Description("Verifies if TraceEventType.Suspend gets logged into Eventlogs")]
        public void TestEvent_TraceSuspend_LogInformation()
        {
            EventViewer e = new EventViewer(machine, log, source);

            Logger = Container.Instance.GetComponent<ILogging>();
            Logger.LogEvent(new TestEvent(Test_EventID, TraceEventType.Suspend, "Test1"));            

            int count = e.SearchtEvent(Test_EventID, EventLogEntryType.Information, "Test1");

            if (0 == count)
            {
                Assert.Fail("Event ID: {0}, Type: {1}, Message: {2} not found", Test_EventID, EventLogEntryType.Information, "Test1");
            }
            else if (1 < count)
            {
                Assert.Fail("Event ID: {0} found more than once, total count =  {1}", Test_EventID, count);
            }
        }

        [TestMethod]
        [Owner("srkalyan")]
        [Description("Verifies if TraceEventType.Transfer gets logged into Eventlogs")]
        public void TestEvent_TraceTransfer_LogInformation()
        {
            EventViewer e = new EventViewer(machine, log, source);

            Logger = Container.Instance.GetComponent<ILogging>();
            Logger.LogEvent(new TestEvent(Test_EventID, TraceEventType.Transfer, "Test1"));           

            int count = e.SearchtEvent(Test_EventID, EventLogEntryType.Information, "Test1");

            if (0 == count)
            {
                Assert.Fail("Event ID: {0}, Type: {1}, Message: {2} not found", Test_EventID, EventLogEntryType.Information, "Test1");
            }
            else if (1 < count)
            {
                Assert.Fail("Event ID: {0} found more than once, total count =  {1}", Test_EventID, count);
            }
        }

        [TestMethod]
        [Owner("srkalyan")]
        [Description("Verifies if TraceEventType.verbose gets logged into Eventlogs")]
        public void TestEvent_TraceVerbose_LogInformation()
        {
            EventViewer e = new EventViewer(machine, log, source);

            Logger = Container.Instance.GetComponent<ILogging>();
            Logger.LogEvent(new TestEvent(Test_EventID, TraceEventType.Verbose, "Test1"));           

            int count = e.SearchtEvent(Test_EventID, EventLogEntryType.Information, "Test1");

            if (0 == count)
            {
                Assert.Fail("Event ID: {0}, Type: {1}, Message: {2} not found", Test_EventID, EventLogEntryType.Information, "Test1");
            }
            else if (1 < count)
            {
                Assert.Fail("Event ID: {0} found more than once, total count =  {1}", Test_EventID, count);
            }
        }

        [TestMethod]
        [Owner("srkalyan")]
        [Description("Verifies if TraceEventType.Warning gets logged into Eventlogs")]
        public void TestEvent_TraceWarning_LogInformation()
        {
            EventViewer e = new EventViewer(machine, log, source);

            Logger = Container.Instance.GetComponent<ILogging>();
            Logger.LogEvent(new TestEvent(Test_EventID, TraceEventType.Warning, "Test1"));            

            int count = e.SearchtEvent(Test_EventID, EventLogEntryType.Warning, "Test1");

            Trace.TraceInformation("Event search {0}", e.Search_EventID(Test_EventID));
            Trace.TraceInformation("Message search {0}", e.SearchMessage("Test1"));
            Trace.TraceInformation("Total Events {0}", e.GetTotal_Events());
            Trace.TraceInformation("Total Errors {0}", e.GetTotal_ErrorEvents());
            Trace.TraceInformation("Total Warnings {0}", e.GetTotal_WarningEvents());
            Trace.TraceInformation("Total info {0}", e.GetTotal_InformationEvents());

            if (0 == count)
            {
                Assert.Fail("Event ID: {0}, Type: {1}, Message: {2} not found", Test_EventID, EventLogEntryType.Warning, "Test1");
            }
            else if (1 < count)
            {
                Assert.Fail("Event ID: {0} found more than once, total count =  {1}", Test_EventID, count);
            }
        }

        [TestMethod]
        [Owner("srkalyan")]
        [Description("Test for LiveN_NPDB framework library")]
        public void Test_Demo_LiveN_NPDB()
        {
            LiveN_NPDB npdb = new LiveN_NPDB(".");

            string temp = npdb.t_settings.lest_AvatarAssetFilterFileFullPath.vc_value;

            npdb.t_settings.lest_AvatarAssetFilterFileFullPath.vc_value = @"c:\temp";
            Assert.AreEqual(@"c:\temp", npdb.t_settings.Generic("lest_AvatarAssetFilterFileFullPath").vc_value, "lest_AvatarAssetFilterFileFullPath value failed to set to <c:\temp>");

            npdb.t_settings["lest_AvatarAssetFilterFileFullPath"].vc_value = temp;
            Assert.AreEqual(temp, npdb.t_settings["lest_AvatarAssetFilterFileFullPath"].vc_value, "lest_AvatarAssetFilterFileFullPath value failed to set to {0}", temp);

            LiveN_NPDB.t_settings_class.row blacklist_path = npdb.t_settings.Generic("lest_AvatarAssetFilterFileFullPath");
            blacklist_path.vc_value = @"c:\temp1";
            Assert.AreEqual(@"c:\temp1", blacklist_path.vc_value, "lest_AvatarAssetFilterFileFullPath value failed to set to <c:\temp1>");

            npdb.t_settings["lest_AvatarAssetFilterFileFullPath"].vc_value = temp;
            Assert.AreEqual(temp, blacklist_path.vc_value, "lest_AvatarAssetFilterFileFullPath value failed to set to {0}", temp);
           
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\GamerPic\GamerPicTests.cs ===
﻿using System;
using Avatar.Services.ManifestWrite.Library;
using AvatarServices.Test.AvatarProxy;
using AvatarServices.Test.Common;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Leet.Core.TestService.Client.DiagnosticDatabase;
using Infrastructure.Test.Common.Logging;
using AvatarServices.Test.UserCache;
using Microsoft.XboxLive.Avatars.Internal;

namespace AvatarServices.Tests
{
    [TestClass]
    public partial class GamerPicTests
    {
        [TestInitialize]
        public void MyTestInitialize()
        {
            CommonCode.TestStartTime = DateTime.Now;
        }

        [TestCleanup]
        public void MyTestCleanUp()
        {
            CommonCode.ValidateEvents();
        }

        [TestMethod]
        [WorkItem(8054)]
        [Owner("rsnyder")]
        [Description("Verify that the GamerPic adds entries into the Diagnostic DB")]
        public void GamerPicTests_Diagnostic()
        {
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];
            GamerPicPartnerProxy gamerPicProxy = new GamerPicPartnerProxy(user.Email, user.Password);

            UpdateGamerPicRequest request = SSRTests.GenerateUpdateGamerPicRequest();

            UpdateGamerPicResponse response = gamerPicProxy.UpdateGamerPic(request);
            Assert.AreEqual<int>(0, response.SuccessCode, "ERROR: Unexpected response code " + response.SuccessCode);

            DiagnosticDatabaseTestService diagnosticService = new DiagnosticDatabaseTestService(Config.Environment.CoreTestServiceBaseUrl);
            //Find Trace event signifying that gamer pic update succeeded
            SqlEvent foundEvent = diagnosticService.GetDiagnosticEntryBySourceAndMessageText("avatarsvcs_manwritepart", 1, String.Format("GamerPic updater succeeded for XUID {0}.", user.Xuid));
            Assert.IsNotNull(foundEvent, String.Format("Could not find gamer pic update succeeded event for user: {0}", user.Xuid));

            foundEvent = null;
            //Find Trace event signifying that the SSR service picked up the gamerpic update
            foundEvent = diagnosticService.GetDiagnosticEntryBySourceAndMessageText("avatarsvcs_serversiderenderer", 1, String.Format("Received GenerateGamerPictureMessage. XUID: {0}", user.Xuid));
            Assert.IsNotNull(foundEvent, String.Format("Could not find server side renderer trace signifying that it received the gamer pic for user: {0}", user.Xuid));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\GamerPic\GamerPicTests_CameraPositions.cs ===
﻿using System;
using System.Net;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Reflection;
using Avatar.Services.ManifestWrite.Library;
using Avatar.Services.ServerSideRenderer.Messaging;
using AvatarServices.Test.AvatarProxy;
using AvatarServices.Test.Common;
using AvatarServices.Test.UserCache;
using Microsoft.XboxLive.Avatars.Internal;
using Microsoft.VisualStudio.TestTools.UnitTesting;

using LiveN.Test;

namespace AvatarServices.Tests
{
    [TestClass]
    public class GamerPicTests_CameraPositions
    {
        /// <summary>
        /// Default user
        /// </summary>
        private User user = null;

        /// <summary>
        /// Proxy used to communicate directly with GamerPic API that our partners will use
        /// </summary>
        private GamerPicPartnerProxy gamerPicProxy = null;

        /// <summary>
        /// GamerPic request used to call the front door GamerPic API
        /// </summary>
        private UpdateGamerPicRequest request = null;

        /// <summary>
        /// Message used to push directly on the SSR queue. By passing the front door
        /// </summary>
        private GenerateGamerPictureMessage message;

        /// <summary>
        /// Manifest used as the default configuration
        /// </summary>
        public const string AvatarManifest_Default = "000000003F8000003F80000000100000031C0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002FF0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002C20003C1C8F109A19CB2E03F80000000000000000000000000000000004000026A0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFBE8749FF372116FFD46552FF37512AFF372116FFFEC854FF372116FFB24F7DFFB24F7D0000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401F80003C1C8F109A19CB2E0000400000000000000000000000000000000002001050002C1C8F109A19CB2E0002000000000000000000000000000000000040005010002C1C8F109A19CB2E0040000000000000000000000000000000080001801720002C1C8F109A19CB2E0001800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001050002C1C8F109A19CB2E0002000000000000000000000000000000000001001590002C1C8F109A19CB2E00010000000000000000000000000000000000008011F0002C1C8F109A19CB2E0000800000000000000000000000000000000000401F80003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

        /// <summary>
        /// Gets or sets the test context which provides
        /// information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get;
            set;
        }

        [TestInitialize]
        public void myTestInitialize()
        {
            SSRTests.RestGamerPicImages();

            // Setup the Default User
            user = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];
            user.ManifestString = AvatarManifest_Default;
            user.WriteManifest(true, Config.Environment.ManifestWritePartService);

            SSRTests.ResetAllImages(user.Xuid);

            // Setup the proxy used to call the font door GamerPic API that our partners call
            gamerPicProxy = new GamerPicPartnerProxy(user.Email, user.Password);

            // GamerPic request used to call the front door GamerPic API
            request = SSRTests.GenerateUpdateGamerPicRequest();

            // Message used to push directly on the SSR queue. By passing the front door
            message = SSRTests.CreateCenteredDiagnosticGamerPicMessage(user);
        }

        [TestCleanup]
        public void myTestCleanup()
        {
            // Write out any of the image that may have been used within the last test
            SSRTests.WriteImages(this.TestContext.TestName);
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Ensure the GamerPic service is working as expected when called with Partner Token")]
        public void GamerPicTests_Partner_PartnerToken_BVT()
        {
            GamerPicClientPartnerResponse response;
            GamerPicClientPartnerRequest gamerPicClient;

            gamerPicClient = new GamerPicClientPartnerRequest(
                                                CommonCode.RunningEnvironment,
                                                CommonCode.RunningEnvironment.UserSettings[0].UserEmail,
                                                CommonCode.RunningEnvironment.UserSettings[0].Password);

            // Set the Requested Token to be a Partner Token
            gamerPicClient.RequestedToken = RequestedTokenEnum.PartnerToken;

            response = gamerPicClient.MakeARequest();

            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, "Incorrect status code.");
            Assert.AreEqual(0, response.BodyWrapper.SuccessCode, "Status code should be set to success. '0'. Response Body: \r\n" + response.Body);
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Ensure the GamerPic service is working as expected when called with User Token")]
        public void GamerPicTests_Partner_UserToken_BVT()
        {
            GamerPicClientPartnerResponse response;
            GamerPicClientPartnerRequest gamerPicClient;

            gamerPicClient = new GamerPicClientPartnerRequest(
                                                CommonCode.RunningEnvironment,
                                                CommonCode.RunningEnvironment.UserSettings[0].UserEmail,
                                                CommonCode.RunningEnvironment.UserSettings[0].Password);

            // Set the Requested Token to be a Partner Token
            gamerPicClient.RequestedToken = RequestedTokenEnum.UserToken;

            response = gamerPicClient.MakeARequest();

            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, "Incorrect status code.");
            Assert.AreEqual(0, response.BodyWrapper.SuccessCode, "Status code should be set to success. '0'. Response Body: \r\n" + response.Body);
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify how the camera positioning effects the output of the GamerPic in the expected way.")]
        public void GamerPicTests_BVT_CameraPosition_Centered()
        {
            GamerPicTests_CameraPosition_Centered();
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify how the camera positioning effects the output of the GamerPic in the expected way.")]
        public void GamerPicTests_CameraPosition_Centered()
        {
            UpdateGamerPicResponse response;

            // Using the backdoor, submit to GamerPic so we can verify the output image
            SSRTests.SendMessage(message);
            SSRTests.AssertDiagnosticImageFound(false, true);
            VerifyDiagnosticImageVersSaved();

            // Now verify that this same request setting can go through the front door GamerPic API
            response = gamerPicProxy.UpdateGamerPic(request);
            Assert.AreEqual(0, response.SuccessCode, "Did not get the expected response from the front door GamerPic API");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify how the camera positioning effects the output of the GamerPic")]
        public void GamerPicTests_CameraPosition_ToLeft()
        {
            UpdateGamerPicResponse response;

            // Move the Avatar to the far left
            message.OffsetX = SSRTests.GamerPicCameraBox.AvatarSSRGamerpicMinXOffset;

            // Using the backdoor, submit to GamerPic so we can verify the output image
            SSRTests.SendMessage(message);
            SSRTests.AssertDiagnosticImageFound(false, true);
            VerifyDiagnosticImageVersSaved();

            // Now verify that this same request setting can go through the front door GamerPic API
            request.OffsetX = message.OffsetX;

            response = gamerPicProxy.UpdateGamerPic(request);
            Assert.AreEqual(0, response.SuccessCode, "Did not get the expected response from the front door GamerPic API");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify how the camera positioning effects the output of the GamerPic")]
        public void GamerPicTests_CameraPosition_ToRight()
        {
            UpdateGamerPicResponse response;

            // Move the Avatar to the far right
            message.OffsetX = SSRTests.GamerPicCameraBox.AvatarSSRGamerpicMaxXOffset;

            // Using the backdoor, submit to GamerPic so we can verify the output image
            SSRTests.SendMessage(message);
            SSRTests.AssertDiagnosticImageFound(false, true);
            VerifyDiagnosticImageVersSaved();

            // Now verify that this same request setting can go through the front door GamerPic API
            request.OffsetX = message.OffsetX;

            response = gamerPicProxy.UpdateGamerPic(request);
            Assert.AreEqual(0, response.SuccessCode, "Did not get the expected response from the front door GamerPic API");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify how the camera positioning effects the output of the GamerPic")]
        public void GamerPicTests_CameraPosition_ToTop()
        {
            UpdateGamerPicResponse response;

            // Move the Avatar to the top
            message.OffsetY = SSRTests.GamerPicCameraBox.AvatarSSRGamerpicMaxYOffset;

            // Using the backdoor, submit to GamerPic so we can verify the output image
            SSRTests.SendMessage(message);
            SSRTests.AssertDiagnosticImageFound(false, true);
            VerifyDiagnosticImageVersSaved();

            // Now verify that this same request setting can go through the front door GamerPic API
            request.OffsetY = message.OffsetY;

            response = gamerPicProxy.UpdateGamerPic(request);
            Assert.AreEqual(0, response.SuccessCode, "Did not get the expected response from the front door GamerPic API");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify how the camera positioning effects the output of the GamerPic")]
        public void GamerPicTests_CameraPosition_ToBottom()
        {
            UpdateGamerPicResponse response;

            // Move the Avatar to the bottom
            message.OffsetY = SSRTests.GamerPicCameraBox.AvatarSSRGamerpicMinYOffset;

            // Using the backdoor, submit to GamerPic so we can verify the output image
            SSRTests.SendMessage(message);
            SSRTests.AssertDiagnosticImageFound(false, true);
            VerifyDiagnosticImageVersSaved();

            // Now verify that this same request setting can go through the front door GamerPic API
            request.OffsetY = message.OffsetY;

            response = gamerPicProxy.UpdateGamerPic(request);
            Assert.AreEqual(0, response.SuccessCode, "Did not get the expected response from the front door GamerPic API");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify how the camera positioning effects the output of the GamerPic")]
        public void GamerPicTests_CameraPosition_ZoomIn()
        {
            UpdateGamerPicResponse response;

            // Move the Avatar as close as possable
            message.FieldOfView = SSRTests.GamerPicCameraBox.AvatarSSRGamerpicMinFieldOfView; 

            // Using the backdoor, submit to GamerPic so we can verify the output image
            SSRTests.SendMessage(message);
            SSRTests.AssertDiagnosticImageFound(false, true);
            VerifyDiagnosticImageVersSaved();

            // Now verify that this same request setting can go through the front door GamerPic API
            request.FieldOfView = message.FieldOfView;

            response = gamerPicProxy.UpdateGamerPic(request);
            Assert.AreEqual(0, response.SuccessCode, "Did not get the expected response from the front door GamerPic API");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify how the camera positioning effects the output of the GamerPic")]
        public void GamerPicTests_CameraPosition_ZoomOut()
        {
            UpdateGamerPicResponse response;

            // Move the Avatar as far as possable
            message.FieldOfView = SSRTests.GamerPicCameraBox.AvatarSSRGamerpicMaxFieldOfView;

            // Using the backdoor, submit to GamerPic so we can verify the output image
            SSRTests.SendMessage(message);
            SSRTests.AssertDiagnosticImageFound(false, true);
            VerifyDiagnosticImageVersSaved();

            // Now verify that this same request setting can go through the front door GamerPic API
            request.FieldOfView = message.FieldOfView;

            response = gamerPicProxy.UpdateGamerPic(request);
            Assert.AreEqual(0, response.SuccessCode, "Did not get the expected response from the front door GamerPic API");
        }

        /// <summary>
        /// Verify the downloaded Diagnostic Images vers the images stored within the Assembly
        /// </summary>
        public void VerifyDiagnosticImageVersSaved()
        {
            string assemblyRoot = "AvatarServices.Tests.GamerPic.Verification_Images.";

            SSRTests.VerifyDiagnosticImageVersSaved(Assembly.GetExecutingAssembly(), assemblyRoot, this.TestContext);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\ClosetPerf\ClosetPerfTests.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using Avatar.Services.Closet.Library;
using AvatarServices.Test.AvatarProxy;
using AvatarServices.Test.Common;
using AvatarServices.Test.UserCache;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.XboxLive.Avatars.Internal;
using LiveN.Test.Avatar;

namespace AvatarServices.Tests
{
    /***************************
     * Setup steps:
     *  1. Run: ClosetTests_PerfSetup
     *  2. Update with the new user: proxyTitleID = new ClosetPartProxy("LLa1459aoiai1@xbltest.com", "supersecret");
     *  3. Update blacklist file to the below location
     *  4. Go to t_settings and change lest_AvatarAssetFilterFileFullPath = \\LIVEnfile01\AvatarResources\584d07d1\AssetFiltering\BlackListedAssets_Robs.xml
     *  5. Change lest_AvatarAssetFilterUpdateIntervalInSeconds = 600 // Ten mins
     *  6. Stop and start w3svc
     *  
     * 
     */

    /// <summary>
    /// Summary description for UnitTest1
    /// </summary>
    [TestClass]
    public class ClosetPerfTests
    {
        /// <summary>
        /// Gets or sets the test context which provides
        /// information about and functionality for the current test run.
        ///</summary>
        public TestContext testContext
        {
            get;
            set;
        }

        static ClosetPartProxy proxyTitleID;

        [ClassInitialize()]
        public static void MyClassInitialize(TestContext testContext)
        {
            proxyTitleID = new ClosetPartProxy("LLa1459aoiai1@xbltest.com", "supersecret");
        }

        [TestMethod]
        [Owner("rsnyder")]
        public void ClosetPerfTests_GetAssets()
        {
            ClosetAssets assets = proxyTitleID.GetAssets();

            Assert.AreEqual(1, assets.assets.Length, "Response is emulated. This should always be 1.");
            Assert.AreEqual("Diamond Bling Earrings", assets.assets[0].title, "The Asset returned was not the correct one. Check which assets your filtering.");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Test case used to generate all required files and values in order to perform a test")]
        public void ClosetPerfTests_PerfSetup()
        {
            Trace.WriteLine("***STARTING: Ensure the user has all Asset possable to cause the most filtering");
            Trace.WriteLine("");

            // Get all available Awardable Assets
            List<AwardableAsset> assets = AwardableAssetCollection.Instance.FindAll(AvatarGender.Male);
            if (assets.Count == 0)
            {
                Assert.Fail("Asserts are required in order to user the blacklist filtering feature");
            }

            #region Get a user so you can add the Awardable Asset to
                for (int i = 0; i < 2; i++)
                {
                    User user = UserCache.Instance.GetUser(AvatarGender.Male);
                    SSRTests.ResetAllImages(user.Xuid);

                    Trace.WriteLine("***USE THIS User[" + i.ToString() + "] Email: " + user.Email);
                    Trace.WriteLine("***USE THIS User[" + i.ToString() + "] Password: " + user.Password);

                    // Equip all Awardable assets
                    for (int x = 0; x < assets.Count; x++)
                    {
                        user.AwardAsset(assets[x]);
                    }

                    // After the user has equiped an asset, it has to be written to there manifest
                    user.WriteManifest(true, Config.Environment.ManifestWritePartService);

                    ClosetPartProxy proxy = new ClosetPartProxy(user.Email, user.Password);

                    ClosetAssets usersAssets = proxy.GetAssets();

                    Assert.AreEqual(assets.Count, usersAssets.assets.Length, "For some reason the user[" + i.ToString() + "] did not get all the Assets. Check to make sure you have not updated the filter list as they could just be getting filtered out.");
                }
            #endregion Get a user so you can add the Awardable Asset to

            #region Create Blacklist Filter file
                Random rnd = new Random();
                string xmlOutput = string.Empty;
                BlacklistedAssets blacklist = new BlacklistedAssets();
                
                blacklist.Add("global", "0");
                blacklist.Add("titleid", "584D07D6");
                blacklist.Add("titleid", "000D07D1");
                blacklist.Add("titleid", "000D07D2");
                blacklist.Add("titleid", "000D07D3");
                blacklist.Add("titleid", "000D07D4");

                for (int i = 0; i < assets.Count; i++)
                {
                    blacklist.Assets[0].Add(assets[i].Id.ToString());

                    // Now buffer the file with invalid guids that are really close to the one just added. This is simulate what we will see in production.
                    for (int x = 0; x < (2500 / assets.Count); x++)
                    {
                        string newGuid;
                        string[] guid = assets[i].Id.ToString().Split('-');

                        newGuid = guid[0] + "-" + guid[1] + "-" + guid[2] + "-" + rnd.Next(0, 10000).ToString("0000") + "-" + guid[4];

                        blacklist.Assets[0].Add(newGuid);
                    }

                    if (i != 2)
                    {
                        blacklist.Assets[1].Add(assets[i].Id.ToString());

                        // Now buffer the file with invalid guids that are really close to the one just added. This is simulate what we will see in production.
                        for (int x = 0; x < (2500 / assets.Count); x++)
                        {
                            string newGuid;
                            string[] guid = assets[i].Id.ToString().Split('-');

                            newGuid = guid[0] + "-" + guid[1] + "-" + guid[2] + "-" + rnd.Next(0, 10000).ToString("0000") + "-" + guid[4];

                            blacklist.Assets[1].Add(newGuid);
                        }
                    }
                    else
                    {
                        Trace.WriteLine("***USE THIS Title will not filter out this asset. Asset Description: " + assets[i].Title);
                    }
                }

                // Now create other TitleIds that filter out everything
                for (int i = 0; i < assets.Count; i++)
                {
                    blacklist.Assets[2].Add(assets[i].Id.ToString());
                    blacklist.Assets[3].Add(assets[i].Id.ToString());
                    blacklist.Assets[4].Add(assets[i].Id.ToString());
                    blacklist.Assets[5].Add(assets[i].Id.ToString());
                }

                using (StreamWriter sw = new StreamWriter("BlackListedAssets.xml"))
                {
                    xmlOutput = blacklist.SerializeToXmlString();
                    sw.Write(xmlOutput);
                }

                Trace.WriteLine("***USE THIS Black List: " + (new FileInfo("BlackListedAssets.xml")).FullName); 
            #endregion Create Blacklist Filter file

            Trace.WriteLine("***");
            Trace.WriteLine("RUNNING Perf Against a different machine. You will have to update you HOST file and change the IP below to the IP of the machine you want to go against");
            Trace.WriteLine("127.0.0.1 	avatarread-origin.dev.xboxlive.com");
            Trace.WriteLine("127.0.0.1 	avatarread-part.dev.xboxlive.com");
            Trace.WriteLine("127.0.0.1 	avatarwrite-part.dev.xboxlive.com");
            Trace.WriteLine("127.0.0.1 	avatarcloset-part.dev.xboxlive.com");
            Trace.WriteLine("127.0.0.1 	coretest.dev.xboxlive.com");
            Trace.WriteLine("***");

            Trace.WriteLine("***FINISHED: Created all required stuff for the perf tests.");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\ManifestRead\ManifestReadTests.cs ===
﻿using System;
using System.Net;
using System.Text;
using Avatar.Services.ManifestRead.Library;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using AvatarServices.Test.Common;
using AvatarServices.Test.UserCache;
using AvatarServices.Test.AvatarProxy;

namespace AvatarServices.Tests
{
    /// <summary>
    /// Partial class containing only the functional tests for ManifestRead
    /// </summary>
    public partial class ManifestReadTests
    {
        [Description("Verify that a single gamertag with no avatar returns 0 manifest.")]
        [TestMethod]
        public void ManifestReadTests_Origin_NoAvatar()
        {
            User user = UserCache.Instance.GetUsersWithoutManifests();
            ManifestReadOriginProxy proxy = new ManifestReadOriginProxy(user.Gamertag);
            NoAvatar_Verification(proxy);
        }

        [Description("Verify that a single gamertag with no avatar returns 0 manifest.")]
        [TestMethod]
        public void ManifestReadTests_Partner_NoAvatar()
        {
            User user = UserCache.Instance.GetUsersWithoutManifests();
            ManifestReadPartProxy proxy = new ManifestReadPartProxy(user.Email, user.Password);
            NoAvatar_Verification(proxy);
        }

        private void NoAvatar_Verification(ManifestReadProxy proxy)
        {
            AvatarManifests m_TargetAvatarManifests = proxy.GetManifest();
            Assert.AreEqual<int>(0, m_TargetAvatarManifests.Manifests.Length, "Expected 0 manifests but received " + m_TargetAvatarManifests.Manifests.Length.ToString()); 
        }

        [Description("Verify that a single gamertag with avatar returns 1 manifest.")]
        [TestMethod]
        public void ManifestReadTests_Origin_HasAvatar()
        {
            User user = UserCache.Instance.GetUser();
            user.WriteManifest(true, Config.Environment.ManifestWritePartService);
            ManifestReadOriginProxy proxy = new ManifestReadOriginProxy(user.Gamertag);
            HasAvatar_Verification(proxy, user);
        }

        [Description("Verify that a single gamertag with avatar returns 1 manifest.")]
        [TestMethod]
        public void ManifestReadTests_Partner_HasAvatar()
        {
            User user = UserCache.Instance.GetUser();
            user.WriteManifest(true, Config.Environment.ManifestWritePartService);
            ManifestReadPartProxy proxy = new ManifestReadPartProxy(user.Email, user.Password);
            HasAvatar_Verification(proxy, user);
        }

        private void HasAvatar_Verification(ManifestReadProxy proxy, User user)
        {
            int retries = 30;
            AvatarManifests m_TargetAvatarManifests = null;

            for (int i = 0; i < retries; i++)
            {
                m_TargetAvatarManifests = proxy.GetManifest();
                if (m_TargetAvatarManifests.Manifests.Length > 0)
                    break;
                System.Diagnostics.Trace.WriteLine(string.Format("Manifest returned empty. Retry # {0}.", i));
                System.Threading.Thread.Sleep(1000);
            }

            Assert.IsNotNull(m_TargetAvatarManifests, "Manifest read response is null.");
            Assert.AreEqual<int>(1, m_TargetAvatarManifests.Manifests.Length);
            Assert.AreEqual<string>(user.Gamertag.ToLower(), m_TargetAvatarManifests.Manifests[0].Gamertag.ToLower());
            Assert.AreEqual<string>(user.ManifestString, m_TargetAvatarManifests.Manifests[0].Manifest);
        }

        #region Manifest Read Origin only tests
        [Description("Verify that the avatarread origin endpoint only accepts 1 gamertag.")]
        [TestMethod]
        public void ManifestReadTests_Origin_MultipleGamertagsRejected()
        {
            User[] users = UserCache.Instance.GetUsersWithManifests(2);
            AvatarManifests m_TargetAvatarManifests = GetAvatarManifestsObject(GetGamertagString(users), false);
            Assert.AreEqual<int>(0, m_TargetAvatarManifests.Manifests.Length, "Expected 0 manifests but received " + m_TargetAvatarManifests.Manifests.Length.ToString()); 
        }

        [Description("Verify that a request with no query parameter returns 0 manifest.")]
        [TestMethod]
        public void ManifestReadTests_Origin_NullGT()
        {
            AvatarManifests m_TargetAvatarManifests = GetAvatarManifestsObject(null, false);
            Assert.AreEqual<int>(0, m_TargetAvatarManifests.Manifests.Length, "Expected 0 manifests but received " + m_TargetAvatarManifests.Manifests.Length.ToString());
        }

        [Description("Verify that a request with an empty gamertag returns 0 manifest.")]
        [TestMethod]
        public void ManifestReadTests_Origin_EmptyGT()
        {
            AvatarManifests m_TargetAvatarManifests = GetAvatarManifestsObject(String.Empty, false);
            Assert.AreEqual<int>(0, m_TargetAvatarManifests.Manifests.Length, "Expected 0 manifests but received " + m_TargetAvatarManifests.Manifests.Length.ToString());
        }

        [Description("Verify that a single gamertag with a trailing extra space and an avatar returns 1 manifest.")]
        [TestMethod]
        public void ManifestReadTests_Origin_Gamertag_AppendExtraSpace()
        {
            User targetUsers = UserCache.Instance.GetUsersWithManifests();
            string gamertagString = targetUsers.Gamertag + " ";
            AvatarManifests m_TargetAvatarManifests = GetAvatarManifestsObject(gamertagString, true);

            //gamertags shouldn't end with a space, so the regex will reject this.
            Assert.AreEqual<int>(0, m_TargetAvatarManifests.Manifests.Length);
        }

        [TestMethod]
        public void ManifestReadTests_Origin_Gamertag_17chars()
        {
            string gt = GetRandomGamertag();
            AvatarManifests am = GetAvatarManifestsObject(gt + "A", false);
            Assert.AreEqual<int>(0, am.Manifests.Length, "Expected 0 manifests but received " + am.Manifests.Length.ToString());
        }

        [TestMethod]
        public void ManifestReadTests_Origin_Gamertag_Invalidchars()
        {
            char[] invalidChars = new char[] { '^', '\'', '\\', '#', 'ÿ', '\n', '향' };
            Random r = new Random();

            StringBuilder gt = new StringBuilder(GetRandomGamertag());
            gt[r.Next(gt.Length)] = invalidChars[r.Next(invalidChars.Length)];
            AvatarManifests am = GetAvatarManifestsObject(gt.ToString(), false);
            Assert.AreEqual<int>(0, am.Manifests.Length, "Expected 0 manifests but received " + am.Manifests.Length.ToString());
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\Closet\ClosetTests_BlacklistFilter.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Threading;
using System.Diagnostics;
using Avatar.Services.Closet.Library;
using AvatarServices.Test.AvatarProxy;
using AvatarServices.Test.Common;
using AvatarServices.Test.UserCache;
using Infrastructure.Test.Common;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.XboxLive.Avatars.Internal;
using LiveN.Test.Avatar;

namespace AvatarServices.Tests
{
    /***************************
     * Setup steps:
     *  1. Go to t_settings and change lest_AvatarAssetFilterFileFullPath = C:\BlackList\BlackListedAssets.xml
     *  2. Change lest_AvatarAssetFilterUpdateIntervalInSeconds = 1
     *  3. Stop and start w3svc
     *  
     * 
     */

    [TestClass]
    /// <summary>
    /// ManifestRead BlacklistFilter test cases
    /// </summary>
    public class ClosetTests_BlacklistFilter
    {
        /// <summary>
        /// Random number generator used to do Random things
        /// </summary>
        private readonly Random rnd = new Random();

        /// <summary>
        /// Member variable for AwardableAssets
        /// </summary>
        private List<AwardableAsset> AwardableAssets_Member;

        /// <summary>
        /// Get all available Male Awardable Assets
        /// </summary> 
        private List<AwardableAsset> AwardableAssets
        {
            get
            {
                if (AwardableAssets_Member == null)
                {
                    AwardableAssets_Member = AwardableAssetCollection.Instance.FindAll(AvatarGender.Male);
                    if (AwardableAssets_Member.Count == 0)
                    {
                        throw new Exception("Asserts are required in order to exequite this test");
                    }
                }

                return AwardableAssets_Member;
            }
        }

        [ClassInitialize]
        public static void myClassInitialize(TestContext testContext)
        {
            FileInfo file;

            // TODO Really extract the values t_setting_overrides
            CommonCode.lest_AvatarAssetFilterFileFullPath = @"\\LIVEnfile01\AvatarResources\584d07d1\AssetFiltering\BlackListedAssets.xml";
            CommonCode.lest_AvatarAssetFilterUpdateIntervalInSeconds = 14400;

            // TODO Really change these within the DB
            CommonCode.AvatarAssetFilterFileFullPath = @"C:\BlackList\BlackListedAssets.xml";
            CommonCode.AvatarAssetFilterUpdateIntervalInSeconds = 1;

            file = new FileInfo(CommonCode.AvatarAssetFilterFileFullPath);

            // Ensure the directory exists
            if (!Directory.Exists(file.DirectoryName))
            {
                Directory.CreateDirectory(file.DirectoryName);
            }
        }

        [TestInitialize]
        public void myTestInitialize()
        {
            CommonCode.TestStartTime = DateTime.Now;
        }

        [ClassCleanup]
        public static void myClassCleanup()
        {
            // TODO Really put the old values back within t_setting_overrides
            CommonCode.AvatarAssetFilterFileFullPath = CommonCode.lest_AvatarAssetFilterFileFullPath;
            CommonCode.AvatarAssetFilterUpdateIntervalInSeconds = CommonCode.lest_AvatarAssetFilterUpdateIntervalInSeconds;
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify default install of service is working as expected.")]
        public void ClosetTests_BVT_BlackListFilter()
        {
            ClosetPartProxy proxy;
            TestUserData user = null;
            ClosetAssets usersAssets;

            if (CommonCode.isEnvironmentLocalRun)
            {
                // Test is not running within TestNet, make sure this test is running against the correct Blacklist
                using (StreamReader sr = new StreamReader(Assembly.GetExecutingAssembly().GetManifestResourceStream(CommonCode.DEFUALT_BLACK_LIST)))
                {
                    CommonCode.UpdateBlacklist(sr.ReadToEnd());
                }
            }

            // Get a user with a predefined Marketplace Assets 
            user = CommonCode.GetUserWithAwardAndMarketplace(false, true);
            
            proxy = new ClosetPartProxy(user.Email, user.Password);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(user.PurchaseList.Count, usersAssets.assets.Length, "Single asset should have been filtered out.");
            Assert.AreEqual(usersAssets.assets[0].id, CommonCode.testMarketplaceList[0].Id.ToString(), "This should be the only asset returned.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify Global section works by default for Marketplace")]
        public void ClosetTests_BlackListFilter_VerifyFilteredMarketplaceAsset_Global()
        {
            TestUserData user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            // Get a user with a predefined Marketplace Assets 
            user = CommonCode.GetUserWithAwardAndMarketplace(false, true);
            proxy = new ClosetPartProxy(user.Email, user.Password);

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", CommonCode.testMarketplaceList[0].Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(1, usersAssets.assets.Length, "Single asset should have been filtered out.");
            Assert.AreEqual(usersAssets.assets[0].id, CommonCode.testMarketplaceList[1].Id.ToString(), "This should be the only asset returned.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify Global section works by default for Awardables")]
        public void ClosetTests_BlackListFilter_VerifyFilteredAwardableAsset_Global()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", user.AwardList[0].Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(1, usersAssets.assets.Length, "Single asset should have been filtered out.");
            Assert.AreEqual(usersAssets.assets[0].id,  user.AwardList[1].Id.ToString(), "This should be the only asset returned.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify Global section works even if it's not Zero")]
        public void ClosetTests_BlackListFilter_GlobalNonZero()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "92", user.AwardList[0].Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(1, usersAssets.assets.Length, "Single asset should have been filtered out.");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[1].Id.ToString(), "This should be the only asset returned.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify Global section works even if there are multiple ones. They should all be combined into one Global Blacklist.")]
        public void ClosetTests_BlackListFilter_GlobalMultiple()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", user.AwardList[1].Id.ToString());
            blacklist.Add(CommonCode.TargetTypes.Global, "0");
            blacklist.Assets[0].Add(user.AwardList[0].Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(0, usersAssets.assets.Length, "Both globals should have been applied. Cause everything to be filtered out.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify Global section works even if there are multiple ones. They should all be combined into one Global Blacklist.")]
        public void ClosetTests_BlackListFilter_GlobalMultipleWithOneZero()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", user.AwardList[0].Id.ToString());
            blacklist.Add(CommonCode.TargetTypes.Global, string.Empty);
            blacklist.Assets[0].Add(user.AwardList[1].Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(0, usersAssets.assets.Length, "Both globals should have been applied. Cause everything to be filtered out.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify the success Load Event gets fired.")]
        public void ClosetTests_BlackListFilter_LoadEvent()
        {
            User user;
            ClosetPartProxy proxy;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", user.AwardList[0].Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            // Make a request just to ensure the Blacklist is actively pulling the file. 
            proxy.GetAssets();

            CommonCode.ValidateEvents(EventIDs.BLACKLIST_FileLoadSuccessEvent);
        }            

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify Platform section works when PlatformId is passed in")]
        public void ClosetTests_BlackListFilter_VerifyFilteredAwardableAsset_Platform()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", user.AwardList[1].Id.ToString());
            blacklist.Add(CommonCode.TargetTypes.TitleID, Config.EnvironmentSettings.SelectedEnvironment.StsSettings.PlatformType); // Ensuring that it's not uring Target TitleID
            blacklist.Add(CommonCode.TargetTypes.Platform, Config.EnvironmentSettings.SelectedEnvironment.StsSettings.PlatformType);
            blacklist.Assets[2].Add(user.AwardList[0].Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(1, usersAssets.assets.Length, "Single asset should have been filtered out");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[1].Id.ToString(), "This should be the only asset returned.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify Platform is not fixed to the STS token and that it's passed in via the header value 'X-Platform-Type'.")]
        public void ClosetTests_BlackListFilter_VerifyPlatformHeader()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);
            proxy.PlatformType = "92";

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", user.AwardList[1].Id.ToString());
            blacklist.Add(CommonCode.TargetTypes.Platform, proxy.PlatformType, user.AwardList[0].Id.ToString()); // Setting Target Id to the overriden Platform ID
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(1, usersAssets.assets.Length, "Single asset should have been filtered out");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[1].Id.ToString(), "This should be the only asset returned.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify if Platform is passed in, it's not used to determine Blacklist Target.")]
        public void ClosetTests_BlackListFilter_VerifyPlatformHeaderNotPassed()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);
            proxy.PlatformType = null;

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", user.AwardList[1].Id.ToString());
            blacklist.Add(CommonCode.TargetTypes.Platform, string.Empty); // Setting to "" to see if Platform is used
            blacklist.Assets[1].Add(user.AwardList[0].Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(1, usersAssets.assets.Length, "Single asset should have been filtered out");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[0].Id.ToString(), "Global Target should have been used.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify Platform section does exact match")]
        public void ClosetTests_BlackListFilter_PlatformSlightlyOff()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", user.AwardList[1].Id.ToString());
            blacklist.Add(CommonCode.TargetTypes.Platform, Config.EnvironmentSettings.SelectedEnvironment.StsSettings.PlatformType + "0");
            blacklist.Assets[1].Add(user.AwardList[0].Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(1, usersAssets.assets.Length, "Single asset should have been filtered out");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[0].Id.ToString(), "Should be using the Global Target.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");
        }

        [TestMethod]
        [WorkItem(8391)]
        [Owner("rsnyder")]
        [Description("Verify TitleID is not using it hex value")]
        public void ClosetTests_BlackListFilter_TitleIDAsHex()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.TitleID, int.Parse(Config.EnvironmentSettings.SelectedEnvironment.StsSettings.TitleId).ToString("X"), user.AwardList[1].Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(2, usersAssets.assets.Length, "Nothing should have been filtered.");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[0].Id.ToString(), "This should have been returned.");
            Assert.AreEqual(usersAssets.assets[1].id, user.AwardList[1].Id.ToString(), "This should have been returned.");
            Assert.IsFalse(usersAssets.Filtered, "Asset should NOT of been filtered.");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify TitleID section does exact match")]
        public void ClosetTests_BlackListFilter_TitleIDSlightlyOff()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", user.AwardList[1].Id.ToString());
            blacklist.Add(CommonCode.TargetTypes.TitleID, Config.EnvironmentSettings.SelectedEnvironment.StsSettings.TitleId + "0");
            blacklist.Assets[1].Add(user.AwardList[0].Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(1, usersAssets.assets.Length, "Single asset should have been filtered out");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[0].Id.ToString(), "Should be using the Global Target.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify if there are other Targets but no Global and the caller does not fall under any Targets.")]
        public void ClosetTests_BlackListFilter_GlobalDoesNotExist()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.TitleID, "-1", user.AwardList[1].Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(2, usersAssets.assets.Length, "Nothing should have been filtered.");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[0].Id.ToString(), "This should have been returned.");
            Assert.AreEqual(usersAssets.assets[1].id, user.AwardList[1].Id.ToString(), "This should have been returned.");
            Assert.IsFalse(usersAssets.Filtered, "Asset should NOT of been filtered.");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify Title over Platform section works")]
        public void ClosetTests_BlackListFilter_VerifyFilteredAwardableAsset_TitleIDOverPlatform()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", user.AwardList[1].Id.ToString());

            // Add two empty Platform Targets with the same value as the TitleID
            blacklist.Add(CommonCode.TargetTypes.Platform, Config.EnvironmentSettings.SelectedEnvironment.StsSettings.TitleId);
            blacklist.Add(CommonCode.TargetTypes.Platform, Config.EnvironmentSettings.SelectedEnvironment.StsSettings.PlatformType);
            
            blacklist.Add(CommonCode.TargetTypes.TitleID, Config.EnvironmentSettings.SelectedEnvironment.StsSettings.TitleId);
            blacklist.Assets[3].Add(user.AwardList[0].Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(1, usersAssets.assets.Length, "Single asset should have been filtered out");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[1].Id.ToString(), "This should be the only asset returned.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify if there are duplicate TitleId targets, it uses the last added target.")]
        public void ClosetTests_BlackListFilter_DuplicateTargets()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", user.AwardList[1].Id.ToString());
            // Add the empty Title
            blacklist.Add(CommonCode.TargetTypes.TitleID, Config.EnvironmentSettings.SelectedEnvironment.StsSettings.TitleId);
            blacklist.Add(CommonCode.TargetTypes.TitleID, Config.EnvironmentSettings.SelectedEnvironment.StsSettings.TitleId);
            blacklist.Assets[2].Add(user.AwardList[0].Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(1, usersAssets.assets.Length, "Single asset should have been filtered out");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[1].Id.ToString(), "This should be the only asset returned.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify nothing gets filtered when the target has no assets")]
        public void ClosetTests_BlackListFilter_VerifyValidNoAssetTarget()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0");
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(2, usersAssets.assets.Length, "Nothing should have been filtered.");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[0].Id.ToString(), "This should have been returned.");
            Assert.AreEqual(usersAssets.assets[1].id, user.AwardList[1].Id.ToString(), "This should have been returned.");
            Assert.IsFalse(usersAssets.Filtered, "Asset should NOT of been filtered.");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify what happens if an invalid guid is passed")]
        public void ClosetTests_BlackListFilter_InvalidGuid()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", "Not a Guid");
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(2, usersAssets.assets.Length, "Nothing should have been filtered.");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[0].Id.ToString(), "This should have been returned.");
            Assert.AreEqual(usersAssets.assets[1].id, user.AwardList[1].Id.ToString(), "This should have been returned.");
            Assert.IsFalse(usersAssets.Filtered, "Asset should NOT of been filtered.");
        }

        [TestMethod]
        [WorkItem(8534)]
        [Owner("rsnyder")]
        [Description("Verify caps does not play a role in filtering")]
        public void ClosetTests_BlackListFilter_CapitilizedGuid()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", user.AwardList[0].Id.ToString().ToUpper());
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(1, usersAssets.assets.Length, "Single asset should have been filtered out.");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[1].Id.ToString(), "This should be the only asset returned.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");
        }

        [TestMethod]
        [WorkItem(8534)]
        [Owner("rsnyder")]
        [Description("Verify lowercase does not play a role in filtering")]
        public void ClosetTests_BlackListFilter_LowerCasedGuid()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", user.AwardList[0].Id.ToString().ToLower());
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(1, usersAssets.assets.Length, "Single asset should have been filtered out.");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[1].Id.ToString(), "This should be the only asset returned.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify Duplicate guid entries still works")]
        public void ClosetTests_BlackListFilter_VerifyDuplicateAssets()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", user.AwardList[0].Id.ToString());
            blacklist.Assets[0].Add(blacklist.Assets[0].AssetIDs[0]);
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(1, usersAssets.assets.Length, "Single asset should have been filtered out.");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[1].Id.ToString(), "This should be the only asset returned.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify that a single Assest can found within Thousands of other Asserts.")]
        public void ClosetTests_BlackListFilter_ThousandsOfGuids()
        {
            User user;
            int index;
            ClosetPartProxy proxy;
            int TotalAssets = 5000;
            ClosetAssets usersAssets;
            Random rnd = new Random();
            BlacklistedAssets blacklist;

            // Randomly pick the location of where the asset will be placed within the total assets
            index = rnd.Next(0, TotalAssets);

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0");

            for (int i = 0; i < TotalAssets; i++)
            {
                if (index == i)
                {
                    blacklist.Assets[0].Add(user.AwardList[0].Id.ToString());

                    continue;
                }

                blacklist.Assets[0].Add(Guid.NewGuid().ToString());
            }

            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(1, usersAssets.assets.Length, "Single asset should have been filtered out.");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[1].Id.ToString(), "This should be the only asset returned.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify if the blacklist gets updated, that the change is process and that all previously filtered assets are discarded and reloaded.")]
        public void ClosetTests_BlackListFilter_BlacklistUpdate()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", user.AwardList[0].Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(1, usersAssets.assets.Length, "Single asset should have been filtered out.");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[1].Id.ToString(), "This should be the only asset returned.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");

            // Now update blacklist with a different Asset being filtered
            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", user.AwardList[1].Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(1, usersAssets.assets.Length, "Single asset should have been filtered out.");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[0].Id.ToString(), "This should be the only asset returned.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");
        }

        [TestMethod]
        [WorkItem(8578)]
        [Owner("rsnyder")]
        [Description("Verify if the blacklist gets updated, that the change is process and that all previously filtered assets are discarded and reloaded.")]
        public void ClosetTests_BlackListFilter_BlacklistUpdateWithNoAssets()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", user.AwardList[0].Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(1, usersAssets.assets.Length, "Single asset should have been filtered out.");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[1].Id.ToString(), "This should be the only asset returned.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");

            // Now update blacklist with a different Asset being filtered
            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0");
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(2, usersAssets.assets.Length, "Nothing should have been filtered.");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[0].Id.ToString(), "This should have been returned.");
            Assert.AreEqual(usersAssets.assets[1].id, user.AwardList[1].Id.ToString(), "This should have been returned.");
            Assert.IsFalse(usersAssets.Filtered, "Asset should NOT of been filtered."); ;
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify if there is no global, Title is still selected")]
        public void ClosetTests_BlackListFilter_VerifyTitleIDWithNoGlobal()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.TitleID, Config.EnvironmentSettings.SelectedEnvironment.StsSettings.TitleId, user.AwardList[0].Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(1, usersAssets.assets.Length, "Single asset should have been filtered out.");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[1].Id.ToString(), "This should be the only asset returned.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");
        }

        [TestMethod]
        [WorkItem(8537)]
        [Owner("rsnyder")]
        [Description("Verify if there are no targets that nothing get filtered")]
        public void ClosetTests_BlackListFilter_NoTargets()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            blacklist = new BlacklistedAssets();
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(2, usersAssets.assets.Length, "Nothing should have been filtered.");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[0].Id.ToString(), "This should have been returned.");
            Assert.AreEqual(usersAssets.assets[1].id, user.AwardList[1].Id.ToString(), "This should have been returned.");
            Assert.IsFalse(usersAssets.Filtered, "Asset should NOT of been filtered.");
        }

        [TestMethod]
        [WorkItem(8537)]
        [Owner("rsnyder")]
        [Description("Verify if the file is empty that nothing get filtered")]
        public void ClosetTests_BlackListFilter_EmptyBlackList()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            CommonCode.UpdateBlacklist(string.Empty);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(2, usersAssets.assets.Length, "Nothing should have been filtered.");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[0].Id.ToString(), "This should have been returned.");
            Assert.AreEqual(usersAssets.assets[1].id, user.AwardList[1].Id.ToString(), "This should have been returned.");
            Assert.IsFalse(usersAssets.Filtered, "Asset should NOT of been filtered.");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify if there is an invalid blacklist uploaded while the service is running, it uses the previous valid blacklist. Then verify if replaced again, it still gets updated.")]
        public void ClosetTests_BlackListFilter_InvalidBlacklist()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", user.AwardList[0].Id.ToString().ToLower());
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(1, usersAssets.assets.Length, "Single asset should have been filtered out.");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[1].Id.ToString(), "This should be the only asset returned.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");


            // Now make the blacklist invalid
            CommonCode.UpdateBlacklist("This is not valid xml");
            CommonCode.ValidateEvents(EventIDs.BLACKLIST_FileLoadFailureEvent);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(1, usersAssets.assets.Length, "Single asset should have been filtered out.");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[1].Id.ToString(), "This should be the only asset returned.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");


            // Now get the list back to working order with a different Asset being filtered
            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", user.AwardList[1].Id.ToString().ToLower());
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(1, usersAssets.assets.Length, "Single asset should have been filtered out.");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[0].Id.ToString(), "This should be the only asset returned.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify if there is an invalid blacklist on load, it uses nothing. Logs and error event and continues. Then verify if replaced again, it still gets updated.")]
        public void ClosetTests_BlackListFilter_InvalidBlacklist_OnLoad()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            // Now make the blacklist invalid
            CommonCode.UpdateBlacklist("This is not valid xml");

            // Stop and start the service with the invalid Blacklist
            Test_Common.RestartService("w3svc", "localhost");

            // Make a request so the Blacklist gets loaded
            usersAssets = proxy.GetAssets();

            CommonCode.ValidateEvents(EventIDs.BLACKLIST_FileLoadFailureEvent);      

            Assert.AreEqual(2, usersAssets.assets.Length, "Nothing should have been filtered.");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[0].Id.ToString(), "This should have been returned.");
            Assert.AreEqual(usersAssets.assets[1].id, user.AwardList[1].Id.ToString(), "This should have been returned.");
            Assert.IsFalse(usersAssets.Filtered, "Asset should NOT of been filtered."); ;


            // Now get the list back to working order with a different Asset being filtered
            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", user.AwardList[1].Id.ToString().ToLower());
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(1, usersAssets.assets.Length, "Single asset should have been filtered out.");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[0].Id.ToString(), "This should be the only asset returned.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify if a TitleID is removed, it get purged.")]
        public void ClosetTests_BlackListFilter_RemovalOfTitleID()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets;
            BlacklistedAssets blacklist;

            user = CreateDefaultUser();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", user.AwardList[1].Id.ToString());
            blacklist.Add(CommonCode.TargetTypes.TitleID, Config.EnvironmentSettings.SelectedEnvironment.StsSettings.TitleId);
            blacklist.Assets[1].Add(user.AwardList[0].Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(1, usersAssets.assets.Length, "Single asset should have been filtered out");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[1].Id.ToString(), "This should be the only asset returned.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");

            // Now update blacklist with a different Asset being filtered
            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", string.Empty);
            blacklist.Assets[0].AssetIDs = null; // Remove all Assets
            CommonCode.UpdateBlacklist(blacklist);

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(2, usersAssets.assets.Length, "Nothing should have been filtered.");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[0].Id.ToString(), "This should have been returned.");
            Assert.AreEqual(usersAssets.assets[1].id, user.AwardList[1].Id.ToString(), "This should have been returned.");
            Assert.IsFalse(usersAssets.Filtered, "Asset should NOT of been filtered."); ;
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Simulating a real world scenario as close as one can.")]
        public void ClosetTests_BlackListFilter_MultiTargets()
        {
            User user;
            ClosetPartProxy proxy;
            ClosetAssets usersAssets = null;
            BlacklistedAssets blacklist = null;

            Assert.Inconclusive("NEED TO IMPLEMENT: Need to get the title Ids added to the list of supported titles within Test01 and Dev01");

            string TitleId_SeaLegend = "1179582721";
            //string PlatformType_SeaLegend = "5";

            string TitleId_HideAndSeek = "1179582722";
            //string PlatformType_HideAndSeek = "5";
            
            string TitleId_TexasHoldem = "1480656886";
            string PlatformType_TexasHoldem = "2";
            
            user = CreateDefaultUser(); 

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", user.AwardList[0].Id.ToString());

            blacklist.Add(CommonCode.TargetTypes.TitleID, TitleId_SeaLegend);
            blacklist.Assets[1].Add(user.AwardList[1].Id.ToString());

            blacklist.Add(CommonCode.TargetTypes.TitleID, TitleId_HideAndSeek);
            blacklist.Assets[1].Add(user.AwardList[0].Id.ToString()); 
            blacklist.Assets[1].Add(user.AwardList[1].Id.ToString());

            // Filtering nothing
            blacklist.Add(CommonCode.TargetTypes.TitleID, TitleId_TexasHoldem);

            CommonCode.UpdateBlacklist(blacklist);

            // Set up the request to use this TitleID
            Config.Environment.StsSettings.TitleId = TitleId_TexasHoldem;
            Config.Environment.StsSettings.PlatformType = PlatformType_TexasHoldem;
            AuthorizationCache.FlushCache();
            proxy = new ClosetPartProxy(user.Email, user.Password);

            try
            {
                // Get filtered Assets
                usersAssets = proxy.GetAssets();
            }
            catch(Exception exc)
            {
                Assert.Fail("This is failing becuase these titles do not exist within the ENV your running in. Fix that and run again. \r\nException: \r\n " + exc.ToString());
            }

            Assert.AreEqual(2, usersAssets.assets.Length, "Nothing should have been filtered.");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[0].Id.ToString(), "This should have been returned.");
            Assert.AreEqual(usersAssets.assets[1].id, user.AwardList[1].Id.ToString(), "This should have been returned.");
            Assert.IsFalse(usersAssets.Filtered, "Asset should NOT of been filtered.");


            // Set up the request to use this TitleID
            Config.Environment.StsSettings.TitleId = TitleId_HideAndSeek;
            AuthorizationCache.FlushCache();

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(0, usersAssets.assets.Length, "Single asset should have been filtered out");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");


            // Set up the request to use this TitleID
            Config.Environment.StsSettings.TitleId = TitleId_SeaLegend;
            AvatarServices.Test.Common.AuthorizationCache.FlushCache();

            // Get filtered Assets
            usersAssets = proxy.GetAssets();

            Assert.AreEqual(1, usersAssets.assets.Length, "Single asset should have been filtered out");
            Assert.AreEqual(usersAssets.assets[0].id, user.AwardList[0].Id.ToString(), "This should be the only asset returned.");
            Assert.IsTrue(usersAssets.Filtered, "Asset should have been filtered. Thus this flag should have been set.");
        }

        /// <summary>
        /// Get a user with the first two AwardableAssets awarded
        /// </summary>
        /// <returns>User with at least two assets to there name</returns>
        private User CreateDefaultUser()
        {
            User user;

            if(AwardableAssets.Count < 2)
            {
                throw new Exception("Default user needs two awardable assets. But there are only " + AwardableAssets.Count + " Awardable Assets.");
            }

            user = UserCache.Instance.GetUsers(1, AvatarGender.Male, 0, 0)[0];
            SSRTests.ResetAllImages(user.Xuid);
            
            user.AwardAsset(AwardableAssets[0]);
            user.AwardAsset(AwardableAssets[1]);

            // Commit the assets to the user's record
            user.WriteManifest(true, Config.Environment.ManifestWritePartService);

            return user;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\GamerPic\GamerPicTests_InvalidCameraPositions.cs ===
﻿using System;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Reflection;
using Avatar.Services.ManifestWrite.Library;
using Avatar.Services.ServerSideRenderer.Messaging;
using AvatarServices.Test.AvatarProxy;
using AvatarServices.Test.Common;
using AvatarServices.Test.UserCache;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.XboxLive.Avatars.Internal;

namespace AvatarServices.Tests
{
    [TestClass]
    public class GamerPic_InvalidCameraPositions
    {
        /// <summary>
        /// Proxy used to communicate directly with GamerPic API that our partners will use
        /// </summary>
        private GamerPicPartnerProxy gamerPicProxy = null;

        /// <summary>
        /// GamerPic request used to call the front door GamerPic API
        /// </summary>
        private UpdateGamerPicRequest request = null;

        /// <summary>
        /// Gets or sets the test context which provides
        /// information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get;
            set;
        }

        /// <summary>
        /// Static user used to ensure the user exists and can make requests using them
        /// </summary>
        private static User staticDefaultUser;

        [ClassInitialize]
        public static void myClassInitialize(TestContext testContext)
        {
            staticDefaultUser = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];
        }

        [TestInitialize]
        public void myTestInitialize()
        {
            SSRTests.RestGamerPicImages();

            // Setup the proxy used to call the font door GamerPic API that our partners call
            gamerPicProxy = new GamerPicPartnerProxy(staticDefaultUser.Email, staticDefaultUser.Password);

            // GamerPic request used to call the front door GamerPic API
            request = SSRTests.GenerateUpdateGamerPicRequest();
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify if the incoming request goes passed the exceptable range")]
        public void GamerPicTests_InvalidCameraPosition_ToLeft()
        {
            UpdateGamerPicResponse response;

            // Move the Avatar to the far left
            request.OffsetX = SSRTests.GamerPicCameraBox.AvatarSSRGamerpicMinXOffset - 0.01f;

            // Now verify that this same request setting can go through the front door GamerPic API
            try
            {
                response = gamerPicProxy.UpdateGamerPic(request);

                Assert.Fail("UpdateGamerPic should have thrown a 500 exception.");
            }
            catch(AvatarServices.Test.Common.RestException exc)
            {
                if (exc.Response.ToString().StartsWith("HTTP/1.1 500"))
                {
                    // PASSED: Returned expected exception
                    return;
                }

                Assert.Fail("Unexpected Exception returned. Exceptions: " + exc.ToString());
            }
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify if the incoming request goes passed the exceptable range")]
        public void GamerPicTests_InvalidCameraPosition_ToRight()
        {
            UpdateGamerPicResponse response;

            // Move the Avatar to the far right
            request.OffsetX = SSRTests.GamerPicCameraBox.AvatarSSRGamerpicMaxXOffset + 0.01f;

            // Now verify that this same request setting can go through the front door GamerPic API
            try
            {
                response = gamerPicProxy.UpdateGamerPic(request);

                Assert.Fail("UpdateGamerPic should have thrown a 500 exception.");
            }
            catch (AvatarServices.Test.Common.RestException exc)
            {
                if (exc.Response.ToString().StartsWith("HTTP/1.1 500"))
                {
                    // PASSED: Returned expected exception
                    return;
                }

                Assert.Fail("Unexpected Exception returned. Exceptions: " + exc.ToString());
            }
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify if the incoming request goes passed the exceptable range")]
        public void GamerPicTests_InvalidCameraPosition_ToTop()
        {
            UpdateGamerPicResponse response;

            // Move the Avatar to the top
            request.OffsetY = SSRTests.GamerPicCameraBox.AvatarSSRGamerpicMaxYOffset + 0.01f;

            // Now verify that this same request setting can go through the front door GamerPic API
            try
            {
                response = gamerPicProxy.UpdateGamerPic(request);

                Assert.Fail("UpdateGamerPic should have thrown a 500 exception.");
            }
            catch (AvatarServices.Test.Common.RestException exc)
            {
                if (exc.Response.ToString().StartsWith("HTTP/1.1 500"))
                {
                    // PASSED: Returned expected exception
                    return;
                }

                Assert.Fail("Unexpected Exception returned. Exceptions: " + exc.ToString());
            }
       }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify if the incoming request goes passed the exceptable range")]
        public void GamerPicTests_InvalidCameraPosition_ToBottom()
        {
            UpdateGamerPicResponse response;

            // Move the Avatar to the bottom
            request.OffsetY = SSRTests.GamerPicCameraBox.AvatarSSRGamerpicMinYOffset - 0.01f;

            // Now verify that this same request setting can go through the front door GamerPic API
            try
            {
                response = gamerPicProxy.UpdateGamerPic(request);

                Assert.Fail("UpdateGamerPic should have thrown a 500 exception.");
            }
            catch (AvatarServices.Test.Common.RestException exc)
            {
                if (exc.Response.ToString().StartsWith("HTTP/1.1 500"))
                {
                    // PASSED: Returned expected exception
                    return;
                }

                Assert.Fail("Unexpected Exception returned. Exceptions: " + exc.ToString());
            }
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify if the incoming request goes passed the exceptable range")]
        public void GamerPicTests_InvalidCameraPosition_ZoomIn()
        {
            UpdateGamerPicResponse response;

            // Move the Avatar as close as possable
            request.FieldOfView = SSRTests.GamerPicCameraBox.AvatarSSRGamerpicMinFieldOfView - 0.01f;

            // Now verify that this same request setting can go through the front door GamerPic API
            try
            {
                response = gamerPicProxy.UpdateGamerPic(request);

                Assert.Fail("UpdateGamerPic should have thrown a 500 exception.");
            }
            catch (AvatarServices.Test.Common.RestException exc)
            {
                if (exc.Response.ToString().StartsWith("HTTP/1.1 500"))
                {
                    // PASSED: Returned expected exception
                    return;
                }

                Assert.Fail("Unexpected Exception returned. Exceptions: " + exc.ToString());
            }
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify if the incoming request goes passed the exceptable range")]
        public void GamerPicTests_InvalidCameraPosition_ZoomOut()
        {
            UpdateGamerPicResponse response;

            // Move the Avatar as far as possable
            request.FieldOfView = SSRTests.GamerPicCameraBox.AvatarSSRGamerpicMaxFieldOfView + 0.01f;

            // Now verify that this same request setting can go through the front door GamerPic API
            try
            {
                response = gamerPicProxy.UpdateGamerPic(request);

                Assert.Fail("UpdateGamerPic should have thrown a 500 exception.");
            }
            catch (AvatarServices.Test.Common.RestException exc)
            {
                if (exc.Response.ToString().StartsWith("HTTP/1.1 500"))
                {
                    // PASSED: Returned expected exception
                    return;
                }

                Assert.Fail("Unexpected Exception returned. Exceptions: " + exc.ToString());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\ManifestRead\ManifestReadTests_BVT.cs ===
﻿using Microsoft.VisualStudio.TestTools.UnitTesting;

using System.Net;

using LiveNew.Test;

using LiveN.Test;
using AvatarServices.Test.UserCache;
using AvatarServices.Test.AvatarProxy;
using Microsoft.XboxLive.Avatars.Internal;
using Avatar.Services.ManifestRead.Library;

namespace AvatarServices.Tests
{
    /// <summary>
    /// Partial class containing only the BVTs for ManifestRead
    /// </summary>
    public partial class ManifestReadTests
    {
        [TestMethod]
        [Owner("rsnyder")]
        [Description("Ensure the ManifestRead Origin service is working as expected")]
        public void ManifestReadTests_Origin_BVT()
        {
            ManifestReadClientResponse response;
            ManifestReadClientRequest ManifestReadClient;

            ManifestReadClient = new ManifestReadClientRequest(CommonCode.RunningEnvironment.ManifestReadService.OriginalString);

            ManifestReadClient.QueryParameters.GamerTag.Value = CommonCode.RunningEnvironment.UserSettings[0].GamerTag;

            response = ManifestReadClient.MakeARequest();

            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, "Incorrect status code.");
            Assert.IsTrue(response.Body.Contains("<AvatarManifests"), "Response did not contain a AvatarManifests xml field. Response Body: \r\n" + response.Body);
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Ensure the ManifestRead Partner service is working as expected when called with Partner Token")]
        public void ManifestReadTests_Partner_PartnerToken_BVT()
        {
            ManifestReadPartnerClientResponse response;
            ManifestReadPartnerClientRequest ManifestReadClient;

            ManifestReadClient = new ManifestReadPartnerClientRequest(
                                                CommonCode.RunningEnvironment,
                                                CommonCode.RunningEnvironment.UserSettings[0].UserEmail,
                                                CommonCode.RunningEnvironment.UserSettings[0].Password);

            // Set the Requested Token to be a Partner Token
            ManifestReadClient.RequestedToken = RequestedTokenEnum.PartnerToken;

            response = ManifestReadClient.MakeARequest();

            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, "Incorrect status code.");
            Assert.IsTrue(response.Body.Contains("<AvatarManifests"), "Response did not contain a AvatarManifests xml field. Response Body: \r\n" + response.Body);
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Ensure the ManifestRead Partner service is working as expected with a User Token")]
        public void ManifestReadTests_Partner_UserToken_BVT()
        {
            ManifestReadPartnerClientResponse response;
            ManifestReadPartnerClientRequest ManifestReadClient;

            ManifestReadClient = new ManifestReadPartnerClientRequest(
                                                CommonCode.RunningEnvironment,
                                                CommonCode.RunningEnvironment.UserSettings[0].UserEmail,
                                                CommonCode.RunningEnvironment.UserSettings[0].Password);

            // Set the Requested Token to be a User Token
            ManifestReadClient.RequestedToken = RequestedTokenEnum.UserToken;

            response = ManifestReadClient.MakeARequest();

            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, "Incorrect status code.");
            Assert.IsTrue(response.Body.Contains("<AvatarManifests"), "Response did not contain a AvatarManifests xml field. Response Body: \r\n" + response.Body);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\ManifestWrite\ManifestWriteTests.cs ===
﻿using System;
using System.IO;
using System.Net;
using System.Text;
using Avatar.Services.ManifestRead.Library;
using Avatar.Services.ManifestWrite.Library;
using AvatarServices.Test.AvatarProxy;
using AvatarServices.Test.Common;
using AvatarServices.Test.UserCache;
using Infrastructure.Test.Common.Logging;
using Leet.Core.TestService.Client.DiagnosticDatabase;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.XboxLive.Avatars.Internal;

using LiveN.Test;

namespace AvatarServices.Tests
{    
    /// Summary description for ManifestWriteTests
    /// </summary>
    [TestClass]
    public class ManifestWriteTests
    {
        // List of Valid and Invalid Manifests to test

        public readonly string[] ValidManifests = new string[]
        {
            "000000003F1000000000000000100000031A0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E00020000003360003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002CE0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002710003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFDE914DFF753E1FFF8A1A0EFF243F53FF753E1FFF000000FF753E1FFF7F3979FF7F39790000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E00001000000000000000000000000000000000004024F0003C1C8F109A19CB2E0000400000000000000000000000000000000000800520001C1C8F109A19CB2E0000800000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000002000360001C1C8F109A19CB2E0002000000000000000000000000000000000004000F30001C1C8F109A19CB2E000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000360001C1C8F109A19CB2E0002000000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000000800520001C1C8F109A19CB2E00008000000000000000000000000000000000004024F0003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "00000000FFF000000000000000100000031A0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E00020000003360003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002CE0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002710003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFDE914DFF753E1FFF8A1A0EFF243F53FF753E1FFF000000FF753E1FFF7F3979FF7F39790000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E00001000000000000000000000000000000000004024F0003C1C8F109A19CB2E0000400000000000000000000000000000000000800520001C1C8F109A19CB2E0000800000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000002000360001C1C8F109A19CB2E0002000000000000000000000000000000000004000F30001C1C8F109A19CB2E000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000360001C1C8F109A19CB2E0002000000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000000800520001C1C8F109A19CB2E00008000000000000000000000000000000000004024F0003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
        };

        public const string Manifest_Invalid_Hat_For_Earrings = "00000000FFF000000000000000100000031A0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E00020000003360003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002CE0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002710003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFDE914DFF753E1FFF8A1A0EFF243F53FF753E1FFF000000FF753E1FFF7F3979FF7F39790000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E00001000000000000000000000000000000000004024F0003C1C8F109A19CB2E0000400000000000000000000000000000000000800520001C1C8F109A19CB2E0000800000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000002000360001C1C8F109A19CB2E00020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000004000F30001C1C8F109A19CB2E00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000360001C1C8F109A19CB2E0002000000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000000800520001C1C8F109A19CB2E00008000000000000000000000000000000000004024F0003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002";
        private const string Manifest_Invalid_Len_2000_All_Zero = "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
        private const string Manifest_Invalid_Len_2001 = "00000000FFF000000000000000100000031A0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E00020000003360003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002CE0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002710003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFDE914DFF753E1FFF8A1A0EFF243F53FF753E1FFF000000FF753E1FFF7F3979FF7F39790000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E00001000000000000000000000000000000000004024F0003C1C8F109A19CB2E0000400000000000000000000000000000000000800520001C1C8F109A19CB2E0000800000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000002000360001C1C8F109A19CB2E0002000000000000000000000000000000000004000F30001C1C8F109A19CB2E000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000360001C1C8F109A19CB2E0002000000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000000800520001C1C8F109A19CB2E00008000000000000000000000000000000000004024F0003C1C8F109A19CB2E00004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000021";
        private const string Manifest_Invalid_Empty = "";
        private const string Manifest_Invalid_Manifest_With_Invalid_Version = "00000000BF8000003F80000000100000031C0003C1C8F109A19CB2E00008000003250003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EB0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A40003C1C8F109A19CB2E03F80000000000000000000000000000000004000026F0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF493421FFC65265FF243F53FF493421FFB37D59FF493421FF399251FF3992510000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402410F03C1C8F109A19CB2E0000400000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA6000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000002001090002C1C8F109A19CB2E0002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001090002C1C8F109A19CB2E00020000000000000000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000000801130002C1C8F109A19CB2E000080000FF0F5DA600000000000000000000000402410003C1C8F109A19CB2E000040000000000000000000000000000E00038D55A354F22000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
        private const string Manifest_Invalid_MarketPlace_Assets = "000000003F000000BF00000000100000031A0003C1C8F109A19CB2E00008000003310003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002F60003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A20003C1C8F109A19CB2E03F80000000000000000000000000000000004000026B0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFC7984CFF682618FFEFC28BFFAE9843FF682618FF6A3919FF682618FFBCAE89FFBCAE890000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402000003C1C8F109A19CB2E0000400000000000000000000000000000000000800670001C1C8F109A19CB2E00008000000000000000000000000000000000010009D0001C1C8F109A19CB2E00010000000000000000000000000000000000020003B0001C1C8F109A19CB2E0002000000000000000000000000000000000100073794213CE5F59B758580828100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020003B0001C1C8F109A19CB2E00020000000000000000000000000000000000010009D0001C1C8F109A19CB2E0001000000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000000402000003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
        private const string Manifest_Invalid_Awardable_Assets = "00000000BF0000000000000000100000031C0003C1C8F109A19CB2E00008000003240003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EF0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002920003C1C8F109A19CB2E03F8000000000000000000000000000000000400002630003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFDE914DFF682618FFD59282FF212121FF682618FFBA72B6FF682618FFAA1D26FFAA1D260000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B00003C1C8F109A19CB2E00004000000000000000000000000000000000008004F0001C1C8F109A19CB2E00008000000000000000000000000000000000010009A0001C1C8F109A19CB2E0001000000000000000000000000000000000002000340001C1C8F109A19CB2E0002000000000000000000000000000000000004000024103C1110123FFFFBAAA00400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000340001C1C8F109A19CB2E00020000000000000000000000000000000000010009A0001C1C8F109A19CB2E00010000000000000000000000000000000000008004F0001C1C8F109A19CB2E0000800000000000000000000000000000000000401B00003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Ensure the ManifestWrite Partner service is working as expected when called with Partner Token")]
        public void ManifestWriteTests_Partner_PartnerToken_BVT()
        {
            ManifestWritePartnerClientResponse response;
            ManifestWritePartnerClientRequest ManifestWriteClient;

            ManifestWriteClient = new ManifestWritePartnerClientRequest(
                                                CommonCode.RunningEnvironment,
                                                CommonCode.RunningEnvironment.UserSettings[0].UserEmail,
                                                CommonCode.RunningEnvironment.UserSettings[0].Password);

            ManifestWriteClient.ContentWrapper.Manifest = ValidManifests[0];

            // Set the Requested Token to be a Partner Token
            ManifestWriteClient.RequestedToken = RequestedTokenEnum.PartnerToken;

            response = ManifestWriteClient.MakeARequest();

            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, "Incorrect status code.");
            Assert.AreEqual(0, response.BodyWrapper.SuccessCode, "Status code should be set to success. '0'. Response Body: \r\n" + response.Body);
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Ensure the ManifestWrite User service is working as expected when called with Partner Token")]
        public void ManifestWriteTests_Partner_UserToken_BVT()
        {
            ManifestWritePartnerClientResponse response;
            ManifestWritePartnerClientRequest ManifestWriteClient;

            ManifestWriteClient = new ManifestWritePartnerClientRequest(
                                                CommonCode.RunningEnvironment,
                                                CommonCode.RunningEnvironment.UserSettings[0].UserEmail,
                                                CommonCode.RunningEnvironment.UserSettings[0].Password);

            ManifestWriteClient.ContentWrapper.Manifest = ValidManifests[0];

            // Set the Requested Token to be a User Token
            ManifestWriteClient.RequestedToken = RequestedTokenEnum.UserToken;

            response = ManifestWriteClient.MakeARequest();

            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode, "Incorrect status code.");
            Assert.AreEqual(0, response.BodyWrapper.SuccessCode, "Status code should be set to success. '0'. Response Body: \r\n" + response.Body);
        }

        [TestMethod]
        public void ManifestWriteTests_BVT_Part_ValidUser_ValidManifest()
        {
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];

            ManifestWriteProxy mwpp = new ManifestWritePartProxy(
                    user.Email,
                    user.Password);

            UpdateManifestResponse umr = mwpp.UpdateManifest(new UpdateManifestRequest() { Manifest = ValidManifests[1] });
            ValidateSingleManifestRead(user.Gamertag, ValidManifests[1]);
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Write Manifest with XUID and ConsoleId contained within the Manifest. Read it and make sure it does not contain them anymore.")]
        public void ManifestWriteTests_XuidAndConsoleIdRemoval()
        {
            ManifestWriteProxy mwpp;
            UpdateManifestResponse umr;
            string Manifest_Valid_WithXuidAndConsoleID    = "00000000FFF000000000000000100000031A0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E00020000003360003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002CE0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002710003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFDE914DFF753E1FFF8A1A0EFF243F53FF753E1FFF000000FF753E1FFF7F3979FF7F39790000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E00001000000000000000000000000000000000004024F0003C1C8F109A19CB2E0000400000000000000000000000000000000000800520001C1C8F109A19CB2E0000800000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000002000360001C1C8F109A19CB2E0002000000000000000000000000000000000004000F30001C1C8F109A19CB2E000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000360001C1C8F109A19CB2E0002000000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000000800520001C1C8F109A19CB2E00008000000000000000000000000000000000004024F0003C1C8F109A19CB2E000040000000000000000000000000000E0002028FAB971F2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002";
            string Manifest_Valid_WithOutXuidAndConsoleID = "00000000FFF000000000000000100000031A0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E00020000003360003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002CE0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002710003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFDE914DFF753E1FFF8A1A0EFF243F53FF753E1FFF000000FF753E1FFF7F3979FF7F39790000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E00001000000000000000000000000000000000004024F0003C1C8F109A19CB2E0000400000000000000000000000000000000000800520001C1C8F109A19CB2E0000800000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000002000360001C1C8F109A19CB2E0002000000000000000000000000000000000004000F30001C1C8F109A19CB2E000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000360001C1C8F109A19CB2E0002000000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000000800520001C1C8F109A19CB2E00008000000000000000000000000000000000004024F0003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];

            mwpp = new ManifestWritePartProxy(user.Email, user.Password);
            umr = mwpp.UpdateManifest(new UpdateManifestRequest() { Manifest = Manifest_Valid_WithXuidAndConsoleID });

            ValidateSingleManifestRead(user.Gamertag, Manifest_Valid_WithOutXuidAndConsoleID);
        }

        [TestMethod]
        [WorkItem(8054)]
        public void ManifestWriteTests_Part_ValidManifest_AddsToSSRQueue()
        {
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];

            ManifestWriteTests_ValidManifest_AddsToSSRQueue(
                user.Email,
                user.Password,
                user.Gamertag,
                user.Xuid.ToString(), false);
        }

        [TestMethod]
        [WorkItem(8054)]
        public void ManifestWriteTests_Part_ValidManifest_AddsToSSRQueue_NoGamerPic()
        {
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];

            ManifestWriteTests_ValidManifest_AddsToSSRQueue(user.Email, user.Password, user.Gamertag, user.Xuid.ToString(), true);
        }

        [TestMethod]
        [WorkItem(8054)]
        public void ManifestWriteTests_Part_ValidManifest_AddsToSSRQueue_HasGamerPic()
        {
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];
            byte[] smallGamerPicData = GetBytes("avatarpic-s.png");
            byte[] largetGamerPicData = GetBytes("avatarpic-l.png");

            TestHookFactory.Instance.SSRService.WriteSmallGamerPicStorageImage(user.Xuid, smallGamerPicData);
            TestHookFactory.Instance.SSRService.WriteLargeGamerPicStorageImage(user.Xuid, largetGamerPicData);

            ManifestWriteTests_ValidManifest_AddsToSSRQueue(user.Email, user.Password, user.Gamertag, user.Xuid.ToString(), false);
        }

        private void ManifestWriteTests_ValidManifest_AddsToSSRQueue(string memberName, string password, string gamertag, string xuid, bool updateGamerPic)
        {
            SetAndTestManifest(memberName, password, gamertag, ValidManifests[0]);
            SetAndTestManifest(memberName, password, gamertag, ValidManifests[1]);

            ManifestWriteTests_ValidManifest_AddsToSSRQueue(xuid, updateGamerPic);
        }

        private byte[] GetBytes(string filePath)
        {
            FileInfo info = new FileInfo(filePath);

            if (info.Exists)
            {
                using (FileStream fs = info.OpenRead())
                {
                    byte[] buffer = new byte[info.Length];
                    fs.Read(buffer, 0, (int)info.Length);
                    return buffer;
                }
            }
            else
            {
                return new byte[0];
            }
        }

        private void ManifestWriteTests_ValidManifest_AddsToSSRQueue(string xuid, bool updateGamerPic)
        {
            DiagnosticDatabaseTestService diagnosticService = new DiagnosticDatabaseTestService(Config.Environment.CoreTestServiceBaseUrl);
            //Find Trace event signifying that manifest write was added to the SSR Queue
            SqlEvent foundEvent = diagnosticService.GetDiagnosticEntryBySourceAndMessageText("avatarsvcs_manwritepart", 1, String.Format("SSR BodyShot SendMessage succeded for XUID {0}.", xuid));
            Assert.IsNotNull(foundEvent, String.Format("Could not find send bodyshot message succeeded event for user: {0}", xuid));

            foundEvent = null;
            //Find Trace event signifying that manifest write was added to the SSR Queue
            foundEvent = diagnosticService.GetDiagnosticEntryBySourceAndMessageText("avatarsvcs_manwritepart", 1, String.Format("SSR GamerPic SendMessage succeded for XUID {0}.", xuid));
            if (updateGamerPic)
            {
                Assert.IsNotNull(foundEvent, String.Format("Could not find send gamerpic message succeeded event for user: {0}", xuid));
            }
            else
            {
                Assert.IsNull(foundEvent, String.Format("Found send gamerpic message succeeded event for user: {0}", xuid));
            }

            foundEvent = null;
            //Find Trace event signifying that the SSR service picked up the manifest update
            foundEvent = diagnosticService.GetDiagnosticEntryBySourceAndMessageText("avatarsvcs_serversiderenderer", 1, String.Format("Received GenerateBodyShotMessage. XUID: {0}", xuid));
            Assert.IsNotNull(foundEvent, String.Format("Could not find server side renderer trace signifying that it received the body shot pic for user: {0}", xuid));


            foundEvent = null;
            //Find Trace event signifying that the SSR service picked up the manifest update
            foundEvent = diagnosticService.GetDiagnosticEntryBySourceAndMessageText("avatarsvcs_serversiderenderer", 1, String.Format("Received GenerateGamerPictureMessage. XUID: {0}", xuid));
            if (updateGamerPic)
            {
                Assert.IsNotNull(foundEvent, String.Format("Could not find server side renderer trace signifying that it received the gamer pic for user: {0}", xuid));
            }
            else
            {
                Assert.IsNull(foundEvent, String.Format("Found server side renderer trace signifying that it received the gamer pic for user: {0}", xuid));
            }
        }

        [TestMethod]
        public void ManifestWriteTests_Part_AwardedAssetNotAwarded()
        {
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];

            ManifestWriteTests_AwardedAssetNotAwarded(new ManifestWritePartProxy(user.Email, user.Password), user.Gamertag);
        }

        private void ManifestWriteTests_AwardedAssetNotAwarded(ManifestWriteProxy mwpp, string Gamertag)
        {
            //this manifest contains an awarded asset.  This should fail if the user hasn't been awarded it yet.

            //todo(michperr): way to create this programatically using usercache
            string manifest = "00000000BF8000000000000000100000031E0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E00020000003360003C1C8F109A19CB2E00000800002EB0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002CE0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002600003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF6E4124FF553921FFBC7535FF88B049FF553921FFAAA6C9FF553921FFE8C84FFFE8C84F0000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401DC0003C1C8F109A19CB2E0000400000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000001000910001C1C8F109A19CB2E00010000000000000000000000000000000000020003B0001C1C8F109A19CB2E0002000000000000000000000000000000000004000024103C1110123FFFFBAAA004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020003B0001C1C8F109A19CB2E0002000000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000000800670001C1C8F109A19CB2E0000800000000000000000000000000000000000401DC0003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

            try
            {
                // Need to call twice as newly created users do not cause an exception. - Don't know why but this does not matter to use as it's just verifying if the backend does throw an exception, we trap it. 
                mwpp.UpdateManifest(new UpdateManifestRequest() { Manifest = manifest });
                mwpp.UpdateManifest(new UpdateManifestRequest() { Manifest = manifest });

                Assert.Fail("Expected 500 to be returned.");
            }
            catch (RestException e)
            {
                Assert.AreEqual<HttpStatusCode>(HttpStatusCode.InternalServerError, e.Response.Status);
            }

            ValidateEmptyManifest(Gamertag);
        }

        [TestMethod]
        public void ManifestWriteTests_Part_EmptyManifest()
        {
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];

            ManifestWriteTests_ValidUser_EmptyManifest(
                new ManifestWritePartProxy(
                    user.Email,
                    user.Password));

        }

        private void ManifestWriteTests_ValidUser_EmptyManifest(ManifestWriteProxy mwp)
        {
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];

            SetAndTestManifest(
                user.Email,
                user.Password,
                user.Gamertag,
                ValidManifests[0]);

            try
            {
                mwp.UpdateManifest(new UpdateManifestRequest() { Manifest = String.Empty });
                Assert.Fail("Expected RestException");
            }
            catch (RestException e)
            {
                //todo(michperr): Is this correct?
                Assert.AreEqual<HttpStatusCode>(HttpStatusCode.InternalServerError, e.Response.Status);
            }

            //todo(michperr): should this be 2000 0's?
            ValidateSingleManifestRead(
                user.Gamertag,
                ValidManifests[0]);
        }

        [TestMethod]
        public void ManifestWriteTests_Part_NoXAuthHeader()
        {
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];

            ManifestWriteTests_NoXAuthHeader(
                new ManifestWritePartProxy(
                    user.Email,
                    user.Password));

        }

        private void ManifestWriteTests_NoXAuthHeader(ManifestWriteProxy mwpp)
        {
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];

            SetAndTestManifest(
                user.Email,
                user.Password,
                user.Gamertag,
                ValidManifests[0]);

            //removing the auth delegate takes the Xauth header out
            mwpp.AuthorizationDelegate = null;

            try
            {
                mwpp.UpdateManifest(new UpdateManifestRequest() { Manifest = ValidManifests[1] });
                Assert.Fail("Expected 401");
            }
            catch (RestException e)
            {
                Assert.AreEqual<HttpStatusCode>(HttpStatusCode.Unauthorized, e.Response.Status);
            }

            ValidateSingleManifestRead(
                user.Gamertag,
                ValidManifests[0]);
        }

        [TestMethod]
        public void ManifestWriteTests_Part_ValidUser_Invalid_Len_3()
        {
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];

            ManifestWriteTests_ValidUser_Invalid_Len_2001(
                new ManifestWritePartProxy(
                    user.Email,
                    user.Password));
        }

        private void ManifestWriteTests_ValidUser_Invalid_Len_3(ManifestWriteProxy mwpp)
        {
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];

            SetAndTestManifest(
                user.Email,
                user.Password,
                user.Gamertag,
                ValidManifests[0]);

            try
            {
                UpdateManifestResponse umr = mwpp.UpdateManifest(new UpdateManifestRequest() { Manifest = GenerateRandomHexString(3) });
                Assert.Fail("Expected 500 from server");
            }
            catch (RestException e)
            {
                Assert.AreEqual<HttpStatusCode>(HttpStatusCode.InternalServerError, e.Response.Status);
            }

            ValidateSingleManifestRead(
                user.Gamertag,
                ValidManifests[0]);
        }

        [TestMethod]
        public void ManifestWriteTests_Part_ValidUser_Invalid_Len_2001()
        {
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];

            ManifestWriteTests_ValidUser_Invalid_Len_2001(
                new ManifestWritePartProxy(
                    user.Email,
                    user.Password));
        }

        private void ManifestWriteTests_ValidUser_Invalid_Len_2001(ManifestWriteProxy mwpp)
        {
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];

            SetAndTestManifest(
                user.Email,
                user.Password,
                user.Gamertag,
                ValidManifests[0]);

            try
            {
                UpdateManifestResponse umr = mwpp.UpdateManifest(new UpdateManifestRequest() { Manifest = Manifest_Invalid_Len_2001 });
                Assert.Fail("Expected 500 from server");
            }
            catch (RestException e)
            {
                Assert.AreEqual<HttpStatusCode>(HttpStatusCode.InternalServerError, e.Response.Status);
            }

            ValidateSingleManifestRead(
                user.Gamertag,
                ValidManifests[0]);
        }

        [TestMethod]
        public void ManifestWriteTests_Part_ValidUser_InvalidCharacter()
        {
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];

            ManifestWriteTests_ValidUser_InvalidCharacter(
                new ManifestWritePartProxy(
                    user.Email,
                    user.Password));
        }

        private void ManifestWriteTests_ValidUser_InvalidCharacter(ManifestWriteProxy mwpp)
        {
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];

            SetAndTestManifest(
                user.Email,
                user.Password,
                user.Gamertag,
                ValidManifests[0]);

            try
            {
                //todo(michperr): Get more valid manifests
                Random r = new Random();
                StringBuilder s = new StringBuilder(ValidManifests[1]);
                //todo(michperr): Move invalid char generation to common, expand the set to all non-hex chars.
                char[] invalidChars = {'%','$','Q','?'};
                s[r.Next(s.Length)] = invalidChars[r.Next(invalidChars.Length)];
                UpdateManifestResponse umr = mwpp.UpdateManifest(new UpdateManifestRequest() { Manifest = s.ToString() });
                Assert.Fail("Expected 500 response from server.");
            }
            catch (RestException e)
            {
                Assert.AreEqual<HttpStatusCode>(HttpStatusCode.InternalServerError, e.Response.Status);
            }
            ValidateSingleManifestRead(
                user.Gamertag,
                ValidManifests[0]);
        }

        [TestMethod]
        public void ManifestWriteTests_Part_ValidUser_InvalidManifest_InvalidVersion()
        {
            User user = User.CreateUser(AvatarGender.Unknown, 0, 0);

            ManifestWriteTests_ValidUser_InvalidManifest_InvalidVersion(
                new ManifestWritePartProxy(
                    user.Email,
                    user.Password));
        }

        private void ManifestWriteTests_ValidUser_InvalidManifest_InvalidVersion(ManifestWriteProxy mwpp)
        {
            UpdateManifestResponse umr;
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];

            SetAndTestManifest(
                user.Email,
                user.Password,
                user.Gamertag,
                ValidManifests[0]);

            try
            {
                // Need to call twice as newly created users do not cause an exception. - Don't know why but this does not matter to use as it's just verifying if the backend does throw an exception, we trap it. 
                umr = mwpp.UpdateManifest(new UpdateManifestRequest() { Manifest = Manifest_Invalid_Manifest_With_Invalid_Version });
                umr = mwpp.UpdateManifest(new UpdateManifestRequest() { Manifest = Manifest_Invalid_Manifest_With_Invalid_Version });
                
                Assert.Fail("Expected RestException");
            }
            catch (RestException re)
            {
                Assert.AreEqual<HttpStatusCode>(HttpStatusCode.InternalServerError, re.Response.Status);
            }
        }

        private void ManifestWriteTests_ValidUser_InvalidManifest_AllZero(ManifestWriteProxy mwpp)
        {
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];

            SetAndTestManifest(
                user.Email,
                user.Password,
                user.Gamertag,
                ValidManifests[0]);
            try
            {
                UpdateManifestResponse umr = mwpp.UpdateManifest(new UpdateManifestRequest() { Manifest = Manifest_Invalid_Len_2000_All_Zero });
                Assert.Fail("Expected 500 response.");
            }
            catch (RestException e)
            {
                Assert.AreEqual<HttpStatusCode>(HttpStatusCode.InternalServerError, e.Response.Status);
            }
            
            ValidateSingleManifestRead(
                user.Gamertag,
                ValidManifests[0]);
        }

        [TestMethod]
        public void ManifestWriteTests_Equip_Invalid_Awardable_Asset()
        {
            UpdateManifestResponse response;
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];
            ManifestWritePartProxy proxy = new ManifestWritePartProxy(user.Email, user.Password);

            try
            {
                // Need to call twice as newly created users do not cause an exception. - Don't know why but this does not matter to use as it's just verifying if the backend does throw an exception, we trap it. 
                response = proxy.UpdateManifest(new UpdateManifestRequest() { Manifest = Manifest_Invalid_Awardable_Assets });
                response = proxy.UpdateManifest(new UpdateManifestRequest() { Manifest = Manifest_Invalid_Awardable_Assets });
                
                Assert.Fail("Expected 500 response.");
            }
            catch (RestException e)
            {
                Assert.AreEqual<HttpStatusCode>(HttpStatusCode.InternalServerError, e.Response.Status);
            }
        }

        [TestMethod]
        public void ManifestWriteTests_Equip_Invalid_Marketplace_Asset()
        {
            UpdateManifestResponse response;
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];
            ManifestWritePartProxy proxy = new ManifestWritePartProxy(user.Email, user.Password);

            try
            {
                // Need to call twice as newly created users do not cause an exception. - Don't know why but this does not matter to use as it's just verifying if the backend does throw an exception, we trap it. 
                response = proxy.UpdateManifest(new UpdateManifestRequest() { Manifest = Manifest_Invalid_MarketPlace_Assets });
                response = proxy.UpdateManifest(new UpdateManifestRequest() { Manifest = Manifest_Invalid_MarketPlace_Assets });
                
                Assert.Fail("Expected 500 response.");
            }
            catch (RestException e)
            {
                Assert.AreEqual<HttpStatusCode>(HttpStatusCode.InternalServerError, e.Response.Status);
            }
        }

        [TestMethod]
        public void ManifestWriteTests_Invalid_Manifest_Hat_For_Earrings()
        {
            UpdateManifestResponse response;
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];
            ManifestWritePartProxy proxy = new ManifestWritePartProxy(user.Email, user.Password);

            try
            {
                // Need to call twice as newly created users do not cause an exception. - Don't know why but this does not matter to use as it's just verifying if the backend does throw an exception, we trap it. 
                response = proxy.UpdateManifest(new UpdateManifestRequest() { Manifest = Manifest_Invalid_Hat_For_Earrings });
                response = proxy.UpdateManifest(new UpdateManifestRequest() { Manifest = Manifest_Invalid_Hat_For_Earrings });
                
                Assert.Fail("Expected 500 response.");
            }
            catch (RestException e)
            {
                Assert.AreEqual<HttpStatusCode>(HttpStatusCode.InternalServerError, e.Response.Status);
            }
        }

        [TestMethod]
        public void ManifestWriteTests_User_Has_Awardable_Asset()
        {
            User user = UserCache.Instance.GetUsers(1, AvatarGender.Both, 0, 1)[0];

            SetAndTestManifest(
                user.Email,
                user.Password,
                user.Gamertag,
                ValidManifests[0]);

            user.EquipAsset(user.AwardList[0]);
            ManifestWritePartProxy proxy = new ManifestWritePartProxy(user.Email, user.Password);
            UpdateManifestResponse response = proxy.UpdateManifest(new UpdateManifestRequest() { Manifest = user.ManifestString });

            ValidateSingleManifestRead(user.Gamertag, user.ManifestString);
        }

        [TestMethod]
        public void ManifestWriteTests_User_Has_Marketplace_Asset()
        {
            User user;

            try
            {
                user = UserCache.Instance.GetUsers(1, AvatarGender.Both, 1, 0)[0];
            }
            catch (Exception exc)
            {
                if (exc.ToString().Contains("XOFF_E_INVALID_OFFER_ID"))
                {
                    Assert.Inconclusive("KNOWN ISSUE: One or more of the Asset(s) could not be found within the environment you are going against.\r\nException:\r\n:" + exc.ToString());
                }

                throw exc;
            }

            SetAndTestManifest(
                user.Email,
                user.Password,
                user.Gamertag,
                ValidManifests[0]);

            user.EquipAsset(user.PurchaseList[0]);
            ManifestWritePartProxy proxy = new ManifestWritePartProxy(user.Email, user.Password);
            UpdateManifestResponse response = proxy.UpdateManifest(new UpdateManifestRequest() { Manifest = user.ManifestString });

            ValidateSingleManifestRead(user.Gamertag, user.ManifestString);
        }

        private string GenerateRandomHexString(int length)
        {
            char [] hexChars = {'0','1','2','3','4','5','6','7','8','9','0','A','B','C','D','E','F'};
            StringBuilder sb = new StringBuilder(length);
            Random r = new Random();
            while (length-- > 0)
            {
                sb.Append(hexChars[r.Next(hexChars.Length)]);
            }
            return sb.ToString();
        }

        /// <summary>
        /// call manifest write to save the manifest, then call manifest read and make sure it's in the db
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <param name="gamerTag"></param>
        /// <param name="manifest"></param>
        private void SetAndTestManifest(string memberName, string password, string gamerTag, string manifest)
        {
            // set the user up initially with manifest 1, then switch to manifest 2
            ManifestWritePartProxy mwpp = new ManifestWritePartProxy(
                memberName,
                password);

            UpdateManifestResponse ump = mwpp.UpdateManifest(new UpdateManifestRequest() { Manifest = manifest });
            Assert.AreEqual<int>(0, ump.SuccessCode);

            ValidateSingleManifestRead(gamerTag, manifest);
        }

        private void ValidateEmptyManifest(string gamerTag)
        {
            ManifestReadOriginProxy mrp = new ManifestReadOriginProxy(gamerTag);
            AvatarManifests readResuts = mrp.GetManifest();
            Assert.AreEqual<int>(0, readResuts.Manifests.Length, "Unexpected number of manifests returned");
        }

        private void ValidateSingleManifestRead(string gamerTag, string manifest)
        {
            int retries = 30;
            AvatarManifests readResuts = null;
            ManifestReadOriginProxy mrp = new ManifestReadOriginProxy(gamerTag);

            for (int i = 0; i < retries; i++)
            {
                readResuts = mrp.GetManifest();

                if (readResuts.Manifests.Length > 0)
                {
                    break;
                }

                System.Diagnostics.Trace.WriteLine(string.Format("Manifest returned empty. Retry # {0}.", i));
                System.Threading.Thread.Sleep(1000);
            }

            Assert.IsNotNull(readResuts, "Manifest read response is null.");
            Assert.AreEqual<int>(1, readResuts.Manifests.Length, "Unexpected number of manifests returned");
            Assert.AreEqual<string>("\r\n" + manifest, "\r\n" + readResuts.Manifests[0].Manifest); // Adding the \r\n so the output it easier to compare
            Assert.AreEqual<string>(gamerTag, readResuts.Manifests[0].Gamertag);
        }

        private void ManifestWriteTests_BVT_ValidUser_ValidManifest(ManifestWriteProxy mwpp)
        {
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Unknown, 0, 0)[0];

            SetAndTestManifest(
                user.Gamertag,
                user.Password,
                user.Gamertag,
                ValidManifests[0]);

            UpdateManifestResponse umr = mwpp.UpdateManifest(new UpdateManifestRequest() { Manifest = ValidManifests[1] });
            ValidateSingleManifestRead(user.Gamertag, ValidManifests[1]);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\ManifestWritePerf\ManifestWritePerfTests.cs ===
﻿using System;
using System.Net;
using System.Text;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using AvatarServices.Test.Common;
using AvatarServices.Test.AvatarProxy;
using Avatar.Services.ManifestWrite.Library;
using Avatar.Services.ManifestRead.Library;
using Leet.Core.TestService.Client.DiagnosticDatabase;
using Infrastructure.Test.Common.Logging;
using Microsoft.XboxLive.Avatars;
using Microsoft.XboxLive.Avatars.Internal;
using System.IO;

namespace AvatarServices.Tests
{  
    /// Summary description for ManifestWriteTests
    /// </summary>
    [TestClass]
    public class ManifestWritePerfTests
    {
        private ManifestWriteProxy ValidManWrite;
        private ManifestWriteProxy InvalidManWrite;

        private readonly string ValidManifest;
        private readonly string InvalidManifest;

        /// <summary>
        /// Gets or sets the test context which provides
        /// information about and functionality for the current test run.
        ///</summary>
        public TestContext testContext
        {
            get;
            set;
        }

        public ManifestWritePerfTests()
        {
            ValidManifest = (new ManifestWriteTests()).ValidManifests[0];
            InvalidManifest = ManifestWriteTests.Manifest_Invalid_Hat_For_Earrings;

            ValidManWrite = new ManifestWritePartProxy("LLa7o63e7a8o4@xbltest.com", "supersecret");
            InvalidManWrite = new ManifestWritePartProxy("avatarsvcs2@xboxtest.com", "supersecret");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Valid Manifest being writen to LiveCache")]
        public void ManifestWritePerfTests_ValidManifest()
        {
            ValidManWrite.UpdateManifest(new UpdateManifestRequest() { Manifest = ValidManifest });
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Invalid Manifest being writen to LiveCache")]
        public void ManifestWritePerfTests_InvalidManifest()
        {
            try
            {
                InvalidManWrite.UpdateManifest(new UpdateManifestRequest() { Manifest = InvalidManifest });

                Assert.Fail("Invalid Manifests should result in an exception being thrown.");
            }
            catch (RestException exc)
            {
                Assert.AreEqual(HttpStatusCode.InternalServerError, exc.Response.Status, "Internal Server Error should have been returned.");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\ManifestRead\ManifestReadTests_BlacklistFilter.cs ===
﻿using System;
using System.IO;
using System.Collections.Generic;
using System.Reflection;
using System.Diagnostics;
using Avatar.Services.ManifestRead.Library;
using Avatar.Services.ServerSideRenderer.Messaging;
using AvatarServices.Test.AvatarProxy;
using AvatarServices.Test.Common;
using AvatarServices.Test.UserCache;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.XboxLive.Avatars;
using Microsoft.XboxLive.Avatars.Internal;

using ManifestReadLibrary = Avatar.Services.ManifestRead.Library;
using LiveN.Test.Avatar;

namespace AvatarServices.Tests
{
    /***************************
     * Setup steps:
     *  1. Go to t_settings and change lest_AvatarAssetFilterFileFullPath = C:\Blacklist\BlackListedAssets.xml
     *  2. Change lest_AvatarAssetFilterUpdateIntervalInSeconds = 1
     *  3. Stop and start w3svc
     *  
     * 
     */

    [TestClass]
    /// <summary>
    /// ManifestRead Blacklist Filter test cases
    /// </summary>
    public class ManifestReadTests_BlacklistFilter
    {
        /// <summary>
        /// Default manifest used to ensure the avatar's image stays the same
        /// </summary>
        private const string DEFAULT_MANIFEST = "000000003F0000003F80000000100000031E0003C1C8F109A19CB2E00008000003330003C1C8F109A19CB2E00020000003370003C1C8F109A19CB2E00000800002EF0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002820003C1C8F109A19CB2E03F80000000000000000000000000000000004000026A0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFDE914DFFB85E22FF5C3B2CFF727F35FFB85E22FF5395CAFFB85E22FF81271FFF81271F0000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401FE0003C1C8F109A19CB2E00004000000000000000000000000000000000008004B0001C1C8F109A19CB2E00008000000000000000000000000000000000010009C0001C1C8F109A19CB2E00010000000000000000000000000000000000020003B0001C1C8F109A19CB2E00020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020003B0001C1C8F109A19CB2E00020000000000000000000000000000000000010009C0001C1C8F109A19CB2E00010000000000000000000000000000000000008004B0001C1C8F109A19CB2E0000800000000000000000000000000000000000401FE0003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

        private readonly BaseAsset Asset_Hat = new StockAsset(new System.Guid("00000040-00e4-0001-c1c8-f109a19cb2e0"), "Red Baseball Cap", "hat", 0);
        private readonly BaseAsset Asset_Shirt = new StockAsset(new System.Guid("00000008-008e-0001-c1c8-f109a19cb2e0"), "Monkey Tee", "shirt", 0);
        private readonly BaseAsset Asset_Costume = new StockAsset(new System.Guid("00800238-00af-0001-c1c8-f109a19cb2e0"), "Western Duster", "Shirt, Trousers, Shoes, Wristwear, Costumes", 0);

        /// <summary>
        /// Power Tee is the default shirt used if a shirt asset needs to be filtered
        /// </summary>
        private readonly BaseAsset Asset_Shirt_PowerTee = new StockAsset(new System.Guid("00000008-0048-0001-c1c8-f109a19cb2e0"), "Power Tee", "shirt", 0);

        /// <summary>
        /// Test Context passed in by mstest
        /// </summary>
        public TestContext TestContext
        {
            get;
            set;
        }

        [ClassInitialize]
        public static void myClassInitialize(TestContext testContext)
        {
            FileInfo file;

            // TODO Really extract the values t_setting_overrides
            CommonCode.lest_AvatarAssetFilterFileFullPath = @"\\LIVEnfile01\AvatarResources\584d07d1\AssetFiltering\BlackListedAssets.xml";
            CommonCode.lest_AvatarAssetFilterUpdateIntervalInSeconds = 14400;

            // TODO Really change these within the DB
            CommonCode.AvatarAssetFilterFileFullPath = @"C:\Blacklist\BlackListedAssets.xml";
            CommonCode.AvatarAssetFilterUpdateIntervalInSeconds = 1;

            file = new FileInfo(CommonCode.AvatarAssetFilterFileFullPath);

            // Ensure the directory exists
            if (!Directory.Exists(file.DirectoryName))
            {
                Directory.CreateDirectory(file.DirectoryName);
            }
        }

        [TestInitialize]
        public void myTestInitialize()
        {
            SSRTests.RestGamerPicImages();

            CommonCode.TestStartTime = DateTime.Now;
        }

        [TestCleanup]
        public void myTestCleanup()
        {
            SSRTests.WriteImages(this.TestContext.TestName);
        }

        [ClassCleanup]
        public static void myClassCleanup()
        {
            // TODO Really put the old values back within t_setting_overrides
            CommonCode.AvatarAssetFilterFileFullPath = CommonCode.lest_AvatarAssetFilterFileFullPath;
            CommonCode.AvatarAssetFilterUpdateIntervalInSeconds = CommonCode.lest_AvatarAssetFilterUpdateIntervalInSeconds;
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verifies Blacklist Filter is set up correctly.")]
        public void ManifestReadTests_BVT_Origin_BlacklistFilter()
        {
            TestUserData testUser;
            BaseAsset marketAsset;

            if (CommonCode.isEnvironmentLocalRun)
            {
                // Test is not running within TestNet, make sure this test is running against the correct Blacklist
                using (StreamReader sr = new StreamReader(Assembly.GetExecutingAssembly().GetManifestResourceStream(CommonCode.DEFUALT_BLACK_LIST)))
                {
                    CommonCode.UpdateBlacklist(sr.ReadToEnd());
                }
            }

            // Get a user with a predefined Marketplace Assets 
            testUser = CommonCode.GetUserWithAwardAndMarketplace(false, true);

            // Set the users default appearance
            testUser.User.ManifestString = DEFAULT_MANIFEST;
            testUser.User.WriteManifest(true, Config.Environment.ManifestWritePartService);

            // This Market place Asset should be within the Global Target of the predefined Blacklist. Assembly location: "AvatarServices.Tests.Closet.BlackListedAssets.xml"
            marketAsset = new StockAsset(CommonCode.testMarketplaceList[1].Id, CommonCode.testMarketplaceList[1].Description, CommonCode.testMarketplaceList[1].Category.ToString(), 0);

            // Equip the passed in Asset to the default user
            EquipAssert(testUser.User, marketAsset);

            // Marketplace asset should be filtered.
            UpdateUsersManifestWithManifestReads_Origin(testUser.User);

            GenerateGamerPic(testUser.User);

            SSRTests.AssertDiagnosticImageFound(false, true);

            VerifyDiagnosticImageVersSaved();
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verifies Blacklist Filter is set up correctly.")]
        public void ManifestReadTests_BVT_Partner_BlacklistFilter()
        {
            TestUserData testUser;
            BaseAsset marketAsset;

            if (CommonCode.isEnvironmentLocalRun)
            {
                // Test is not running within TestNet, make sure this test is running against the correct Blacklist
                using (StreamReader sr = new StreamReader(Assembly.GetExecutingAssembly().GetManifestResourceStream(CommonCode.DEFUALT_BLACK_LIST)))
                {
                    CommonCode.UpdateBlacklist(sr.ReadToEnd());
                }
            }

            // Get a user with a predefined Marketplace Assets 
            testUser = CommonCode.GetUserWithAwardAndMarketplace(false, true);

            // Set the users default appearance
            testUser.User.ManifestString = DEFAULT_MANIFEST;
            testUser.User.WriteManifest(true, Config.Environment.ManifestWritePartService);

            marketAsset = new StockAsset(CommonCode.testMarketplaceList[0].Id, CommonCode.testMarketplaceList[0].Description, CommonCode.testMarketplaceList[0].Category.ToString(), 0);

            // Equip the passed in Asset to the user
            EquipAssert(testUser.User, marketAsset);

            //**** Do you want to see what the Avatar looks like. Just uncomment the below.
            //GenerateBodyShot(testUser.User);
            //GenerateGamerPic(testUser.User);
            //SSRTests.AssertDiagnosticImageFound(true, true);
            //Assert.Fail("Checking equipped Asset. For efficiency, this section need to be commented out again.");
            //****

            // Marketplace asset should be filtered.
            UpdateUsersManifestWithManifestReads_Partner(testUser.User, uint.Parse(Config.EnvironmentSettings.SelectedEnvironment.StsSettings.TitleId), uint.Parse(Config.EnvironmentSettings.SelectedEnvironment.StsSettings.PlatformType));

            GenerateGamerPic(testUser.User);

            SSRTests.AssertDiagnosticImageFound(false, true);

            VerifyDiagnosticImageVersSaved();
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Pulls back the default avatar images to verify that they look the same as when this test was created.")]
        public void ManifestReadTests_BlacklistFilter_DefaultImageCheck()
        {
            User user = GetDefaultUser();

            GenerateBodyShot(user);
            GenerateGamerPic(user);

            SSRTests.AssertDiagnosticImageFound(true, true);   

            VerifyDiagnosticImageVersSaved();
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verifies that a specific Asset GETS filtered to something reasonable")]
        public void ManifestReadTests_BlacklistFilter_Hat_Filtered()
        {
            VerifyAssetGetsFiltered(Asset_Hat);
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verifies that a specific Asset DOES NOT get filtered to something reasonable")]
        public void ManifestReadTests_BlacklistFilter_Hat_NotFiltered()
        {
            VerifyAssetDoesNotGetFiltered(Asset_Hat);
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verifies that a specific Asset GETS filtered to something reasonable")]
        public void ManifestReadTests_BlacklistFilter_Shirt_Filtered()
        {
            VerifyAssetGetsFiltered(Asset_Shirt);
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verifies that a specific Asset DOES NOT get filtered to something reasonable")]
        public void ManifestReadTests_BlacklistFilter_Shirt_NotFiltered()
        {
            VerifyAssetDoesNotGetFiltered(new BaseAsset[] { Asset_Shirt, Asset_Costume });
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verifies that a specific Asset GETS filtered to something reasonable")]
        public void ManifestReadTests_BlacklistFilter_Costume_Filtered()
        {
            VerifyAssetGetsFiltered(Asset_Costume);
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Even though an asset that is the default asset is itself blacklisted, it's still working. While this should never happen, it's good to see what happens if it did.")]
        public void ManifestReadTests_BlacklistFilter_PowerTee_Filtered()
        {
            // NOTE: Even though an asset that is the default asset is itself blacklisted, it's should still working. While this should never happen, it's good to see what happens if it did.

            try
            {
                VerifyAssetGetsFiltered(Asset_Shirt_PowerTee);
            }
            catch(Exception exc)
            {
                if (!exc.Message.Contains("Manifest Filtered flag should be true"))
                {
                    // Unknown Exception
                    throw;
                }

                // Ok this one is strange, just under this strange edge cases. The Manifest Filtered flag is not getting set to filtered. As this is so far the only case I can get to repro this, I'm going to ignore.
            }
            
            // NOTE: Special note to the overly observent. When you place the Power Pee on top of a non filtered BlackListed shit. You will end up getting the previously ok Asset and not the Power Tee. 
            //       But if you place a Blacklisted Asset and then the Power Tee, you will get the Power Tee. This case is verified within ManifestReadTests_BlacklistFilter_CurrentAndPreviousBlacklistedAssets
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verifies that a specific Asset DOES NOT get filtered to something reasonable")]
        public void ManifestReadTests_BlacklistFilter_Costume_NotFiltered()
        {
            VerifyAssetDoesNotGetFiltered(new BaseAsset[] { Asset_Shirt, Asset_Costume });
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify that if Title ID is valid, title ID is used.")]
        public void ManifestReadTests_BlacklistFilter_Partner_TitleID_Exists()
        {
            User user;
            BlacklistedAssets blacklist;

            user = GetDefaultUser();

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", Asset_Hat.Id.ToString());
            blacklist.Add(CommonCode.TargetTypes.TitleID, "4D6CDA4", Asset_Hat.Id.ToString());
            blacklist.Add(CommonCode.TargetTypes.Platform, "12345", Asset_Hat.Id.ToString());
            blacklist.Add(CommonCode.TargetTypes.TitleID, Config.EnvironmentSettings.SelectedEnvironment.StsSettings.TitleId); // Caller will fall under this target
            CommonCode.UpdateBlacklist(blacklist);

            EquipAssert(user, Asset_Hat);

            // As you are using a TitleID that does not filter this cap out. Your image should still have the hat on.
            UpdateUsersManifestWithManifestReads_Partner(user);

            GenerateGamerPic(user);

            SSRTests.AssertDiagnosticImageFound(false, true);

            VerifyDiagnosticImageVersSaved();
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify that if Title ID is valid, Platform ID is used.")]
        public void ManifestReadTests_BlacklistFilter_Partner_PlatformID_Exists()
        {
            User user;
            BlacklistedAssets blacklist;

            user = GetDefaultUser();

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", Asset_Hat.Id.ToString());
            blacklist.Add(CommonCode.TargetTypes.TitleID, "4D6CDA4", Asset_Hat.Id.ToString());
            blacklist.Add(CommonCode.TargetTypes.Platform, Config.EnvironmentSettings.SelectedEnvironment.StsSettings.PlatformType); // Caller will fall under this target
            blacklist.Add(CommonCode.TargetTypes.TitleID, "81186212", Asset_Hat.Id.ToString()); 
            CommonCode.UpdateBlacklist(blacklist);

            EquipAssert(user, Asset_Hat);

            // As you are using a PartnerId that does not filter this cap out. Your image should still have the hat on.
            UpdateUsersManifestWithManifestReads_Partner(user);

            GenerateGamerPic(user);

            SSRTests.AssertDiagnosticImageFound(false, true);

            VerifyDiagnosticImageVersSaved();
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify that if a platform ID that is recognized within the Blacklist, it gets used.")]
        public void ManifestReadTests_BlacklistFilter_PlatformID_Exists()
        {
            User user;
            BlacklistedAssets blacklist;

            user = GetDefaultUser();

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", Asset_Hat.Id.ToString());
            blacklist.Add(CommonCode.TargetTypes.TitleID, "4D6CDA4", Asset_Hat.Id.ToString());
            blacklist.Add(CommonCode.TargetTypes.Platform, "12345"); // Caller will fall under this target
            blacklist.Add(CommonCode.TargetTypes.TitleID, "81186212", Asset_Hat.Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            EquipAssert(user, Asset_Hat);

            // As you are using a platform ID that does not filter this cap out. Your image should still have the hat on.
            UpdateUsersManifestWithManifestReads_Origin(user, 0, 12345);

            GenerateGamerPic(user);

            SSRTests.AssertDiagnosticImageFound(false, true);

            VerifyDiagnosticImageVersSaved();
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify that if Title ID is valid, title ID is used.")]
        public void ManifestReadTests_BlacklistFilter_TitleID_Exists()
        {
            User user;
            BlacklistedAssets blacklist;

            user = GetDefaultUser();

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", Asset_Hat.Id.ToString());
            blacklist.Add(CommonCode.TargetTypes.TitleID, "4D6CDA4", Asset_Hat.Id.ToString()); 
            blacklist.Add(CommonCode.TargetTypes.Platform, "12345", Asset_Hat.Id.ToString());
            blacklist.Add(CommonCode.TargetTypes.TitleID, "81186212"); // Caller will fall under this target
            CommonCode.UpdateBlacklist(blacklist);

            EquipAssert(user, Asset_Hat);

            // As you are using a TitleID that does not filter this cap out. Your image should still have the hat on.
            UpdateUsersManifestWithManifestReads_Origin(user, 81186212, 0);

            GenerateGamerPic(user);

            SSRTests.AssertDiagnosticImageFound(false, true);

            VerifyDiagnosticImageVersSaved();
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify that if both Title ID and Platform ID are valid, title ID is used.")]
        public void ManifestReadTests_BlacklistFilter_TitleID_Over_PlatformID()
        {
            User user;
            BlacklistedAssets blacklist;

            user = GetDefaultUser();

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", Asset_Hat.Id.ToString());
            blacklist.Add(CommonCode.TargetTypes.TitleID, "4D6CDA4"); // Caller will fall under this target
            blacklist.Add(CommonCode.TargetTypes.Platform, "12345", Asset_Hat.Id.ToString()); 
            blacklist.Add(CommonCode.TargetTypes.TitleID, "81186212", Asset_Hat.Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            EquipAssert(user, Asset_Hat);

            // As you are using a platform ID that does not filter this cap out. Your image should still have the hat on.
            UpdateUsersManifestWithManifestReads_Origin(user, 0x4D6CDA4, 12345);

            GenerateGamerPic(user);

            SSRTests.AssertDiagnosticImageFound(false, true);

            VerifyDiagnosticImageVersSaved();
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify that if both Title ID and Platform ID are valid but TitleID is not within the BlackList, PlatformID is used.")]
        public void ManifestReadTests_BlacklistFilter_NotFoundTitleID_With_PlatformID()
        {
            User user;
            BlacklistedAssets blacklist;

            user = GetDefaultUser();

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", Asset_Hat.Id.ToString());
            blacklist.Add(CommonCode.TargetTypes.TitleID, "4D6CDA4", Asset_Hat.Id.ToString());
            blacklist.Add(CommonCode.TargetTypes.Platform, "12345"); // Caller will fall under this target
            blacklist.Add(CommonCode.TargetTypes.TitleID, "81186212", Asset_Hat.Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            EquipAssert(user, Asset_Hat);

            // As you are using a platform ID that does not filter this cap out. Your image should still have the hat on.
            UpdateUsersManifestWithManifestReads_Origin(user, 0xABCD, 12345);

            GenerateGamerPic(user);

            SSRTests.AssertDiagnosticImageFound(false, true);

            VerifyDiagnosticImageVersSaved();
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify that if both Title ID and Platform ID are valid but are not within the Blacklist file, Global is used.")]
        public void ManifestReadTests_BlacklistFilter_NotFoundTitleID_With_NotFoundPlatformID()
        {
            User user;
            BlacklistedAssets blacklist;

            user = GetDefaultUser();

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0");
            blacklist.Add(CommonCode.TargetTypes.TitleID, "4D6CDA4", Asset_Hat.Id.ToString());
            blacklist.Add(CommonCode.TargetTypes.Platform, "12345", Asset_Hat.Id.ToString());
            blacklist.Add(CommonCode.TargetTypes.TitleID, "81186212", Asset_Hat.Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            EquipAssert(user, Asset_Hat);

            // Adding extra values. So contains would say they are a match. But they are not exact match
            UpdateUsersManifestWithManifestReads_Origin(user, 0x4D6CDA49, 123459);

            GenerateGamerPic(user);

            SSRTests.AssertDiagnosticImageFound(false, true);

            VerifyDiagnosticImageVersSaved();
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify that if the Asset Guid is all Caps, it still gets filtered.")]
        public void ManifestReadTests_BlacklistFilter_CapitalizeAssetGuid()
        {
            User user;
            BlacklistedAssets blacklist;

            user = GetDefaultUser();

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", Asset_Hat.Id.ToString().ToUpper());
            CommonCode.UpdateBlacklist(blacklist);

            EquipAssert(user, Asset_Hat);

            // No match, should use Global and filter out the hat
            UpdateUsersManifestWithManifestReads_Origin(user);

            GenerateGamerPic(user);

            SSRTests.AssertDiagnosticImageFound(false, true);

            VerifyDiagnosticImageVersSaved();
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify that if the Asset Guid is all lower cased, it still gets filtered.")]
        public void ManifestReadTests_BlacklistFilter_LowercasedAssetGuid()
        {
            User user;
            BlacklistedAssets blacklist;

            user = GetDefaultUser();

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", Asset_Hat.Id.ToString().ToLower());
            CommonCode.UpdateBlacklist(blacklist);

            EquipAssert(user, Asset_Hat);

            // No match, should use Global and filter out the hat
            UpdateUsersManifestWithManifestReads_Origin(user);

            GenerateGamerPic(user);

            SSRTests.AssertDiagnosticImageFound(false, true);

            VerifyDiagnosticImageVersSaved();
        }

        [TestMethod]
        [WorkItem(9404)]
        [Owner("rsnyder")]
        [Description("Verify that if there are duplicate Assets, it still loads correctly.")]
        public void ManifestReadTests_BlacklistFilter_DuplicateAssets()
        {
            User user;
            BlacklistedAssets blacklist;

            user = GetDefaultUser();

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", Asset_Hat.Id.ToString().ToUpper());
            blacklist.Assets[0].Add(blacklist.Assets[0].AssetIDs[0]);
            CommonCode.UpdateBlacklist(blacklist);

            EquipAssert(user, Asset_Hat);

            // No match, should use Global and filter out the hat
            UpdateUsersManifestWithManifestReads_Origin(user);

            GenerateGamerPic(user);

            SSRTests.AssertDiagnosticImageFound(false, true);

            VerifyDiagnosticImageVersSaved();
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verifies that even if the user currently has a Blacklisted assest as well as there previous asset was Blacklist, it still does not get selected as the fall back.")]
        public void ManifestReadTests_BlacklistFilter_CurrentAndPreviousBlacklistedAssets()
        {
            User user;
            BlacklistedAssets blacklist;
            ManifestReadLibrary::AvatarManifest avatarManifest = null;

            // Get a user with all the default configurations
            user = GetDefaultUser();

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", Asset_Shirt.Id.ToString());
            blacklist.Assets[0].Add(Asset_Costume.Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            // Equip the passed in Asset to the default user
            EquipAssert(user, Asset_Shirt);

            // Now equip another blacklisted Asset
            EquipAssert(user, Asset_Costume);

            // Now pull the user's Manifest through ManifestRead where it should be filtered out
            avatarManifest = UpdateUsersManifestWithManifestReads_Origin(user);

            // Generate Gamer Pics so you can visually verify that the Manifest has been altered
            GenerateGamerPic(user);
            SSRTests.AssertDiagnosticImageFound(false, true);

            // Using the pulled down images from AssertDiagnosticImageFound, compare them against the save images within the test suite.
            VerifyDiagnosticImageVersSaved();

            Assert.IsTrue(avatarManifest.Filtered, "Assert flag should be true as asset was filtered.");
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify that if the caller has multi Assets, then all get removed.")]
        public void ManifestReadTests_BlacklistFilter_MultiBlockedAssets()
        {
            User user;
            BlacklistedAssets blacklist;

            user = GetDefaultUser();

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", Asset_Hat.Id.ToString());
            blacklist.Assets[0].Add(Asset_Shirt.Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            EquipAssert(user, Asset_Hat);
            EquipAssert(user, Asset_Shirt);

            // As you are using a TitleID that does not filter this cap out. Your image should still have the hat on.
            UpdateUsersManifestWithManifestReads_Partner(user);

            GenerateGamerPic(user);

            SSRTests.AssertDiagnosticImageFound(false, true);

            VerifyDiagnosticImageVersSaved();
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify that a single Assest can found within Thousands of other Asserts.")]
        public void ManifestReadTests_BlacklistFilter_ThousandsOfGuids()
        {
            User user;
            int index;
            int TotalAssets = 5000;
            Random rnd = new Random();
            BlacklistedAssets blacklist;

            // Randomly pick the location of where the asset will be placed within the total assets
            index = rnd.Next(0, TotalAssets);

            Trace.WriteLine("Asset location within the array of " + TotalAssets.ToString() + " is " + index.ToString());

            user = GetDefaultUser();

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0");

            for (int i = 0; i < TotalAssets; i++)
            {
                if (index == i)
                {
                    blacklist.Assets[0].Add(Asset_Hat.Id.ToString().ToUpper());

                    continue;
                }

                blacklist.Assets[0].Add(Guid.NewGuid().ToString());
            }

            CommonCode.UpdateBlacklist(blacklist);

            EquipAssert(user, Asset_Hat);

            // No match, should use Global and filter out the hat
            UpdateUsersManifestWithManifestReads_Origin(user);

            GenerateGamerPic(user);

            SSRTests.AssertDiagnosticImageFound(false, true);

            VerifyDiagnosticImageVersSaved();
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify that if the Asset Guid is invalid, it does not effect other Assets from getting filtered.")]
        public void ManifestReadTests_BlacklistFilter_InvalidGuid()
        {
            User user;
            BlacklistedAssets blacklist;

            user = GetDefaultUser();

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", "Oops this is not a valid guid");
            blacklist.Assets[0].Add(Asset_Hat.Id.ToString());
            blacklist.Assets[0].Add("Invalid Guid");
            CommonCode.UpdateBlacklist(blacklist);

            EquipAssert(user, Asset_Hat);

            // No match, should use Global and filter out the hat
            UpdateUsersManifestWithManifestReads_Origin(user, 0x4D6CDA49, 123459);

            GenerateGamerPic(user);

            SSRTests.AssertDiagnosticImageFound(false, true);

            VerifyDiagnosticImageVersSaved();
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify that updating the blacklist works.")]
        public void ManifestReadTests_BlacklistFilter_UpdateBlacklist()
        {
            User user;
            BlacklistedAssets blacklist;
            ManifestReadLibrary::AvatarManifest avatarManifest = null;

            user = GetDefaultUser();

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", Asset_Hat.Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            EquipAssert(user, Asset_Hat);

            // No match, should use Global and filter out the hat
            avatarManifest = GetUsersManifestWithManifestRead_Origin(user, 0, 0);

            Assert.AreEqual("\r\n" + DEFAULT_MANIFEST, "\r\n" + avatarManifest.Manifest, "Hat should have been removed. So manafest should be identical to default at this point.");

            // Now remove the blacklisted Hat
            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0");
            CommonCode.UpdateBlacklist(blacklist);

            GenerateGamerPic(user);

            SSRTests.AssertDiagnosticImageFound(false, true);

            // Avatar should now have the hat on. As it's no longer blacklisted.
            VerifyDiagnosticImageVersSaved();
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify that updating the blacklist works even if there is a write lock on the file.")]
        public void ManifestReadTests_BlacklistFilter_UpdateBlacklistWithWriteLockOn()
        {
            User user;
            string xmlOutput;
            StreamWriter sw = null;
            BlacklistedAssets blacklist;
            ManifestReadLibrary::AvatarManifest avatarManifest = null;

            user = GetDefaultUser();

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", Asset_Hat.Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            EquipAssert(user, Asset_Hat);

            // No match, should use Global and filter out the hat
            avatarManifest = GetUsersManifestWithManifestRead_Origin(user, 0, 0);

            Assert.AreEqual("\r\n" + DEFAULT_MANIFEST, "\r\n" + avatarManifest.Manifest, "Hat should have been removed. So manafest should be identical to default at this point.");

            // Now remove the blacklisted Hat
            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0");

            try
            {
                // Open the file and write. But do not close the handle
                xmlOutput = blacklist.SerializeToXmlString();
                sw = new StreamWriter(CommonCode.AvatarAssetFilterFileFullPath, false);

                sw.Write(xmlOutput);

                // File has been written, now wait for the file to be picked up by the service
                System.Threading.Thread.Sleep(CommonCode.AvatarAssetFilterUpdateIntervalInSeconds * 1000);

                GenerateGamerPic(user);

                SSRTests.AssertDiagnosticImageFound(false, true);

                // Avatar should now have the hat on. As it's no longer blacklisted.
                VerifyDiagnosticImageVersSaved();
            }
            finally
            {
                // Ensure the file handle gets closed
                if (sw != null)
                {
                    sw.Close();
                }
            }
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify that if the file is missing while updating, that an event gets through.")]
        public void ManifestReadTests_BlacklistFilter_MissingFileOnUpdate()
        {
            User user;
            BlacklistedAssets blacklist;
            ManifestReadLibrary::AvatarManifest avatarManifest = null;

            user = GetDefaultUser();

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", Asset_Hat.Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            EquipAssert(user, Asset_Hat);

            // No match, should use Global and filter out the hat
            avatarManifest = GetUsersManifestWithManifestRead_Origin(user, 0, 0);

            Assert.AreEqual("\r\n" + DEFAULT_MANIFEST, "\r\n" + avatarManifest.Manifest, "Hat should have been removed. So manafest should be identical to default at this point.");

            // Now remove the blacklist file
            File.Delete(CommonCode.AvatarAssetFilterFileFullPath);

            // File has been deleted, now wait for the service to try and picked up the file
            System.Threading.Thread.Sleep(CommonCode.AvatarAssetFilterUpdateIntervalInSeconds * 1000);

            CommonCode.ValidateEvents(EventIDs.BLACKLIST_FileLoadFailureEvent);

            // File is missing, the service to continue to use the old file
            avatarManifest = GetUsersManifestWithManifestRead_Origin(user, 0, 0);

            Assert.AreEqual("\r\n" + DEFAULT_MANIFEST, "\r\n" + avatarManifest.Manifest, "Hat should have been removed. So manafest should be identical to default at this point.");

            // Now remove the blacklisted Hat and update the file to ensure it gets picked up
            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0");
            CommonCode.UpdateBlacklist(blacklist);

            GenerateGamerPic(user);

            SSRTests.AssertDiagnosticImageFound(false, true);

            // Avatar should now have the hat on. As it's no longer blacklisted.
            VerifyDiagnosticImageVersSaved();
        }

        [TestMethod]
        [Owner("rsnyder")]
        [Description("Verify that if the file is missing while starting, that an event gets through.")]
        public void ManifestReadTests_BlacklistFilter_MissingFileOnLoad()
        {
            User user;
            BlacklistedAssets blacklist;
            ManifestReadLibrary::AvatarManifest avatarManifest = null;

            Assert.Inconclusive("NEED TO IMPLEMENT: Test case needs to be fully implemented");

            user = GetDefaultUser();

            EquipAssert(user, Asset_Hat);

            // Now remove the blacklist file
            File.Delete(CommonCode.AvatarAssetFilterFileFullPath);

            // TODO: NOW Stop and start the service

            CommonCode.ValidateEvents(EventIDs.BLACKLIST_FileLoadFailureEvent);

            GenerateGamerPic(user);

            SSRTests.AssertDiagnosticImageFound(false, true);

            // Avatar should have the hat on as there should be nothing blocked.
            VerifyDiagnosticImageVersSaved();

            // Now create the blacklist and verify that it blocks the Hat
            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", Asset_Hat.Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            // File is missing, the service should continue to load with blank Blocked Assets
            avatarManifest = GetUsersManifestWithManifestRead_Origin(user, 0, 0);

            Assert.AreEqual("\r\n" + DEFAULT_MANIFEST, "\r\n" + avatarManifest.Manifest, "Hat should have been removed. So manafest should be identical to default at this point.");
        }

        /// <summary>
        /// Verify the downloaded Diagnostic Images vers the images stored within the Assembly
        /// </summary>
        public void VerifyDiagnosticImageVersSaved()
        {
            string assemblyRoot = "AvatarServices.Tests.ManifestRead.Verification_Images.";

            // For these tests I don't care about the small images
            SSRTests.smallGamerPicDiagnosticImage = new byte[0];

            SSRTests.VerifyDiagnosticImageVersSaved(Assembly.GetExecutingAssembly(), assemblyRoot, this.TestContext);
        }

        /// <summary>
        /// Get a user with all the defaults 
        /// </summary>
        /// <returns>New user</returns>
        public static User GetDefaultUser()
        {
            User user = UserCache.Instance.GetUser(AvatarGender.Male);

            // TODO this is required becuase the user needs a GamerTile. This should be rethought.
            SSRTests.ResetAllImages(user.Xuid);

            // Set the users default appearance
            user.ManifestString = DEFAULT_MANIFEST;
            user.WriteManifest(true, Config.Environment.ManifestWritePartService);

            return user;
        }

        /// <summary>
        /// Equips the passed in asset to the passed in user
        /// </summary>
        /// <param name="user">User you want the asset equipped to</param>
        /// <param name="asset">Asset to equip</param>
        public static void EquipAssert(User user, BaseAsset asset)
        {
            user.EquipAsset(asset);

            // After the user has equiped an asset, it has to be written to there manifest
            user.WriteManifest(true, Config.Environment.ManifestWritePartService);
        }

        /// <summary>
        /// Tell SSR to generate a new Body Shot
        /// </summary>
        /// <param name="user"></param>
        public static void GenerateBodyShot(User user)
        {
            GenerateBodyShotMessage bsMessage = SSRTests.CreateDiagnosticBodyShotMessage(user);

            SSRTests.SendMessage(bsMessage);
        }

        /// <summary>
        /// Tell SSR to generate a new Gamer Pic image
        /// </summary>
        public static void GenerateGamerPic(User user)
        {
            GenerateGamerPictureMessage gpMessage = SSRTests.CreateCenteredDiagnosticGamerPicMessage(user);

            SSRTests.SendMessage(gpMessage);
        }

        /// <summary>
        /// Verify that the passed in Asset gets filtered out
        /// </summary>
        /// <param name="filteredAsset">Asset to be equipped and then verified via image comparison that it's nolonger on</param>
        public void VerifyAssetGetsFiltered(BaseAsset filteredAsset)
        {
            User user;
            BlacklistedAssets blacklist;
            string manifestBeforeFiltering = null;
            ManifestReadLibrary::AvatarManifest avatarManifest = null;

            // Get a user with all the default configurations
            user = GetDefaultUser();

            // Equip the passed in Asset to the default user
            EquipAssert(user, filteredAsset);

            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", filteredAsset.Id.ToString());
            CommonCode.UpdateBlacklist(blacklist);

            //**** Do you want to see what the Avatar looks like. Just uncomment the below.
            //GenerateBodyShot(user);
            //GenerateGamerPic(user);
            //SSRTests.AssertDiagnosticImageFound(true, true);
            //Assert.Fail("Checking equipped Asset. This section need to be commented out again.");
            //****

            // Save off the Manifest before it gets update with the filtered manifest
            manifestBeforeFiltering = user.ManifestString;

            // Now pull the user's Manifest through ManifestRead where it should be filtered out
            avatarManifest = UpdateUsersManifestWithManifestReads_Origin(user);

            // Adding the new line so if these get outputed they line up together. Easier to see the differences this way.
            Assert.AreNotEqual("\r\n" + manifestBeforeFiltering, "\r\n" + avatarManifest.Manifest, "These Manifest should not be the same as the Manifest from the user should have been filtered.");

            // Generate Gamer Pics so you can visually verify that the Manifest has been altered
            GenerateGamerPic(user);
            SSRTests.AssertDiagnosticImageFound(false, true);

            // Using the pulled down images from AssertDiagnosticImageFound, compare them against the save images within the test suite.
            VerifyDiagnosticImageVersSaved();

            Assert.IsTrue(avatarManifest.Filtered, "Manifest Filtered flag should be true as asset was filtered.");
        }

        /// <summary>
        /// Verifies that an Asset that is of the same Category as the filtered Asset does not get filtered out by mistack
        /// </summary>
        /// <param name="filteredAsset">Asset that is within the BlackList</param>
        public void VerifyAssetDoesNotGetFiltered(BaseAsset filteredAsset)
        {
            VerifyAssetDoesNotGetFiltered(new BaseAsset[] { filteredAsset });
        }

        /// <summary>
        /// Verifies that an Asset that is of the same Category as the filtered Asset does not get filtered out by mistack
        /// </summary>
        /// <param name="filteredAsset">Assets that are within the BlackList</param>
        public void VerifyAssetDoesNotGetFiltered(BaseAsset[] filteredAssets)
        {
            User user;
            int Index = 0;
            Random rnd = new Random();
            BlacklistedAssets blacklist;
            BaseAsset equipAsset = null;
            List<StockAsset> assets = null;
            ComponentCategories assetCategory;
            ManifestReadLibrary::AvatarManifest avatarManifest = null;

            if ((filteredAssets == null) || (filteredAssets.Length == 0))
            {
                throw new ArgumentNullException("filteredAssets", "Filtered arrary must contain atleast 1.");
            }

            // Slightly limiting. But will do for now
            assetCategory = filteredAssets[0].Category;

            // Find an Asset that is not one that has been filtered out
            assets = StockAssetCollection.Instance.FindAll(AvatarGender.Male, assetCategory, false, string.Empty);

            // Used to choose a different asset each time
            Index = rnd.Next(0, assets.Count);

            for (int i = 0; i < assets.Count; i++)
            {
                bool useable = true;

                for (int x = 0; x < filteredAssets.Length; x++)
                {
                    if (filteredAssets[x].Id == assets[Index].Id)
                    {
                        useable = false;
                    }
                }

                if (useable)
                {
                    // This Asset is not the same as the one that gets filtered.
                    equipAsset = assets[Index];

                    break;
                }

                // The index asset did not meet the criteria. Move on to the next asset.
                Index++;
                if (Index >= assets.Count)
                {
                    // Index is outside the assert range. Start from the beginning
                    Index = 0;
                }
            }

            if (equipAsset == null)
            {
                Assert.Fail("Could not find an Assert for the category '" + assetCategory.ToString() + "' that did not belong to the filtered asset list.");
            }

            Trace.WriteLine("TRACE: Selected Asset ID: '" + equipAsset.Id.ToString() + "' Description: '" + equipAsset.Description + "' Category: '" + equipAsset.Category.ToString() + "' BodyType: " + equipAsset.BodyType + "'");

            // Now generate the Filtered list based off the Filtered Assets passed
            blacklist = CommonCode.QuickCreateBlacklist(CommonCode.TargetTypes.Global, "0", filteredAssets[0].Id.ToString());
            for (int i = 1; i < filteredAssets.Length; i++)
            {
                blacklist.Assets[0].Add(filteredAssets[i].Id.ToString());
            }

            CommonCode.UpdateBlacklist(blacklist);

            // Get a user with all the default configurations
            user = GetDefaultUser();

            EquipAssert(user, equipAsset);

            avatarManifest = GetUsersManifestWithManifestRead_Origin(user);

            //**** Do you want to see what the Avatar looks like. Just uncomment the below.
            //GenerateBodyShot(user);
            //GenerateGamerPic(user);
            //SSRTests.AssertDiagnosticImageFound(true, true); 
            //Assert.Fail("Checking equipped Asset. For efficiency, this section need to be commented out again.");
            //****

            // Adding the new line so if these get outputed they line up together. Easier to see the differences this way.
            Assert.AreEqual("\r\n" + user.ManifestString, "\r\n" + avatarManifest.Manifest, "No Filteration should have been applied to this user. This Manifest should be the same before and after ManifestRead.");
            Assert.IsFalse(avatarManifest.Filtered, "Assert flag should be false as the asset was not filtered.");
        }

        /// <summary>
        /// Get the passed in Users Manifest via the ManifestRead API
        /// </summary>
        /// <param name="user">User's Manifest to be returned via the ManifestRead API</param>
        public static ManifestReadLibrary::AvatarManifest GetUsersManifestWithManifestRead_Origin(User user)
        {
            // Uses the global BlackList Filter
            return GetUsersManifestWithManifestRead_Origin(user, 0, 0);
        }

        /// <summary>
        /// Get the passed in Users Manifest via the ManifestRead API
        /// </summary>
        /// <param name="user">User's Manifest to be returned via the ManifestRead API</param>
        /// <param name="titleID">Title ID used to distinguish between the different Blacklists</param>
        /// <param name="platformType">Platform type used to distinguish between the different Blacklists</param>
        public static ManifestReadLibrary::AvatarManifest GetUsersManifestWithManifestRead_Origin(User user, UInt32 titleID, UInt32 platformType)
        {
            int retries = 30;
            bool receivedManifest = false;
            AvatarManifests avatarManifests = null;
            ManifestReadOriginProxy proxyOrigin = new ManifestReadOriginProxy(user.Gamertag);

            for (int i = 0; i < retries; i++)
            {
                avatarManifests = proxyOrigin.GetManifest(titleID, platformType);

                if ((avatarManifests != null) &&
                     (avatarManifests.Manifests != null) &&
                     (avatarManifests.Manifests.Length > 0)
                   )
                {
                    receivedManifest = true;

                    break;
                }

                System.Diagnostics.Trace.WriteLine(string.Format("Manifest Origin returned empty. Retry # {0}.", i));
                System.Threading.Thread.Sleep(1000);
            }

            if (!receivedManifest)
            {
                Assert.Fail("Failed to pull a Manifest form ManifestRead Origin for this user.");
            }

            return avatarManifests.Manifests[0];
        }

        /// <summary>
        /// Get the passed in Users Manifest via the ManifestRead API
        /// </summary>
        /// <param name="user">User's Manifest to be returned via the ManifestRead API</param>
        /// <param name="titleID">Title ID used to distinguish between the different Blacklists</param>
        /// <param name="platformType">Platform type used to distinguish between the different Blacklists</param>
        public static ManifestReadLibrary::AvatarManifest GetUsersManifestWithManifestRead_Partner(User user, UInt32 titleID, UInt32 platformType)
        {
            int retries = 30;
            bool receivedManifest = false;
            AvatarManifests avatarManifests = null;
            ManifestReadPartProxy proxyPartner = new ManifestReadPartProxy(user.Email, user.Password);

            // titleID is not used. As it gets set when logging in. So bigger change will need to happen

            proxyPartner.PlatformType = platformType.ToString();

            for (int i = 0; i < retries; i++)
            {
                avatarManifests = proxyPartner.GetManifest();

                if ((avatarManifests != null) &&
                     (avatarManifests.Manifests != null) &&
                     (avatarManifests.Manifests.Length > 0)
                   )
                {
                    receivedManifest = true;

                    break;
                }

                System.Diagnostics.Trace.WriteLine(string.Format("Manifest Partner returned empty. Retry # {0}.", i));
                System.Threading.Thread.Sleep(1000);
            }

            if (!receivedManifest)
            {
                Assert.Fail("Failed to pull a Manifest form ManifestRead Partner for this user.");
            }

            return avatarManifests.Manifests[0];
        }

        /// <summary>
        /// Call Manifest Read for the passed in user.Manifest and then Write that Manifest as the users Manifest. Useful to test out what Assets got filtered out. 
        /// As when you call read, the Assets are Filtered. Writing them back, sets the users manifest with the filtered Assets so you can take a pic of the user.
        /// </summary>
        /// <param name="user">User's Manifest to be updated with the returned Manifest from ManifestRead</param>
        public static ManifestReadLibrary::AvatarManifest UpdateUsersManifestWithManifestReads_Partner(User user)
        {
            return UpdateUsersManifestWithManifestReads_Partner(user, uint.Parse(Config.EnvironmentSettings.SelectedEnvironment.StsSettings.TitleId), uint.Parse(Config.EnvironmentSettings.SelectedEnvironment.StsSettings.PlatformType));
        }

        /// <summary>
        /// Call Manifest Read for the passed in user.Manifest and then Write that Manifest as the users Manifest. Useful to test out what Assets got filtered out. 
        /// As when you call read, the Assets are Filtered. Writing them back, sets the users manifest with the filtered Assets so you can take a pic of the user.
        /// </summary>
        /// <param name="user">User's Manifest to be updated with the returned Manifest from ManifestRead</param>
        /// <param name="titleID">Title ID used to distinguish between the different Blacklists</param>
        /// <param name="platformType">Platform type used to distinguish between the different Blacklists</param>
        public static ManifestReadLibrary::AvatarManifest UpdateUsersManifestWithManifestReads_Partner(User user, UInt32 titleID, UInt32 platformType)
        {
            ManifestReadLibrary::AvatarManifest avatarManifest = null;

            avatarManifest = GetUsersManifestWithManifestRead_Partner(user, titleID, platformType);

            user.ManifestString = avatarManifest.Manifest;
            user.WriteManifest(true, Config.Environment.ManifestWritePartService);

            return avatarManifest;
        }

        /// <summary>
        /// Call Manifest Read for the passed in user and then save that Manifest as the users Manifest. Useful for when the Manifest has been altered because of an Asset(s) being filtered out.
        /// </summary>
        /// <param name="user">User's Manifest to be updated with the returned Manifest from ManifestRead</param>
        public static ManifestReadLibrary::AvatarManifest UpdateUsersManifestWithManifestReads_Origin(User user)
        {
            // Uses the global BlackList Filter
            return UpdateUsersManifestWithManifestReads_Origin(user, 0, 0);
        }

        /// <summary>
        /// Call Manifest Read for the passed in user.Manifest and then Write that Manifest as the users Manifest. Useful to test out what Assets got filtered out. 
        /// As when you call read, the Assets are Filtered. Writing them back, sets the users manifest with the filtered Assets so you can take a pic of the user.
        /// </summary>
        /// <param name="user">User's Manifest to be updated with the returned Manifest from ManifestRead</param>
        /// <param name="titleID">Title ID used to distinguish between the different Blacklists</param>
        /// <param name="platformType">Platform type used to distinguish between the different Blacklists</param>
        public static ManifestReadLibrary::AvatarManifest UpdateUsersManifestWithManifestReads_Origin(User user, UInt32 titleID, UInt32 platformType)
        {
            ManifestReadLibrary::AvatarManifest avatarManifest = null;

            avatarManifest = GetUsersManifestWithManifestRead_Origin(user, titleID, platformType);

            user.ManifestString = avatarManifest.Manifest;
            user.WriteManifest(true, Config.Environment.ManifestWritePartService);

            return avatarManifest;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\ManifestRead\ManifestReadTests_Common.cs ===
﻿using System;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Cache;
using System.Text;
using System.Xml.Linq;
using Avatar.Services.ManifestRead.Library;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using AvatarServices.Test.Common;
using AvatarServices.Test.UserCache;
using AvatarServices.Test.AvatarProxy;

namespace AvatarServices.Tests
{
    /// <summary>
    /// Partial class containing only the common members for ManifestReadTests
    /// </summary>
    [TestClass]
    public partial class ManifestReadTests
    {
        private static Random randomGenerator = new Random();
        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        /// <summary>
        /// Returns a random gamertag of length given by MAX_GAMERTAG_LENGTH.
        /// </summary>
        /// <returns>Random gamertag of length MAX_GAMERTAG_LENGTH.</returns>
        public string GetRandomGamertag()
        {
            StringBuilder sb = new StringBuilder(TestSettings.MAX_GAMERTAG_LENGTH);
            // First character of a gamertag must be a letter
            sb.Append(TestSettings.VALID_GAMERTAG_CHARACTERS[randomGenerator.Next(26)]);
            for (int i = 1; i < 16; i++)
            {
                sb.Append(TestSettings.VALID_GAMERTAG_CHARACTERS[randomGenerator.Next(37)]);
            }
            return sb.ToString();
        }

        //todo(michperr): FIgure out how to make this repeatable
        /// <summary>
        /// Randomizes the case of a given string.
        /// </summary>
        /// <param name="s">String to be randomized.</param>
        /// <returns>String who case is randomized.</returns>
        public string RandomizeCase(string s)
        {
            StringBuilder sb = new StringBuilder(s.Length);
            foreach (char c in s)
            {
                sb.Append((randomGenerator.Next(2) >= 1) ? char.ToUpper(c) : char.ToLower(c));
            }
            return sb.ToString();
        }


        /// <summary>
        /// Creates a comma seperated string for the list of gamertags.
        /// </summary>
        /// <param name="GamertagList">The list of gamertags.</param>
        /// <returns>A comma seperated gamertag string.</returns>
        public static string GetGamertagString(string[] GamertagList)
        {
            if (GamertagList == null)
            {
                return null;
            }
            return string.Join(",", GamertagList);
        }

        /// <summary>
        /// Creates a comma seperated string for the list of users.
        /// </summary>
        /// <param name="userList">The list of users.</param>
        /// <returns>A comma seperated gamertag string.</returns>
        public static string GetGamertagString(User[] userList)
        {
            if (userList == null || userList.Length == 0)
            {
                return string.Empty;
            }

            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < userList.Length - 1; i++)
            {
                sb.Append(userList[i].Gamertag);
                sb.Append(",");
            }
            sb.Append(userList[userList.Length - 1].Gamertag);

            return sb.ToString();
        }

        private AvatarManifests GetAvatarManifestsObject(string gamerTagString, bool urlEncode)
        {
            if (urlEncode)
            {
                gamerTagString = Uri.EscapeUriString(gamerTagString);
            }
            ManifestReadOriginProxy mrp = new ManifestReadOriginProxy(gamerTagString);
            RestResponse rr = mrp.GetManifest_RR(0, 0);

            // Only check header for functional tests
            if (!this.TestContext.TestName.ToLower().StartsWith("bvt"))
            {
                Assert.IsTrue(rr.CorrectContentType);
            }

            return RestRequest.DeserializeObject<AvatarManifests>(rr.Body);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\SSR\SSRTests_BlackListFilter.cs ===
﻿using System.Collections.Generic;
using AssetLibrary;
using Avatar.Services.ServerSideRenderer.Messaging;
using CloudServices.Test.Common.Configuration;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.XboxLive.Avatars;
using Test.Avatar.Functional.AvatarServiceTests.Common;
using Avatar.Services.ManifestRead.Library;
using Avatar.Test.AvatarProxy;

namespace Test.Avatar.Functional.AvatarServiceTests
{
    public partial class SSRTests
    {
        [TestMethod]
        [Description("When an avatar pic message for a female with awarded assets is sent, verify that an image is generated.")]
        public void BVT_SSR_BlacklistFilter_FilterHat()
        {
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Female, 0, 0)[0];
            //User user = UserCache.Instance.GetUsers(1, AvatarGender.Female)[0];

            //GenerateGamerPictureMessage message = new GenerateGamerPictureMessage();
            //message.XUID = user.Xuid;
            //message.OffsetZ = -5;
            //message.Frame = 45;
            //message.UsePropAnimation = true;
            //byte[] manifest = Xboxcom.Test.Library.Avatar.GenerateManifestData("00000000BF800000BF00000000100000031F0003C1C8F109A19CB2E00008000003260003C1C8F109A19CB2E00020000003370003C1C8F109A19CB2E00000800002F90003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A20003C1C8F109A19CB2E03F8000000000000000000000000000000000400002620003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF64411BFF1F120BFFEB7D80FF212121FF1F120BFFBA72B6FF1F120BFFCF5969FFCF59690000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402230003C1C8F109A19CB2E0000400000000000000000000000000000000000801110002C1C8F109A19CB2E00008000000000000000000000000000000000010015E0002C1C8F109A19CB2E00010000000000000000000000000000000000020010B0002C1C8F109A19CB2E0002000000000000000000000000000000000040005010002C1C8F109A19CB2E0040000000000000000000000000000000000100073794213CE5F59B75858082810000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020010B0002C1C8F109A19CB2E00020000000000000000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000000801110002C1C8F109A19CB2E0000800000000000000000000000000000000000402230003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");

            //Ugly Dress that this av will have on "00800018-0171-0002-c1c8-f109a19cb2e0"

            string sdgf = GetDiagnosticVersion(1).ToString();

            user.ManifestString = "000000003F8000003F80000000100000031C0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002FF0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002C20003C1C8F109A19CB2E03F80000000000000000000000000000000004000026A0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFBE8749FF372116FFD46552FF37512AFF372116FFFEC854FF372116FFB24F7DFFB24F7D0000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401F80003C1C8F109A19CB2E0000400000000000000000000000000000000002001050002C1C8F109A19CB2E0002000000000000000000000000000000000040005010002C1C8F109A19CB2E0040000000000000000000000000000000080001801720002C1C8F109A19CB2E0001800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001050002C1C8F109A19CB2E0002000000000000000000000000000000000001001590002C1C8F109A19CB2E00010000000000000000000000000000000000008011F0002C1C8F109A19CB2E0000800000000000000000000000000000000000401F80003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            //Contains giud "000000003F8000003F80000000100000031C0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002FF0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002C20003C1C8F109A19CB2E03F80000000000000000000000000000000004000026A0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFBE8749FF372116FFD46552FF37512AFF372116FFFEC854FF372116FFB24F7DFFB24F7D0000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401F80003C1C8F109A19CB2E0000400000000000000000000000000000000002001050002C1C8F109A19CB2E0002000000000000000000000000000000000040005010002C1C8F109A19CB2E0040000000000000000000000000000000080001801720002C1C8F109A19CB2E0001800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001050002C1C8F109A19CB2E0002000000000000000000000000000000000001001590002C1C8F109A19CB2E00010000000000000000000000000000000000008011F0002C1C8F109A19CB2E0000800000000000000000000000000000000000401F80003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
                                //"000000003F8000003F80000000100000031C0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002FF0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002C20003C1C8F109A19CB2E03F80000000000000000000000000000000004000026A0003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFBE8749FF372116FFD46552FF37512AFF372116FFFEC854FF372116FFB24F7DFFB24F7D0000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401F80003C1C8F109A19CB2E00004000000000000000000000000000000000008011F0002C1C8F109A19CB2E0000800000000000000000000000000000000001001590002C1C8F109A19CB2E0001000000000000000000000000000000000002001050002C1C8F109A19CB2E0002000000000000000000000000000000000040005010002C1C8F109A19CB2E004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002001050002C1C8F109A19CB2E0002000000000000000000000000000000000001001590002C1C8F109A19CB2E00010000000000000000000000000000000000008011F0002C1C8F109A19CB2E0000800000000000000000000000000000000000401F80003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            
            user.WriteManifest(true, Config.Environment.ManifestWritePartService);
            ResetAllImages(user.Xuid);

            ManifestReadOriginProxy proxy = new ManifestReadOriginProxy(user.Gamertag);

            int retries = 30;
            AvatarManifests m_TargetAvatarManifests = null;

            for (int i = 0; i < retries; i++)
            {
                m_TargetAvatarManifests = proxy.GetManifest();

                if ( (m_TargetAvatarManifests != null) && (m_TargetAvatarManifests.Manifests != null) )
                {
                    if (m_TargetAvatarManifests.Manifests.Length > 0)
                    {
                        break;
                    }
                }

                System.Diagnostics.Trace.WriteLine(string.Format("Manifest returned empty. Retry # {0}.", i));
                System.Threading.Thread.Sleep(1000);
            }

            user.ManifestString = m_TargetAvatarManifests.Manifests[0].Manifest;
            user.WriteManifest(true, Config.Environment.ManifestWritePartService);
                        
            GenerateBodyShotMessage bsMessage = CreateDiagnosticBodyShotMessage(user);
            //bsMessage.

            GenerateGamerPictureMessage gpMessage = CreateCenteredDiagnosticGamerPicMessage(user);
            gpMessage.OffsetX = 0f; 
            gpMessage.OffsetY = 0.3f; 
            gpMessage.OffsetZ = 2f; 

            SendMessage(bsMessage);
            SendMessage(gpMessage);

            AssertDiagnosticImageFound(true, true);
            
            Assert.AreEqual(1, 2);

            //if ((filterMask & AvatarAssetFilterMask.BlacklistedAssets) == AvatarAssetFilterMask.BlacklistedAssets)
            //{//Ugly Dress that this av will have on "00800018-0171-0002-c1c8-f109a19cb2e0"
                //filter black listed assets. We will use the Tatra avanata manifest editing APIs.
                Microsoft.XboxLive.Avatars.AvatarManifest avManifest = Microsoft.XboxLive.Avatars.AvatarManifest.Create(user.ManifestByte);
            //    AvatarComponentMasks componentMasksToRemove = GetComponentMasksToRemove(avManifest);
            //    if (componentMasksToRemove != AvatarComponentMasks.None)
            //    {
            //        manifestChanged = true;
            //        avManifest.RemoveComponents(componentMasksToRemove);
            //    }

            //    manifest = avManifest.SaveToBinary();
            //}




           // user = UserCache.Instance.GetUsers(1, AvatarGender.Male)[0];
           // List<AwardableAsset> asset = AwardableAssetCollection.Instance.FindMultiple(2, AvatarGender.Male);
           // "00800018-0171-0002-c1c8-f109a19cb2e0"
            List<StockAsset> asset = StockAssetCollection.Instance.FindMultiple(2, AvatarGender.Female, ComponentCategories.Hat, false , string.Empty);
            
            BaseAsset test = new StockAsset(asset[0].Id, asset[0].Description, asset[0].CategoryString, asset[0].Index);

            user.EquipAsset(test);
            if (!user.EquipAllAssets())
            {
                Assert.Inconclusive("Failed to equip assets.");
            }

            //user.Manifest = 
            user.WriteManifest(true, Config.Environment.ManifestWritePartService);
            ResetAllImages(user.Xuid);

            bsMessage = CreateDiagnosticBodyShotMessage(user);
            //bsMessage.

            gpMessage = CreateCenteredDiagnosticGamerPicMessage(user);
            //message.OffsetX = 0;
            //message.OffsetY = -0.05f;
            gpMessage.OffsetZ = 3f;
            //message.RotationY = 0.01f;

            SendMessage(bsMessage);
            SendMessage(gpMessage);

            AssertDiagnosticImageFound(true, true);
         }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\SSR\SSRRendererTests.cs ===
﻿using Avatar.Services.ServerSideRenderer.Messaging;
using Leet.Core.Configuration;
using Leet.Core.Diagnostics;
using Leet.Core.IO;
using Leet.Core.IoCCo;
using Leet.Live.Livecache;
using Leet.Live.Livecache.Account;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.XboxLive.Avatars;
using Microsoft.XboxLive.Avatars.Internal;
using Test.Avatar.Functional.AvatarServiceTests.Common;
using AssetLibrary;
using System;
using System.Diagnostics;
using CloudServices.Test.Common.Configuration;

namespace Test.Avatar.Functional.AvatarServiceTests
{
    /// <summary>
    /// Generates a bunch of images to be manually verified
    /// </summary>
    [TestClass]
    public partial class SSRRendererTests
    {
        #region Constructor/Properties and fields
        public SSRRendererTests()
        {
            Container.Instance.AddService<ILogFormatter, LogFormatter>();
            Container.Instance.AddService<ILogging, Logging>();
            Container.Instance.AddService<ILcAuthManager, AnonymousLcAuthManager>();
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();

            ConfigurationSelector.RegisterProvider(componentName, "LEET");
            LeetLivecacheClient.RegisterServiceInterfacesAndInitialize(componentName);
        }
        private TestContext testContextInstance;
        private const string componentName = "avatarsvcs_serversiderenderer";
        private const int frameCount = 50;

        public TestContext TestContext
        {
            get { return testContextInstance; }
            set { testContextInstance = value; }
        }
        #endregion

        [TestMethod]
        public void Functional_SSR_Rendering_Male_AnimationFemaleIdleCheckNails()
        {
            User user = UserCache.Instance.GetUsers(1, AvatarGender.Male)[0];

            for (int i = 0; i < frameCount; i++)
            {
                GenerateGamerPictureMessage message = new GenerateGamerPictureMessage();
                message.XUID = user.Xuid;
                message.AnimationId = AvatarAssetsPack.AnimationFemaleIdleCheckNails;
                message.Frame = i * 5;
                message.OffsetZ = SSRTests.GamerPicCameraBox.AvatarSSRGamerpicMaxZOffset;
                SendTestMessage(message, string.Format("{0}_{1}.png", this.TestContext.TestName, i));
            }
        }

        [TestMethod]
        public void Functional_SSR_Rendering_Female_AnimationMaleShockedSurprised()
        {
            User user = UserCache.Instance.GetUsers(1, AvatarGender.Female)[0];

            for (int i = 0; i < frameCount; i++)
            {
                GenerateGamerPictureMessage message = new GenerateGamerPictureMessage();
                message.XUID = user.Xuid;
                message.AnimationId = AvatarAssetsPack.AnimationMaleShockedSurprised;
                message.Frame = i * 5;
                message.OffsetZ = SSRTests.GamerPicCameraBox.AvatarSSRGamerpicMaxZOffset;
                SendTestMessage(message, string.Format("{0}_{1}.png", this.TestContext.TestName, i));
            }
        }

        [TestMethod]
        public void Functional_SSR_Rendering_Male_Carryables()
        {
            User user = UserCache.Instance.GetUsers(1, AvatarGender.Male)[0];

            user.AwardAssets(AwardableAssetCollection.Instance.FindAll(AvatarGender.Male, ComponentCategories.Carryable, false, string.Empty));
            user.PurchaseAssets(MarketplaceAssetCollection.Instance.FindAll(AvatarGender.Male, ComponentCategories.Carryable, false, string.Empty));

            bool successful = true;

            for (int i = 0; i < user.AwardList.Count; i++)
            {
                user.EquipAsset(user.AwardList[i]);
                user.WriteManifest(true, Config.Environment.ManifestWritePartService);

                GenerateGamerPictureMessage message = new GenerateGamerPictureMessage();
                message.XUID = user.Xuid;
                message.Frame = 20;
                message.OffsetZ = SSRTests.GamerPicCameraBox.AvatarSSRGamerpicMaxZOffset;
                message.UsePropAnimation = true;

                if (!SendTestMessage(message, string.Format("Male_{0}_20_{1}.png", user.AwardList[i].Description.Replace(" ", "_"), i)))
                    successful = false;

                message.Frame = 45;
                if (!SendTestMessage(message, string.Format("Male_{0}_45_{1}.png", user.AwardList[i].Description.Replace(" ", "_"), i)))
                    successful = false;
            }

            for (int i = 0; i < user.PurchaseList.Count; i++)
            {
                user.EquipAsset(user.PurchaseList[i]);
                user.WriteManifest(true, Config.Environment.ManifestWritePartService);

                GenerateGamerPictureMessage message = new GenerateGamerPictureMessage();
                message.XUID = user.Xuid;
                message.Frame = 20;
                message.OffsetZ = SSRTests.GamerPicCameraBox.AvatarSSRGamerpicMaxZOffset;
                message.UsePropAnimation = true;

                if (!SendTestMessage(message, string.Format("Male_{0}_20_{1}.png", user.PurchaseList[i].Description.Replace(" ", "_"), i)))
                    successful = false;

                message.Frame = 45;
                if (!SendTestMessage(message, string.Format("Male_{0}_45_{1}.png", user.PurchaseList[i].Description.Replace(" ", "_"), i)))
                    successful = false;
            }

            if (!successful)
            {
                Assert.Fail("Some of the images failed to load");
            }
        }

        [TestMethod]
        public void Functional_SSR_Rendering_Female_Carryables()
        {
            User user = UserCache.Instance.GetUsers(1, AvatarGender.Female)[0];

            user.AwardAssets(AwardableAssetCollection.Instance.FindAll(AvatarGender.Female, ComponentCategories.Carryable, false, string.Empty));
            user.PurchaseAssets(MarketplaceAssetCollection.Instance.FindAll(AvatarGender.Female, ComponentCategories.Carryable, false, string.Empty));

            bool successful = true;

            for (int i = 0; i < user.AwardList.Count; i++)
            {
                user.EquipAsset(user.AwardList[i]);
                user.WriteManifest(true, Config.Environment.ManifestWritePartService);

                GenerateGamerPictureMessage message = new GenerateGamerPictureMessage();
                message.XUID = user.Xuid;
                message.OffsetZ = SSRTests.GamerPicCameraBox.AvatarSSRGamerpicMaxZOffset;
                message.Frame = 20;
                message.UsePropAnimation = true;

                if (!SendTestMessage(message, string.Format("Female_{0}_20_{1}.png", user.AwardList[i].Description.Replace(" ", "_"), i)))
                    successful = false;

                message.Frame = 45;
                if (!SendTestMessage(message, string.Format("Female_{0}_45_{1}.png", user.AwardList[i].Description.Replace(" ", "_"), i)))
                    successful = false;
            }

            for (int i = 0; i < user.PurchaseList.Count; i++)
            {
                user.EquipAsset(user.PurchaseList[i]);
                user.WriteManifest(true, Config.Environment.ManifestWritePartService);

                GenerateGamerPictureMessage message = new GenerateGamerPictureMessage();
                message.XUID = user.Xuid;
                message.OffsetZ = SSRTests.GamerPicCameraBox.AvatarSSRGamerpicMaxZOffset;
                message.Frame = 20;
                message.UsePropAnimation = true;

                if (!SendTestMessage(message, string.Format("Female_{0}_20_{1}.png", user.PurchaseList[i].Description.Replace(" ", "_"), i)))
                    successful = false;

                message.Frame = 45;
                if (!SendTestMessage(message, string.Format("Female_{0}_45_{1}.png", user.PurchaseList[i].Description.Replace(" ", "_"), i)))
                    successful = false;
            }

            if (!successful)
            {
                Assert.Fail("Some of the images failed to load");
            }
        }

        [Description("Regresstion test for bug # 4442")]
        [TestMethod]
        public void Functional_SSR_Rendering_Carryable_Hand()
        {            
            User user = UserCache.Instance.GetUsers(1, AvatarGender.Female)[0];

            GenerateGamerPictureMessage message = new GenerateGamerPictureMessage();
            message.XUID = user.Xuid;
            message.OffsetZ = SSRTests.GamerPicCameraBox.AvatarSSRGamerpicMaxZOffset;
            message.Frame = 45;
            message.UsePropAnimation = true;
            message.AvatarManifest = Xboxcom.Test.Library.Avatar.GenerateManifestData("00000000BF800000BF00000000100000031F0003C1C8F109A19CB2E00008000003260003C1C8F109A19CB2E00020000003370003C1C8F109A19CB2E00000800002F90003C1C8F109A19CB2E03F8000000000000000000000000000000000200002A20003C1C8F109A19CB2E03F8000000000000000000000000000000000400002620003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF64411BFF1F120BFFEB7D80FF212121FF1F120BFFBA72B6FF1F120BFFCF5969FFCF59690000000200010002C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000402230003C1C8F109A19CB2E0000400000000000000000000000000000000000801110002C1C8F109A19CB2E00008000000000000000000000000000000000010015E0002C1C8F109A19CB2E00010000000000000000000000000000000000020010B0002C1C8F109A19CB2E0002000000000000000000000000000000000040005010002C1C8F109A19CB2E0040000000000000000000000000000000000100073794213CE5F59B75858082810000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020010B0002C1C8F109A19CB2E00020000000000000000000000000000000000010015E0002C1C8F109A19CB2E0001000000000000000000000000000000000000801110002C1C8F109A19CB2E0000800000000000000000000000000000000000402230003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");

            Assert.IsTrue(SendTestMessage(message, this.TestContext.TestName + ".png"));
        }

        private bool SendTestMessage(GenerateGamerPictureMessage message, string imageName)
        {
            try
            {
                GamerPictureMessageProcessorEx processor = new GamerPictureMessageProcessorEx();
                bool result = processor.ProcessTestMessage(message, imageName);
                if (!result)
                {
                    Trace.WriteLine(string.Format("ERROR: Failed to render image - {0}", imageName));
                }
                return result;
            }
            catch (Exception ex)
            {
                Trace.WriteLine(string.Format("ERROR: Failed to render image - {0}: {1}", imageName, ex.ToString()));
                return false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\SSR\SSRTests_BVT.cs ===
﻿using Avatar.Services.ServerSideRenderer.Messaging;
using AvatarServices.Test.Common;
using AvatarServices.Test.UserCache;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace AvatarServices.Tests
{
    /// <summary>
    /// SSR BVT test cases
    /// </summary>
    public partial class SSRTests
    {
        [TestMethod]
        [Description("When a valid diagnostic bodyshot message is sent, verify that an image is generated.")]
        public void SSRTests_BVT_DiagnosticBodyShot_Valid()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateBodyShotMessage message = CreateDiagnosticBodyShotMessage(user);
            SendMessage(message);

            AssertDiagnosticImageFound(true, false);
        }

        [TestMethod]
        [Description("When a valid diagnostic gamerpic message is sent, verify that images are generated.")]
        public void SSRTests_BVT_DiagnosticGamerPic_Valid()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\SSR\SSRTests_BodyShot.cs ===
﻿using Avatar.Services.ServerSideRenderer.Messaging;
using Leet.Core.TestService;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using AvatarServices.Test.Common;
using AvatarServices.Test.UserCache;
using Microsoft.XboxLive.Avatars.Internal;

namespace AvatarServices.Tests
{
    /// <summary>
    /// SSR functional tests for bodyshot - XUID, Pose, Version, Type
    /// </summary>
    public partial class SSRTests
    {
        #region Xuid
        [Description("When a bodyshot message with a valid xuid is sent, verify that the image is generated.")]
        [TestMethod]
        public void SSRTests_BodyShot_Xuid_Valid()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateBodyShotMessage message = CreateDiagnosticBodyShotMessage(user.Xuid, 1);
            SendMessage(message);

            AssertDiagnosticImageFound(true, false);
        }

        [Description("When a bodyshot message with an invalid xuid is sent, verify that no image is generated.")]
        [TestMethod]
        public void SSRTests_BodyShot_Xuid_Invalid()
        {
            ResetAllImages(invalidXuid);

            GenerateBodyShotMessage message = CreateDiagnosticBodyShotMessage(invalidXuid, 1);
            SendMessage(message);

            AssertDiagnosticImageFound(false, false);
            CommonCode.ValidateEvents(EventIDs.SSR_GamerProfileRetrievalFailure, 1);
        }
        #endregion

        #region Version/Type
        [Description("When a bodyshot message with an invalid version is sent, verify that no image is generated.")]
        [TestMethod]
        public void SSRTests_BodyShot_Version_Invalid()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateBodyShotMessage message = CreateDiagnosticBodyShotMessage(user.Xuid, 3);
            SendMessage(message);

            AssertDiagnosticImageFound(false, false);
            CommonCode.ValidateEvents(EventIDs.SSR_UnrecognizedMessageVersion, 1);
        }

        [Description("When a custom data type is sent within GenerateBodyShotMessage, verify that no image is generated.")]
        [TestMethod]
        public void SSRTests_BodyShot_DataStruct_Invalid()
        {
            ResetAllImages(invalidXuid);

            CustomMessage message = new CustomMessage(123.456);
            SendBodyShotMessage(message);

            AssertDiagnosticImageFound(false, false);
            CommonCode.ValidateEvents(EventIDs.SSR_UnrecognizedMessageFormat, 1);
        }
        #endregion

        #region Pose

        [Description("When a bodyshot message with random pose flag, verify that a random image is generated in all 10 images.")]
        [TestMethod]
        public void SSRTests_BodyShot_Pose_Random()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            for (int i = 0; i < 10; i++)
            {
                GenerateBodyShotMessage message = CreateDiagnosticBodyShotMessage(user.Xuid, 1);
                message.PickRandomPose = true;
                SendMessage(message);

                AssertDiagnosticImageFound(true, false);
                WriteImages(this.TestContext.TestName, i);
            }
        }

        [Description("When a bodyshot message with a valid pose index is sent, verify that the same image is generated in all 3 images.")]
        [TestMethod]
        public void SSRTests_BodyShot_Pose_Index_Valid()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            for (int i = 0; i < 3; i++)
            {
                GenerateBodyShotMessage message = CreateDiagnosticBodyShotMessage(user.Xuid, 1);
                message.PickRandomPose = false;
                message.PoseIndex = 2;
                SendMessage(message);

                AssertDiagnosticImageFound(true, false);
                WriteImages(this.TestContext.TestName, i);
            }
        }

        [Description("When a bodyshot message with a invalid pose index is sent, verify that the default image is generated in all 3 images..")]
        [TestMethod]
        public void SSRTests_BodyShot_Pose_Index_Invalid()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            for (int i = 0; i < 3; i++)
            {
                GenerateBodyShotMessage message = CreateDiagnosticBodyShotMessage(user.Xuid, 1);
                message.PickRandomPose = false;
                message.PoseIndex = 1000;
                SendMessage(message);

                AssertDiagnosticImageFound(true, false);
                WriteImages(this.TestContext.TestName, i);
            }
        }

        [Description("Renders all female poses")]
        [TestMethod]
        public void SSRTests_BodyShot_Pose_Index_Female()
        {
            User user = UserCache.Instance.GetUsers(1, Microsoft.XboxLive.Avatars.Internal.AvatarGender.Female, 0, 0)[0];
            ResetAllImages(user.Xuid);

            for (int i = 0; i < poseMax; i++)
            {
                GenerateBodyShotMessage message = CreateDiagnosticBodyShotMessage(user.Xuid, 1);
                message.PickRandomPose = false;
                message.PoseIndex = i;
                SendMessage(message);

                AssertDiagnosticImageFound(true, false);
                WriteImages(this.TestContext.TestName, i);
                CommonCode.SSRTestService.DeleteImages(Config.Environment.SsrMachineName);
            }
        }

        [Description("Renders all male poses")]
        [TestMethod]
        public void SSRTests_BodyShot_Pose_Index_Male()
        {
            User user = UserCache.Instance.GetUsers(1, Microsoft.XboxLive.Avatars.Internal.AvatarGender.Male, 0, 0)[0];
            ResetAllImages(user.Xuid);

            for (int i = 0; i < poseMax; i++)
            {
                GenerateBodyShotMessage message = CreateDiagnosticBodyShotMessage(user.Xuid, 1);
                message.PickRandomPose = false;
                message.PoseIndex = i;
                SendMessage(message);

                AssertDiagnosticImageFound(true, false);
                WriteImages(this.TestContext.TestName, i);
                CommonCode.SSRTestService.DeleteImages(Config.Environment.SsrMachineName);
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\SSR\SSRTests_GamerPic_Animation.cs ===
﻿using System;
using Avatar.Services.ServerSideRenderer.Messaging;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.XboxLive.Avatars;
using Microsoft.XboxLive.Avatars.Internal;
using AvatarServices.Test.Common;
using AvatarServices.Test.UserCache;

namespace AvatarServices.Tests
{
    public partial class SSRTests
    {
        #region Frame / No Carryable
        [Description("When a gamerpic message with a negative frame number is sent, verify that an image is generated for frame 0.")]
        [TestMethod]
        public void SSRTests_GamerPic_Frame_Negative_AnimationGenericCelebration()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.Frame = -randomGenerator.Next(0, Int32.MaxValue);
            message.AnimationId = AvatarAssetsPack.AnimationGenericCelebration;

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with a zero frame number is sent, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Frame_Zero_AnimationGenericCelebration()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.Frame = 0;
            message.AnimationId = AvatarAssetsPack.AnimationGenericCelebration;

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with a positive frame number is sent, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Frame_Positive_AnimationGenericCelebration()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.Frame = 5;
            message.AnimationId = AvatarAssetsPack.AnimationGenericCelebration;

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with a very high frame number is sent, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Frame_HighNumber_AnimationGenericCelebration()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.Frame = Int32.MaxValue;
            message.AnimationId = AvatarAssetsPack.AnimationGenericCelebration;

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }
        #endregion

        #region Animation / No Carryable
        [Description("When a gamerpic message with a default (zero) animation id is sent, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_AnimationId_Default_AnimationGenericStand0()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.Frame = 5;
            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with an invalid animation id is sent, verify that no image is generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_AnimationId_Invalid()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.AnimationId = Guid.NewGuid();
            message.Frame = 5;
            SendMessage(message);

            AssertDiagnosticImageFound(false, false);
            CommonCode.ValidateEvents(EventIDs.SSR_ImageGenerationFailed, 1);
            CommonCode.ValidateEvents(EventIDs.SSR_MessageNotProcessed, 1);
        }

        [Description("When a gamerpic message for a female avatar with a female animation id is sent, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Avatar_Female_AnimationFemaleSadCry()
        {
            User user = UserCache.Instance.GetUsers(1, AvatarGender.Female)[0];
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.AnimationId = AvatarAssetsPack.AnimationFemaleSadCry;
            message.Frame = 5;
            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message for a female avatar with a male animation id is sent, verify that no image is generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Avatar_Female_AnimationMaleYawn()
        {
            User user = UserCache.Instance.GetUsers(1, AvatarGender.Female)[0];
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.AnimationId = AvatarAssetsPack.AnimationMaleShockedSurprised;
            message.Frame = 5;
            message.OffsetZ = SSRTests.GamerPicCameraBox.AvatarSSRGamerpicMaxZOffset;
            message.OffsetY = -0.05f;
            SendMessage(message);

            AssertDiagnosticImageFound(false, false);
            CommonCode.ValidateEvents(EventIDs.SSR_ImageGenerationFailed, 1);
        }

        [Description("When a gamerpic message for a female avatar with a generic animation id is sent, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Avatar_Female_AnimationGenericWave()
        {
            User user = UserCache.Instance.GetUsers(1, AvatarGender.Female)[0];
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.AnimationId = AvatarAssetsPack.AnimationGenericWave;
            message.Frame = 5;
            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message for a male avatar with a male animation id is sent, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Avatar_Male_AnimationMaleAngry()
        {
            User user = UserCache.Instance.GetUsers(1, AvatarGender.Male)[0];
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.AnimationId = AvatarAssetsPack.AnimationMaleAngry;
            message.Frame = 5;
            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message for a male avatar with a female animation id is sent, verify no image is generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Avatar_Male_AnimationFemaleYawn()
        {
            User user = UserCache.Instance.GetUsers(1, AvatarGender.Male)[0];
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.AnimationId = AvatarAssetsPack.AnimationFemaleIdleCheckNails;
            message.Frame = 5;
            message.OffsetZ = SSRTests.GamerPicCameraBox.AvatarSSRGamerpicMaxZOffset; 
            message.OffsetY = -0.05f;
            SendMessage(message);

            AssertDiagnosticImageFound(false, false);
            CommonCode.ValidateEvents(EventIDs.SSR_ImageGenerationFailed, 1);
        }

        [Description("When a gamerpic message for a male avatar with a generic animation id is sent, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Avatar_Male_AnimationGenericCelebration()
        {
            User user = UserCache.Instance.GetUsers(1, AvatarGender.Male)[0];
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.AnimationId = AvatarAssetsPack.AnimationGenericCelebration;
            message.Frame = 5;
            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }
        #endregion

        #region Carryable
        [Description("When a gamerpic message with carryable is sent for a user with no carryable in his manifest, verify that no image is generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Carryable_Invalid()
        {
            User user = UserCache.Instance.CreateUsers(1, AvatarGender.Both, 0, 0)[0];
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user.Xuid, 1);
            message.Frame = Int32.MinValue;
            message.UsePropAnimation = true;

            SendMessage(message);

            AssertDiagnosticImageFound(false, false);
            CommonCode.ValidateEvents(EventIDs.SSR_ImageGenerationFailed, 1);
        }

        [Description("When a gamerpic message without carryable flag is sent for a user with carryable in his manifest, verify that an image is generated with generic stand animation.")]
        [TestMethod]
        public void SSRTests_GamerPic_Carryable_NotUsed()
        {
            User user = UserCache.Instance.GetUsersWithoutManifests();
            ResetAllImages(user.Xuid);

            AvatarManifest manifest = GetManifestWithCarryable(AvatarGender.Both);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user.Xuid, 1);
            message.AvatarManifest = manifest.SaveToBinary();
            message.Frame = 0;
            message.UsePropAnimation = false;

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with carryable and a negative frame number is sent, verify that an image is generated at frame 0.")]
        [TestMethod]
        public void SSRTests_GamerPic_Carryable_Frame_Min()
        {
            User user = UserCache.Instance.GetUsersWithoutManifests();
            ResetAllImages(user.Xuid);

            AvatarManifest manifest = GetManifestWithCarryable(AvatarGender.Both);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user.Xuid, 1);
            message.AvatarManifest = manifest.SaveToBinary();
            message.Frame = Int32.MinValue;
            message.UsePropAnimation = true;

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with carryable and a zero frame number is sent, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Carryable_Frame_Zero()
        {
            User user = UserCache.Instance.GetUsersWithoutManifests();
            ResetAllImages(user.Xuid);

            AvatarManifest manifest = GetManifestWithCarryable(AvatarGender.Both);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user.Xuid, 1);
            message.AvatarManifest = manifest.SaveToBinary();
            message.Frame = 0;
            message.UsePropAnimation = true;

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with carryable a valid, positive frame number is sent, verify that the images are generated at frame 0.")]
        [TestMethod]
        public void SSRTests_GamerPic_Carryable_Frame_Valid()
        {
            User user = UserCache.Instance.GetUsersWithoutManifests();
            ResetAllImages(user.Xuid);

            AvatarManifest manifest = GetManifestWithCarryable(AvatarGender.Both);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user.Xuid, 1);
            message.AvatarManifest = manifest.SaveToBinary();
            message.Frame = 20;
            message.UsePropAnimation = true;

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with carryable and a very high frame number is sent, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Carryable_Frame_Max()
        {
            User user = UserCache.Instance.GetUsersWithoutManifests();
            ResetAllImages(user.Xuid);

            AvatarManifest manifest = GetManifestWithCarryable(AvatarGender.Both);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user.Xuid, 1);
            message.AvatarManifest = manifest.SaveToBinary();
            message.Frame = Int32.MaxValue;
            message.UsePropAnimation = true;

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\SSR\SSRTests_GamerPic_Camera.cs ===
﻿using System;
using Avatar.Services.ServerSideRenderer.Messaging;
using AvatarServices.Test.Common;
using AvatarServices.Test.UserCache;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace AvatarServices.Tests
{
    public partial class SSRTests
    {
        #region Gamerpic Message Variations - Field of view & Camera
        [Description("When a gamerpic message with a negative field of view is sent, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_FieldOfView_Negative()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.FieldOfView = -10;

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with a zero field of view is sent, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_FieldOfView_Zero()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.FieldOfView = 0;

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with a positive field of view is sent, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_FieldOfView_Positive()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.FieldOfView = 5;

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with a random camera settings is sent, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Camera_Random()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            
            // TODO need a random number generator for floats.
            message.OffsetX = GetRandomSingle();
            message.OffsetY = GetRandomSingle();
            message.OffsetZ = GetRandomSingle();

            message.RotationX = GetRandomSingle();
            message.RotationY = GetRandomSingle();
            message.RotationZ = GetRandomSingle();

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with max values for camera settings is sent, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Camera_Max()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);

            message.OffsetX = Single.MaxValue;
            message.OffsetY = Single.MaxValue;
            message.OffsetZ = Single.MaxValue;

            message.RotationX = Single.MaxValue;
            message.RotationY = Single.MaxValue;
            message.RotationZ = Single.MaxValue;

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with min values for camera settings is sent, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Camera_Min()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);

            message.OffsetX = Single.MinValue;
            message.OffsetY = Single.MinValue;
            message.OffsetZ = Single.MinValue;

            message.RotationX = Single.MinValue;
            message.RotationY = Single.MinValue;
            message.RotationZ = Single.MinValue;

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with no custom camera settings, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Camera_Zero()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("A gamerpic image with camera on top of the avatar.")]
        [TestMethod]
        public void SSRTests_GamerPic_Camera_Top()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.RotationX = (float)(Math.PI / 2);
            //message.OffsetY = 1f;

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("A gamerpic image with camera to the left of the avatar.")]
        [TestMethod]
        public void SSRTests_GamerPic_Camera_Left()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.RotationY = -(float)(Math.PI / 2);

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("A gamerpic image with camera to the right of the avatar.")]
        [TestMethod]
        public void SSRTests_GamerPic_Camera_Right()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.RotationY = (float)(Math.PI / 2);

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("A gamerpic image with camera to back left of the avatar.")]
        [TestMethod]
        public void SSRTests_GamerPic_Camera_Back()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.RotationY = (float)(Math.PI);

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        #region Camera Offset
        [Description("When a gamerpic message with a positive x offset, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Camera_OffsetX_Positive()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.OffsetX = 10;

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with a positive y offset, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Camera_OffsetY_Positive()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.OffsetY = 10;

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with a positive z offset, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Camera_OffsetZ_Positive()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.OffsetZ = 10;

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with a negative x offset, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Camera_OffsetX_Negative()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.OffsetX = -10; 

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with a negative y offset, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Camera_OffsetY_Negative()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.OffsetY = -10;

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with a negative z offset, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Camera_OffsetZ_Negative()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.OffsetZ = -10;

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }
        #endregion

        #region Camera Rotation
        [Description("When a gamerpic message with a positive x rotation, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Camera_RotationX_Positive()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.RotationX = (float)(Math.PI / 4);

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with a positive y rotation, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Camera_RotationY_Positive()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.RotationY = (float)(Math.PI / 4);

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with a positive z rotation, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Camera_RotationZ_Positive()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.RotationZ = (float)(Math.PI / 4);

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with a positive x rotation + 2 pi, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Camera_RotationX_PositivePlus()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.RotationX = (float)(Math.PI / 4 + 2 * Math.PI);

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with a positive y rotation + 2 pi, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Camera_RotationY_PositivePlus()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.RotationY = (float)(Math.PI / 4 + 2 * Math.PI);

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with a positive z rotation + 2 pi, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Camera_RotationZ_PositivePlus()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.RotationZ = (float)(Math.PI / 4 + 2 * Math.PI);

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with a negative x rotation, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Camera_RotationX_Negative()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.RotationX = -(float)(Math.PI / 4);

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with a negative y rotation, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Camera_RotationY_Negative()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.RotationY = -(float)(Math.PI / 4);

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with a negative z rotation, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Camera_RotationZ_Negative()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user);
            message.RotationZ = -(float)(Math.PI / 4);

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }
        #endregion
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\SSR\SSRTests_User.cs ===
﻿using Avatar.Services.ServerSideRenderer.Messaging;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.XboxLive.Avatars;
using Microsoft.XboxLive.Avatars.Internal;
using AvatarServices.Test.Common;
using AvatarServices.Test.UserCache;

namespace AvatarServices.Tests
{
    public partial class SSRTests
    {
        #region User Variations
        [Description("When an avatar pic message for a user with no avatar is sent, verify that no image is generated.")]
        [TestMethod]
        public void SSRTests_AvatarPics_NoAvatar()
        {
            User user = UserCache.Instance.GetUsersWithoutManifests();
            ResetAllImages(user.Xuid);

            GenerateBodyShotMessage bsMessage = CreateDiagnosticBodyShotMessage(user);
            GenerateGamerPictureMessage gpMessage = CreateCenteredDiagnosticGamerPicMessage(user);

            SendMessage(bsMessage);
            SendMessage(gpMessage);

            AssertDiagnosticImageFound(false, false);
            CommonCode.ValidateMultipleEvents(new EventIDs[] { EventIDs.SSR_ManifestNotFound, EventIDs.SSR_ImageGenerationFailed }, new int[] { 2, 2 });
        }

        [Description("When an avatar pic message for a male with only stock assets is sent, verify that an image is generated.")]
        [TestMethod]
        public void SSRTests_AvatarPics_Male_StockOnly()
        {
            User user = UserCache.Instance.GetUsers(1, AvatarGender.Male, 0, 0)[0];
            ResetAllImages(user.Xuid);

            GenerateBodyShotMessage bsMessage = CreateDiagnosticBodyShotMessage(user);
            GenerateGamerPictureMessage gpMessage = CreateCenteredDiagnosticGamerPicMessage(user);

            SendMessage(bsMessage);
            SendMessage(gpMessage);

            AssertDiagnosticImageFound(true, true);
        }

        [Description("When an avatar pic message for a female with only stock assets is sent, verify that an image is generated.")]
        [TestMethod]
        public void SSRTests_AvatarPics_Female_StockOnly()
        {
            User user = UserCache.Instance.GetUsers(1, AvatarGender.Female, 0, 0)[0];
            ResetAllImages(user.Xuid);

            GenerateBodyShotMessage bsMessage = CreateDiagnosticBodyShotMessage(user);
            GenerateGamerPictureMessage gpMessage = CreateCenteredDiagnosticGamerPicMessage(user);

            SendMessage(bsMessage);
            SendMessage(gpMessage);

            AssertDiagnosticImageFound(true, true);
        }

        [Description("When an avatar pic message for a male with a costume is sent, verify that an image is generated.")]
        [TestMethod]
        public void SSRTests_AvatarPics_Male_Costume()
        {
            User user = UserCache.Instance.GetUsersWithComponent(1, AvatarGender.Male, ComponentCategories.Costume)[0];
            ResetAllImages(user.Xuid);

            GenerateBodyShotMessage bsMessage = CreateDiagnosticBodyShotMessage(user);
            GenerateGamerPictureMessage gpMessage = CreateCenteredDiagnosticGamerPicMessage(user);

            SendMessage(bsMessage);
            SendMessage(gpMessage);

            AssertDiagnosticImageFound(true, true);
        }

        [TestMethod]
        [Description("When an avatar pic message for a female with a costume is sent, verify that an image is generated.")]
        public void SSRTests_AvatarPics_Female_Costume()
        {
            User user = UserCache.Instance.GetUsersWithComponent(1, AvatarGender.Female, ComponentCategories.Costume)[0];
            ResetAllImages(user.Xuid);

            GenerateBodyShotMessage bsMessage = CreateDiagnosticBodyShotMessage(user);
            GenerateGamerPictureMessage gpMessage = CreateCenteredDiagnosticGamerPicMessage(user);

            SendMessage(bsMessage);
            SendMessage(gpMessage);

            AssertDiagnosticImageFound(true, true);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\SSR\SSRTests_Common.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Xml;
using System.Xml.Serialization;
using Avatar.Services.ManifestWrite.Library;
using Avatar.Services.ServerSideRenderer.Messaging;
using AvatarServices.Test.Common;
using AvatarServices.Test.UserCache;
using Leet.Core.TestService.Client.DiagnosticDatabase;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.XboxLive.Avatars;
using Microsoft.XboxLive.Avatars.Internal;
using LiveN.Test.Avatar;

namespace AvatarServices.Tests
{
    [TestClass]
    public partial class SSRTests
    {
        public SSRTests()
        {
            string stockUri = "http://download.xboxlive.com/content/584d07d1/{0}.bin";
            string nonStockUri = "http://download.xboxlive.com/content/{0}/avataritems/{1}.bin";

            diagnosticService = new DiagnosticDatabaseTestService(Config.Environment.CoreTestServiceBaseUrl);

            assetManager = new AssetDataManager();
            assetManager.AddAssetProvider(new AssetUrlDataProvider(stockUri, nonStockUri));
        }

        #region Constructor/setup/cleanup
        [TestInitialize]
        public void MyTestInitialize()
        {
            RestGamerPicImages();
        }

        [TestCleanup]
        public void MyTestCleanUp()
        {
            // Write out any of the image that may have been used within the last test
            WriteImages(this.TestContext.TestName);

            CommonCode.ValidateEvents();
        }
        #endregion

        #region Properties and fields
        /// <summary>
        /// Gets or sets the test context which provides
        /// information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get;
            set;
        }

        private const ulong invalidXuid = 012345;

        /// <summary>
        /// Number of seconds to wait before giving up
        /// </summary>
        private const int TIMEOUT = 30;
        private static Random randomGenerator = new Random();
        private const string BODYSHOT_FILENAME = "avatar-body.png";
        private const string LARGE_GAMERPIC_FILENAME = "avatarpic-l.png";
        private const string SMALL_GAMERPIC_FILENAME = "avatarpic-s.png";
        private DiagnosticDatabaseTestService diagnosticService;
        private AssetDataManager assetManager;
        private int poseMax = 20;
        private const string xboxTile = "fffe07d10002000100010001\0";

        public static byte[] bodyShotDiagnosticImage;
        public static byte[] largeGamerPicDiagnosticImage;
        public static byte[] smallGamerPicDiagnosticImage;
        public static byte[] bodyShotStorageImage;
        public static byte[] largeGamerPicStorageImage;
        public static byte[] smallGamerPicStorageImage;

        /// <summary>
        /// Gamer Pic Camera Box restrictions
        /// 
        /// TODO: Values should be taken directly from the config file
        /// $DEPOT$\LEST_MAIN_DEV\product\SharedSource\Configuration\ConfigItems.xml
        /// </summary>
        public struct GamerPicCameraBox
        {
            public const float AvatarSSRGamerpicMaxXOffset = 0.35f;
            public const float AvatarSSRGamerpicMaxYOffset = 0.15f;
            public const float AvatarSSRGamerpicMaxZOffset = 2.4f;
            public const float AvatarSSRGamerpicMinXOffset = -0.28f;
            public const float AvatarSSRGamerpicMinYOffset = -0.38f;
            public const float AvatarSSRGamerpicMinZOffset = 2.4f;
            public const float AvatarSSRGamerpicMaxFieldOfView = 0.196870044f;
            public const float AvatarSSRGamerpicMinFieldOfView = 0.0593898855f;
        }

        #endregion

        /// <summary>
        /// Sets up the defaults for the GamerPic images
        /// </summary>
        public static void RestGamerPicImages()
        {
            try
            {
                CommonCode.SSRTestService.DeleteImages(Config.Environment.SsrMachineName);
            }
            catch (Exception ex)
            {
                Assert.Inconclusive("MyTestInitialize: There was an error deleting images: " + ex.ToString());
            }

            bodyShotDiagnosticImage = new byte[0];
            largeGamerPicDiagnosticImage = new byte[0];
            smallGamerPicDiagnosticImage = new byte[0];
            bodyShotStorageImage = new byte[0];
            largeGamerPicStorageImage = new byte[0];
            smallGamerPicStorageImage = new byte[0];

            CommonCode.TestStartTime = DateTime.Now;
        }

        #region Send Message
        public static void SendMessage(BaseMessage message)
        {
            SendMessage(message, null);
        }

        public static void SendMessage(BaseMessage message, string messageName)
        {
            if (string.IsNullOrEmpty(messageName))
            {
                Trace.WriteLine(string.Format("TRACE: Sending SSR Test Service message: {0}", GetMessageXml(message)));
                CommonCode.SSRTestService.SendMessage(message);
            }
            else
            {
                Trace.WriteLine(string.Format("TRACE: Sending SSR Test Service message with MessageName={1}: {0}", GetMessageXml(message), messageName));
                CommonCode.SSRTestService.SendMessageWithName(message, messageName);
            }
        }

        public static void SendBodyShotMessage(BaseMessage message)
        {
            Trace.WriteLine(string.Format("TRACE: Sending SSR Test Service BodyShot message: {0}", GetMessageXml(message)));
            CommonCode.SSRTestService.SendBodyShotMessage(message);
        }

        public static void SendGamerPicMessage(BaseMessage message)
        {
            Trace.WriteLine(string.Format("TRACE: Sending SSR Test Service GamerPic message: {0}", GetMessageXml(message)));
            CommonCode.SSRTestService.SendGamerPicMessage(message);
        }
        #endregion

        #region Validate Images

        public void ValidateImages(ulong xuid, bool findBodyShotImage, bool findGamerPicImage)
        {
            AssertDiagnosticImageFound(findBodyShotImage, findGamerPicImage);
            AssertStorageImageFound(xuid, findBodyShotImage, findGamerPicImage); // Disabling since we're hitting storage cache
            AssertCompareImages();
        }

        private void AssertStorageImageFound(ulong xuid, bool findBodyShotImage, bool findGamerPicImage)
        {
            bool storageImagePass = true;
            Stopwatch stopWatch = Stopwatch.StartNew();

            Trace.WriteLine("TRACE: Looking for storage images.");

            while (stopWatch.Elapsed.TotalSeconds < TIMEOUT)
            {
                bodyShotStorageImage = CommonCode.SSRTestService.GetBodyshotStorageImage(xuid);
                largeGamerPicStorageImage = CommonCode.SSRTestService.GetLargeGamerPicStorageImage(xuid);
                smallGamerPicStorageImage = CommonCode.SSRTestService.GetSmallGamerPicStorageImage(xuid);

                if (!findBodyShotImage && bodyShotStorageImage.Length > 0)
                    break;
                else if (!findGamerPicImage && largeGamerPicStorageImage.Length > 0)
                    break;
                else if (findBodyShotImage && !findGamerPicImage && bodyShotStorageImage.Length > 0)
                    break;
                else if (findGamerPicImage && !findBodyShotImage && largeGamerPicStorageImage.Length > 0 && smallGamerPicStorageImage.Length > 0)
                    break;
                else if (findBodyShotImage && findGamerPicImage &&
                    bodyShotStorageImage.Length > 0 && largeGamerPicStorageImage.Length > 0 && smallGamerPicStorageImage.Length > 0)
                    break;
                else
                    Thread.Sleep(100);
            }

            string errorMsg = "FAILED: Expected storage {0} to be {1}, but {2}.";
            if (findBodyShotImage != bodyShotStorageImage.Length > 0)
            {
                storageImagePass = false;
                Trace.WriteLine(string.Format(errorMsg, "bodyshot image", findBodyShotImage ? "found" : "not found", findBodyShotImage ? "not found" : "found"));
            }
            if (findGamerPicImage != largeGamerPicStorageImage.Length > 0)
            {
                storageImagePass = false;
                Trace.WriteLine(string.Format(errorMsg, "large gamerpic image", findGamerPicImage ? "found" : "not found", findGamerPicImage ? "not found" : "found"));
            }
            if (findGamerPicImage != smallGamerPicStorageImage.Length > 0)
            {
                storageImagePass = false;
                Trace.WriteLine(string.Format(errorMsg, "small gamerpic image", findGamerPicImage ? "found" : "not found", findGamerPicImage ? "not found" : "found"));
            }

            if (!storageImagePass)
            {
                Assert.Fail("Failed to verify the storage via the SSRTest Service.");
            }
        }

        /// <summary>
        /// Pull the Diagnostic image via the SSRTest Service to ensure it was produced
        /// </summary>
        public static void AssertDiagnosticImageFound(bool findBodyShotImage, bool findGamerPicImage)
        {
            bool diagnosticImagePass = true;
            Stopwatch stopWatch = Stopwatch.StartNew();

            Trace.WriteLine("TRACE: Looking for diagnostic images via the SSR Test Service. SSR Machine Name: '" + Config.Environment.SsrMachineName + "'");

            while (stopWatch.Elapsed.TotalSeconds < TIMEOUT)
            {
                bodyShotDiagnosticImage = CommonCode.SSRTestService.GetDiagnosticImage(BODYSHOT_FILENAME, Config.Environment.SsrMachineName);
                largeGamerPicDiagnosticImage = CommonCode.SSRTestService.GetDiagnosticImage(LARGE_GAMERPIC_FILENAME, Config.Environment.SsrMachineName);
                smallGamerPicDiagnosticImage = CommonCode.SSRTestService.GetDiagnosticImage(SMALL_GAMERPIC_FILENAME, Config.Environment.SsrMachineName);

                if (!findBodyShotImage && bodyShotDiagnosticImage.Length > 0)
                {
                    Trace.WriteLine("TRACE: Found bodyShotDiagnosticImage with size: " + bodyShotDiagnosticImage.Length.ToString());

                    break;
                }
                else if (!findGamerPicImage && largeGamerPicDiagnosticImage.Length > 0)
                {
                    Trace.WriteLine("TRACE: Found largeGamerPicDiagnosticImage with size: " + largeGamerPicDiagnosticImage.Length.ToString());

                    break;
                }
                else if (findBodyShotImage && !findGamerPicImage && bodyShotDiagnosticImage.Length > 0)
                {
                    Trace.WriteLine("TRACE: Found bodyShotDiagnosticImage with size: " + bodyShotDiagnosticImage.Length.ToString());

                    break;
                }
                else if (findGamerPicImage && !findBodyShotImage && largeGamerPicDiagnosticImage.Length > 0 && smallGamerPicDiagnosticImage.Length > 0)
                {
                    Trace.WriteLine("TRACE: Found largeGamerPicDiagnosticImage with size: " + largeGamerPicDiagnosticImage.Length.ToString());
                    Trace.WriteLine("TRACE: Found smallGamerPicDiagnosticImage with size: " + smallGamerPicDiagnosticImage.Length.ToString());

                    break;
                }
                else if (findBodyShotImage &&
                          findGamerPicImage &&
                          (bodyShotDiagnosticImage.Length > 0) &&
                          (largeGamerPicDiagnosticImage.Length > 0) &&
                          (smallGamerPicDiagnosticImage.Length > 0)
                        )
                {
                    break;
                }

                Trace.WriteLine("TRACE: Waiting for SSR to push the images to the share. SSRTestService working properly. Elapsed secs: " + stopWatch.Elapsed.TotalSeconds);

                // Did not find the expect image. Wait a little bit and try again.
                Thread.Sleep(100);
            }

            string errorMsg = "FAILED: Expected diagnostic {0} to be {1}, but {2}.";
            if (findBodyShotImage != (bodyShotDiagnosticImage.Length > 0))
            {
                diagnosticImagePass = false;
                Trace.WriteLine(string.Format(errorMsg, "bodyshot image", findBodyShotImage ? "found" : "it was not found", findBodyShotImage ? "not found" : "found"));
            }

            if (findGamerPicImage != (smallGamerPicDiagnosticImage.Length > 0))
            {
                diagnosticImagePass = false;
                Trace.WriteLine(string.Format(errorMsg, "small gamerpic image", findGamerPicImage ? "found" : "not found", findGamerPicImage ? "not found" : "found"));
            }

            if (findGamerPicImage != (largeGamerPicDiagnosticImage.Length > 0))
            {
                diagnosticImagePass = false;
                Trace.WriteLine(string.Format(errorMsg, "large gamerpic image", findGamerPicImage ? "found" : "not found", findGamerPicImage ? "not found" : "found"));
            }

            if (!diagnosticImagePass)
            {
                Assert.Fail("Failed to retrive the appropriate diagnostic image via the SSRTest Service.");
            }
        }

        private void AssertCompareImages()
        {
            bool compareImagePass = true;

            if (!AreEqual(bodyShotDiagnosticImage, bodyShotStorageImage))
            {
                compareImagePass = false;
                Trace.WriteLine("FAILED: Storage and diagnostic bodyshot images differ.");
            }
            if (!AreEqual(largeGamerPicDiagnosticImage, largeGamerPicStorageImage))
            {
                compareImagePass = false;
                Trace.WriteLine("FAILED: Storage and diagnostic large gamerpic images differ.");
            }
            if (!AreEqual(smallGamerPicDiagnosticImage, smallGamerPicStorageImage))
            {
                compareImagePass = false;
                Trace.WriteLine("FAILED: Storage and diagnostic small gamerpic images differ.");
            }

            if (!compareImagePass)
            {
                Assert.Fail("Storage vers diagnotis image comparison failed.");
            }
        }

        private bool AreEqual(byte[] array1, byte[] array2)
        {
            if (array1.Length != array2.Length)
            {
                return false;
            }

            for (int i = 0; i < array1.Length; i++)
            {
                if (array1[i] != array2[i])
                {
                    return false;
                }
            }

            return true;
        }

        #endregion

        #region Verify Images

        /// <summary>
        /// Verify the downloaded Diagnostic Images vers the images stored within the Assembly
        /// </summary>
        /// <param name="assembly">Assembly that contains the images. Tipically Assembly.GetExecutingAssembly()</param>
        /// <param name="assemblyRoot">Location within the assembly the images can be found. Example: "AvatarServices.Tests.ManifestReadTests.BlackListFiltering."</param>
        /// <param name="context">Current Test Context</param>
        public static void VerifyDiagnosticImageVersSaved(Assembly assembly, string assemblyRoot, TestContext context)
        {
            if (bodyShotDiagnosticImage.Length > 0)
            {
                VerifyDiagnosticImageVersSaved(assembly, assemblyRoot + context.TestName + "_" + BODYSHOT_FILENAME, bodyShotDiagnosticImage);
            }

            if (largeGamerPicDiagnosticImage.Length > 0)
            {
                VerifyDiagnosticImageVersSaved(assembly, assemblyRoot + context.TestName + "_" + LARGE_GAMERPIC_FILENAME, largeGamerPicDiagnosticImage);
            }

            if (smallGamerPicDiagnosticImage.Length > 0)
            {
                VerifyDiagnosticImageVersSaved(assembly, assemblyRoot + context.TestName + "_" + SMALL_GAMERPIC_FILENAME, smallGamerPicDiagnosticImage);
            }
        }

        /// <summary>
        /// Verify the downloaded Diagnostic Images vers the images stored within the Assembly
        /// </summary>
        /// <param name="assembly">Assembly that contains the images. Tipically Assembly.GetExecutingAssembly()</param>
        /// <param name="AssemblyLocation">Location of the image within the assembly</param>
        /// <param name="image">Image to compare against</param>
        public static void VerifyDiagnosticImageVersSaved(Assembly assembly, string AssemblyLocation, byte[] image)
        {
            Stream myStream;
            byte[] assemblyImage;

            if (string.IsNullOrEmpty(AssemblyLocation))
            {
                throw new ArgumentNullException("AssemblyLocation");
            }

            if (image == null)
            {
                throw new ArgumentNullException("image");
            }

            Trace.WriteLine("TRACE: Verifying Diagnostic Image Vers Embedded Image located at: '" + AssemblyLocation + "'");

            using (myStream = assembly.GetManifestResourceStream(AssemblyLocation))
            {
                if (myStream == null)
                {
                    throw new Exception("Could not find Assembly Image '" + AssemblyLocation + "'. Verify the image is present and that the Image's Property->Build Action = Embedded Resource");
                }

                assemblyImage = new byte[myStream.Length];
                myStream.Read(assemblyImage, 0, (int)myStream.Length);

                if (!CommonCode.CompareImages(assemblyImage, image))
                {
                    Assert.Fail("Downloaded Diagnostic Image does not match exactly with the one found within the project '" + assemblyImage + "'. \r\nPOSSABLE ISSUE: Slight change in the image generation code has just occured. Verify Diagnostic Image still appear simular to the one within the project. Then update the the project Image.");
                }
            }
        }

        #endregion Verify Images

        #region Write Images

        /// <summary>
        /// Write out the images so they can be manually viewed and verified
        /// </summary>
        public static void WriteImages(string testName)
        {
            WriteImages(testName, -1);
        }

        /// <summary>
        /// Write out the images so they can be manually viewed and verified
        /// </summary>
        public static void WriteImages(string testName, int index)
        {
            string filePath;

            if (index >= 0)
            {
                filePath = Path.Combine(Directory.GetCurrentDirectory(), string.Format("{0}_{1}_", testName, index));
            }
            else
            {
                filePath = Path.Combine(Directory.GetCurrentDirectory(), string.Format("{0}_", testName));
            }

            if (bodyShotDiagnosticImage.Length > 0)
            {
                WriteImage(filePath + BODYSHOT_FILENAME, ref bodyShotDiagnosticImage);
            }

            if (largeGamerPicDiagnosticImage.Length > 0)
            {
                WriteImage(filePath + LARGE_GAMERPIC_FILENAME, ref largeGamerPicDiagnosticImage);
            }

            if (smallGamerPicDiagnosticImage.Length > 0)
            {
                WriteImage(filePath + SMALL_GAMERPIC_FILENAME, ref smallGamerPicDiagnosticImage);
            }
        }

        /// <summary>
        /// Write out the images so they can be manually viewed and verified
        /// </summary>
        public static void WriteImage(string filePath, ref byte[] image)
        {
            Trace.WriteLine("TRACE: Image saved at '" + filePath + "'. Image size: " + image.Length.ToString());

            try
            {
                using (FileStream fs = File.Create(filePath))
                {
                    fs.Write(image, 0, image.Length);
                    fs.Flush();
                    fs.Close();
                }
            }
            catch (Exception exc)
            {
                // As this method is not directly used to test anything. Exceptions should be ignored.
                Trace.TraceWarning("WARNING: Failed to create image file at path: '" + filePath + "' Exception: \r\n" + exc.ToString());
            }
        }
        #endregion

        #region Reset Images
        public static void ResetAllImages(ulong xuid)
        {
            // TODO: This needs to find a better home. As the creation of the gamers Tile, Gamer Profile Pic, is required. So all users should have a default one.
            // Adding this becuase all tests need to have there Tile set or else they will fail. Bug 7214
            SetGamerTile(xuid, true);

            // TODO Comment out the below. Need to gigure out if this is actually need or can you remove it?
            //Thread.Sleep(5000); // Sleep for 5 seconds for manifest changes to clear the cache.

            //Trace.WriteLine(string.Format("TRACE: Resetting all images for xuid {0} in Storage.", xuid));
            //ssrService.ResetAllImages(xuid);
        }
        #endregion

        #region Read/Sync GamerTile Settings
        private static void ValidateGamerTile(ulong xuid, bool isAvatar)
        {
            // Give 10 seconds for settings calls to finish
            Thread.Sleep(10 * 1000);
            string gamerTile = CommonCode.SSRTestService.ReadGamercardTileSetting(xuid);

            Assert.AreEqual<bool>(isAvatar, gamerTile.Substring(0, 4) == "0001", string.Format("Failed to {0}get avatar picture", isAvatar ? "" : "not "));
        }

        private static void SetGamerTile(ulong xuid, bool isAvatar)
        {
            string tileString;
            if (isAvatar)
            {
                const string AVATAR_TITLE_ID = "fffe0854";

                // Create the setting value as a string
                Random rand = new Random(DateTime.Now.Millisecond);
                string random1 = rand.Next(9999).ToString("X4");
                string random2 = rand.Next(9999).ToString("X4");

                tileString = String.Format("{0}0001{1}0001{2}\0", AVATAR_TITLE_ID, random1, random2);
            }
            else
            {
                tileString = xboxTile;
            }

            CommonCode.SSRTestService.SetGamercardTileSetting(xuid, tileString);
        }
        #endregion

        #region Create Message
        public static GenerateBodyShotMessage CreateDiagnosticBodyShotMessage(int version)
        {
            GenerateBodyShotMessage message = GenerateBodyShotMessageBase();

            message.Version = GetDiagnosticVersion(version);

            return message;
        }

        public static GenerateBodyShotMessage CreateDiagnosticBodyShotMessage(ulong xuid, int version)
        {
            GenerateBodyShotMessage message = GenerateBodyShotMessageBase();

            message.XUID = xuid;
            message.Version = GetDiagnosticVersion(version);

            return message;
        }

        public static GenerateBodyShotMessage CreateDiagnosticBodyShotMessage(User user)
        {
            GenerateBodyShotMessage message = GenerateBodyShotMessageBase();

            message.XUID = user.Xuid;

            return message;
        }

        public static GenerateBodyShotMessage CreateDiagnosticBodyShotMessage(User user, byte[] manifest)
        {
            GenerateBodyShotMessage message = GenerateBodyShotMessageBase();

            message.XUID = user.Xuid;
            message.AvatarManifest = manifest;

            return message;
        }

        public static GenerateBodyShotMessage CreateBodyShotMessage(User user)
        {
            GenerateBodyShotMessage message = GenerateBodyShotMessageBase();

            message.XUID = user.Xuid;
            message.Version = 1;

            return message;
        }

        public static GenerateBodyShotMessage GenerateBodyShotMessageBase()
        {
            GenerateBodyShotMessage message = new GenerateBodyShotMessage();

            message.Version = GetDiagnosticVersion(1);
            message.PickRandomPose = false;
            message.PoseIndex = 0;

            return message;
        }

        public static GenerateGamerPictureMessage CreateDiagnosticGamerPicMessage(int version)
        {
            GenerateGamerPictureMessage GamerPictureMessage = GenerateGamerPictureMessageBase();

            GamerPictureMessage.Version = GetDiagnosticVersion(version);

            return GamerPictureMessage;
        }

        public static GenerateGamerPictureMessage CreateDiagnosticGamerPicMessage(ulong xuid, int version)
        {
            GenerateGamerPictureMessage GamerPictureMessage = GenerateGamerPictureMessageBase();

            GamerPictureMessage.XUID = xuid;
            GamerPictureMessage.Version = GetDiagnosticVersion(version);

            return GamerPictureMessage;
        }

        public static GenerateGamerPictureMessage CreateDiagnosticGamerPicMessage(User user)
        {
            GenerateGamerPictureMessage GamerPictureMessage = GenerateGamerPictureMessageBase();

            GamerPictureMessage.XUID = user.Xuid;
            GamerPictureMessage.Version = GetDiagnosticVersion(1);

            return GamerPictureMessage;
        }

        public static GenerateGamerPictureMessage CreateDiagnosticGamerPicMessage(User user, byte[] manifest)
        {
            GenerateGamerPictureMessage GamerPictureMessage = GenerateGamerPictureMessageBase();

            GamerPictureMessage.XUID = user.Xuid;
            GamerPictureMessage.AvatarManifest = manifest;
            GamerPictureMessage.Version = GetDiagnosticVersion(1);

            return GamerPictureMessage;
        }

        public static GenerateGamerPictureMessage CreateDiagnosticGamerPicMessage(User user, bool useCarryableAnimation, int frame)
        {
            GenerateGamerPictureMessage GamerPictureMessage = GenerateGamerPictureMessageBase();

            GamerPictureMessage.XUID = user.Xuid;
            GamerPictureMessage.Frame = frame;
            GamerPictureMessage.UsePropAnimation = useCarryableAnimation;
            GamerPictureMessage.Version = GetDiagnosticVersion(1);

            return GamerPictureMessage;
        }

        public static UpdateGamerPicRequest GenerateUpdateGamerPicRequest()
        {
            UpdateGamerPicRequest message = new UpdateGamerPicRequest();

            // Using the same defaults as the CreateSSRGamerpicMessage: $DEPOT$\LEST_MAIN_DEV\product\Source\AvatarServices\Avatar.Services.ManifestWrite.Library\ManifestUpdater.cs
            message.FieldOfView = SSRTests.GamerPicCameraBox.AvatarSSRGamerpicMaxFieldOfView;
            message.AnimationId = new Guid("00400000-0003-0003-c1c8-f109a19cb2e0");  // the basic standing pose

            // Center the gamerpic on the nose for a basic head shot
            message.OffsetX = 0;
            message.OffsetY = -0.06f;
            message.OffsetZ = SSRTests.GamerPicCameraBox.AvatarSSRGamerpicMaxZOffset;
            message.RotationY = 0.03f;
            message.FieldOfView = 0.155f;
            message.FocalJoint = CommonCode.AVATAR_HEAD_JOINT;

            return message;
        }

        public static GenerateGamerPictureMessage CreateGamerPicMessage(User user)
        {
            GenerateGamerPictureMessage GamerPictureMessage = GenerateGamerPictureMessageBase();

            GamerPictureMessage.XUID = user.Xuid;
            GamerPictureMessage.Version = 1;

            return GamerPictureMessage;
        }

        public static GenerateGamerPictureMessage CreateCenteredDiagnosticGamerPicMessage(User user)
        {
            GenerateGamerPictureMessage message = GenerateGamerPictureMessageBase();

            message.XUID = user.Xuid;
            message.Version = GetDiagnosticVersion(message.Version);

            return message;
        }

        public static GenerateGamerPictureMessage CreateCenteredDiagnosticGamerPicMessage(User user, byte[] manifest)
        {
            GenerateGamerPictureMessage message = CreateCenteredDiagnosticGamerPicMessage(user);
            message.AvatarManifest = manifest;
            return message;
        }

        /// <summary>
        /// Generate a default Gamer Picture Message with all the default values set to valid values
        /// </summary>
        private static GenerateGamerPictureMessage GenerateGamerPictureMessageBase()
        {
            GenerateGamerPictureMessage message = new GenerateGamerPictureMessage();

            message.Version = 1;

            // Using the same defaults as the CreateSSRGamerpicMessage: $DEPOT$\LEST_MAIN_DEV\product\Source\AvatarServices\Avatar.Services.ManifestWrite.Library\ManifestUpdater.cs
            message.UsePropAnimation = false;
            message.SaveGamerpicToProfile = false;
            message.AnimationId = new Guid("00400000-0003-0003-c1c8-f109a19cb2e0");  // the basic standing pose

            // Center the gamerpic on the nose for a basic head shot
            message.OffsetX = 0;
            message.OffsetY = -0.06f;
            message.OffsetZ = SSRTests.GamerPicCameraBox.AvatarSSRGamerpicMaxZOffset; 
            message.RotationY = 0.03f;
            message.FieldOfView = 0.155f;
            message.FocalJoint = CommonCode.AVATAR_HEAD_JOINT;

            return message;
        }
        #endregion

        #region Common User Methods
        private AvatarManifest GetManifestWithCarryable(AvatarGender gender)
        {
            AvatarManifest manifest = AvatarManifest.CreateRandom(assetManager, gender, 1)[0];

            BaseAsset asset = StockAssetCollection.Instance.FindFirst(manifest.BodyType, ComponentCategories.Carryable, false, string.Empty);
            if (asset == null)
            {
                asset = AwardableAssetCollection.Instance.FindFirst(manifest.BodyType, ComponentCategories.Carryable, false, string.Empty);
            }

            if (asset == null)
            {
                asset = MarketplaceAssetCollection.Instance.FindFirst(manifest.BodyType, ComponentCategories.Carryable, false, string.Empty);
            }

            if (asset == null)
            {
                throw new UserSetupException("There are no available carryable asset to equip.");
            }
            else
            {
                manifest.Update(assetManager, asset.Id);
            }
            return manifest;
        }
        #endregion

        #region Helpers
        /// <summary>
        /// Returns a random gamertag of length given by MAX_GAMERTAG_LENGTH.
        /// </summary>
        /// <returns>Random gamertag of length MAX_GAMERTAG_LENGTH.</returns>
        public static string GetRandomGamertag()
        {
            StringBuilder sb = new StringBuilder(TestSettings.MAX_GAMERTAG_LENGTH);
            // First character of a gamertag must be a letter
            sb.Append(TestSettings.VALID_GAMERTAG_CHARACTERS[randomGenerator.Next(0, 26)]);
            for (int i = 1; i < 16; i++)
            {
                sb.Append(TestSettings.VALID_GAMERTAG_CHARACTERS[randomGenerator.Next(0, 37)]);
            }
            return sb.ToString();
        }

        public static float GetRandomSingle()
        {
            return (Single)((Single.MaxValue - Single.MinValue) * randomGenerator.Next(0, Int32.MaxValue) / Int32.MaxValue - Single.MinValue);
        }

        public static string GetMessageXml(BaseMessage message)
        {
            StringBuilder sb = new StringBuilder();
            using (XmlWriter writer = XmlWriter.Create(sb))
            {
                XmlSerializer serializer = new XmlSerializer(message.GetType());
                serializer.Serialize(writer, message);
            }

            return sb.ToString();
        }

        public static int GetDiagnosticVersion(int version)
        {
            return (int)((uint)version | 0X80000000);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\SSR\SSRTests_GamerPic.cs ===
﻿using System;
using Avatar.Services.ServerSideRenderer.Messaging;
using Leet.Core.TestService;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using AvatarServices.Test.Common;
using AvatarServices.Test.UserCache;

namespace AvatarServices.Tests
{
    /// <summary>
    /// SSR functional tests for gamerpic - XUID, Version, Type, Background color
    /// </summary>
    public partial class SSRTests
    {
        #region Xuid
        [Description("When a gamerpic message with a valid xuid is sent, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Xuid_Valid()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user.Xuid, 1);
            SendMessage(message);

            AssertDiagnosticImageFound(false, true);
        }

        [Description("When a gamerpic message with an invalid xuid is sent, verify that no image is generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Xuid_Invalid()
        {
            ResetAllImages(invalidXuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(invalidXuid, 1);
            SendMessage(message);

            AssertDiagnosticImageFound(false, false);
            CommonCode.ValidateEvents(EventIDs.SSR_GamerProfileRetrievalFailure, 1);
        }

        #endregion

        #region SaveSetting
        [Description("When a gamerpic message with a valid xuid and save setting flag true, verify that the images are generated and saved to profile.")]
        [TestMethod]
        public void SSRTests_GamerPic_SaveSetting_True()
        {
            SSRTests_GamerPic_SaveSetting(true);
        }

        [Description("When a gamerpic message with a valid xuid and save setting flag false, verify that the images are generated and not saved to profile.")]
        [TestMethod]
        public void SSRTests_GamerPic_SaveSetting_False()
        {
            SSRTests_GamerPic_SaveSetting(false);
        }

        private void SSRTests_GamerPic_SaveSetting(bool saveGamerPicToProfile)
        {
            // Create brand new user
            User user = UserCache.Instance.CreateUsers(1, Microsoft.XboxLive.Avatars.Internal.AvatarGender.Both, 0, 0)[0];

            // Set gamer tile to xbox tile
            SetGamerTile(user.Xuid, false);
            ValidateGamerTile(user.Xuid, false);

            // Send message
            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user.Xuid, 1);
            message.SaveGamerpicToProfile = saveGamerPicToProfile;
            SendMessage(message);

            // Find diagnostic image
            AssertDiagnosticImageFound(false, true);

            // validate that the gamer tile is avatar pic
            ValidateGamerTile(user.Xuid, saveGamerPicToProfile);
        }
        #endregion

        #region Version/Type
        [Description("When a gamerpic message with an invalid version is sent, verify that no image is generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Version_Invalid()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateDiagnosticGamerPicMessage(user.Xuid, 3);
            SendMessage(message);

            AssertDiagnosticImageFound(false, false);
            CommonCode.ValidateEvents(EventIDs.SSR_UnrecognizedMessageVersion, 1);
        }

        [Description("When a custom data type is sent within GenerateGamerPictureMessage, verify that no image is generated")]
        [TestMethod]
        public void SSRTests_GamerPic_DataStruct_Invalid()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            CustomMessage message = new CustomMessage(123.456);
            SendGamerPicMessage(message);

            AssertDiagnosticImageFound(false, false);
            CommonCode.ValidateEvents(EventIDs.SSR_UnrecognizedMessageFormat, 1);
        }
        #endregion

        #region Background ID
            private const int MIN_BACKGROUNDID = 0;
            private const int MAX_BACKGROUNDID = 17;

            [TestMethod]
            [Owner("rsnyder")]
            [Description("When a gamerpic message with min background ID is sent, verify that the images are generated.")]
            public void SSRTests_GamerPic_BackgroundID_Min()
            {
                User user = UserCache.Instance.GetUsersWithManifests();
                ResetAllImages(user.Xuid);

                GenerateGamerPictureMessage message = CreateCenteredDiagnosticGamerPicMessage(user);

                message.BackgroundImageId = MIN_BACKGROUNDID;

                SendMessage(message);

                AssertDiagnosticImageFound(false, true);
            }

            [TestMethod]
            [Owner("rsnyder")]
            [Description("Walk through all the background images.")]
            public void SSRTests_GamerPic_WalkThroughAllBackgroundImage()
            {
                User user = UserCache.Instance.GetUsersWithManifests();
                ResetAllImages(user.Xuid);

                GenerateGamerPictureMessage message = CreateCenteredDiagnosticGamerPicMessage(user);

                for (int bgID = MIN_BACKGROUNDID; bgID < MAX_BACKGROUNDID; bgID++)
                {
                    CommonCode.SSRTestService.DeleteImages(Config.Environment.SsrMachineName);

                    message.BackgroundImageId = bgID;

                    SendMessage(message);

                    AssertDiagnosticImageFound(false, true);
                    WriteImages("SSRTests_GamerPic_WalkThroughAllBackgroundImage", bgID);
                }
            }

            [TestMethod]
            [Owner("rsnyder")]
            [Description("When a gamerpic message with min background ID is sent, verify that the images are generated.")]
            public void SSRTests_GamerPic_BackgroundID_Max()
            {
                User user = UserCache.Instance.GetUsersWithManifests();
                ResetAllImages(user.Xuid);

                GenerateGamerPictureMessage message = CreateCenteredDiagnosticGamerPicMessage(user);

                message.BackgroundImageId = MAX_BACKGROUNDID;

                SendMessage(message);

                AssertDiagnosticImageFound(false, true);
            }

            [TestMethod]
            [Owner("rsnyder")]
            [Description("When a gamerpic message with min background ID is sent, verify that the images are generated.")]
            public void SSRTests_GamerPic_BackgroundID_Random()
            {
                User user = UserCache.Instance.GetUsersWithManifests();
                ResetAllImages(user.Xuid);

                GenerateGamerPictureMessage message = CreateCenteredDiagnosticGamerPicMessage(user);

                message.BackgroundImageId = randomGenerator.Next(MIN_BACKGROUNDID, MAX_BACKGROUNDID + 1);

                SendMessage(message);

                AssertDiagnosticImageFound(false, true);
            }

            [TestMethod]
            [Owner("rsnyder")]
            [WorkItem(7355)]
            [Description("When a gamerpic message with min background ID is sent, verify that the images are generated.")]
            public void SSRTests_GamerPic_BackgroundID_Invalid()
            {
                User user = UserCache.Instance.GetUsersWithManifests();
                ResetAllImages(user.Xuid);

                GenerateGamerPictureMessage message = CreateCenteredDiagnosticGamerPicMessage(user);

                message.BackgroundImageId = MIN_BACKGROUNDID - 1;

                SendMessage(message);

                AssertDiagnosticImageFound(false, false);
                CommonCode.ValidateEvents(EventIDs.SSR_FailedToLoadBackgroundImage, 1);
            }
        #endregion Background ID

        #region Background color
        [Description("When a gamerpic message with zero background is sent, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Background_Zero()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateCenteredDiagnosticGamerPicMessage(user);
            message.BackgroundAlpha = 0;
            message.BackgroundBlue = 0;
            message.BackgroundGreen = 0;
            message.BackgroundRed = 0;

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);

            // TODO: This test will always use the BackGroundID=0 and not the BackgroundColor. This is becuse the Background Color has been depricated and is nolonger used. Create an image that verifies the output is always the same.
        }

        [Description("When a gamerpic message with max background is sent, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Background_Max()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateCenteredDiagnosticGamerPicMessage(user);
            message.BackgroundAlpha = Byte.MaxValue;
            message.BackgroundBlue = Byte.MaxValue;
            message.BackgroundGreen = Byte.MaxValue;
            message.BackgroundRed = Byte.MaxValue;

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);

            // TODO: This test will always use the BackGroundID=0 and not the BackgroundColor. This is becuse the Background Color has been depricated and is nolonger used. Create an image that verifies the output is always the same.
        }

        [Description("When a gamerpic message with random background is sent, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_GamerPic_Background_Random()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateCenteredDiagnosticGamerPicMessage(user);
            byte[] colors = new byte[4];
            randomGenerator.NextBytes(colors);
            message.BackgroundAlpha = colors[0];
            message.BackgroundBlue = colors[1];
            message.BackgroundGreen = colors[2];
            message.BackgroundRed = colors[3];

            SendMessage(message);

            AssertDiagnosticImageFound(false, true);

            // TODO: This test will always use the BackGroundID=0 and not the BackgroundColor. This is becuse the Background Color has been depricated and is nolonger used. Create an image that verifies the output is always the same.
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\SSR\SSRTests_Tests.cs ===
﻿using System;
using Avatar.Services.ServerSideRenderer.Messaging;
using AvatarServices.Test.Common;
using AvatarServices.Test.UserCache;
using LiveN.Test.Users;
using Infrastructure.Test.Common.Logging;
using Leet.Core.TestService;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.XboxLive.Avatars.Internal;
using LiveN.Test.Avatar;

namespace AvatarServices.Tests
{
    /// <summary>
    /// SSR functional tests for message type variations
    /// </summary>
    public partial class SSRTests
    {
        #region Message without diagnostic flags
        [Description("When a valid bodyshot message is sent without diagnostic flag, verify that the image is generated.")]
        [TestMethod]
        [WorkItem(8054)]
        public void SSRTests_BodyShot_Valid()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateBodyShotMessage message = CreateBodyShotMessage(user);
            SendMessage(message);

            SqlEvent foundEvent = null;
            //Verify that SSR received the message. todo: Use perf counters to verify that the message was processed successfully
            foundEvent = diagnosticService.GetDiagnosticEntryBySourceAndMessageText("avatarsvcs_serversiderenderer", 3, String.Format("Received GenerateBodyShotMessage. XUID: {0}", user.Xuid));
            Assert.IsNotNull(foundEvent, String.Format("Could not find server side renderer diagnostics trace signifying that it received the body shot pic for user: {0}", user.Xuid));
        }

        [Description("When a valid gamerpic message is sent without diagnostic flag, verify that the image is generated.")]
        [TestMethod]
        [WorkItem(8054)]
        public void SSRTests_GamerPic_Valid()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateGamerPicMessage(user);
            SendMessage(message);

            SqlEvent foundEvent = null;
            //Verify that SSR received the message. todo: Use perf counters to verify that the message was processed successfully
            foundEvent = diagnosticService.GetDiagnosticEntryBySourceAndMessageText("avatarsvcs_serversiderenderer", 3, String.Format("Received GenerateGamerPictureMessage. XUID: {0}", user.Xuid));
            Assert.IsNotNull(foundEvent, String.Format("Could not find server side renderer trace signifying that it received the gamer pic for user: {0}", user.Xuid));
        }
        #endregion

        #region Invalid messages
        [Description("When an invalid message data and name are sent, verify that the message is not received by the service and no event is logged.")]
        [TestMethod]
        public void SSRTests_DataStruct_Invalid_MessageName_Invalid()
        {
            ResetAllImages(invalidXuid);

            CustomMessage message = new CustomMessage(12345.678);
            SendMessage(message, "Avatar.Services.ServerSideRenderer.Messaging.BaseMessage");

            AssertDiagnosticImageFound(false, false);
        }

        [Description("When a bodyshot message is sent within an invalid message type name, verify that the message is not received by the service and no event is logged.")]
        [TestMethod]
        public void SSRTests_BodyShot_MessageName_Invalid()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateBodyShotMessage message = CreateDiagnosticBodyShotMessage(user);
            SendMessage(message, "Avatar.Services.ServerSideRenderer.Messaging.BaseMessage");

            AssertDiagnosticImageFound(false, false);
        }

        [Description("When a gamerpic message is sent within an invalid message type name, verify that the message is not received by the service and no event is logged.")]
        [TestMethod]
        public void SSRTests_GamerPic_MessageName_Invalid()
        {
            User user = UserCache.Instance.GetUsersWithManifests();
            ResetAllImages(user.Xuid);

            GenerateGamerPictureMessage message = CreateCenteredDiagnosticGamerPicMessage(user);
            SendMessage(message, "Avatar.Services.ServerSideRenderer.Messaging.BaseMessage");

            AssertDiagnosticImageFound(false, false);
        }
        #endregion

        #region Storage
        [Description("When a valid message is sent for a new user, verify that the message is processed and found in xbl storage.")]
        [TestMethod]
        public void SSRTests_Storage_Valid()
        {
            User user = UserCache.Instance.CreateUsers(1, Microsoft.XboxLive.Avatars.Internal.AvatarGender.Male, 0, 0)[0];
            ResetAllImages(user.Xuid);

            GenerateBodyShotMessage messagebs = CreateDiagnosticBodyShotMessage(user);
            GenerateGamerPictureMessage messagegp = CreateCenteredDiagnosticGamerPicMessage(user);
            SendMessage(messagebs);
            SendMessage(messagegp);

            ValidateImages(user.Xuid, true, true);
        }
        #endregion

        #region Message With Manifests
        [Description("When a message with valid manifest is sent, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_Manifest_Valid()
        {
            User user = UserCache.Instance.GetUsersWithoutManifests();
            ResetAllImages(user.Xuid);

            byte[] manifest = AvatarManifest.CreateRandom(assetManager, AvatarGender.Both, 1)[0].SaveToBinary();

            GenerateBodyShotMessage messagebs = CreateDiagnosticBodyShotMessage(user, manifest);
            GenerateGamerPictureMessage messagegp = CreateCenteredDiagnosticGamerPicMessage(user, manifest);
            SendMessage(messagebs);
            SendMessage(messagegp);

            AssertDiagnosticImageFound(true, true);
        }

        [Description("When a message with invalid manifest is sent, verify that the images are not generated.")]
        [TestMethod]
        public void SSRTests_Manifest_Invalid()
        {
            User user = UserCache.Instance.GetUsersWithoutManifests();
            ResetAllImages(user.Xuid);

            byte[] manifest = new byte[] { 0, 1, 2, 3, 4 };

            GenerateBodyShotMessage messagebs = CreateDiagnosticBodyShotMessage(user, manifest);
            GenerateGamerPictureMessage messagegp = CreateCenteredDiagnosticGamerPicMessage(user, manifest);
            SendMessage(messagebs);
            SendMessage(messagegp);

            AssertDiagnosticImageFound(false, false);
            CommonCode.ValidateEvents(EventIDs.SSR_MessageNotProcessed, 2);
        }

        [Description("When a message with manifest with awardable is sent, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_Manifest_Awardable()
        {
            User user = UserCache.Instance.GetUsersWithoutManifests();
            ResetAllImages(user.Xuid);

            AvatarManifest manifest = AvatarManifest.CreateRandom(assetManager, AvatarGender.Both, 1)[0];
            AwardableAsset asset = AwardableAssetCollection.Instance.FindFirst(ComponentCategories.Hat, false);
            manifest.Update(assetManager, asset.Id);

            GenerateBodyShotMessage messagebs = CreateDiagnosticBodyShotMessage(user, manifest.SaveToBinary());
            GenerateGamerPictureMessage messagegp = CreateCenteredDiagnosticGamerPicMessage(user, manifest.SaveToBinary());
            SendMessage(messagebs);
            SendMessage(messagegp);

            AssertDiagnosticImageFound(true, true);
        }

        [Description("When a message with manifest with marketplace assets is sent, verify that the images are generated.")]
        [TestMethod]
        public void SSRTests_Manifest_Marketplace()
        {
            User user = UserCache.Instance.GetUsersWithoutManifests();
            ResetAllImages(user.Xuid);

            AvatarManifest manifest = AvatarManifest.CreateRandom(assetManager, AvatarGender.Male, 1)[0];
            MarketplaceAsset asset = MarketplaceAssetCollection.Instance.FindFirst(AvatarGender.Male, ComponentCategories.Shirt | ComponentCategories.Trousers | ComponentCategories.Wristwear, false, string.Empty);
            manifest.Update(assetManager, asset.Id);

            GenerateBodyShotMessage messagebs = CreateDiagnosticBodyShotMessage(user, manifest.SaveToBinary());
            GenerateGamerPictureMessage messagegp = CreateCenteredDiagnosticGamerPicMessage(user, manifest.SaveToBinary());
            SendMessage(messagebs);
            SendMessage(messagegp);

            try
            {
                AssertDiagnosticImageFound(true, true);
            }
            catch(Exception exc)
            {
                try
                {
                    CommonCode.ValidateEvents(EventIDs.SSR_ImageGenerationFailed);
                }
                catch
                {
                    // Unknow issue
                    throw exc;
                }

                Assert.Inconclusive("KNOWN ISSUE: One or more of the Asset(s) could not be found within the environment you are going against.\r\nException:\r\n:" + exc.ToString());
            }
        }

        [Description("When a message with an asset that's not available is sent, verify that the images are not generated.")]
        [TestMethod]
        public void SSRTests_Manifest_NotAvailable()
        {
            User user = UserCache.Instance.GetUsersWithoutManifests();
            ResetAllImages(user.Xuid);

            AvatarManifest manifest = AvatarManifest.CreateRandom(assetManager, AvatarGender.Male, 1)[0];
            MarketplaceAsset asset = MarketplaceAssetCollection.Instance.FindFirst(AvatarGender.Male, ComponentCategories.Shirt | ComponentCategories.Trousers | ComponentCategories.Wristwear, false, string.Empty);
            manifest.Update(assetManager, asset.Id);
            string manifestString = ManifestHelper.GenerateManifestString(manifest.SaveToBinary());
            string oldId = asset.Id.ToString().ToUpper().Replace("-", "");
            string newId = Guid.NewGuid().ToString().ToUpper().Replace("-", "");
            manifestString = manifestString.ToUpper().Replace(oldId, newId);
            byte[] manifestData = ManifestHelper.GenerateManifestData(manifestString);

            GenerateBodyShotMessage messagebs = CreateDiagnosticBodyShotMessage(user, manifestData);
            GenerateGamerPictureMessage messagegp = CreateCenteredDiagnosticGamerPicMessage(user, manifestData);
            SendMessage(messagebs);
            SendMessage(messagegp);

            AssertDiagnosticImageFound(false, false);
            CommonCode.ValidateMultipleEvents(new EventIDs[] { EventIDs.SSR_ImageGenerationFailed, EventIDs.SSR_MessageNotProcessed }, new int[] { 2, 2, });
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\SSR\TestHookFactory.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Core.TestService;
using Leet.Core.TestService.Client.AvatarServices;
using AvatarServices.Test.Common;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Avatar.Services.ServerSideRenderer.Messaging;
using System.Diagnostics;
using System.IO;
using System.Threading;
using System.Xml;
using System.Xml.Serialization;

namespace AvatarServices.Tests
{
    public class TestHookFactory
    {
        #region Constructor/Field/Properties
        private TestHookFactory()
        {
            try
            {
                if (Config.Environment.SsrUseTestService)
                    this.ssrService = new SSRTestService(Config.Environment.CoreTestServiceBaseUrl);
                else
                    this.ssrService = new SSRService(Config.Environment.SsrDevServiceAccount);
            }
            catch (Exception ex)
            {
                Assert.Inconclusive("There was an error initializing SSR service: " + ex.ToString());
            }
        }

        private static object _lockObject = new object();
        private static TestHookFactory _instance;
        public static TestHookFactory Instance
        {
            get
            {
                if (_instance == null)
                {
                    lock (_lockObject)
                    {
                        if (_instance == null)
                        {
                            _instance = new TestHookFactory();
                        }
                    }
                }
                return _instance;
            }
        }

        private ISSRService ssrService;
        public ISSRService SSRService
        {
            get { return this.ssrService; }
        }
        #endregion


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarSerivces.Tests\SSRPerf\SSRPerfTests.cs ===
﻿using System.Reflection;
using Avatar.Services.ServerSideRenderer.Messaging;
using AvatarServices.Tests;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace SSRTests_Perf
{
    /// <summary>
    /// SSR Perf test cases
    /// </summary>
    [TestClass]
    public partial class SSRPerfTests
    {
        /// <summary>
        /// Lock used to ensure only a single verification test runs at one time
        /// </summary>
        private static object thisLock = new object();

        private static GenerateBodyShotMessage BodyShotMessage;
        private static GenerateBodyShotMessage BodyShotMessage_Verified;

        /// <summary>
        /// Gets or sets the test context which provides
        /// information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get;
            set;
        }

        [ClassInitialize()]
        public static void MyClassInitialize(TestContext context)
        {
            BodyShotMessage = new GenerateBodyShotMessage();
            BodyShotMessage.Version = 1;
            BodyShotMessage.PoseIndex = 0;
            BodyShotMessage.PickRandomPose = false;
            BodyShotMessage.XUID = 2600292641995867;


            BodyShotMessage_Verified = new GenerateBodyShotMessage();
            BodyShotMessage_Verified.Version = SSRTests.GetDiagnosticVersion(1); // Used to get the SSR to output this image to a share
            BodyShotMessage_Verified.PoseIndex = 0;
            BodyShotMessage_Verified.PickRandomPose = false;
            BodyShotMessage_Verified.XUID = 2600292641995867;
        }

        [TestMethod]
        [Description("Send a valid BodyShot request to SSR")]
        public void SSRPerfTests_BodyShot()
        {
            SSRTests.SendMessage(BodyShotMessage);
        }

        [TestMethod]
        [Description("Send a valid BodyShot request to SSR and then verify it get outputted correctly")]
        public void SSRPerfTests_BodyShot_Verified()
        {
            // Ensure that only one thread can get in here at any one time
            lock (thisLock)
            {
                // Clear out any old images
                SSRTests.RestGamerPicImages();

                SSRTests.SendMessage(BodyShotMessage_Verified);

                SSRTests.AssertDiagnosticImageFound(true, false);

                // Is the validation failing becuase the image has changed. Uncomment and then copy the image into the project
                // NOTE: Make sure you are taking the image from the recorded response. Or else you could get a different image from when you are using Fiddler.
                SSRTests.WriteImages(this.TestContext.TestName);

                VerifyDiagnosticImageVersSaved();               
            }
        }

        /// <summary>
        /// Verify the downloaded Diagnostic Images vers the images stored within the Assembly
        /// </summary>
        public void VerifyDiagnosticImageVersSaved()
        {
            string assemblyRoot = "AvatarServices.Tests.SSR_Perf.";

            SSRTests.VerifyDiagnosticImageVersSaved(Assembly.GetExecutingAssembly(), assemblyRoot, this.TestContext);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.AvatarProxy\ClosetProxy.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Avatar.Services.Closet.Library;

using AvatarServices.Test.Common;

namespace AvatarServices.Test.AvatarProxy
{
    public class ClosetPartProxy : ClosetProxy
    {
        public ClosetPartProxy(string url, string email, string pw, string loc, string platform)
            : this(url, email, pw, loc, platform, false) { }

        public ClosetPartProxy(string email, string pw, string loc, string platform)
            : this(Config.Environment.ClosetPartService, email, pw, loc, platform, false) { }

        public ClosetPartProxy(string email, string pw)
            : this(Config.Environment.ClosetPartService, email, pw, "en-US", Config.Environment.StsSettings.PlatformType, false) { }

        public ClosetPartProxy(string email, string pw, bool useCanned)
            : this(Config.Environment.ClosetPartService, email, pw, "en-US", Config.Environment.StsSettings.PlatformType, useCanned) { }

        public ClosetPartProxy(string uri, string email, string pw, string loc, string platform, bool useCanned)
            : base(uri, email, pw, loc, platform, useCanned)
        {
            this.AuthorizationDelegate = () =>
            {
                KeyValuePair<string, string> authzHeader =
                    new KeyValuePair<string, string>("X-PartnerAuthorization", "XBL1.0 x=" + AuthorizationCache.GetPartnerToken(_memberName, _password));
                
                return authzHeader;
            };
        }
    }

    public class ClosetProxy : RestRequest
    {
        protected Uri _serviceUri;
        protected string _memberName;
        protected string _password;
        protected string _locale;

        /// <summary>
        /// Platform type used to determine were the request if comming from. Example: Console, Web, phone
        /// </summary>
        protected string _platform = null;

        /// <summary>
        /// Get or set the platform type sent with the request
        /// </summary>
        public string PlatformType
        {
            get
            {
                return _platform;
            }
            set
            {
                this.PlatformDelegate = null;

                _platform = value;
                if (_platform != null)
                {
                    this.PlatformDelegate = () =>
                    {
                        KeyValuePair<string, string> xPlatformHeader = new KeyValuePair<string, string>("X-Platform-Type", PlatformType);

                        return xPlatformHeader;
                    };
                }
            }
        }

        public ClosetProxy(string serviceUri, string emailAddress, string password, string locale, string platform)
            : this(serviceUri, emailAddress, password, locale, platform, false) { }

        public ClosetProxy(string serviceUri, string emailAddress, string password, string locale, string platform, bool useCanned)
        {
            _serviceUri = new Uri(serviceUri);
            _memberName = emailAddress;
            _password = password;
            _locale = locale;

            if (_locale != null)
            {
                this.LocaleDelegate = () =>
                {
                    KeyValuePair<string, string> xLocaleHeader =
                        new KeyValuePair<string, string>("X-Locale", _locale);
                    return xLocaleHeader;
                };
            }

            this.PlatformType = platform;

            if (useCanned)
            {
                this.CannedDelegate = () =>
                {
                    KeyValuePair<string, string> authzHeader =
                        new KeyValuePair<string, string>("X-Canned", "true");
                    return authzHeader;
                };
            }
        }

        public RestResponse GetAssets_RR()
        {
            RestResponse rr;
            UriBuilder requestUri;

            requestUri = new UriBuilder(_serviceUri);
            requestUri.Path = "Closet.svc/GetClosetAssets";

            rr = Get(requestUri.ToString(), GetHttpHeaders());

            return rr;
        }

        public ClosetAssets GetAssets()
        {
            ClosetAssets Assets;
            RestResponse rr = GetAssets_RR();

            Assets = DeserializeObject<ClosetAssets>(rr.Body);

            return Assets;
        }       
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.AvatarProxy\GamerPicProxy.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Avatar.Services.ManifestWrite.Library;
using AvatarServices.Test.Common;

namespace AvatarServices.Test.AvatarProxy
{
    public class GamerPicPartnerProxy : GamerPicProxy
    {
        public GamerPicPartnerProxy(string email, string pw)
            : this(Config.Environment.ManifestWritePartService, email, pw) { }

        public GamerPicPartnerProxy(string uri, string email, string pw)
            : base(uri, email, pw)
        {
            this.AuthorizationDelegate = () =>
            {
                KeyValuePair<string, string> authzHeader =
                    new KeyValuePair<string, string>("X-PartnerAuthorization", "XBL1.0 x=" + AuthorizationCache.GetPartnerToken(_memberName, _password));
                return authzHeader;
            };
        }
    }

    public class GamerPicProxy : RestRequest
    {
        protected Uri _serviceUri;
        protected string _memberName;
        protected string _password;

        public GamerPicProxy(string serviceUri, string emailAddress, string password)
        {
            _serviceUri = new Uri(serviceUri);
            _memberName = emailAddress;
            _password = password;
        }

        public UpdateGamerPicResponse UpdateGamerPic(UpdateGamerPicRequest upReq)
        {
            UriBuilder requestUri = new UriBuilder(_serviceUri);
            requestUri.Path = "GamerPic.svc/Update";
            RestResponse rr = Post(requestUri.ToString(), GetHttpHeaders(), SerializeObject(upReq));
            return DeserializeObject<UpdateGamerPicResponse>(rr.Body);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.AvatarProxy\ManifestReadProxy.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Avatar.Services.ManifestRead.Library;
using AvatarServices.Test.Common;


namespace AvatarServices.Test.AvatarProxy
{
    public class ManifestReadPartProxy : ManifestReadProxy
    {
        /// <summary>
        /// Platform type used to determine were the request if comming from. Example: Console, Web, phone
        /// </summary>
        protected string _platform;

        /// <summary>
        /// Get or set the platform type sent with the request
        /// </summary>
        public string PlatformType
        {
            get
            {
                return _platform;
            }
            set
            {
                _platform = value;
                if (_platform == null)
                {
                    this.PlatformDelegate = null;
                }

                this.PlatformDelegate = () =>
                {
                    KeyValuePair<string, string> xPlatformHeader = new KeyValuePair<string, string>("X-Platform-Type", PlatformType);

                    return xPlatformHeader;
                };
            }
        }

        public ManifestReadPartProxy(string email, string pw)
            : this(Config.Environment.ManifestReadPartService, email, pw, false) { }

        public ManifestReadPartProxy(string email, string pw, bool useCanned)
            : this(Config.Environment.ManifestReadPartService, email, pw, useCanned) { }

        public ManifestReadPartProxy(string url, string email, string pw)
            : this(url, email, pw, false) { }

        public ManifestReadPartProxy(string url, string email, string pw, bool useCanned)
            : base(url, email, pw, useCanned)
        {
            this.PlatformType = Config.Environment.StsSettings.PlatformType;

            this.AuthorizationDelegate = () =>
            {
                KeyValuePair<string, string> authzHeader =
                    new KeyValuePair<string, string>("X-PartnerAuthorization", "XBL1.0 x=" + AuthorizationCache.GetPartnerToken(_memberName, _password));
                return authzHeader;
            };
        }
    }

    public class ManifestReadOriginProxy : ManifestReadProxy
    {
        public ManifestReadOriginProxy(string gamertag, bool useCanned)
            : base(Config.Environment.ManifestReadService, gamertag, useCanned) { }

        public ManifestReadOriginProxy(string gamertag)
            : this(Config.Environment.ManifestReadService, gamertag) { }

        public ManifestReadOriginProxy(string url, string gamertag)
            : base(url, gamertag) { }
    }

    public class ManifestReadProxy : RestRequest
    {
        protected Uri _serviceUri;
        protected string _memberName;
        protected string _password;
        protected bool _authRequest;
        protected string _gamertagString;

        public ManifestReadProxy(string url, string email, string password, bool useCanned)
        {
            this._serviceUri = new Uri(url);
            this._memberName = email;
            this._password = password;

            if (useCanned)
            {
                this.CannedDelegate = () =>
                {
                    KeyValuePair<string, string> authzHeader =
                        new KeyValuePair<string, string>("X-Canned", "true");
                    return authzHeader;
                };
            }
        }

        public ManifestReadProxy(string url, string gamertag, bool useCanned)
        {
            this._serviceUri = new Uri(url);
            this._gamertagString = gamertag;

            if (useCanned)
            {
                this.CannedDelegate = () =>
                {
                    KeyValuePair<string, string> authzHeader =
                        new KeyValuePair<string, string>("X-Canned", "true");
                    return authzHeader;
                };
            }
        }

        public ManifestReadProxy(string url, string gamertag)
            :this(url, gamertag, false)
        {
           
        }

        public RestResponse GetManifest_RR(UInt32 titleID, UInt32 platformType)
        {
            RestResponse rr;
            string queryParms = "";
            UriBuilder uib = new UriBuilder(_serviceUri);

            uib.Path = "Manifest.svc/";

            // authenticated requests hit 'GetManifest'
            if (this.AuthorizationDelegate != null)
            {
                //todo(michperr): Replace with proper path builder
                uib.Path += "GetManifest";
            }
            else
            {
                //unauthenticated requests may or may not have a query string param depending on the exact test.
                if (_gamertagString != null)
                {
                    //todo(michperr): Replace with proper query builder
                    queryParms = String.Format("gt={0}", _gamertagString);
                }
            }

            // Partner API uses the TitleID from the STS token and PlatformType from the header. So no need to pass then in here.
            if (!(this is ManifestReadPartProxy))
            {
                if (queryParms.Length > 0)
                {
                    queryParms += "&";
                }

                queryParms += String.Format("titleid={0}", titleID);
                queryParms += String.Format("&platformType={0}", platformType);
            }

            uib.Query = queryParms;

            rr = Get(uib.ToString(), GetHttpHeaders());

            HandleResponse(rr);

            return rr;
        }

        public AvatarManifests GetManifest()
        {
            return GetManifest(0, 0);
        }

        public AvatarManifests GetManifest(UInt32 titleID, UInt32 platformType)
        {
            RestResponse rr = GetManifest_RR(titleID, platformType);
            return DeserializeObject<AvatarManifests>(rr.Body);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.AvatarProxy\ManifestWriteProxy.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Avatar.Services.ManifestWrite.Library;
using AvatarServices.Test.Common;
using System.Net;

namespace AvatarServices.Test.AvatarProxy
{
    public class ManifestWritePartProxy : ManifestWriteProxy
    {
        public ManifestWritePartProxy(string email, string pw)
            : this(Config.Environment.ManifestWritePartService, email, pw) { }

        public ManifestWritePartProxy(string uri, string email, string pw) : base(uri, email, pw) 
        {
            this.AuthorizationDelegate = () =>
            {
                KeyValuePair<string, string> authzHeader =
                    new KeyValuePair<string, string>("X-PartnerAuthorization", "XBL1.0 x=" + AuthorizationCache.GetPartnerToken(_memberName, _password));
                return authzHeader;
            };
        }
    }
    
    public class ManifestWriteProxy:RestRequest
    {
        protected Uri _serviceUri;
        protected string _memberName;
        protected string _password;

        public ManifestWriteProxy(string serviceUri, string emailAddress, string password)
        {
            _serviceUri = new Uri(serviceUri);
            _memberName = emailAddress;
            _password = password;

        }

        public UpdateManifestResponse UpdateManifest(UpdateManifestRequest upReq)
        {
            RestResponse rr = UpdateManifest_RR(upReq);
            return DeserializeObject<UpdateManifestResponse>(rr.Body);
        }

        public RestResponse UpdateManifest_RR(UpdateManifestRequest upReq)
        {
            UriBuilder requestUri = new UriBuilder(_serviceUri);
            requestUri.Path = "Manifest.svc/Update";
            RestResponse rr = Post(requestUri.ToString(), GetHttpHeaders(), SerializeObject(upReq));
            return rr;            
        }

        public int UpdateManifest(string manifest)
        {
            UpdateManifestRequest request = new UpdateManifestRequest();
            request.Manifest = manifest;

            UpdateManifestResponse response = UpdateManifest(request);
            return response.SuccessCode;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.BlacklistTool\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows.Forms;

namespace AvatarServices.Test.BlacklistTool
{
    /// <summary>
    /// The main entry point for the application.
    /// The Main is will switch between Windows and Console mode depending on number of command line arguments that is passed.
    /// Will run as GUI app when invoked without any commandline parameters
    /// Will run as Console app when command line arguments are passed.
    /// </summary>
    static class Program
    {                           
        /// <summary>
        /// Constant used to redirect the console output to the cmd window
        /// </summary>
        private const int ATTACH_PARENT_PROCESS = -1;

        [System.Runtime.InteropServices.DllImport("kernel32.dll")]
        private static extern bool AllocConsole();
        [System.Runtime.InteropServices.DllImport("kernel32.dll")]
        private static extern bool AttachConsole(int processId);

        /// <summary>
        /// Program.Main is the entry point for the application
        /// </summary>
        [STAThread]
        static void Main(string[] args)
        {
            if (args.Length > 0)
            {
                AttachConsole(ATTACH_PARENT_PROCESS);

                // Command line given, display console 
                AllocConsole();
                ConsoleMain(args);
            }
            else
            {
                try
                {                   
                    // If there are no command line arguments run as normal GUI windows form app.
                    Application.EnableVisualStyles();
                    Application.SetCompatibleTextRenderingDefault(false);                    
                    Application.Run(new ToolGUI());                    
                }
                catch (Exception e)
                {
                    MessageBox.Show(e.ToString());                    
                }
            }
        }

        /// <summary>
        /// Function to run the application in Console mode
        /// </summary>
        private static void ConsoleMain(string[] args)
        {
            Console.WriteLine();
            if (((args.Length == 1) && (args[0].Equals("-help") || args[0].Equals("-h") || args[0].Equals("/?") || args[0].Equals("?"))) || (args.Length != 1))
            {
                Console.WriteLine("");
                Console.WriteLine(@"========");
                Console.WriteLine(@"Usage example for console - c:\>BlacklistTool <file_name>");
                Console.WriteLine(@"Where <file_name> is the input excel file which has a sheet <blacklist> with blacklisted Assets");
                Console.WriteLine(@"========");
                Console.WriteLine(@"Usage example for GUI - c:\>BlacklistTool");
                Console.WriteLine(@"Invoke without any parameters for GUI version");
                Console.WriteLine(@"========");

                return;
            }
            
            ToolGUI.console_invoke(args[0], null);
            Console.WriteLine("Press any key to continue...");
        }               
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.BlacklistTool\ExcelFactory.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Data.OleDb;
using System.IO;
using System.Xml;
using AvatarServices.Test.Common;

namespace AvatarServices.Test.BlacklistTool
{
    public class ExcelFactory
    {
        /// <summary>
        /// Member valiable to store Excel file name and worksheet name that is used
        /// _record_list used to store parsed Excel file rows
        /// </summary>
        private string _file_name;
        private string _worksheet;         
        private List<string> _record_list;

        /// <summary>
        /// Member variable to store the Blacklist XML file
        /// </summary>
        private string _xml_file;

        //Constructor
        public ExcelFactory(string file, string sheet_name)
        {            
            if(!String.IsNullOrEmpty(file))
            {
                if (File.Exists(file))
                {
                    _file_name = file; //set the _file_name                                        
                    DataTable table = GetDataTableFromExcelFile(file, sheet_name);

                    foreach (DataRow row in table.Rows)
                    {
                        string record = "";
                        foreach (DataColumn col in table.Columns)
                        {
                            // Replace comma with space as we are using comma as column delimiter for records                     
                            record = record + (row[col].ToString().Replace(',',' ') + ",");
                        }

                        if (_record_list == null)
                        {
                            _record_list = new List<string>();
                        }

                        _record_list.Add(record);                                                
                    }

                    // Set the output XML file path
                    _xml_file = Directory.GetCurrentDirectory() + @"\BlackListedAssets.xml";

                    // Delete existing XML file before processing and creating a new file
                    if (File.Exists(_xml_file))
                    {
                        File.Delete(_xml_file);
                    }
                }
            }
        }

        /// <summary>
        /// Function returns private memeber _file_name string 
        /// </summary>
        public string get_filename()
        {
            return _file_name;
        }

        /// <summary>
        /// Function returns private member _worksheet string
        /// </summary>        
        public string get_worksheet()
        {
            return _worksheet;
        }

        /// <summary>
        /// Constant to store the DB connection string to connect to Excel file
        /// </summary>        
        private const string CONNECTION_STRING = "Provider=Microsoft.ACE.OLEDB.12.0;Data Source=<FILENAME>;Extended Properties=\"Excel 12.0;HDR=No;IMEX=1\"";

        /// <summary>
        /// Function extracts the sheet containing blacklist asset and returns it as DataTable from the Excel file.       
        /// </summary>
        /// <param name="fullFileName">file name</param>
        /// <param name="sheetName_actual">sheet name to process. if null will default to "blacklist"</param>
        /// <returns> DataTable object which contains the input Excel file data</returns>
        public DataTable GetDataTableFromExcelFile(string fullFileName, string sheetName_actual) 
        {                
            
            if (String.IsNullOrEmpty(sheetName_actual))
            {
                this._worksheet = "blacklist"; // we default to "blacklist" if sheetName is null or empty
            }
            else
            {
                this._worksheet = sheetName_actual;
            }
                        
            OleDbConnection objConnection = new OleDbConnection(); 
            objConnection = new OleDbConnection(CONNECTION_STRING.Replace("<FILENAME>", fullFileName)); 
            DataSet dsImport = new DataSet(); 

            try 
            { 
                    objConnection.Open(); 

                    DataTable dtSchema = objConnection.GetOleDbSchemaTable(OleDbSchemaGuid.Tables, null); 

                    if( (null == dtSchema) || ( dtSchema.Rows.Count <= 0 ) ) 
                    {                           

                        throw new Exception(String.Format("Error reading the input Excel file - \"{0}\"", fullFileName));
                    }


                    if (!CheckIfSheetNameExists(this._worksheet+"$", dtSchema)) 
                    {
                        throw new Exception(String.Format("Error: Sheet \"{0}\" do not exist in file \"{1}\"", this._worksheet, fullFileName));                                                        
                    }

                    new OleDbDataAdapter("SELECT * FROM [" + this._worksheet+"$"+ "]", objConnection).Fill(dsImport); 
            } 
           
            finally 
            { 
                    // Clean up. 
                    if(objConnection != null) 
                    { 
                            objConnection.Close(); 
                            objConnection.Dispose();                                 
                    } 
            } 

            return dsImport.Tables[0];               
        } 
 
        /// <summary> 
        /// This method checks if the user entered sheetName exists in the Schema Table 
        /// </summary> 
        /// <param name="sheetName">Sheet name to be verified</param> 
        /// <param name="dtSchema">schema table </param> 
        private bool CheckIfSheetNameExists(string sheetName, DataTable dtSchema) 
        { 
            foreach(DataRow dataRow in dtSchema.Rows) 
            { 
                    if( sheetName.ToLower() == dataRow["TABLE_NAME"].ToString().ToLower() ) 
                    { 
                            return true; 
                    }        
            } 
            return false; 
        }

        /// <summary> 
        /// This method process the </_record_list> to serialize the XML 
        /// </summary> 
        /// <param name="out error">any error during process is returened back in this string</param> 
        /// <param name="out XMLstring">the XML constructed is retured back in this string </param> 
        public string CreateXMLfile(out string error, out string XMLstring)
        {
            if (this._record_list == null)
            {
                // no data to create XML file throw exception
                throw new Exception("Error: No data to create XML file. _record_list is empty");
            }           

            error = "";
            int line_number = 0;
            BlacklistedAssets b = new BlacklistedAssets();            

            foreach (string record in this._record_list)
            {
                line_number++;

                string[] tokens = record.Split(new char[] { ',' });

                if (tokens[0].Contains("Blocklist") || tokens[0].Contains("PlatformID") || tokens[0].Contains("Blocklist")
                    || tokens[1].Contains("TitleID"))
                {
                    continue; //skip records that does not have any value
                }

                if (!String.IsNullOrEmpty(tokens[0]) && !String.IsNullOrEmpty(tokens[1]))
                {
                    error = error + String.Format("Error: Excel line <{0}>. Ignored as it has both PlatformID {1} and TitleID {2} \n", line_number, tokens[0], tokens[1]);
                    continue; //error, record has both TitleID and PlatformID
                }

                if (String.IsNullOrEmpty(tokens[0]) && String.IsNullOrEmpty(tokens[1]))
                {

                    if (!String.IsNullOrEmpty(tokens[3]))
                    {
                        b.Add_Asset("global", "0", null, tokens[3].Trim(), ref error, line_number);
                    }
                    continue;
                }

                if (!String.IsNullOrEmpty(tokens[0]))
                {
                    b.Add_Asset("PlatformID", tokens[0].Trim(), null, tokens[3].Trim(), ref error, line_number);
                    continue;
                }

                if (!String.IsNullOrEmpty(tokens[1]))
                {
                    b.Add_Asset("TitleID", tokens[1].Trim(), null, tokens[3].Trim(), ref error, line_number);
                    continue;
                }
            }
           
            XMLstring = b.SerializeToXmlString();

            XmlDocument doc = b.ToXmlDocument();
            doc.CreateComment(DateTime.Now.ToString());

            //Create a comment.
            XmlComment newComment;
            newComment = doc.CreateComment(String.Format("Excel source: {0}. Worksheet: {1}. Time: {2}", (new FileInfo(_file_name)).Name, _worksheet, DateTime.Now.ToString()));

            //Add the new node to the document.
            XmlElement root = doc.DocumentElement;
            doc.InsertBefore(newComment, root);            
            doc.Save(_xml_file);

            return _xml_file;
        }
    } 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.BlacklistTool\ToolGUI.cs ===
﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Xml.Linq;
using System.Xml;
using System.IO;
using System.Diagnostics;
using AvatarServices.Test.Common;

namespace AvatarServices.Test.BlacklistTool
{
    public partial class ToolGUI : Form
    {       

        public ToolGUI()
        {
            InitializeComponent();
            richTextBox1.LinkClicked += new System.Windows.Forms.LinkClickedEventHandler(Link_Clicked); //event handler to process clicking link in richtextbox.
        }

        /// <summary>
        /// Function that process the Excel file for GUI mode.
        /// </summary>
        private void button1_Click(object sender, EventArgs e)
        {
            string error="";
            string xml_file="";

            try
            {
                richTextBox1.Clear();
                richTextBox1.AppendText(String.Format(DateTime.Now.ToString() + "\n"));

                if (String.IsNullOrEmpty(textBox1.Text))
                {
                    richTextBox1.AppendText("Error: File name is empty\n");
                    MessageBox.Show("Error: File name is empty");

                    return;
                }

                string file = textBox1.Text;
                string sheet_name = null;
                string xml_str;

                if (!File.Exists(file))
                {
                    error += String.Format("Error: The file <{0}> do not exist. \n", file);
                    return;
                }

                ExcelFactory e1 = new ExcelFactory(file, sheet_name);
                xml_file = e1.CreateXMLfile(out error, out xml_str);

                richTextBox1.AppendText("====\n");
                richTextBox1.AppendText(String.Format("Input Excel file - <{0}> \n", e1.get_filename()));
                richTextBox1.AppendText(String.Format("Worksheet used - <{0}> \n", e1.get_worksheet()));               

                if (!String.IsNullOrEmpty(xml_file))
                    System.Diagnostics.Process.Start(xml_file);

            }
            catch (InvalidOperationException invalid)
            {
                richTextBox1.AppendText("====\n");
                richTextBox1.AppendText(invalid.ToString());
                richTextBox1.AppendText("====\n");
                richTextBox1.AppendText("Try again after installing the following: 2007 Office System Driver: Data Connectivity Components - http://www.microsoft.com/downloads/en/details.aspx?FamilyID=7554F536-8C28-4598-9B72-EF94E038C891&displaylang=en ");
            }
            catch (Exception exp)
            {
                richTextBox1.AppendText("====\n");
                richTextBox1.AppendText(exp.ToString());
                richTextBox1.AppendText("====\n");             
            }
            finally
            {
                if (!String.IsNullOrEmpty(error))
                {                    
                    richTextBox1.AppendText("====\n");
                    richTextBox1.AppendText("Errors and Warnings:\n");
                    richTextBox1.AppendText(error);                    
                }

                if (File.Exists(xml_file))
                {
                    richTextBox1.AppendText("====\n");
                    richTextBox1.AppendText(String.Format("XML file generated - file:{0}  \n", xml_file));
                    richTextBox1.AppendText("====\n");
                    richTextBox1.AppendText("SUCCESS: Output XML file created\n");
                }
                else
                {
                    richTextBox1.AppendText("====\n");
                    richTextBox1.AppendText("FAILURE: Output XML file NOT created\n");
                }

                if (!String.IsNullOrEmpty(error))
                {
                    MessageBox.Show("Attention! Errors and Warinings detected during excel file processing");
                }
            }           
        }

        /// <summary>
        /// Function that process the Excel file for Console mode.
        /// </summary>
        /// <param name="file">Exfel file name</param>
        /// <param name="sheet_name">Sheet name in the Excel file which if null or empty will default to 'blacklist' which is what we use</param>                
        public static void console_invoke(string file, string sheet_name)
        {
            string error = "";
            string xml_file = "";

            try
            {
                if (String.IsNullOrEmpty(file))
                {
                    MessageBox.Show("Error: File name is empty");
                    return;
                }

                if (!File.Exists(file))
                {
                    error += String.Format("Error: The file <{0}> do not exist. \n", file);
                    return;
                }

                string xml_str;
                ExcelFactory e1 = new ExcelFactory(file, sheet_name);
                xml_file = e1.CreateXMLfile(out error, out xml_str);

                Console.WriteLine("====");
                Console.WriteLine("Input Excel file - <{0}>", e1.get_filename());
                Console.WriteLine("Worksheet used - <{0}>", e1.get_worksheet());
                Console.WriteLine();

            }
            catch (InvalidOperationException invalid)
            {
                Console.WriteLine("====");
                Console.WriteLine("Errors and Warnings:");
                Console.WriteLine(invalid.ToString());
                Console.WriteLine("====");

                Console.WriteLine("Try again after installing the following: 2007 Office System Driver: Data Connectivity Components - http://www.microsoft.com/downloads/en/details.aspx?FamilyID=7554F536-8C28-4598-9B72-EF94E038C891&displaylang=en ");
                Console.WriteLine("====");
            }
            catch (Exception exp)
            {
                Console.WriteLine("====");
                Console.WriteLine(exp.ToString());
                Console.WriteLine("====");             
            }
            finally
            {                
                if (!String.IsNullOrEmpty(error))
                {
                    Console.WriteLine("====\n");
                    Console.WriteLine("Errors and Warnings:\n");
                    Console.WriteLine(error);                 
                }

                if (File.Exists(xml_file))
                {
                    Console.WriteLine("====");
                    Console.WriteLine("XML file generated - {0}", xml_file);
                    Console.WriteLine("====");
                    Console.WriteLine("SUCCESS: Output XML file created\n");
                }
                else
                {
                    Console.WriteLine("====");
                    Console.WriteLine("FAILURE: Output XML file NOT created\n");
                }

            }                
        }

        /// <summary>
        /// Function to select Excel file from file open dialog box.
        /// <summary>
        private void button2_Click(object sender, EventArgs e)
        {
            try
            {
                OpenFileDialog dialog = new OpenFileDialog();

                if (dialog.ShowDialog() == DialogResult.OK)
                {
                    textBox1.Text = dialog.FileName;
                }
            }
            catch (Exception e1)
            {
                MessageBox.Show(e1.ToString());
            }
            
            return;//user didn't select a file
        }

        /// <summary>
        /// Function to clear the Output testbox.
        /// <summary>
        private void button3_Click(object sender, EventArgs e)
        {
            richTextBox1.Clear();                   
        }

        private void label1_Click(object sender, EventArgs e)
        {

        }

        /// <summary> 
        ///Open the target file on clicking it in rich testbox
        /// <summary>
        protected void Link_Clicked(object sender, System.Windows.Forms.LinkClickedEventArgs e)
        {
            System.Diagnostics.Process.Start(e.LinkText);
        }

        private void richTextBox1_TextChanged(object sender, EventArgs e)
        {            

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.BlacklistTool\Properties\Resources.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4952
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace AvatarServices.Test.BlacklistTool.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("AvatarServices.Test.BlacklistTool.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.BlacklistTool\Properties\Settings.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4952
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace AvatarServices.Test.BlacklistTool.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.BlacklistTool\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("BlacklistTool")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.BlacklistTool\ToolGUI.Designer.cs ===
﻿namespace AvatarServices.Test.BlacklistTool
{
    partial class ToolGUI
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.button1 = new System.Windows.Forms.Button();
            this.label1 = new System.Windows.Forms.Label();
            this.textBox1 = new System.Windows.Forms.TextBox();
            this.label3 = new System.Windows.Forms.Label();
            this.button2 = new System.Windows.Forms.Button();
            this.button_ClearLogs = new System.Windows.Forms.Button();
            this.richTextBox1 = new System.Windows.Forms.RichTextBox();
            this.SuspendLayout();
            // 
            // button1
            // 
            this.button1.Location = new System.Drawing.Point(332, 15);
            this.button1.Name = "button1";
            this.button1.Size = new System.Drawing.Size(89, 48);
            this.button1.TabIndex = 0;
            this.button1.Text = "Generate XML";
            this.button1.UseVisualStyleBackColor = true;
            this.button1.Click += new System.EventHandler(this.button1_Click);
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(12, 13);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(90, 13);
            this.label1.TabIndex = 2;
            this.label1.Text = "Excel blacklist file";
            this.label1.Click += new System.EventHandler(this.label1_Click);
            // 
            // textBox1
            // 
            this.textBox1.Location = new System.Drawing.Point(15, 29);
            this.textBox1.Name = "textBox1";
            this.textBox1.Size = new System.Drawing.Size(223, 20);
            this.textBox1.TabIndex = 3;
            // 
            // label3
            // 
            this.label3.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(12, 76);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(39, 13);
            this.label3.TabIndex = 6;
            this.label3.Text = "Output";
            // 
            // button2
            // 
            this.button2.Location = new System.Drawing.Point(244, 29);
            this.button2.Name = "button2";
            this.button2.Size = new System.Drawing.Size(75, 21);
            this.button2.TabIndex = 9;
            this.button2.Text = "Open file";
            this.button2.UseVisualStyleBackColor = true;
            this.button2.Click += new System.EventHandler(this.button2_Click);
            // 
            // button_ClearLogs
            // 
            this.button_ClearLogs.Location = new System.Drawing.Point(56, 71);
            this.button_ClearLogs.Name = "button_ClearLogs";
            this.button_ClearLogs.Size = new System.Drawing.Size(75, 23);
            this.button_ClearLogs.TabIndex = 10;
            this.button_ClearLogs.Text = "Clear logs";
            this.button_ClearLogs.UseVisualStyleBackColor = true;
            this.button_ClearLogs.Click += new System.EventHandler(this.button3_Click);
            // 
            // richTextBox1
            // 
            this.richTextBox1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.richTextBox1.Location = new System.Drawing.Point(15, 100);
            this.richTextBox1.Name = "richTextBox1";
            this.richTextBox1.Size = new System.Drawing.Size(406, 161);
            this.richTextBox1.TabIndex = 1;
            this.richTextBox1.Text = "";
            this.richTextBox1.TextChanged += new System.EventHandler(this.richTextBox1_TextChanged);
            // 
            // ToolGUI
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(435, 281);
            this.Controls.Add(this.richTextBox1);
            this.Controls.Add(this.button_ClearLogs);
            this.Controls.Add(this.button2);
            this.Controls.Add(this.label3);
            this.Controls.Add(this.textBox1);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.button1);
            this.Name = "ToolGUI";
            this.Text = "Blacklist Tool";
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Button button1;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.TextBox textBox1;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.Button button2;
        private System.Windows.Forms.Button button_ClearLogs;
        private System.Windows.Forms.RichTextBox richTextBox1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.BlacklistTool\UnitTest\Blacklist_UnitTest.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.IO;
using System.Xml;
using System.Xml.Linq;
using AvatarServices.Test.Common;

namespace AvatarServices.Test.BlacklistTool
{
    /// <summary>
    /// Summary description for Blacklist_UnitTest
    /// </summary>
    [TestClass]
    public class BlacklistTool_UnitTest
    {
        /// <summary>
        /// Member variables for excel file and xml file.
        /// </summary>
        private string _excel_file;
        private string _xml_file;

        public BlacklistTool_UnitTest()
        {
            _excel_file = Directory.GetCurrentDirectory().ToString() + @"\file1.xlsx";
            _xml_file = Directory.GetCurrentDirectory().ToString() + @"\BlacklistedAssets.xml";
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
         [TestInitialize()]
         public void MyTestInitialize() 
         {
             // Delete the temp Excel file and BlacklistedAssets.xml file before starting each test
             if (File.Exists(_excel_file))
                 File.Delete(_excel_file);

             if (File.Exists(_xml_file))
                 File.Delete(_xml_file);                  
         }

        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        /// <summary>
        /// This function checks if given (target, value, asset) node exist in the given XML object
        /// </summary>
        /// <param name="b"> object of type BlacklistedAssets</param>
        /// <param name="target">PlatformID or TitleID</param>        
        /// <param name="value">HEX value of the target</param>        
        /// <param name="asset"> asset value string</param>
        /// <returns> true if (target, value, asset) is found in the given BlacklistedAssets XML object</returns>
         private bool Check_XML_Node(BlacklistedAssets b, string target, string value, string asset)
        {
            if (b != null)
            {
                if (b.Assets != null)
                {
                    foreach (AssetsElements a in b.Assets)
                    {
                        if (a.Target.Equals(target) && a.Value.Equals(value))
                        {
                            if (a.AssetIDs != null)
                            {
                                if (a.AssetIDs.Contains(String.Format(asset).ToLower()))
                                {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
           
            return false;
        }

        [TestMethod]
        [Owner("srkalyan")]
        [Description("Verifies if GUIDs are stored in lowercase in the XML file that is generated")]
        public void BlacklistTool_Check_GUIDs_lowercase()
        {                                                
            ExcelGenerator file1 = new ExcelGenerator(_excel_file, null);
            string asset1 = "00000AB8-CA3A-82A2-CEA5-E9274C4107E2";
            
            List<string> rec = new List<string>();                        
            rec.Add(String.Format("'','','','{0}'", asset1));

            file1.Insert_Rows(rec, null);

            ExcelFactory f = new ExcelFactory(_excel_file, null);

            string error;
            string XML;

            string xml_file = f.CreateXMLfile(out error, out XML);                        

            XML = file1.GetXmlString(_xml_file);

            BlacklistedAssets b = (BlacklistedAssets)file1.ToObject(typeof(BlacklistedAssets), XML);

            Assert.IsTrue(Check_XML_Node(b, "global","0", asset1), String.Format("GUID <{0}> is NOT lowercased in the XML file", asset1));
            Assert.IsTrue(String.IsNullOrEmpty(error), "Following unexpected Error and Warnings were thrown <{0}>", error);
        }

        [TestMethod]
        [Owner("srkalyan")]
        [Description("Verifies if BlacklistedAssets.xml file gets created")]
        public void BlacklistTool_Check_XML_filename()
        {         
            ExcelGenerator file1 = new ExcelGenerator(_excel_file, null);
            string asset1 = "00000AB8-CA3A-82A2-CEA5-E9274C4107E2";

            List<string> rec = new List<string>();
            rec.Add("'','','','"+asset1+"'");

            file1.Insert_Rows(rec, null);

            ExcelFactory f = new ExcelFactory(_excel_file, null);

            string error;
            string XML;
            string xml_file = f.CreateXMLfile(out error, out XML);            

            Assert.AreEqual(true, File.Exists(_xml_file), String.Format("The XML file {0} was not created", _xml_file));
            Assert.IsTrue(String.IsNullOrEmpty(error), "Following unexpected Error and Warnings were thrown <{0}>", error);
        }

        [TestMethod]
        [Owner("srkalyan")]
        [Description("Verifies if two unique AssetIDs are successfully stored for target type <global>")]
        public void BlacklistTool_Check_Target_global_two_unique_assets()
        {            
            ExcelGenerator file1 = new ExcelGenerator(_excel_file, null);

            string asset1 = "00000AB8-CA3A-82A2-CEA5-E9274C4107E2";
            string asset2 = "00000008-1292-e231-ce11-478f454108c6";

            List<string> rec = new List<string>();
            rec.Add(String.Format("'','','','{0}'", asset1));
            rec.Add(String.Format("'','','','{0}'", asset2));

            file1.Insert_Rows(rec, null);

            ExcelFactory f = new ExcelFactory(_excel_file, null);

            string error;
            string XML;

            string xml_file = f.CreateXMLfile(out error, out XML);            
            XML = file1.GetXmlString(xml_file);

            BlacklistedAssets b = (BlacklistedAssets)file1.ToObject(typeof(BlacklistedAssets), XML);

            Assert.IsTrue(Check_XML_Node(b, "global", "0", asset1), "Target <global> do not have unique Asset <{0}> in the XML file <{1} >generated", asset1.ToLower(), xml_file);
            Assert.IsTrue(Check_XML_Node(b, "global", "0", asset2), "Target <global> do not have unique Asset <{0}> in the XML file <{1} >generated", asset2.ToLower(), xml_file);
            Assert.IsTrue(String.IsNullOrEmpty(error), "Following unexpected Errors and Warnings were thrown <{0}>", error);         
        }

        [TestMethod]
        [Owner("srkalyan")]
        [Description("Verifies if TargetID value gets converted from Hex to Decimal in the XML file")]
        public void BlacklistTool_Check_Target_TitleID_value_hex_to_decimal()
        {
            ExcelGenerator file1 = new ExcelGenerator(_excel_file, null);

            string asset1 = "00000008-1292-e231-ce11-478f454108c6";
            string TitleID = "4D530914";   
            string TitleID_dec = int.Parse(TitleID, System.Globalization.NumberStyles.HexNumber).ToString();

            List<string> rec = new List<string>();
            rec.Add(String.Format("'','{0}','','{1}'", TitleID, asset1));            

            file1.Insert_Rows(rec, null);

            ExcelFactory f = new ExcelFactory(_excel_file, null);

            string error;
            string XML;

            string xml_file = f.CreateXMLfile(out error, out XML);
            XML = file1.GetXmlString(_xml_file);

            BlacklistedAssets b = (BlacklistedAssets)file1.ToObject(typeof(BlacklistedAssets), XML);

            Assert.IsTrue(Check_XML_Node(b, "TitleID", TitleID_dec,asset1) , "TitleID with Decimal Val <{0}> not present in the XML file <{1} >generated", TitleID_dec, _xml_file);
            Assert.IsTrue(String.IsNullOrEmpty(error), "Following unexpected Error and Warnings were thrown <{0}>", error);
        }

        [TestMethod]
        [Owner("srkalyan")]
        [Description("Verifies if PlatformID value gets converted from Hex to Decimal in the XML file")]
        public void BlacklistTool_Check_Target_PlatformID_value_hex_to_decimal()
        {
            ExcelGenerator file1 = new ExcelGenerator(_excel_file, null);

            string asset = "00000008-1292-e231-ce11-478f454108c6";
            string PlatformID = "4D530914";
            string PlatformID_dec = int.Parse(PlatformID, System.Globalization.NumberStyles.HexNumber).ToString();

            List<string> rec = new List<string>();
            rec.Add(String.Format("'{0}','','','{1}'", PlatformID, asset));

            file1.Insert_Rows(rec, null);
            ExcelFactory f = new ExcelFactory(_excel_file, null);

            string error;
            string XML;
            string xml_file = f.CreateXMLfile(out error, out XML);            

            XML = file1.GetXmlString(xml_file);

            BlacklistedAssets b = (BlacklistedAssets)file1.ToObject(typeof(BlacklistedAssets), XML);

            Assert.IsTrue(Check_XML_Node(b, "PlatformID", PlatformID_dec, asset), "PlatformID with decimal Val <{0}> and AssetID <{1}> not present in the XML file <{2} >generated", PlatformID_dec, asset.ToLower(), _xml_file);
            Assert.IsTrue(String.IsNullOrEmpty(error), "Following unexpected Error and Warnings were thrown <{0}>", error);
        }


        [TestMethod]
        [Owner("srkalyan")]
        [Description("Verifies if two unique AssetIDs are successfully stored for target type <TitleID>")]
        public void BlacklistTool_Check_Target_TitleID_two_unique_assets()
        {
            ExcelGenerator file1 = new ExcelGenerator(_excel_file, null);

            string TitleID = "4D530914";
            string TitleID_dec = int.Parse(TitleID, System.Globalization.NumberStyles.HexNumber).ToString();
            string asset1 = "00000AB8-CA3A-82A2-CEA5-E9274C4107E2";
            string asset2 = "00000008-1292-e231-ce11-478f454108c6";

            List<string> rec = new List<string>();
            rec.Add(String.Format("'','{0}','','{1}'", TitleID, asset1));
            rec.Add(String.Format("'','{0}','','{1}'", TitleID, asset2));            

            file1.Insert_Rows(rec, null);

            ExcelFactory f = new ExcelFactory(_excel_file, null);

            string error;
            string XML;
            string xml_file = f.CreateXMLfile(out error, out XML);            

            XML = file1.GetXmlString(_xml_file);

            BlacklistedAssets b = (BlacklistedAssets)file1.ToObject(typeof(BlacklistedAssets), XML);

            Assert.IsTrue(Check_XML_Node(b, "TitleID", TitleID_dec, asset1), "Target <TitleID> value <{0}> do not have Assets <{1}> in the XML file <{2}> generated", TitleID_dec, asset1.ToLower(), _xml_file);
            Assert.IsTrue(Check_XML_Node(b, "TitleID", TitleID_dec, asset2), "Target <TitleID> value <{0}> do not have Assets <{1}> in the XML file <{2}> generated", TitleID_dec, asset2.ToLower(), _xml_file);
            Assert.IsTrue(String.IsNullOrEmpty(error), "Following unexpected Error and Warnings were thrown <{0}>", error);
        }

        [TestMethod]
        [Owner("srkalyan")]
        [Description("Verifies if two unique AssetIDs are successfully stored for target type <PlatformID>")]
        public void BlacklistTool_Check_Target_PlatformID_two_unique_assets()
        {
            ExcelGenerator file1 = new ExcelGenerator(_excel_file, null);

            string PlatformID = "4D530914";
            string PlatformID_dec = int.Parse(PlatformID, System.Globalization.NumberStyles.HexNumber).ToString();
            string asset1 = "00000AB8-CA3A-82A2-CEA5-E9274C4107E2";
            string asset2 = "00000008-1292-e231-ce11-478f454108c6";

            List<string> rec = new List<string>();
            rec.Add(String.Format("'{0}','','','{1}'", PlatformID, asset1));
            rec.Add(String.Format("'{0}','','','{1}'", PlatformID, asset2));            

            file1.Insert_Rows(rec, null);

            ExcelFactory f = new ExcelFactory(_excel_file, null);

            string error;
            string XML;

            string xml_file = f.CreateXMLfile(out error, out XML);

            Assert.IsTrue(File.Exists(xml_file));
            XML = file1.GetXmlString(xml_file);

            BlacklistedAssets b = (BlacklistedAssets)file1.ToObject(typeof(BlacklistedAssets), XML);

            Assert.IsTrue(Check_XML_Node(b, "PlatformID", PlatformID_dec, asset1), "Target <PlatformID> value <{0}> do not have Asset <{1}> in the XML file <{2}> generated", PlatformID_dec, asset1.ToLower(), _xml_file);
            Assert.IsTrue(Check_XML_Node(b, "PlatformID", PlatformID_dec, asset2), "Target <PlatformID> value <{0}> do not have Asset <{1}> in the XML file <{2}> generated", PlatformID_dec, asset2.ToLower(), _xml_file);
            Assert.IsTrue(String.IsNullOrEmpty(error), "Following unexpected Error and Warnings were thrown <{0}>", error);
        }


        [TestMethod]
        [Owner("srkalyan")]
        [Description("Verifies that proper Error message is thrown if input Excel file has a row with both PlatformID and TitleID")]
        public void BlacklistTool_Check_Target_PlatformID_TitleID_present_error()
        {
            string Error_Message = "Error: Excel line <2>. Ignored as it has both PlatformID 4D530914 and TitleID 4D530914";
            string str_file = Directory.GetCurrentDirectory().ToString() + @"\file1.xlsx";
            ExcelGenerator file1 = new ExcelGenerator(str_file, null);            

            string PlatformID = "4D530914";
            string PlatformID_dec = int.Parse(PlatformID, System.Globalization.NumberStyles.HexNumber).ToString();

            List<string> rec = new List<string>();
            rec.Add("'4D530914','4D530914','','00000AB8-CA3A-82A2-CEA5-E9274C4107E2'");
            rec.Add("'4D530914','','','00000AB8-CA3A-82A2-CEA5-E9274C4107E2'");       

            file1.Insert_Rows(rec, null);

            ExcelFactory f = new ExcelFactory(str_file, null);

            string error;
            string XML;
            string xml_file = f.CreateXMLfile(out error, out XML);

            Assert.IsTrue(File.Exists(xml_file));
            XML = file1.GetXmlString(xml_file);

            Assert.IsTrue(error.Contains(Error_Message), "Following Error message missing <{0}>", Error_Message);           
        }

        [TestMethod]
        [Owner("srkalyan")]
        [Description("Verifies that proper Warning message is thrown if input Excel file has duplicate AssetsIDs for same PlatformID")]
        public void BlacklistTool_Check_Target_PlatformID_duplicate_Assets_warning()
        {
            string str_file = Directory.GetCurrentDirectory().ToString() + @"\file1.xlsx";
            ExcelGenerator file1 = new ExcelGenerator(str_file, null);

            string asset1="00000AB8-CA3A-82A2-CEA5-E9274C4107E2";
            string PlatformID = "4D530914";
            string PlatformID_dec = int.Parse(PlatformID, System.Globalization.NumberStyles.HexNumber).ToString();

            List<string> rec = new List<string>();
            rec.Add(String.Format("'{0}','','','{1}'", PlatformID, asset1));
            rec.Add(String.Format("'{0}','','','{1}'", PlatformID, asset1));

            string Warning_Message = String.Format("Warning: Excel line <3>. Duplicate AssetID <{0}> found and ignored for Target <PlatformID>, Value <{1}> in the input Excel file", asset1.ToLower(), PlatformID_dec) ;

            file1.Insert_Rows(rec, null);

            ExcelFactory f = new ExcelFactory(str_file, null);

            string error;
            string XML;
            string xml_file = f.CreateXMLfile(out error, out XML);

            Assert.IsTrue(File.Exists(xml_file));
            XML = file1.GetXmlString(xml_file);
            
            Assert.IsTrue(error.Contains(Warning_Message), "Following Warning message missing <{0}>", Warning_Message);
        }

        [TestMethod]
        [Owner("srkalyan")]
        [Description("Verifies that proper Warning message is thrown if input Excel file has duplicate AssetsIDs for same TitleID")]
        public void BlacklistTool_Check_Target_TitleID_duplicate_Assets_warning()
        {
            string str_file = Directory.GetCurrentDirectory().ToString() + @"\file1.xlsx";
            ExcelGenerator file1 = new ExcelGenerator(str_file, null);

            string asset1 = "00000AB8-CA3A-82A2-CEA5-E9274C4107E2";
            string TitleID = "4D530914";
            string TitleID_dec = int.Parse(TitleID, System.Globalization.NumberStyles.HexNumber).ToString();

            string Warning_Message = String.Format("Warning: Excel line <3>. Duplicate AssetID <{0}> found and ignored for Target <TitleID>, Value <{1}> in the input Excel file", asset1.ToLower(), TitleID_dec);

            List<string> rec = new List<string>();
            rec.Add(String.Format("'','{0}','','{1}'", TitleID, asset1));
            rec.Add(String.Format("'','{0}','','{1}'", TitleID, asset1));

            file1.Insert_Rows(rec, null);

            ExcelFactory f = new ExcelFactory(str_file, null);

            string error;
            string XML;
            string xml_file = f.CreateXMLfile(out error, out XML);

            Assert.IsTrue(File.Exists(xml_file));
            XML = file1.GetXmlString(xml_file);

            Assert.IsTrue(error.Contains(Warning_Message), "Following Warning message missing <{0}>", Warning_Message);
        }

        [TestMethod]
        [Owner("srkalyan")]
        [Description("Verifies that valid targets - <global>, TitleID and PlatformID from Excel are convereted and stored in XML file")]
        public void BlacklistTool_Check_valid_Targets_globalTitleID_PlatformID()
        {
            string str_file = Directory.GetCurrentDirectory().ToString() + @"\file1.xlsx";
            ExcelGenerator file1 = new ExcelGenerator(str_file, null);

            string asset1_global = "00000008-BDC5-92F2-C959-E411454108C6";
            string asset2_title_id = "00000008-5875-3291-CE0B-59D7444D07D1";
            string asset3_platform_id = "00000000-1111-1111-1111-59D7444D07D1";
            string TitleID = "4D5309A2";
            string TitleID_dec = int.Parse(TitleID, System.Globalization.NumberStyles.HexNumber).ToString();
            string PlatformID = "4D4D4D4D";
            string PlatformID_dec = int.Parse(PlatformID, System.Globalization.NumberStyles.HexNumber).ToString();            

            List<string> rec = new List<string>();
            rec.Add(String.Format("'','','','{0}'", asset1_global));
            rec.Add(String.Format("'','{0}','','{1}'", TitleID, asset2_title_id));
            rec.Add(String.Format("'{0}','','','{1}'", PlatformID, asset3_platform_id));

            file1.Insert_Rows(rec, null);

            ExcelFactory f = new ExcelFactory(str_file, null);

            string error;
            string XML;
            string xml_file = f.CreateXMLfile(out error, out XML);

            Assert.IsTrue(File.Exists(xml_file));
            XML = file1.GetXmlString(xml_file);

            BlacklistedAssets b = (BlacklistedAssets)file1.ToObject(typeof(BlacklistedAssets), XML);

            Assert.IsTrue(Check_XML_Node(b, "global", "0", asset1_global), "Target <global> do not have Asset <{0}> in the XML file <{1}> generated", asset1_global.ToLower(), _xml_file);
            Assert.IsTrue(Check_XML_Node(b, "TitleID", TitleID_dec, asset2_title_id), "Target <TitleID> value <{0}> do not have Asset <{1}> in the XML file <{2}> generated", TitleID_dec, asset2_title_id.ToLower(), _xml_file);
            Assert.IsTrue(Check_XML_Node(b, "PlatformID", PlatformID_dec, asset3_platform_id), "Target <PlatformID> value <{0}> do not have Asset <{1}> in the XML file <{2}> generated", TitleID_dec, asset3_platform_id.ToLower(), _xml_file);
            Assert.IsTrue(String.IsNullOrEmpty(error), "Following unexpected Error and Warnings were thrown <{0}>", error);
        }

        [TestMethod]
        [Owner("srkalyan")]
        [Description("Verifies that valid targets - <global>, TitleID with Description having comma in it gets successfully converted to XML")]
        public void BlacklistTool_Check_Description_with_comma()
        {
            string str_file = Directory.GetCurrentDirectory().ToString() + @"\file1.xlsx";
            ExcelGenerator file1 = new ExcelGenerator(str_file, null);

            string asset1_global = "00000008-BDC5-92F2-C959-E411454108C6";
            string asset2_title_id = "00000008-5875-3291-CE0B-59D7444D07D1";
            string asset3_platform_id = "00000000-1111-1111-1111-59D7444D07D1";
            string TitleID = "4D5309A2";
            string TitleID_dec = int.Parse(TitleID, System.Globalization.NumberStyles.HexNumber).ToString();
            string PlatformID = "4D4D4D4D";
            string PlatformID_dec = int.Parse(PlatformID, System.Globalization.NumberStyles.HexNumber).ToString();

            List<string> rec = new List<string>();

            //Description having comma in it.
            rec.Add(String.Format("'','','test, this','{0}'", asset1_global));
            rec.Add(String.Format("'','{0}','test, this','{1}'", TitleID, asset2_title_id));
            rec.Add(String.Format("'{0}','','test, this','{1}'", PlatformID, asset3_platform_id)); 

            file1.Insert_Rows(rec, null);

            ExcelFactory f = new ExcelFactory(str_file, null);

            string error;
            string XML;
            string xml_file = f.CreateXMLfile(out error, out XML);

            Assert.IsTrue(File.Exists(xml_file));
            XML = file1.GetXmlString(xml_file);

            BlacklistedAssets b = (BlacklistedAssets)file1.ToObject(typeof(BlacklistedAssets), XML);

            Assert.IsTrue(Check_XML_Node(b, "global", "0", asset1_global), "Target <global> do not have Asset <{0}> in the XML file <{1}> generated", asset1_global.ToLower(), _xml_file);
            Assert.IsTrue(Check_XML_Node(b, "TitleID", TitleID_dec, asset2_title_id), "Target <TitleID> value <{0}> do not have Asset <{1}> in the XML file <{2}> generated", TitleID_dec, asset2_title_id.ToLower(), _xml_file);
            Assert.IsTrue(Check_XML_Node(b, "PlatformID", PlatformID_dec, asset3_platform_id), "Target <PlatformID> value <{0}> do not have Asset <{1}> in the XML file <{2}> generated", TitleID_dec, asset3_platform_id.ToLower(), _xml_file);
            Assert.IsTrue(String.IsNullOrEmpty(error), "Following unexpected Error and Warnings were thrown <{0}>", error);
        }

        [TestMethod]
        [Owner("srkalyan")]
        [Description("Verifies that valid GUIDs given withing { } gets successfully converted to XML")]
        public void BlacklistTool_Check_GUIDs_within_bracket()
        {
            string str_file = Directory.GetCurrentDirectory().ToString() + @"\file1.xlsx";
            ExcelGenerator file1 = new ExcelGenerator(str_file, null);

            string asset1_global = "00000008-BDC5-92F2-C959-E411454108C6";
            string asset1_brackets = "{" + asset1_global + "}";
            string asset2_title_id = "00000008-5875-3291-CE0B-59D7444D07D1";
            string asset3_platform_id = "00000000-1111-1111-1111-59D7444D07D1";
            string TitleID = "4D5309A2";
            string TitleID_dec = int.Parse(TitleID, System.Globalization.NumberStyles.HexNumber).ToString();
            string PlatformID = "4D4D4D4D";
            string PlatformID_dec = int.Parse(PlatformID, System.Globalization.NumberStyles.HexNumber).ToString();

            List<string> rec = new List<string>();

            rec.Add(String.Format("'','','','{0}'", asset1_brackets));
            rec.Add(String.Format("'','{0}','','{1}'", TitleID, asset2_title_id));
            rec.Add(String.Format("'{0}','','','{1}'", PlatformID, asset3_platform_id));

            file1.Insert_Rows(rec, null);

            ExcelFactory f = new ExcelFactory(str_file, null);

            string error;
            string XML;
            string xml_file = f.CreateXMLfile(out error, out XML);

            Assert.IsTrue(File.Exists(xml_file));
            XML = file1.GetXmlString(xml_file);

            BlacklistedAssets b = (BlacklistedAssets)file1.ToObject(typeof(BlacklistedAssets), XML);

            Assert.IsTrue(Check_XML_Node(b, "global", "0", asset1_global), "Target <global> do not have Asset <{0}> in the XML file <{1}> generated", asset1_global.ToLower(), _xml_file);
            Assert.IsTrue(Check_XML_Node(b, "TitleID", TitleID_dec, asset2_title_id), "Target <TitleID> value <{0}> do not have Asset <{1}> in the XML file <{2}> generated", TitleID_dec, asset2_title_id.ToLower(), _xml_file);
            Assert.IsTrue(Check_XML_Node(b, "PlatformID", PlatformID_dec, asset3_platform_id), "Target <PlatformID> value <{0}> do not have Asset <{1}> in the XML file <{2}> generated", TitleID_dec, asset3_platform_id.ToLower(), _xml_file);
            Assert.IsTrue(String.IsNullOrEmpty(error), "Following unexpected Error and Warnings were thrown <{0}>", error);
        }

        [TestMethod]
        [Owner("srkalyan")]
        [Description("Verifies that valid GUIDs given withing { } gets successfully converted to XML")]
        public void BlacklistTool_Check_invalid_GUIDs()
        {
            string str_file = Directory.GetCurrentDirectory().ToString() + @"\file1.xlsx";
            ExcelGenerator file1 = new ExcelGenerator(str_file, null);

            string asset1_global = "00000008-BDC5-92F2-C959-E411454108C6";            
            string invalid_asset2_title_id = "00000008-5875-3291-CE0B-7444D07D1"; //invalid GUID
            string asset3_platform_id = "00000000-1111-1111-1111-59D7444D07D1";
            string TitleID = "4D5309A2";
            string TitleID_dec = int.Parse(TitleID, System.Globalization.NumberStyles.HexNumber).ToString();
            string PlatformID = "4D4D4D4D";
            string PlatformID_dec = int.Parse(PlatformID, System.Globalization.NumberStyles.HexNumber).ToString();
            string error_message = "Error!!!: Excel line <3>. AssetID <00000008-5875-3291-ce0b-7444d07d1> is not a valid GUID and ignored\n";

            List<string> rec = new List<string>();

            rec.Add(String.Format("'','','','{0}'", asset1_global));
            rec.Add(String.Format("'','{0}','','{1}'", TitleID, invalid_asset2_title_id));
            rec.Add(String.Format("'{0}','','','{1}'", PlatformID, asset3_platform_id));

            file1.Insert_Rows(rec, null);

            ExcelFactory f = new ExcelFactory(str_file, null);

            string error;
            string XML;
            string xml_file = f.CreateXMLfile(out error, out XML);

            Assert.IsTrue(File.Exists(xml_file));
            XML = file1.GetXmlString(xml_file);

            BlacklistedAssets b = (BlacklistedAssets)file1.ToObject(typeof(BlacklistedAssets), XML);

            Assert.IsTrue(Check_XML_Node(b, "global", "0", asset1_global), "Target <global> do not have Asset <{0}> in the XML file <{1}> generated", asset1_global.ToLower(), _xml_file);
            Assert.IsTrue(!Check_XML_Node(b, "TitleID", TitleID_dec, invalid_asset2_title_id), "Target <TitleID> value <{0}> with invalid GUID Asset <{1}> was added to the the XML file <{2}> generated", TitleID_dec, invalid_asset2_title_id, _xml_file);
            Assert.IsTrue(Check_XML_Node(b, "PlatformID", PlatformID_dec, asset3_platform_id), "Target <PlatformID> value <{0}> do not have Asset <{1}> in the XML file <{2}> generated", TitleID_dec, asset3_platform_id.ToLower(), _xml_file);
            Assert.IsTrue(error.Contains(error_message), "Following error message is missing from the tool <{0}>", error_message);
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.BlacklistTool\UnitTest\ExcelGenerator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data.Common;
using System.Data.OleDb;
using System.IO;
using System.Reflection;
using System.Diagnostics;
using System.Xml;
using System.Xml.Serialization;
using System.Threading;
using Excel = Microsoft.Office.Interop.Excel;

namespace AvatarServices.Test.BlacklistTool
{
    /// <summary>
    /// Class to create excel files for testing
    /// </summary>

    class ExcelGenerator
    {
        /// <summary>
        /// Member valiables to store Excel file name and worksheet name that is used
        /// _header_fields is the header row used
        /// </summary>
        private string _file;
        private string _worksheet;
        private string _header_fields = "PlatformID, TitleID, Description, GUIDs";

        /// <summary>
        /// Constructor take file and worksheet name and creates the a blank excel file with header, mainly for Description field.    
        /// </summary>
        public ExcelGenerator(string strFileName, string strSheetName)
        {
            try
            {
                if (System.IO.File.Exists(strFileName))
                {
                    System.IO.File.SetAttributes(strFileName, FileAttributes.Normal);
                    System.IO.File.Delete(strFileName);
                }

                // Open an instance of excel. Create a new workbook. 
                // A workbook by default has three sheets, so if you just want  
                //a single one, delete sheet 2 and 3 

                Excel.Application xlApp = new Microsoft.Office.Interop.Excel.Application();
                Excel._Workbook xlWB = (Excel._Workbook)xlApp.Workbooks.Add(Missing.Value);

                Excel._Worksheet xlSheet = (Excel._Worksheet)xlWB.Sheets[1];
                ((Excel._Worksheet)xlWB.Sheets[2]).Delete();
                ((Excel._Worksheet)xlWB.Sheets[2]).Delete();

                if (String.IsNullOrEmpty(strSheetName))
                    strSheetName = "blacklist";

                xlSheet.Name = strSheetName;

                // Insert column headers 
                xlSheet.Cells[1, 1] = "PlatformID";
                xlSheet.Cells[1, 2] = "TitleID";
                xlSheet.Cells[1, 3] = "Description";
                xlSheet.Cells[1, 4] = "GUIDs";

                xlWB.SaveAs(strFileName, Missing.Value, Missing.Value, Missing.Value,
                Missing.Value, Missing.Value,
                Microsoft.Office.Interop.Excel.XlSaveAsAccessMode.xlNoChange, Missing.Value,
                Missing.Value, Missing.Value, Missing.Value, Missing.Value);
                xlApp.Quit();

                // Release the COM object, set the Excel variables to Null, and tell the  
                //Garbage Collector to do its thing 
                System.Runtime.InteropServices.Marshal.ReleaseComObject(xlSheet);
                System.Runtime.InteropServices.Marshal.ReleaseComObject(xlWB);
                System.Runtime.InteropServices.Marshal.ReleaseComObject(xlApp);

                xlSheet = null;
                xlWB = null;
                xlApp = null;

                Kill_Excel_Process();

                _file = strFileName;
            }
            catch (System.Runtime.InteropServices.COMException comEx)
            {
                Trace.TraceError(String.Format("ExcelGenerator(): File = <{0}>, SheetName= <{1}>", strFileName, strSheetName));
                throw comEx;
            }
        }


        /// <summary>
        /// Office.Interop.Excel has a issue where it does not close the process on Quit()
        /// This function takes care of closing excel process that was created
        /// </summary>
        private void Kill_Excel_Process()
        {
            try
            {
                GC.Collect();

                System.Diagnostics.Process[] PROC = Process.GetProcessesByName("EXCEL");
                foreach (System.Diagnostics.Process PK in PROC)
                {//User excel process always have window name
                    //COM process do not.
                    if (PK.MainWindowTitle.Length == 0)
                        PK.Kill();
                }
            }
            catch(Exception)
            {
            }
        }

        /// <summary>
        /// This function is used to add data to the excel file
        /// </summary>
        /// <param name="rows">List of rows to be inserted</param>
        /// <param name="worksheet">Worksheet to use to, if null will default to "blacklist"</param>
        /// <returns> DataTable object which contains the input Excel file data</returns>
        public void Insert_Rows(List<string> rows, string worksheet)
        {
            System.Data.OleDb.OleDbConnection MyConnection=null;
            System.Data.OleDb.OleDbCommand myCommand=null;
            try
            {
                if (rows != null)
                {
                    if (String.IsNullOrEmpty(worksheet))
                        this._worksheet = "blacklist";
                    else
                        this._worksheet = worksheet;

                    string CONNECTION_STRING = String.Format("Provider=Microsoft.ACE.OLEDB.12.0;Mode=ReadWrite;Data Source='{0}';Extended Properties=\"Excel 12.0;HDR=No;IMEX=0\"", this._file);                    
                    myCommand = new System.Data.OleDb.OleDbCommand();
                    string sql = null;
                    MyConnection = new System.Data.OleDb.OleDbConnection(CONNECTION_STRING);

                    try
                    {
                        MyConnection.Open();
                    }
                    catch (System.Data.OleDb.OleDbException)
                    { // likely because the Excel just created is having some object, handle references. Retry after some wait.
                        Thread.Sleep(5000);
                        MyConnection.Open();
                    }

                    myCommand.Connection = MyConnection;

                    foreach (string row in rows)
                    {
                        sql = String.Format("Insert into [{0}] ({1}) Values({2})", this._worksheet + "$", this._header_fields, row);
                        myCommand.CommandText = sql;
                        myCommand.ExecuteNonQuery();
                    }
                    MyConnection.Close();
                }
            }            
            finally
            {
                if (MyConnection != null)
                {
                    MyConnection.Close();
                    MyConnection.Dispose();
                }

                if (myCommand != null)
                {
                    myCommand.Dispose();
                }
            }
        }

        /// <summary>
        /// This function for deserialization, takes a xml string and returns back the object
        /// </summary>
        /// <param name="objectType">Object type to be used</param>
        /// <param name="xml">XML string to deserialize</param>
        /// <returns> object. Will be null if unsuccessful</returns>
        public object ToObject(Type objectType, string xml)
        {
            object obj = null;
            try
            {                
                XmlSerializer xs = new XmlSerializer(objectType);
                StringReader sr = new StringReader(xml);
                XmlReader reader = new XmlTextReader(sr);
                obj= xs.Deserialize(reader); 

            }
            catch (Exception)
            {
            }

            return obj;
        }

        /// <summary>
        /// This function to get the XML string from an input file
        /// </summary>
        /// <param name="strFile">file to be used</param>        
        /// <returns> XML as string</returns>
        public string GetXmlString(string strFile)
        {
            string ret = null;
            try
            {
                // Load the xml file into XmlDocument object.
                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.Load(strFile);

                // Now create StringWriter object to get data from xml document.
                StringWriter sw = new StringWriter();
                XmlTextWriter xw = new XmlTextWriter(sw);
                xmlDoc.WriteTo(xw);
                ret = sw.ToString();
            }
            catch (Exception)
            {
            }
            return ret;
        }		
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\Config.cs ===
using System;
using System.Configuration;

namespace AvatarServices.Test.Common
{
	/// <summary>
	/// Class that encapsulates configuration information, parsed from app.config.
	/// </summary>
	public static class Config
	{
        private static EnvironmentSettingsSection envSettings;

        /// <summary>
        /// 
        /// </summary>
        static Config()
        {
            envSettings = (EnvironmentSettingsSection)ConfigurationManager.GetSection("environmentSettings");            
        }

        public static EnvironmentSettingsSection EnvironmentSettings
        {
            get
            {
                return envSettings;
            }
        }

        public static EnvironmentElement Environment
        {
            get
            {
                return envSettings.SelectedEnvironment;
            }
        }        
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\Crypt32.cs ===
#region Using Directives

using System;
using System.Runtime.InteropServices;

#endregion

namespace AvatarServices.Test.Common
{
	#region Public Enums
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// 
	/// </summary>
	[Flags]
	public enum CryptProtectFlags
	{
		CryptProtectUIForbidden = 0x1,
		CryptProtectLocalMachine = 0x4,
		CryptProtectCredSync = 0x8,
		CryptProtectAudit = 0x10,
		CryptProtectNoRecovery = 0x20,
		CryptProtectVerifyProtection = 0x40,
		CryptProtectCredRegenerate = 0x80,
	}

	/// <summary>
	/// 
	/// </summary>
	public enum CertificateEncoding : int
	{
		X509AsnEncoding = 0x1,
		Pkcs7AsnEncoding = 0x00010000,
	}

	/// <summary>
	/// 
	/// </summary>
	public enum CertStoreAddDisposition : int
	{
		/// <summary>
		/// If a matching certificate or a link to a matching certificate exists in the store, the operation fails. The GetLastError function returns the CRYPT_E_EXISTS code.
		/// </summary>
		AddNew = 1,
		/// <summary>
		/// If a matching certificate or a link to a matching certificate exists, that existing certificate or link is used and properties from the new certificate are added. The function does not fail, but it does not add a new context. If ppCertContext is not NULL, the existing context is duplicated. 
		/// If a matching certificate or link to a matching certificate does not exist, a new certificate is added.
		/// </summary>
		AddUseExisting = 2,
		/// <summary>
		/// If a matching certificate or link to a matching certificate exists in the store, the existing certificate or link is deleted and a new certificate is created and added to the store. If a matching certificate or link to a matching certificate does not exist, a new certificate is created and added to the store.
		/// </summary>
		AddReplaceExisting = 3,
		/// <summary>
		/// The function makes no check for an existing matching certificate or link to a matching certificate. A new certificate is always added to the store. This can lead to duplicates in a store.
		/// </summary>
		AddAlways = 4,
		/// <summary>
		/// If a matching certificate exists in the store, that existing context is deleted before creating and adding the new context. The new context inherits properties from the existing certificate.
		/// </summary>
		AddReplaceExistingInheritProperties = 5,
		/// <summary>
		/// If a matching certificate or a link to a matching certificate exists, the function compares the NotBefore times on the certificates. If the existing certificate has a NotBefore time less than the NotBefore time on the new certificate, the old certificate or link is replaced just as with CERT_STORE_ADD_REPLACE_EXISTING. If the existing certificate has a NotBefore time greater than or equal to the NotBefore time on the certificate to be added, the function fails with the GetLastError function returning the CRYPT_E_EXISTS code. 
		/// If a matching certificate or a link to a matching certificate is not found in the store, a new certificate is added to the store.
		/// </summary>
		AddNewer = 6,
		/// <summary>
		/// The action is the same as for CERT_STORE_ADD_NEWER, except that if an older certificate is replaced, the properties of the older certificate are incorporated into the replacement certificate.
		/// </summary>
		AddNewerInheritProperties = 7,
	}
	#endregion

	#region Public Stucts

		#region DataBlob Struct
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	///		The CryptoAPI CRYPTOAPI_BLOB structure is used for an arbitrary array of
	///		bytes. It is declared in Wincrypt.h and provides flexibility for objects
	///		that can contain various data types.
	/// </summary>
	[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
	public struct DataBlob : IDisposable
	{
		#region Variable Declarations
		/// <summary>
		///		Count of bytes in the buffer pointed to by pbData.
		/// </summary>
		private int cbData;
		/// <summary>
		///		Pointer to a block of data bytes.
		/// </summary>
		private IntPtr pbData;

		#endregion

		#region Constructors
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		///		Initializes a new instance of DataBlob.
		/// </summary>
		/// <param name="data">Array of data to place in the DataBlob.</param>
		/// <remarks>
		///		Since the data must be passed to unmanaged code, this constructor
		///		copies the managed data to an unmanaged buffer and stores the
		///		pointer of the buffer.
		/// </remarks>
		public DataBlob(byte[] data)
		{
			cbData = data.Length;
			pbData = Marshal.AllocHGlobal(cbData);
			Marshal.Copy(data, 0, pbData, cbData);
		}
		#endregion

		#region Public Methods
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		///		Returns the data located in the buffer pointer pbData.
		///		This data is typically set by unmanaged code. The data is copied
		///		to a managed array, which is in turn passed to the calling code.
		/// </summary>
		/// <returns>The data located in the buffer pointer pbData.</returns>
		public byte[] GetData()
		{
			if (pbData == IntPtr.Zero)
				return null;
			else
			{
				byte[] data = new byte[cbData];
				Marshal.Copy(pbData, data, 0, cbData);
				return data;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		///		Frees the data buffer pointed to by the pbData member.
		/// </summary>
		/// <remarks>
		///		This structure supports Dispose for convenience, but calling
		///		an interface member (Dispose) will cause boxing. The Close
		///		method doesn't require boxing.
		/// </remarks>
		public void Close()
		{
			if (pbData != IntPtr.Zero)
			{
				Kernel32.ZeroMemory(pbData, cbData);
				Marshal.FreeHGlobal(pbData);
				pbData = IntPtr.Zero;
				cbData = 0;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		///		Frees the data buffer pointed to by the pbData member.
		/// </summary>
		/// <remarks>
		///		This structure supports Dispose for convenience, but calling
		///		an interface member (Dispose) will cause boxing. The Close
		///		method doesn't require boxing.
		/// </remarks>
		public void Dispose()
		{
			Close();
		}
		#endregion
	}
		#endregion

		#region CryptProtectPromptStruct
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	///		The CryptProtectPromptStruct structure provides the text of a prompt
	///		and information about when and where that prompt is to be displayed
	///		when using the CryptProtectData and CryptUnprotectData functions.
	/// </summary>
	[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
	public struct CryptProtectPromptStruct
	{
		/// <summary>
		///		Size of this structure in bytes.
		/// </summary>
		public int cbSize;
		/// <summary>
		///		DWORD flags that indicate when prompts to the user are to be displayed.
		/// </summary>
		public int dwPromptFlags;
		/// <summary>
		///		Window handle to the parent window.
		/// </summary>
		public IntPtr hwndApp;
		/// <summary>
		///		A string containing the text of a prompt to be displayed.
		/// </summary>
		public String szPrompt;
	}
		#endregion

	#endregion

	#region Crypt32 Class
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Summary description for Crypt32.
	/// </summary>
	public class Crypt32
	{
		//HRESULTs found in winerror.h
		/// <summary>
		/// The object or property already exists. (0x80092005)
		/// </summary>
		public const int CryptEExists = -2146885627;        //0x80092005
        public const int CryptENoKeyProperty = -2146885621; //0x8009200B;
        public const int CryptOaep = 0x00000040;
        public const int ProvRsaFull = 1;
        public const string MsBaseProvider = "Microsoft Base Cryptographic Provider v1.0";
        public const string MsEnhancedProvider = "Microsoft Enhanced Cryptographic Provider v1.0";
        public const int CryptNewKeyset = 0x00000008;
        public const int AlgClassDataEncrypt = (3 << 13);
        public const int AlgTypeBlock = (3 << 9);
        public const int AlgSid3Des = 3;
        public const int Calg3Des = (AlgClassDataEncrypt | AlgTypeBlock | AlgSid3Des);
        public const int _192BitKeySize = 0x00C00000;
        public const int CryptExportable = 0x00000001;
        public const int PlainTextKeyBlob = 0x8;

		#region Constructors
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		protected Crypt32()
		{
			
		}
		#endregion

		#region Public Methods
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		///		The CryptProtectData function performs encryption on the data in a
		///		DataBlob structure.
		/// </summary>
		/// <param name="pDataIn">
		///		Pointer to a DataBlob structure containing the plaintext to be encrypted.
		///	</param>
		/// <param name="szDataDescr">
		///		String with a readable description of the data to be encrypted. This 
		///		description string is included with the encrypted data. This parameter is 
		///		optional and can be set to NULL with Windows XP and later. It is required 
		///		and cannot be set to NULL before Windows XP.
		///	</param>
		/// <param name="pOptionalEntropy">
		///		Pointer to a DataBlob structure that contains a password or other
		///		additional entropy used to encrypt the data. The DataBlob structure used
		///		in the encryption phase must also be used in the decryption phase. This
		///		parameter can be set to NULL for no additional entropy.
		/// </param>
		/// <param name="pvReserved">Reserved for future use and must be set to NULL.</param>
		/// <param name="pPromptStruct">
		///		Pointer to a CryptProtectPromptStruct structure that provides information
		///		about where and when prompts are to be displayed and what the content of
		///		those prompts should be. The parameter is optional and can be set to NULL
		///		in both the encryption and decryption phases.
		/// </param>
		/// <param name="dwFlags">
		///		See the CRYPTPROTECT_UI_FORBIDDEN and CRYPTPROTECT_LOCAL_MACHINE constants.
		/// </param>
		/// <param name="pDataOut">
		///		Pointer to a DataBlob structure that receives the encrypted data.
		/// </param>
		/// <returns>
		///		If the function succeeds, the return value is TRUE.
		///		If the function fails, the return value is FALSE. For extended error
		///		information, call GetLastError.
		/// </returns>
		/// <remarks>
		///		Typically, only a user with the same logon credential as the 
		///		encrypter can decrypt the data. In addition, the encryption and 
		///		decryption usually must be done on the same computer.
		/// </remarks>
		[DllImport("Crypt32.dll", SetLastError=true, CharSet=CharSet.Unicode)]
		public static extern bool CryptProtectData(
			[In()]ref DataBlob pDataIn,
			[In()]string szDataDescr, 
			[In()]ref DataBlob pOptionalEntropy,
			[In()]IntPtr pvReserved, 
			[In()]ref CryptProtectPromptStruct pPromptStruct,
			[In()]int dwFlags, 
			ref DataBlob pDataOut);

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		///		The CryptUnprotectData function decrypts and does an integrity check of
		///		the data in a DataBlob structure. Usually, only a user with the same
		///		logon credentials as the encrypter can decrypt the data. In addition,
		///		the encryption and decryption must be done on the same computer.
		/// </summary>
		/// <param name="pDataIn">
		///		Pointer to a DataBlob structure that holds the encrypted data. The 
		///		DataBlob structure's cbData member holds the length of the pbData 
		///		member's byte string that contains the text to be encrypted.
		/// </param>
		/// <param name="szDataDescr">
		///		Pointer to a string readable description of the encrypted data included
		///		with the encrypted data is placed. This parameter is optional and can be
		///		set to NULL.
		/// </param>
		/// <param name="pOptionalEntropy">
		///		Pointer to a DataBlob structure containing a password or other additional
		///		entropy used when the data was encrypted. This parameter is optional and
		///		can be set to NULL; however, if an optional entropy DataBlob structure
		///		was used in the encryption phase, that same DataBlob structure must be
		///		used for the decryption phase.
		/// </param>
		/// <param name="pvReserved">Reserved for future use and must be set to NULL.</param>
		/// <param name="pPromptStruct">
		///		Pointer to a CryptProtectPromptStruct structure that provides information
		///		about where and when prompts are to be displayed and what the content of
		///		those prompts should be. This parameter is optional and can be set to NULL.
		/// </param>
		/// <param name="dwFlags">
		///		See the CRYPTPROTECT_UI_FORBIDDEN and CRYPTPROTECT_LOCAL_MACHINE constants.
		/// </param>
		/// <param name="pDataOut">
		///		Pointer to a DataBlob structure where the function stores the decrypted data.
		/// </param>
		/// <returns></returns>
		[DllImport("Crypt32.dll", SetLastError=true, CharSet=CharSet.Unicode)]
		public static extern bool CryptUnprotectData(
			[In()]ref DataBlob pDataIn,
			string szDataDescr,
			[In()]ref DataBlob pOptionalEntropy,
			[In()]IntPtr pvReserved, 
			[In()]ref CryptProtectPromptStruct pPromptStruct,
			[In()]int dwFlags, 
			ref DataBlob pDataOut);

		/// <summary>
		/// 
		/// </summary>
		/// <param name="hCertStore"></param>
		/// <param name="certEncodingType"></param>
		/// <param name="certEncoded"></param>
		/// <param name="certEncodedSize"></param>
		/// <param name="addDisposition"></param>
		/// <param name="certContext"></param>
		/// <returns></returns>
		[DllImport("Crypt32.dll", SetLastError = true)]
		public static extern bool CertAddEncodedCertificateToStore(
			[In] IntPtr hCertStore,
			[In] CertificateEncoding certEncodingType,
			[In] byte[] certEncoded,
			[In] int certEncodedSize,
		    [In] CertStoreAddDisposition addDisposition,
			[Out] IntPtr certContext);

		/// <summary>
		/// 
		/// </summary>
		/// <param name="certContext"></param>
		/// <returns></returns>
		[DllImport("Crypt32.dll", SetLastError = true)]
		public static extern bool CertDeleteCertificateFromStore([In] IntPtr certContext);

		/// <summary>
		/// 
		/// </summary>
		/// <param name="certContext"></param>
		/// <returns></returns>
		[DllImport("Crypt32.dll", SetLastError = true)]
		public static extern bool CertFreeCertificateContext([In] IntPtr certContext);

		/// <summary>
		/// 
		/// </summary>
		/// <param name="certEncodingType"></param>
		/// <param name="certEncoded"></param>
		/// <param name="certEncodedSize"></param>
		/// <returns></returns>
		[DllImport("Crypt32.dll", SetLastError = true)]
		public static extern IntPtr CertCreateCertificateContext(
			CertificateEncoding certEncodingType,
			byte[] certEncoded,
			int certEncodedSize);

		/// <summary>
		/// 
		/// </summary>
		/// <param name="hCertStore"></param>
		/// <param name="certContext"></param>
		/// <param name="addDisposition"></param>
		/// <param name="certContext"></param>
		/// <returns></returns>
		[DllImport("Crypt32.dll", SetLastError = true)]
		public static extern bool CertAddCertificateContextToStore(
			IntPtr hCertStore,
			IntPtr certContext,
			[In] CertStoreAddDisposition addDisposition,
		    [Out] IntPtr pCertContext);

        /// <summary>
        /// Duplicates a certificate context by incrementing its reference count
        /// </summary>
        /// <param name="certContext">Pointer to the CERT_CONTEXT structure to duplicate.</param>
        /// <returns>Currently, a copy is not made of the context, and the returned pointer to a context has the same value as the pointer to a context that was input. If the pointer passed into this function is NULL, NULL is returned.</returns>
        [DllImport("Crypt32.dll", SetLastError = true)]
        public static extern IntPtr CertDuplicateCertificateContext(IntPtr certContext);

        /// <summary>
        /// Duplicates a store handle by incrementing the store's reference count.
        /// </summary>
        /// <param name="certStoreContext">Handle to the certificate store to duplicate.</param>
        /// <returns>Currently, a copy is not made of the handle and the returned handle is the same as the handle that was input. If NULL is passed in, the called function will raise an access violation exception.</returns>
        [DllImport("Crypt32.dll", SetLastError = true)]
        public static extern IntPtr CertDuplicateStore(IntPtr certStoreContext);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="hCryptProv"></param>
        /// <param name="dwCertEncodingType"></param>
        /// <param name="pInfo"></param>
        /// <param name="phKey"></param>
        /// <returns></returns>
        [DllImport("Crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern bool CryptImportPublicKeyInfo(
            IntPtr hCryptProv,
            CertificateEncoding dwCertEncodingType,
            IntPtr pInfo,
            ref IntPtr phKey);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pCert"></param>
        /// <param name="dwFlags"></param>
        /// <param name="pvReserved"></param>
        /// <param name="phCryptProv"></param>
        /// <param name="pdwKeySpec"></param>
        /// <param name="pfCallerFreeProv"></param>
        /// <returns></returns>
        [DllImport("Crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern bool CryptAcquireCertificatePrivateKey(
            IntPtr pCert,
            uint dwFlags,
            IntPtr pvReserved,
            out IntPtr phCryptProv,
            out uint pdwKeySpec,
            out bool pfCallerFreeProv);

		#endregion
	}
	#endregion	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\BlacklistedAssets.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using System.Xml.Serialization;
using Infrastructure.Test;

namespace AvatarServices.Test.Common
{
    /// <summary>
    /// Instance of Use Response derived from Use Response Xml.
    /// </summary>
    [XmlRoot("BlackListedAssets", Namespace = "http://xboxlive/avatar/BlacklistedAssets.xsd/")]
    public class BlacklistedAssets : SerializerExtension
    {
        /// <summary>
        /// Collection of Asserts for the designated Target
        /// </summary>
        [XmlElement(ElementName = "Assets")]
        public List<AssetsElements> Assets { get; set; }

        public BlacklistedAssets()
        {
            // Set the default namespace
            this.Xmlns = new System.Xml.Serialization.XmlSerializerNamespaces(
                            new XmlQualifiedName[] 
                                { 
                                    new XmlQualifiedName(string.Empty, "http://xboxlive/avatar/BlacklistedAssets.xsd/") 
                                }
                            );
        }

        /// <summary>
        /// Add an Assests Element and create a single Asset
        /// </summary>
        /// <param name="Target">Target Type</param>
        /// <param name="Value">Value of the 'Value' attribute</param>
        /// <param name="AssetGuid">Guid of the Asset to be added to the BlackList</param>
        /// <returns>Return the index of the newly added Assets Element</returns>
        public int Add(string Target, string Value, string AssetGuid)
        {
            int index;

            index = Add(Target, Value);

            this.Assets[index].Add(AssetGuid);

            return index;
        }

        /// <summary>
        /// Add an Assests Element
        /// </summary>
        /// <param name="Target">Target Type</param>
        /// <param name="Value">Value of the 'Value' attribute</param>
        /// <returns>Return the index of the newly added Assets Element</returns>
        public int Add(string Target, string Value)
        {
            AssetsElements Asset;

            if (this.Assets == null)
            {
                this.Assets = new List<AssetsElements>();
            }

            Asset = new AssetsElements();

            Asset.Target = Target;
            Asset.Value = Value;

            Assets.Add(Asset);

            return Assets.Count - 1;
        }


        /// <summary>
        /// Checks if given string is a valid GUID.
        /// </summary>
        /// <param name="str_guid">guid string value</param>
        /// <returns>Return true if string is a valud GUID and false if not</returns>  
        private bool IsValidGuid(string str_guid)
        {
            try
            {
                Guid g = new Guid(str_guid);
                return true;
            }
            catch
            {
                return false;
            }
            
        } 

        /// <summary>
        /// Constructs Assests list and adds items to the list on each call. This will be serialized to create XML.
        /// </summary>
        /// <param name="Target">Target Type</param>
        /// <param name="Value">Value of the 'Value' attribute</param>
        /// <param name="Description">Description of the asset</param> TODO: Add them as comments in XML.
        /// <param name="GUIDs">AssetIDs</param>
        /// <param name="error">string to store and return the errors while process the input from Excel file</param>
        /// <returns>Return true if item was added successful to the Assests list and false if not</returns>  
        public bool Add_Asset(string target, string value, string Description, string GUIDs, ref string error, int line)
        {
            if (!String.IsNullOrEmpty(value))
            {
                value = int.Parse(value, System.Globalization.NumberStyles.HexNumber).ToString();
            }

            if (!String.IsNullOrEmpty(GUIDs))
            {
                GUIDs = GUIDs.ToLower().Replace('{', ' ').Replace('}', ' ').Trim();

                if(!IsValidGuid(GUIDs))
                {
                    error = error + String.Format("Error!!!: Excel line <{0}>. AssetID <{1}> is not a valid GUID and ignored\n", line, GUIDs);
                    return false; // row is skipped and not added to XML.               
                }
            }            

            if (Assets == null)
            {
                if (!String.IsNullOrEmpty(target) && !String.IsNullOrEmpty(value))
                {
                    AssetsElements e1 = new AssetsElements();

                    e1.Target = target;
                    e1.Value = value;

                    if (!String.IsNullOrEmpty(GUIDs))
                        e1.Add(GUIDs);

                    // Creating the list here, first item added.
                    Assets = new List<AssetsElements>();
                    Assets.Add(e1);

                    return true;
                }
                return false;
            }
            else
            {                
                //List alread exist and we need to construct and add new item to the list.
                foreach (AssetsElements element in Assets)
                {
                    //first we go through the existing list and see if Target, Value node is already there, if it exists we add the AssetID under this.
                    if (element.Target.Equals(target) && element.Value.Equals(value))
                    {
                        
                        // Here the Target and Value already exist and we just need to add AssetIDs
                        if(!String.IsNullOrEmpty(GUIDs))
                        {

                            if (element.AssetIDs == null)
                            {
                                element.Add(GUIDs); //adding AssetID to existing element
                                return true;
                            }

                            foreach (string AssetID in element.AssetIDs)
                            {
                                if (AssetID.Equals(GUIDs))
                                {
                                    error = error + String.Format("Warning: Excel line <{0}>. Duplicate AssetID <{1}> found and ignored for Target <{2}>, Value <{3}> in the input Excel file \n", line, AssetID, target, value);
                                    return false; // duplicate element
                                }
                            }                       
                                                        
                            element.Add(GUIDs); //adding AssetID to existing element
                            return true;
                        }

                        error = error + String.Format("Warning: Excel line <{0}>. Empty AssetID is found and ignored for Target <{1}>, Value <{2}> in the input Excel file \n", line, target, value);
                        return false; //we don't want to add empty Assets under existing Target and Value node and return false
                    }
                }                

                //we are here because the Target and Vaue node we are processing is new and the Assets list already exist, so need to create a new element.
                if (!String.IsNullOrEmpty(target) && !String.IsNullOrEmpty(value))
                {
                    AssetsElements e2 = new AssetsElements();

                    e2.Target = target;
                    e2.Value = value;

                    if (!String.IsNullOrEmpty(GUIDs))
                        e2.Add(GUIDs);

                    Assets.Add(e2); //Adding new Element to Assets list.                    
                    return true;
                }                            
            }

            return false;       
        }
    }

    /// <summary>
    /// Collection of Asserts for the designated Target
    /// </summary>
    [XmlRoot(ElementName = "Assets")]
    public partial class AssetsElements : SerializerExtension
    {
        [XmlAttributeAttribute(AttributeName = "target")]
        public string Target { get; set; }

        [XmlAttributeAttribute(AttributeName = "value")]
        public string Value { get; set; }

        [XmlElement(ElementName = "AssetID")]
        public List<string> AssetIDs { get; set; }

        /// <summary>
        /// Add a new AssetID
        /// </summary>
        /// <param name="AssetGuid">Guid of the Asset to be added to the BlackList</param>
        /// <returns>Return the index of the newly added AssetID</returns>
        public int Add(string AssetGuid)
        {            
            if (AssetIDs == null)
            {
                AssetIDs = new List<string>();
            }           

            AssetIDs.Add(AssetGuid);

            return AssetIDs.Count - 1;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\ColorConsoleTraceListener.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.Globalization;

namespace AvatarServices.Test.Common
{
    /// <summary>
    /// 
    /// </summary>
    public class ColorConsoleTraceListener : TextWriterTraceListener
    {
        private bool showSource;

        /// <summary>
        /// 
        /// </summary>
        public ColorConsoleTraceListener()
            : this(true)
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="showSource"></param>
        public ColorConsoleTraceListener(bool showSource)
            : base(Console.Out)
        {
            this.showSource = showSource;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="eventCache"></param>
        /// <param name="source"></param>
        /// <param name="eventType"></param>
        /// <param name="id"></param>
        /// <param name="message"></param>
        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message)
        {
            if ((this.Filter != null) && !this.Filter.ShouldTrace(eventCache, source, eventType, id, message, null, null, null))
                return;

            try
            {
                Console.ForegroundColor = ConsoleColor.White;
                this.WriteHeader(source, eventType, id);

                switch (eventType)
                {
                    case TraceEventType.Start:
                    case TraceEventType.Stop:
                        {
                            Console.ForegroundColor = ConsoleColor.Green;
                            break;
                        }
                    case TraceEventType.Verbose:
                        {
                            Console.ForegroundColor = ConsoleColor.Gray;
                            break;
                        }
                    case TraceEventType.Information:
                        {
                            Console.ForegroundColor = ConsoleColor.Blue;
                            break;
                        }
                    case TraceEventType.Warning:
                        {
                            Console.ForegroundColor = ConsoleColor.Yellow;
                            break;
                        }
                    case TraceEventType.Error:
                    case TraceEventType.Critical:
                        {
                            Console.ForegroundColor = ConsoleColor.Red;
                            break;
                        }
                }

                base.WriteLine(message);

                Console.ForegroundColor = ConsoleColor.White;
                this.WriteFooter(eventCache);
            }
            finally
            {
                Console.ResetColor();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="eventCache"></param>
        /// <param name="source"></param>
        /// <param name="eventType"></param>
        /// <param name="id"></param>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, params object[] args)
        {
            TraceEvent(eventCache, source, eventType, id, String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void WriteIndent()
        {
            this.NeedIndent = false;
            for (int i = 0; i < this.IndentLevel; i++)
            {
                for (int j = 0; j < this.IndentSize; j++)
                    this.Write("\t");
            }
            //base.WriteIndent();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="source"></param>
        /// <param name="type"></param>
        /// <param name="id"></param>
        protected virtual void WriteHeader(string source, TraceEventType type, int id)
        {
            StringBuilder header = new StringBuilder();
            if (this.showSource)
                header.AppendFormat("{0} ", source);
            header.AppendFormat("{0}: ", type);
            if (id != 0)
                header.AppendFormat("{0}: ", id);
            this.Write(header.ToString());
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="cache"></param>
        protected virtual void WriteFooter(TraceEventCache eventCache)
        {
            if (eventCache != null)
            {
                base.IndentLevel++;
                if (this.IsEnabled(TraceOptions.ProcessId))
                {
                    this.WriteLine("ProcessId=" + eventCache.ProcessId);
                }
                if (this.IsEnabled(TraceOptions.LogicalOperationStack))
                {
                    this.Write("LogicalOperationStack=");
                    Stack logicalOperationStack = eventCache.LogicalOperationStack;
                    bool flag = true;
                    foreach (object obj2 in logicalOperationStack)
                    {
                        if (!flag)
                        {
                            this.Write(", ");
                        }
                        else
                        {
                            flag = false;
                        }
                        this.Write(obj2.ToString());
                    }
                    this.WriteLine(string.Empty);
                }
                if (this.IsEnabled(TraceOptions.ThreadId))
                {
                    this.WriteLine("ThreadId=" + eventCache.ThreadId);
                }
                if (this.IsEnabled(TraceOptions.DateTime))
                {
                    //this POS is in UTC; convert to local
                    DateTime local = TimeZoneInfo.ConvertTimeFromUtc(eventCache.DateTime, TimeZoneInfo.Local);
                    this.WriteLine("DateTime=" + local.ToString("MM/dd/yyyy hh:mm:ss.ffff tt"));
                }
                if (this.IsEnabled(TraceOptions.Timestamp))
                {
                    this.WriteLine("Timestamp=" + eventCache.Timestamp);
                }
                if (this.IsEnabled(TraceOptions.Callstack))
                {
                    this.WriteLine("Callstack=" + eventCache.Callstack);
                }
                base.IndentLevel--;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="opts"></param>
        /// <returns></returns>
        protected bool IsEnabled(TraceOptions opts)
        {
            return ((opts & this.TraceOutputOptions) != TraceOptions.None);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\Kernel32.cs ===
#region Using Directives

using System;
using System.Runtime.InteropServices;
using System.Text;

#endregion

namespace AvatarServices.Test.Common
{
	#region Public Enums
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// 
	/// </summary>
	[Flags]
	public enum FormatMessageFlags
	{
		FormatMessageAllocateBuffer = 0x00000100,
		/// <summary>
		/// Ignores the arguments parameter of the FormatMessage function
		/// </summary>
		FormatMessageIgnoreInserts = 0x00000200,
		FormatMessageFromString = 0x00000800,
		/// <summary>
		/// Causes FormatMessage to search the system table of error codes
		/// </summary>
		FormatMessageFromSystem = 0x00001000,
		FormatMessageArgumentArray = 0x00002000,
	}
	#endregion

	#region Public Structs
	/// <summary>
	/// 
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct SecurityAttributes
	{
		public int Length;
		public IntPtr lpSecurityDescriptor;
		public bool bInheritHandle;
	}
	#endregion

	#region Kernel32 Class
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Summary description for Kernel32.
	/// </summary>
	public static class Kernel32
	{
		#region Constants

		public const int STD_INPUT_HANDLE = -10;
		public const int STD_ERROR_HANDLE = -12;

		#endregion

		#region Public Methods
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		///		Fills a memory buffer with zeroes.
		/// </summary>
		/// <param name="ptr">Pointer to the memory buffer to be filled with zeroes.</param>
		/// <param name="cnt">Number of bytes in the buffer.</param>
		[DllImport("kernel32.dll", EntryPoint="RtlZeroMemory")]
		public static extern void ZeroMemory([In()]IntPtr ptr, [In()]int cnt);

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		///		Formats and returns string messages
		/// </summary>
		/// <param name="dwFlags">See FORMAT_MESSAGE_IGNORE_INSERTS and FORMAT_MESSAGE_FROM_SYSTEM</param>
		/// <param name="lpSource">
		///		Pointer to source string, or module handle containing message specified by MessageId
		///	</param>
		/// <param name="dwMessageId">Identifier to the message</param>
		/// <param name="dwLanguageId">
		///		Language identifier used to return localized messages. Passing 0 causes FormatMessage
		///		to search for the neutral ID, followed by the current language ID (for the thread), 
		///		and then default user and system language ID, followed by the ID for English U.S.
		/// </param>
		/// <param name="lpBuffer">Pointer to the buffer to be filled with the resulting message</param>
		/// <param name="nSize">Size of the buffer pointed to by lpBuffer</param>
		/// <param name="Arguments">Optional insertion arguments</param>
		/// <returns></returns>
		[DllImport("kernel32.dll", SetLastError=true, EntryPoint="FormatMessageW", CharSet=CharSet.Auto)]
		public static extern int FormatMessage(
			[In()]int dwFlags,
			[In()]IntPtr lpSource,
			[In()]int dwMessageId,
			[In()]int dwLanguageId,
			StringBuilder lpBuffer,
			[In()]int nSize,
			[In()]IntPtr Arguments);

		/// <summary>
		/// 
		/// </summary>
		/// <param name="handle"></param>
		/// <returns></returns>
		[DllImport("kernel32.dll", CharSet = CharSet.Auto)]
		public static extern bool CloseHandle(IntPtr handle);

		/// <summary>
		/// 
		/// </summary>
		/// <param name="whichHandle"></param>
		/// <returns></returns>
		[DllImport("kernel32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
		public static extern IntPtr GetStdHandle(int handleType);

		/// <summary>
		/// 
		/// </summary>
		/// <param name="hReadPipe"></param>
		/// <param name="hWritePipe"></param>
		/// <param name="lpPipeAttributes"></param>
		/// <param name="nSize"></param>
		/// <returns></returns>
		[DllImport("kernel32.dll")]
		static extern bool CreatePipe(out IntPtr hReadPipe, out IntPtr hWritePipe, ref SecurityAttributes lpPipeAttributes, uint nSize);

		/// <summary>
		/// 
		/// </summary>
		/// <returns></returns>
		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int GetConsoleOutputCP();

		#endregion
	}
	#endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\SetupException.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AvatarServices.Test.Common
{
    /// <summary>
    /// Class representing an error during setup for the tests.
    /// </summary>
    public class SetupException : Exception
    {
        public SetupException(string message) : base(message) { }
        public SetupException(string message, Exception innerException) : base(message, innerException) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\EventIDs.cs ===
﻿namespace AvatarServices.Test.Common
{
    /// <summary>
    /// Used to describe the different expected events within the Event Viewer
    /// </summary>
    public enum EventIDs : int
    {
        SSR_UnrecognizedMessageFormat = 100,
        SSR_UnrecognizedMessageVersion = 101,
        SSR_MessageNotProcessed = 102,
        SSR_MessageProcessorStarted = 103,
        SSR_MessageProcessorStopped = 104,
        SSR_ServiceBrokerErrorMessage = 105,
        SSR_ImageGenerationFailed = 106,
        SSR_InvalidMessageData = 107,
        SSR_ReceiverConstructionFailure = 108,
        SSR_GamerProfileRetrievalFailure = 109,
        SSR_ManifestNotFound = 110,
        SSR_MessageReceiveFailure = 111,
        SSR_RandomPoseConfigurationLoaded = 112,
        SSR_InvalidPoseConfiguration = 113,
        SSR_EndReceiveFailure = 114,
        SSR_StartupFailure = 115,
        SSR_FailedToLoadBackgroundImage = 122,

        BLACKLIST_FileLoadFailureEvent = 1000,
        BLACKLIST_FileLoadSuccessEvent = 1001,

        LIVECACHE_UnknownError = 4215
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\TestSettings.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AvatarServices.Test.Common
{
    public static class TestSettings
    {
        public const int MAX_GAMERTAG_LENGTH = 15;
        public const string PASSPORT_DOMAIN = "xboxtest.com";
        public const string PASSPORT_PASSWORD = "supersecret";
        public const int MAX_MANIFESTS = 16;  // todo(jinsuh): get it from the health page which may or may not expose npdb settings
        public const int MAX_URL_LENGTH = 2100;
        public const string VALID_GAMERTAG_CHARACTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890 ";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\TestHookFactory.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Core.TestService;
using Leet.Core.TestService.Client.AvatarServices;
using AvatarServices.Test.Common;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Avatar.Services.ServerSideRenderer.Messaging;
using System.Diagnostics;
using System.IO;
using System.Threading;
using System.Xml;
using System.Xml.Serialization;

namespace AvatarServices.Test.Common
{
    public class TestHookFactory
    {
        #region Constructor/Field/Properties
        private TestHookFactory()
        {
            try
            {
                if (Config.Environment.SsrUseTestService)
                    this.ssrService = new SSRTestService(Config.Environment.CoreTestServiceBaseUrl);
                else
                    this.ssrService = new SSRService(Config.Environment.SsrDevServiceAccount);
            }
            catch (Exception ex)
            {
                Assert.Inconclusive("There was an error initializing SSR service: " + ex.ToString());
            }
        }

        private static object _lockObject = new object();
        private static TestHookFactory _instance;
        public static TestHookFactory Instance
        {
            get
            {
                if (_instance == null)
                {
                    lock (_lockObject)
                    {
                        if (_instance == null)
                        {
                            _instance = new TestHookFactory();
                        }
                    }
                }
                return _instance;
            }
        }

        private ISSRService ssrService;
        public ISSRService SSRService
        {
            get { return this.ssrService; }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\TraceEx.cs ===
﻿using System;
using System.Reflection;
using System.Diagnostics;

namespace AvatarServices.Test.Common
{
    /// <summary>
    /// 
    /// </summary>
    public static class TraceEx
    {
        private static Type internalTraceType = Type.GetType("System.Diagnostics.TraceInternal, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", true, true);
        private static MethodInfo traceEvent = internalTraceType.GetMethod("TraceEvent");

        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceVerbose(string format, params object[] args)
        {
            TraceVerbose(String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceVerbose(string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Verbose, 0, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceStart(string format, params object[] args)
        {
            TraceStart(String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceStart(string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Start, 0, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceStop(string format, params object[] args)
        {
            TraceStop(String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceStop(string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Stop, 0, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="type"></param>
        /// <param name="id"></param>
        /// <param name="message"></param>
        public static void TraceEvent(TraceEventType type, int id, string message)
        {
            traceEvent.Invoke(null, new object[] { type, id, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="type"></param>
        /// <param name="id"></param>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceEvent(TraceEventType type, int id, string format, params object[] args)
        {
            traceEvent.Invoke(null, new object[] { type, id, format, args });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceError(string format, params object[] args)
        {
            TraceError(String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceError(string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Error, 1000, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="eventId"></param>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceError(int eventId, string format, params object[] args)
        {
            TraceError(eventId, String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceError(int eventId, string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Error, eventId, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="eventId"></param>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceWarning(int eventId, string format, params object[] args)
        {
            TraceWarning(eventId, String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceWarning(int eventId, string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Warning, eventId, message, null });
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\TestHelper.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Runtime.Serialization;
using System.Text;

namespace AvatarServices.Test.Common
{
    /// <summary>
    /// Represents helper methods.
    /// </summary>
    public static class TestHelper
    {
        #region XML Serialization helper methods
        /// <summary>
        /// Loads an object using a data contract.
        /// </summary>
        /// <param name="TypeOfObject">The type of the object to load.</param>
        /// <param name="XMLFileName">The XML filename which contains the serialized object.</param>
        /// <returns>An object which is stored in the specified XML file.</returns>
        public static object LoadDataContract(Type TypeOfObject, string XMLFileName)
        {
            DataContractSerializer m_Serializer = new DataContractSerializer(TypeOfObject);
            object m_StateObject;

            using (FileStream m_Reader = new FileStream(XMLFileName, FileMode.Open))
            {
                m_StateObject = m_Serializer.ReadObject(XmlDictionaryReader.CreateTextReader(m_Reader, XmlDictionaryReaderQuotas.Max));
            }

            return m_StateObject;
        }

        /// <summary>
        /// Saves the specified object to the specified XML file.
        /// </summary>
        /// <param name="ObjectToSave">The object to save.</param>
        /// <param name="XMLFileName">The XML filename where the object will be saved.</param>
        public static void SaveXmlObject(object ObjectToSave, string XMLFileName)
        {
            XmlSerializer m_Serializer = new XmlSerializer(ObjectToSave.GetType());

            using (TextWriter m_Writer = new StreamWriter(XMLFileName, false))
            {
                m_Serializer.Serialize(m_Writer, ObjectToSave);
            }
        }

        /// <summary>
        /// Load an object from the specified XML file.
        /// </summary>
        /// <param name="TypeOfObject">The type of the object to load.</param>
        /// <param name="XMLFileName">The XML filename which contains the serialized object.</param>
        /// <returns>An object which is stored in the specified XML file.</returns>
        public static object LoadXmlObject(Type TypeOfObject, string XMLFileName)
        {
            XmlSerializer m_Serializer = new XmlSerializer(TypeOfObject);
            object m_StateObject;

            using (TextReader m_Reader = new StreamReader(XMLFileName))
            {
                m_StateObject = m_Serializer.Deserialize(m_Reader);
            }

            return m_StateObject;
        }

        /// <summary>
        /// Gets an object created from the specified text.
        /// </summary>
        /// <param name="TypeOfObject">The type of the object contained in the text.</param>
        /// <param name="Text">The text from which the object will be created.</param>
        /// <returns>An object representing the data stored in the specified text.</returns>
        public static object GetDataContractObjectFromText(Type TypeOfObject, string Text)
        {
            DataContractSerializer m_Serializer = new DataContractSerializer(TypeOfObject);
            Stream m_TextStream = new MemoryStream(Encoding.ASCII.GetBytes(Text));
            return m_Serializer.ReadObject(m_TextStream);
        }

        /// <summary>
        /// Gets an object create from xml text using XmlSerializer.
        /// </summary>
        /// <param name="TypeOfObject">The type of the object contained in the text.</param>
        /// <param name="xmlText">The text from which the object will be created.</param>
        /// <returns>An object representing the data stored in the specified text.</returns>
        public static object LoadObjectFromXmlText(Type TypeOfObject, string xmlText)
        {
            XmlSerializer xs = new XmlSerializer(TypeOfObject);
            Stream m_TextStream = new MemoryStream(Encoding.ASCII.GetBytes(xmlText));
            return xs.Deserialize(m_TextStream);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\XmlDocumentEx.cs ===
using System;
using System.Xml;
using System.IO;
using System.Text;
using System.Security;
using System.Collections.Specialized;

namespace AvatarServices.Test.Common
{
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	public class XmlDocumentEx: XmlDocument
	{
		protected XmlNamespaceManager nsmgr;
		protected bool hasNamespaces = false;
		protected NameValueCollection defaultNamespaces = new NameValueCollection();
		protected bool useCdata = false;

		/// <summary>
		/// 
		/// </summary>
		public const string DefaultNamespacePrefix = "dfltns";

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public XmlDocumentEx(): base()
		{
			InternalContructor(null, null, null, false);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xml"></param>
		public XmlDocumentEx(string xml): base()
		{
			InternalContructor(xml, null, null, false);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xml"></param>
		/// <param name="loadNamespaces"></param>
		public XmlDocumentEx(string xml, bool loadNamespaces): base()
		{
			InternalContructor(xml, null, null, loadNamespaces);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xml"></param>
		public XmlDocumentEx(Stream xml): base()
		{
			InternalContructor(null, xml, null, false);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xml"></param>
		/// <param name="loadNamespaces"></param>
		public XmlDocumentEx(Stream xml, bool loadNamespaces): base()
		{
			InternalContructor(null, xml, null, loadNamespaces);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xml"></param>
		public XmlDocumentEx(XmlDocument xml): base()
		{
			InternalContructor(null, null, xml, false);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xml"></param>
		/// <param name="loadNamespaces"></param>
		public XmlDocumentEx(XmlDocument xml, bool loadNamespaces): base()
		{
			InternalContructor(null, null, xml, loadNamespaces);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public XmlNamespaceManager NamespaceManager
		{
			get
			{
				return this.nsmgr;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public bool HasNamespaces
		{
			get
			{
				return this.hasNamespaces;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public NameValueCollection DefaultNamespaces
		{
			get
			{
				return this.defaultNamespaces;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public bool UseCdata
		{
			get
			{
				return this.useCdata;
			}
			set
			{
				this.useCdata = value;

				if(this.DocumentElement !=  null)
				{
					UpdateCdataInXml(this.DocumentElement, value);
				}
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="filename"></param>
		/// <param name="loadNamespaces"></param>
		public void Load(string filename, bool loadNamespaces)
		{
			base.Load(filename);

			if(loadNamespaces)
			{
				LoadNamespaces();
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <returns></returns>
		public string FormatXml()
		{
			return FormatXml(Encoding.UTF8, 1, '\t', '"');
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="indentation"></param>
		/// <param name="indentChar"></param>
		/// <param name="quoteChar"></param>
		/// <returns></returns>
		public string FormatXml(int indentation, char indentChar, char quoteChar)
		{
			return FormatXml(Encoding.UTF8, indentation, indentChar, quoteChar);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="encoding"></param>
		/// <param name="indentation"></param>
		/// <param name="indentChar"></param>
		/// <param name="quoteChar"></param>
		/// <returns></returns>
		public string FormatXml(Encoding encoding, int indentation, char indentChar, char quoteChar)
		{
			MemoryStream memoryStream = new MemoryStream();
			XmlTextWriter xmlWriter = null;
			string formattedXml;

			try
			{
				xmlWriter = new XmlTextWriter(memoryStream, encoding);
				xmlWriter.Formatting = Formatting.Indented;
				xmlWriter.Indentation = indentation;
				xmlWriter.IndentChar = indentChar;
				xmlWriter.QuoteChar = quoteChar;
				xmlWriter.Namespaces = (this.hasNamespaces) ? true : false;
				
				this.WriteTo(xmlWriter);
				xmlWriter.Flush();
				
				memoryStream.Seek(0, SeekOrigin.Begin);
				StreamReader reader = new StreamReader(memoryStream, encoding);
				formattedXml = reader.ReadToEnd();
			}
			finally
			{
				if(xmlWriter != null)
				{
					xmlWriter.Close();
				}
			}

			return formattedXml;
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <returns></returns>
		public string Escape()
		{
			return EscapeXml(this.OuterXml);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <returns></returns>
		public string Unescape()
		{
			return UnescapeXml(this.OuterXml);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public void LoadNamespaces()
		{
			FindNamespaces(this.DocumentElement);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xpath"></param>
		/// <returns></returns>
		public string GetNodeValue(string xpath)
		{
			XmlNode temp = this.SelectSingleNode(xpath, this.nsmgr);

			if(temp != null)
			{
				return temp.InnerText;
			}
			
			throw new NullReferenceException("Unable to get the value for the node; the specified xpath '" + xpath + "' returned a null value."); 
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xpath"></param>
		/// <param name="value"></param>
		public void SetNodeValue(string xpath, string value)
		{
			XmlNode temp = this.SelectSingleNode(xpath, this.nsmgr);

			if(temp != null)
			{
				temp.InnerText = value;
			}
			else
			{
				throw new NullReferenceException("Unable to set the value for the node; the specified xpath '" + xpath + "' returned a null value."); 
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xpath"></param>
		/// <returns></returns>
		public bool DoesNodeExist(string xpath)
		{
			XmlNode temp;

			return DoesNodeExist(xpath, out temp);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xpath"></param>
		/// <param name="node"></param>
		/// <returns></returns>
		public bool DoesNodeExist(string xpath, out XmlNode node)
		{
			node = this.SelectSingleNode(xpath, this.nsmgr);
			
			return (node != null) ? true : false;
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xml"></param>
		/// <returns></returns>
		public static string EscapeXml(string xml)
		{
			if((xml != null) && (xml.Length > 0))
			{
				return SecurityElement.Escape(xml);
			}

			return String.Empty;
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xml"></param>
		/// <returns></returns>
		public static string UnescapeXml(string xml)
		{
			if((xml != null) && (xml.Length > 0))
			{
				string temp = xml;

				temp = temp.Replace("&lt;", "<");
				temp = temp.Replace("&gt;", ">");
				temp = temp.Replace("&amp;", "&");
				temp = temp.Replace("&apos;", "'");
				temp = temp.Replace("&quot;", "\"");

				return temp;
			}

			return String.Empty;
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="oldPrefix"></param>
		/// <param name="newPrefix"></param>
		public void UpdatePrefix(string oldPrefix, string newPrefix)
		{
			UpdatePrefix(this.DocumentElement, oldPrefix, newPrefix);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="root"></param>
		private void FindNamespaces(XmlNode root)
		{
			if (root == null)
			{
				return;
			}

			if(root.Attributes != null)
			{
				foreach(XmlAttribute attribute in root.Attributes)
				{
					if((String.Compare(attribute.Prefix, "xmlns", true) == 0) || (String.Compare(attribute.LocalName, "xmlns", true) == 0))
					{
						if(attribute.Prefix.Length > 0)	//regular namespace
						{
							if(!this.nsmgr.HasNamespace(attribute.LocalName))
							{
								this.nsmgr.AddNamespace(attribute.LocalName, attribute.Value);
							}
						}
						else							//default namespace; xpath REQUIRES that it be given a 'dummy' prefix!
						{
							if(!this.nsmgr.HasNamespace(DefaultNamespacePrefix))
							{
								this.defaultNamespaces.Add(attribute.OwnerElement.LocalName, DefaultNamespacePrefix);
								this.nsmgr.AddNamespace(attribute.Prefix, attribute.Value);
								this.nsmgr.AddNamespace(DefaultNamespacePrefix, attribute.Value);
							}
							else
							{
								string newPrefix = attribute.OwnerElement.LocalName.ToLower() + DefaultNamespacePrefix;
								this.defaultNamespaces.Add(attribute.OwnerElement.LocalName, newPrefix);
								this.nsmgr.AddNamespace(newPrefix, attribute.Value);
							}
						}

						this.hasNamespaces = true;
					}
				}
			}
			
			foreach(XmlNode child in root.ChildNodes)
			{
				FindNamespaces(child);
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="root"></param>
		/// <param name="useCata"></param>
		private void UpdateCdataInXml(XmlNode root, bool useCata)
		{
			if(root.NodeType == XmlNodeType.Text)
			{
				if(useCdata)
				{
					root.ParentNode.InnerXml = "<![CDATA[" + root.Value + "]]>";
				}
			}
			else if (root.NodeType == XmlNodeType.Element && !root.HasChildNodes)
			{
				if (useCata)
				{
					root.InnerXml = "<![CDATA[" + root.Value + "]]>";
				}
			}
			else if (root.NodeType == XmlNodeType.CDATA)
			{
				if (!useCdata)
				{
					root.ParentNode.InnerXml = root.Value;
				}
			}
			else if (root.HasChildNodes)
			{
				foreach (XmlNode child in root.ChildNodes)
				{
					UpdateCdataInXml(child, useCdata);
				}
			}
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="root"></param>
		/// <param name="oldPrefix"></param>
		/// <param name="newPrefix"></param>
		private void UpdatePrefix(XmlNode root, string oldPrefix, string newPrefix)
		{
			if ((root.Attributes != null) && (root.Attributes.Count > 0))
			{
				XmlAttribute prefixAttribute = root.Attributes[String.Format("xmlns:{0}", oldPrefix)];

				if (prefixAttribute != null)
				{
					//update the old prefix definition to the new name
					string namespaceValue = prefixAttribute.Value;
					root.Attributes.Remove(prefixAttribute);
					XmlAttribute newPrefixAttribute = root.OwnerDocument.CreateAttribute(String.Format("xmlns:{0}", newPrefix), prefixAttribute.NamespaceURI);
					newPrefixAttribute.Value = namespaceValue;
					root.Attributes.Append(newPrefixAttribute);
				}
			}

			if (root.Prefix == oldPrefix)
			{
				root.Prefix = newPrefix;
			}

			foreach (XmlNode child in root.ChildNodes)
			{
				if (child.NodeType == XmlNodeType.Element)
				{
					//only elements can have prefixes/attributes
					UpdatePrefix(child, oldPrefix, newPrefix);
				}
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xml"></param>
		/// <param name="xmlStream"></param>
		/// <param name="loadNamespaces"></param>
		private void InternalContructor(string xml, Stream xmlStream, XmlNode xmlNode, bool loadNamespaces)
		{
			this.nsmgr = new XmlNamespaceManager(this.NameTable);

			if((xml != null) && (xml.Length > 0))
			{
				this.LoadXml(xml);
			}
			else if((xmlStream != null) && (xmlStream.Length > 0))
			{
				this.Load(xmlStream);
			}
			else if(xmlNode != null)
			{
				this.LoadXml(xmlNode.OuterXml);
			}

			if(loadNamespaces)
			{
				this.LoadNamespaces();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\Utility.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Configuration;
using System.Security.Cryptography;
using System.IO;
using System.Reflection;
using System.Runtime.Serialization;

namespace AvatarServices.Test.Common
{
    /// <summary>
    /// Utils class to hold utilities library methods
    /// </summary>
    public static class Utility
    {

        private static Random rnd = new Random();
        private static object rndLock = new object();
        private static char[] whitespaceChars;
        private static string currentDirectory;
        private static string originalAssemblyDirectory;
        public static bool lockTest = true;

        /// <summary>
        /// 
        /// </summary>
        static Utility()
        {
            FileInfo assemblyFile = new FileInfo(new Uri(Assembly.GetExecutingAssembly().CodeBase).LocalPath);
            currentDirectory = assemblyFile.DirectoryName;
            originalAssemblyDirectory = String.IsNullOrEmpty(AppDomain.CurrentDomain.SetupInformation.PrivateBinPath) ? String.Empty : AppDomain.CurrentDomain.SetupInformation.PrivateBinPath;
            if (!Directory.Exists(originalAssemblyDirectory))
            {
                originalAssemblyDirectory = String.Empty;
            }
            if (ConfigurationManager.AppSettings["lockTest"] == "false")
                lockTest = false;
        }

        /// <summary>
        /// 
        /// </summary>
        private static char[] WhitespaceChars
        {
            get
            {
                if (whitespaceChars == null)
                {
                    Type stringType = typeof(string);
                    object chars = stringType.InvokeMember("WhitespaceChars", BindingFlags.GetField | BindingFlags.NonPublic | BindingFlags.Static, null, null, null);
                    whitespaceChars = chars as char[];
                }

                return whitespaceChars;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public static Random GlobalRandom
        {
            get
            {
                //NOTE: NOT thread safe!
                return rnd;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public static string CurrentDirectory
        {
            get
            {
                return currentDirectory;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public static string OriginalAssemblyDirectory
        {
            get
            {
                return originalAssemblyDirectory;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="max"></param>
        /// <returns></returns>
        public static int GenerateRandomNumber(int max)
        {
            lock (rndLock)
            {
                return rnd.Next(max);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="min"></param>
        /// <param name="max"></param>
        /// <returns></returns>
        public static int GenerateRandomNumber(int min, int max)
        {
            lock (rndLock)
            {
                return rnd.Next(min, max);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="length"></param>
        /// <returns></returns>
        public static string GenerateRandomString()
        {
            return GenerateRandomString(GenerateRandomNumber(1024));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="length"></param>
        /// <returns></returns>
        public static string GenerateRandomString(int length)
        {
            return GenerateRandomString(length, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="length"></param>
        /// <returns></returns>
        public static string GenerateRandomString(int length, char[] excludeChars)
        {
            StringBuilder value = new StringBuilder(length);
            for (int i = 0; i < length; )
            {
                char temp = (char)GenerateRandomNumber(127);    //(char)GenerateRandomNumber(33, 127);
                if (!char.IsControl(temp) && (excludeChars == null || !excludeChars.Contains<char>(temp)))
                {
                    value.Append(temp);
                    i++;
                }
            }

            return value.ToString().Trim();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static ulong GenerateRandomUInt64()
        {
            byte[] buffer = new byte[sizeof(ulong)];
            RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
            rng.GetNonZeroBytes(buffer);
            return BitConverter.ToUInt64(buffer, 0);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static uint GenerateRandomUInt32()
        {
            byte[] buffer = new byte[sizeof(uint)];
            RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
            rng.GetNonZeroBytes(buffer);
            return BitConverter.ToUInt32(buffer, 0);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="array"></param>
        /// <returns></returns>
        public static string ArrayToString(Array array)
        {
            return ArrayToString(array, ", ");
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="array"></param>
        /// <returns></returns>
        public static string ArrayToString(Array array, string divider)
        {
            StringBuilder values = new StringBuilder();
            foreach (object obj in array)
            {
                values.Append(obj);
                values.Append(divider);
            }

            values.Length -= divider.Length;
            return values.ToString();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="length"></param>
        /// <returns></returns>
        public static string WhitespaceString(int length)
        {
            StringBuilder whitespace = new StringBuilder(length);
            Random rnd = new Random(unchecked((int)DateTime.Now.Ticks));

            for (int i = 0; i < length; i++)
                whitespace.Append(WhitespaceChars[rnd.Next(WhitespaceChars.Length)]);
            return whitespace.ToString();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="input"></param>    
        /// <returns></returns>
        public static string AppendWhitespace(object input)
        {
            return AppendWhitespace(input, true, true);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="input"></param>
        /// <param name="before"></param>
        /// <param name="after"></param>
        /// <returns></returns>
        public static string AppendWhitespace(object input, bool before, bool after)
        {
            StringBuilder newString = new StringBuilder(input.ToString());
            Random rnd = new Random(unchecked((int)DateTime.Now.Ticks));

            if (before)
                newString.Insert(0, WhitespaceString(rnd.Next(1, 5)));
            if (after)
                newString.Append(WhitespaceString(rnd.Next(1, 5)));
            return newString.ToString();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="length"></param>
        /// <returns></returns>
        public static string GenerateUnicodeString(int length)
        {
            StringBuilder sb = new StringBuilder();
            while (sb.Length < length)
            {
                char c = (char)GenerateRandomNumber(0x20, 0xfff0);
                if ((((c < '⁪') || (c > '⁯')) && ((c < 0xd800) || (c > 0xdfff))) && (((c < 0xe000) || (c > 0xf8ff)) && (c != 0xfeff)))
                {
                    sb.Append(c);
                }
            }
            return sb.ToString();

        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static byte[] GenerateRandomBytes()
        {
            return GenerateRandomBytes(GlobalRandom.Next(129));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="length"></param>
        /// <returns></returns>
        public static byte[] GenerateRandomBytes(int length)
        {
            byte[] data = new byte[length];
            GlobalRandom.NextBytes(data);
            return data;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\X509Certificate2Ex.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Runtime.InteropServices;
using System.ComponentModel;
using System.IO;
using System.Security.AccessControl;
using AvatarServices.Test.Common;

namespace AvatarServices.Test.Common
{
    /// <summary>
    /// Extended X509Certificate2 class that allows easy access to the certificate's key pair for encryption/decryption and signature
    /// generation/verification.  Certificates can also be installed, uninstalled and access to the private key material
    /// can be managed.
    /// </summary>
    public class X509Certificate2Ex : X509Certificate2, IDisposable
    {
        /// <summary>
        /// 
        /// </summary>
        public enum SearchField
        {
            CertHash,
            FriendlyName,
            SerialNumber,
            Subject,
            SubjectKeyIdentifier,
            Thumbprint,
        }

        public const string ClientAuthenticationOid = "1.3.6.1.5.5.7.3.2";
        public const string SmartCardLogonOid = "1.3.6.1.4.1.311.20.2.2";
        public const string OtgSmartCardOid = "1.3.6.1.4.1.311.42.2.1";

        private string ski;
        private X509KeyUsageFlags keyUsage;
        private List<Oid> enhancedKeyUsage = new List<Oid>();
        private string keyAlgorithm;
        //used as the hasing algorithm when signing data with an RSA cert
        private SHA1CryptoServiceProvider sha1;
        private RSACryptoServiceProvider publicRsa;
        private DSACryptoServiceProvider publicDsa;
        private RSACryptoServiceProvider privateRsa;
        private DSACryptoServiceProvider privateDsa;
        private bool isRsa;
        string privateKeyPath;
        private bool canUsePrivateKey;
        private List<X509ChainElement> certChain;
        private bool isDisposed;

        /// <summary>
        /// 
        /// </summary>
        public X509Certificate2Ex()
            : base()
        { }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="filepath"></param>
        public X509Certificate2Ex(string filepath)
            : base(filepath)
        {
            InternalConstructor();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="filepath"></param>
        /// <param name="password"></param>
        public X509Certificate2Ex(string filepath, string password)
            : base(filepath, password)
        {
            InternalConstructor();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="filepath"></param>
        /// <param name="password"></param>
        /// <param name="keyStorageFlags"></param>
        public X509Certificate2Ex(string filepath, string password, X509KeyStorageFlags keyStorageFlags)
            : base(filepath, password, keyStorageFlags)
        {
            InternalConstructor();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="rawData"></param>
        public X509Certificate2Ex(byte[] rawData)
            : base(rawData)
        {
            InternalConstructor();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="handle"></param>
        public X509Certificate2Ex(IntPtr handle)
            : base(handle)
        {
            InternalConstructor();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="certificate"></param>
        public X509Certificate2Ex(X509Certificate certificate)
            : base(certificate)
        {
            InternalConstructor();
        }

        /// <summary>
        /// Friendly name of the certificate's key algorithm.  Should be RSA or DSA.
        /// </summary>
        public string KeyAlgorithm
        {
            get { return this.keyAlgorithm; }
        }

        /// <summary>
        /// The subject key identifier of the certificate.
        /// </summary>
        public string SKI
        {
            get { return this.ski; }
        }

        /// <summary>
        /// 
        /// </summary>
        public X509KeyUsageFlags KeyUsage
        {
            get { return this.keyUsage; }
        }

        /// <summary>
        /// 
        /// </summary>
        public List<Oid> EnhancedKeyUsage
        {
            get { return this.enhancedKeyUsage; }
        }

        /// <summary>
        /// Returns the file path where the private key is located.
        /// </summary>
        public string PrivateKeyPath
        {
            get
            {
                if (this.HasPrivateKey)
                {
                    if (this.privateKeyPath == null)
                        this.privateKeyPath = GetPrivateKeyPath();

                    return this.privateKeyPath;
                }

                throw new ApplicationException("The certificate does not have a private key.");
            }
        }

        /// <summary>
        /// Returns whether or not the private key can be found and used by the current user.  Private keys
        /// cannot necessarily be used by just any user.
        /// </summary>
        public bool CanUsePrivateKey
        {
            get { return this.canUsePrivateKey; }
        }

        /// <summary>
        /// 
        /// </summary>
        public List<X509ChainElement> CertificateChain
        {
            get
            {
                if (this.certChain == null)
                    BuildCertChain();

                return this.certChain;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public X509ChainElement RootCertificateAuthority
        {
            get
            {
                if (this.CertificateChain.Count > 0)
                    return this.CertificateChain[this.CertificateChain.Count - 1];

                return null;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public List<X509ChainElement> IntermediateCertificateAuthorities
        {
            get
            {
                if (this.CertificateChain.Count > 2)
                    return this.CertificateChain.GetRange(1, this.CertificateChain.Count - 2);

                return new List<X509ChainElement>();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public X509ChainStatus[] Status
        {
            get { return this.CertificateChain[0].ChainElementStatus; }
        }

        /// <summary>
        /// 
        /// </summary>
        public bool IsValid
        {
            get { return this.Status.Length == 1 && this.Status[0].Status == X509ChainStatusFlags.NoError; }
        }

        /// <summary>
        /// Searches for a certificate in the MY store of the local machine, using the specified subject.
        /// </summary>
        /// <param name="subject"></param>
        /// <returns></returns>
        public static X509Certificate2Ex FindCertificate(string subject)
        {
            return FindCertificate(subject, SearchField.Subject, StoreName.My, StoreLocation.LocalMachine, OpenFlags.ReadOnly, false);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="data"></param>
        /// <param name="field"></param>
        /// <returns></returns>
        public static X509Certificate2Ex FindCertificate(string data, SearchField field)
        {
            return FindCertificate(data, field, StoreName.My, StoreLocation.LocalMachine);
        }

        /// <summary>
        /// Searches for a certificate in the specified store name and store location, by subject.
        /// </summary>
        /// <param name="subject"></param>
        /// <param name="storeName"></param>
        /// <param name="storeLocation"></param>
        /// <returns></returns>
        public static X509Certificate2Ex FindCertificate(string data, SearchField field, StoreName storeName, StoreLocation storeLocation)
        {
            return FindCertificate(data, field, storeName, storeLocation, OpenFlags.ReadOnly, true);
        }

        /// <summary>
        /// Searches for a certificate in the specified store name and store location, by subject.  An exact subject match
        /// and how the certificate store is opened can be specified.
        /// </summary>
        /// <param name="subject"></param>
        /// <param name="storeName"></param>
        /// <param name="storeLocation"></param>
        /// <returns></returns>
        public static X509Certificate2Ex FindCertificate(string data, SearchField field, StoreName storeName, StoreLocation storeLocation, OpenFlags openFlags, bool exactMatch)
        {
            X509Store certStore = new X509Store(storeName, storeLocation);

            try
            {
                certStore.Open(openFlags);
                for (int i = 0; i < certStore.Certificates.Count; i++)
                {
                    string compareData = String.Empty;
                    switch (field)
                    {
                        case SearchField.CertHash:
                            {
                                compareData = certStore.Certificates[i].GetCertHashString();
                                break;
                            }
                        case SearchField.FriendlyName:
                            {
                                compareData = certStore.Certificates[i].FriendlyName;
                                break;
                            }
                        case SearchField.SerialNumber:
                            {
                                compareData = certStore.Certificates[i].SerialNumber;
                                break;
                            }
                        case SearchField.Subject:
                            {
                                compareData = certStore.Certificates[i].Subject;
                                break;
                            }
                        case SearchField.SubjectKeyIdentifier:
                            {
                                X509Certificate2Ex tempCert = new X509Certificate2Ex(certStore.Certificates[i]);
                                compareData = tempCert.SKI;
                                break;
                            }
                        case SearchField.Thumbprint:
                            {
                                compareData = certStore.Certificates[i].Thumbprint;
                                break;
                            }
                    }

                    if ((!exactMatch && compareData.Contains(data)) || compareData.Equals(data))
                    {
                        return new X509Certificate2Ex(certStore.Certificates[i]);
                    }
                }
                throw new ApplicationException(String.Format("Unable to find a certificate with '{0}' in cert field {1}, in store name {2} and store location {3}.", data, field.ToString(), storeName.ToString(), storeLocation.ToString()));
            }
            finally
            {
                certStore.Close();
            }
        }

        /// <summary>
        /// Returns all certificates found in the specified store name and location.  The certificates returned are read only.
        /// </summary>
        /// <param name="storeLocation"></param>
        /// <param name="storeName"></param>
        /// <returns></returns>
        public static List<X509Certificate2Ex> FindCertificates(StoreLocation storeLocation, StoreName storeName)
        {
            List<X509Certificate2Ex> certs = new List<X509Certificate2Ex>();
            X509Store certStore = new X509Store(storeName, storeLocation);

            try
            {
                certStore.Open(OpenFlags.ReadOnly);
                for (int i = 0; i < certStore.Certificates.Count; i++)
                {
                    certs.Add(new X509Certificate2Ex(certStore.Certificates[i]));
                }

                return certs;
            }
            finally
            {
                certStore.Close();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="subject"></param>
        /// <param name="storeName"></param>
        /// <param name="storeLocation"></param>
        /// <returns></returns>
        public static X509Certificate2Ex TryFindCertificate(string subject, StoreName storeName, StoreLocation storeLocation)
        {
            try
            {
                return FindCertificate(subject, SearchField.Subject, storeName, storeLocation, OpenFlags.ReadOnly, false);
            }
            catch (ApplicationException)
            {
                return null;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="data"></param>
        /// <param name="field"></param>
        /// <returns></returns>
        public static X509Certificate2Ex TryFindCertificate(string data, SearchField field)
        {
            return TryFindCertificate(data, field, StoreName.My, StoreLocation.LocalMachine);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="data"></param>
        /// <param name="field"></param>
        /// <param name="storeName"></param>
        /// <param name="storeLocation"></param>
        /// <returns></returns>
        public static X509Certificate2Ex TryFindCertificate(string data, SearchField field, StoreName storeName, StoreLocation storeLocation)
        {
            try
            {
                return FindCertificate(data, field, storeName, storeLocation);
            }
            catch (ApplicationException)
            {
                return null;
            }
        }

        /// <summary>
        /// Installs the specified certificate into the LOCAL_MACHINE\MY certificate store.  If the same certificate
        /// already exists in the certificate store, it will not be installed.
        /// </summary>
        /// <param name="certificate"></param>
        /// <returns></returns>
        public static void InstallCertificate(X509Certificate2 certificate)
        {
            InstallCertificate(certificate, StoreName.My, StoreLocation.LocalMachine);
        }

        /// <summary>
        /// Installs the provided certificate into the specified certificate store name and location.  How the certificate is 
        /// installed (overwrite existing, etc.) can be specified by the CertStoreAddDisposition flag.
        /// </summary>
        /// <param name="certificate"></param>
        /// <param name="storeName"></param>
        /// <param name="storeLocation"></param>
        /// <param name="addDisposition"></param>
        public static void InstallCertificate(X509Certificate2 certificate, StoreName storeName, StoreLocation storeLocation)
        {
            X509Store certStore = new X509Store(storeName, storeLocation);

            try
            {
                certStore.Open(OpenFlags.ReadWrite);
                certStore.Add(certificate);
            }
            finally
            {
                certStore.Close();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="certificates"></param>
        /// <param name="storeName"></param>
        /// <param name="storeLocation"></param>
        public static void InstallCertificates(List<X509Certificate2> certificates, StoreName storeName, StoreLocation storeLocation)
        {
            X509Store certStore = new X509Store(storeName, storeLocation);

            try
            {
                certStore.Open(OpenFlags.ReadWrite);
                for (int i = 0; i < certificates.Count; i++)
                {
                    certStore.Add(certificates[i]);
                }
            }
            finally
            {
                certStore.Close();
            }
        }

        /// <summary>
        /// Deletes the certificate, found in the specified certificate store name and location by subject, from its
        /// respective certificate store. 
        /// </summary>
        /// <param name="subject"></param>
        /// <param name="storeName"></param>
        /// <param name="storeLocation"></param>
        public static void UninstallCertificate(string subject, StoreName storeName, StoreLocation storeLocation)
        {
            UninstallCertificate(X509Certificate2Ex.FindCertificate(subject, SearchField.Subject, storeName, storeLocation, OpenFlags.ReadWrite, false));
        }

        /// <summary>
        /// Deletes the specified certificate from its respective certificate store.  The certificate must be opened as
        /// read/write and have been loaded from a valid certificate store in order for this operation to succeed.
        /// </summary>
        /// <param name="certificate"></param>
        public static void UninstallCertificate(X509Certificate2Ex certificate)
        {
            bool success = Crypt32.CertDeleteCertificateFromStore(certificate.Handle);
            if (!success)
            {
                throw new Win32Exception();
            }
        }

        /// <summary>
        /// Deletes the specified certificates from its respective certificate store.  The certificate must be opened as
        /// read/write and have been loaded from a valid certificate store in order for this operation to succeed.
        /// </summary>
        /// <param name="certificate"></param>
        public static void UninstallCertificates(List<X509Certificate2> certificates)
        {
            for (int i = 0; i < certificates.Count; i++)
            {
                bool success = Crypt32.CertDeleteCertificateFromStore(certificates[i].Handle);
                if (!success)
                {
                    throw new Win32Exception();
                }
            }
        }

        /// <summary>
        /// Grants access to the private key material of a certificate, found in the specified certificate store name and location by subject,
        /// to the specified identity (DOMAIN\USERNAME).  The certificate must have a private key to perform this action.
        /// </summary>
        /// <param name="subject"></param>
        /// <param name="storeName"></param>
        /// <param name="storeLocation"></param>
        /// <param name="identity"></param>
        public static void GrantAccessToPrivateKey(string subject, StoreName storeName, StoreLocation storeLocation, string identity)
        {
            GrantAccessToPrivateKey(X509Certificate2Ex.FindCertificate(subject, SearchField.Subject, storeName, storeLocation, OpenFlags.ReadWrite, false), identity);
        }

        /// <summary>
        /// Grants access to the private key material of the specified certificate, to the specified identity (DOMAIN\USERNAME).
        /// The certificate must have a private key to perform this action.  Note: the certificate object should reference a
        /// certificate that is already installed into a certificate store.
        /// </summary>
        /// <param name="certificate"></param>
        /// <param name="identity"></param>
        public static void GrantAccessToPrivateKey(X509Certificate2Ex certificate, string identity)
        {
            if (!certificate.HasPrivateKey)
            {
                throw new ApplicationException("The certificate does not have a private key.");
            }

            FileInfo fileInfo = new FileInfo(certificate.PrivateKeyPath);
            FileSecurity fileSecurity = fileInfo.GetAccessControl(AccessControlSections.Access);
            fileSecurity.AddAccessRule(new FileSystemAccessRule(identity, FileSystemRights.FullControl, AccessControlType.Allow));
            fileInfo.SetAccessControl(fileSecurity);
        }

        /// <summary>
        /// Denies access to the private key material of a certificate, found in the specified certificate store name and location by subject,
        /// to the specified identity (DOMAIN\USERNAME).  The certificate must have a private key to perform this action.
        /// </summary>
        /// <param name="subject"></param>
        /// <param name="storeName"></param>
        /// <param name="storeLocation"></param>
        /// <param name="identity"></param>
        public static void DenyAccessToPrivateKey(string subject, StoreName storeName, StoreLocation storeLocation, string identity)
        {
            DenyAccessToPrivateKey(X509Certificate2Ex.FindCertificate(subject, SearchField.Subject, storeName, storeLocation, OpenFlags.ReadOnly, false), identity);
        }

        /// <summary>
        /// Denies access to the private key material of the specified certificate, to the specified identity (DOMAIN\USERNAME).
        /// The certificate must have a private key to perform this action.  Note: the certificate object should reference a
        /// certificate that is already installed into a certificate store.
        /// </summary>
        /// <param name="certificate"></param>
        /// <param name="identity"></param>
        public static void DenyAccessToPrivateKey(X509Certificate2Ex certificate, string identity)
        {
            if (!certificate.HasPrivateKey)
            {
                throw new ApplicationException("The certificate does not have a private key.");
            }

            FileInfo fileInfo = new FileInfo(certificate.PrivateKeyPath);
            FileSecurity fileSecurity = fileInfo.GetAccessControl(AccessControlSections.Access);
            fileSecurity.RemoveAccessRule(new FileSystemAccessRule(identity, FileSystemRights.FullControl, AccessControlType.Allow));
            fileInfo.SetAccessControl(fileSecurity);
        }

        /// <summary>
        /// Signs data with the private key of the certificate.  Requires that the loaded certificate supports signing and
        /// has access to the private key.  For RSA certificates, SHA1 is used as the hashing algorithm.
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        public byte[] SignData(byte[] data)
        {
            if (!this.HasPrivateKey)
            {
                throw new ApplicationException("The certificate does not have a private key and cannot be used to sign data.");
            }

            byte[] signedData;

            if (this.isRsa)
            {
                signedData = this.privateRsa.SignData(data, this.sha1);
            }
            else
            {
                signedData = this.privateDsa.SignData(data);
            }

            return signedData;
        }

        /// <summary>
        /// Signs data with the private key of the certificate.  Requires that the loaded certificate supports signing and
        /// has access to the private key.  For RSA certificates, SHA1 is used as the hashing algorithm.  The specified
        /// string is turned into an array of bytes using UTF-8 encoding and the resulting signature value is returned as a
        /// base64 string.
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        public string SignData(string data)
        {
            return Convert.ToBase64String(SignData(Encoding.UTF8.GetBytes(data)));
        }

        /// <summary>
        /// Verifies the specified data using the specified signature value, using the public key of the certificate.
        /// For RSA certificates, SHA1 is used as the hashing algorithm.
        /// </summary>
        /// <param name="data"></param>
        /// <param name="signature"></param>
        /// <returns></returns>
        public bool VerifySignature(byte[] data, byte[] signature)
        {
            bool verified;

            if (this.isRsa)
            {
                verified = this.publicRsa.VerifyData(data, this.sha1, signature);
            }
            else
            {
                verified = this.publicDsa.VerifyData(data, signature);
            }

            return verified;
        }

        /// <summary>
        /// Verifies the specified data using the specified signature value, using the public key of the certificate.
        /// For RSA certificates, SHA1 is used as the hashing algorithm.  The specified string is turned into an array of
        /// bytes using UTF-8 encoding.  The signature should be a valid base64 string.
        /// </summary>
        /// <param name="data"></param>
        /// <param name="base64Signature"></param>
        /// <returns></returns>
        public bool VerifySignature(string data, string base64Signature)
        {
            return VerifySignature(Encoding.UTF8.GetBytes(data), Convert.FromBase64String(base64Signature));
        }

        /// <summary>
        /// Encrypts the specified data with the public key of the certificate.  Optimal Asymmetric Encryption Padding (OAEP)
        /// is not used.
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        public byte[] EncryptData(byte[] data)
        {
            return EncryptData(data, false);
        }

        /// <summary>
        /// Encrypts the specified data with the public key of the certificate.  Optionally, Optimal Asymmetric Encryption
        /// Padding (OAEP) can be specified.
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        public byte[] EncryptData(byte[] data, bool useOaep)
        {
            if (this.isRsa)
            {
                return this.privateRsa.Encrypt(data, useOaep);
            }
            else
            {
                throw new ApplicationException("Only RSA certificates can be used to encrypt or decrypt data.");
            }
        }

        /// <summary>
        /// Encrypts the specified data with the public key of the certificate.  Optimal Asymmetric Encryption Padding (OAEP)
        /// is not used.  The specified string is turned into an array of bytes using UTF-8 encoding.  The resulting cipher
        /// is returned as a base64 string.
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        public string EncryptData(string data)
        {
            return Convert.ToBase64String(EncryptData(Encoding.UTF8.GetBytes(data)));
        }

        /// <summary>
        /// Decrypts the specified data with the private key of the certificate.  Requires that the loaded certificate
        /// supports signing and has access to the private key.  Optimal Asymmetric Encryption Padding (OAEP) is not used.
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        public byte[] DecryptData(byte[] data)
        {
            return DecryptData(data, false);
        }

        /// <summary>
        /// Decrypts the specified data with the private key of the certificate.  Requires that the loaded certificate
        /// supports signing and has access to the private key.  Optionally, Asymmetric Encryption Padding (OAEP) can
        /// be specified.
        /// </summary>
        /// <param name="data"></param>
        /// <param name="useOaep"></param>
        /// <returns></returns>
        public byte[] DecryptData(byte[] data, bool useOaep)
        {
            if (!this.HasPrivateKey)
            {
                throw new ApplicationException("The certificate does not have a private key and cannot be used to decrypt data.");
            }

            if (this.isRsa)
            {
                return this.privateRsa.Decrypt(data, useOaep);
            }
            else
            {
                throw new ApplicationException("Only RSA certificates can be used to encrypt or decrypt data.");
            }
        }

        /// <summary>
        /// Decrypts the specified data with the private key of the certificate.  Requires that the loaded certificate
        /// supports signing and has access to the private key.  Optimal Asymmetric Encryption Padding (OAEP) is not used.
        /// The specified cipher should be a valid base64 string.  The resulting decrypted value is returned as a clear-text
        /// string using UTF-8 encoding.
        /// </summary>
        /// <param name="base64String"></param>
        /// <returns></returns>
        public string DecryptData(string base64String)
        {
            return Encoding.UTF8.GetString(DecryptData(Convert.FromBase64String(base64String)));
        }

        /// <summary>
        /// Installs the certificate into the LOCAL_MACHINE\MY certificate store.
        /// </summary>
        /// <returns></returns>
        public void Install()
        {
            InstallCertificate(this);
        }

        /// <summary>
        /// Installs the certificate into the specified certificate store name and location.
        /// </summary>
        /// <param name="storeName"></param>
        /// <param name="storeLocation"></param>
        /// <returns></returns>
        public void Install(StoreName storeName, StoreLocation storeLocation)
        {
            InstallCertificate(this, storeName, storeLocation);
        }

        /// <summary>
        /// Deletes the certificate from its respective certificate store.
        /// </summary>
        public void Uninstall()
        {
            UninstallCertificate(this);
        }

        /// <summary>
        /// Grants access to private key material of the certificate to the specified identity.
        /// </summary>
        /// <param name="identity"></param>
        public void GrantPrivateKeyAccess(string identity)
        {
            GrantAccessToPrivateKey(this, identity);
        }

        /// <summary>
        /// Denies access to private key material of the certificate to the specified identity.
        /// </summary>
        /// <param name="identity"></param>
        public void DenyPrivateKeyAccess(string identity)
        {
            DenyAccessToPrivateKey(this, identity);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public bool IsCertChainInstalled()
        {
            return IsCertChainInstalled(StoreLocation.LocalMachine);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="storeName"></param>
        /// <param name="storeLocation"></param>
        /// <returns></returns>
        public bool IsCertChainInstalled(StoreLocation storeLocation)
        {
            if (this.RootCertificateAuthority == null)
            {
                return false;
            }

            //verify that any intermediate cert(s) are in the Intermediate CA store
            if (this.IntermediateCertificateAuthorities != null)
            {
                for (int i = 0; i < this.IntermediateCertificateAuthorities.Count; i++)
                {
                    if (TryFindCertificate(this.IntermediateCertificateAuthorities[i].Certificate.Thumbprint, SearchField.Thumbprint, StoreName.CertificateAuthority, storeLocation) == null)
                    {
                        return false;
                    }
                }
            }

            //verify that the root cert are in the Intermediate CA store
            return TryFindCertificate(this.RootCertificateAuthority.Certificate.Thumbprint, SearchField.Thumbprint, StoreName.Root, storeLocation) != null;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public bool IsRevoked()
        {
            for (int i = 0; i < this.Status.Length; i++)
            {
                if (this.Status[i].Status == X509ChainStatusFlags.Revoked)
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// 
        /// </summary>
        public void InstallCertChain()
        {
            InstallCertChain(StoreLocation.LocalMachine);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="location"></param>
        public void InstallCertChain(StoreLocation location)
        {
            InstallCertChain(this, location);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="certificate"></param>
        public static void InstallCertChain(X509Certificate2Ex certificate)
        {
            InstallCertChain(certificate, StoreLocation.LocalMachine);
        }

        /// <summary>
        /// 
        /// </summary>
        public static void InstallCertChain(X509Certificate2Ex certificate, StoreLocation location)
        {
            List<X509Certificate2> intermediates = new List<X509Certificate2>(certificate.IntermediateCertificateAuthorities.Count);
            for (int i = 0; i < certificate.IntermediateCertificateAuthorities.Count; i++)
            {
                intermediates.Add(certificate.IntermediateCertificateAuthorities[i].Certificate);
            }

            //install any intermediate CA(s)
            InstallCertificates(intermediates, StoreName.CertificateAuthority, location);

            //install the root CA
            InstallCertificate(certificate.RootCertificateAuthority.Certificate, StoreName.Root, location);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="removeIntermediates"></param>
        /// <param name="removeRoot"></param>
        public void UninstallCertChain(bool removeIntermediates, bool removeRoot)
        {
            UninstallCertChain(StoreLocation.LocalMachine, removeIntermediates, removeRoot);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="location"></param>
        /// <param name="removeIntermediates"></param>
        /// <param name="removeRoot"></param>
        public void UninstallCertChain(StoreLocation location, bool removeIntermediates, bool removeRoot)
        {
            UninstallCertChain(this, location, removeIntermediates, removeRoot);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="certificate"></param>
        public static void UninstallCertChain(X509Certificate2Ex certificate, bool removeIntermediates, bool removeRoot)
        {
            UninstallCertChain(certificate, StoreLocation.LocalMachine, removeIntermediates, removeRoot);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="certificate"></param>
        /// <param name="location"></param>
        /// <param name="removeIntermediates"></param>
        /// <param name="removeRoot"></param>
        public static void UninstallCertChain(X509Certificate2Ex certificate, StoreLocation location, bool removeIntermediates, bool removeRoot)
        {
            if (removeIntermediates)
            {
                //uninstall any intermediate CA(s)
                List<X509Certificate2> intermediates = new List<X509Certificate2>(certificate.IntermediateCertificateAuthorities.Count);
                for (int i = 0; i < certificate.IntermediateCertificateAuthorities.Count; i++)
                {
                    try
                    {
                        X509Certificate2Ex intermediateCACert = X509Certificate2Ex.FindCertificate(certificate.IntermediateCertificateAuthorities[i].Certificate.Thumbprint, SearchField.Thumbprint, StoreName.CertificateAuthority, location, OpenFlags.ReadWrite, true);
                        intermediates.Add(intermediateCACert);
                    }
                    catch (ApplicationException)
                    {
                        //if we can't find the intermediate cert, then it's not installed and thus
                        //a no-op.  Move to the next one...
                    }
                }

                UninstallCertificates(intermediates);
            }

            if (removeRoot)
            {
                try
                {
                    X509Certificate2Ex rootCACert = X509Certificate2Ex.FindCertificate(certificate.RootCertificateAuthority.Certificate.Thumbprint, SearchField.Thumbprint, StoreName.Root, location, OpenFlags.ReadWrite, true);
                    UninstallCertificate(rootCACert);
                }
                catch (ApplicationException)
                {
                    //if we can't find the root cert, then it's not installed and thus
                    //a no-op.  Move to the next one...
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [System.Security.Permissions.PermissionSet(System.Security.Permissions.SecurityAction.LinkDemand, Unrestricted = true)]
        public override void Reset()
        {
            this.canUsePrivateKey = false;
            this.certChain = null;
            this.enhancedKeyUsage = null;
            this.isRsa = false;
            this.keyAlgorithm = null;
            this.keyUsage = X509KeyUsageFlags.None;
            this.privateDsa = null;
            this.privateRsa = null;
            this.publicDsa = null;
            this.publicRsa = null;
            this.sha1 = null;
            this.ski = null;

            base.Reset();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="applicationPolicyOid"></param>
        /// <returns></returns>
        public bool Verify(string applicationPolicyOid)
        {
            return Verify(applicationPolicyOid, X509RevocationMode.Online);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="applicationPolicyOid"></param>
        /// <param name="revocationMode"></param>
        /// <returns></returns>
        public bool Verify(string applicationPolicyOid, X509RevocationMode revocationMode)
        {
            X509ChainStatus[] chainStatus;
            return Verify(applicationPolicyOid, revocationMode, out chainStatus);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="applicationPolicy"></param>
        /// <returns></returns>
        public bool Verify(Oid applicationPolicy)
        {
            return Verify(applicationPolicy, X509RevocationMode.Online);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="applicationPolicy"></param>
        /// <param name="revocationMode"></param>
        /// <returns></returns>
        public bool Verify(Oid applicationPolicy, X509RevocationMode revocationMode)
        {
            X509ChainStatus[] chainStatus;
            return Verify(applicationPolicy, revocationMode, out chainStatus);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="applicationPolicyOid"></param>
        /// <param name="chainStatus"></param>
        /// <returns></returns>
        public bool Verify(string applicationPolicyOid, X509RevocationMode revocationMode, out X509ChainStatus[] chainStatus)
        {
            OidCollection applicationPolicies = new OidCollection();
            applicationPolicies.Add(new Oid(applicationPolicyOid));
            return Verify(revocationMode, X509RevocationFlag.ExcludeRoot, X509VerificationFlags.NoFlag, applicationPolicies, null, out chainStatus);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="applicationPolicies"></param>
        /// <param name="chainStatus"></param>
        /// <returns></returns>
        public bool Verify(Oid applicationPolicy, X509RevocationMode revocationMode, out X509ChainStatus[] chainStatus)
        {
            OidCollection applicationPolicies = new OidCollection();
            applicationPolicies.Add(applicationPolicy);
            return Verify(revocationMode, X509RevocationFlag.ExcludeRoot, X509VerificationFlags.NoFlag, applicationPolicies, null, out chainStatus);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="revocationMode"></param>
        /// <param name="revocationFlag"></param>
        /// <param name="verificationFlags"></param>
        /// <param name="applicationPolicies"></param>
        /// <param name="certificatePolicies"></param>
        /// <param name="chainStatus"></param>
        /// <returns></returns>
        public bool Verify(X509RevocationMode revocationMode, X509RevocationFlag revocationFlag, X509VerificationFlags verificationFlags, OidCollection applicationPolicies, OidCollection certificatePolicies, out X509ChainStatus[] chainStatus)
        {
            X509Chain chain = new X509Chain();
            chain.ChainPolicy = new X509ChainPolicy();
            chain.ChainPolicy.RevocationMode = revocationMode;
            chain.ChainPolicy.RevocationFlag = revocationFlag;
            chain.ChainPolicy.VerificationFlags = X509VerificationFlags.NoFlag;

            if (applicationPolicies != null)
            {
                for (int i = 0; i < applicationPolicies.Count; i++)
                {
                    chain.ChainPolicy.ApplicationPolicy.Add(applicationPolicies[i]);
                }
            }

            if (certificatePolicies != null)
            {
                for (int i = 0; i < certificatePolicies.Count; i++)
                {
                    chain.ChainPolicy.CertificatePolicy.Add(certificatePolicies[i]);
                }
            }

            chain.Build(this);
            chainStatus = chain.ChainStatus;
            return chain.ChainStatus.Length == 0;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="oid"></param>
        /// <returns></returns>
        public bool HasEnhancedKeyUsage(string oid)
        {
            for (int i = 0; i < this.EnhancedKeyUsage.Count; i++)
            {
                if (this.EnhancedKeyUsage[i].Value == oid)
                    return true;
            }

            return false;
        }

        /// <summary>
        /// 
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="disposing"></param>
        protected void Dispose(bool disposing)
        {
            if (!this.isDisposed)
            {
                if (disposing)
                {
                    if (this.sha1 != null)
                        this.sha1.Clear();
                }

                this.isDisposed = true;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="certificate"></param>
        /// <returns></returns>
        protected void GetCertificateExtensions()
        {
            for (int i = 0; i < this.Extensions.Count; i++)
            {
                if (this.Extensions[i] is X509SubjectKeyIdentifierExtension)
                {
                    this.ski = (this.Extensions[i] as X509SubjectKeyIdentifierExtension).SubjectKeyIdentifier;
                }
                else if (this.Extensions[i] is X509KeyUsageExtension)
                {
                    this.keyUsage |= (this.Extensions[i] as X509KeyUsageExtension).KeyUsages;
                }
                else if (this.Extensions[i] is X509EnhancedKeyUsageExtension)
                {
                    X509EnhancedKeyUsageExtension enhancedKeyUsage = this.Extensions[i] as X509EnhancedKeyUsageExtension;
                    Oid[] usages = new Oid[enhancedKeyUsage.EnhancedKeyUsages.Count];
                    enhancedKeyUsage.EnhancedKeyUsages.CopyTo(usages, 0);
                    this.enhancedKeyUsage.AddRange(usages);
                }
            }
        }

        /// <summary>
        /// Returns the unique name of the key container that contains the private key.
        /// </summary>
        /// <returns></returns>
        protected string GetPrivateKeyContainerName()
        {
            if (this.HasPrivateKey)
            {
                if (this.isRsa)
                {
                    return this.privateRsa.CspKeyContainerInfo.UniqueKeyContainerName;
                }
                else
                {
                    return this.privateDsa.CspKeyContainerInfo.UniqueKeyContainerName;
                }
            }

            throw new ApplicationException("The certificate does not have a private key.");
        }

        /// <summary>
        /// Returns the full file path where the private key is located.
        /// </summary>
        /// <returns></returns>
        protected string GetPrivateKeyPath()
        {
            string cryptoPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData), @"Microsoft\Crypto\");
            string keyFile = GetPrivateKeyContainerName();
            string[] files = Directory.GetFiles(cryptoPath, keyFile, SearchOption.AllDirectories);

            if (files.Length > 0)
            {
                return files[0];
            }

            cryptoPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), @"Microsoft\Crypto\");
            files = Directory.GetFiles(cryptoPath, keyFile, SearchOption.AllDirectories);

            if (files.Length > 0)
            {
                return files[0];
            }

            throw new ApplicationException("Unable to find the filepath of the private key; it exists but is not accessible.");
        }

        /// <summary>
        /// 
        /// </summary>
        protected void BuildCertChain()
        {
            this.certChain = new List<X509ChainElement>();
            X509Chain chain = new X509Chain();
            chain.Build(this);

            for (int i = 0; i < chain.ChainElements.Count; i++)
            {
                this.certChain.Add(chain.ChainElements[i]);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        private void InternalConstructor()
        {
            GetCertificateExtensions();

            Oid oid = new Oid(this.GetKeyAlgorithm());
            this.keyAlgorithm = oid.FriendlyName;
            this.sha1 = new SHA1CryptoServiceProvider();

            if (this.keyAlgorithm.Equals("RSA", StringComparison.OrdinalIgnoreCase))
            {
                this.isRsa = true;
                this.publicRsa = this.PublicKey.Key as RSACryptoServiceProvider;
            }
            else if (this.keyAlgorithm.Equals("DSA", StringComparison.OrdinalIgnoreCase))
            {
                this.isRsa = false;
                this.publicDsa = this.PublicKey.Key as DSACryptoServiceProvider;
            }
            else
            {
                throw new ApplicationException(String.Format("The specified key algorithm, {0}, with ID {1} is currently unsupported.", this.keyAlgorithm, oid.Value));
            }

            if (this.HasPrivateKey)
            {
                try
                {
                    if (this.isRsa)
                    {
                        this.privateRsa = this.PrivateKey as RSACryptoServiceProvider;
                    }
                    else
                    {
                        this.privateDsa = this.PrivateKey as DSACryptoServiceProvider;
                    }

                    this.canUsePrivateKey = true;
                }
                catch (CryptographicException)
                {
                    //can't access key set...
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\UserCache.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Xboxcom.Test.Library;
using CloudServices.Test.Common.Configuration;
using Microsoft.XboxLive.Avatars;
using System.Diagnostics;
using AssetLibrary;
using System.Threading;

namespace Test.Avatar.Functional.AvatarServiceTests.Common
{
    /// <summary>
    /// Class representing cached user repository to be shared across tests.
    /// </summary>
    public class UserCache
    {
        private UserCache()
        {
            Environments.SetEnvironment(Config.Environment.LiveLibEnvironment);
            Trace.WriteLine("TRACE: Setting LiveLib environment to " + Config.Environment.LiveLibEnvironment);
            if (Config.Environment.UseStf)
            {
                Environments.SetStfEnvironment(Config.Environment.LiveLibEnvironment);
            }
        }

        private static UserCache instance = new UserCache();
        public static UserCache Instance
        {
            get
            {
                return instance;
            }
        }

        private Dictionary<string, User> userList = new Dictionary<string, User>();
        private Random rand = new Random();

        public User GetUserByGamertag(string gamertag)
        {
            User user;

            //see if it's cached locally
            if (userList.TryGetValue(gamertag.ToLower(),out user))
            {
                return user;
            }
            
            string email = gamertag.Replace(" ", "") + "VeryLong@" + TestSettings.PASSPORT_DOMAIN;
            AccountSettings settings = new AccountSettings(live.common.XblUserTier.Silver, live.common.PassportType.Real, email, TestSettings.PASSPORT_PASSWORD, gamertag);
            try
            {
                // Try to create a new user.
                user = new User(settings);
            }
            catch (live.common.XErrFailedException ex)
            {
                if (ex.HResult == 0x80154013 || ex.HResult == 0x80154000) //80154013: XONLINE_E_PASSPORT_ALREADY_LINKED 80154000: XONLINE_E_ACCOUNTS_NAME_TAKEN
                {
                    user = new User(Account.LoadExistingAccount(email, TestSettings.PASSPORT_PASSWORD));
                }
                else
                    throw new UserSetupException("There was an unhandled exception from Xbox Live service while creating a new user.", ex);
            }

            return user;
        }

        /// <summary>
        /// Returns an array of users with manifests.
        /// </summary>
        /// <param name="count">Number of users to get.</param>
        /// <returns>Array of users with manifests.</returns>
        public User[] GetUsersWithManifests(int count)
        {
            return GetUsers(count);
        }

        /// <summary>
        /// Returns an array of users without manifests.
        /// </summary>
        /// <param name="count">Number of users to get.</param>
        /// <returns>Array of users without manifests.</returns>
        public User[] GetUsersWithoutManifests(int count)
        {
            return GetUsers(count, AvatarGender.Unknown);
        }

        /// <summary>
        /// Returns an array of users whose gamertags are of max possible length when url encoded.
        /// </summary>
        /// <param name="count">Number of users to get.</param>
        /// <returns>Array of users with maximum gamertag length.</returns>
        public User[] GetUsersMaxGamertagLength(int count)
        {
            List<User> foundUserList = userList.Values.Where(user => user.Gamertag.Length == TestSettings.MAX_GAMERTAG_LENGTH).ToList();

            // Create users if the cache doesn't have enough
            int additionalCount = foundUserList.Count - count;
            for (int i = 0; i < additionalCount; i++)
            {
                User user;
                string gamertag;
                while (true)
                {
                    gamertag = GetRandomGamertagMaxLength();
                    if (!userList.ContainsKey(gamertag))
                        break;
                }
                string email = gamertag.Replace(" ", "") + "VeryLong@" + TestSettings.PASSPORT_DOMAIN;
                AccountSettings settings = new AccountSettings(live.common.XblUserTier.Silver, live.common.PassportType.Real, email, TestSettings.PASSPORT_PASSWORD, gamertag);
                try
                {
                    // Try to create a new user.
                    user = new User(settings);
                }
                catch (live.common.XErrFailedException ex)
                {
                    if (ex.HResult == 0x80154013 || ex.HResult == 0x80154000) //80154013: XONLINE_E_PASSPORT_ALREADY_LINKED 80154000: XONLINE_E_ACCOUNTS_NAME_TAKEN
                    {
                        user = new User(Account.LoadExistingAccount(email, TestSettings.PASSPORT_PASSWORD));
                    }
                    else
                        throw new UserSetupException("There was an unhandled exception from Xbox Live service while creating a new user.", ex);
                }
                foundUserList.Add(user);
            }

            // Can't proceed with the test if there aren't enough users.
            if (foundUserList.Count != count)
            {
                throw new UserSetupException(string.Format("There are only {0} users when the test requires {1} users.", foundUserList.Count, count));
            }
            return foundUserList.ToArray();

        }

        public User[] GetUsersWithComponent(int count, ComponentCategories component)
        {
            return GetUsersWithComponent(count, AvatarGender.Both, component);
        }

        public User[] GetUsersWithComponent(int count, AvatarGender gender, ComponentCategories component)
        {
            if (gender == AvatarGender.Unknown)
            {
                throw new UserSetupException("Unknown avatar gender is passed in. Can't expect avatar components for an avatar without a manifest."
                    , new ArgumentException("AvatarGender"));
            }

            List<User> foundUserList;

            IEnumerable<User> result1 = userList.Values.Where(user => user.AwardList.Any(award => (award.Category | component) == component)
                            || user.PurchaseList.Any(purchase => (purchase.Category | component) == component));

            foundUserList = result1.ToList();

            try
            {
                AvatarComponentType avatarComp = (AvatarComponentType)Enum.Parse(typeof(AvatarComponentType), component.ToString(), true);
                IEnumerable<User> result2;
                if (avatarComp != AvatarComponentType.Body)
                {                    
                    result2 = userList.Values.Where(user => user.Manifest != null && user.Manifest.IsComponentPresent(avatarComp));
                    foundUserList.AddRange(result2.ToList());
                }
            }
            catch (ArgumentException)
            {
                // Failed to parse the enum. Ignore it.
            }

            // Create users if the cache doesn't have enough
            int additionalCount = Math.Max(0, count - foundUserList.Count);

            if (additionalCount > 0)
            {
                User[] users = GetUsers(additionalCount, gender, 0, 0);
                for (int i = 0; i < additionalCount; i++)
                {
                    BaseAsset asset = StockAssetCollection.Instance.FindFirst(users[i].Manifest.BodyType, component, false, string.Empty);
                    if (asset == null)
                    {
                        asset = AwardableAssetCollection.Instance.FindFirst(users[i].Manifest.BodyType, component, false, string.Empty);
                        users[i].AwardAsset(asset as AwardableAsset);
                        users[i].EquipAsset(asset);
                    }
                    else
                    {
                        users[i].EquipAsset(asset);
                    }

                    if (asset == null)
                    {
                        asset = MarketplaceAssetCollection.Instance.FindFirst(users[i].Manifest.BodyType, component, false, string.Empty);
                        users[i].PurchaseAsset(asset as MarketplaceAsset);
                        users[i].EquipAsset(asset);
                    }
                    if (asset == null)
                    {
                        throw new UserSetupException("There are no available carryable asset to equip.");
                    }

                    users[i].WriteManifest(true, Config.Environment.ManifestWritePrivateService);
                    foundUserList.Add(users[i]);
                }

                Thread.Sleep(31 * 1000); // Wait till cache clears
            }

            // Can't proceed with the test if there aren't enough users.
            if (foundUserList.Count < count)
            {
                throw new UserSetupException(string.Format("There are only {0} users when the test requires {1} users.", foundUserList.Count, count));
            }
            return foundUserList.GetRange(0, count).ToArray();
        }

        public User[] GetUsers(int count)
        {
            return GetUsers(count, AvatarGender.Both);
        }

        public User[] GetUsers(int count, AvatarGender gender)
        {
            return GetUsers(count, gender, 0, 0);
        }

        public User[] GetUsers(int count, AvatarGender gender, int purchaseCount, int awardCount)
        {
            List<User> foundUserList;
            IEnumerable<User> result = userList.Values.Where(user => user.PurchaseList.Count == purchaseCount
                                                            && user.AwardList.Count == awardCount);
            if (gender == AvatarGender.Unknown)
            {
                result = result.Where(user => user.Manifest == null);
            }
            else
            {
                result = result.Where(user => user.Manifest != null && (user.Manifest.BodyType & gender) == user.Manifest.BodyType);
            }
            foundUserList = result.ToList();

            // Create users if the cache doesn't have enough
            int additionalCount = Math.Max(0, count - foundUserList.Count);
            foundUserList.AddRange(CreateUsers(additionalCount, gender, purchaseCount, awardCount));          

            // Can't proceed with the test if there aren't enough users.
            if (foundUserList.Count < count)
            {
                throw new UserSetupException(string.Format("There are only {0} users when the test requires {1} users.", foundUserList.Count, count));
            }
            return foundUserList.GetRange(0, count).ToArray();
        }

        public User[] CreateUsers(int count, AvatarGender gender, int purchaseCount, int awardCount)
        {
            List<User> users = new List<User>();
            for (int i = 0; i < count; i++)
            {
                User user = User.CreateUser(gender, purchaseCount, awardCount);
                users.Add(user);
                userList.Add(user.Gamertag, user);
            }
            return users.ToArray();
        }

        /// <summary>
        /// Returns a random gamertag of max possible length when url encoded.
        /// </summary>
        /// <returns>Gamerga of maximum possible length.</returns>
        private string GetRandomGamertagMaxLength()
        {
            string gamertag = string.Empty;
            // Start with a letter
            for (int i = 0; i < TestSettings.MAX_GAMERTAG_LENGTH; i++)
            {
                if (i % 2 == 0)
                    gamertag += TestSettings.VALID_GAMERTAG_CHARACTERS[rand.Next(26)].ToString();
                else
                    gamertag += " ";
            }
            return gamertag;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\Authorization\Authorization.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net;
using System.IO;
using System.Xml.Linq;
using System.Xml;
using System.Diagnostics;
using System.Configuration;
using System.Security.Cryptography.X509Certificates;
using System.Net.Sockets;
using System.Net.Security;

using LiveN.Test.Framework;
using AvatarServices.Test.Common;
using RPSTicketCreation;


namespace AvatarServices.Test.Common
{
    /// <summary>
    /// 
    /// </summary>
    public class Authorization
    {

        private static string SecurityTicketQuery = "/GetSecurityTicket?platformType={platformId}&titleId={titleId}&titleVersion={titleVersion}&clientVersion={clientVersion}&deviceId={deviceId}";
        private static string PartnerSecurityTicketQuery = "/GetPartnerSecurityTicket?xuid={xuid}&titleId={titleId}&titleVersion={titleVersion}&audience={audienceUri}";
        private static RPSTicketGenerator rpsTicketGenerator;

        /// <summary>
        /// 
        /// </summary>
        public static RPSTicketGenerator RpsTicketGenerator
        {
            get
            {
                if (rpsTicketGenerator == null)
                {
                    RPSTicketGeneratorConfig ticketConfig = new RPSTicketGeneratorConfig();
                    ticketConfig.SiteURL = String.Format("http://{0}", Config.Environment.StsSettings.LiveIdServiceTarget);
                    ticketConfig.PPEnv = PassportEnvironment.INT;
                    ticketConfig.CacheData = false;

                    rpsTicketGenerator = new RPSTicketGenerator(ticketConfig);
                }

                return rpsTicketGenerator;
            }
        }

        /// <summary>
        /// Helper method - to get LiveIDToken using LiveIDClient (IDCRL).
        /// </summary>
        public static string GenerateLoginTicket(string username, string password)
        {
            string loginTicket = null;

            try
            {
                TraceEx.TraceVerbose("Attempting to get a Windows LiveID login ticket for {0}/{1}...", username, password);

                loginTicket = LiveID.GetLoginTicket(
                    username,
                    password,
                    Config.Environment.StsSettings.LiveIdServiceTarget,
                    Config.Environment.UserSettings[username].Policy,
                    Config.Environment.UserSettings[username].Environment);
            }
            catch (Exception e)
            {
                try
                {
                    Trace.TraceWarning("Failed to get a Windows LiveID login ticket for {0}/{1}, using IDCRL.  Attempting HTTP form/cookie scrapes with RpsTicketGenerator...", username, password);
                    Trace.TraceError("IDCRL exception:\r\n{0}", e);

                    //if IDCRL fails, try using RpsTicketGenerator, which - literally - does HTML form/cookie scraping
                    loginTicket = RpsTicketGenerator.GetRPSCompactTicket(username, password);
                    loginTicket = "t=" + loginTicket.Trim('"');
                }
                catch (Exception ex)
                {
                    throw new Exception(String.Format("Error getting Windows LiveID login ticket for {0}/{1}, using RpsTicketGenerator.", username, password), ex);
                }
            }

            return loginTicket;
        }

        /// todo(michperr): Not Threadsafe
        /// </summary>
        /// <param name="cert"></param>
        /// <param name="stsPath"></param>
        private static void CertHack(X509Certificate cert, Uri stsPath)
        {
            RemoteCertificateValidationCallback rcvc = delegate(object sender, System.Security.Cryptography.X509Certificates.X509Certificate certificate,
                                           System.Security.Cryptography.X509Certificates.X509Chain chain,
                                           System.Net.Security.SslPolicyErrors sslPolicyErrors)
            {
                return true;
            };

            try
            {
                ServicePointManager.ServerCertificateValidationCallback += rcvc;

                LocalCertificateSelectionCallback lcsc = delegate(object sender, string targetHost, X509CertificateCollection localCertificates,
                   X509Certificate remoteCertificate, string[] acceptableIssuers)
                {
                    //reference to the local passed in certificate
                    return cert;
                };

                using (TcpClient tcp = new TcpClient(stsPath.Host, stsPath.Port))
                {
                    using (SslStream ssl = new SslStream(tcp.GetStream(), false, rcvc, lcsc))
                    {
                        ssl.AuthenticateAsClient(stsPath.Host, new X509CertificateCollection(new X509Certificate[] { cert }),
                            System.Security.Authentication.SslProtocols.Default, false);

                        // create a request that we don't care about
                        BasicHttpRequest dummyReq = new BasicHttpRequest("https://" + stsPath.Host + ":" + stsPath.Port + "/sts/sts.asmx");

                        //HttpRequest req = new HttpRequest(serverAndPort, "/sts/sts.asmx");

                        ssl.Write(dummyReq.ToBytes());
                        ssl.Flush();
                        // this read is necessary to force the client certificate
                        ssl.Read(new byte[1], 0, 1);
                        ssl.Close();
                    }
                }
            }
            finally
            {
                ServicePointManager.ServerCertificateValidationCallback -= rcvc;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="loginTicket"></param>
        /// <param name="gameId"></param>
        /// <param name="gameVersion"></param>
        /// <returns></returns>
        public static string GenerateWebSTSToken(string loginTicket, string gameId, string gameVersion)
        {
            WebStsService wss = new WebStsService(Config.Environment.StsSettings.WebStsUrl);
            SecurityTokensResponse str = wss.GetSamlTokensXml(/*loginTicket,*/ WebStsService.GetUserTokensUrlFormat, gameId, gameVersion, null, null, TokenType.UserToken, WebStsService.RpsCookieName);
            return str.UserToken;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="loginTicket"></param>
        /// <param name="gameId"></param>
        /// <param name="gameVersion"></param>
        /// <returns></returns>
        public static string GenerateWebPartnerSTSToken(string loginTicket, string gameId, string gameVersion)
        {
            WebStsService wss = new WebStsService(Config.Environment.StsSettings.WebStsUrl);
            SecurityTokensResponse str = wss.GetSamlTokensXml(/*loginTicket,*/ WebStsService.GetPartnerTokensUrlFormat, gameId, gameVersion, null, null, TokenType.PartnerToken, WebStsService.RpsCookieName);
            return str.PartnerToken;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="loginTicket"></param>
        /// <returns></returns>
        public static string GeneratePlatformSTSToken(string loginTicket)
        {
            X509Certificate2 cert = InstallStsClientCertificate();
            string[] parts = cert.Subject.Split(':');
            //this is awesome... sometimes the device id is in the subject, other times the thumb is expected
            string deviceId = (parts.Length == 3) ? parts[2] : cert.Thumbprint;

            string queryString = SecurityTicketQuery;
            queryString = queryString.Replace("{platformId}", Config.Environment.StsSettings.PlatformType);
            queryString = queryString.Replace("{titleId}", Config.Environment.StsSettings.TitleId);
            queryString = queryString.Replace("{titleVersion}", Config.Environment.StsSettings.TitleVersion);
            queryString = queryString.Replace("{clientVersion}", Config.Environment.StsSettings.ClientVersion);
            queryString = queryString.Replace("{deviceId}", deviceId);

            string fullUrl = Config.Environment.StsSettings.StsUrl + queryString;
            TraceEx.TraceVerbose("Sending the following STS request: {0}", fullUrl);

            BasicHttpRequest httpRequest = new BasicHttpRequest(fullUrl);
            httpRequest.BaseHttpRequest.Timeout = int.Parse(ConfigurationManager.AppSettings["Timeout"]);
            httpRequest.BaseHttpRequest.Headers.Add("Authorization", "WLID1.0 " + loginTicket);

            if (fullUrl.StartsWith("https://"))
            {
                CertHack(cert, new Uri(fullUrl));
                httpRequest.BaseHttpRequest.ClientCertificates.Add(cert);
            }

            string response = httpRequest.GetResponse();

            if (httpRequest.HttpResponse.StatusCode != HttpStatusCode.OK)
            {
                StringBuilder trace = new StringBuilder();
                trace.AppendFormat("Error getting STS token:\r\n\r\nHTTP/1.1 {0} {1}\r\n", (int)httpRequest.HttpResponse.StatusCode, httpRequest.HttpResponse.StatusCode);
                foreach (string key in httpRequest.HttpResponse.Headers.Keys)
                    trace.AppendFormat("{0}: {1}\r\n", key, httpRequest.HttpResponse.Headers[key]);

                if (!String.IsNullOrEmpty(response))
                    trace.AppendFormat("\r\n{0}\r\n", response);

                throw new Exception(trace.ToString());
            }

            string stsToken = GetSamlTokenXml(response);
            return stsToken;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsToken"></param>
        /// <returns></returns>
        public static string GeneratePartnerSecurityToken(string stsToken)
        {
            return GeneratePartnerSecurityToken(stsToken, Config.Environment.StsSettings.AudienceUri);
        }

        /// <summary>
        /// Helper method - to get PartnerSecurityTicket using GetPartnerSecurityTicket from STS/sts.asmx.
        /// </summary>
        public static string GeneratePartnerSecurityToken(string stsToken, string audienceUri)
        {
            string xuid = Authorization.GetXuid(stsToken);

            string queryString = PartnerSecurityTicketQuery;
            queryString = queryString.Replace("{xuid}", xuid);
            queryString = queryString.Replace("{titleId}", Config.Environment.StsSettings.TitleId);
            queryString = queryString.Replace("{titleVersion}", Config.Environment.StsSettings.TitleVersion);
            queryString = queryString.Replace("{audienceUri}", System.Web.HttpUtility.UrlEncode(Config.Environment.StsSettings.AudienceUri));

            string fullUrl = Config.Environment.StsSettings.StsUrl + queryString;
            TraceEx.TraceVerbose("Sending the following Partner Security Token request: {0}", fullUrl);

            BasicHttpRequest httpRequest = new BasicHttpRequest(fullUrl);
            httpRequest.BaseHttpRequest.Timeout = int.Parse(ConfigurationManager.AppSettings["Timeout"]);
            httpRequest.BaseHttpRequest.Headers.Add("X-Authorization", "XBL1.0 x=" + stsToken);

            if (fullUrl.StartsWith("https://"))
            {
                X509Certificate2 cert = InstallStsClientCertificate();
                CertHack(cert, new Uri(fullUrl));
                httpRequest.BaseHttpRequest.ClientCertificates.Add(cert);
            }

            string response = httpRequest.GetResponse();
            if (httpRequest.HttpResponse.StatusCode != HttpStatusCode.OK)
            {
                StringBuilder trace = new StringBuilder();
                trace.AppendFormat("Error getting Partner Security Token token:\r\n\r\nHTTP/1.1 {0} {1}\r\n", (int)httpRequest.HttpResponse.StatusCode, httpRequest.HttpResponse.StatusCode);
                foreach (string key in httpRequest.HttpResponse.Headers.Keys)
                    trace.AppendFormat("{0}: {1}\r\n", key, httpRequest.HttpResponse.Headers[key]);

                if (!String.IsNullOrEmpty(response))
                    trace.AppendFormat("\r\n{0}\r\n", response);

                throw new Exception(trace.ToString());
            }

            string partnerTicket = GetSamlTokenXml(response);
            return partnerTicket;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="STSTicket"></param>
        /// <returns></returns>
        public static string GetXuid(string stsToken)
        {
            try
            {
                XmlDocumentEx xmlDoc = new XmlDocumentEx(stsToken, true);
                XmlNode node = xmlDoc.SelectSingleNode("saml:Assertion/saml:AttributeStatement/saml:Attribute[@AttributeName='Xuid0']/saml:AttributeValue", xmlDoc.NamespaceManager);
                if (node == null)
                    throw new ApplicationException("No xuid claim was found in the STS token! Most likely, this is a machine security token and not a user token. The Windows Live ID ticket used to generate this token most likely does NOT have an Xbox Live account.");
                return node.InnerText;
            }
            catch (XmlException e)
            {
                throw new ApplicationException(String.Format("Invalid STS token: {0}", e.Message), e);
            }
        }

        public static string GetXuid(string userID, string password)
        {
            return GetXuid(AuthorizationCache.GetStsToken(userID, password));
        }
        /// <summary>
        /// Helper method - to parse STSServiceResponse from GetSecurityTicket.
        /// </summary>
        private static string GetSamlTokenXml(string stsServiceResponse)
        {
            try
            {
                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.LoadXml(stsServiceResponse);

                //returning the first child of the root document element
                return xmlDoc.DocumentElement.FirstChild.Value;
            }
            catch (Exception ex)
            {
                throw new ApplicationException("The STS token was invalid: " + ex.Message, ex);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public static X509Certificate2 InstallStsClientCertificate()
        {
            X509Certificate2 clientCert;
            X509Store localMachineMy = new X509Store(StoreName.My, StoreLocation.LocalMachine);

            try
            {
                localMachineMy.Open(OpenFlags.ReadWrite);
                X509Certificate2Collection certs = localMachineMy.Certificates.Find(X509FindType.FindBySubjectName, Config.Environment.StsSettings.ClientCertSubject, false);
                if (certs.Count == 0)
                {
                    Trace.TraceInformation("Required STS client certificate not found; installing CN={0} to LOCAL_MACHINE\\My", Config.Environment.StsSettings.ClientCertSubject);
                    string testCertPath = Path.Combine(Utility.CurrentDirectory, "2CVIfNWSzOr-aVLGLnunBFyLF8mNiR6DOUqYbxcXDr4.pfx");
                    if (!File.Exists(testCertPath))
                        throw new ApplicationException(String.Format("Unable to find STS client certificate, required for authentication, at: {0}", testCertPath));

                    X509Certificate2 testCert = new X509Certificate2(testCertPath, "udc", X509KeyStorageFlags.MachineKeySet | X509KeyStorageFlags.PersistKeySet);
                    localMachineMy.Add(testCert);
                    clientCert = testCert;
                    Trace.TraceInformation("Successfully installed STS client certificate.");
                }
                else
                {
                    Trace.TraceInformation("Verified that the expected STS client certificate, CN={0}, is installed, with private key, in LOCAL_MACHINE\\My", Config.Environment.StsSettings.ClientCertSubject);
                    clientCert = certs[0];
                }
            }
            catch (Exception e)
            {
                throw new ApplicationException("Error enumerating or adding required test certificate to LOCAL_MACHINE\\My.", e);
            }
            finally
            {
                if (localMachineMy != null)
                    localMachineMy.Close();
            }

            return clientCert;
        }

        /// <summary>
        /// 
        /// </summary>
        public static X509Certificate2 InstallClientCertificate(string testCertPath, string thumbprint, string password, string nameOfServiceCertIsUsedFor)
        {
            X509Certificate2 clientCert = null;
            X509Store localMachineMy = new X509Store(StoreName.My, StoreLocation.LocalMachine);
            try
            {
                localMachineMy.Open(OpenFlags.ReadWrite);
                X509Certificate2Collection certs = localMachineMy.Certificates.Find(X509FindType.FindByThumbprint, thumbprint, false);
                if (certs.Count == 0)
                {
                    Trace.TraceInformation("Required {0} client certificate with thumbprint = {1} is not found; installing {2} to LOCAL_MACHINE\\My", nameOfServiceCertIsUsedFor, thumbprint, testCertPath);
                    if (!File.Exists(testCertPath))
                        throw new ApplicationException(String.Format("Unable to find {0} client certificate, required for authentication, at: {1}", nameOfServiceCertIsUsedFor, testCertPath));
                    X509Certificate2 testCert = new X509Certificate2(testCertPath, password, X509KeyStorageFlags.MachineKeySet | X509KeyStorageFlags.PersistKeySet);
                    localMachineMy.Add(testCert);
                    clientCert = testCert;
                    Trace.TraceInformation("Successfully installed " + nameOfServiceCertIsUsedFor + " client certificate.");
                }
                else
                {
                    Trace.TraceInformation("Verified that the expected " + nameOfServiceCertIsUsedFor + " client certificate with thumbprint = {0} is installed, with private key, in LOCAL_MACHINE\\My", ConfigurationManager.AppSettings["PFEClientCertThumbprint"]);
                    clientCert = certs[0];
                }
            }
            catch (Exception e)
            {
                throw new ApplicationException("Error enumerating or adding required " + nameOfServiceCertIsUsedFor + " test certificate to LOCAL_MACHINE\\My.", e);
            }
            finally
            {
                if (localMachineMy != null)
                    localMachineMy.Close();
            }
            return clientCert;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\Authorization\SecurityTokensResponse.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using System.Net;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace AvatarServices.Test.Common
{

    public enum TokenType : byte { UserToken = 1, PartnerToken };

    /// <summary>
    /// 
    /// </summary>
    public class SecurityTokensResponse
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="response"></param>
        /// <param name="tokenType"></param>
        public SecurityTokensResponse(string response, TokenType tokenType)
        {
            ParseTokens(response, tokenType);
        }

        /// <summary>
        /// 
        /// </summary>
        public string UserToken
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string PartnerToken
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="response"></param>
        /// <param name="tokenType"></param>
        protected void ParseTokens(string response, TokenType tokenType)
        {
            try
            {
                XmlDocumentEx xmlResponse = new XmlDocumentEx(response, true);

                switch (tokenType)
                {
                    case TokenType.UserToken:
                        ParseUserTokens(response, xmlResponse);
                        break;
                    case TokenType.PartnerToken:
                        ParsePartnerTokens(response, xmlResponse);
                        break;
                }
            }
            catch (XmlException)
            {
                throw new ApplicationException(String.Format("Invalid Xml returned by WebSTS service:\r\n\r\n{0}", response));
            }
        }

        /// <summary>
        /// Gets the user token and asserts that partner token is null
        /// </summary>
        /// <param name="response"></param>
        /// <param name="xmlResponse"></param>
        protected void ParseUserTokens(string response, XmlDocumentEx xmlResponse)
        {
            // get user token
            XmlNode temp = xmlResponse.SelectSingleNode("dfltns:Tokens/dfltns:User", xmlResponse.NamespaceManager);
            if (temp == null)
                throw new ApplicationException(String.Format("User token (Tokens/User) not found in WebSTS response:\r\n\r\n{0}", response));
            this.UserToken = temp.InnerText;

            // assert that the partner token is null
            temp = xmlResponse.SelectSingleNode("dfltns:Tokens/dfltns:Partner", xmlResponse.NamespaceManager);
            Assert.AreEqual(temp.InnerText, "", String.Format("GetUserTokensXml API should not return partner token in WebSTS response. Partner Token: \"{0}\" returned ", temp.InnerText));
            Assert.AreEqual(temp.Attributes["i:nil"].Value, "true");
        }

        /// <summary>
        /// Gets the partner token and asserts that the user token is null
        /// </summary>
        /// <param name="response"></param>
        /// <param name="xmlResponse"></param>
        protected void ParsePartnerTokens(string response, XmlDocumentEx xmlResponse)
        {
            // get the partner token
            XmlNode temp = xmlResponse.SelectSingleNode("dfltns:Tokens/dfltns:Partner", xmlResponse.NamespaceManager);
            if (temp == null)
                throw new ApplicationException(String.Format("Partner token (Tokens/Partner) not found in WebSTS response:\r\n\r\n{0}", response));
            this.PartnerToken = temp.InnerText;

            // assert that the user token is null
            temp = xmlResponse.SelectSingleNode("dfltns:Tokens/dfltns:User", xmlResponse.NamespaceManager);
            Assert.AreEqual(temp.InnerText, "", String.Format("GetPartnerTokensXml API should not return user token in WebSTS response. User Token: \"{0}\" returned ", temp.InnerText));
            Assert.AreEqual(temp.Attributes["i:nil"].Value, "true");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\Authorization\AuthorizationCache.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Web;
using System.Web.Caching;
using System.Diagnostics;

using LiveN.Test.Framework;
using AvatarServices.Test.Common;

namespace AvatarServices.Test.Common
{
    /// <summary>
    /// Caches authorization information, on a per credential basis, to avoid repeat/superfluous authentications.
    /// Currently hardcoded to cache authorization data for 30 mins.
    /// </summary>
    public static class AuthorizationCache
    {
        private static HttpRuntime httpRuntime;
        private static object syncLock = new object();

        /// <summary>
        /// 
        /// </summary>
        static AuthorizationCache()
        {
            //this ensures that the HttpRuntime cache is available,
            //irrespective of environment (console, web app, winform, etc.)
            if (httpRuntime == null)
            {
                lock (syncLock)
                {
                    if (httpRuntime == null)
                        httpRuntime = new HttpRuntime();
                }
            }

            try
            {
                Trace.TraceInformation("Attempting to clear IDCRL cache...");
                LiveID.ClearIDCRLCache();
            }
            catch { }

        }

        /// <summary>
        /// 
        /// </summary>
        private static Cache AuthCache
        {
            get
            {
                return HttpRuntime.Cache;
            }
        }

        /// <summary>
        /// Flush all cached values
        /// </summary>
        public static void FlushCache()
        {
            foreach (System.Collections.DictionaryEntry entry in AuthCache)
            {
                AuthCache.Remove((string)entry.Key);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <returns></returns>
        public static string GetLoginTicket(string username, string password)
        {
            string key = GetWlidTicketKey(username);
            string loginTicket = AuthCache.Get(key) as string;
            if (loginTicket == null)
            {
                if (Config.Environment.StsSettings.UsePlatformSts == false)
                {
                    loginTicket = LiveID.GetRpsAuthCookie(Config.Environment.StsSettings.WebStsLiveIdUrl, username, password);
                }
                else
                {
                    loginTicket = Authorization.GenerateLoginTicket(username, password);
                }
                AuthCache.Add(key, loginTicket, null, DateTime.Now.AddMinutes(30), Cache.NoSlidingExpiration, CacheItemPriority.Normal, null);
            }

            return loginTicket;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="loginTicket"></param>
        /// <returns></returns>
        public static string GetStsToken(string username, string password)
        {
            string loginTicket = GetLoginTicket(username, password);
            string key = GetUserTokenKey(username);
            string stsToken = AuthCache.Get(key) as string;

            if (stsToken == null)
            {
                if (Config.Environment.StsSettings.UsePlatformSts == false)
                {
                    //todo(michperr): move this value to config
                    stsToken = Authorization.GenerateWebSTSToken(loginTicket, "1297287444", Config.Environment.StsSettings.TitleVersion);
                }
                else
                {
                    stsToken = Authorization.GeneratePlatformSTSToken(loginTicket);
                }
                AuthCache.Add(key, stsToken, null, DateTime.Now.AddMinutes(30), Cache.NoSlidingExpiration, CacheItemPriority.Normal, null);
            }

            return stsToken;
        }

        private static string GetWlidTicketKey(string userName)
        {
            return userName + "WLID";
        }

        private static string GetPartnerTokenKey(string userName)
        {
            return userName.ToLower() + "PartnerToken";
        }

        private static string GetUserTokenKey(string userName)
        {
            return userName.ToLower() + "STS";
        }

        public static string GetPartnerToken(string username, string password)
        {
            string key = GetPartnerTokenKey(username);
            string partnerToken = AuthCache.Get(key) as string;
            
            if (partnerToken == null)
            {
                if (Config.Environment.StsSettings.UsePlatformSts == false)
                {
                    partnerToken = Authorization.GenerateWebPartnerSTSToken(
                        GetLoginTicket(username, password),
                        Config.Environment.StsSettings.TitleId,
                        Config.Environment.StsSettings.TitleVersion);
                }
                else
                {
                    partnerToken = Authorization.GeneratePartnerSecurityToken(GetStsToken(username, password));
                }
                AuthCache.Add(key, partnerToken, null, DateTime.Now.AddMinutes(30), Cache.NoSlidingExpiration, CacheItemPriority.Normal, null);
            }

            return partnerToken;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\Authorization\WebStsService.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using System.IO;
using System.Net;

using AvatarServices.Test.Common;

namespace AvatarServices.Test.Common
{
    /// <summary>
    /// 
    /// </summary>
    public class WebStsService : RestRequest
    {
        public const string GetUserTokensUrlFormat = "/usertoken?gameId={gameId}&gameVersion={gameVersion}";
        public const string GetPartnerTokensUrlFormat = "/partnertoken?gameId={gameId}&gameVersion={gameVersion}&audienceUri={audienceUri}";

        /// <summary>
        /// 
        /// </summary>
        /// <param name="baseUri"></param>
        public WebStsService(string baseUri)
        {
            this.BaseUri = baseUri;
        }

        /// <summary>
        /// 
        /// </summary>
        public string BaseUri
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="gameId"></param>
        /// <param name="gameVersion"></param>
        /// <param name="audienceUri"></param>
        /// <returns></returns>
        public string FormatGameStateUrl(string url, string gameId, string gameVersion, string audienceUri)
        {
            return this.BaseUri + url.Replace("{gameId}", gameId).Replace("{gameVersion}", gameVersion).Replace("{audienceUri}", audienceUri);
        }

        /// <summary>
        /// Formats part of the url when there are multiple game ids
        /// </summary>
        /// <param name="url"></param>
        /// <param name="gameIds"></param>
        public string FormatMultipleGameIdsUrl(string url, params string[] gameIds)
        {
            for (int i = 0; i < gameIds.Length; i++)
            {
                url = url.Replace("gameId" + i.ToString(), gameIds[i]);
            }
            return url;
        }

        /// <summary>
        /// Formats part of the url when there are multiple audience uris
        /// </summary>
        /// <param name="url"></param>
        /// <param name="audienceUris"></param>
        public string FormatMultipleAudienceUrisUrl(string url, params string[] audienceUris)
        {
            for (int i = 0; i < audienceUris.Length; i++)
            {
                url = url.Replace("audienceUri" + i.ToString(), audienceUris[i]);
            }
            return url;
        }

        /// <summary>
        /// Gets the Saml token
        /// </summary>
        /// <param name="formatUrl"></param>
        /// <param name="gameId"></param>
        /// <param name="gameVersion"></param>
        /// <param name="audienceUri"></param>
        /// <param name="headers"></param>
        /// <param name="tokenType"></param>
        /// <param name="cookieName"></param>
        /// <returns></returns>
        public SecurityTokensResponse GetSamlTokensXml(string formatUrl, string gameId, string gameVersion, string audienceUri,
                                                            Dictionary<string, string> headers, TokenType tokenType, string cookieName)
        {
            string url;
            url = FormatGameStateUrl(formatUrl, gameId, gameVersion, audienceUri);

            SecurityTokensResponse tokens = GetSamlTokensXML(url, headers, tokenType, cookieName);
            return tokens;
        }

        /// <summary>
        /// Gets the Saml token
        /// </summary>
        /// <param name="url"></param>
        /// <param name="headers"></param>
        /// <param name="tokenType"></param>
        /// <param name="cookieName"></param>
        /// <returns></returns>
        public SecurityTokensResponse GetSamlTokensXML(string url, Dictionary<string, string> headers, TokenType tokenType, string cookieName)
        {
            Dictionary<string, string> httpHeaders;

            if (headers == null)
                httpHeaders = GetHttpHeaders(null, cookieName);
            else
                httpHeaders = headers;

            RestResponse response = Get(url, httpHeaders);
            //HandleResponse(response);
            SecurityTokensResponse tokens = new SecurityTokensResponse(response.Body, tokenType);
            return tokens;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\Configuration\EnvironmentElementCollection.cs ===
using System;
using System.Configuration;

namespace AvatarServices.Test.Common
{
    /// <summary>
    /// 
    /// </summary>
    public class EnvironmentElementCollection : ConfigurationElementCollection
    {
        /// <summary>
        /// 
        /// </summary>
        public EnvironmentElementCollection()
        {

        }

        /// <summary>
        /// 
        /// </summary>
        public override ConfigurationElementCollectionType CollectionType
        {
            get
            {
                return ConfigurationElementCollectionType.AddRemoveClearMap;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        protected override ConfigurationElement CreateNewElement()
        {
            return new EnvironmentElement();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="element"></param>
        /// <returns></returns>
        protected override object GetElementKey(ConfigurationElement element)
        {
            return ((EnvironmentElement)element).Name;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public EnvironmentElement this[int index]
        {
            get
            {
                return (EnvironmentElement)BaseGet(index);
            }
            set
            {
                if (BaseGet(index) != null)
                    BaseRemoveAt(index);
                BaseAdd(index, value);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        new public EnvironmentElement this[string name]
        {
            get
            {
                return (EnvironmentElement)BaseGet(name);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\Configuration\PreExistingUserElementCollection.cs ===
using System;
using System.Configuration;

namespace AvatarServices.Test.Common
{
    /// <summary>
    /// 
    /// </summary>
    public class PreExistingUserElementCollection : ConfigurationElementCollection
    {
        /// <summary>
        /// 
        /// </summary>
        public PreExistingUserElementCollection()
        {

        }

        /// <summary>
        /// 
        /// </summary>
        public override ConfigurationElementCollectionType CollectionType
        {
            get
            {
                return ConfigurationElementCollectionType.AddRemoveClearMap;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        protected override ConfigurationElement CreateNewElement()
        {
            return new PreExistingUserElement();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="element"></param>
        /// <returns></returns>
        protected override object GetElementKey(ConfigurationElement element)
        {
            return ((PreExistingUserElement)element).Membername;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public PreExistingUserElement this[int index]
        {
            get
            {
                return (PreExistingUserElement)BaseGet(index);
            }
            set
            {
                if (BaseGet(index) != null)
                    BaseRemoveAt(index);
                BaseAdd(index, value);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        new public PreExistingUserElement this[string membername]
        {
            get
            {
                return (PreExistingUserElement)BaseGet(membername);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\Configuration\PreExistingUserElement.cs ===
using System;
using System.Configuration;

namespace AvatarServices.Test.Common
{
    /// <summary>
    /// 
    /// </summary>
    public class PreExistingUserElement : ConfigurationElement
    {
        /// <summary>
        /// 
        /// </summary>
        public PreExistingUserElement()
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="usePreExisting"></param>
        /// <param name="msnTouVersion"></param>
        /// <param name="winLiveTouVersion"></param>
        public PreExistingUserElement(string membername, string password, string xuid, string gamerTag, string env, string policy)
        {
            this.Membername = membername;
            this.Password = password;
            this.Xuid = xuid;
            this.Environment = env;
            this.Policy = policy;
            this.Gamertag = gamerTag;
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("membername", IsRequired = true)]
        //[RegexStringValidator(@"^[a-zA-Z0-9-_\.]{1,64}@[a-zA-Z0-9]([a-zA-Z0-9]|-(?!\.)|\.(?!\.)(?!-)){2,48}[a-zA-Z]$")]
        public string Membername
        {
            get
            {
                return (string)this["membername"];
            }
            set
            {
                this["membername"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("password", IsRequired = true)]
        public string Password
        {
            get
            {
                return (string)this["password"];
            }
            set
            {
                this["password"] = value;
            }
        }
        [ConfigurationProperty("xuid", IsRequired = false)]
        public string Xuid
        {
            get
            {
                return (string)this["xuid"];
            }
            set
            {
                this["xuid"] = value;
            }
        }
        [ConfigurationProperty("gamertag", IsRequired = true)]
        public string Gamertag
        {
            get
            {
                return (string)this["gamertag"];
            }
            set
            {
                this["gamertag"] = value;
            }
        }

        [ConfigurationProperty("environment", IsRequired = true)]
        public string Environment
        {
            get
            {
                return (string)this["environment"];
            }
            set
            {
                this["environment"] = value;
            }
        }
        [ConfigurationProperty("policy", IsRequired = true)]
        public string Policy
        {
            get
            {
                return (string)this["policy"];
            }
            set
            {
                this["policy"] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\Configuration\EnvironmentElement.cs ===
﻿using System;
using System.Configuration;

namespace AvatarServices.Test.Common
{

    //todo(michperr): Make all the URI's of the URI type so we can ditch the '/' stuff.
    public class EnvironmentElement : ConfigurationElement
    {
        /// <summary>
        /// 
        /// </summary>
        public EnvironmentElement()
        {

        }


        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("name", IsRequired = false, DefaultValue = "DEV")]
        //[RegexStringValidator("^(Dev|Babysitter|Storax|Tesla|StressNet)$")]
        public string Name
        {
            get
            {
                return (string)this["name"];
            }
            set
            {
                this["name"] = value;
            }
        }

        [ConfigurationProperty("ManifestReadService", IsRequired = false)]
        public string ManifestReadService
        {
            get
            {
                string uri = (string)this["ManifestReadService"];
                if (uri.EndsWith(@"/"))
                {
                    uri = uri.Substring(0, uri.Length - 1);
                }
                return uri;
            }
            set
            {
                this["ManifestReadService"] = value;
            }
        }

        [ConfigurationProperty("ManifestReadPartService", IsRequired = false)]
        public string ManifestReadPartService
        {
            get
            {
                string uri = (string)this["ManifestReadPartService"];
                if (uri.EndsWith(@"/"))
                {
                    uri = uri.Substring(0, uri.Length - 1);
                }
                return uri;
            }
            set
            {
                this["ManifestReadPartService"] = value;
            }
        }

        [ConfigurationProperty("ManifestWritePartService", IsRequired = false)]
        public string ManifestWritePartService
        {
            get
            {
                string uri = (string)this["ManifestWritePartService"];
                if (uri.EndsWith(@"/"))
                {
                    uri = uri.Substring(0, uri.Length - 1);
                }
                return uri;
            }
            set
            {
                this["ManifestWritePartService"] = value;
            }
        }

        [ConfigurationProperty("ClosetPartService", IsRequired = false)]
        public string ClosetPartService
        {
            get
            {
                Uri uri;
                if (!Uri.TryCreate((string)this["ClosetPartService"], UriKind.Absolute, out uri))
                {
                    throw new ArgumentException("ClosetPartService should be a valid absolute URI");
                }
                return uri.ToString();
            }
            set
            {
                this["ClosetPartService"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("GameDataService", IsRequired = false)]
        public string GameDataService
        {
            get
            {
                string uri = (string)this["GameDataService"];
                if (!uri.EndsWith(@"/"))
                {
                    uri = uri + "/";
                }
                return uri;
            }
            set
            {
                this["GameDataService"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("GameSessionService", IsRequired = false)]
        public string GameSessionService
        {
            get
            {
                string uri = (string)this["GameSessionService"];
                if (uri.EndsWith(@"/"))
                {
                    uri = uri.Substring(0, uri.Length - 1);
                }
                return uri;
            }
            set
            {
                this["GameSessionService"] = value;
            }
        }

        [ConfigurationProperty("GameStateService", IsRequired = false)]
        public string GameStateService
        {
            get
            {
                string uri = (string)this["GameStateService"];
                if (uri.EndsWith(@"/"))
                {
                    uri = uri.Substring(0, uri.Length - 1);
                }
                return uri;
            }
            set
            {
                this["GameStateService"] = value;
            }
        }

        [ConfigurationProperty("NotificationsService", IsRequired = false)]
        public string NotificationsService
        {
            get
            {
                string uri = (string)this["NotificationsService"];
                if (!uri.EndsWith(@"/"))
                {
                    uri = uri + "/";
                }
                return uri;
            }
            set
            {
                this["NotificationsService"] = value;
            }
        }

        [ConfigurationProperty("NotificationsServicePrivate", IsRequired = false)]
        public string NotificationsServicePrivate
        {
            get
            {
                string uri = (string)this["NotificationsServicePrivate"];
                if (!uri.EndsWith(@"/"))
                {
                    uri = uri + "/";
                }
                return uri;
            }
            set
            {
                this["NotificationsServicePrivate"] = value;
            }
        }


        [ConfigurationProperty("PartnerService", IsRequired = false)]
        public string PartnerService
        {
            get
            {
                string uri = (string)this["PartnerService"];
                if (!uri.EndsWith(@"/"))
                {
                    uri = uri + "/";
                }
                return uri;
            }
            set
            {
                this["PartnerService"] = value;
            }
        }


        [ConfigurationProperty("MPTestHooksService", IsRequired = false)]
        public string MPTestHooksService
        {
            get
            {
                string uri = (string)this["MPTestHooksService"];
                if (uri.EndsWith(@"/"))
                {
                    uri = uri.Substring(0, uri.Length - 1);
                }
                return uri;
            }
            set
            {
                this["MPTestHooksService"] = value;
            }
        }



        [ConfigurationProperty("ConnectionString", IsRequired = false)]
        public string ConnectionString
        {
            get
            {
                return (string)this["ConnectionString"];
            }
            set
            {
                this["ConnectionString"] = value;
            }
        }

        [ConfigurationProperty("SsrUseTestService", IsRequired = false, DefaultValue = false)]
        public bool SsrUseTestService
        {
            get
            {
                return (bool)this["SsrUseTestService"];
            }
            set
            {
                this["SsrUseTestService"] = value;
            }
        }

        [ConfigurationProperty("SsrDevServiceAccount", IsRequired = false)]
        public string SsrDevServiceAccount
        {
            get
            {
                return (string)this["SsrDevServiceAccount"];
            }
            set
            {
                this["SsrDevServiceAccount"] = value;
            }
        }

        [ConfigurationProperty("SsrMachineName", IsRequired = false)]
        public string SsrMachineName
        {
            get
            {
                return (string)this["SsrMachineName"];
            }
            set
            {
                this["SsrMachineName"] = value;
            }
        }

        [ConfigurationProperty("CoreTestServiceBaseUrl", IsRequired = false)]
        public string CoreTestServiceBaseUrl
        {
            get
            {
                return (string)this["CoreTestServiceBaseUrl"];
            }
            set
            {
                this["CoreTestServiceBaseUrl"] = value;
            }
        }

        [ConfigurationProperty("LiveLibEnvironment", IsRequired = false)]
        public string LiveLibEnvironment
        {
            get
            {
                return (string)this["LiveLibEnvironment"];
            }
            set
            {
                this["LiveLibEnvironment"] = value;
            }
        }

        [ConfigurationProperty("UseStf", IsRequired = false, DefaultValue = "true")]
        public bool UseStf
        {
            get
            {
                return (bool)this["UseStf"];
            }
            set
            {
                this["UseStf"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("preExistingUsers", IsRequired = false)]
        public PreExistingUserElementCollection UserSettings
        {
            get
            {
                return (PreExistingUserElementCollection)this["preExistingUsers"];
            }
            set
            {
                this["preExistingUsers"] = value;
            }
        }

        [ConfigurationProperty("StsSettings", IsRequired = true)]
        public StsSettingsElement StsSettings
        {
            get
            {
                return (StsSettingsElement)this["StsSettings"];
            }
            set
            {
                this["StsSettings"] = value;
            }
        }

        [ConfigurationProperty("CosmosCacheTimeoutInMinutes", IsRequired = false)]
        public int CosmosCacheTimeoutInMinutes
        {
            get
            {
                return (int)this["CosmosCacheTimeoutInMinutes"];
            }
            set
            {
                this["CosmosCacheTimeoutInMinutes"] = value;
            }
        }

        [ConfigurationProperty("IsTestOnlyEnvironment", IsRequired = false, DefaultValue = false)]
        public bool IsTestOnlyEnvironment
        {
            get
            {
                return (bool)this["IsTestOnlyEnvironment"];
            }
            set
            {
                this["IsTestOnlyEnvironment"] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\LiveLibExtensions\AvatarAsset.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using live.common;

namespace live.protocol
{
    public class AvatarAsset : WireData
    {
        // Fields
        [WireInfo(ArraySize = 0x10)]
        public byte[] AvatarAssetId;
        public uint AvatarAssetOrdinal;
        public DateTime Awarded;
        public uint BodyComponent;
        public byte BodyTypeMask;
        public string Description;
        public byte DescriptionLen;
        public int Flags;
        public string HowTo;
        public byte HowToLen;
        public uint ImageId;
        public uint Sequence;
        public uint SubCategory;
        public string Title;
        public byte TitleLen;
        public const int XAVATAR_DETAILS_PLATFORM_MASK = 0x700000;
        public const int XAVATAR_DETAILS_PLATFORM_SHIFT = 20;

        // Methods
        public AvatarAsset()
        {
            this.AvatarAssetOrdinal = 0;
            this.Awarded = XOn.MinDateTime;
            this.Sequence = 0;
            this.Flags = 0;
            this.ImageId = 0;
            this.TitleLen = 0;
            this.Title = "";
            this.DescriptionLen = 0;
            this.Description = "";
            this.HowToLen = 0;
            this.HowTo = "";
            this.BodyTypeMask = 0;
            this.BodyComponent = 0;
            this.SubCategory = 0;
        }

        public AvatarAsset(uint avatarAssetOrdinal, byte avatarAssetBodyTypeMask, DateTime awarded, int flags)
        {
            this.AvatarAssetOrdinal = 0;
            this.Awarded = XOn.MinDateTime;
            this.Sequence = 0;
            this.Flags = 0;
            this.ImageId = 0;
            this.TitleLen = 0;
            this.Title = "";
            this.DescriptionLen = 0;
            this.Description = "";
            this.HowToLen = 0;
            this.HowTo = "";
            this.BodyTypeMask = 0;
            this.BodyComponent = 0;
            this.SubCategory = 0;
            this.AvatarAssetOrdinal = avatarAssetOrdinal;
            this.BodyTypeMask = avatarAssetBodyTypeMask;
            this.Awarded = awarded;
            this.Flags = flags;
        }

        public static int SetPlatformTypeInFlags(int existingFlags, int platformType)
        {
            int newFlags = existingFlags & -7340033;
            return (newFlags | ((platformType << 20) & 0x700000));
        }
    }

 

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\Configuration\EnvironmentSettingsSection.cs ===
﻿using System;
using System.Configuration;

namespace AvatarServices.Test.Common
{
    /// <summary>
    /// 
    /// </summary>
    public class EnvironmentSettingsSection : ConfigurationSection
    {
        private static ConfigurationPropertyCollection properties;
        private static readonly ConfigurationProperty selected = new ConfigurationProperty("selected", typeof(string));
        private static readonly ConfigurationProperty customSettings = new ConfigurationProperty("environments", typeof(EnvironmentElementCollection));
        private static EnvironmentElement selectedEnvironment;

        /// <summary>
        /// 
        /// </summary>
        public EnvironmentSettingsSection()
        {
            properties = new ConfigurationPropertyCollection();
            properties.Add(customSettings);
            properties.Add(selected);
        }

        /// <summary>
        /// 
        /// </summary>
        protected override ConfigurationPropertyCollection Properties
        {
            get
            {
                return properties;
            }
        }

        [ConfigurationProperty("selected",
            DefaultValue = "Storax",
            IsRequired = true,
            IsKey = false)]
        [StringValidator(InvalidCharacters =
            " ~!@#$%^&*()[]{}/;'\"|\\",
            MinLength = 1, MaxLength = 60)]
        public string Selected
        {
            get
            {
                return (string)this["selected"];
            }
            set
            {
                this["selected"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [ConfigurationProperty("environments", IsRequired = true)]
        public EnvironmentElementCollection Environments
        {
            get
            {
                return (EnvironmentElementCollection)this["environments"];
            }
            set
            {
                this["environments"] = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public EnvironmentElement SelectedEnvironment
        {
            get
            {
                if (selectedEnvironment == null)
                {
                    foreach (EnvironmentElement env in this.Environments)
                    {
                        if (string.Equals(this.Selected, env.Name, StringComparison.OrdinalIgnoreCase))
                        {
                            selectedEnvironment = env;
                            break;
                        }
                    }

                    if (selectedEnvironment == null)
                    {
                        throw new ConfigurationErrorsException("No enviornment marked as selected.");
                    }
                }
                return selectedEnvironment;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\Configuration\StsSettingsElement.cs ===
﻿using System;
using System.Configuration;

namespace AvatarServices.Test.Common
{
    /// <summary>
    /// 
    /// </summary>
    public class StsSettingsElement : ConfigurationElement
    {
        /// <summary>
        /// 
        /// </summary>
        public StsSettingsElement()
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="usePreExisting"></param>
        /// <param name="msnTouVersion"></param>
        /// <param name="winLiveTouVersion"></param>
        public StsSettingsElement(
            string platformType,
            string titleId,
            string titleVersion,
            string clientVersion,
            string audienceUri,
            string clientCertSubject,
            string stsUrl,
            string liveIdServiceTarget,
            bool usePlatformSts)
        {
            this.PlatformType = platformType;
            this.TitleId = titleId;
            this.TitleVersion = titleVersion;
            this.ClientVersion = clientVersion;
            this.AudienceUri = audienceUri;
            this.ClientCertSubject = clientCertSubject;
            this.StsUrl = stsUrl;
            this.LiveIdServiceTarget = liveIdServiceTarget;
            this.UsePlatformSts = usePlatformSts;
        }

        [ConfigurationProperty("UsePlatformSts", DefaultValue = true)]
        public bool UsePlatformSts
        {
            get
            {
                return (bool)this["UsePlatformSts"];
            }
            set
            {
                this["UsePlatformSts"] = value;
            }
        }

        [ConfigurationProperty("WebStsUrl", IsRequired = false)]
        public string WebStsUrl
        {
            get
            {
                return (string)this["WebStsUrl"];
            }
            set
            {
                this["WebStsUrl"] = value;
            }
        }
        [ConfigurationProperty("WebStsLiveIdUrl", IsRequired = false)]
        public string WebStsLiveIdUrl
        {
            get
            {
                return (string)this["WebStsLiveIdUrl"];
            }
            set
            {
                this["WebStsLiveIdUrl"] = value;
            }
        }

        [ConfigurationProperty("LiveIdServiceTarget", IsRequired = false)]
        public string LiveIdServiceTarget
        {
            get
            {
                return (string)this["LiveIdServiceTarget"];
            }
            set
            {
                this["LiveIdServiceTarget"] = value;
            }
        }

        [ConfigurationProperty("StsUrl", IsRequired = false)]
        public string StsUrl
        {
            get
            {
                return (string)this["StsUrl"];
            }
            set
            {
                this["StsUrl"] = value;
            }
        }

        /// <summary>
        /// Overriding becuase the configuration does not allow sets
        /// </summary>
        private string PlatformType_Override = null;

        [ConfigurationProperty("PlatformType", IsRequired = true)]
        public string PlatformType
        {
            get
            {
                if (PlatformType_Override != null)
                {
                    return PlatformType_Override;
                }

                return (string)this["PlatformType"];
            }
            set
            {
                PlatformType_Override = value;
            }
        }

        /// <summary>
        /// Overriding becuase the configuration does not allow sets
        /// </summary>
        private string TitleId_Overrride = null;

        [ConfigurationProperty("TitleId", IsRequired = true)]
        public string TitleId
        {
            get
            {
                if (TitleId_Overrride != null)
                {
                    return TitleId_Overrride;
                }

                return (string)this["TitleId"];
            }
            set
            {
                TitleId_Overrride = value;
            }
        }

        [ConfigurationProperty("TitleVersion", IsRequired = true)]
        public string TitleVersion
        {
            get
            {
                return (string)this["TitleVersion"];
            }
            set
            {
                this["TitleVersion"] = value;
            }
        }

        [ConfigurationProperty("ClientVersion", IsRequired = true)]
        public string ClientVersion
        {
            get
            {
                return (string)this["ClientVersion"];
            }
            set
            {
                this["ClientVersion"] = value;
            }
        }

        [ConfigurationProperty("AudienceUri", IsRequired = false)]
        public string AudienceUri
        {
            get
            {
                return (string)this["AudienceUri"];
            }
            set
            {
                this["AudienceUri"] = value;
            }
        }

        [ConfigurationProperty("ClientCertSubject", IsRequired = false)]
        public string ClientCertSubject
        {
            get
            {
                return (string)this["ClientCertSubject"];
            }
            set
            {
                this["ClientCertSubject"] = value;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\Proxy\BasicHttpRequest.cs ===
using System;
using System.Net;
using System.Text;
using System.Xml;
using System.IO;
using System.Threading;
using System.Runtime.Serialization;

namespace AvatarServices.Test.Common
{
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Summary description for BasicRequest.
	/// </summary>
    /// 
    [Serializable]
	public class BasicHttpRequest
	{
		protected delegate string MakeStringRequestAndGetResponseDelegate(string request, Encoding encoding);
		protected delegate string MakeStreamRequestAndGetResponseDelegate(Stream request, Encoding encoding);

		protected HttpWebRequest webRequest = null;
		protected HttpWebResponse webResponse = null;
		protected string request = String.Empty;
		protected string response = String.Empty;
		protected byte[] rawRequest = null;
		[NonSerialized]
        protected Encoding encoding = null;
		protected WebException lastException = null;
		protected string url;

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="url"></param>
		public BasicHttpRequest(string url)
		{
			this.webRequest = (HttpWebRequest)WebRequest.Create(url);
			this.url = url;
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="uri"></param>
		public BasicHttpRequest(Uri uri)
		{
			this.webRequest = (HttpWebRequest)WebRequest.Create(uri);
			this.url = uri.ToString();
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public HttpWebRequest BaseHttpRequest
		{
			get
			{
				return this.webRequest;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public HttpWebResponse HttpResponse
		{
			get
			{
				return this.webResponse;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public string Request
		{
			get
			{
				return this.request;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public byte[] RawRequest
		{
			get
			{
				return this.rawRequest.Clone() as byte[];
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public string Response
		{
			get
			{
				return this.response;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public WebException LastException
		{
			get
			{
				return this.lastException;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public virtual string Url
		{
			get
			{
				return this.url;
			}
			set
			{
				this.url = value;
				this.webRequest = CloneHttpWebRequest(this.webRequest, value);
			}
		}
		
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="request"></param>
		/// <param name="callback"></param>
		/// <param name="state"></param>
		/// <returns></returns>
		public virtual IAsyncResult BeginMakeRequest(string request, AsyncCallback callback, object state)
		{
			return BeginMakeRequest(request, Encoding.UTF8, callback, state);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="request"></param>
		/// <param name="encoding"></param>
		/// <param name="callback"></param>
		/// <param name="state"></param>
		/// <returns></returns>
		public virtual IAsyncResult BeginMakeRequest(string request, Encoding encoding, AsyncCallback callback, object state)
		{
			if((this.url == null) || (this.url.Length == 0))
			{
				throw new ApplicationException("Attempting to make a web request without specifying a valid Url.  Please provide a valid Url to send a request to.");
			}

			this.lastException = null;

			if(this.webResponse != null)
			{
				this.webResponse.Close();
				this.webResponse = null;
			}

			this.request = request;
			this.rawRequest = encoding.GetBytes(request);
			this.webRequest.ContentLength = this.rawRequest.Length;

			return this.webRequest.BeginGetRequestStream(callback, state);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="requestStream"></param>
		/// <param name="callback"></param>
		/// <param name="state"></param>
		/// <returns></returns>
		public virtual IAsyncResult BeginMakeRequest(Stream requestStream, AsyncCallback callback, object state)
		{
			return BeginMakeRequest(requestStream, Encoding.UTF8, callback, state);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="requestStream"></param>
		/// <param name="encoding"></param>
		/// <param name="callback"></param>
		/// <param name="state"></param>
		/// <returns></returns>
		public virtual IAsyncResult BeginMakeRequest(Stream requestStream, Encoding encoding, AsyncCallback callback, object state)
		{
			string request = String.Empty;
			using(StreamReader reader = new StreamReader(requestStream, encoding))
			{
				request = reader.ReadToEnd();
			}

			return BeginMakeRequest(request, encoding, callback, state);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="ar"></param>
		/// <param name="request"></param>
		/// <param name="encoding"></param>
		public virtual void EndMakeRequest(IAsyncResult ar)
		{
			using(Stream requestStream = this.webRequest.EndGetRequestStream(ar))
			{
				requestStream.Write(this.rawRequest, 0, this.rawRequest.Length);
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="request"></param>
		public virtual void MakeRequest(string request)
		{
			MakeRequest(request, Encoding.UTF8);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="request"></param>
		/// <param name="encoding"></param>
		public virtual void MakeRequest(string request, Encoding encoding)
		{
			if((this.url == null) || (this.url.Length == 0))
			{
				throw new ApplicationException("Attempting to make a web request without specifying a valid Url.  Please provide a valid Url to send a request to.");
			}

			this.lastException = null;

			if(this.webResponse != null)
			{
				this.webResponse.Close();
				this.webResponse = null;
			}

			this.request = request;
			this.rawRequest = encoding.GetBytes(request);

            try
            {
                this.webRequest.ContentLength = this.rawRequest.Length;
            }
            catch (InvalidOperationException)
            {
                //fix for times when a request fails and the underlying HttpWebRequest object can't be reused
                this.webRequest = CloneHttpWebRequest(this.webRequest, this.webRequest.RequestUri.ToString());
            }
			
			using(Stream requestStream = this.webRequest.GetRequestStream())
			{
				requestStream.Write(this.rawRequest, 0, this.rawRequest.Length);
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="stream"></param>
		public virtual void MakeRequest(Stream requestStream)
		{
			MakeRequest(requestStream, Encoding.UTF8);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="stream"></param>
		/// <param name="encoding"></param>
		public virtual void MakeRequest(Stream requestStream, Encoding encoding)
		{
			string request = String.Empty;
			using(StreamReader reader = new StreamReader(requestStream, encoding))
			{
				request = reader.ReadToEnd();
			}

			MakeRequest(request, encoding);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="callback"></param>
		/// <param name="state"></param>
		/// <returns></returns>
		public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, object state)
		{
			return BeginGetResponse(Encoding.UTF8, callback, state);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="callback"></param>
		/// <param name="state"></param>
		/// <returns></returns>
		public virtual IAsyncResult BeginGetResponse(Encoding encoding, AsyncCallback callback, object state)
		{
			this.encoding = encoding;
			return this.webRequest.BeginGetResponse(callback, state);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="ar"></param>
		/// <param name="encoding"></param>
		/// <returns></returns>
		public string EndGetResponse(IAsyncResult ar)
		{				
			try
			{
				GetResponseStream(this.webRequest.EndGetResponse(ar), this.encoding);
			}
			catch(WebException e)
			{
				if(e.Response != null)
				{
					GetResponseStream(e.Response, this.encoding);
				}
				else
				{
					this.lastException = e;
					throw;
				}
			}
						
			return this.response;
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <returns></returns>
		public virtual string GetResponse()
		{
			return GetResponse(Encoding.UTF8);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="encoding"></param>
		/// <returns></returns>
		public virtual string GetResponse(Encoding encoding)
		{
			try
			{
				GetResponseStream(this.webRequest.GetResponse(), encoding);
			}
			catch (WebException e)
			{
				if (e.Response != null)
				{
					GetResponseStream(e.Response, encoding);
				}
				else
				{
					this.lastException = e;
					throw;
				}
			}
			finally
			{
				this.webRequest = CloneHttpWebRequest(this.webRequest, null);
			}
							
			return this.response;
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="request"></param>
		/// <param name="callback"></param>
		/// <param name="state"></param>
		/// <returns></returns>
		public virtual IAsyncResult BeginMakeRequestAndGetResponse(string request, AsyncCallback callback, object state)
		{
			return BeginMakeRequestAndGetResponse(request, Encoding.UTF8, callback, state);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="request"></param>
		/// <param name="encoding"></param>
		/// <param name="callback"></param>
		/// <param name="state"></param>
		/// <returns></returns>
		public virtual IAsyncResult BeginMakeRequestAndGetResponse(string request, Encoding encoding, AsyncCallback callback, object state)
		{
			MakeStringRequestAndGetResponseDelegate beginAsync = new MakeStringRequestAndGetResponseDelegate(MakeRequestAndGetResponse);
			return beginAsync.BeginInvoke(request, encoding, callback, state);
			
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="request"></param>
		/// <param name="callback"></param>
		/// <param name="state"></param>
		/// <returns></returns>
		public virtual IAsyncResult BeginMakeRequestAndGetResponse(Stream request, AsyncCallback callback, object state)
		{
			return BeginMakeRequestAndGetResponse(request, Encoding.UTF8, callback, state);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="request"></param>
		/// <param name="encoding"></param>
		/// <param name="callback"></param>
		/// <param name="state"></param>
		/// <returns></returns>
		public virtual IAsyncResult BeginMakeRequestAndGetResponse(Stream request, Encoding encoding, AsyncCallback callback, object state)
		{
			MakeStreamRequestAndGetResponseDelegate beginAsync = new MakeStreamRequestAndGetResponseDelegate(MakeRequestAndGetResponse);
			return beginAsync.BeginInvoke(request, encoding, callback, state);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="ar"></param>
		/// <returns></returns>
		public virtual string EndMakeRequestAndGetResponse(IAsyncResult ar)
		{
			if(ar.AsyncState.GetType() == typeof(MakeStringRequestAndGetResponseDelegate))
			{
				MakeStringRequestAndGetResponseDelegate endAsync = (MakeStringRequestAndGetResponseDelegate)ar.AsyncState;
				return endAsync.EndInvoke(ar);
			}
			else
			{
				MakeStreamRequestAndGetResponseDelegate endAsync = (MakeStreamRequestAndGetResponseDelegate)ar.AsyncState;
				return endAsync.EndInvoke(ar);
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="request"></param>
		/// <returns></returns>
		public virtual string MakeRequestAndGetResponse(string request)
		{
			return MakeRequestAndGetResponse(request, Encoding.UTF8);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="request"></param>
		/// <param name="encoding"></param>
		/// <returns></returns>
		public virtual string MakeRequestAndGetResponse(string request, Encoding encoding)
		{
			MakeRequest(request, encoding);
			return GetResponse(encoding);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="requestStream"></param>
		/// <returns></returns>
		public virtual string MakeRequestAndGetResponse(Stream requestStream)
		{
			return MakeRequestAndGetResponse(requestStream, Encoding.UTF8);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="requestStream"></param>
		/// <param name="encoding"></param>
		/// <returns></returns>
		public virtual string MakeRequestAndGetResponse(Stream requestStream, Encoding encoding)
		{
			MakeRequest(requestStream, encoding);
			return GetResponse(encoding);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="response"></param>
		protected void GetResponseStream(WebResponse response, Encoding encoding)
		{
			this.webResponse = (HttpWebResponse)response;

			//if we don't do this, the app can run out of connections! Disposes of the underlying response stream...
			using(StreamReader reader = new StreamReader(this.webResponse.GetResponseStream(), encoding))
			{
				this.response = reader.ReadToEnd();
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="httpRequest"></param>
		protected static HttpWebRequest CloneHttpWebRequest(HttpWebRequest httpRequest, string newUrl)
		{
			if((httpRequest == null) || ((httpRequest.RequestUri == null) && String.IsNullOrEmpty(newUrl)))
			{
				throw new ApplicationException("Attempting to generate a new HttpWebRequest without specifying a valid Url.  Verify that the Url is valid and has been properly set.");
			}

			HttpWebRequest clone = (HttpWebRequest)WebRequest.Create((String.IsNullOrEmpty(newUrl) ? httpRequest.RequestUri.ToString() : newUrl));

			clone.AllowAutoRedirect = httpRequest.AllowAutoRedirect;
			clone.AllowWriteStreamBuffering = httpRequest.AllowWriteStreamBuffering;
			clone.AuthenticationLevel = httpRequest.AuthenticationLevel;
			clone.AutomaticDecompression = httpRequest.AutomaticDecompression;
			clone.CachePolicy = httpRequest.CachePolicy;
			clone.ClientCertificates.AddRange(httpRequest.ClientCertificates);
			clone.ConnectionGroupName = httpRequest.ConnectionGroupName;
			clone.ContentType = httpRequest.ContentType;
			clone.ContinueDelegate = httpRequest.ContinueDelegate;
			clone.CookieContainer = httpRequest.CookieContainer;
			clone.Credentials = httpRequest.Credentials;

            for (int i = 0; i < httpRequest.Headers.Keys.Count; i++)
            {
                try
                {
                    if (httpRequest.Headers.Keys[i].Equals("Host", StringComparison.OrdinalIgnoreCase)
                        || httpRequest.Headers.Keys[i].Equals("Proxy-Connection", StringComparison.OrdinalIgnoreCase)
                        || httpRequest.Headers.Keys[i].Equals("Connection", StringComparison.OrdinalIgnoreCase))
                    {
                        continue;
                    }
                    clone.Headers.Add(httpRequest.Headers.Keys[i], httpRequest.Headers[httpRequest.Headers.Keys[i]]);
                }
                catch
                {

                }
            }

			clone.ImpersonationLevel = httpRequest.ImpersonationLevel;
			clone.KeepAlive = clone.KeepAlive;
			clone.MaximumAutomaticRedirections = httpRequest.MaximumAutomaticRedirections;
			clone.MaximumResponseHeadersLength = httpRequest.MaximumResponseHeadersLength;
			clone.MediaType = httpRequest.MediaType;
			clone.Method = httpRequest.Method;
			clone.Pipelined = httpRequest.Pipelined;
			clone.PreAuthenticate = httpRequest.PreAuthenticate;
			clone.ProtocolVersion = httpRequest.ProtocolVersion;
			clone.Proxy = httpRequest.Proxy;
			clone.ReadWriteTimeout = httpRequest.ReadWriteTimeout;
			clone.SendChunked = httpRequest.SendChunked;
			clone.Timeout = httpRequest.Timeout;
			clone.TransferEncoding = httpRequest.TransferEncoding;
			clone.UnsafeAuthenticatedConnectionSharing = httpRequest.UnsafeAuthenticatedConnectionSharing;
			clone.UseDefaultCredentials = httpRequest.UseDefaultCredentials;
			clone.UserAgent = httpRequest.UserAgent;

			return clone;
		}
        public string GetHeaderString()
        {
            StringBuilder sb = new StringBuilder();
            
            //request line
            sb.Append(this.BaseHttpRequest.Method);
            sb.Append(" ");
            sb.Append(this.BaseHttpRequest.RequestUri.PathAndQuery.ToString());
            sb.Append(" ");
            sb.Append("HTTP/" + this.BaseHttpRequest.ProtocolVersion.ToString());
            sb.AppendLine();

            sb.AppendLine("Host: " + this.BaseHttpRequest.RequestUri.Host + ":" + this.BaseHttpRequest.RequestUri.Port);
            if (this.BaseHttpRequest.ContentLength != -1)
            {
                sb.AppendLine("Content-Length: " + this.BaseHttpRequest.ContentLength.ToString());
            }
            sb.AppendLine();

            return sb.ToString();
        }
        //this is only used in GETs for now, so there should be no body.
        public byte[] ToBytes()
        {
            string headers = GetHeaderString();
            int byte_count = Encoding.UTF8.GetByteCount(headers);
            byte[] ans = new byte[byte_count /* + (Content == null ? 0 : Content.Length) */];

            Encoding.UTF8.GetBytes(headers, 0, headers.Length, ans, 0);

            //todo(michperr): Spot for the content
            return ans;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\LiveLibExtensions\EnumAvatarAssetRequest.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using live.common;

namespace live.protocol
{
    public class AvatarAssetEnumRequest : XRLObject2
    {
        // Fields
        public ulong ForPuid = 0L;
        public ushort LocaleId = 0;
        public ushort MaxAssets = 0x20;
        public ulong Puid = 0L;
        public ushort StartingIndex = 0;
        public uint TitleId = 0;

        // Properties
        public string Xrl
        {
            get
            {
                return "/xstats/xavatarassetenum.ashx";
            }
        }
    }

    public class AvatarAssetEnumResponse : XRLObject2
    {
        // Fields
        [WireInfo(SizeParam = "AvatarAssetsCount")]
        public AvatarAsset[] AvatarAssets = null;
        public ushort AvatarAssetsCount = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\Proxy\RestException.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AvatarServices.Test.Common
{
    /// <summary>
    /// 
    /// </summary>
    public class RestException: Exception
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="response"></param>
        public RestException(RestResponse response): this(response, null)
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="response"></param>
        /// <param name="message"></param>
        public RestException(RestResponse response, string message): this(response, message, null)
        {
            
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="response"></param>
        /// <param name="message"></param>
        /// <param name="innerException"></param>
        public RestException(RestResponse response, string message, Exception innerException): base(message, innerException)
        {
            this.Response = response;
        }

        /// <summary>
        /// 
        /// </summary>
        public RestResponse Response
        {
            get;
            protected set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\LiveLibExtensions\SyncAvatarAwardRequest.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using live.common;

namespace live.protocol
{
    public class SyncAvatarAssetRequest : XRLObject2
    {
        // Fields
        [WireInfo(Max = 0x20L)]
        public ushort AvatarAssetCount = 0;
        [WireInfo(SizeParam = "AvatarAssetCount")]
        public AvatarAsset[] AvatarAssets = null;
        public ushort LocaleId = 0;
        public ushort StartingIndex = 0;
        public uint TitleId = 0;
        public ulong UserId = 0L;
        public DateTime Version = XOn.MinDateTime;

        // Properties
        public string Xrl
        {
            get
            {
                return "/xstats/syncavatarassets.ashx";
            }
        }
    }

    public class SyncAvatarAssetResponse : XRLObject2
    {
        // Fields
        [WireInfo(Max = 0x20L)]
        public ushort AvatarAssetCount = 0;
        [WireInfo(SizeParam = "AvatarAssetCount")]
        public AvatarAsset[] AvatarAssets = null;
        public uint MoreAvatarAssetPending = 0;
        public DateTime Version = XOn.MinDateTime;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\Proxy\RestRequest.cs ===
﻿using System;
using System.Collections.Generic;
using System.Net;
using System.IO;
using System.Runtime.Serialization;
using System.Xml;
using System.Text;
using AvatarServices.Test.Common;
using System.Security.Cryptography.X509Certificates;

namespace AvatarServices.Test.Common
{
    /// <summary>
    /// 
    /// </summary>
    public class RestRequest
    {
        //todo(michperr): static as a hack for the multiplayer tests.  Change to a delegate or something.
        public static string XmlContentType = "application/xml";

        public delegate KeyValuePair<string, string> XAuthorizationDelegate();

        public delegate KeyValuePair<string, string> XAuthorizationDelegateWithCookieName(string cookiename);

        public delegate KeyValuePair<string, string> XLocaleDelegate();

        public delegate KeyValuePair<string, string> XPlatformDelegate();

        public delegate KeyValuePair<string, string> XCannedDelegate();

        public const string RpsCookieName = "RPSSecAuth";

        public XAuthorizationDelegate AuthorizationDelegate
        {
            get;
            set;
        }

        public XAuthorizationDelegateWithCookieName AuthorizationDelegateWithCookieName
        {
            get;
            set;
        }

        public XLocaleDelegate LocaleDelegate
        {
            get;
            set;
        }

        public XPlatformDelegate PlatformDelegate
        {
            get;
            set;
        }

        public XCannedDelegate CannedDelegate
        {
            get;
            set;
        }

        public static int Timeout
        {
            get;
            set;
        }

        public virtual Dictionary<string, string> GetHttpHeaders()
        {
            return GetHttpHeaders(XmlContentType);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="contentType"></param>
        /// <returns></returns>
        public virtual Dictionary<string, string> GetHttpHeaders(string contentType)
        {
            return GetHttpHeaders(contentType, RpsCookieName);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="contentType"></param>
        /// <param name="cookieName"></param>
        /// <returns></returns>
        public virtual Dictionary<string, string> GetHttpHeaders(string contentType, string cookieName)
        {
            Dictionary<string, string> httpHeaders = new Dictionary<string, string>();

            if (contentType != null)
                httpHeaders.Add("Content-Type", contentType);

            //httpHeaders.Add("X-Locale", "EN-US");
            KeyValuePair<string, string> authzToken = new KeyValuePair<string, string>();

            if (this.AuthorizationDelegate != null)
            {
                authzToken = this.AuthorizationDelegate();
                httpHeaders.Add(authzToken.Key, authzToken.Value);
            }

            if (this.AuthorizationDelegateWithCookieName != null && String.IsNullOrEmpty(authzToken.Key))
            {
                authzToken = this.AuthorizationDelegateWithCookieName(cookieName);
                httpHeaders.Add(authzToken.Key, authzToken.Value);
            }

            if (this.LocaleDelegate != null)
            {
                KeyValuePair<string, string> xLocale = this.LocaleDelegate();
                httpHeaders.Add(xLocale.Key, xLocale.Value);
            }

            if (this.PlatformDelegate != null)
            {
                KeyValuePair<string, string> xPlatform = this.PlatformDelegate();
                httpHeaders.Add(xPlatform.Key, xPlatform.Value);
            }

            if (this.CannedDelegate != null)
            {
                KeyValuePair<string, string> xCanned = this.CannedDelegate();
                httpHeaders.Add(xCanned.Key, xCanned.Value);
            }

            return httpHeaders;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <returns></returns>
        public static RestResponse Get(string url)
        {
            return Get(url, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="httpHeaders"></param>
        /// <returns></returns>
        public static RestResponse Get(string url, Dictionary<string, string> httpHeaders, X509Certificate2 cert)
        {
            return SendRequest(url, "GET", httpHeaders, null, cert);
        }


        public static RestResponse Get(string url, Dictionary<string, string> httpHeaders)
        {
            return Get(url, httpHeaders, null);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        public static RestResponse Post(string url, string body)
        {
            return Post(url, null, body);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="httpHeaders"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        public static RestResponse Post(string url, Dictionary<string, string> httpHeaders, string body, X509Certificate2 cert)
        {
            return SendRequest(url, "POST", httpHeaders, body, cert);
        }
        public static RestResponse Post(string url, Dictionary<string, string> httpHeaders, string body)
        {
            return Post(url, httpHeaders, body, null);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <returns></returns>
        public static RestResponse Delete(string url)
        {
            return Delete(url, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="httpHeaders"></param>
        /// <returns></returns>
        public static RestResponse Delete(string url, Dictionary<string, string> httpHeaders, X509Certificate2 cert)
        {
            return SendRequest(url, "DELETE", httpHeaders, null, cert);
        }

        public static RestResponse Delete(string url, Dictionary<string, string> httpHeaders)
        {
            return Delete(url, httpHeaders, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        public static RestResponse Put(string url, string body)
        {
            return Put(url, null, body);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="httpHeaders"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        public static RestResponse Put(string url, Dictionary<string, string> httpHeaders, string body, X509Certificate2 cert)
        {
            return SendRequest(url, "PUT", httpHeaders, body, cert);
        }

        public static RestResponse Put(string url, Dictionary<string, string> httpHeaders, string body)
        {
            return Put(url, httpHeaders, body, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="obj"></param>
        /// <param name="objType"></param>
        /// <returns></returns>
        public static string SerializeObject(object obj)
        {
            using (MemoryStream mStream = new MemoryStream())
            using (StreamReader reader = new StreamReader(mStream))
            {
                DataContractSerializer dcs = new DataContractSerializer(obj.GetType());
                dcs.WriteObject(mStream, obj);
                mStream.Position = 0;
                return reader.ReadToEnd();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="response"></param>
        /// <returns></returns>
        public static T DeserializeObject<T>(string response)
        {
            DataContractSerializer dcjs = new DataContractSerializer(typeof(T));
            using (MemoryStream mStream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(response)))
            {
                T obj = (T)dcjs.ReadObject(mStream);
                return obj;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="response"></param>
        public static void HandleResponse(RestResponse response)
        {
            //if (!response.CorrectContentType)
            //{
            //    TraceEx.TraceWarning(1000, "BUG!! incorrect Content-Type header found in response.  We always expect 'application/xml' but got '{0}' instead.", response.ContentType);
            //    throw new RestException(response, String.Format("Found incorrect Content-Type header in response.  Expected 'application/xml', but got '{0}' instead", response.ContentType));
            //}

            if (!response.Succeeded)
                throw new RestException(response);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="method"></param>
        /// <param name="httpHeaders"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        protected static RestResponse SendRequest(string url, string method, System.Collections.IDictionary httpHeaders, string body, X509Certificate2 cert)
        {
            return SendRequest(url, method, XmlContentType, httpHeaders, body, cert);
        }

        protected static RestResponse SendRequest(string url, string method, System.Collections.IDictionary httpHeaders, string body)
        {
            return SendRequest(url, method, httpHeaders, body, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="method"></param>
        /// <param name="contentType"></param>
        /// <returns></returns>
        protected static RestResponse SendRequest(string url, string method, string contentType, System.Collections.IDictionary httpHeaders, string body, X509Certificate2 cert)
        {
            if (string.Compare(Config.Environment.Name, "fygar", true) == 0)
            {
                ServicePointManager.ServerCertificateValidationCallback += delegate(object sender, System.Security.Cryptography.X509Certificates.X509Certificate certificate,
                                           System.Security.Cryptography.X509Certificates.X509Chain chain,
                                           System.Net.Security.SslPolicyErrors sslPolicyErrors)
                {
                    return true;
                };
            }

            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);

            request.Method = method;
            request.ContentType = contentType;
            request.UserAgent = "MP Test";

            if (Timeout > 0)
                request.Timeout = Timeout;

            if (string.Equals(method, "PUT") || string.Equals(method, "POST"))
            {
                if (body != null)
                {
                    request.ContentLength = Encoding.UTF8.GetByteCount(body);
                }
                else
                {
                    request.ContentLength = 0;
                }
            }

            if (httpHeaders != null && httpHeaders.Count > 0)
            {
                foreach (object key in httpHeaders.Keys)
                {
                    if (httpHeaders[key] == null)
                    {
                        // The value is empty, thus the Header should be omitted
                        continue;
                    }

                    AddOrUpdateHttpHeader(request, key.ToString(), httpHeaders[key].ToString());
                }
            }

            TraceRequest(request, body);

            if (body != null)
            {
                using (StreamWriter writer = new StreamWriter(request.GetRequestStream()))
                {
                    writer.Write(body);
                }
            }

            if (cert != null)
            {
                request.ClientCertificates.Add(cert);
            }

            HttpWebResponse response = null;
            RestResponse restResponse = new RestResponse();

            try
            {
                response = (HttpWebResponse)request.GetResponse();
                restResponse.ResponseUri = response.ResponseUri;
                restResponse.Status = response.StatusCode;
                restResponse.StatusDescription = response.StatusDescription;
                CopyHttpHeaders(response.Headers, restResponse.Headers);

                using (StreamReader reader = new StreamReader(response.GetResponseStream()))
                {
                    restResponse.Body = reader.ReadToEnd();
                }
            }
            catch (WebException e)
            {
                //non-HTTP 200 status code
                if (e.Status == WebExceptionStatus.ProtocolError)
                {
                    response = (HttpWebResponse)e.Response;
                    restResponse.ResponseUri = response.ResponseUri;
                    restResponse.Status = response.StatusCode;
                    restResponse.StatusDescription = response.StatusDescription;
                    CopyHttpHeaders(response.Headers, restResponse.Headers);

                    using (StreamReader reader = new StreamReader(response.GetResponseStream()))
                    {
                        restResponse.Body = reader.ReadToEnd();
                    }
                }
                else
                    throw;
            }
            finally
            {
                if (response != null)
                    response.Close();
            }

            TraceResponse(restResponse);
            HandleResponse(restResponse);

            return restResponse;
        }
        protected static RestResponse SendRequest(string url, string method, string contentType, System.Collections.IDictionary httpHeaders, string body)
        {
            return SendRequest(url, method, contentType, httpHeaders, body, null);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="body"></param>
        /// <param name="request"></param>
        protected static void TraceRequest(HttpWebRequest request, string body)
        {
            StringBuilder trace = new StringBuilder();
            trace.AppendFormat("\r\n\r\n{0} {1} HTTP/1.1\r\n", request.Method, request.RequestUri.PathAndQuery);

            foreach (string key in request.Headers.Keys)
                trace.AppendFormat("{0}: {1}\r\n", key, request.Headers[key]);

            if (!String.IsNullOrEmpty(body))
                trace.AppendFormat("\r\n{0}\r\n\r\n", FormatXml(body));
            TraceEx.TraceVerbose(trace.ToString());
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="request"></param>
        /// <param name="body"></param>
        protected static void TraceResponse(RestResponse response)
        {
            StringBuilder trace = new StringBuilder();
            trace.AppendFormat("\r\n\r\nHTTP/1.1 {0} {1}\r\n", (int)response.Status, response.Status);

            foreach (string key in response.Headers.Keys)
                trace.AppendFormat("{0}: {1}\r\n", key, response.Headers[key]);

            if (!String.IsNullOrEmpty(response.Body))
                trace.AppendFormat("\r\n{0}\r\n\r\n", response.Body);
            TraceEx.TraceVerbose(trace.ToString());
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="xml"></param>
        /// <returns></returns>
        protected static string FormatXml(string xml)
        {
            try
            {
                XmlDocumentEx xmlDoc = new XmlDocumentEx(xml, true);
                return xmlDoc.FormatXml(2, ' ', '"');
            }
            catch
            {

            }

            return xml;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="request"></param>
        /// <param name="key"></param>
        /// <param name="value"></param>
        protected static void AddOrUpdateHttpHeader(HttpWebRequest request, string key, string value)
        {
            switch (key.ToLower())
            {
                case "accept":
                    {
                        request.Accept = value;
                        break;
                    }
                case "connection":
                    {
                        request.Connection = value;
                        break;
                    }
                case "content-type":
                    {
                        request.ContentType = value;
                        break;
                    }
                case "referer":
                    {
                        request.Referer = value;
                        break;
                    }
                case "user-agent":
                    {
                        request.UserAgent = value;
                        break;
                    }
                default:
                    {
                        request.Headers[key] = value;
                        break;
                    }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="webHeaders"></param>
        /// <param name="httpHeaders"></param>
        protected static void CopyHttpHeaders(WebHeaderCollection webHeaders, Dictionary<string, string> httpHeaders)
        {
            if (webHeaders != null && webHeaders.Count > 0)
            {
                foreach (string key in webHeaders.Keys)
                    httpHeaders[key] = webHeaders[key];
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Common\Proxy\RestResponse.cs ===
﻿using System;
using System.Collections.Generic;
using System.Net;
using System.Text;

namespace AvatarServices.Test.Common
{
    /// <summary>
    /// 
    /// </summary>
    public class RestResponse
    {
        /// <summary>
        /// 
        /// </summary>
        public RestResponse()
        {
            this.Headers = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        }

        /// <summary>
        /// 
        /// </summary>
        public Uri ResponseUri
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public HttpStatusCode Status
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string ContentType
        {
            get
            {
                return this.Headers["Content-Type"];
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public string Body
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public Dictionary<string, string> Headers
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string StatusDescription
        {
            get;
            set;
        }        

        /// <summary>
        /// 
        /// </summary>
        public bool Succeeded
        {
            get
            {
                return this.Status == HttpStatusCode.OK;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public bool CorrectContentType
        {
            get
            {
                return this.ContentType.Contains("application/xml");
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            StringBuilder trace = new StringBuilder();
            trace.AppendFormat("HTTP/1.1 {0} {1}\r\n", (int)this.Status, this.Status);
            
            foreach(string key in this.Headers.Keys)
                trace.AppendFormat("{0}: {1}\r\n", key, this.Headers[key]);

            trace.Append("\r\n" + this.Body);
            return trace.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Emulators\EmulatorSettings.cs ===
﻿using System;
using System.Xml.Serialization;
using System.Xml;
using System.Linq;
using System.IO;
using System.Configuration;

namespace AvatarServices.Test.Emulators
{
    [Serializable]
    public class EmulatorSettings
    {
        private Emulator[] emulators;

        [XmlElement("Emulator")]
        public Emulator[] Emulators
        {
            get
            {
                return this.emulators;
            }
            set
            {
                this.emulators = value;
            }
        }

        private static EmulatorSettings instance;
        private static object lockObject = new object();
        public static EmulatorSettings Instance
        {
            get
            {
                if (instance == null)
                {
                    lock (lockObject)
                    {
                        if (instance == null)
                        {
                            instance = new EmulatorSettings();
                            instance.Load();
                        }
                    }
                }
                return instance;
            }
        }

        public Emulator GetEmulator(Type type)
        {
            return GetEmulator(type.Name);
        }

        public Emulator GetEmulator(string className)
        {
            return emulators.First(em => em.Name.Equals(className, StringComparison.OrdinalIgnoreCase));
        }

        private void Load()
        {
            XmlSerializer serializer = new XmlSerializer(typeof(EmulatorSettings));
            string filePath = "EmulatorSettings.xml";
            if (!File.Exists(filePath))
            {
                filePath = ConfigurationManager.AppSettings["EmulatorSettingsPath"];
            }
            
            using (XmlReader reader = XmlReader.Create(filePath))
            {
                instance = serializer.Deserialize(reader) as EmulatorSettings;
            }
        }
    }

    [Serializable]
    public class Emulator
    {
        private string name;

        private int latency;

        [XmlAttribute("name")]
        public string Name
        {
            get
            {
                return this.name;
            }

            set
            {
                this.name = value;
            }
        }

        [XmlAttribute("latency")]
        public int Latency
        {
            get
            {
                return this.latency;
            }
            set
            {
                this.latency = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Emulators\TestAvatarStorageAccess.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Live.Livecache.DataAccess;
using System.Threading;
using AvatarServices.Test;

namespace AvatarServices.Test.Emulators
{
    public class TestAvatarStorageAccess : IAvatarStorageAccess
    {
        private int latency = 0;

        public TestAvatarStorageAccess()
        {
            latency = EmulatorSettings.Instance.GetEmulator(this.GetType()).Latency;
        }

        #region IAvatarStorageAccess Members

        public void StorageWrite(ulong userId, string pictureName, byte[] data)
        {
            Thread.Sleep(latency);
            return;
        }

        public bool StorageValidate(ulong readerPuid, string pictureName)
        {
            Thread.Sleep(latency);
            return false;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Emulators\TestBillingOfferingDataAccess.cs ===
﻿using System;
using System.Collections.Generic;
using Leet.Live.Livecache.DataAccess;
using System.Threading;
using AvatarServices.Test.Emulators;
using System.Collections.ObjectModel;
using xonline.common.protocol;

namespace AvatarServices.Test.Emulators
{
    public class TestBillingOfferingDataAccess : IBillingOfferingDataAccess
    {
        private int latency = 0;

        public TestBillingOfferingDataAccess()
        {
            latency = EmulatorSettings.Instance.GetEmulator(this.GetType()).Latency;
        }

        public PurchaseHistoryResponse GetPurchaseHistory(PurchaseHistoryRequest request)
        {
            Thread.Sleep(latency);
            List<PurchaseHistoryEntry> history = new List<PurchaseHistoryEntry>();
            //Add assets
            return new PurchaseHistoryResponse
            {
                TotalItems = (UInt32)history.Count,
                PurchaseHistoryEntries = new ReadOnlyCollection<PurchaseHistoryEntry>(history)
            };
        }

        /// <summary>
        /// Enumerate Assets for a user and a titleid
        /// </summary>
        ///<param name="request"></param>
        /// <returns></returns>
        public EnumerateAssetsResponse EnumerateAssets(EnumerateAssetsRequest request)
        {
            throw new NotImplementedException();
        }


        public uint GetPointsBalance(ulong xuid)
        {
            throw new NotImplementedException();
        }

        public uint PurchaseMediaOfferWithPoints(ulong xuid, Guid offerId, uint points, int mediaType, uint store, Guid transactionId)
        {
            throw new NotImplementedException();
        }

        public uint PurchaseMediaOfferWithToken(ulong xuid, Guid offerId, uint points, int mediaType, uint store, string token, Guid transactionId)
        {
            throw new NotImplementedException();
        }

        public MediaInstanceUrl[] GetMediaInstanceUrls(Guid[] mediaInstanceId)
        {
            throw new NotImplementedException();
        }

        public uint VerifyToken(ulong livePuid, string token, uint storeId, out ushort offerCatalogType, out Guid emsOfferId, out Guid mediaId, out uint mediaType, out ulong xboxOfferId, out uint xboxOfferType)
        {
            throw new NotImplementedException();
        }

        public void AssetConsume(ulong livePuid, uint titleId, Guid trackingGuid, xonline.common.protocol.Asset[] assetsToConsume)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Returns the available offers.
        /// </summary>
        /// <param name="request"></param>
        /// <returns></returns>
        public ContentEnumerateResponse EnumerateContent(ContentEnumerateRequest request)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Returns 0 if the purchase successful, hresult error code if fails.
        /// </summary>
        /// <param name="purchaseReq"></param>
        /// <returns></returns>
        public uint PurchaseGamertag(XeOfferPurchaseGamertagRequest purchaseReq)
        {
            throw new NotImplementedException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Emulators\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Emulators")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("847fd8d0-be8c-47ce-b722-be73c77312d7")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Emulators\TestSettingsDataAccess.cs ===
﻿using System;
using System.Collections.Generic;
using Leet.Live.Livecache.DataAccess;
using Leet.Live.Livecache.Logic.Profile;
using System.Threading;
using AvatarServices.Test.Emulators;
using System.Collections.ObjectModel;

namespace AvatarServices.Test.Emulators
{
    public class TestSettingsDataAccess : ISettingsDataAccess
    {        
        private int latency = 0;

        public TestSettingsDataAccess()
        {
            latency = EmulatorSettings.Instance.GetEmulator(this.GetType()).Latency;
        }

        #region ISettingsDataAccess Members

        public void LoadSettings(xonline.common.protocol.ReadSettingsResponse readResp, IGamerProfile profile, IWebPreferences webPreferences)
        {
            throw new NotImplementedException();
        }

        public IGamerProfile[] LoadSettings(xonline.common.protocol.ReadSettingsResponse readResp)
        {
            throw new NotImplementedException();
        }

        public xonline.common.protocol.ReadSettingsResponse[] ReadProfileSettings(ulong callingLivepuid, ulong[] targetLivepuids, uint[] settings)
        {
            throw new NotImplementedException();
        }

        public SaveSettingsResponse SyncSettings(ulong callingLivepuid, ProfileSetting[] settings)
        {
            Thread.Sleep(latency);
            return new SaveSettingsResponse();
        }

        public IGamerProfile GetGamerProfile(ulong callingLivepuid, ulong targetLivepuid)
        {
            throw new NotImplementedException();
        }

        public IGamerProfile GetGamerProfile(string gamertag, ulong callingLivepuid, ulong targetLivepuid)
        {
            throw new NotImplementedException();
        }

        public IGamerProfile GetPublicGamerProfile(ulong targetLivepuid)
        {
            Thread.Sleep(latency);
            return new TestGamerProfile();
        }

        public IGamerProfile GetPublicGamerProfile(string gamertag, ulong targetLivepuid)
        {
            throw new NotImplementedException();
        }

        public IGamerProfile[] GetGamerProfilesBySetting(ulong callingLivepuid, ulong[] targetLivepuids, uint[] settings, bool getGamertag)
        {
            throw new NotImplementedException();
        }

        public Dictionary<ulong, IGamerProfile> GetGamerProfileCollectionBySetting(ulong callingLivepuid, ulong[] targetLivepuids, uint[] settings, bool getGamertag)
        {
            throw new NotImplementedException();
        }

        public ReadOnlyCollection<AwardedAvatarAsset> GetUserAvatarAwards(ulong livePuid, ushort localeId, uint titleID)
        {
            Thread.Sleep(latency);
            List<AwardedAvatarAsset> assets = new List<AwardedAvatarAsset>();
            //Add assets

            return new ReadOnlyCollection<AwardedAvatarAsset>(assets);
        }

        public void SaveSettings(IGamerProfile profile, IWebPreferences preferences, string locale)
        {
            throw new NotImplementedException();
        }

        public void SaveGamerProfile(IGamerProfile profile, string locale)
        {
            throw new NotImplementedException();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.Emulators\TestGamerProfile.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Live.Livecache.Logic.Profile;
using Leet.Live.Livecache;
using Leet.Live.Livecache.Logic.Avatars;
using Microsoft.XboxLive.Avatars;
using Microsoft.XboxLive.Avatars.Internal;

namespace AvatarServices.Test.Emulators
{
    public class TestGamerProfile : IGamerProfile
    {
        #region IGamerProfile Members

        public ulong LivePuid
        {
            get
            {
                return 1234;
            }
            set
            {
                // do nothing
            }
        }

        public string GamerTag
        {
            get
            {
                return "somegamertag";
            }
            set
            {
                // do nothing
            }
        }

        public string Bio
        {
            get
            {
                return "my bio";
            }
            set
            {
                // do nothing
            }
        }

        public string Name
        {
            get
            {
                return "my name";
            }
            set
            {
                // do nothing
            }
        }

        public string Location
        {
            get
            {
                return "my location";
            }
            set
            {
                // do nothing
            }
        }

        public string Motto
        {
            get
            {
                return "my motto";
            }
            set
            {
                // do nothing
            }
        }

        public int Gamerscore
        {
            get
            {
                return 100;
            }
            set
            {
                // do nothing
            }
        }

        public bool HasAcceptedTOU
        {
            get
            {
                return true;
            }
            set
            {
                // do nothing
            }
        }

        public int Country
        {
            get
            {
                return 103;
            }
            set
            {
                // do nothing
            }
        }

        public float Reputation
        {
            get
            {
                return 0;
            }
            set
            {
                // do nothing
            }
        }

        public int ReputationBucket
        {
            get { return 0; }
        }

        public string GamerTileUrl
        {
            get
            {
                return "http://badurl";
            }
            set
            {
                // do nothing
            }
        }

        public string SecureGamerTileUrl
        {
            get
            {
                return "http://badurl";
            }
            set
            {
                // do nothing
            }
        }

        public string SmallGamerTileUrl
        {
            get
            {
                return "http://badurl";
            }
            set
            {
                // do nothing
            }
        }

        public string SecureSmallGamerTileUrl
        {
            get
            {
                return "http://badurl";
            }
            set
            {
                // do nothing
            }
        }

        public string GamerTileId
        {
            get
            {
                return "tileid";
            }
            set
            {
                // do nothing
            }
        }

        public GamercardZone Zone
        {
            get
            {
                return GamercardZone.Family;
            }
            set
            {
                // do nothing
            }
        }

        public GamerTier Tier
        {
            get
            {
                return GamerTier.Gold;
            }
            set
            {
                // do nothing
            }
        }

        public byte[] AvatarManifest
        {
            get
            {
                return CreateRandomManifest(AvatarGender.Both).SaveToBinary();
            }
            set
            {
                // do nothing
            }
        }

        public AvatarBodyType AvatarBodyType
        {
            get { return AvatarBodyType.Male; }
        }

        public bool IsLaunchTeamMember
        {
            get { return false; }
        }

        public bool IsCheater
        {
            get { return false; }
        }

        public bool IsNXELaunchTeamMember
        {
            get { return false; }
        }

        public int ProfilePermissions
        {
            get
            {
                return 0;
            }
            set
            {
                // do nothing
            }
        }

        public PrivilegeValue ProfileActivityPrivilege
        {
            get
            {
                return PrivilegeValue.Allow;
            }
            set
            {
                // do nothing
            }
        }

        public PrivilegeValue ProfileUserCreatedContentPrivilege
        {
            get
            {
                return PrivilegeValue.Allow;
            }
            set
            {
                // do nothing
            }
        }

        public PrivilegeValue PlayedMusicSharingPrivilege
        {
            get
            {
                return PrivilegeValue.Allow;
            }
            set
            {
                // do nothing
            }
        }

        public string GamerTile
        {
            get
            {
                return "sometile";
            }
            set
            {
                // do nothing
            }
        }

        public string BlogUrl
        {
            get
            {
                return "http://badurl";
            }
            set
            {
                // do nothing
            }
        }

        public GamerTypeFlags GamerType
        {
            get
            {
                return 0;
            }
            set
            {
                // do nothing
            }
        }
        #endregion

        private static object lockObject = new object();
        private static AssetDataManager privateAssetManager;
        private static AssetDataManager assetManager
        {
            get
            {
                if (privateAssetManager == null)
                {
                    lock (lockObject)
                    {
                        if (privateAssetManager == null)
                        {
                            string stockUri = "http://download.xboxlive.com/content/584d07d1/{0}.bin";
                            string nonStockUri = "http://download.xboxlive.com/content/{0}/avataritems/{1}.bin";
                            privateAssetManager = new AssetDataManager();
                            privateAssetManager.AddAssetProvider(new AssetUrlDataProvider(stockUri, nonStockUri));
                        }
                    }
                }
                return privateAssetManager;
            }
        }

        private AvatarManifest CreateRandomManifest(AvatarGender gender)
        {
            return Microsoft.XboxLive.Avatars.Internal.AvatarManifest.CreateRandom(assetManager, gender, 1)[0];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.UserCache\UserCache.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using AvatarServices.Test.Common;
using LiveN.Test.Users;
using Microsoft.XboxLive.Avatars;
using Microsoft.XboxLive.Avatars.Internal;
using System.Diagnostics;
using System.Threading;
using LiveN.Test.Avatar;


namespace AvatarServices.Test.UserCache
{
    /// <summary>
    /// Class representing cached user repository to be shared across tests.
    /// </summary>
    public class UserCache
    {
        private UserCache()
        {
            Environments.SetEnvironment(Config.Environment.LiveLibEnvironment);
            
            if (Config.Environment.UseStf)
            {
                Environments.SetStfEnvironment(Config.Environment.LiveLibEnvironment);
            }
        }

        private static UserCache instance = new UserCache();
        public static UserCache Instance
        {
            get
            {
                return instance;
            }
        }

        private Dictionary<string, User> userList = new Dictionary<string, User>();
        private Random rand = new Random();

        /// <summary>
        /// Get user with a manifest.
        /// </summary>
        /// <returns>Returns a singal user with it's manifest</returns>
        public User GetUsersWithManifests()
        {
            User user = GetUsersWithManifests(1)[0];

            Trace.WriteLine("TRACE: Using user \t\t GamerTag: \t" + user.Gamertag + "\r\n\t\t\t Xuid: \t\t" + user.Xuid + "\r\n\t\t\t Email: \t\t" + user.Email + "\r\n\t\t\t Password: \t" + user.Password);

            return user;
        }

        /// <summary>
        /// Returns an array of users with manifests.
        /// </summary>
        /// <param name="count">Number of users to get.</param>
        /// <returns>Array of users with manifests.</returns>
        public User[] GetUsersWithManifests(int count)
        {
            return GetUsers(count);
        }

        /// <summary>
        /// Returns a users without manifests.
        /// </summary>
        /// <returns>User without manifests.</returns>
        public User GetUsersWithoutManifests()
        {
            User user = GetUsersWithoutManifests(1)[0];

            Trace.WriteLine("TRACE: Using user \t GamerTag: \t" + user.Gamertag + "\r\n\t\t\t Xuid: \t\t" + user.Xuid + "\r\n\t\t\t Email: \t\t" + user.Email + "\r\n\t\t\t Password: \t" + user.Password);

            return user;
        }

        /// <summary>
        /// Returns an array of users without manifests.
        /// </summary>
        /// <param name="count">Number of users to get.</param>
        /// <returns>Array of users without manifests.</returns>
        public User[] GetUsersWithoutManifests(int count)
        {
            return GetUsers(count, AvatarGender.Unknown);
        }

        /// <summary>
        /// Returns an array of users whose gamertags are of max possible length when url encoded.
        /// </summary>
        /// <param name="count">Number of users to get.</param>
        /// <returns>Array of users with maximum gamertag length.</returns>
        public User[] GetUsersMaxGamertagLength(int count)
        {
            List<User> foundUserList = userList.Values.Where(user => user.Gamertag.Length == TestSettings.MAX_GAMERTAG_LENGTH).ToList();

            // Create users if the cache doesn't have enough
            int additionalCount = foundUserList.Count - count;
            for (int i = 0; i < additionalCount; i++)
            {
                User user;
                string gamertag;
                while (true)
                {
                    gamertag = GetRandomGamertagMaxLength();
                    if (!userList.ContainsKey(gamertag))
                        break;
                }
                string email = gamertag.Replace(" ", "") + "VeryLong@" + TestSettings.PASSPORT_DOMAIN;
                AccountSettings settings = new AccountSettings(live.common.XblUserTier.Silver, live.common.PassportType.Real, email, TestSettings.PASSPORT_PASSWORD, gamertag);
                try
                {
                    // Try to create a new user.
                    user = new User(settings);
                }
                catch (live.common.XErrFailedException ex)
                {
                    if (ex.HResult == 0x80154013 || ex.HResult == 0x80154000) //80154013: XONLINE_E_PASSPORT_ALREADY_LINKED 80154000: XONLINE_E_ACCOUNTS_NAME_TAKEN
                    {
                        user = new User(Account.LoadExistingAccount(email, TestSettings.PASSPORT_PASSWORD));
                    }
                    else
                        throw new UserSetupException("There was an unhandled exception from Xbox Live service while creating a new user.", ex);
                }
                foundUserList.Add(user);
            }

            // Can't proceed with the test if there aren't enough users.
            if (foundUserList.Count != count)
            {
                throw new UserSetupException(string.Format("There are only {0} users when the test requires {1} users.", foundUserList.Count, count));
            }
            return foundUserList.ToArray();

        }

        public User[] GetUsersWithComponent(int count, ComponentCategories component)
        {
            return GetUsersWithComponent(count, AvatarGender.Both, component);
        }

        public User[] GetUsersWithComponent(int count, AvatarGender gender, ComponentCategories component)
        {
            if (gender == AvatarGender.Unknown)
            {
                throw new UserSetupException("Unknown avatar gender is passed in. Can't expect avatar components for an avatar without a manifest."
                    , new ArgumentException("AvatarGender"));
            }

            List<User> foundUserList;

            IEnumerable<User> result1 = userList.Values.Where(user => user.AwardList.Any(award => (award.Category | component) == component)
                            || user.PurchaseList.Any(purchase => (purchase.Category | component) == component));

            foundUserList = result1.ToList();

            try
            {
                AvatarComponentType avatarComp = (AvatarComponentType)Enum.Parse(typeof(AvatarComponentType), component.ToString(), true);
                IEnumerable<User> result2;
                if (avatarComp != AvatarComponentType.Body)
                {                    
                    result2 = userList.Values.Where(user => user.Manifest != null && user.Manifest.IsComponentPresent(avatarComp));
                    foundUserList.AddRange(result2.ToList());
                }
            }
            catch (ArgumentException)
            {
                // Failed to parse the enum. Ignore it.
            }

            // Create users if the cache doesn't have enough
            int additionalCount = Math.Max(0, count - foundUserList.Count);

            if (additionalCount > 0)
            {
                User[] users = GetUsers(additionalCount, gender, 0, 0);
                for (int i = 0; i < additionalCount; i++)
                {
                    BaseAsset asset = StockAssetCollection.Instance.FindFirst(users[i].Manifest.BodyType, component, false, string.Empty);
                    if (asset == null)
                    {
                        asset = AwardableAssetCollection.Instance.FindFirst(users[i].Manifest.BodyType, component, false, string.Empty);
                        users[i].AwardAsset(asset as AwardableAsset);
                        users[i].EquipAsset(asset);
                    }
                    else
                    {
                        users[i].EquipAsset(asset);
                    }

                    if (asset == null)
                    {
                        asset = MarketplaceAssetCollection.Instance.FindFirst(users[i].Manifest.BodyType, component, false, string.Empty);
                        users[i].PurchaseAsset(asset as MarketplaceAsset);
                        users[i].EquipAsset(asset);
                    }
                    if (asset == null)
                    {
                        throw new UserSetupException("There are no available carryable asset to equip.");
                    }

                    users[i].WriteManifest(true, Config.Environment.ManifestWritePartService);
                    foundUserList.Add(users[i]);
                }

                Thread.Sleep(31 * 1000); // Wait till cache clears
            }

            // Can't proceed with the test if there aren't enough users.
            if (foundUserList.Count < count)
            {
                throw new UserSetupException(string.Format("There are only {0} users when the test requires {1} users.", foundUserList.Count, count));
            }
            return foundUserList.GetRange(0, count).ToArray();
        }

        /// <summary>
        /// Get or create a new user
        /// </summary>
        /// <returns>Returns and existing or a new </returns>
        public User GetUser()
        {
            User user = GetUsers(1)[0];

            Trace.WriteLine("TRACE: Using user \t GamerTag: \t" + user.Gamertag + "\r\n\t Xuid: \t\t" + user.Xuid + "\r\n\t Email: \t\t" + user.Email + "\r\n\t Password: \t" + user.Password);

            return user;
        }

        /// <summary>
        /// Get or create a new user
        /// </summary>
        /// <param name="gender">Specify gender</param>
        /// <returns>Returns and existing or a new </returns>
        public User GetUser(AvatarGender gender)
        {
            User user = GetUsers(1, gender)[0];

            Trace.WriteLine("TRACE: Using user \t GamerTag: \t" + user.Gamertag + "\r\n\t Xuid: \t\t" + user.Xuid + "\r\n\t Email: \t\t" + user.Email + "\r\n\t Password: \t" + user.Password);

            return user;
        }

        public User[] GetUsers(int count)
        {
            return GetUsers(count, AvatarGender.Both);
        }

        public User[] GetUsers(int count, AvatarGender gender)
        {
            return GetUsers(count, gender, 0, 0);
        }

        public User[] GetUsers(int count, AvatarGender gender, int purchaseCount, int awardCount)
        {
            List<User> foundUserList;
            IEnumerable<User> result;

            Trace.WriteLine("TRACE: LiveLib environment = '" + Config.Environment.LiveLibEnvironment + "'");

            result = userList.Values.Where(user => user.PurchaseList.Count == purchaseCount
                                                            && user.AwardList.Count == awardCount);

            if (gender == AvatarGender.Unknown)
            {
                result = result.Where(user => user.Manifest == null);
            }
            else
            {
                result = result.Where(user => user.Manifest != null && (user.Manifest.BodyType & gender) == user.Manifest.BodyType);
            }

            foundUserList = result.ToList();

            // Create users if the cache doesn't have enough
            int additionalCount = Math.Max(0, count - foundUserList.Count);
            foundUserList.AddRange(CreateUsers(additionalCount, gender, purchaseCount, awardCount));          

            // Can't proceed with the test if there aren't enough users.
            if (foundUserList.Count < count)
            {
                throw new UserSetupException(string.Format("There are only {0} users when the test requires {1} users.", foundUserList.Count, count));
            }

            return foundUserList.GetRange(0, count).ToArray();
        }

        public User[] CreateUsers(int count, AvatarGender gender, int purchaseCount, int awardCount)
        {
            List<User> users = new List<User>();

            for (int i = 0; i < count; i++)
            {
                User user = User.CreateUser(gender, purchaseCount, awardCount);
                users.Add(user);
                userList.Add(user.Gamertag, user);
            }

            return users.ToArray();
        }

        /// <summary>
        /// Returns a random gamertag of max possible length when url encoded.
        /// </summary>
        /// <returns>Gamerga of maximum possible length.</returns>
        private string GetRandomGamertagMaxLength()
        {
            string gamertag = string.Empty;
            // Start with a letter
            for (int i = 0; i < TestSettings.MAX_GAMERTAG_LENGTH; i++)
            {
                if (i % 2 == 0)
                    gamertag += TestSettings.VALID_GAMERTAG_CHARACTERS[rand.Next(26)].ToString();
                else
                    gamertag += " ";
            }
            return gamertag;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.UserCache\UserSetupException.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AvatarServices.Test.UserCache
{
    /// <summary>
    /// Class representing an error during user setup for the tests.
    /// </summary>
    public class UserSetupException : Exception
    {
        public UserSetupException(string message) : base(message) { }
        public UserSetupException(string message, Exception innerException) : base(message, innerException) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\AvatarServices.Test\AvatarServices.Test.UserCache\User.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.XboxLive.Avatars;
using Microsoft.XboxLive.Avatars.Internal;
using AvatarServices.Test.Common;
using LiveN.Test.Users;
using System.Diagnostics;
using Microsoft.XboxLive.Avatars.Internal.Assets;
using LiveN.Test.Avatar;
using live.protocol;
using ServerTestFramework.LiveService.AvatarAsset;
using live.common;
using AvatarServices.Test.AvatarProxy;


namespace AvatarServices.Test.UserCache
{
    /// <summary>
    /// Class representing a user that contains the user's type, manifest, and gamertag.
    /// </summary>
    public class User
    {
        /// <summary>
        /// Get or set the manifest of this user
        /// </summary>
        /// <remarks>You have to call WriteManifest in order to set the updated avatar</remarks>
        public AvatarManifest Manifest 
        {
            get
            {
                if (account.Avatar.ManifestData != null && account.Avatar.ManifestData.Length == 1000)
                {
                    return AvatarManifest.Create(account.Avatar.ManifestData);
                }
                else
                {
                    return null;
                }
            }
            set
            {
                account.Avatar.SetManifest(value.SaveToBinary());
            }
        }

        /// <summary>
        /// Get or set the manifest of this user
        /// </summary>
        /// <remarks>You have to call WriteManifest in order to set the updated avatar</remarks>
        public byte[] ManifestByte
        {
            get
            {
                return account.Avatar.ManifestData;
            }
            set
            {
                account.Avatar.SetManifest(value);
            }
        }

        /// <summary>
        /// Get or set the manifest of this user.
        /// </summary>
        /// <remarks>You have to call WriteManifest in order to set the updated avatar</remarks>
        public string ManifestString
        {
            get
            {
                if (this.Manifest != null)
                {
                    return ManifestHelper.GenerateManifestString(this.Manifest.SaveToBinary());
                }
                else
                {
                    return string.Empty;
                }
            }
            set
            {
                account.Avatar.SetManifest(ManifestHelper.GenerateManifestData(value));
            }
        }

        public string Email
        {
            get { return account.XblUser.Settings.UserPassportInfo.MemberName; }
        }

        public string Password
        {
            get { return account.XblUser.Settings.UserPassportInfo.Password; }
        }

        public string Gamertag
        {
            get { return account.Gamertag; }
        }

        public ulong Xuid 
        { 
            get { return account.XblUser.Puid; } 
        }

        public List<MarketplaceAsset> PurchaseList = new List<MarketplaceAsset>();
        public List<AwardableAsset> AwardList = new List<AwardableAsset>();

        internal Account account;

        internal User()
        {
            account = new Account();
        }

        internal User(AccountSettings settings)
        {
            account = new Account(settings);
        }

        internal User(Account accountData)
        {
            account = accountData;
        }

        public static User CreateUser(AvatarGender gender, int purchaseCount, int awardCount)
        {
            User user = new User();

            switch (gender)
            {
                case AvatarGender.Female:
                case AvatarGender.Male:
                case AvatarGender.Both:

                    user.CreateRandomManifest(gender);
                    user.account.Avatar.WriteManifest();

                    break;

                case AvatarGender.Unknown:
                default:

                    break;
            }

            Trace.WriteLine("TRACE: Created user \t GamerTag: \t" + user.Gamertag + "\r\n\t\t\t Xuid: \t\t" + user.Xuid + "\r\n\t\t\t Email: \t\t" + user.Email + "\r\n\t\t\t Password: \t" + user.Password);
            
            if (purchaseCount > 0)
            {
                Trace.WriteLine("TRACE: Adding " + purchaseCount.ToString() + " Marketplace Assets to above user.");

                user.PurchaseRandomMarketplaceAssets(purchaseCount, gender);
            }
           
            if (awardCount > 0)
            {
                Trace.WriteLine("TRACE: Adding " + purchaseCount.ToString() + " Award Assets to above user.");

                user.AwardRandomAssets(awardCount, gender);
            }

            return user;
        }
        
        public void CreateRandomManifest(AvatarGender gender)
        {
            byte[] manifestData = ManifestHelper.CreateRandomManifest(gender);
            account.Avatar.SetManifest(manifestData);
        }

        public void PurchaseRandomMarketplaceAssets(int purchaseCount, AvatarGender gender)
        {
            List<MarketplaceAsset> assetList = MarketplaceAssetCollection.Instance.FindMultiple(purchaseCount, gender);
            PurchaseAssets(assetList);
        }

        public void PurchaseAsset(MarketplaceAsset asset)
        {
            List<MarketplaceAsset> assetList = new List<MarketplaceAsset>();
            assetList.Add(asset);
            PurchaseAssets(assetList);
        }

        public void PurchaseAssets(List<MarketplaceAsset> assetList)
        {
            List<OfferMediaTypeExpectedPrice> offerList = new List<OfferMediaTypeExpectedPrice>(assetList.Count);
            foreach (MarketplaceAsset asset in assetList)
            {
                OfferMediaTypeExpectedPrice offer = new OfferMediaTypeExpectedPrice();
                offer = new OfferMediaTypeExpectedPrice();
                offer.expectedPriceWhole = asset.PriceWhole;
                offer.expectedPriceFractional = asset.PriceFractional;
                offer.mediaTypeId = (int)live.common.next.MediaTypeEnum.AvatarItem;
                offer.offerId = asset.OfferId;
                offerList.Add(offer);
            }

            account.PurchaseMarketplaceOffers(offerList.ToArray());
            PurchaseList.AddRange(assetList);
            foreach (MarketplaceAsset asset in assetList)
            {
                Trace.WriteLine(string.Format("TRACE: Purchased asset {0} - {1}", asset.Id, asset.Description));
            }
        }

        public void AwardRandomAssets(int awardCount, AvatarGender gender)
        {
            List<AwardableAsset> assetList = AwardableAssetCollection.Instance.FindMultiple(awardCount, gender);
            AwardAssets(assetList);
        }

        public void AwardAsset(AwardableAsset asset)
        {
            List<AwardableAsset> assetList = new List<AwardableAsset>();
            assetList.Add(asset);
            AwardAssets(assetList);
        }

        public void AwardAssets(List<AwardableAsset> assetList)
        {
            if (!AvatarServices.Test.Common.Config.Environment.UseStf)
            {
                throw new UserSetupException("Stf is disabled in the current environment. Unable to award assets to current user.");
            }

            List<AvatarAssetWD> liveAssetList = new List<AvatarAssetWD>(assetList.Count);
            foreach (AwardableAsset asset in assetList)
            {
                AvatarAssetWD liveAsset = new AvatarAssetWD(asset.Ordinal, (byte)asset.BodyType, asset.SortIndex, (int)XOn.XAVATAR_DETAILS_ACHIEVED);
                liveAssetList.Add(liveAsset);
            }

            account.Avatar.AwardAvatarAsset_Stf(liveAssetList.ToArray());
            AwardList.AddRange(assetList);
            foreach (AwardableAsset asset in assetList)
            {
                Trace.WriteLine(string.Format("TRACE: Awarded asset {0} - {1}", asset.Id, asset.Description));
            }
        }

        public bool EquipAsset(BaseAsset asset)
        {
            bool successful = true;
            byte[] manifestData = account.Avatar.ManifestData;
            if (!ManifestHelper.EquipAsset(ref manifestData, asset))
            {
                successful = false;
                Trace.WriteLine(string.Format("ERROR: Failed to equip asset {0} - {1}", asset.Id, asset.Description));
            }
            else
            {
                account.Avatar.SetManifest(manifestData);
                Trace.WriteLine(string.Format("TRACE: Equipped asset {0} - {1}", asset.Id, asset.Description));
            }
            return successful;
        }

        public bool RemoveAsset(BaseAsset asset)
        {
            foreach (ComponentInfo component in Manifest.GetComponents(AvatarComponentMasks.All))
            {
                if (component.AssetId == asset.Id)
                {
                    Manifest.RemoveComponents(component.ComponentMask);
                    return true;
                }
            }
            return false;
        }

        public bool EquipAllAssets()
        {
            bool successful = true;
            foreach (MarketplaceAsset asset in PurchaseList)
            {
                if (!EquipAsset(asset))
                {
                    successful = false;
                }
            }

            foreach (AwardableAsset asset in AwardList)
            {
                if (!EquipAsset(asset))
                {
                    successful = false;
                }
            }

            return successful;
        }

        public void WriteManifest(bool useAvatarProxy, string avatarProxyUrl)
        {
            if (useAvatarProxy)
            {
                Trace.WriteLine(string.Format("Updating the manifest for user {0}: Manifest = {1}", this.Email, this.ManifestString));
                ManifestWritePartProxy proxy = new ManifestWritePartProxy(this.Email, this.Password);
                int statusCode = proxy.UpdateManifest(this.ManifestString);
                if (statusCode != 0)
                {
                    throw new Exception(string.Format("Updating the manifest returned invalid status code: ", statusCode));
                }
            }
            else
            {
                account.Avatar.WriteManifest();
            }
 
        }

        public void WriteManifest()
        {
            account.Avatar.WriteManifest();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\AvatarLib\BaseAsset.cs ===
﻿using System;
using Microsoft.XboxLive.Avatars.Internal;

namespace LiveN.Test.Avatar
{
    public abstract class BaseAsset
    {
        // todo figure out body type and component type based on the Guid
        public Guid Id { get; set; }
        public virtual string Description { get; set; }

        public AvatarGender BodyType
        {
            get
            {
                if (Id != Guid.Empty)
                {
                    return AssetLoader.GetAssetBodyType(Id);
                }
                else
                {
                    return AvatarGender.Unknown;
                }
            }
        }

        public ComponentCategories Category
        {
            get
            {
                if (Id != Guid.Empty)
                {
                    return AssetLoader.GetComponentTypeFromAssetId(Id);
                }
                else
                {
                    return ComponentCategories.None;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\AvatarLib\AssetCollection.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.XboxLive.Avatars.Internal;

namespace LiveN.Test.Avatar
{
    public abstract class AssetCollection<T> : List<T> where T : BaseAsset
    {
        private static Random random = new Random();

        #region FindFirst
        public T FindFirst(AvatarGender gender)
        {
            return FindFirst(gender, ComponentCategories.None, false, string.Empty);
        }

        public T FindFirst(ComponentCategories category, bool matchAll)
        {
            return FindFirst(AvatarGender.Unknown, category, matchAll, string.Empty);
        }

        public T FindFirst(string queryString)
        {
            return FindFirst(AvatarGender.Unknown, ComponentCategories.None, false, queryString);
        }

        public T FindFirst(AvatarGender gender, ComponentCategories category, bool matchAll, string queryString)
        {
            return FindAll(gender, category, matchAll, queryString).ToList().FirstOrDefault<T>();
        }
        #endregion

        #region FindAll
        public List<T> FindAll(AvatarGender gender)
        {
            return FindAll(gender, ComponentCategories.None, false, string.Empty);
        }

        public List<T> FindAll(ComponentCategories category, bool matchAll)
        {
            return FindAll(AvatarGender.Unknown, category, matchAll, string.Empty);
        }

        public List<T> FindAll(string queryString)
        {
            return FindAll(AvatarGender.Unknown, ComponentCategories.None, false, string.Empty);
        }

        public List<T> FindAll(AvatarGender gender, ComponentCategories category, bool matchAll, string queryString)
        {
            if (queryString == null)
            {
                queryString = string.Empty;
            }

            IEnumerable<T> resultList = this.Where(
                asset => (asset.BodyType & gender) == gender
                    && asset.Description.ToLower().Contains(queryString.ToLower()));

            if (matchAll)
            {
                return resultList.Where(asset => asset.Category == category).ToList();
            }
            else
            {
                return resultList.Where(asset => (asset.Category & category) == category).ToList();
            }
        }
        #endregion

        #region FindRandom
        public T FindRandom()
        {
            int index = random.Next(0, this.Count);
            return this[index];
        }

        public T FindRandom(AvatarGender gender)
        {
            return FindRandom(gender, ComponentCategories.None, false, string.Empty);
        }

        public T FindRandom(ComponentCategories category, bool matchAll)
        {
            return FindRandom(AvatarGender.Unknown, category, matchAll, string.Empty);
        }

        public T FindRandom(AvatarGender gender, ComponentCategories category, bool matchAll, string queryString)
        {
            List<T> foundList = FindAll(gender, category, matchAll, queryString);
            int index = random.Next(0, foundList.Count);
            return foundList[index];
        }
        #endregion

        #region FindMultiple
        public List<T> FindMultiple(int count)
        {
            return FindMultiple(count, string.Empty);
        }

        public List<T> FindMultiple(int count, AvatarGender gender)
        {
            return FindMultiple(count, gender, ComponentCategories.None, false, string.Empty);
        }

        public List<T> FindMultiple(int count, ComponentCategories category, bool matchAll)
        {
            return FindMultiple(count, AvatarGender.Unknown, category, matchAll, string.Empty);
        }

        public List<T> FindMultiple(int count, string queryString)
        {
            return FindMultiple(count, AvatarGender.Unknown, ComponentCategories.None, false, queryString);
        }

        public List<T> FindMultiple(int count, AvatarGender gender, ComponentCategories category, bool matchAll, string queryString)
        {
            if (count <= 0)
            {
                throw new ArgumentException("The number of assets cannot be less than or equal to zero", "count");
            }

            List<T> foundList = FindAll(gender, category, matchAll, queryString);

            return foundList.GetRange(0, Math.Min(count, this.Count));
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\AvatarLib\MarketplaceAsset.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Xml;
using System.Xml.Serialization;

namespace LiveN.Test.Avatar
{
    public class MarketplaceAsset : BaseAsset
    {
        public Guid OfferId { get; set; }
        public uint PriceWhole { get; set; }
        public uint PriceFractional { get; set; }
        public string CountryCode { get; set; }

        public MarketplaceAsset() { }

        public MarketplaceAsset(Guid assetId, Guid offerId, string description, uint priceWhole, uint priceFractional, string countryCode)
        {
            this.Id = assetId;
            this.OfferId = offerId;
            this.Description = description;
            this.PriceWhole = priceWhole;
            this.PriceFractional = priceFractional;
            this.CountryCode = countryCode;
        }
    }

    public class MarketplaceAssetCollection : AssetCollection<MarketplaceAsset>
    {
        private static readonly MarketplaceAssetCollection instance = new MarketplaceAssetCollection();
        public static MarketplaceAssetCollection Instance
        {
            get { return instance; }
        }

        private MarketplaceAssetCollection()
        {
            Assembly assembly = Assembly.GetExecutingAssembly();
            Stream stream = assembly.GetManifestResourceStream(assembly.GetName().Name + ".offers.xml");

            List<MarketplaceAsset> assetList = new List<MarketplaceAsset>();
            using (XmlReader reader = XmlReader.Create(stream))
            {
                XmlSerializer serializer = new XmlSerializer(typeof(List<MarketplaceAsset>));

                assetList = serializer.Deserialize(reader) as List<MarketplaceAsset>;
            }

            this.AddRange(assetList);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\AvatarLib\ManifestHelper.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.XboxLive.Avatars.Internal;

namespace LiveN.Test.Avatar
{
    public class ManifestHelper
    {
        ~ManifestHelper()
        {
            assetManager.Cleanup();
        }

        #region Privates
        private static object lockObject = new object();
        private static AssetDataManager privateAssetManager;
        private static AssetDataManager assetManager
        {
            get
            {
                if (privateAssetManager == null)
                {
                    lock (lockObject)
                    {
                        if (privateAssetManager == null)
                        {
                            string stockUri = "http://download.xboxlive.com/content/584d07d1/{0}.bin";
                            string nonStockUri = "http://download.xboxlive.com/content/{0}/avataritems/{1}.bin";
                            privateAssetManager = new AssetDataManager();
                            privateAssetManager.AddAssetProvider(new AssetUrlDataProvider(stockUri, nonStockUri));
                        }
                    }
                }
                return privateAssetManager;
            }
        }

        private static char[] manifestBuffer = new char[2000];
        private static char[] hexCharacterMap = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
        #endregion

        public static byte[] CreateRandomManifest(AvatarGender gender)
        {
            AvatarManifest manifest = AvatarManifest.CreateRandom(gender, 1)[0];
            return manifest.SaveToBinary();
        }

        public static byte[] CreateRandomManifest(uint avatarBodyType)
        {
            return CreateRandomManifest((AvatarGender)avatarBodyType);
        }

        /// <summary>
        /// Generates the manifest string in hex from manifest byte array.
        /// </summary>
        /// <param name="manifestData">Manifest data in bytes.</param>
        /// <returns>Manifest string in hex.</returns>
        public static string GenerateManifestString(byte[] manifestData)
        {
            if (manifestData.Length == 0)
                return string.Empty;

            for (int i = 0; i < 1000; ++i)
            {
                // Split each byte of the manifest into the high and low halves, then
                // convert it to the hex character so it can be serialized into the
                // expected hex format.  It can then be sliced & diced into the 
                // asset GUIDs by the renderer.
                manifestBuffer[i * 2] = hexCharacterMap[manifestData[i] >> 4];
                manifestBuffer[i * 2 + 1] = hexCharacterMap[manifestData[i] & 0xF];
            }
            return new string(manifestBuffer);
        }

        /// <summary>
        /// Generates the manifest byte array from the manifest string in hex.
        /// </summary>
        /// <param name="hexManifestString">Manifest string in hex.</param>
        /// <returns>Manifest data in bytes.</returns>
        public static byte[] GenerateManifestData(string hexManifestString)
        {
            byte[] manifestData = new byte[1000];

            for (int i = 0; i < 1000; i++)
            {
                manifestData[i] = Convert.ToByte(hexManifestString.Substring(2 * i, 2), 16);
            }

            return manifestData;
        }

        /// <summary>
        /// Checks if the given manifest has the given asset.
        /// </summary>
        /// <param name="manifest">Manifest to check.</param>
        /// <param name="assetId">Guid of the asset to look for.</param>
        /// <returns>Boolean to indicate that the manifest has the asset.</returns>
        private static bool ManifestHasAsset(AvatarManifest manifest, Guid assetId)
        {
            string manifestString = GenerateManifestString(manifest.SaveToBinary());
            return ManifestHasAsset(manifestString, assetId);
        }

        /// <summary>
        /// Checks if the given manifest has the given asset.
        /// </summary>
        /// <param name="manifestString">Manifest string in hex to check.</param>
        /// <param name="assetId">Guid of the asset to look for.</param>
        /// <returns>Boolean to indicate that the manifest has the asset.</returns>
        private static bool ManifestHasAsset(string manifestString, Guid assetId)
        {
            string assetString = assetId.ToString().Replace("-", "").ToUpper();
            return manifestString.Contains(assetString);
        }

        /// <summary>
        /// Checks if two given manifests are equal.
        /// </summary>
        /// <param name="manifest1">Manifest data in bytes.</param>
        /// <param name="manifest2">Second manifest data in bytes to compare.</param>
        /// <returns>Boolean to indicate that two manifests are equal.</returns>
        public static bool ManifestsAreEqual(byte[] manifest1, byte[] manifest2)
        {
            return string.Equals(GenerateManifestString(manifest1), GenerateManifestString(manifest2), StringComparison.OrdinalIgnoreCase);
        }

        /// <summary>
        /// Adds the given asset to the current account's manifest. 
        /// NOTE: Only the assets that the account owns should be equipped. Otherwise, ManifestWrite operation will fail.
        /// </summary>
        /// <param name="asset">Asset to equip</param>
        /// <returns>Boolean to indicate that the manifest contains the asset.</returns>
        public static bool EquipAsset(ref byte[] manifestData, BaseAsset asset)
        {
            return EquipAsset(ref manifestData, asset.Id);
        }

        /// <summary>
        /// Adds the given asset to the current account's manifest. 
        /// NOTE: Only the assets that the account owns should be equipped. Otherwise, ManifestWrite operation will fail.
        /// </summary>
        /// <param name="assetId">Guid of the asset to equip</param>
        /// <returns>Boolean to indicate that the manifest contains the asset.</returns>
        public static bool EquipAsset(ref byte[] manifestData, Guid assetId)
        {
            AvatarManifest manifest = AvatarManifest.Create(manifestData);
            manifest.Update(assetManager, assetId);

            if (ManifestHasAsset(manifest, assetId))
            {
                return true;
            }
            else
            {
                return false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\AvatarLib\AwardableAsset.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Xml;
using System.Xml.Linq;
using System.Xml.XPath;

namespace LiveN.Test.Avatar
{
    public class AwardableAsset : BaseAsset
    {
        private uint _titleStringId;
        private uint _descriptionStringId;

        public uint Ordinal { get; set; }
        public uint SortIndex { get; set; }
        public int Flags { get; set; }
        public string FriendlyName { get; set; }
        
        private string _locale = "en-US";
        public string Locale 
        { 
            get
            {
                return _locale;
            }
            set
            {
                _description = String.Empty;
                _title = String.Empty;
                _locale = value;
            }
        }

        private string _title;
        public string Title 
        {
            get
            {
                if(String.IsNullOrEmpty(_title))
                {
                    _title = AssignLocalizedString(_titleStringId);
                }
                return _title;
            }
        }

        private string _description;
        public override string Description
        {
            get
            {
                if (String.IsNullOrEmpty(_description))
                {
                    _description = AssignLocalizedString(_descriptionStringId);
                }
                return _description;
            }
            set
            {
                _description = value;
            }
        }

        public AwardableAsset() { }

        public AwardableAsset(Guid id, string friendlyName, uint ordinal, uint sortIndex)
        {
            this.Id = id;
            this.FriendlyName = friendlyName;
            this.Ordinal = ordinal;
            this.SortIndex = sortIndex;
        }

        public AwardableAsset(Guid id, string friendlyName, uint ordinal, uint sortIndex, uint titleStringId, uint descriptionStringId)
        {
            this.Id = id;
            this.FriendlyName = friendlyName;
            this.Ordinal = ordinal;
            this.SortIndex = sortIndex;
            this._descriptionStringId = descriptionStringId;
            this._titleStringId = titleStringId;
        }

        private string AssignLocalizedString(uint stringId)
        {
            Assembly assembly = Assembly.GetExecutingAssembly();
            Stream stream = assembly.GetManifestResourceStream(assembly.GetName().Name + ".Underachievemenswear_Original.xlast");

            XPathDocument doc = new XPathDocument(stream);
            XPathNavigator navigator = doc.CreateNavigator();

            XPathExpression query = navigator.Compile(String.Format("//xbox:LocalizedString[@id={0}]/xbox:Translation[@locale='{1}']", stringId, this.Locale));

            XmlNamespaceManager ns = new XmlNamespaceManager(navigator.NameTable);
            ns.AddNamespace("xbox", "http://www.xboxlive.com/xlast");
            query.SetContext(ns);
            XPathNodeIterator nodes = navigator.Select(query);
            if (nodes.MoveNext())
            {
                return nodes.Current.Value;
            }
            else
            {
                return String.Empty;
            }
        }
    }

    public class AwardableAssetCollection : AssetCollection<AwardableAsset>
    {
        private static readonly AwardableAssetCollection instance = new AwardableAssetCollection();
        public static AwardableAssetCollection Instance
        {
            get { return instance; }
        }

        private AwardableAssetCollection()
        {
            Assembly assembly = Assembly.GetExecutingAssembly();
            Stream stream = assembly.GetManifestResourceStream(assembly.GetName().Name + ".Underachievemenswear_Original.xlast");

            using (XmlReader reader = XmlReader.Create(stream))
            {
                XDocument tocAssets = XDocument.Load(reader);
                XNamespace ns = tocAssets.Root.Name.Namespace;

                string guid1 = string.Empty;
                string guid2 = string.Empty;
                string friendlyName;
                uint ordinalId;
                uint titleStringId;
                uint descriptionStringId;

                IEnumerable<XElement> allAwards = tocAssets.Descendants(ns + "XboxLiveSubmissionProject")
                    .Descendants(ns + "GameConfigProject").Descendants(ns + "AvatarItems").Descendants(ns + "AvatarItem");

                foreach (XElement award in allAwards)
                {
                    guid2 = String.Empty;
                    try
                    {
                        ordinalId = Convert.ToUInt32(award.Attribute("id").Value);
                        friendlyName = award.Attribute("friendlyName").Value;
                        guid1 = award.Attribute("guid1").Value;
                        titleStringId = Convert.ToUInt32(award.Attribute("displayStringId1").Value);
                        descriptionStringId = Convert.ToUInt32(award.Attribute("descriptionStringId").Value);
                        this.Add(new AwardableAsset(new Guid(guid1), friendlyName, ordinalId, ordinalId, titleStringId, descriptionStringId));

                        if (award.Attribute("guid2") != null)
                        {
                            guid2 = award.Attribute("guid2").Value;
                            titleStringId = Convert.ToUInt32(award.Attribute("displayStringId2").Value);
                        }
                        if (!string.IsNullOrEmpty(guid2))
                        {
                            this.Add(new AwardableAsset(new Guid(guid2), friendlyName, ordinalId, ordinalId, titleStringId, descriptionStringId));
                        }
                    }
                    catch (Exception ex)
                    {
                        // Suppress an exception and continue to next
                        Trace.WriteLine(string.Format("There was an error retrieving an asset {0}: {1}", award.ToString(), ex.ToString()));
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\AvatarLib\StockAsset.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Xml;
using System.Xml.Linq;

namespace LiveN.Test.Avatar
{
    public class StockAsset : BaseAsset
    {
        public uint Index { get; set; }
        public string CategoryString { get; set; }

        public StockAsset() { }

        public StockAsset(Guid id, string description, string category, uint index)
        {
            this.Id = id;
            this.Description = description;
            this.Index = index;
            this.CategoryString = category;
        }
    }

    public class StockAssetCollection : AssetCollection<StockAsset>
    {
        private static readonly StockAssetCollection instance = new StockAssetCollection();
        public static StockAssetCollection Instance
        {
            get { return instance; }
        }

        private StockAssetCollection()
        {
            Assembly assembly = Assembly.GetExecutingAssembly();
            Stream stream = assembly.GetManifestResourceStream(assembly.GetName().Name + ".tocindex_en.xml");

            using (XmlReader reader = XmlReader.Create(stream))
            {
                XDocument tocAssets = XDocument.Load(reader);

                string assetId = string.Empty;
                string assetDescription = string.Empty;
                string assetCategory = string.Empty;
                uint assetIndex = 0;

                IEnumerable<XElement> allAssets = tocAssets.Descendants("Assets").Descendants("AssetCategory").Descendants("Asset");
                foreach (XElement asset in allAssets)
                {
                    try
                    {
                        assetCategory = asset.Parent.Attribute("name").Value.ToLower();
                        assetId = asset.Attribute("id").Value;
                        assetDescription = asset.Element("Description").Value;
                        assetIndex = Convert.ToUInt32(asset.Attribute("index").Value);

                        this.Add(new StockAsset(new Guid(assetId), assetDescription, assetCategory, assetIndex));
                    }
                    catch (Exception ex)
                    {
                        // Suppress an exception and continue to next
                        Trace.WriteLine(string.Format("There was an error retrieving an asset {0}: {1}", asset.ToString(), ex.ToString()));
                    }
                }

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\AvatarLib\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("LiveN.Test.Avatar")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("f9bd68ae-49fb-445d-991d-9f0261978ee7")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\CommonLib\AssemblyNameComparer.cs ===
using System;
using System.Collections;
using System.Reflection;

namespace LiveN.Test.Common
{
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Summary description for AssemblyNameComparer.
	/// </summary>
	public class AssemblyNameComparer: IComparer
	{
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public AssemblyNameComparer()
		{
			
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="x"></param>
		/// <param name="y"></param>
		/// <returns></returns>
		public int Compare(object x, object y)
		{
			AssemblyName first = x as AssemblyName;
			AssemblyName second = y as AssemblyName;

			return first.Name.CompareTo(second.Name);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\CommonLib\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Common")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft")]
//[assembly: AssemblyProduct("Common")]
//[assembly: AssemblyCopyright("Copyright © Microsoft 2010")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("d76468f2-b9eb-4cb0-9f85-79b177aa59d5")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\CommonLib\ColorConsoleTraceListener.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.Globalization;

namespace LiveN.Test.Common
{
    /// <summary>
    /// 
    /// </summary>
    public class ColorConsoleTraceListener : TextWriterTraceListener
    {
        private bool showSource;

        /// <summary>
        /// 
        /// </summary>
        public ColorConsoleTraceListener()
            : this(true)
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="showSource"></param>
        public ColorConsoleTraceListener(bool showSource)
            : base(Console.Out)
        {
            this.showSource = showSource;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="eventCache"></param>
        /// <param name="source"></param>
        /// <param name="eventType"></param>
        /// <param name="id"></param>
        /// <param name="message"></param>
        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message)
        {
            if ((this.Filter != null) && !this.Filter.ShouldTrace(eventCache, source, eventType, id, message, null, null, null))
                return;

            try
            {
                Console.ForegroundColor = ConsoleColor.White;
                this.WriteHeader(source, eventType, id);

                switch (eventType)
                {
                    case TraceEventType.Start:
                    case TraceEventType.Stop:
                        {
                            Console.ForegroundColor = ConsoleColor.Green;
                            break;
                        }
                    case TraceEventType.Verbose:
                        {
                            Console.ForegroundColor = ConsoleColor.Gray;
                            break;
                        }
                    case TraceEventType.Information:
                        {
                            Console.ForegroundColor = ConsoleColor.Blue;
                            break;
                        }
                    case TraceEventType.Warning:
                        {
                            Console.ForegroundColor = ConsoleColor.Yellow;
                            break;
                        }
                    case TraceEventType.Error:
                    case TraceEventType.Critical:
                        {
                            Console.ForegroundColor = ConsoleColor.Red;
                            break;
                        }
                }

                base.WriteLine(message);

                Console.ForegroundColor = ConsoleColor.White;
                this.WriteFooter(eventCache);
            }
            finally
            {
                Console.ResetColor();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="eventCache"></param>
        /// <param name="source"></param>
        /// <param name="eventType"></param>
        /// <param name="id"></param>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, params object[] args)
        {
            TraceEvent(eventCache, source, eventType, id, String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void WriteIndent()
        {
            this.NeedIndent = false;
            for (int i = 0; i < this.IndentLevel; i++)
            {
                for (int j = 0; j < this.IndentSize; j++)
                    this.Write("\t");
            }
            //base.WriteIndent();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="source"></param>
        /// <param name="type"></param>
        /// <param name="id"></param>
        protected virtual void WriteHeader(string source, TraceEventType type, int id)
        {
            StringBuilder header = new StringBuilder();
            if (this.showSource)
                header.AppendFormat("{0} ", source);
            header.AppendFormat("{0}: ", type);
            if (id != 0)
                header.AppendFormat("{0}: ", id);
            this.Write(header.ToString());
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="cache"></param>
        protected virtual void WriteFooter(TraceEventCache eventCache)
        {
            if (eventCache != null)
            {
                base.IndentLevel++;
                if (this.IsEnabled(TraceOptions.ProcessId))
                {
                    this.WriteLine("ProcessId=" + eventCache.ProcessId);
                }
                if (this.IsEnabled(TraceOptions.LogicalOperationStack))
                {
                    this.Write("LogicalOperationStack=");
                    Stack logicalOperationStack = eventCache.LogicalOperationStack;
                    bool flag = true;
                    foreach (object obj2 in logicalOperationStack)
                    {
                        if (!flag)
                        {
                            this.Write(", ");
                        }
                        else
                        {
                            flag = false;
                        }
                        this.Write(obj2.ToString());
                    }
                    this.WriteLine(string.Empty);
                }
                if (this.IsEnabled(TraceOptions.ThreadId))
                {
                    this.WriteLine("ThreadId=" + eventCache.ThreadId);
                }
                if (this.IsEnabled(TraceOptions.DateTime))
                {
                    //this POS is in UTC; convert to local
                    DateTime local = TimeZoneInfo.ConvertTimeFromUtc(eventCache.DateTime, TimeZoneInfo.Local);
                    this.WriteLine("DateTime=" + local.ToString("MM/dd/yyyy hh:mm:ss.ffff tt"));
                }
                if (this.IsEnabled(TraceOptions.Timestamp))
                {
                    this.WriteLine("Timestamp=" + eventCache.Timestamp);
                }
                if (this.IsEnabled(TraceOptions.Callstack))
                {
                    this.WriteLine("Callstack=" + eventCache.Callstack);
                }
                base.IndentLevel--;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="opts"></param>
        /// <returns></returns>
        protected bool IsEnabled(TraceOptions opts)
        {
            return ((opts & this.TraceOutputOptions) != TraceOptions.None);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\CommonLib\EventViewer.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.Collections;
using System.Collections.ObjectModel;

namespace LiveN.Test.Common
{
    /// <summary>
    /// Event viewer class
    /// </summary>
    public class EventViewer
    {
        #region variables

        /// <summary>
        /// Source name for the start mark entry
        /// </summary>
        private const string SourceMark = "EventViewerStart";

        /// <summary>
        /// Total events logged
        /// </summary>
        private int totalCount;

        /// <summary>
        /// Log name
        /// </summary>
        private string logName;

        /// <summary>
        /// start time
        /// </summary>
        private DateTime startTime;

        /// <summary>
        /// Last mark in event log
        /// </summary>
        private string lastMark;

        /// <summary>
        /// machine name
        /// </summary>
        private string machineName;

        /// <summary>
        /// Event source
        /// </summary>
        public string EventSource { get; set; }

        #endregion

        /// <summary>
        /// Create an EventViewer class that can be used to pull event from the passed in logName
        /// </summary>
        /// <param name="logName">Application, Security, System, ...</param>
        public EventViewer(string machine, string logName, string source)
        {
            this.logName = logName;
            EventSource = source;
            machineName = machine;

            if (!EventLog.SourceExists(logName, machineName))
            {
                throw new Exception(String.Format("ERROR: LogName: {0} or MachineName: {1} do not exist", logName, machine));
            }

            ResetEventStartPosition();
        }

        /// <summary>
        /// Resets the start position by writing an entry that we can find later
        /// </summary>
        public void ResetEventStartPosition()
        {
            Random r = new Random();

            EventLog eventLog = new EventLog(logName, machineName);
            eventLog.Source = SourceMark;
            lastMark = "LastEntry" + DateTime.Now + r.Next();

            try
            {
                eventLog.WriteEntry(lastMark, EventLogEntryType.Information, 8888);
            }
            catch (System.Security.SecurityException e)
            {
                // If UAC is not enabled a security exception will be thrown
                throw new System.Security.SecurityException("ERROR:Make sure that you run as administrator.", e);
            }

            EventLogEntryCollection logEntryCollection = eventLog.Entries;
            totalCount = logEntryCollection.Count;
            startTime = logEntryCollection[totalCount - 1].TimeWritten;
        }

        /// <summary>
        /// Clears all events in the event log
        /// </summary>
        public void ClearAllEvents()
        {
            EventLog eventLog = new EventLog(logName, machineName);

            try
            {
                eventLog.Clear();
            }
            catch (System.Security.SecurityException e)
            {
                // If UAC is not enabled a security exception will be thrown
                throw new System.Security.SecurityException("ERROR:Make sure that you run as administrator.", e);
            }

            // Reset the event start position
            ResetEventStartPosition();
        }

        /// <summary>
        /// Gets all the events from the start time
        /// </summary>
        /// <returns>all events in a collection</returns>
        public Collection<EventLogEntry> GetAllEvents()
        {
            return GetAllEvents(EventLogEntryType.Error, EventLogEntryType.Warning, EventLogEntryType.Information);
        }

        /// <summary>
        /// Gets all the events from the start time
        /// </summary>
        /// <param name="eventLogEntryTypes">List of EventLog types that you want returned</param>
        /// <returns>Array of EventLogs that meet your criteria</returns>
        public Collection<EventLogEntry> GetAllEvents(params EventLogEntryType[] eventLogEntryTypes)
        {
            return this.GetAllEvents(null, eventLogEntryTypes);
        }

        /// <summary>
        /// Get all the events with specified event types and event id
        /// If you don't want to filter your search by EventId, specifying expectedEventLogId = null will ignore it
        /// </summary>
        /// <param name="expectedEventLogId">Expected event instance id, if null, it will ignore this filter</param>
        /// <param name="eventLogEntryTypes">Event log entry types that we are looking for</param>
        /// <returns>Array of EventLogs that meet your criteria</returns>
        public Collection<EventLogEntry> GetAllEvents(long? expectedEventLogId, params EventLogEntryType[] eventLogEntryTypes)
        {
            Collection<EventLogEntry> retEventLogEntry = new Collection<EventLogEntry>();

            if (eventLogEntryTypes.Length == 0)
            {
                return retEventLogEntry;
            }

            EventLog eventLog = new EventLog(logName, this.machineName);
            EventLogEntryCollection logEntryCollection = eventLog.Entries;

            int startingIndex = this.totalCount;
            if (totalCount > 0 &&
                ((logEntryCollection.Count < totalCount) ||
                 (logEntryCollection[this.totalCount - 1].Source != EventViewer.SourceMark)))
            {
                // The event logs must have been cleaned or the log is full and start has been pushed back
                // Starting from the last entry, go back until you find the last entry before the start time

                // Setting to zero to ensure if the loop exist, you will start are the beginning
                startingIndex = this.FindStartPoint(ref logEntryCollection);
            }

            // Collect all the long entries from the starting point on
            for (int i = startingIndex, loggingSpot = 0; i < logEntryCollection.Count; i++, loggingSpot++)
            {
                if (logEntryCollection[i].Source == EventSource)
                {
                    for (int x = 0; x < eventLogEntryTypes.Length; x++)
                    {
                        if (eventLogEntryTypes[x] == logEntryCollection[i].EntryType)
                        {
                            
                            // If expectedEventLogId is set to null, we will ignore this filter
                            if ((expectedEventLogId != null && logEntryCollection[i].InstanceId == expectedEventLogId) ||
                                expectedEventLogId == null)
                            {
                                retEventLogEntry.Add(logEntryCollection[i]);
                            }
                            
                            break;
                        }
                    }
                }
            }

            return retEventLogEntry;
        }

        /// <summary>
        /// Generate a well formatted string for all the events
        /// </summary>
        /// <returns>Well formatted string describing the events</returns>
        public string GenerateFormattedStringForAllEvents()
        {
            string output = string.Empty;

            try
            {
                Collection<EventLogEntry> events = GetAllEvents();

                output = GenerateFormattedString(events);
            }
            catch (Exception exc)
            {
                output += "HAD AN EXCEPTION while trying to output the Event Logs. Exception: " + exc.ToString();
            }

            return output;
        }

        /// <summary>
        /// Generates a well formatted string of all the passed in events
        /// </summary>
        /// <param name="events">Collection of events to be outputted</param>
        /// <returns>Well formatted string describing the events</returns>
        public static string GenerateFormattedString(Collection<EventLogEntry> events)
        {
            string output = string.Empty;

            try
            {
                foreach (EventLogEntry entry in events)
                {
                    output += "Source: " + entry.Source + " \tLogged: " + entry.TimeGenerated + "\r\n" +
                              "EventID: " + entry.InstanceId + "\t\tLevel: " + entry.EntryType + "\r\n" +
                              "Message: " + entry.Message.Replace("\r\n", "\r\n\t") + "\r\n";
                }
            }
            catch(Exception exc)
            {
                output += "HAD AN EXCEPTION while trying to output the Event Logs. Exception: " + exc.ToString();
            }

            return output;
        }

        /// <summary>
        /// Searches for the marked starting point
        /// </summary>
        /// <param name="logEntryCollection">log entry collection</param>
        /// <returns>location of cloest start time</returns>
        private int FindStartPoint(ref EventLogEntryCollection logEntryCollection)
        {
            return FindStartPoint(ref logEntryCollection, 0, logEntryCollection.Count - 1);
        }

        /// <summary>
        /// Search for the start point
        /// </summary>
        /// <param name="logEntryCollection">collection</param>
        /// <param name="min">min search point</param>
        /// <param name="max">max search point</param>
        /// <returns>returns the index of the entry with the closes start time</returns>
        private int FindStartPoint(
            ref EventLogEntryCollection logEntryCollection,
            int min,
            int max)
        {
            int i = max;
            int j = ((max - min) / 2) + min;

            if (i > logEntryCollection.Count - 1)
            {
                return logEntryCollection.Count - 1;
            }

            if (min == max)
            {
                return min;
            }

            if (logEntryCollection[i].Message == lastMark &&
                logEntryCollection[i].Source == SourceMark)
            {
                return i;
            }

            if (logEntryCollection[j].TimeWritten < startTime)
            {
                return FindStartPoint(ref logEntryCollection, j, i);
            }
            else if (logEntryCollection[j].TimeWritten > startTime)
            {
                return FindStartPoint(ref logEntryCollection, min, j);
            }
            else
            {
                // If it is equal we don't know if there are several
                // events with the same start time so go backwards till
                // find it or a log time before the start
                int tmp = j;
                while (tmp >= 0 && !(logEntryCollection[tmp].TimeWritten < startTime))
                {
                    if (logEntryCollection[tmp].Message == lastMark &&
                        logEntryCollection[tmp].Source == SourceMark)
                    {
                        return tmp;
                    }

                    // Move on if it still has the same time but not the mark;
                    tmp--;
                }

                // if not found it possible that more events with the same start 
                // time is after j.
                return FindStartPoint(ref logEntryCollection, j, i);
            }
        }

        /// <summary>
        /// WriteTestEvent writes test events used mainly for testing purpose
        /// </summary>
        /// <param name="EventLogEntryType">Give the EventLogEntrytype</param>
        /// <param name="event_id">Event ID to geberate</param>
        /// <param name="test_message">Message for the Event to be generated</param>
        /// <returns>void</returns>
        public void WriteTestEvent(EventLogEntryType event_type, int event_id, string test_message)
        {
            EventLog eventLog = new EventLog(logName, machineName);
            eventLog.Source = this.EventSource;

            try
            {
                eventLog.WriteEntry(test_message, event_type, event_id);
            }
            catch (System.Security.SecurityException e)
            {
                // If UAC is not enabled a security exception will be thrown
                throw new System.Security.SecurityException("ERROR:Make sure that you run as administrator.", e);
            }
        }

        /// <summary>
        /// Search for events that match the given inputs - event id, message, event type
        /// </summary>
        /// <param name="event_id">Event ID to search</param>
        /// <param name="eventLogEntryTypes">Event log entry type to search</param>
        /// <param name="message">Event message to search</param>
        /// <returns>int - count of number of events that match the event specified - ID, event_type, message</returns>
        public int SearchtEvent(int event_id, EventLogEntryType event_type, string message)
        {
            int count = 0;
            Collection<EventLogEntry> retEventLogEntry = this.GetAllEvents();

            if(retEventLogEntry != null)
            {
                foreach (EventLogEntry eve in retEventLogEntry)
                {
                    if ((event_id == eve.InstanceId) && (event_type == eve.EntryType) && (eve.Message.Contains(message)))
                    {
                        count++;
                    }
                }
            }

            return count;
        }

        /// <summary>
        /// Count number of events that match the given EventID
        /// </summary>
        /// <param name="event_id">Event ID to search</param>
        /// <returns>int - count of number of events that match the event specified Event ID</returns>
        public int Search_EventID(int event_id)
        {
            int count = 0;
            Collection<EventLogEntry> retEventLogEntry = this.GetAllEvents();

            if (retEventLogEntry != null)
            {
                foreach (EventLogEntry eve in retEventLogEntry)
                {
                    if (event_id == eve.InstanceId)
                    {
                        count++;
                    }
                }
            }

            return count;
        }

        /// <summary>
        /// Count number of events that match the given Message body
        /// </summary>
        /// <param name="message">Message body to search</param>
        /// <returns>int - count of number of events that match the event specified Event message</returns>
        public int SearchMessage(string message)
        {
            int count = 0;
            Collection<EventLogEntry> retEventLogEntry = this.GetAllEvents();

            if (retEventLogEntry != null)
            {
                foreach (EventLogEntry eve in retEventLogEntry)
                {
                    if (eve.Message.Contains(message))
                    {
                        count++;
                    }
                }
            }

            return count;
        }

        /// <summary>
        /// Count all events for the registered source
        /// </summary>
        public int GetTotal_Events()
        {
            Collection<EventLogEntry> retEventLogEntry = this.GetAllEvents();

            return retEventLogEntry.Count;
        }

        /// <summary>
        /// Count all Error events for the registered source
        /// </summary>
        public int GetTotal_ErrorEvents()
        {
            Collection<EventLogEntry> retEventLogEntry = this.GetAllEvents(EventLogEntryType.Error);

            return retEventLogEntry.Count;
        }

        /// <summary>
        /// Count all Warning events for the registered source
        /// </summary>
        public int GetTotal_WarningEvents()
        {
            Collection<EventLogEntry> retEventLogEntry = this.GetAllEvents(EventLogEntryType.Warning);

            return retEventLogEntry.Count;
        }

        /// <summary>
        /// Count all Information events for the registered source
        /// </summary>
        public int GetTotal_InformationEvents()
        {
            Collection<EventLogEntry> retEventLogEntry = this.GetAllEvents(EventLogEntryType.Information);

            return retEventLogEntry.Count;
        }     
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\CommonLib\FileIO.cs ===
//------------------------------------------------------------------------------------
// Description:
//  Used to do common file IO operations
//
// <Copyright> Copyright (C) Microsoft Corporation.  All rights reserved. </Copyright>
//------------------------------------------------------------------------------------

namespace LiveN.Test.Common
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Text;

    /// <summary>
    /// Common code dealing with File IO
    /// </summary>
    public static class FileIO
    {
        /// <summary>
        /// Writes the stream to a binary file
        /// </summary>
        /// <param name="fileName">Name of file to generate</param>
        /// <param name="stream">stream containing the binary</param>
        public static void BinaryFileWriter(string fileName, Stream stream)
        {
            using (BinaryWriter br = new BinaryWriter(new FileStream(fileName, FileMode.CreateNew)))
            {
                int read;
                byte[] buffer = new byte[32 * 1024];

                while ((read = stream.Read(buffer, 0, buffer.Length)) > 0)
                {
                    br.Write(buffer);
                }
            }
        }

        /// <summary>
        /// Change the passed in file's attribute to ReadOnly if it's not already.
        /// </summary>
        /// <param name="path">the File path</param>
        public static void MakeReadOnly(string path)
        {
            if (!File.Exists(path))
            {
                throw new FileNotFoundException("File (" + path + ") does not exists.");
            }

            if (!((File.GetAttributes(path) & FileAttributes.ReadOnly) == 0))
            {
                return; // It's already read only
            }

            File.SetAttributes(path, FileAttributes.ReadOnly);
        }

        /// <summary>
        /// Change the passed in file's attribute to Normal.
        /// </summary>
        /// <param name="path">the File path</param>
        public static void MakeWriteable(string path)
        {
            if (!File.Exists(path))
            {
                throw new Exception("File (" + path + ") does not exists.");
            }

            if ((File.GetAttributes(path) & FileAttributes.ReadOnly) == 0)
            {
                return; // It's not read only
            }

            File.SetAttributes(path, FileAttributes.Normal);
        }

        /// <summary>
        /// Return if the file is Writeable or Not.
        /// </summary>
        /// <param name="path">the File path</param>
        /// <returns>Returns true if the file is writable. Else it returns false.</returns>
        public static bool IsWriteable(string path)
        {
            if (!File.Exists(path))
            {
                throw new FileNotFoundException("File (" + path + ") does not exists.");
            }

            if ((File.GetAttributes(path) & FileAttributes.ReadOnly) == 0)
            {
                return true; // It's not read only
            }

            // It's read only
            return false;
        }

        /// <summary>
        /// Create the passed in directory
        /// </summary>
        /// <param name="path">Path filename of the directory to be created.</param>
        /// <returns>Returns the DirectoryInfo of the newly created directory</returns>
        public static DirectoryInfo CreateDirectory(string path)
        {
            if (string.IsNullOrEmpty(path))
            {
                return null;
            }

            string dir;
            FileInfo file = new FileInfo(path);

            dir = path;
            if (file.Extension.Length > 0)
            {
                // This means that they passed in a filename
                dir = file.DirectoryName;
            }

            return Directory.CreateDirectory(dir);
        }

        /// <summary>
        /// Clear the passed in directory
        /// </summary>
        /// <param name="path">Path directory to be cleared.</param>
        public static void ClearDirectory(string path)
        {
            string[] locations;
            FileInfo fileInfo = new FileInfo(path);

            if (fileInfo.Extension.Length > 0)
            {
                // This means that they passed in a filename
                path = fileInfo.DirectoryName;
            }

            locations = Directory.GetFiles(path);
            foreach (string file in locations)
            {
                File.Delete(file);
            }

            locations = Directory.GetDirectories(path);
            foreach (string dir in locations)
            {
                Directory.Delete(dir, true);
            }
        }

        /// <summary>
        /// This method accepts two strings the represent two files to 
        /// compare. A return value of 0 indicates that the contents of the files
        /// are the same. A return value of any other value indicates that the 
        /// files are not the same.
        /// </summary>
        /// <param name="file1">File 1</param>
        /// <param name="file2">File 2</param>
        /// <returns>true if equal else false</returns>
        public static bool FileCompare(string file1, string file2)
        {
            int file1byte;
            int file2byte;
            FileStream fs1;
            FileStream fs2;

            // Determine if the same file was referenced two times.
            if (file1 == file2)
            {
                // Return true to indicate that the files are the same.
                return true;
            }

            // Open the two files.
            fs1 = new FileStream(file1, FileMode.Open);
            fs2 = new FileStream(file2, FileMode.Open);

            // Check the file sizes. If they are not the same, the files 
            // are not the same.
            if (fs1.Length != fs2.Length)
            {
                // Close the file
                fs1.Close();
                fs2.Close();

                // Return false to indicate files are different
                return false;
            }

            // Read and compare a byte from each file until either a
            // non-matching set of bytes is found or until the end of
            // file1 is reached.
            do
            {
                // Read one byte from each file.
                file1byte = fs1.ReadByte();
                file2byte = fs2.ReadByte();
            }
            while ((file1byte == file2byte) && (file1byte != -1));

            // Close the files.
            fs1.Close();
            fs2.Close();

            // Return the success of the comparison. "file1byte" is 
            // equal to "file2byte" at this point only if the files are 
            // the same.
            return ((file1byte - file2byte) == 0);
        }

        /// <summary>
        /// Copy a file
        /// </summary>
        /// <param name="sourceFileName">From file</param>
        /// <param name="destFileName">Copy to file</param>
        public static void CopyFile(string sourceFileName, string destFileName)
        {
            CreateDirectory(destFileName);

            if (File.Exists(destFileName))
            {
                // Destination file exist, you need to ensure that you can write to it
                File.SetAttributes(destFileName, FileAttributes.Normal);
            }

            try
            {
                File.Copy(sourceFileName, destFileName, true);
            }
            catch (Exception exc)
            {
                throw new Exception("Had a problem coping '" + sourceFileName + "' to '" + destFileName + "'. \r\nException:\r\n" + exc.ToString());
            }
        }

        /// <summary>
        /// Copies alls the files and sub folders
        /// </summary>
        /// <param name="sourcePath">Directory to be copied</param>
        /// <param name="destPath">Directory to copy to</param>
        public static void CopyDirectory(string sourcePath, string destPath)
        {
            int i;
            string[] files;
            string[] dirs;
            string[] parentFolderName;

            if (!Directory.Exists(sourcePath))
            {
                throw new DirectoryNotFoundException("Directory '" + sourcePath + "' does not exist.");
            }

            files = Directory.GetFiles(sourcePath);
            dirs = Directory.GetDirectories(sourcePath);

            if (destPath.EndsWith("\\"))
            {
                destPath = destPath.Substring(0, destPath.Length - 1);
            }

            for (i = 0; i < files.Length; i++)
            {
                CopyFile(files[i], destPath + "\\" + new FileInfo(files[i]).Name);
            }

            for (i = 0; i < dirs.Length; i++)
            {
                parentFolderName = dirs[i].Split('\\');

                CopyDirectory(dirs[i], destPath + "\\" + parentFolderName[parentFolderName.Length - 1]);
            }
        }

        /// <summary>
        /// Creates an output file 
        /// </summary>
        /// <param name="stream">Resource Stream</param>
        /// <param name="filename">Desired output filename</param>
        public static void CreateOutputFile(Stream stream, string filename)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            using (StreamReader streamReader = new StreamReader(stream))
            {
                CreateOutputFile(streamReader, filename, System.Text.Encoding.Default);
            }
        }

        /// <summary>
        /// Creates an output file
        /// </summary>
        /// <param name="stream">Resource Stream</param>
        /// <param name="filename">Desired output filename</param>
        /// <param name="encoding">Encoding Type</param>
        public static void CreateOutputFile(Stream stream, string filename, System.Text.Encoding encoding)
        {
            if (stream == null)
            {
                throw new ArgumentNullException("stream");
            }

            using (StreamReader streamReader = new StreamReader(stream))
            {
                CreateOutputFile(streamReader, filename, encoding);
            }
        }

        /// <summary>
        /// Creates a file from a text reader based on an encoding
        /// </summary>
        /// <param name="reader">TextReader to be written to a file</param>
        /// <param name="fileName">Desired output filename</param>
        /// <param name="encoding">Encoding Type</param>
        public static void CreateOutputFile(TextReader reader, string fileName, Encoding encoding)
        {
            if (reader == null)
            {
                throw new ArgumentNullException("reader");
            }

            if (string.IsNullOrEmpty(fileName))
            {
                throw new ArgumentNullException("fileName");
            }

            // Don't try to read to end otherwise because if big streams are processed
            // we can run into issues
            using (StreamWriter streamWriter = new StreamWriter(File.Create(fileName), encoding))
            {
                char[] buff = new char[1024];
                int readLen;
                while ((readLen = reader.Read(buff, 0, buff.Length)) > 0)
                {
                    streamWriter.Write(buff, 0, readLen);
                }
            }
        }

        /// <summary>
        /// Creates an output file
        /// </summary>
        /// <param name="output">String to be written to a file</param>
        /// <param name="filename">Desired output filename</param>
        /// <param name="encoding">Encoding Type</param>
        public static void CreateOutputFile(string output, string filename, System.Text.Encoding encoding)
        {
            StreamWriter streamWriter;

            if (output == null)
            {
                throw new ArgumentNullException("output");
            }

            if (string.IsNullOrEmpty(filename))
            {
                throw new ArgumentNullException("filename");
            }

            streamWriter = new StreamWriter(File.Create(filename), encoding);
            streamWriter.Write(output);
            streamWriter.Close();
        }

        /// <summary>
        /// Creates a binary output file. Used to keep an exe in tacked
        /// </summary>
        /// <param name="stream">Resource Stream</param>
        /// <param name="filename">Desired output filename</param>
        public static void CreateOutputBinaryFile(Stream stream, string filename)
        {
            int bytesRead;
            const int SIZE_BUFF = 1024;
            byte[] buffer = new byte[SIZE_BUFF];
            Stream fileOut = System.IO.File.OpenWrite(filename);

            while ((bytesRead = stream.Read(buffer, 0, SIZE_BUFF)) > 0)
            {
                fileOut.Write(buffer, 0, bytesRead);
            }

            fileOut.Close();
        }

        /// <summary>
        /// Redirect the stderr and stdout to the string arguments passed in
        /// </summary>
        /// <param name="fileName">the program to execute</param>
        /// <param name="args">the arguments</param>
        /// <param name="stdErr">reference to the buffer stderr</param>
        /// <param name="stdOut">reference to the buffer stdout </param>
        /// <returns>Returns the ExitCode of the process</returns>
        public static int RedirectProcessOutput(string fileName, string[] args, out string stdErr, out string stdOut)
        {
            StringBuilder stdErrBuff = new StringBuilder();
            StringBuilder stdOutBuff = new StringBuilder();

            if (args == null)
            {
                // No arguments where passed in
                args = new string[0];
            }

            stdErr = string.Empty;
            stdOut = string.Empty;

            // Setup start info to redirect output
            ProcessStartInfo procStartInfo = new ProcessStartInfo(fileName);
            procStartInfo.Arguments = string.Join(" ", args);
            procStartInfo.RedirectStandardError = true;
            procStartInfo.RedirectStandardOutput = true;
            procStartInfo.UseShellExecute = false;
            procStartInfo.CreateNoWindow = true;
            procStartInfo.ErrorDialog = false;

            // Init process and event handler for output redirection
            Process proc = new Process();

            proc.StartInfo = procStartInfo;
            proc.ErrorDataReceived += new DataReceivedEventHandler(
                delegate(object o, DataReceivedEventArgs e)
                {
                    stdErrBuff.Append(e.Data);
                    if (!string.IsNullOrEmpty(e.Data))
                    {
                        stdErrBuff.Append("\r\n");
                    }
                });

            proc.OutputDataReceived += new DataReceivedEventHandler(
                delegate(object o, DataReceivedEventArgs e)
                {
                    stdOutBuff.Append(e.Data);
                    if (!string.IsNullOrEmpty(e.Data))
                    {
                        stdOutBuff.Append("\r\n");
                    }
                });

            // Startup the process and the readers
            proc.Start();
            proc.BeginErrorReadLine();
            proc.BeginOutputReadLine();
            proc.WaitForExit();

            stdErr = stdErrBuff.ToString();
            stdOut = stdOutBuff.ToString();

            return proc.ExitCode;
        }

        /// <summary>
        /// Returns the file stream encoding by looking for the BOM at the being of the stream
        /// </summary>
        /// <param name="fs">file stream</param>
        /// <returns>Encoding of file stream</returns>
        public static Encoding GetFileEncoding(Stream fs)
        {
            Encoding retEncoding = Encoding.Default;
            if (fs != null && !fs.CanRead)
            {
                throw new ArgumentException("File stream must be not null and readable");
            }

            byte[] mark = new byte[4];

            long initPosition = fs.Position;
            fs.Position = 0;
            int readBytes = fs.Read(mark, 0, mark.Length);

            if (readBytes == 0)
            {
                throw new Exception("Error reading stream");
            }

            if (mark[0] == 239 && mark[1] == 187 && mark[2] == 191)
            {
                // EF BB BF - UTF8
                retEncoding = Encoding.UTF8;
            }
            else if (mark[0] == 254 && mark[1] == 255)
            {
                // FE FF - UTF16 (Big Endian)
                retEncoding = Encoding.BigEndianUnicode;
            }
            else if (mark[0] == 254 && mark[1] == 255)
            {
                retEncoding = Encoding.UTF32;

                // FF FE - UTF16 (Little Endian) else it is FF FE - UTF32 (Little Endian)
                if (mark[2] != 0 && mark[3] != 0)
                {
                    retEncoding = Encoding.GetEncoding("UTF-16LE");
                }
            }
            else if (mark[0] == 0 && mark[1] == 0 && mark[2] == 254 && mark[3] == 255)
            {
                // FE FF - UTF32 (Big Endian)
                retEncoding = Encoding.GetEncoding("UTF-32BE");
            }

            fs.Position = initPosition;
            return retEncoding;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\CommonLib\ThreadException.cs ===
using System;

namespace LiveN.Test.Common
{
	/// <summary>
	/// 
	/// </summary>
	public class ThreadException: Exception
	{
		/// <summary>
		/// 
		/// </summary>
		public ThreadException(): base()
		{

		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="message"></param>
		public ThreadException(string message): base(message)
		{

		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="innerException"></param>
		public ThreadException(Exception innerException): base(innerException.Message, innerException)
		{

		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="message"></param>
		/// <param name="innerException"></param>
		public ThreadException(string message, Exception innerException): base(message, innerException)
		{

		}

        /// <summary>
        /// 
        /// </summary>
        /// <param name="info"></param>
        /// <param name="context"></param>
        protected ThreadException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context): base(info, context)
        {

        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\CommonLib\CommandLineArguments.cs ===
﻿//////////////////////////////////////////////////////////////////////////////
//    Command Line Argument Parser
//    ----------------------------
//
//    Author: hotweird@hotmail.com
//
//    Microsoft Public License (Ms-PL)
//
//    This license governs use of the accompanying software. If you use the software, you
//    accept this license. If you do not accept the license, do not use the software.
//
//    1. Definitions
//
//    The terms "reproduce," "reproduction," "derivative works," and "distribution" have the
//    same meaning here as under U.S. copyright law.
//
//    A "contribution" is the original software, or any additions or changes to the software.
//
//    A "contributor" is any person that distributes its contribution under this license.
//
//    "Licensed patents" are a contributor's patent claims that read directly on its contribution.
//
//    2. Grant of Rights
//
//    (A) Copyright Grant- Subject to the terms of this license, including the license conditions
//        and limitations in section 3, each contributor grants you a non-exclusive, worldwide,
//        royalty-free copyright license to reproduce its contribution, prepare derivative works
//        of its contribution, and distribute its contribution or any derivative works that you create.
//
//    (B) Patent Grant- Subject to the terms of this license, including the license conditions and
//        limitations in section 3, each contributor grants you a non-exclusive, worldwide,
//        royalty-free license under its licensed patents to make, have made, use, sell, offer for
//        sale, import, and/or otherwise dispose of its contribution in the software or derivative
//        works of the contribution in the software.
//
//    3. Conditions and Limitations
//
//    (A) No Trademark License- This license does not grant you rights to use any contributors'
//        name, logo, or trademarks.
//
//    (B) If you bring a patent claim against any contributor over patents that you claim are
//        infringed by the software, your patent license from such contributor to the software ends
//        automatically.
//
//    (C) If you distribute any portion of the software, you must retain all copyright, patent,
//        trademark, and attribution notices that are present in the software.
//
//    (D) If you distribute any portion of the software in source code form, you may do so only under
//        this license by including a complete copy of this license with your distribution. If you
//        distribute any portion of the software in compiled or object code form, you may only do so
//        under a license that complies with this license.
//
//    (E) The software is licensed "as-is." You bear the risk of using it. The contributors give no
//        express warranties, guarantees or conditions. You may have additional consumer rights under
//        your local laws which this license cannot change. To the extent permitted under your local
//        laws, the contributors exclude the implied warranties of merchantability, fitness for a
//        particular purpose and non-infringement.
//
//    Usage
//    -----
//
//    Parsing command line arguments to a console application is a common problem. 
//    This library handles the common task of reading arguments from a command line 
//    and filling in the values in a type.
//
//    To use this library, define a class whose fields represent the data that your 
//    application wants to receive from arguments on the command line. Then call 
//    CommandLine.ParseArguments() to fill the object with the data 
//    from the command line. Each field in the class defines a command line argument. 
//    The type of the field is used to validate the data read from the command line. 
//    The name of the field defines the name of the command line option.
//
//    The parser can handle fields of the following types:
//
//    - string
//    - int
//    - uint
//    - bool
//    - enum
//    - array of the above type
//
//    For example, suppose you want to read in the argument list for wc (word count). 
//    wc takes three optional boolean arguments: -l, -w, and -c and a list of files.
//
//    You could parse these arguments using the following code:
//
//    class WCArguments
//    {
//        public bool lines;
//        public bool words;
//        public bool chars;
//        public string[] files;
//    }
//
//    class WC
//    {
//        static void Main(string[] args)
//        {
//            if (CommandLine.ParseArgumentsWithUsage(args, parsedArgs))
//            {
//            //     insert application code here
//            }
//        }
//    }
//
//    So you could call this aplication with the following command line to count 
//    lines in the foo and bar files:
//
//        wc.exe /lines /files:foo /files:bar
//
//    The program will display the following usage message when bad command line 
//    arguments are used:
//
//        wc.exe -x
//
//    Unrecognized command line argument '-x'
//        /lines[+|-]                         short form /l
//        /words[+|-]                         short form /w
//        /chars[+|-]                         short form /c
//        /files:<string>                     short form /f
//        @<file>                             Read response file for more options
//
//    That was pretty easy. However, you realy want to omit the "/files:" for the 
//    list of files. The details of field parsing can be controled using custom 
//    attributes. The attributes which control parsing behaviour are:
//
//    ArgumentAttribute 
//        - controls short name, long name, required, allow duplicates, default value
//        and help text
//    DefaultArgumentAttribute 
//        - allows omition of the "/name".
//        - This attribute is allowed on only one field in the argument class.
//
//    So for the wc.exe program we want this:
//
//    using System;
//    using Utilities;
//
//    class WCArguments
//    {
//        [Argument(ArgumentType.AtMostOnce, HelpText="Count number of lines in the input text.")]
//        public bool lines;
//        [Argument(ArgumentType.AtMostOnce, HelpText="Count number of words in the input text.")]
//        public bool words;
//        [Argument(ArgumentType.AtMostOnce, HelpText="Count number of chars in the input text.")]
//        public bool chars;
//        [DefaultArgument(ArgumentType.MultipleUnique, HelpText="Input files to count.")]
//        public string[] files;
//    }
//
//    class WC
//    {
//        static void Main(string[] args)
//        {
//            WCArguments parsedArgs = new WCArguments();
//            if (CommandLine.ParseArgumentsWithUsage(args, parsedArgs))
//            {
//            //     insert application code here
//            }
//        }
//    }
//
//
//
//    So now we have the command line we want:
//
//        wc.exe /lines foo bar
//
//    This will set lines to true and will set files to an array containing the 
//    strings "foo" and "bar".
//
//    The new usage message becomes:
//
//        wc.exe -x
//
//    Unrecognized command line argument '-x'
//    /lines[+|-]  Count number of lines in the input text. (short form /l)
//    /words[+|-]  Count number of words in the input text. (short form /w)
//    /chars[+|-]  Count number of chars in the input text. (short form /c)
//    @<file>      Read response file for more options
//    <files>      Input files to count. (short form /f)
//
//    If you want more control over how error messages are reported, how /help is 
//    dealt with, etc you can instantiate the CommandLine.Parser class.
//
//
//
//    Cheers,
//    Peter Hallam
//    C# Compiler Developer
//    Microsoft Corp.
//
//
//
//
//    Release Notes
//    -------------
//
//    10/02/2002 Initial Release
//    10/14/2002 Bug Fix
//    01/08/2003 Bug Fix in @ include files
//    10/23/2004 Added user specified help text, formatting of help text to 
//            screen width. Added ParseHelp for /?.
//    11/23/2004 Added support for default values.
//    02/23/2005 Fix bug with short name and default arguments.
//////////////////////////////////////////////////////////////////////////////
namespace LiveN.Test.Common
{
    using System;
    using System.Diagnostics;
    using System.Reflection;
    using System.Collections;
    using System.IO;
    using System.Text;
    using System.Runtime.InteropServices;

    /// <summary>
    /// Used to control parsing of command line arguments.
    /// </summary>
    [Flags]
    public enum ArgumentType
    {
        /// <summary>
        /// Indicates that this field is required. An error will be displayed
        /// if it is not present when parsing arguments.
        /// </summary>
        Required = 0x01,
        /// <summary>
        /// Only valid in conjunction with Multiple.
        /// Duplicate values will result in an error.
        /// </summary>
        Unique = 0x02,
        /// <summary>
        /// Inidicates that the argument may be specified more than once.
        /// Only valid if the argument is a collection
        /// </summary>
        Multiple = 0x04,

        /// <summary>
        /// The default type for non-collection arguments.
        /// The argument is not required, but an error will be reported if it is specified more than once.
        /// </summary>
        AtMostOnce = 0x00,

        /// <summary>
        /// For non-collection arguments, when the argument is specified more than
        /// once no error is reported and the value of the argument is the last
        /// value which occurs in the argument list.
        /// </summary>
        LastOccurenceWins = Multiple,

        /// <summary>
        /// The default type for collection arguments.
        /// The argument is permitted to occur multiple times, but duplicate 
        /// values will cause an error to be reported.
        /// </summary>
        MultipleUnique = Multiple | Unique,
    }

    /// <summary>
    /// Allows control of command line parsing.
    /// Attach this attribute to instance fields of types used
    /// as the destination of command line argument parsing.
    /// </summary>
    [AttributeUsage(AttributeTargets.Field)]
    public class ArgumentAttribute : Attribute
    {
        /// <summary>
        /// Allows control of command line parsing.
        /// </summary>
        /// <param name="type"> Specifies the error checking to be done on the argument. </param>
        public ArgumentAttribute(ArgumentType type)
        {
            this.type = type;
        }

        /// <summary>
        /// The error checking to be done on the argument.
        /// </summary>
        public ArgumentType Type
        {
            get { return this.type; }
        }
        /// <summary>
        /// Returns true if the argument did not have an explicit short name specified.
        /// </summary>
        public bool DefaultShortName { get { return null == this.shortName; } }

        /// <summary>
        /// The short name of the argument.
        /// Set to null means use the default short name if it does not
        /// conflict with any other parameter name.
        /// Set to String.Empty for no short name.
        /// This property should not be set for DefaultArgumentAttributes.
        /// </summary>
        public string ShortName
        {
            get { return this.shortName; }
            set { Debug.Assert(value == null || !(this is DefaultArgumentAttribute)); this.shortName = value; }
        }

        /// <summary>
        /// Returns true if the argument did not have an explicit long name specified.
        /// </summary>
        public bool DefaultLongName { get { return null == this.longName; } }

        /// <summary>
        /// The long name of the argument.
        /// Set to null means use the default long name.
        /// The long name for every argument must be unique.
        /// It is an error to specify a long name of String.Empty.
        /// </summary>
        public string LongName
        {
            get { Debug.Assert(!this.DefaultLongName); return this.longName; }
            set { Debug.Assert(value != ""); this.longName = value; }
        }

        /// <summary>
        /// The default value of the argument.
        /// </summary>
        public object DefaultValue
        {
            get { return this.defaultValue; }
            set { this.defaultValue = value; }
        }

        /// <summary>
        /// Returns true if the argument has a default value.
        /// </summary>
        public bool HasDefaultValue { get { return null != this.defaultValue; } }

        /// <summary>
        /// Returns true if the argument has help text specified.
        /// </summary>
        public bool HasHelpText { get { return null != this.helpText; } }

        /// <summary>
        /// The help text for the argument.
        /// </summary>
        public string HelpText
        {
            get { return this.helpText; }
            set { this.helpText = value; }
        }

        private string shortName;
        private string longName;
        private string helpText;
        private object defaultValue;
        private ArgumentType type;
    }

    /// <summary>
    /// Indicates that this argument is the default argument.
    /// '/' or '-' prefix only the argument value is specified.
    /// The ShortName property should not be set for DefaultArgumentAttribute
    /// instances. The LongName property is used for usage text only and
    /// does not affect the usage of the argument.
    /// </summary>
    [AttributeUsage(AttributeTargets.Field)]
    public class DefaultArgumentAttribute : ArgumentAttribute
    {
        /// <summary>
        /// Indicates that this argument is the default argument.
        /// </summary>
        /// <param name="type"> Specifies the error checking to be done on the argument. </param>
        public DefaultArgumentAttribute(ArgumentType type)
            : base(type)
        {
        }
    }

    /// <summary>
    /// A delegate used in error reporting.
    /// </summary>
    public delegate void ErrorReporter(string message);

    /// <summary>
    /// Parser for command line arguments.
    ///
    /// The parser specification is infered from the instance fields of the object
    /// specified as the destination of the parse.
    /// Valid argument types are: int, uint, string, bool, enums
    /// Also argument types of Array of the above types are also valid.
    /// 
    /// Error checking options can be controlled by adding a ArgumentAttribute
    /// to the instance fields of the destination object.
    ///
    /// At most one field may be marked with the DefaultArgumentAttribute
    /// indicating that arguments without a '-' or '/' prefix will be parsed as that argument.
    ///
    /// If not specified then the parser will infer default options for parsing each
    /// instance field. The default long name of the argument is the field name. The
    /// default short name is the first character of the long name. Long names and explicitly
    /// specified short names must be unique. Default short names will be used provided that
    /// the default short name does not conflict with a long name or an explicitly
    /// specified short name.
    ///
    /// Arguments which are array types are collection arguments. Collection
    /// arguments can be specified multiple times.
    /// </summary>
    public sealed class Parser
    {
        /// <summary>
        /// The System Defined new line string.
        /// </summary>
        public const string NewLine = "\r\n";

        /// <summary>
        /// Don't ever call this.
        /// </summary>
        private Parser() { }

        /// <summary>
        /// Parses Command Line Arguments. Displays usage message to Console.Out
        /// if /?, /help or invalid arguments are encounterd.
        /// Errors are output on Console.Error.
        /// Use ArgumentAttributes to control parsing behaviour.
        /// </summary>
        /// <param name="arguments"> The actual arguments. </param>
        /// <param name="destination"> The resulting parsed arguments. </param>
        /// <returns> true if no errors were detected. </returns>
        public static bool ParseArgumentsWithUsage(string[] arguments, object destination)
        {
            if (Parser.ParseHelp(arguments) || !Parser.ParseArguments(arguments, destination))
            {
                // error encountered in arguments. Display usage message
                System.Console.Write(Parser.ArgumentsUsage(destination.GetType()));
                return false;
            }

            return true;
        }

        /// <summary>
        /// Parses Command Line Arguments. 
        /// Errors are output on Console.Error.
        /// Use ArgumentAttributes to control parsing behaviour.
        /// </summary>
        /// <param name="arguments"> The actual arguments. </param>
        /// <param name="destination"> The resulting parsed arguments. </param>
        /// <returns> true if no errors were detected. </returns>
        public static bool ParseArguments(string[] arguments, object destination)
        {
            return Parser.ParseArguments(arguments, destination, new ErrorReporter(Console.Error.WriteLine));
        }

        /// <summary>
        /// Parses Command Line Arguments. 
        /// Use ArgumentAttributes to control parsing behaviour.
        /// </summary>
        /// <param name="arguments"> The actual arguments. </param>
        /// <param name="destination"> The resulting parsed arguments. </param>
        /// <param name="reporter"> The destination for parse errors. </param>
        /// <returns> true if no errors were detected. </returns>
        public static bool ParseArguments(string[] arguments, object destination, ErrorReporter reporter)
        {
            Parser parser = new Parser(destination.GetType(), reporter);
            return parser.Parse(arguments, destination);
        }

        private static void NullErrorReporter(string message)
        {
        }

        private class HelpArgument
        {
            [ArgumentAttribute(ArgumentType.AtMostOnce, ShortName = "?")]
            public bool help = false;
        }

        /// <summary>
        /// Checks if a set of arguments asks for help.
        /// </summary>
        /// <param name="args"> Args to check for help. </param>
        /// <returns> Returns true if args contains /? or /help. </returns>
        public static bool ParseHelp(string[] args)
        {
            Parser helpParser = new Parser(typeof(HelpArgument), new ErrorReporter(NullErrorReporter));
            HelpArgument helpArgument = new HelpArgument();
            helpParser.Parse(args, helpArgument);
            return helpArgument.help;
        }


        /// <summary>
        /// Returns a Usage string for command line argument parsing.
        /// Use ArgumentAttributes to control parsing behaviour.
        /// Formats the output to the width of the current console window.
        /// </summary>
        /// <param name="argumentType"> The type of the arguments to display usage for. </param>
        /// <returns> Printable string containing a user friendly description of command line arguments. </returns>
        public static string ArgumentsUsage(Type argumentType)
        {
            int screenWidth = Parser.GetConsoleWindowWidth();
            if (screenWidth == 0)
                screenWidth = 80;
            return ArgumentsUsage(argumentType, screenWidth);
        }

        /// <summary>
        /// Returns a Usage string for command line argument parsing.
        /// Use ArgumentAttributes to control parsing behaviour.
        /// </summary>
        /// <param name="argumentType"> The type of the arguments to display usage for. </param>
        /// <param name="columns"> The number of columns to format the output to. </param>
        /// <returns> Printable string containing a user friendly description of command line arguments. </returns>
        public static string ArgumentsUsage(Type argumentType, int columns)
        {
            return (new Parser(argumentType, null)).GetUsageString(columns);
        }

        private const int STD_OUTPUT_HANDLE = -11;

        private struct COORD
        {
            internal Int16 x;
            internal Int16 y;
        }

        private struct SMALL_RECT
        {
            internal Int16 Left;
            internal Int16 Top;
            internal Int16 Right;
            internal Int16 Bottom;
        }

        private struct CONSOLE_SCREEN_BUFFER_INFO
        {
            internal COORD dwSize;
            internal COORD dwCursorPosition;
            internal Int16 wAttributes;
            internal SMALL_RECT srWindow;
            internal COORD dwMaximumWindowSize;
        }

        [DllImport("kernel32.dll", EntryPoint = "GetStdHandle", SetLastError = true, CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        private static extern int GetStdHandle(int nStdHandle);

        [DllImport("kernel32.dll", EntryPoint = "GetConsoleScreenBufferInfo", SetLastError = true, CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        private static extern int GetConsoleScreenBufferInfo(int hConsoleOutput, ref CONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);

        /// <summary>
        /// Returns the number of columns in the current console window
        /// </summary>
        /// <returns>Returns the number of columns in the current console window</returns>
        public static int GetConsoleWindowWidth()
        {
            int screenWidth;
            CONSOLE_SCREEN_BUFFER_INFO csbi = new CONSOLE_SCREEN_BUFFER_INFO();

            int rc;
            rc = GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), ref csbi);
            screenWidth = csbi.dwSize.x;
            return screenWidth;
        }

        /// <summary>
        /// Searches a StringBuilder for a character
        /// </summary>
        /// <param name="text"> The text to search. </param>
        /// <param name="value"> The character value to search for. </param>
        /// <param name="startIndex"> The index to stat searching at. </param>
        /// <returns> The index of the first occurence of value or -1 if it is not found. </returns>
        public static int IndexOf(StringBuilder text, char value, int startIndex)
        {
            for (int index = startIndex; index < text.Length; index++)
            {
                if (text[index] == value)
                    return index;
            }

            return -1;
        }

        /// <summary>
        /// Searches a StringBuilder for a character in reverse
        /// </summary>
        /// <param name="text"> The text to search. </param>
        /// <param name="value"> The character to search for. </param>
        /// <param name="startIndex"> The index to start the search at. </param>
        /// <returns>The index of the last occurence of value in text or -1 if it is not found. </returns>
        public static int LastIndexOf(StringBuilder text, char value, int startIndex)
        {
            for (int index = Math.Min(startIndex, text.Length - 1); index >= 0; index--)
            {
                if (text[index] == value)
                    return index;
            }

            return -1;
        }

        private const int spaceBeforeParam = 2;

        /// <summary>
        /// Creates a new command line argument parser.
        /// </summary>
        /// <param name="argumentSpecification"> The type of object to  parse. </param>
        /// <param name="reporter"> The destination for parse errors. </param>
        public Parser(Type argumentSpecification, ErrorReporter reporter)
        {
            this.reporter = reporter;
            this.arguments = new ArrayList();
            this.argumentMap = new Hashtable();

            foreach (FieldInfo field in argumentSpecification.GetFields())
            {
                if (!field.IsStatic && !field.IsInitOnly && !field.IsLiteral)
                {
                    ArgumentAttribute attribute = GetAttribute(field);
                    if (attribute is DefaultArgumentAttribute)
                    {
                        Debug.Assert(this.defaultArgument == null);
                        this.defaultArgument = new Argument(attribute, field, reporter);
                    }
                    else
                    {
                        this.arguments.Add(new Argument(attribute, field, reporter));
                    }
                }
            }

            // add explicit names to map
            foreach (Argument argument in this.arguments)
            {
                Debug.Assert(!argumentMap.ContainsKey(argument.LongName));
                this.argumentMap[argument.LongName] = argument;
                if (argument.ExplicitShortName)
                {
                    if (argument.ShortName != null && argument.ShortName.Length > 0)
                    {
                        Debug.Assert(!argumentMap.ContainsKey(argument.ShortName));
                        this.argumentMap[argument.ShortName] = argument;
                    }
                    else
                    {
                        argument.ClearShortName();
                    }
                }
            }

            // add implicit names which don't collide to map
            foreach (Argument argument in this.arguments)
            {
                if (!argument.ExplicitShortName)
                {
                    if (argument.ShortName != null && argument.ShortName.Length > 0 && !argumentMap.ContainsKey(argument.ShortName))
                        this.argumentMap[argument.ShortName] = argument;
                    else
                        argument.ClearShortName();
                }
            }
        }

        private static ArgumentAttribute GetAttribute(FieldInfo field)
        {
            object[] attributes = field.GetCustomAttributes(typeof(ArgumentAttribute), false);
            if (attributes.Length == 1)
                return (ArgumentAttribute)attributes[0];

            Debug.Assert(attributes.Length == 0);
            return null;
        }

        private void ReportUnrecognizedArgument(string argument)
        {
            this.reporter(string.Format("Unrecognized command line argument '{0}'", argument));
        }

        /// <summary>
        /// Parses an argument list into an object
        /// </summary>
        /// <param name="args"></param>
        /// <param name="destination"></param>
        /// <returns> true if an error occurred </returns>
        private bool ParseArgumentList(string[] args, object destination)
        {
            bool hadError = false;
            if (args != null)
            {
                foreach (string argument in args)
                {
                    if (argument.Length > 0)
                    {
                        switch (argument[0])
                        {
                            case '-':
                            case '/':
                                int endIndex = argument.IndexOfAny(new char[] { ':', '+', '-' }, 1);
                                string option = argument.Substring(1, endIndex == -1 ? argument.Length - 1 : endIndex - 1);
                                string optionArgument;
                                if (option.Length + 1 == argument.Length)
                                {
                                    optionArgument = null;
                                }
                                else if (argument.Length > 1 + option.Length && argument[1 + option.Length] == ':')
                                {
                                    optionArgument = argument.Substring(option.Length + 2);
                                }
                                else
                                {
                                    optionArgument = argument.Substring(option.Length + 1);
                                }

                                Argument arg = (Argument)this.argumentMap[option];
                                if (arg == null)
                                {
                                    ReportUnrecognizedArgument(argument);
                                    hadError = true;
                                }
                                else
                                {
                                    hadError |= !arg.SetValue(optionArgument, destination);
                                }
                                break;
                            case '@':
                                string[] nestedArguments;
                                hadError |= LexFileArguments(argument.Substring(1), out nestedArguments);
                                hadError |= ParseArgumentList(nestedArguments, destination);
                                break;
                            default:
                                if (this.defaultArgument != null)
                                {
                                    hadError |= !this.defaultArgument.SetValue(argument, destination);
                                }
                                else
                                {
                                    ReportUnrecognizedArgument(argument);
                                    hadError = true;
                                }
                                break;
                        }
                    }
                }
            }

            return hadError;
        }

        /// <summary>
        /// Parses an argument list.
        /// </summary>
        /// <param name="args"> The arguments to parse. </param>
        /// <param name="destination"> The destination of the parsed arguments. </param>
        /// <returns> true if no parse errors were encountered. </returns>
        public bool Parse(string[] args, object destination)
        {
            bool hadError = ParseArgumentList(args, destination);

            // check for missing required arguments
            foreach (Argument arg in this.arguments)
            {
                hadError |= arg.Finish(destination);
            }
            if (this.defaultArgument != null)
            {
                hadError |= this.defaultArgument.Finish(destination);
            }

            return !hadError;
        }

        private struct ArgumentHelpStrings
        {
            public ArgumentHelpStrings(string syntax, string help)
            {
                this.syntax = syntax;
                this.help = help;
            }

            public string syntax;
            public string help;
        }

        /// <summary>
        /// A user firendly usage string describing the command line argument syntax.
        /// </summary>
        public string GetUsageString(int screenWidth)
        {
            ArgumentHelpStrings[] strings = GetAllHelpStrings();

            int maxParamLen = 0;
            foreach (ArgumentHelpStrings helpString in strings)
            {
                maxParamLen = Math.Max(maxParamLen, helpString.syntax.Length);
            }

            const int minimumNumberOfCharsForHelpText = 10;
            const int minimumHelpTextColumn = 5;
            const int minimumScreenWidth = minimumHelpTextColumn + minimumNumberOfCharsForHelpText;

            int helpTextColumn;
            int idealMinimumHelpTextColumn = maxParamLen + spaceBeforeParam;
            screenWidth = Math.Max(screenWidth, minimumScreenWidth);
            if (screenWidth < (idealMinimumHelpTextColumn + minimumNumberOfCharsForHelpText))
                helpTextColumn = minimumHelpTextColumn;
            else
                helpTextColumn = idealMinimumHelpTextColumn;

            const string newLine = "\n";
            StringBuilder builder = new StringBuilder();
            foreach (ArgumentHelpStrings helpStrings in strings)
            {
                // add syntax string
                int syntaxLength = helpStrings.syntax.Length;
                builder.Append(helpStrings.syntax);

                // start help text on new line if syntax string is too long
                int currentColumn = syntaxLength;
                if (syntaxLength >= helpTextColumn)
                {
                    builder.Append(newLine);
                    currentColumn = 0;
                }

                // add help text broken on spaces
                int charsPerLine = screenWidth - helpTextColumn;
                int index = 0;
                while (index < helpStrings.help.Length)
                {
                    // tab to start column
                    builder.Append(' ', helpTextColumn - currentColumn);
                    currentColumn = helpTextColumn;

                    // find number of chars to display on this line
                    int endIndex = index + charsPerLine;
                    if (endIndex >= helpStrings.help.Length)
                    {
                        // rest of text fits on this line
                        endIndex = helpStrings.help.Length;
                    }
                    else
                    {
                        endIndex = helpStrings.help.LastIndexOf(' ', endIndex - 1, Math.Min(endIndex - index, charsPerLine));
                        if (endIndex <= index)
                        {
                            // no spaces on this line, append full set of chars
                            endIndex = index + charsPerLine;
                        }
                    }

                    // add chars
                    builder.Append(helpStrings.help, index, endIndex - index);
                    index = endIndex;

                    // do new line
                    AddNewLine(newLine, builder, ref currentColumn);

                    // don't start a new line with spaces
                    while (index < helpStrings.help.Length && helpStrings.help[index] == ' ')
                        index++;
                }

                // add newline if there's no help text                
                if (helpStrings.help.Length == 0)
                {
                    builder.Append(newLine);
                }
            }

            return builder.ToString();
        }
        private static void AddNewLine(string newLine, StringBuilder builder, ref int currentColumn)
        {
            builder.Append(newLine);
            currentColumn = 0;
        }
        private ArgumentHelpStrings[] GetAllHelpStrings()
        {
            ArgumentHelpStrings[] strings = new ArgumentHelpStrings[NumberOfParametersToDisplay()];

            int index = 0;
            foreach (Argument arg in this.arguments)
            {
                strings[index] = GetHelpStrings(arg);
                index++;
            }
            strings[index++] = new ArgumentHelpStrings("@<file>", "Read response file for more options");
            if (this.defaultArgument != null)
                strings[index++] = GetHelpStrings(this.defaultArgument);

            return strings;
        }

        private static ArgumentHelpStrings GetHelpStrings(Argument arg)
        {
            return new ArgumentHelpStrings(arg.SyntaxHelp, arg.FullHelpText);
        }

        private int NumberOfParametersToDisplay()
        {
            int numberOfParameters = this.arguments.Count + 1;
            if (HasDefaultArgument)
                numberOfParameters += 1;
            return numberOfParameters;
        }

        /// <summary>
        /// Does this parser have a default argument.
        /// </summary>
        /// <value> Does this parser have a default argument. </value>
        public bool HasDefaultArgument
        {
            get { return this.defaultArgument != null; }
        }

        private bool LexFileArguments(string fileName, out string[] arguments)
        {
            string args = null;

            try
            {
                using (FileStream file = new FileStream(fileName, FileMode.Open, FileAccess.Read))
                {
                    args = (new StreamReader(file)).ReadToEnd();
                }
            }
            catch (Exception e)
            {
                this.reporter(string.Format("Error: Can't open command line argument file '{0}' : '{1}'", fileName, e.Message));
                arguments = null;
                return false;
            }

            bool hadError = false;
            ArrayList argArray = new ArrayList();
            StringBuilder currentArg = new StringBuilder();
            bool inQuotes = false;
            int index = 0;

            // while (index < args.Length)
            try
            {
                while (true)
                {
                    // skip whitespace
                    while (char.IsWhiteSpace(args[index]))
                    {
                        index += 1;
                    }

                    // # - comment to end of line
                    if (args[index] == '#')
                    {
                        index += 1;
                        while (args[index] != '\n')
                        {
                            index += 1;
                        }
                        continue;
                    }

                    // do one argument
                    do
                    {
                        if (args[index] == '\\')
                        {
                            int cSlashes = 1;
                            index += 1;
                            while (index == args.Length && args[index] == '\\')
                            {
                                cSlashes += 1;
                            }

                            if (index == args.Length || args[index] != '"')
                            {
                                currentArg.Append('\\', cSlashes);
                            }
                            else
                            {
                                currentArg.Append('\\', (cSlashes >> 1));
                                if (0 != (cSlashes & 1))
                                {
                                    currentArg.Append('"');
                                }
                                else
                                {
                                    inQuotes = !inQuotes;
                                }
                            }
                        }
                        else if (args[index] == '"')
                        {
                            inQuotes = !inQuotes;
                            index += 1;
                        }
                        else
                        {
                            currentArg.Append(args[index]);
                            index += 1;
                        }
                    } while (!char.IsWhiteSpace(args[index]) || inQuotes);
                    argArray.Add(currentArg.ToString());
                    currentArg.Length = 0;
                }
            }
            catch (System.IndexOutOfRangeException)
            {
                // got EOF 
                if (inQuotes)
                {
                    this.reporter(string.Format("Error: Unbalanced '\"' in command line argument file '{0}'", fileName));
                    hadError = true;
                }
                else if (currentArg.Length > 0)
                {
                    // valid argument can be terminated by EOF
                    argArray.Add(currentArg.ToString());
                }
            }

            arguments = (string[])argArray.ToArray(typeof(string));
            return hadError;
        }

        private static string LongName(ArgumentAttribute attribute, FieldInfo field)
        {
            return (attribute == null || attribute.DefaultLongName) ? field.Name : attribute.LongName;
        }

        private static string ShortName(ArgumentAttribute attribute, FieldInfo field)
        {
            if (attribute is DefaultArgumentAttribute)
                return null;
            if (!ExplicitShortName(attribute))
                return LongName(attribute, field).Substring(0, 1);
            return attribute.ShortName;
        }

        private static string HelpText(ArgumentAttribute attribute, FieldInfo field)
        {
            if (attribute == null)
                return null;
            else
                return attribute.HelpText;
        }

        private static bool HasHelpText(ArgumentAttribute attribute)
        {
            return (attribute != null && attribute.HasHelpText);
        }

        private static bool ExplicitShortName(ArgumentAttribute attribute)
        {
            return (attribute != null && !attribute.DefaultShortName);
        }

        private static object DefaultValue(ArgumentAttribute attribute, FieldInfo field)
        {
            return (attribute == null || !attribute.HasDefaultValue) ? null : attribute.DefaultValue;
        }

        private static Type ElementType(FieldInfo field)
        {
            if (IsCollectionType(field.FieldType))
                return field.FieldType.GetElementType();
            else
                return null;
        }

        private static ArgumentType Flags(ArgumentAttribute attribute, FieldInfo field)
        {
            if (attribute != null)
                return attribute.Type;
            else if (IsCollectionType(field.FieldType))
                return ArgumentType.MultipleUnique;
            else
                return ArgumentType.AtMostOnce;
        }

        private static bool IsCollectionType(Type type)
        {
            return type.IsArray;
        }

        private static bool IsValidElementType(Type type)
        {
            return type != null && (
                type == typeof(int) ||
                type == typeof(uint) ||
                type == typeof(string) ||
                type == typeof(bool) ||
                type.IsEnum);
        }

        [System.Diagnostics.DebuggerDisplay("Name = {LongName}")]
        private class Argument
        {
            public Argument(ArgumentAttribute attribute, FieldInfo field, ErrorReporter reporter)
            {
                this.longName = Parser.LongName(attribute, field);
                this.explicitShortName = Parser.ExplicitShortName(attribute);
                this.shortName = Parser.ShortName(attribute, field);
                this.hasHelpText = Parser.HasHelpText(attribute);
                this.helpText = Parser.HelpText(attribute, field);
                this.defaultValue = Parser.DefaultValue(attribute, field);
                this.elementType = ElementType(field);
                this.flags = Flags(attribute, field);
                this.field = field;
                this.seenValue = false;
                this.reporter = reporter;
                this.isDefault = attribute != null && attribute is DefaultArgumentAttribute;

                if (IsCollection)
                {
                    this.collectionValues = new ArrayList();
                }

                Debug.Assert(this.longName != null && this.longName != "");
                Debug.Assert(!this.isDefault || !this.ExplicitShortName);
                Debug.Assert(!IsCollection || AllowMultiple, "Collection arguments must have allow multiple");
                Debug.Assert(!Unique || IsCollection, "Unique only applicable to collection arguments");
                Debug.Assert(IsValidElementType(Type) ||
                    IsCollectionType(Type));
                Debug.Assert((IsCollection && IsValidElementType(elementType)) ||
                    (!IsCollection && elementType == null));
                Debug.Assert(!(this.IsRequired && this.HasDefaultValue), "Required arguments cannot have default value");
                Debug.Assert(!this.HasDefaultValue || (this.defaultValue.GetType() == field.FieldType), "Type of default value must match field type");
            }

            public bool Finish(object destination)
            {
                if (this.SeenValue)
                {
                    if (this.IsCollection)
                    {
                        this.field.SetValue(destination, this.collectionValues.ToArray(this.elementType));
                    }
                }
                else
                {
                    if (this.HasDefaultValue)
                    {
                        this.field.SetValue(destination, this.DefaultValue);
                    }
                }

                return ReportMissingRequiredArgument();
            }

            private bool ReportMissingRequiredArgument()
            {
                if (this.IsRequired && !this.SeenValue)
                {
                    if (this.IsDefault)
                        reporter(string.Format("Missing required argument '<{0}>'.", this.LongName));
                    else
                        reporter(string.Format("Missing required argument '/{0}'.", this.LongName));
                    return true;
                }
                return false;
            }

            private void ReportDuplicateArgumentValue(string value)
            {
                this.reporter(string.Format("Duplicate '{0}' argument '{1}'", this.LongName, value));
            }

            public bool SetValue(string value, object destination)
            {
                if (SeenValue && !AllowMultiple)
                {
                    this.reporter(string.Format("Duplicate '{0}' argument", this.LongName));
                    return false;
                }
                this.seenValue = true;

                object newValue;
                if (!ParseValue(this.ValueType, value, out newValue))
                    return false;
                if (this.IsCollection)
                {
                    if (this.Unique && this.collectionValues.Contains(newValue))
                    {
                        ReportDuplicateArgumentValue(value);
                        return false;
                    }
                    else
                    {
                        this.collectionValues.Add(newValue);
                    }
                }
                else
                {
                    this.field.SetValue(destination, newValue);
                }

                return true;
            }

            public Type ValueType
            {
                get { return this.IsCollection ? this.elementType : this.Type; }
            }

            private void ReportBadArgumentValue(string value)
            {
                this.reporter(string.Format("'{0}' is not a valid value for the '{1}' command line option", value, this.LongName));
            }

            private bool ParseValue(Type type, string stringData, out object value)
            {
                // null is only valid for bool variables
                // empty string is never valid
                if ((stringData != null || type == typeof(bool)) && (stringData == null || stringData.Length > 0))
                {
                    try
                    {
                        if (type == typeof(string))
                        {
                            value = stringData;
                            return true;
                        }
                        else if (type == typeof(bool))
                        {
                            if (stringData == null || stringData == "+")
                            {
                                value = true;
                                return true;
                            }
                            else if (stringData == "-")
                            {
                                value = false;
                                return true;
                            }
                        }
                        else if (type == typeof(int))
                        {
                            value = int.Parse(stringData);
                            return true;
                        }
                        else if (type == typeof(uint))
                        {
                            value = int.Parse(stringData);
                            return true;
                        }
                        else
                        {
                            Debug.Assert(type.IsEnum);

                            bool valid = false;
                            foreach (string name in Enum.GetNames(type))
                            {
                                if (name == stringData)
                                {
                                    valid = true;
                                    break;
                                }
                            }
                            if (valid)
                            {
                                value = Enum.Parse(type, stringData, true);
                                return true;
                            }
                        }
                    }
                    catch
                    {
                        // catch parse errors
                    }
                }

                ReportBadArgumentValue(stringData);
                value = null;
                return false;
            }

            private void AppendValue(StringBuilder builder, object value)
            {
                if (value is string || value is int || value is uint || value.GetType().IsEnum)
                {
                    builder.Append(value.ToString());
                }
                else if (value is bool)
                {
                    builder.Append((bool)value ? "+" : "-");
                }
                else
                {
                    bool first = true;
                    foreach (object o in (System.Array)value)
                    {
                        if (!first)
                        {
                            builder.Append(", ");
                        }
                        AppendValue(builder, o);
                        first = false;
                    }
                }
            }

            public string LongName
            {
                get { return this.longName; }
            }

            public bool ExplicitShortName
            {
                get { return this.explicitShortName; }
            }

            public string ShortName
            {
                get { return this.shortName; }
            }

            public bool HasShortName
            {
                get { return this.shortName != null; }
            }

            public void ClearShortName()
            {
                this.shortName = null;
            }

            public bool HasHelpText
            {
                get { return this.hasHelpText; }
            }

            public string HelpText
            {
                get { return this.helpText; }
            }

            public object DefaultValue
            {
                get { return this.defaultValue; }
            }

            public bool HasDefaultValue
            {
                get { return null != this.defaultValue; }
            }

            public string FullHelpText
            {
                get
                {
                    StringBuilder builder = new StringBuilder();
                    if (this.HasHelpText)
                    {
                        builder.Append(this.HelpText);
                    }
                    if (this.HasDefaultValue)
                    {
                        if (builder.Length > 0)
                            builder.Append(" ");
                        builder.Append("Default value:'");
                        AppendValue(builder, this.DefaultValue);
                        builder.Append('\'');
                    }
                    if (this.HasShortName)
                    {
                        if (builder.Length > 0)
                            builder.Append(" ");
                        builder.Append("(short form /");
                        builder.Append(this.ShortName);
                        builder.Append(")");
                    }
                    return builder.ToString();
                }
            }

            public string SyntaxHelp
            {
                get
                {
                    StringBuilder builder = new StringBuilder();

                    if (this.IsDefault)
                    {
                        builder.Append("<");
                        builder.Append(this.LongName);
                        builder.Append(">");
                    }
                    else
                    {
                        builder.Append("/");
                        builder.Append(this.LongName);
                        Type valueType = this.ValueType;
                        if (valueType == typeof(int))
                        {
                            builder.Append(":<int>");
                        }
                        else if (valueType == typeof(uint))
                        {
                            builder.Append(":<uint>");
                        }
                        else if (valueType == typeof(bool))
                        {
                            builder.Append("[+|-]");
                        }
                        else if (valueType == typeof(string))
                        {
                            builder.Append(":<string>");
                        }
                        else
                        {
                            Debug.Assert(valueType.IsEnum);

                            builder.Append(":{");
                            bool first = true;
                            foreach (FieldInfo field in valueType.GetFields())
                            {
                                if (field.IsStatic)
                                {
                                    if (first)
                                        first = false;
                                    else
                                        builder.Append('|');
                                    builder.Append(field.Name);
                                }
                            }
                            builder.Append('}');
                        }
                    }

                    return builder.ToString();
                }
            }

            public bool IsRequired
            {
                get { return 0 != (this.flags & ArgumentType.Required); }
            }

            public bool SeenValue
            {
                get { return this.seenValue; }
            }

            public bool AllowMultiple
            {
                get { return 0 != (this.flags & ArgumentType.Multiple); }
            }

            public bool Unique
            {
                get { return 0 != (this.flags & ArgumentType.Unique); }
            }

            public Type Type
            {
                get { return field.FieldType; }
            }

            public bool IsCollection
            {
                get { return IsCollectionType(Type); }
            }

            public bool IsDefault
            {
                get { return this.isDefault; }
            }

            private string longName;
            private string shortName;
            private string helpText;
            private bool hasHelpText;
            private bool explicitShortName;
            private object defaultValue;
            private bool seenValue;
            private FieldInfo field;
            private Type elementType;
            private ArgumentType flags;
            private ArrayList collectionValues;
            private ErrorReporter reporter;
            private bool isDefault;
        }

        private ArrayList arguments;
        private Hashtable argumentMap;
        private Argument defaultArgument;
        private ErrorReporter reporter;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\CommonLib\ThreadPoolEx.cs ===
#region Using Directives

using System;
using System.Collections;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.Threading;

#endregion

namespace LiveN.Test.Common
{
	#region Public Delegates

	public delegate void ThreadPoolCallback(int threadId);

	#endregion

	#region ThreadPoolEx Class
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Summary description for ThreadPoolEx.
	/// </summary>
	public static class ThreadPoolEx
	{
		#region Variable Declarations

		private static Dictionary<int, ThreadInfo> threads = new Dictionary<int, ThreadInfo>(500);
		private static Queue<ThreadInfo> waitingThreads = new Queue<ThreadInfo>(500);
		private static int maxThreads = 200;
		private static int currentThreads = 0;

		#endregion

		#region Public Properties
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public static int MaxThreads
		{
			get
			{
				return maxThreads;
			}
			set
			{
				Interlocked.Exchange(ref maxThreads, value);
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public static int ActiveThreads
		{
			get
			{
				return currentThreads;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public static int QueuedThreads
		{
			get
			{
				return waitingThreads.Count;
			}
		}
		#endregion

		#region Public Methods
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="method"></param>
		/// <param name="parameters"></param>
		/// <param name="callback"></param>
		/// <param name="state"></param>
		/// <returns></returns>
		public static int StartThread(Delegate method, object[] parameters, Delegate callback, object[] state)
		{
			return _StartThread(ThreadPriority.Normal, false, method, parameters, callback, state);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="priority"></param>
		/// <param name="isBackground"></param>
		/// <param name="method"></param>
		/// <param name="parameters"></param>
		/// <param name="callback"></param>
		/// <param name="state"></param>
		/// <returns></returns>
		public static int StartThread(ThreadPriority priority, bool isBackground, Delegate method, object[] parameters, Delegate callback, object[] state)
		{
			return _StartThread(priority, isBackground, method, parameters, callback, state);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="priority"></param>
		/// <param name="isBackground"></param>
		/// <param name="method"></param>
		/// <param name="parameters"></param>
		/// <param name="callback"></param>
		/// <param name="state"></param>
		/// <returns></returns>
		public static int StartThread(ThreadPriority priority, bool isBackground, Delegate method, object[] parameters, ThreadPoolCallback callback)
		{
			return _StartThread(priority, isBackground, method, parameters, callback, null);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="priority"></param>
		/// <param name="isBackground"></param>
		/// <param name="method"></param>
		/// <param name="parameters"></param>
		/// <returns></returns>
		public static int StartThread(ThreadPriority priority, bool isBackground, Delegate method, object[] parameters)
		{
			return _StartThread(priority, isBackground, method, parameters, null, null);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="method"></param>
		/// <param name="parameters"></param>
		/// <returns></returns>
		public static int StartThread(Delegate method, object[] parameters)
		{
			return _StartThread(ThreadPriority.Normal, false, method, parameters, null, null);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="method"></param>
		/// <param name="parameters"></param>
		/// <param name="startTime"></param>
		/// <param name="repeatTime"></param>
		/// <returns></returns>
		public static int StartTimer(Delegate method, object[] parameters, int startTime, int repeatTime)
		{
			return _StartTimer(method, parameters, startTime, repeatTime);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="threadId"></param>
		public static void StopThread(int threadId)
		{
			if(threads.ContainsKey(threadId))
			{
				ThreadInfo info = threads[threadId];
				
				if((info.WorkerThread != null) && info.WorkerThread.IsAlive)
				{
					info.WorkerThread.Abort();
				}
			}

			lock (((IDictionary)threads).SyncRoot)
			{
				threads.Remove(threadId);
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="threadId"></param>
		/// <returns></returns>
		public static object GetThreadResult(int threadId)
		{
			object[] parameters;
			return GetThreadResult(threadId, out parameters);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="threadId"></param>
		/// <param name="parameters"></param>
		/// <returns></returns>
		public static object GetThreadResult(int threadId, out object[] parameters)
		{
			parameters = null;

			if(threads.ContainsKey(threadId))
			{
				ThreadInfo thread = threads[threadId];

				//if the thread threw an exception, throw is back to the client
				if((thread.MethodReturnValue != null) && (thread.MethodReturnValue.GetType().IsSubclassOf(typeof(Exception))))
				{
					throw new ThreadException(thread.MethodReturnValue as Exception);
				}

				if(thread.MethodParameters != null)
				{
					parameters = (object[])thread.MethodParameters.Clone();
				}

				return thread.MethodReturnValue;
			}

			return null;
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="threadId"></param>
		/// <returns></returns>
		public static object WaitForThread(int threadId)
		{
			return WaitForThread(threadId, 0);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="threadId"></param>
		/// <returns></returns>
		public static object WaitForThread(int threadId, int timeout)
		{
			if(threads.ContainsKey(threadId))
			{
				ThreadInfo info = threads[threadId];
				if((info.WorkerThread != null) && !info.IsCompleted)
				{
					if (timeout <= 0)
					{
						info.WorkerThread.Join();
					}
					else
					{
						info.WorkerThread.Join(timeout);
					}
				}

				lock (((IDictionary)threads).SyncRoot)
				{
					threads.Remove(threadId);
				}

				return info.MethodReturnValue;
			}

			return null;
		}

		/// <summary>
		/// 
		/// </summary>
		public static void WaitForAllThreads()
		{
			WaitForAllThreads(0);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public static void WaitForAllThreads(int timeout)
		{
			List<ThreadInfo> queuedThreads = new List<ThreadInfo>();
			ThreadInfo[] infos = new ThreadInfo[threads.Values.Count];

			threads.Values.CopyTo(infos, 0);
			foreach(ThreadInfo info in infos)
			{
				if(info.WorkerThread != null)
				{
					if(info.WorkerThread.IsAlive && !info.IsCompleted)
					{
						if (timeout <= 0)
						{
							info.WorkerThread.Join();
						}
						else
						{
							info.WorkerThread.Join(timeout);
						}
					}
					else	//queued up thread that hasn't started yet..
					{
						queuedThreads.Add(info);
					}
				}
			}

			//now wait for any queued threads...
			foreach(ThreadInfo info in queuedThreads)
			{
				if(info.WorkerThread != null)
				{
					if(info.WorkerThread.IsAlive && !info.IsCompleted)
					{
						if (timeout <= 0)
						{
							info.WorkerThread.Join();
						}
						else
						{
							info.WorkerThread.Join(timeout);
						}
					}
				}
			}

			lock (((IDictionary)threads).SyncRoot)
			{
				threads.Clear();
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public static void StopAllThreads()
		{
			lock (((IDictionary)threads).SyncRoot)
			{
				foreach(ThreadInfo info in threads.Values)
				{
					if((info.WorkerThread != null) && info.WorkerThread.IsAlive)
					{
						info.WorkerThread.Abort();
					}
				}

				threads.Clear();
			}

			Interlocked.Exchange(ref currentThreads, 0);
		}
		#endregion

		#region Private Methods
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="priority"></param>
		/// <param name="isBackground"></param>
		/// <param name="method"></param>
		/// <param name="parameters"></param>
		/// <param name="callback"></param>
		/// <param name="state"></param>
		/// <returns></returns>
		private static int _StartThread(ThreadPriority priority, bool isBackground, Delegate method, object[] parameters, Delegate callback, object[] state)
		{
			Thread t = new Thread(new ThreadStart(RunThread));
			int threadId = t.GetHashCode();

			t.Priority = priority;
			t.IsBackground = isBackground;

			ThreadInfo info = new ThreadInfo(t, method, parameters, callback, state);

			lock (((IDictionary)threads).SyncRoot)
			{
				threads.Add(threadId, info);
			}
			
			if(currentThreads < maxThreads)
			{
				t.Start();
				Interlocked.Increment(ref currentThreads);
			}
			else
			{
				lock (((ICollection)waitingThreads).SyncRoot)
				{
					waitingThreads.Enqueue(info);
				}
			}
			
			return threadId;
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		private static void RunThread()
		{
			try
			{
				int threadId = Thread.CurrentThread.GetHashCode();
				ThreadInfo info = threads[threadId];

				try
				{
					info.MethodReturnValue = info.Method.DynamicInvoke(info.MethodParameters);
				}
				catch(Exception e)
				{
					if(e.InnerException != null)
					{
						info.MethodReturnValue = e.InnerException;
					}
					else
					{
						info.MethodReturnValue = e;
					}
				}
				finally
				{
					info.IsCompleted = true;

					lock (((IDictionary)threads).SyncRoot)
					{
						threads[threadId] = info;
					}
					
					if(info.Callback != null)
					{
						if(info.Callback.GetType() == typeof(ThreadPoolCallback))
						{
							info.CallbackReturnValue = info.Callback.DynamicInvoke(new object[]{info.WorkerThread.GetHashCode()});
						}
						else
						{
							info.CallbackReturnValue = info.Callback.DynamicInvoke(info.CallbackState);
						}
					}
				}

				if(waitingThreads.Count > 0)
				{
					ThreadInfo newThread;

					lock (((ICollection)waitingThreads).SyncRoot)
					{
						newThread = waitingThreads.Dequeue();
					}

					newThread.WorkerThread.Start();
					Interlocked.Increment(ref currentThreads);
				}
			}
			finally
			{
				Interlocked.Decrement(ref currentThreads);
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="method"></param>
		/// <param name="parameters"></param>
		/// <param name="startTime"></param>
		/// <param name="repeatTime"></param>
		/// <returns></returns>
		private static int _StartTimer(Delegate method, object[] parameters, int startTime, int repeatTime)
		{
			Thread t = new Thread(new ThreadStart(RunTimerThread));
			int threadId = t.GetHashCode();

			t.Priority = ThreadPriority.Normal;
			t.IsBackground = false;

			ThreadInfo info = new ThreadInfo(t, method, parameters, startTime, repeatTime);

			lock (((IDictionary)threads).SyncRoot)
			{
				threads.Add(threadId, info);
			}
			
			if(currentThreads < maxThreads)
			{
				t.Start();
				Interlocked.Increment(ref currentThreads);
			}
			else
			{
				lock (((ICollection)waitingThreads).SyncRoot)
				{
					waitingThreads.Enqueue(info);
				}
			}
			
			return threadId;
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		private static void RunTimerThread()
		{
			int threadId = Thread.CurrentThread.GetHashCode();
			ThreadInfo info = threads[threadId];

			Thread.Sleep(info.StartTime);
			RunThread();

			while(true)
			{
				Thread.Sleep(info.RepeatTime);
				RunThread();
			}
		}
		#endregion
	}
	#endregion

	#region ThreadInfo Class
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// 
	/// </summary>
	internal class ThreadInfo
	{
		#region Variable Declarations

		private Thread thread;
		private Delegate method;
		private object[] parameters;
		private object methodReturnValue;
		private Delegate callback;
		private object[] state;
		private object callbackReturnValue;
		private bool isCompleted = false;
		private int startTime = 0;
		private int repeatTime = 0;

		#endregion

		#region Constructors
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public ThreadInfo()
		{

		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="thread"></param>
		/// <param name="method"></param>
		/// <param name="parameters"></param>
		/// <param name="callBack"></param>
		/// <param name="state"></param>
		public ThreadInfo(Thread thread, Delegate method, object[] parameters, Delegate callBack, object[] state)
		{
			this.thread = thread;
			this.method = method;
			this.parameters = parameters;
			this.callback = callBack;
			this.state = state;
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="thread"></param>
		/// <param name="method"></param>
		/// <param name="parameters"></param>
		/// <param name="startTime"></param>
		/// <param name="repeatTime"></param>
		public ThreadInfo(Thread thread, Delegate method, object[] parameters, int startTime, int repeatTime)
		{
			this.thread = thread;
			this.method = method;
			this.parameters = parameters;
			this.startTime = startTime;
			this.repeatTime = repeatTime;
		}
		#endregion

		#region Public Properties
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public Thread WorkerThread
		{
			get
			{
				return this.thread;
			}
			set
			{
				this.thread = value;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public Delegate Method
		{
			get
			{
				return this.method;
			}
			set
			{
				this.method = value;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public object[] MethodParameters
		{
			get
			{
				return this.parameters;
			}
			set
			{
				this.parameters = value;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public object MethodReturnValue
		{
			get
			{
				return this.methodReturnValue;
			}
			set
			{
				this.methodReturnValue = value;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public Delegate Callback
		{
			get
			{
				return this.callback;
			}
			set
			{
				this.callback = value;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public object[] CallbackState
		{
			get
			{
				return this.state;
			}
			set
			{
				this.state = value;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public object CallbackReturnValue
		{
			get
			{
				return this.callbackReturnValue;
			}
			set
			{
				this.callbackReturnValue = value;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public bool IsCompleted
		{
			get
			{
				return this.isCompleted;
			}
			set
			{
				this.isCompleted = value;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public int StartTime
		{
			get
			{
				return this.startTime;
			}
			set
			{
				this.startTime = value;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public int RepeatTime
		{
			get
			{
				return this.repeatTime;
			}
			set
			{
				this.repeatTime = value;
			}
		}
		#endregion
	}
	#endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\CommonLib\Forms\ErrorBox.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Text;
using System.Windows.Forms;

namespace LiveN.Test.Common.Forms
{
	public partial class ErrorBox : Form
	{
		/// <summary>
		/// 
		/// </summary>
		/// <param name="e"></param>
		/// <param name="message"></param>
		public ErrorBox(Exception e, string caption, string message)
		{
			InitializeComponent();

			this.Height = 146;
			this.errorIcon.Image = SystemIcons.Error.ToBitmap();
			this.Text = caption;
			this.errorMessage.Text = String.Format("{0}  {1}", message, e.Message);
			this.innerException.Text = e.ToString();
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void ok_Click(object sender, EventArgs e)
		{
			this.Close();
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void showInnerException_Click(object sender, EventArgs e)
		{
			if (this.Height == 279)
			{
				this.Height = 146;
			}
			else
			{
				this.Height = 279;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\CommonLib\XmlDocumentEx.cs ===
using System;
using System.Xml;
using System.IO;
using System.Text;
using System.Security;
using System.Collections.Specialized;

namespace LiveN.Test.Common
{
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	public class XmlDocumentEx: XmlDocument
	{
		protected XmlNamespaceManager nsmgr;
		protected bool hasNamespaces = false;
		protected NameValueCollection defaultNamespaces = new NameValueCollection();
		protected bool useCdata = false;

		/// <summary>
		/// 
		/// </summary>
		public const string DefaultNamespacePrefix = "dfltns";

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public XmlDocumentEx(): base()
		{
			InternalContructor(null, null, null, false);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xml"></param>
		public XmlDocumentEx(string xml): base()
		{
			InternalContructor(xml, null, null, false);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xml"></param>
		/// <param name="loadNamespaces"></param>
		public XmlDocumentEx(string xml, bool loadNamespaces): base()
		{
			InternalContructor(xml, null, null, loadNamespaces);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xml"></param>
		public XmlDocumentEx(Stream xml): base()
		{
			InternalContructor(null, xml, null, false);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xml"></param>
		/// <param name="loadNamespaces"></param>
		public XmlDocumentEx(Stream xml, bool loadNamespaces): base()
		{
			InternalContructor(null, xml, null, loadNamespaces);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xml"></param>
		public XmlDocumentEx(XmlDocument xml): base()
		{
			InternalContructor(null, null, xml, false);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xml"></param>
		/// <param name="loadNamespaces"></param>
		public XmlDocumentEx(XmlDocument xml, bool loadNamespaces): base()
		{
			InternalContructor(null, null, xml, loadNamespaces);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public XmlNamespaceManager NamespaceManager
		{
			get
			{
				return this.nsmgr;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public bool HasNamespaces
		{
			get
			{
				return this.hasNamespaces;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public NameValueCollection DefaultNamespaces
		{
			get
			{
				return this.defaultNamespaces;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public bool UseCdata
		{
			get
			{
				return this.useCdata;
			}
			set
			{
				this.useCdata = value;

				if(this.DocumentElement !=  null)
				{
					UpdateCdataInXml(this.DocumentElement, value);
				}
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="filename"></param>
		/// <param name="loadNamespaces"></param>
		public void Load(string filename, bool loadNamespaces)
		{
			base.Load(filename);

			if(loadNamespaces)
			{
				LoadNamespaces();
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <returns></returns>
		public string FormatXml()
		{
			return FormatXml(Encoding.UTF8, 1, '\t', '"');
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="indentation"></param>
		/// <param name="indentChar"></param>
		/// <param name="quoteChar"></param>
		/// <returns></returns>
		public string FormatXml(int indentation, char indentChar, char quoteChar)
		{
			return FormatXml(Encoding.UTF8, indentation, indentChar, quoteChar);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="encoding"></param>
		/// <param name="indentation"></param>
		/// <param name="indentChar"></param>
		/// <param name="quoteChar"></param>
		/// <returns></returns>
		public string FormatXml(Encoding encoding, int indentation, char indentChar, char quoteChar)
		{
			MemoryStream memoryStream = new MemoryStream();
			XmlTextWriter xmlWriter = null;
			string formattedXml;

			try
			{
				xmlWriter = new XmlTextWriter(memoryStream, encoding);
				xmlWriter.Formatting = Formatting.Indented;
				xmlWriter.Indentation = indentation;
				xmlWriter.IndentChar = indentChar;
				xmlWriter.QuoteChar = quoteChar;
				xmlWriter.Namespaces = (this.hasNamespaces) ? true : false;
				
				this.WriteTo(xmlWriter);
				xmlWriter.Flush();
				
				memoryStream.Seek(0, SeekOrigin.Begin);
				StreamReader reader = new StreamReader(memoryStream, encoding);
				formattedXml = reader.ReadToEnd();
			}
			finally
			{
				if(xmlWriter != null)
				{
					xmlWriter.Close();
				}
			}

			return formattedXml;
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <returns></returns>
		public string Escape()
		{
			return EscapeXml(this.OuterXml);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <returns></returns>
		public string Unescape()
		{
			return UnescapeXml(this.OuterXml);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public void LoadNamespaces()
		{
			FindNamespaces(this.DocumentElement);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xpath"></param>
		/// <returns></returns>
		public string GetNodeValue(string xpath)
		{
			XmlNode temp = this.SelectSingleNode(xpath, this.nsmgr);

			if(temp != null)
			{
				return temp.InnerText;
			}
			
			throw new NullReferenceException("Unable to get the value for the node; the specified xpath '" + xpath + "' returned a null value."); 
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xpath"></param>
		/// <param name="value"></param>
		public void SetNodeValue(string xpath, string value)
		{
			XmlNode temp = this.SelectSingleNode(xpath, this.nsmgr);

			if(temp != null)
			{
				temp.InnerText = value;
			}
			else
			{
				throw new NullReferenceException("Unable to set the value for the node; the specified xpath '" + xpath + "' returned a null value."); 
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xpath"></param>
		/// <returns></returns>
		public bool DoesNodeExist(string xpath)
		{
			XmlNode temp;

			return DoesNodeExist(xpath, out temp);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xpath"></param>
		/// <param name="node"></param>
		/// <returns></returns>
		public bool DoesNodeExist(string xpath, out XmlNode node)
		{
			node = this.SelectSingleNode(xpath, this.nsmgr);
			
			return (node != null) ? true : false;
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xml"></param>
		/// <returns></returns>
		public static string EscapeXml(string xml)
		{
			if((xml != null) && (xml.Length > 0))
			{
				return SecurityElement.Escape(xml);
			}

			return String.Empty;
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xml"></param>
		/// <returns></returns>
		public static string UnescapeXml(string xml)
		{
			if((xml != null) && (xml.Length > 0))
			{
				string temp = xml;

				temp = temp.Replace("&lt;", "<");
				temp = temp.Replace("&gt;", ">");
				temp = temp.Replace("&amp;", "&");
				temp = temp.Replace("&apos;", "'");
				temp = temp.Replace("&quot;", "\"");

				return temp;
			}

			return String.Empty;
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="oldPrefix"></param>
		/// <param name="newPrefix"></param>
		public void UpdatePrefix(string oldPrefix, string newPrefix)
		{
			UpdatePrefix(this.DocumentElement, oldPrefix, newPrefix);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="root"></param>
		private void FindNamespaces(XmlNode root)
		{
			if (root == null)
			{
				return;
			}

			if(root.Attributes != null)
			{
				foreach(XmlAttribute attribute in root.Attributes)
				{
					if((String.Compare(attribute.Prefix, "xmlns", true) == 0) || (String.Compare(attribute.LocalName, "xmlns", true) == 0))
					{
						if(attribute.Prefix.Length > 0)	//regular namespace
						{
							if(!this.nsmgr.HasNamespace(attribute.LocalName))
							{
								this.nsmgr.AddNamespace(attribute.LocalName, attribute.Value);
							}
						}
						else							//default namespace; xpath REQUIRES that it be given a 'dummy' prefix!
						{
							if(!this.nsmgr.HasNamespace(DefaultNamespacePrefix))
							{
								this.defaultNamespaces.Add(attribute.OwnerElement.LocalName, DefaultNamespacePrefix);
								this.nsmgr.AddNamespace(attribute.Prefix, attribute.Value);
								this.nsmgr.AddNamespace(DefaultNamespacePrefix, attribute.Value);
							}
							else
							{
								string newPrefix = attribute.OwnerElement.LocalName.ToLower() + DefaultNamespacePrefix;
								this.defaultNamespaces.Add(attribute.OwnerElement.LocalName, newPrefix);
								this.nsmgr.AddNamespace(newPrefix, attribute.Value);
							}
						}

						this.hasNamespaces = true;
					}
				}
			}
			
			foreach(XmlNode child in root.ChildNodes)
			{
				FindNamespaces(child);
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="root"></param>
		/// <param name="useCata"></param>
		private void UpdateCdataInXml(XmlNode root, bool useCata)
		{
			if(root.NodeType == XmlNodeType.Text)
			{
				if(useCdata)
				{
					root.ParentNode.InnerXml = "<![CDATA[" + root.Value + "]]>";
				}
			}
			else if (root.NodeType == XmlNodeType.Element && !root.HasChildNodes)
			{
				if (useCata)
				{
					root.InnerXml = "<![CDATA[" + root.Value + "]]>";
				}
			}
			else if (root.NodeType == XmlNodeType.CDATA)
			{
				if (!useCdata)
				{
					root.ParentNode.InnerXml = root.Value;
				}
			}
			else if (root.HasChildNodes)
			{
				foreach (XmlNode child in root.ChildNodes)
				{
					UpdateCdataInXml(child, useCdata);
				}
			}
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="root"></param>
		/// <param name="oldPrefix"></param>
		/// <param name="newPrefix"></param>
		private void UpdatePrefix(XmlNode root, string oldPrefix, string newPrefix)
		{
			if ((root.Attributes != null) && (root.Attributes.Count > 0))
			{
				XmlAttribute prefixAttribute = root.Attributes[String.Format("xmlns:{0}", oldPrefix)];

				if (prefixAttribute != null)
				{
					//update the old prefix definition to the new name
					string namespaceValue = prefixAttribute.Value;
					root.Attributes.Remove(prefixAttribute);
					XmlAttribute newPrefixAttribute = root.OwnerDocument.CreateAttribute(String.Format("xmlns:{0}", newPrefix), prefixAttribute.NamespaceURI);
					newPrefixAttribute.Value = namespaceValue;
					root.Attributes.Append(newPrefixAttribute);
				}
			}

			if (root.Prefix == oldPrefix)
			{
				root.Prefix = newPrefix;
			}

			foreach (XmlNode child in root.ChildNodes)
			{
				if (child.NodeType == XmlNodeType.Element)
				{
					//only elements can have prefixes/attributes
					UpdatePrefix(child, oldPrefix, newPrefix);
				}
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="xml"></param>
		/// <param name="xmlStream"></param>
		/// <param name="loadNamespaces"></param>
		private void InternalContructor(string xml, Stream xmlStream, XmlNode xmlNode, bool loadNamespaces)
		{
			this.nsmgr = new XmlNamespaceManager(this.NameTable);

			if((xml != null) && (xml.Length > 0))
			{
				this.LoadXml(xml);
			}
			else if((xmlStream != null) && (xmlStream.Length > 0))
			{
				this.Load(xmlStream);
			}
			else if(xmlNode != null)
			{
				this.LoadXml(xmlNode.OuterXml);
			}

			if(loadNamespaces)
			{
				this.LoadNamespaces();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\CommonLib\Extensions.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Reflection;
using System.ServiceModel;
using System.Text;

namespace LiveN.Test.Common
{
    /// <summary>
    /// 
    /// </summary>
    public static class Extensions
    {
        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="member"></param>
        /// <returns></returns>
        public static List<T> GetCustomAttributes<T>(this MemberInfo member)
        {
            return GetCustomAttributes<T>(member, false);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="member"></param>
        /// <param name="inherit"></param>
        /// <returns></returns>
        public static List<T> GetCustomAttributes<T>(this MemberInfo member, bool inherit)
        {
            return member.GetCustomAttributes(typeof(T), inherit).Cast<T>().ToList<T>();
        }

        /// <summary>
        /// Attempts to format the input string as indented, readable xml.
        /// The original value is returned for non-xml inputs.
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static string FormatXml(this string value)
        {
            return FormatXml(value, 2, ' ');
        }

        /// <summary>
        /// Attempts to format the input string as indented, readable xml.
        /// The original value is returned for non-xml inputs.
        /// </summary>
        /// <param name="value"></param>
        /// <param name="indentationCount"></param>
        /// <param name="indentChar"></param>
        /// <returns></returns>
        public static string FormatXml(this string value, int indentationCount, char indentChar)
        {
            try
            {
                XmlDocumentEx xmlDoc = new XmlDocumentEx(value, true);
                return xmlDoc.FormatXml(indentationCount, indentChar, '"');
            }
            catch
            {

            }

            return value;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="request"></param>
        /// <param name="requestBody"></param>
        /// <returns></returns>
        public static string ToTraceString(this HttpWebRequest request, string requestBody)
        {
            if (request == null)
                return String.Empty;

            StringBuilder trace = new StringBuilder();
            trace.AppendFormat("\r\n\r\n{0} {1} HTTP/{2}\r\n", request.Method, request.RequestUri.PathAndQuery, request.ProtocolVersion);

            foreach (string key in request.Headers.Keys)
                trace.AppendFormat("{0}: {1}\r\n", key, request.Headers[key]);

            if (!String.IsNullOrEmpty(requestBody))
                trace.AppendFormat("\r\n{0}\r\n\r\n", requestBody.FormatXml());
            return trace.ToString();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="response"></param>
        /// <returns></returns>
        public static string ToTraceString(this HttpWebResponse response)
        {
            string responseBody;
            using (StreamReader reader = new StreamReader(response.GetResponseStream()))
            {
                responseBody = reader.ReadToEnd();
            }

            return ToTraceString(response, responseBody);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="response"></param>
        /// <returns></returns>
        public static string ToTraceString(this HttpWebResponse response, string responseBody)
        {
            if (response == null)
                return String.Empty;

            StringBuilder trace = new StringBuilder();
            trace.AppendFormat("HTTP/{0} {1} {2}\r\n", response.ProtocolVersion, (int)response.StatusCode, response.StatusCode);

            foreach (string key in response.Headers.Keys)
                trace.AppendFormat("{0}: {1}\r\n", key, response.Headers[key]);

            if(!String.IsNullOrEmpty(responseBody))
            {
                trace.Append("\r\n" + responseBody.FormatXml());
            }

            return trace.ToString();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="channel"></param>
        public static void CloseConnection(this ICommunicationObject channel)
        {
            if (channel == null || channel.State != CommunicationState.Opened)
            {
                return;
            }

            try
            {
                channel.Close();
            }
            catch (CommunicationException)
            {
                channel.Abort();
            }
            catch (TimeoutException)
            {
                channel.Abort();
            }
            catch (Exception)
            {
                channel.Abort();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\CommonLib\TraceEx.cs ===
﻿using System;
using System.Reflection;
using System.Diagnostics;

namespace LiveN.Test.Common
{
    /// <summary>
    /// 
    /// </summary>
    public static class TraceEx
    {
        private static Type internalTraceType = Type.GetType("System.Diagnostics.TraceInternal, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", true, true);
        private static MethodInfo traceEvent = internalTraceType.GetMethod("TraceEvent");

        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceVerbose(string format, params object[] args)
        {
            TraceVerbose(String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceVerbose(string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Verbose, 0, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceStart(string format, params object[] args)
        {
            TraceStart(String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceStart(string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Start, 0, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceStop(string format, params object[] args)
        {
            TraceStop(String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceStop(string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Stop, 0, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="type"></param>
        /// <param name="id"></param>
        /// <param name="message"></param>
        public static void TraceEvent(TraceEventType type, int id, string message)
        {
            traceEvent.Invoke(null, new object[] { type, id, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="type"></param>
        /// <param name="id"></param>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceEvent(TraceEventType type, int id, string format, params object[] args)
        {
            traceEvent.Invoke(null, new object[] { type, id, format, args });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceError(string format, params object[] args)
        {
            TraceError(String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceError(string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Error, 1000, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="eventId"></param>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceError(int eventId, string format, params object[] args)
        {
            TraceError(eventId, String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceError(int eventId, string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Error, eventId, message, null });
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="eventId"></param>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public static void TraceWarning(int eventId, string format, params object[] args)
        {
            TraceWarning(eventId, String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public static void TraceWarning(int eventId, string message)
        {
            traceEvent.Invoke(null, new object[] { TraceEventType.Warning, eventId, message, null });
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\CommonLib\Forms\ErrorBox.Designer.cs ===
namespace LiveN.Test.Common.Forms
{
	partial class ErrorBox
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		/// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
		protected override void Dispose(bool disposing)
		{
			if (disposing && (components != null))
			{
				components.Dispose();
			}
			base.Dispose(disposing);
		}

		#region Windows Form Designer generated code

		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.errorMessage = new System.Windows.Forms.Label();
			this.ok = new System.Windows.Forms.Button();
			this.showInnerException = new System.Windows.Forms.Button();
			this.innerException = new System.Windows.Forms.TextBox();
			this.errorIcon = new System.Windows.Forms.PictureBox();
			((System.ComponentModel.ISupportInitialize)(this.errorIcon)).BeginInit();
			this.SuspendLayout();
			// 
			// errorMessage
			// 
			this.errorMessage.Location = new System.Drawing.Point(12, 19);
			this.errorMessage.Name = "errorMessage";
			this.errorMessage.Size = new System.Drawing.Size(458, 44);
			this.errorMessage.TabIndex = 0;
			// 
			// ok
			// 
			this.ok.Location = new System.Drawing.Point(152, 82);
			this.ok.Name = "ok";
			this.ok.Size = new System.Drawing.Size(75, 23);
			this.ok.TabIndex = 1;
			this.ok.Text = "&OK";
			this.ok.UseVisualStyleBackColor = true;
			this.ok.Click += new System.EventHandler(this.ok_Click);
			// 
			// showInnerException
			// 
			this.showInnerException.Location = new System.Drawing.Point(240, 82);
			this.showInnerException.Name = "showInnerException";
			this.showInnerException.Size = new System.Drawing.Size(144, 23);
			this.showInnerException.TabIndex = 2;
			this.showInnerException.Text = "&Show Inner Exception";
			this.showInnerException.UseVisualStyleBackColor = true;
			this.showInnerException.Click += new System.EventHandler(this.showInnerException_Click);
			// 
			// innerException
			// 
			this.innerException.Location = new System.Drawing.Point(12, 122);
			this.innerException.Multiline = true;
			this.innerException.Name = "innerException";
			this.innerException.ReadOnly = true;
			this.innerException.ScrollBars = System.Windows.Forms.ScrollBars.Both;
			this.innerException.Size = new System.Drawing.Size(505, 120);
			this.innerException.TabIndex = 3;
			// 
			// errorIcon
			// 
			this.errorIcon.Location = new System.Drawing.Point(480, 17);
			this.errorIcon.Name = "errorIcon";
			this.errorIcon.Size = new System.Drawing.Size(35, 34);
			this.errorIcon.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
			this.errorIcon.TabIndex = 4;
			this.errorIcon.TabStop = false;
			// 
			// ErrorBox
			// 
			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
			this.ClientSize = new System.Drawing.Size(529, 254);
			this.Controls.Add(this.errorIcon);
			this.Controls.Add(this.innerException);
			this.Controls.Add(this.showInnerException);
			this.Controls.Add(this.ok);
			this.Controls.Add(this.errorMessage);
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "ErrorBox";
			this.ShowIcon = false;
			this.ShowInTaskbar = false;
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
			((System.ComponentModel.ISupportInitialize)(this.errorIcon)).EndInit();
			this.ResumeLayout(false);
			this.PerformLayout();

		}

		#endregion

		private System.Windows.Forms.Label errorMessage;
		private System.Windows.Forms.Button ok;
		private System.Windows.Forms.Button showInnerException;
		private System.Windows.Forms.TextBox innerException;
		private System.Windows.Forms.PictureBox errorIcon;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\CommonLib\Utility.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Configuration;
using System.Security.Cryptography;
using System.IO;
using System.Reflection;
using System.Runtime.Serialization;

namespace LiveN.Test.Common
{
    /// <summary>
    /// Utils class to hold utilities library methods
    /// </summary>
    public static class Utility
    {
        private static Random rnd = new Random();
        private static object rndLock = new object();
        private static char[] whitespaceChars;
        private static string currentDirectory;
        private static string originalAssemblyDirectory;

        static Utility()
        {
            FileInfo assemblyFile = new FileInfo(new Uri(Assembly.GetExecutingAssembly().CodeBase).LocalPath);
            currentDirectory = assemblyFile.DirectoryName;
            originalAssemblyDirectory = String.IsNullOrEmpty(AppDomain.CurrentDomain.SetupInformation.PrivateBinPath) ? String.Empty : AppDomain.CurrentDomain.SetupInformation.PrivateBinPath;
            if (!Directory.Exists(originalAssemblyDirectory))
            {
                originalAssemblyDirectory = String.Empty;
            }
        }

        private static char[] WhitespaceChars
        {
            get
            {
                if (whitespaceChars == null)
                {
                    Type stringType = typeof(string);
                    object chars = stringType.InvokeMember("WhitespaceChars", BindingFlags.GetField | BindingFlags.NonPublic | BindingFlags.Static, null, null, null);
                    whitespaceChars = chars as char[];
                }

                return whitespaceChars;
            }
        }

        public static Random GlobalRandom
        {
            get
            {
                //NOTE: NOT thread safe!
                return rnd;
            }
        }

        public static string CurrentDirectory
        {
            get
            {
                return currentDirectory;
            }
        }

        public static string OriginalAssemblyDirectory
        {
            get
            {
                return originalAssemblyDirectory;
            }
        }

        public static int GenerateRandomNumber(int max)
        {
            lock (rndLock)
            {
                return rnd.Next(max);
            }
        }

        public static int GenerateRandomNumber(int min, int max)
        {
            lock (rndLock)
            {
                return rnd.Next(min, max);
            }
        }

        public static string GenerateRandomString()
        {
            return GenerateRandomString(GenerateRandomNumber(1024));
        }

        public static string GenerateRandomString(int length)
        {
            return GenerateRandomString(length, null);
        }

        public static string GenerateRandomString(int length, char[] excludeChars)
        {
            StringBuilder value = new StringBuilder(length);
            for (int i = 0; i < length; )
            {
                char temp = (char)GenerateRandomNumber(127);    //(char)GenerateRandomNumber(33, 127);
                if (!char.IsControl(temp) && (excludeChars == null || !excludeChars.Contains<char>(temp)))
                {
                    value.Append(temp);
                    i++;
                }
            }

            return value.ToString().Trim();
        }

        public static ulong GenerateRandomUInt64()
        {
            byte[] buffer = new byte[sizeof(ulong)];
            RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
            rng.GetNonZeroBytes(buffer);
            return BitConverter.ToUInt64(buffer, 0);
        }

        public static uint GenerateRandomUInt32()
        {
            byte[] buffer = new byte[sizeof(uint)];
            RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
            rng.GetNonZeroBytes(buffer);
            return BitConverter.ToUInt32(buffer, 0);
        }

        public static string ArrayToString(Array array)
        {
            return ArrayToString(array, ", ");
        }

        public static string ArrayToString(Array array, string divider)
        {
            StringBuilder values = new StringBuilder();
            foreach (object obj in array)
            {
                values.Append(obj);
                values.Append(divider);
            }

            if (values.Length > 0)
                values.Length -= divider.Length;
            return values.ToString();
        }

        public static string WhitespaceString(int length)
        {
            StringBuilder whitespace = new StringBuilder(length);
            Random rnd = new Random(unchecked((int)DateTime.Now.Ticks));

            for (int i = 0; i < length; i++)
                whitespace.Append(WhitespaceChars[rnd.Next(WhitespaceChars.Length)]);
            return whitespace.ToString();
        }

        public static string AppendWhitespace(object input)
        {
            return AppendWhitespace(input, true, true);
        }

        public static string AppendWhitespace(object input, bool before, bool after)
        {
            StringBuilder newString = new StringBuilder(input.ToString());
            Random rnd = new Random(unchecked((int)DateTime.Now.Ticks));

            if (before)
                newString.Insert(0, WhitespaceString(rnd.Next(1, 5)));
            if (after)
                newString.Append(WhitespaceString(rnd.Next(1, 5)));
            return newString.ToString();
        }

        public static string GenerateUnicodeString(int length)
        {
            StringBuilder sb = new StringBuilder();
            while (sb.Length < length)
            {
                char c = (char)GenerateRandomNumber(0x20, 0xfff0);
                if ((((c < '⁪') || (c > '⁯')) && ((c < 0xd800) || (c > 0xdfff))) && (((c < 0xe000) || (c > 0xf8ff)) && (c != 0xfeff)))
                {
                    sb.Append(c);
                }
            }
            return sb.ToString();

        }

        public static byte[] GenerateRandomBytes()
        {
            return GenerateRandomBytes(GlobalRandom.Next(129));
        }

        public static byte[] GenerateRandomBytes(int length)
        {
            byte[] data = new byte[length];
            GlobalRandom.NextBytes(data);
            return data;
        }

        /// <summary>
        /// Get the string between the First string and the second
        /// </summary>
        /// <param name="startIndex">Start looking for the first string here, set to 0 to start at the begining</param>
        /// <param name="search">String to be searched</param>
        /// <param name="first">First string to find</param>
        /// <param name="end">End string to find</param>
        /// <returns>Returns the string between the first and the second string Else returns null</returns>
        public static string GetBetween(int startIndex, string search, string first, string end)
        {
            int endLocation = 0;
            int startLocation = 0;

            if (first == null)
            {
                // The user just wants to start with the begining of the string
                startLocation = 0;
            }
            else
            {
                startLocation = search.IndexOf(first, startIndex);
                if (startLocation < 0)
                {
                    return null;
                }

                startLocation += first.Length;
            }

            if (end == null)
            {
                // User wants the rest of the string
                endLocation = search.Length;
            }
            else
            {
                endLocation = search.IndexOf(end, startLocation);
                if (endLocation < 0)
                {
                    return null;
                }
            }

            return search.Substring(startLocation, endLocation - startLocation);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\CommonLib\Forms\AboutForm.cs ===
#region Using Directives

using System;
using System.Security;
using System.ComponentModel;
using System.Windows.Forms;
using System.Drawing;
using System.Diagnostics;
using System.Reflection;
using System.Text;
using System.Globalization;
using System.Security.Permissions;

#endregion

namespace LiveN.Test.Common.Forms
{
	#region AboutForm Class
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Summary description for AboutForm.
	/// </summary>
	public class AboutForm : System.Windows.Forms.Form
	{
		#region Delegates

		private delegate void UpdateProcessInformationDelegate(string[] values);

		#endregion

		#region Variable Declarations

		private System.Windows.Forms.Button btnOkay;
		private System.ComponentModel.Container components = new Container();
		private System.Windows.Forms.Panel backgroundPanel;
		private System.Windows.Forms.PictureBox pictureBoxIcon;
		private System.Windows.Forms.LinkLabel linkLblPJL;
		private System.Windows.Forms.Label lblAuthor;
		private System.Windows.Forms.Label lblApplicationVersion;
		private System.Windows.Forms.Label lblApplicationName;
		private ListViewExBase moduleListView;
		private System.Windows.Forms.ColumnHeader colModuleName;
		private System.Windows.Forms.ColumnHeader colModuleVersion;
		private System.Windows.Forms.ColumnHeader columnHeader1;
		private System.Windows.Forms.ColumnHeader columnHeader2;
		private System.Windows.Forms.ColumnHeader columnHeader3;
		private System.Windows.Forms.ColumnHeader columnHeader4;
		private System.Windows.Forms.TabControl tabControlAbout;
		private System.Windows.Forms.TabPage tabPageApplication;
		private System.Windows.Forms.TabPage tabPageResources;
		private ListViewExBase listViewProcess;
		private System.Windows.Forms.CheckBox checkBoxRefresh;
		
		private ToolTip toolTipImage;
		private int threadId;

		#endregion

		#region Constants

		private const string MailTo = "mailto:{0}@microsoft.com";

		#endregion

		#region Constructors
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="applicationName"></param>
		/// <param name="types"></param>
		[PermissionSet(SecurityAction.LinkDemand)]
		public AboutForm(string applicationName, string author, string authorAlias)
		{
			InternalConstructor(applicationName, author, authorAlias, null);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="applicationName"></param>
		/// <param name="picture"></param>
		/// <param name="types"></param>
		[PermissionSet(SecurityAction.LinkDemand)]
		public AboutForm(string applicationName, string author, string authorAlias, Image picture)
		{
			InternalConstructor(applicationName, author, authorAlias, picture);
		}
		#endregion

		#region Public Properties
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public string ApplicationName
		{
			get
			{
				return this.lblApplicationName.Tag as String;
			}
			set
			{
				this.lblApplicationName.Text = value + " Version:";
				this.Text = "About " + value + "...";
				this.lblApplicationName.Tag = value;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public Image Picture
		{
			get
			{
				return this.pictureBoxIcon.Image;
			}
			set
			{
				this.pictureBoxIcon.Image = value;
			}
		}
		#endregion

		#region Protected Methods
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose(bool disposing)
		{
			if(disposing)
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose(disposing);
		}
		#endregion

		#region Private Methods

			#region Initialization

				#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			System.Windows.Forms.ListViewItem listViewItem1 = new System.Windows.Forms.ListViewItem(new string[] {
            "Process Id",
            ""}, -1);
			System.Windows.Forms.ListViewItem listViewItem2 = new System.Windows.Forms.ListViewItem(new string[] {
            "Priority Class",
            ""}, -1);
			System.Windows.Forms.ListViewItem listViewItem3 = new System.Windows.Forms.ListViewItem(new string[] {
            "Loaded Modules",
            ""}, -1);
			System.Windows.Forms.ListViewItem listViewItem4 = new System.Windows.Forms.ListViewItem(new string[] {
            "Handles",
            ""}, -1);
			System.Windows.Forms.ListViewItem listViewItem5 = new System.Windows.Forms.ListViewItem(new string[] {
            "System Memory",
            ""}, -1);
			System.Windows.Forms.ListViewItem listViewItem6 = new System.Windows.Forms.ListViewItem(new string[] {
            "Virtual Memory",
            ""}, -1);
			System.Windows.Forms.ListViewItem listViewItem7 = new System.Windows.Forms.ListViewItem(new string[] {
            "Threads",
            ""}, -1);
			System.Windows.Forms.ListViewItem listViewItem8 = new System.Windows.Forms.ListViewItem(new string[] {
            "Total Processor Time",
            ""}, -1);
			this.btnOkay = new System.Windows.Forms.Button();
			this.backgroundPanel = new System.Windows.Forms.Panel();
			this.pictureBoxIcon = new System.Windows.Forms.PictureBox();
			this.tabControlAbout = new System.Windows.Forms.TabControl();
			this.tabPageApplication = new System.Windows.Forms.TabPage();
			this.moduleListView = new LiveN.Test.Common.Forms.ListViewExBase();
			this.colModuleName = new System.Windows.Forms.ColumnHeader();
			this.colModuleVersion = new System.Windows.Forms.ColumnHeader();
			this.linkLblPJL = new System.Windows.Forms.LinkLabel();
			this.lblAuthor = new System.Windows.Forms.Label();
			this.lblApplicationVersion = new System.Windows.Forms.Label();
			this.lblApplicationName = new System.Windows.Forms.Label();
			this.tabPageResources = new System.Windows.Forms.TabPage();
			this.checkBoxRefresh = new System.Windows.Forms.CheckBox();
			this.listViewProcess = new LiveN.Test.Common.Forms.ListViewExBase();
			this.columnHeader3 = new System.Windows.Forms.ColumnHeader();
			this.columnHeader4 = new System.Windows.Forms.ColumnHeader();
			this.columnHeader1 = new System.Windows.Forms.ColumnHeader();
			this.columnHeader2 = new System.Windows.Forms.ColumnHeader();
			this.backgroundPanel.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)(this.pictureBoxIcon)).BeginInit();
			this.tabControlAbout.SuspendLayout();
			this.tabPageApplication.SuspendLayout();
			this.tabPageResources.SuspendLayout();
			this.SuspendLayout();
			// 
			// btnOkay
			// 
			this.btnOkay.Location = new System.Drawing.Point(200, 256);
			this.btnOkay.Name = "btnOkay";
			this.btnOkay.Size = new System.Drawing.Size(80, 24);
			this.btnOkay.TabIndex = 4;
			this.btnOkay.Text = "&OK";
			this.btnOkay.Click += new System.EventHandler(this.btnOkay_Click);
			// 
			// backgroundPanel
			// 
			this.backgroundPanel.BackColor = System.Drawing.Color.White;
			this.backgroundPanel.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.backgroundPanel.Controls.Add(this.pictureBoxIcon);
			this.backgroundPanel.Location = new System.Drawing.Point(11, 8);
			this.backgroundPanel.Name = "backgroundPanel";
			this.backgroundPanel.Size = new System.Drawing.Size(45, 280);
			this.backgroundPanel.TabIndex = 7;
			// 
			// pictureBoxIcon
			// 
			this.pictureBoxIcon.Location = new System.Drawing.Point(5, 8);
			this.pictureBoxIcon.Name = "pictureBoxIcon";
			this.pictureBoxIcon.Size = new System.Drawing.Size(32, 32);
			this.pictureBoxIcon.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
			this.pictureBoxIcon.TabIndex = 0;
			this.pictureBoxIcon.TabStop = false;
			// 
			// tabControlAbout
			// 
			this.tabControlAbout.Controls.Add(this.tabPageApplication);
			this.tabControlAbout.Controls.Add(this.tabPageResources);
			this.tabControlAbout.HotTrack = true;
			this.tabControlAbout.Location = new System.Drawing.Point(72, 8);
			this.tabControlAbout.Name = "tabControlAbout";
			this.tabControlAbout.SelectedIndex = 0;
			this.tabControlAbout.Size = new System.Drawing.Size(352, 232);
			this.tabControlAbout.TabIndex = 14;
			this.tabControlAbout.SelectedIndexChanged += new System.EventHandler(this.tabControlAbout_SelectedIndexChanged);
			// 
			// tabPageApplication
			// 
			this.tabPageApplication.Controls.Add(this.moduleListView);
			this.tabPageApplication.Controls.Add(this.linkLblPJL);
			this.tabPageApplication.Controls.Add(this.lblAuthor);
			this.tabPageApplication.Controls.Add(this.lblApplicationVersion);
			this.tabPageApplication.Controls.Add(this.lblApplicationName);
			this.tabPageApplication.Location = new System.Drawing.Point(4, 22);
			this.tabPageApplication.Name = "tabPageApplication";
			this.tabPageApplication.Size = new System.Drawing.Size(344, 206);
			this.tabPageApplication.TabIndex = 0;
			this.tabPageApplication.Text = "Application";
			// 
			// moduleListView
			// 
			this.moduleListView.AllowColumnReorder = true;
			this.moduleListView.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
            this.colModuleName,
            this.colModuleVersion});
			this.moduleListView.FullRowSelect = true;
			this.moduleListView.GridLines = true;
			this.moduleListView.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.Nonclickable;
			this.moduleListView.LabelWrap = false;
			this.moduleListView.Location = new System.Drawing.Point(16, 64);
			this.moduleListView.MultiSelect = false;
			this.moduleListView.Name = "moduleListView";
			this.moduleListView.Size = new System.Drawing.Size(312, 128);
			this.moduleListView.TabIndex = 19;
			this.moduleListView.UseCompatibleStateImageBehavior = false;
			this.moduleListView.View = System.Windows.Forms.View.Details;
			// 
			// colModuleName
			// 
			this.colModuleName.Text = "Loaded Modules";
			this.colModuleName.Width = 207;
			// 
			// colModuleVersion
			// 
			this.colModuleVersion.Text = "Version";
			this.colModuleVersion.Width = 101;
			// 
			// linkLblPJL
			// 
			this.linkLblPJL.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
			this.linkLblPJL.Location = new System.Drawing.Point(53, 8);
			this.linkLblPJL.Name = "linkLblPJL";
			this.linkLblPJL.Size = new System.Drawing.Size(267, 16);
			this.linkLblPJL.TabIndex = 17;
			this.linkLblPJL.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.linkLblPJL_LinkClicked);
			// 
			// lblAuthor
			// 
			this.lblAuthor.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
			this.lblAuthor.Location = new System.Drawing.Point(8, 8);
			this.lblAuthor.Name = "lblAuthor";
			this.lblAuthor.Size = new System.Drawing.Size(56, 16);
			this.lblAuthor.TabIndex = 16;
			this.lblAuthor.Text = "Author:";
			// 
			// lblApplicationVersion
			// 
			this.lblApplicationVersion.AutoSize = true;
			this.lblApplicationVersion.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
			this.lblApplicationVersion.Location = new System.Drawing.Point(224, 29);
			this.lblApplicationVersion.Name = "lblApplicationVersion";
			this.lblApplicationVersion.Size = new System.Drawing.Size(0, 13);
			this.lblApplicationVersion.TabIndex = 15;
			this.lblApplicationVersion.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			// 
			// lblApplicationName
			// 
			this.lblApplicationName.AutoSize = true;
			this.lblApplicationName.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
			this.lblApplicationName.Location = new System.Drawing.Point(16, 29);
			this.lblApplicationName.Name = "lblApplicationName";
			this.lblApplicationName.Size = new System.Drawing.Size(0, 13);
			this.lblApplicationName.TabIndex = 14;
			this.lblApplicationName.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			// 
			// tabPageResources
			// 
			this.tabPageResources.Controls.Add(this.checkBoxRefresh);
			this.tabPageResources.Controls.Add(this.listViewProcess);
			this.tabPageResources.Location = new System.Drawing.Point(4, 22);
			this.tabPageResources.Name = "tabPageResources";
			this.tabPageResources.Size = new System.Drawing.Size(344, 206);
			this.tabPageResources.TabIndex = 1;
			this.tabPageResources.Text = "Resources";
			// 
			// checkBoxRefresh
			// 
			this.checkBoxRefresh.Checked = true;
			this.checkBoxRefresh.CheckState = System.Windows.Forms.CheckState.Checked;
			this.checkBoxRefresh.Location = new System.Drawing.Point(16, 180);
			this.checkBoxRefresh.Name = "checkBoxRefresh";
			this.checkBoxRefresh.Size = new System.Drawing.Size(136, 16);
			this.checkBoxRefresh.TabIndex = 21;
			this.checkBoxRefresh.Text = "Automatically Refresh";
			this.checkBoxRefresh.CheckedChanged += new System.EventHandler(this.checkBoxRefresh_CheckedChanged);
			// 
			// listViewProcess
			// 
			this.listViewProcess.AllowColumnReorder = true;
			this.listViewProcess.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
            this.columnHeader3,
            this.columnHeader4});
			this.listViewProcess.FullRowSelect = true;
			this.listViewProcess.GridLines = true;
			this.listViewProcess.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.Nonclickable;
			this.listViewProcess.Items.AddRange(new System.Windows.Forms.ListViewItem[] {
            listViewItem1,
            listViewItem2,
            listViewItem3,
            listViewItem4,
            listViewItem5,
            listViewItem6,
            listViewItem7,
            listViewItem8});
			this.listViewProcess.LabelWrap = false;
			this.listViewProcess.Location = new System.Drawing.Point(16, 24);
			this.listViewProcess.MultiSelect = false;
			this.listViewProcess.Name = "listViewProcess";
			this.listViewProcess.Size = new System.Drawing.Size(312, 144);
			this.listViewProcess.TabIndex = 20;
			this.listViewProcess.UseCompatibleStateImageBehavior = false;
			this.listViewProcess.View = System.Windows.Forms.View.Details;
			// 
			// columnHeader3
			// 
			this.columnHeader3.Text = "Process Property";
			this.columnHeader3.Width = 202;
			// 
			// columnHeader4
			// 
			this.columnHeader4.Text = "Property Value";
			this.columnHeader4.Width = 106;
			// 
			// columnHeader1
			// 
			this.columnHeader1.Text = "Loaded Modules";
			this.columnHeader1.Width = 207;
			// 
			// columnHeader2
			// 
			this.columnHeader2.Text = "Version";
			this.columnHeader2.Width = 101;
			// 
			// AboutForm
			// 
			this.AcceptButton = this.btnOkay;
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(434, 295);
			this.Controls.Add(this.tabControlAbout);
			this.Controls.Add(this.backgroundPanel);
			this.Controls.Add(this.btnOkay);
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "AboutForm";
			this.ShowInTaskbar = false;
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
			this.Closing += new System.ComponentModel.CancelEventHandler(this.AboutForm_Closing);
			this.Load += new System.EventHandler(this.AboutForm_Load);
			this.backgroundPanel.ResumeLayout(false);
			this.backgroundPanel.PerformLayout();
			((System.ComponentModel.ISupportInitialize)(this.pictureBoxIcon)).EndInit();
			this.tabControlAbout.ResumeLayout(false);
			this.tabPageApplication.ResumeLayout(false);
			this.tabPageApplication.PerformLayout();
			this.tabPageResources.ResumeLayout(false);
			this.ResumeLayout(false);

		}
			#endregion

			#endregion

			#region Event Handlers

				#region btnOkay Event Handlers
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void btnOkay_Click(object sender, System.EventArgs e)
		{
			this.Close();
		}
				#endregion

				#region linkLblPJL Event Handlers
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void linkLblPJL_LinkClicked(object sender, System.Windows.Forms.LinkLabelLinkClickedEventArgs e)
		{
			try
			{
				Process.Start(e.Link.LinkData as String);
			}
			catch(Win32Exception ex)
			{
				MessageBox.Show(this, String.Format("Unable to open the default email client to email {0}!  If this problem persists,\r\nplease email the author at '{1}', using the email client of your choice.\r\n\r\nError Message: {2}", this.linkLblPJL.Text, (e.Link.LinkData as String).Replace("mailto:", ""), ex.Message), "Error Opening Email Client", MessageBoxButtons.OK, MessageBoxIcon.Error);
			}
		}
				#endregion

				#region checkBoxRefresh Event Handlers
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void checkBoxRefresh_CheckedChanged(object sender, System.EventArgs e)
		{
			if(!this.checkBoxRefresh.Checked)
			{
				ThreadPoolEx.StopThread(this.threadId);
			}
			else
			{
				this.threadId = ThreadPoolEx.StartTimer(new MethodInvoker(GetProcessInformation), null, 0, 2000);
			}
		}
				#endregion

				#region tabControlAbout Event Handlers
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void tabControlAbout_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			switch(this.tabControlAbout.SelectedIndex)
			{
				case 0:	//Application tab
				{
					ThreadPoolEx.StopThread(threadId);
					break;
				}
				case 1:	//Resources tab
				{
					if(this.checkBoxRefresh.Checked)
					{
						this.threadId = ThreadPoolEx.StartTimer(new MethodInvoker(GetProcessInformation), null, 0, 2000);
					}
					break;
				}
			}
		}
				#endregion

				#region AboutForm Event Handlers
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void AboutForm_Closing(object sender, System.ComponentModel.CancelEventArgs e)
		{
			ThreadPoolEx.StopThread(this.threadId);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void AboutForm_Load(object sender, System.EventArgs e)
		{
			tabControlAbout_SelectedIndexChanged(this, EventArgs.Empty);
		}
				#endregion

			#endregion

			#region Helper Methods
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		[PermissionSet(SecurityAction.LinkDemand)]
		private void GetVersionInfo()
		{
			Assembly applicationAssembly = Assembly.GetEntryAssembly();

			try
			{
				//get overall application version
				this.lblApplicationVersion.Text = applicationAssembly.GetName().Version.ToString();

				//sort & display all references this application has
				AssemblyName[] names = applicationAssembly.GetReferencedAssemblies();
				Array.Sort(names, new AssemblyNameComparer());
				this.moduleListView.BeginUpdate();
				
				for(int i=0; i<names.Length; i++)
				{
					ListViewItem module = new ListViewItem(new string[]{names[i].Name + ".dll", names[i].Version.ToString()});
					this.moduleListView.Items.Add(module);
				}

				this.colModuleVersion.Width = -2;
			}
			catch
			{
				this.lblApplicationVersion.Text = "Unable to get version!";
				this.moduleListView.Items.Clear();
				ListViewItem error = new ListViewItem(new string[]{"Unable to load modules!", ""});
				this.moduleListView.Items.Add(error);
			}
			finally
			{
				this.moduleListView.EndUpdate();
			}

			Process currentProcess = Process.GetCurrentProcess();
			this.listViewProcess.Items[0].SubItems[1].Text = currentProcess.Id.ToString(CultureInfo.CurrentCulture.NumberFormat);
			this.listViewProcess.Items[1].SubItems[1].Text = currentProcess.PriorityClass.ToString();
			this.listViewProcess.Items[2].SubItems[1].Text = currentProcess.Modules.Count.ToString(CultureInfo.CurrentCulture.NumberFormat);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <returns></returns>
		private void GetProcessInformation()
		{
			try
			{
				Process currentProcess = Process.GetCurrentProcess();
				string[] values = new string[5];

				values[0] = currentProcess.HandleCount.ToString(CultureInfo.CurrentCulture.NumberFormat);
				values[1] = (currentProcess.WorkingSet64 / 1024).ToString(CultureInfo.CurrentCulture.NumberFormat) + "k";
				values[2] = (currentProcess.VirtualMemorySize64 / 1024).ToString(CultureInfo.CurrentCulture.NumberFormat) + "k";
				values[3] = currentProcess.Threads.Count.ToString(CultureInfo.CurrentCulture.NumberFormat);

				TimeSpan temp = currentProcess.TotalProcessorTime;
				values[4] = FormatTimespan(temp.Hours, temp.Minutes, temp.Seconds, temp.Milliseconds);

				this.Invoke(new UpdateProcessInformationDelegate(UpdateProcessInformation), new object[]{values});
			}
			catch(Exception e)
			{
				this.Invoke(new UpdateProcessInformationDelegate(UpdateProcessInformation), new object[]{new string[]{e.Message}});
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="hours"></param>
		/// <param name="minutes"></param>
		/// <param name="seconds"></param>
		/// <param name="milliSeconds"></param>
		/// <returns></returns>
		private static string FormatTimespan(int hours, int minutes, int seconds, int milliSeconds)
		{
			StringBuilder timeDisplay = new StringBuilder();

			PadTimeUnit(timeDisplay, hours);
			PadTimeUnit(timeDisplay, minutes);
			PadTimeUnit(timeDisplay, seconds);
			PadTimeUnit(timeDisplay, milliSeconds);
			timeDisplay.Length -= 1;

			return timeDisplay.ToString();
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="paddedTimeUnit"></param>
		/// <param name="timeUnit"></param>
		private static void PadTimeUnit(StringBuilder paddedTimeUnit, int timeUnit)
		{
			paddedTimeUnit.Append(timeUnit.ToString(CultureInfo.CurrentCulture.NumberFormat));

			if(timeUnit <= 9)
			{
				paddedTimeUnit.Insert(paddedTimeUnit.Length - 1, "0");
			}

			paddedTimeUnit.Append(":");
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		private void UpdateProcessInformation(string[] values)
		{
			Debug.Assert(!this.InvokeRequired, "Attempting to update the about box UI, with process information, from a different thread, without properly invoking it!");
			
			try
			{
				this.listViewProcess.BeginUpdate();

				if(values.Length == 5)
				{
					this.listViewProcess.Items[3].SubItems[1].Text = values[0];
					this.listViewProcess.Items[4].SubItems[1].Text = values[1];
					this.listViewProcess.Items[5].SubItems[1].Text = values[2];
					this.listViewProcess.Items[6].SubItems[1].Text = values[3];
					this.listViewProcess.Items[7].SubItems[1].Text = values[4];
				}
				else
				{
					this.listViewProcess.Items.Clear();
					this.listViewProcess.Items.Add(new ListViewItem("Unable to list Process information! " + values[0]));
				}
			}
			finally
			{
				this.listViewProcess.EndUpdate();
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="applicationName"></param>
		/// <param name="picture"></param>
		/// <param name="types"></param>
		[PermissionSet(SecurityAction.LinkDemand)]
		private void InternalConstructor(string applicationName, string author, string authorAlias, Image picture)
		{
			InitializeComponent();
			GetVersionInfo();
						
			this.ApplicationName = applicationName;
			this.lblApplicationName.Left = this.lblAuthor.Left;
			this.lblApplicationVersion.Left = this.lblApplicationName.Right + 2;
			this.linkLblPJL.Text = author;
			this.linkLblPJL.Links[0].LinkData = String.Format(MailTo, authorAlias);

			if(picture != null)
			{
				this.pictureBoxIcon.Image = picture;
				this.toolTipImage = new ToolTip(this.components);
				this.toolTipImage.SetToolTip(this.pictureBoxIcon, applicationName);
			}
		}
			#endregion


		#endregion
	}
	#endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\CommonLib\X509Certificate2Ex.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Runtime.InteropServices;
using System.ComponentModel;
using System.IO;
using System.Security.AccessControl;
using LiveN.Test.Common;
using LiveN.Test.Common.Win32;

namespace LiveN.Test.Common
{
    /// <summary>
    /// Extended X509Certificate2 class that allows easy access to the certificate's key pair for encryption/decryption and signature
    /// generation/verification.  Certificates can also be installed, uninstalled and access to the private key material
    /// can be managed.
    /// </summary>
    public class X509Certificate2Ex : X509Certificate2, IDisposable
    {
        /// <summary>
        /// 
        /// </summary>
        public enum SearchField
        {
            CertHash,
            FriendlyName,
            SerialNumber,
            Subject,
            SubjectKeyIdentifier,
            Thumbprint,
        }

        public const string ClientAuthenticationOid = "1.3.6.1.5.5.7.3.2";
        public const string SmartCardLogonOid = "1.3.6.1.4.1.311.20.2.2";
        public const string OtgSmartCardOid = "1.3.6.1.4.1.311.42.2.1";

        private string ski;
        private X509KeyUsageFlags keyUsage;
        private List<Oid> enhancedKeyUsage = new List<Oid>();
        private string keyAlgorithm;
        //used as the hasing algorithm when signing data with an RSA cert
        private SHA1CryptoServiceProvider sha1;
        private RSACryptoServiceProvider publicRsa;
        private DSACryptoServiceProvider publicDsa;
        private RSACryptoServiceProvider privateRsa;
        private DSACryptoServiceProvider privateDsa;
        private bool isRsa;
        string privateKeyPath;
        private bool canUsePrivateKey;
        private List<X509ChainElement> certChain;
        private bool isDisposed;

        /// <summary>
        /// 
        /// </summary>
        public X509Certificate2Ex()
            : base()
        { }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="filepath"></param>
        public X509Certificate2Ex(string filepath)
            : base(filepath)
        {
            InternalConstructor();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="filepath"></param>
        /// <param name="password"></param>
        public X509Certificate2Ex(string filepath, string password)
            : base(filepath, password)
        {
            InternalConstructor();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="filepath"></param>
        /// <param name="password"></param>
        /// <param name="keyStorageFlags"></param>
        public X509Certificate2Ex(string filepath, string password, X509KeyStorageFlags keyStorageFlags)
            : base(filepath, password, keyStorageFlags)
        {
            InternalConstructor();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="rawData"></param>
        public X509Certificate2Ex(byte[] rawData)
            : base(rawData)
        {
            InternalConstructor();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="handle"></param>
        public X509Certificate2Ex(IntPtr handle)
            : base(handle)
        {
            InternalConstructor();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="certificate"></param>
        public X509Certificate2Ex(X509Certificate certificate)
            : base(certificate)
        {
            InternalConstructor();
        }

        /// <summary>
        /// Friendly name of the certificate's key algorithm.  Should be RSA or DSA.
        /// </summary>
        public string KeyAlgorithm
        {
            get { return this.keyAlgorithm; }
        }

        /// <summary>
        /// The subject key identifier of the certificate.
        /// </summary>
        public string SKI
        {
            get { return this.ski; }
        }

        /// <summary>
        /// 
        /// </summary>
        public X509KeyUsageFlags KeyUsage
        {
            get { return this.keyUsage; }
        }

        /// <summary>
        /// 
        /// </summary>
        public List<Oid> EnhancedKeyUsage
        {
            get { return this.enhancedKeyUsage; }
        }

        /// <summary>
        /// Returns the file path where the private key is located.
        /// </summary>
        public string PrivateKeyPath
        {
            get
            {
                if (this.HasPrivateKey)
                {
                    if (this.privateKeyPath == null)
                        this.privateKeyPath = GetPrivateKeyPath();

                    return this.privateKeyPath;
                }

                throw new ApplicationException("The certificate does not have a private key.");
            }
        }

        /// <summary>
        /// Returns whether or not the private key can be found and used by the current user.  Private keys
        /// cannot necessarily be used by just any user.
        /// </summary>
        public bool CanUsePrivateKey
        {
            get { return this.canUsePrivateKey; }
        }

        /// <summary>
        /// 
        /// </summary>
        public List<X509ChainElement> CertificateChain
        {
            get
            {
                if (this.certChain == null)
                    BuildCertChain();

                return this.certChain;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public X509ChainElement RootCertificateAuthority
        {
            get
            {
                if (this.CertificateChain.Count > 0)
                    return this.CertificateChain[this.CertificateChain.Count - 1];

                return null;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public List<X509ChainElement> IntermediateCertificateAuthorities
        {
            get
            {
                if (this.CertificateChain.Count > 2)
                    return this.CertificateChain.GetRange(1, this.CertificateChain.Count - 2);

                return new List<X509ChainElement>();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public X509ChainStatus[] Status
        {
            get { return this.CertificateChain[0].ChainElementStatus; }
        }

        /// <summary>
        /// 
        /// </summary>
        public bool IsValid
        {
            get { return this.Status.Length == 1 && this.Status[0].Status == X509ChainStatusFlags.NoError; }
        }

        /// <summary>
        /// Searches for a certificate in the MY store of the local machine, using the specified subject.
        /// </summary>
        /// <param name="subject"></param>
        /// <returns></returns>
        public static X509Certificate2Ex FindCertificate(string subject)
        {
            return FindCertificate(subject, SearchField.Subject, StoreName.My, StoreLocation.LocalMachine, OpenFlags.ReadOnly, false);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="data"></param>
        /// <param name="field"></param>
        /// <returns></returns>
        public static X509Certificate2Ex FindCertificate(string data, SearchField field)
        {
            return FindCertificate(data, field, StoreName.My, StoreLocation.LocalMachine);
        }

        /// <summary>
        /// Searches for a certificate in the specified store name and store location, by subject.
        /// </summary>
        /// <param name="subject"></param>
        /// <param name="storeName"></param>
        /// <param name="storeLocation"></param>
        /// <returns></returns>
        public static X509Certificate2Ex FindCertificate(string data, SearchField field, StoreName storeName, StoreLocation storeLocation)
        {
            return FindCertificate(data, field, storeName, storeLocation, OpenFlags.ReadOnly, true);
        }

        /// <summary>
        /// Searches for a certificate in the specified store name and store location, by subject.  An exact subject match
        /// and how the certificate store is opened can be specified.
        /// </summary>
        /// <param name="subject"></param>
        /// <param name="storeName"></param>
        /// <param name="storeLocation"></param>
        /// <returns></returns>
        public static X509Certificate2Ex FindCertificate(string data, SearchField field, StoreName storeName, StoreLocation storeLocation, OpenFlags openFlags, bool exactMatch)
        {
            X509Store certStore = new X509Store(storeName, storeLocation);

            try
            {
                certStore.Open(openFlags);
                for (int i = 0; i < certStore.Certificates.Count; i++)
                {
                    string compareData = String.Empty;
                    switch (field)
                    {
                        case SearchField.CertHash:
                            {
                                compareData = certStore.Certificates[i].GetCertHashString();
                                break;
                            }
                        case SearchField.FriendlyName:
                            {
                                compareData = certStore.Certificates[i].FriendlyName;
                                break;
                            }
                        case SearchField.SerialNumber:
                            {
                                compareData = certStore.Certificates[i].SerialNumber;
                                break;
                            }
                        case SearchField.Subject:
                            {
                                compareData = certStore.Certificates[i].Subject;
                                break;
                            }
                        case SearchField.SubjectKeyIdentifier:
                            {
                                X509Certificate2Ex tempCert = new X509Certificate2Ex(certStore.Certificates[i]);
                                compareData = tempCert.SKI;
                                break;
                            }
                        case SearchField.Thumbprint:
                            {
                                compareData = certStore.Certificates[i].Thumbprint;
                                break;
                            }
                    }

                    if ((!exactMatch && compareData.Contains(data)) || compareData.Equals(data))
                    {
                        return new X509Certificate2Ex(certStore.Certificates[i]);
                    }
                }
                throw new ApplicationException(String.Format("Unable to find a certificate with '{0}' in cert field {1}, in store name {2} and store location {3}.", data, field.ToString(), storeName.ToString(), storeLocation.ToString()));
            }
            finally
            {
                certStore.Close();
            }
        }

        /// <summary>
        /// Returns all certificates found in the specified store name and location.  The certificates returned are read only.
        /// </summary>
        /// <param name="storeLocation"></param>
        /// <param name="storeName"></param>
        /// <returns></returns>
        public static List<X509Certificate2Ex> FindCertificates(StoreLocation storeLocation, StoreName storeName)
        {
            List<X509Certificate2Ex> certs = new List<X509Certificate2Ex>();
            X509Store certStore = new X509Store(storeName, storeLocation);

            try
            {
                certStore.Open(OpenFlags.ReadOnly);
                for (int i = 0; i < certStore.Certificates.Count; i++)
                {
                    certs.Add(new X509Certificate2Ex(certStore.Certificates[i]));
                }

                return certs;
            }
            finally
            {
                certStore.Close();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="subject"></param>
        /// <param name="storeName"></param>
        /// <param name="storeLocation"></param>
        /// <returns></returns>
        public static X509Certificate2Ex TryFindCertificate(string subject, StoreName storeName, StoreLocation storeLocation)
        {
            try
            {
                return FindCertificate(subject, SearchField.Subject, storeName, storeLocation, OpenFlags.ReadOnly, false);
            }
            catch (ApplicationException)
            {
                return null;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="data"></param>
        /// <param name="field"></param>
        /// <returns></returns>
        public static X509Certificate2Ex TryFindCertificate(string data, SearchField field)
        {
            return TryFindCertificate(data, field, StoreName.My, StoreLocation.LocalMachine);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="data"></param>
        /// <param name="field"></param>
        /// <param name="storeName"></param>
        /// <param name="storeLocation"></param>
        /// <returns></returns>
        public static X509Certificate2Ex TryFindCertificate(string data, SearchField field, StoreName storeName, StoreLocation storeLocation)
        {
            try
            {
                return FindCertificate(data, field, storeName, storeLocation);
            }
            catch (ApplicationException)
            {
                return null;
            }
        }

        /// <summary>
        /// Installs the specified certificate into the LOCAL_MACHINE\MY certificate store.  If the same certificate
        /// already exists in the certificate store, it will not be installed.
        /// </summary>
        /// <param name="certificate"></param>
        /// <returns></returns>
        public static void InstallCertificate(X509Certificate2 certificate)
        {
            InstallCertificate(certificate, StoreName.My, StoreLocation.LocalMachine);
        }

        /// <summary>
        /// Installs the provided certificate into the specified certificate store name and location.  How the certificate is 
        /// installed (overwrite existing, etc.) can be specified by the CertStoreAddDisposition flag.
        /// </summary>
        /// <param name="certificate"></param>
        /// <param name="storeName"></param>
        /// <param name="storeLocation"></param>
        /// <param name="addDisposition"></param>
        public static void InstallCertificate(X509Certificate2 certificate, StoreName storeName, StoreLocation storeLocation)
        {
            X509Store certStore = new X509Store(storeName, storeLocation);

            try
            {
                certStore.Open(OpenFlags.ReadWrite);
                certStore.Add(certificate);
            }
            finally
            {
                certStore.Close();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="certificates"></param>
        /// <param name="storeName"></param>
        /// <param name="storeLocation"></param>
        public static void InstallCertificates(List<X509Certificate2> certificates, StoreName storeName, StoreLocation storeLocation)
        {
            X509Store certStore = new X509Store(storeName, storeLocation);

            try
            {
                certStore.Open(OpenFlags.ReadWrite);
                for (int i = 0; i < certificates.Count; i++)
                {
                    certStore.Add(certificates[i]);
                }
            }
            finally
            {
                certStore.Close();
            }
        }

        /// <summary>
        /// Deletes the certificate, found in the specified certificate store name and location by subject, from its
        /// respective certificate store. 
        /// </summary>
        /// <param name="subject"></param>
        /// <param name="storeName"></param>
        /// <param name="storeLocation"></param>
        public static void UninstallCertificate(string subject, StoreName storeName, StoreLocation storeLocation)
        {
            UninstallCertificate(X509Certificate2Ex.FindCertificate(subject, SearchField.Subject, storeName, storeLocation, OpenFlags.ReadWrite, false));
        }

        /// <summary>
        /// Deletes the specified certificate from its respective certificate store.  The certificate must be opened as
        /// read/write and have been loaded from a valid certificate store in order for this operation to succeed.
        /// </summary>
        /// <param name="certificate"></param>
        public static void UninstallCertificate(X509Certificate2Ex certificate)
        {
            bool success = Crypt32.CertDeleteCertificateFromStore(certificate.Handle);
            if (!success)
            {
                throw new Win32Exception();
            }
        }

        /// <summary>
        /// Deletes the specified certificates from its respective certificate store.  The certificate must be opened as
        /// read/write and have been loaded from a valid certificate store in order for this operation to succeed.
        /// </summary>
        /// <param name="certificate"></param>
        public static void UninstallCertificates(List<X509Certificate2> certificates)
        {
            for (int i = 0; i < certificates.Count; i++)
            {
                bool success = Crypt32.CertDeleteCertificateFromStore(certificates[i].Handle);
                if (!success)
                {
                    throw new Win32Exception();
                }
            }
        }

        /// <summary>
        /// Grants access to the private key material of a certificate, found in the specified certificate store name and location by subject,
        /// to the specified identity (DOMAIN\USERNAME).  The certificate must have a private key to perform this action.
        /// </summary>
        /// <param name="subject"></param>
        /// <param name="storeName"></param>
        /// <param name="storeLocation"></param>
        /// <param name="identity"></param>
        public static void GrantAccessToPrivateKey(string subject, StoreName storeName, StoreLocation storeLocation, string identity)
        {
            GrantAccessToPrivateKey(X509Certificate2Ex.FindCertificate(subject, SearchField.Subject, storeName, storeLocation, OpenFlags.ReadWrite, false), identity);
        }

        /// <summary>
        /// Grants access to the private key material of the specified certificate, to the specified identity (DOMAIN\USERNAME).
        /// The certificate must have a private key to perform this action.  Note: the certificate object should reference a
        /// certificate that is already installed into a certificate store.
        /// </summary>
        /// <param name="certificate"></param>
        /// <param name="identity"></param>
        public static void GrantAccessToPrivateKey(X509Certificate2Ex certificate, string identity)
        {
            if (!certificate.HasPrivateKey)
            {
                throw new ApplicationException("The certificate does not have a private key.");
            }

            FileInfo fileInfo = new FileInfo(certificate.PrivateKeyPath);
            FileSecurity fileSecurity = fileInfo.GetAccessControl(AccessControlSections.Access);
            fileSecurity.AddAccessRule(new FileSystemAccessRule(identity, FileSystemRights.FullControl, AccessControlType.Allow));
            fileInfo.SetAccessControl(fileSecurity);
        }

        /// <summary>
        /// Denies access to the private key material of a certificate, found in the specified certificate store name and location by subject,
        /// to the specified identity (DOMAIN\USERNAME).  The certificate must have a private key to perform this action.
        /// </summary>
        /// <param name="subject"></param>
        /// <param name="storeName"></param>
        /// <param name="storeLocation"></param>
        /// <param name="identity"></param>
        public static void DenyAccessToPrivateKey(string subject, StoreName storeName, StoreLocation storeLocation, string identity)
        {
            DenyAccessToPrivateKey(X509Certificate2Ex.FindCertificate(subject, SearchField.Subject, storeName, storeLocation, OpenFlags.ReadOnly, false), identity);
        }

        /// <summary>
        /// Denies access to the private key material of the specified certificate, to the specified identity (DOMAIN\USERNAME).
        /// The certificate must have a private key to perform this action.  Note: the certificate object should reference a
        /// certificate that is already installed into a certificate store.
        /// </summary>
        /// <param name="certificate"></param>
        /// <param name="identity"></param>
        public static void DenyAccessToPrivateKey(X509Certificate2Ex certificate, string identity)
        {
            if (!certificate.HasPrivateKey)
            {
                throw new ApplicationException("The certificate does not have a private key.");
            }

            FileInfo fileInfo = new FileInfo(certificate.PrivateKeyPath);
            FileSecurity fileSecurity = fileInfo.GetAccessControl(AccessControlSections.Access);
            fileSecurity.RemoveAccessRule(new FileSystemAccessRule(identity, FileSystemRights.FullControl, AccessControlType.Allow));
            fileInfo.SetAccessControl(fileSecurity);
        }

        /// <summary>
        /// Signs data with the private key of the certificate.  Requires that the loaded certificate supports signing and
        /// has access to the private key.  For RSA certificates, SHA1 is used as the hashing algorithm.
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        public byte[] SignData(byte[] data)
        {
            if (!this.HasPrivateKey)
            {
                throw new ApplicationException("The certificate does not have a private key and cannot be used to sign data.");
            }

            byte[] signedData;

            if (this.isRsa)
            {
                signedData = this.privateRsa.SignData(data, this.sha1);
            }
            else
            {
                signedData = this.privateDsa.SignData(data);
            }

            return signedData;
        }

        /// <summary>
        /// Signs data with the private key of the certificate.  Requires that the loaded certificate supports signing and
        /// has access to the private key.  For RSA certificates, SHA1 is used as the hashing algorithm.  The specified
        /// string is turned into an array of bytes using UTF-8 encoding and the resulting signature value is returned as a
        /// base64 string.
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        public string SignData(string data)
        {
            return Convert.ToBase64String(SignData(Encoding.UTF8.GetBytes(data)));
        }

        /// <summary>
        /// Verifies the specified data using the specified signature value, using the public key of the certificate.
        /// For RSA certificates, SHA1 is used as the hashing algorithm.
        /// </summary>
        /// <param name="data"></param>
        /// <param name="signature"></param>
        /// <returns></returns>
        public bool VerifySignature(byte[] data, byte[] signature)
        {
            bool verified;

            if (this.isRsa)
            {
                verified = this.publicRsa.VerifyData(data, this.sha1, signature);
            }
            else
            {
                verified = this.publicDsa.VerifyData(data, signature);
            }

            return verified;
        }

        /// <summary>
        /// Verifies the specified data using the specified signature value, using the public key of the certificate.
        /// For RSA certificates, SHA1 is used as the hashing algorithm.  The specified string is turned into an array of
        /// bytes using UTF-8 encoding.  The signature should be a valid base64 string.
        /// </summary>
        /// <param name="data"></param>
        /// <param name="base64Signature"></param>
        /// <returns></returns>
        public bool VerifySignature(string data, string base64Signature)
        {
            return VerifySignature(Encoding.UTF8.GetBytes(data), Convert.FromBase64String(base64Signature));
        }

        /// <summary>
        /// Encrypts the specified data with the public key of the certificate.  Optimal Asymmetric Encryption Padding (OAEP)
        /// is not used.
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        public byte[] EncryptData(byte[] data)
        {
            return EncryptData(data, false);
        }

        /// <summary>
        /// Encrypts the specified data with the public key of the certificate.  Optionally, Optimal Asymmetric Encryption
        /// Padding (OAEP) can be specified.
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        public byte[] EncryptData(byte[] data, bool useOaep)
        {
            if (this.isRsa)
            {
                return this.privateRsa.Encrypt(data, useOaep);
            }
            else
            {
                throw new ApplicationException("Only RSA certificates can be used to encrypt or decrypt data.");
            }
        }

        /// <summary>
        /// Encrypts the specified data with the public key of the certificate.  Optimal Asymmetric Encryption Padding (OAEP)
        /// is not used.  The specified string is turned into an array of bytes using UTF-8 encoding.  The resulting cipher
        /// is returned as a base64 string.
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        public string EncryptData(string data)
        {
            return Convert.ToBase64String(EncryptData(Encoding.UTF8.GetBytes(data)));
        }

        /// <summary>
        /// Decrypts the specified data with the private key of the certificate.  Requires that the loaded certificate
        /// supports signing and has access to the private key.  Optimal Asymmetric Encryption Padding (OAEP) is not used.
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        public byte[] DecryptData(byte[] data)
        {
            return DecryptData(data, false);
        }

        /// <summary>
        /// Decrypts the specified data with the private key of the certificate.  Requires that the loaded certificate
        /// supports signing and has access to the private key.  Optionally, Asymmetric Encryption Padding (OAEP) can
        /// be specified.
        /// </summary>
        /// <param name="data"></param>
        /// <param name="useOaep"></param>
        /// <returns></returns>
        public byte[] DecryptData(byte[] data, bool useOaep)
        {
            if (!this.HasPrivateKey)
            {
                throw new ApplicationException("The certificate does not have a private key and cannot be used to decrypt data.");
            }

            if (this.isRsa)
            {
                return this.privateRsa.Decrypt(data, useOaep);
            }
            else
            {
                throw new ApplicationException("Only RSA certificates can be used to encrypt or decrypt data.");
            }
        }

        /// <summary>
        /// Decrypts the specified data with the private key of the certificate.  Requires that the loaded certificate
        /// supports signing and has access to the private key.  Optimal Asymmetric Encryption Padding (OAEP) is not used.
        /// The specified cipher should be a valid base64 string.  The resulting decrypted value is returned as a clear-text
        /// string using UTF-8 encoding.
        /// </summary>
        /// <param name="base64String"></param>
        /// <returns></returns>
        public string DecryptData(string base64String)
        {
            return Encoding.UTF8.GetString(DecryptData(Convert.FromBase64String(base64String)));
        }

        /// <summary>
        /// Installs the certificate into the LOCAL_MACHINE\MY certificate store.
        /// </summary>
        /// <returns></returns>
        public void Install()
        {
            InstallCertificate(this);
        }

        /// <summary>
        /// Installs the certificate into the specified certificate store name and location.
        /// </summary>
        /// <param name="storeName"></param>
        /// <param name="storeLocation"></param>
        /// <returns></returns>
        public void Install(StoreName storeName, StoreLocation storeLocation)
        {
            InstallCertificate(this, storeName, storeLocation);
        }

        /// <summary>
        /// Deletes the certificate from its respective certificate store.
        /// </summary>
        public void Uninstall()
        {
            UninstallCertificate(this);
        }

        /// <summary>
        /// Grants access to private key material of the certificate to the specified identity.
        /// </summary>
        /// <param name="identity"></param>
        public void GrantPrivateKeyAccess(string identity)
        {
            GrantAccessToPrivateKey(this, identity);
        }

        /// <summary>
        /// Denies access to private key material of the certificate to the specified identity.
        /// </summary>
        /// <param name="identity"></param>
        public void DenyPrivateKeyAccess(string identity)
        {
            DenyAccessToPrivateKey(this, identity);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public bool IsCertChainInstalled()
        {
            return IsCertChainInstalled(StoreLocation.LocalMachine);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="storeName"></param>
        /// <param name="storeLocation"></param>
        /// <returns></returns>
        public bool IsCertChainInstalled(StoreLocation storeLocation)
        {
            if (this.RootCertificateAuthority == null)
            {
                return false;
            }

            //verify that any intermediate cert(s) are in the Intermediate CA store
            if (this.IntermediateCertificateAuthorities != null)
            {
                for (int i = 0; i < this.IntermediateCertificateAuthorities.Count; i++)
                {
                    if (TryFindCertificate(this.IntermediateCertificateAuthorities[i].Certificate.Thumbprint, SearchField.Thumbprint, StoreName.CertificateAuthority, storeLocation) == null)
                    {
                        return false;
                    }
                }
            }

            //verify that the root cert are in the Intermediate CA store
            return TryFindCertificate(this.RootCertificateAuthority.Certificate.Thumbprint, SearchField.Thumbprint, StoreName.Root, storeLocation) != null;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public bool IsRevoked()
        {
            for (int i = 0; i < this.Status.Length; i++)
            {
                if (this.Status[i].Status == X509ChainStatusFlags.Revoked)
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// 
        /// </summary>
        public void InstallCertChain()
        {
            InstallCertChain(StoreLocation.LocalMachine);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="location"></param>
        public void InstallCertChain(StoreLocation location)
        {
            InstallCertChain(this, location);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="certificate"></param>
        public static void InstallCertChain(X509Certificate2Ex certificate)
        {
            InstallCertChain(certificate, StoreLocation.LocalMachine);
        }

        /// <summary>
        /// 
        /// </summary>
        public static void InstallCertChain(X509Certificate2Ex certificate, StoreLocation location)
        {
            List<X509Certificate2> intermediates = new List<X509Certificate2>(certificate.IntermediateCertificateAuthorities.Count);
            for (int i = 0; i < certificate.IntermediateCertificateAuthorities.Count; i++)
            {
                intermediates.Add(certificate.IntermediateCertificateAuthorities[i].Certificate);
            }

            //install any intermediate CA(s)
            InstallCertificates(intermediates, StoreName.CertificateAuthority, location);

            //install the root CA
            InstallCertificate(certificate.RootCertificateAuthority.Certificate, StoreName.Root, location);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="removeIntermediates"></param>
        /// <param name="removeRoot"></param>
        public void UninstallCertChain(bool removeIntermediates, bool removeRoot)
        {
            UninstallCertChain(StoreLocation.LocalMachine, removeIntermediates, removeRoot);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="location"></param>
        /// <param name="removeIntermediates"></param>
        /// <param name="removeRoot"></param>
        public void UninstallCertChain(StoreLocation location, bool removeIntermediates, bool removeRoot)
        {
            UninstallCertChain(this, location, removeIntermediates, removeRoot);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="certificate"></param>
        public static void UninstallCertChain(X509Certificate2Ex certificate, bool removeIntermediates, bool removeRoot)
        {
            UninstallCertChain(certificate, StoreLocation.LocalMachine, removeIntermediates, removeRoot);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="certificate"></param>
        /// <param name="location"></param>
        /// <param name="removeIntermediates"></param>
        /// <param name="removeRoot"></param>
        public static void UninstallCertChain(X509Certificate2Ex certificate, StoreLocation location, bool removeIntermediates, bool removeRoot)
        {
            if (removeIntermediates)
            {
                //uninstall any intermediate CA(s)
                List<X509Certificate2> intermediates = new List<X509Certificate2>(certificate.IntermediateCertificateAuthorities.Count);
                for (int i = 0; i < certificate.IntermediateCertificateAuthorities.Count; i++)
                {
                    try
                    {
                        X509Certificate2Ex intermediateCACert = X509Certificate2Ex.FindCertificate(certificate.IntermediateCertificateAuthorities[i].Certificate.Thumbprint, SearchField.Thumbprint, StoreName.CertificateAuthority, location, OpenFlags.ReadWrite, true);
                        intermediates.Add(intermediateCACert);
                    }
                    catch (ApplicationException)
                    {
                        //if we can't find the intermediate cert, then it's not installed and thus
                        //a no-op.  Move to the next one...
                    }
                }

                UninstallCertificates(intermediates);
            }

            if (removeRoot)
            {
                try
                {
                    X509Certificate2Ex rootCACert = X509Certificate2Ex.FindCertificate(certificate.RootCertificateAuthority.Certificate.Thumbprint, SearchField.Thumbprint, StoreName.Root, location, OpenFlags.ReadWrite, true);
                    UninstallCertificate(rootCACert);
                }
                catch (ApplicationException)
                {
                    //if we can't find the root cert, then it's not installed and thus
                    //a no-op.  Move to the next one...
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [System.Security.Permissions.PermissionSet(System.Security.Permissions.SecurityAction.LinkDemand, Unrestricted = true)]
        public override void Reset()
        {
            this.canUsePrivateKey = false;
            this.certChain = null;
            this.enhancedKeyUsage = null;
            this.isRsa = false;
            this.keyAlgorithm = null;
            this.keyUsage = X509KeyUsageFlags.None;
            this.privateDsa = null;
            this.privateRsa = null;
            this.publicDsa = null;
            this.publicRsa = null;
            this.sha1 = null;
            this.ski = null;

            base.Reset();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="applicationPolicyOid"></param>
        /// <returns></returns>
        public bool Verify(string applicationPolicyOid)
        {
            return Verify(applicationPolicyOid, X509RevocationMode.Online);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="applicationPolicyOid"></param>
        /// <param name="revocationMode"></param>
        /// <returns></returns>
        public bool Verify(string applicationPolicyOid, X509RevocationMode revocationMode)
        {
            X509ChainStatus[] chainStatus;
            return Verify(applicationPolicyOid, revocationMode, out chainStatus);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="applicationPolicy"></param>
        /// <returns></returns>
        public bool Verify(Oid applicationPolicy)
        {
            return Verify(applicationPolicy, X509RevocationMode.Online);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="applicationPolicy"></param>
        /// <param name="revocationMode"></param>
        /// <returns></returns>
        public bool Verify(Oid applicationPolicy, X509RevocationMode revocationMode)
        {
            X509ChainStatus[] chainStatus;
            return Verify(applicationPolicy, revocationMode, out chainStatus);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="applicationPolicyOid"></param>
        /// <param name="chainStatus"></param>
        /// <returns></returns>
        public bool Verify(string applicationPolicyOid, X509RevocationMode revocationMode, out X509ChainStatus[] chainStatus)
        {
            OidCollection applicationPolicies = new OidCollection();
            applicationPolicies.Add(new Oid(applicationPolicyOid));
            return Verify(revocationMode, X509RevocationFlag.ExcludeRoot, X509VerificationFlags.NoFlag, applicationPolicies, null, out chainStatus);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="applicationPolicies"></param>
        /// <param name="chainStatus"></param>
        /// <returns></returns>
        public bool Verify(Oid applicationPolicy, X509RevocationMode revocationMode, out X509ChainStatus[] chainStatus)
        {
            OidCollection applicationPolicies = new OidCollection();
            applicationPolicies.Add(applicationPolicy);
            return Verify(revocationMode, X509RevocationFlag.ExcludeRoot, X509VerificationFlags.NoFlag, applicationPolicies, null, out chainStatus);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="revocationMode"></param>
        /// <param name="revocationFlag"></param>
        /// <param name="verificationFlags"></param>
        /// <param name="applicationPolicies"></param>
        /// <param name="certificatePolicies"></param>
        /// <param name="chainStatus"></param>
        /// <returns></returns>
        public bool Verify(X509RevocationMode revocationMode, X509RevocationFlag revocationFlag, X509VerificationFlags verificationFlags, OidCollection applicationPolicies, OidCollection certificatePolicies, out X509ChainStatus[] chainStatus)
        {
            X509Chain chain = new X509Chain();
            chain.ChainPolicy = new X509ChainPolicy();
            chain.ChainPolicy.RevocationMode = revocationMode;
            chain.ChainPolicy.RevocationFlag = revocationFlag;
            chain.ChainPolicy.VerificationFlags = X509VerificationFlags.NoFlag;

            if (applicationPolicies != null)
            {
                for (int i = 0; i < applicationPolicies.Count; i++)
                {
                    chain.ChainPolicy.ApplicationPolicy.Add(applicationPolicies[i]);
                }
            }

            if (certificatePolicies != null)
            {
                for (int i = 0; i < certificatePolicies.Count; i++)
                {
                    chain.ChainPolicy.CertificatePolicy.Add(certificatePolicies[i]);
                }
            }

            chain.Build(this);
            chainStatus = chain.ChainStatus;
            return chain.ChainStatus.Length == 0;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="oid"></param>
        /// <returns></returns>
        public bool HasEnhancedKeyUsage(string oid)
        {
            for (int i = 0; i < this.EnhancedKeyUsage.Count; i++)
            {
                if (this.EnhancedKeyUsage[i].Value == oid)
                    return true;
            }

            return false;
        }

        /// <summary>
        /// 
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="disposing"></param>
        protected void Dispose(bool disposing)
        {
            if (!this.isDisposed)
            {
                if (disposing)
                {
                    if (this.sha1 != null)
                        this.sha1.Clear();
                }

                this.isDisposed = true;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="certificate"></param>
        /// <returns></returns>
        protected void GetCertificateExtensions()
        {
            for (int i = 0; i < this.Extensions.Count; i++)
            {
                if (this.Extensions[i] is X509SubjectKeyIdentifierExtension)
                {
                    this.ski = (this.Extensions[i] as X509SubjectKeyIdentifierExtension).SubjectKeyIdentifier;
                }
                else if (this.Extensions[i] is X509KeyUsageExtension)
                {
                    this.keyUsage |= (this.Extensions[i] as X509KeyUsageExtension).KeyUsages;
                }
                else if (this.Extensions[i] is X509EnhancedKeyUsageExtension)
                {
                    X509EnhancedKeyUsageExtension enhancedKeyUsage = this.Extensions[i] as X509EnhancedKeyUsageExtension;
                    Oid[] usages = new Oid[enhancedKeyUsage.EnhancedKeyUsages.Count];
                    enhancedKeyUsage.EnhancedKeyUsages.CopyTo(usages, 0);
                    this.enhancedKeyUsage.AddRange(usages);
                }
            }
        }

        /// <summary>
        /// Returns the unique name of the key container that contains the private key.
        /// </summary>
        /// <returns></returns>
        protected string GetPrivateKeyContainerName()
        {
            if (this.HasPrivateKey)
            {
                if (this.isRsa)
                {
                    return this.privateRsa.CspKeyContainerInfo.UniqueKeyContainerName;
                }
                else
                {
                    return this.privateDsa.CspKeyContainerInfo.UniqueKeyContainerName;
                }
            }

            throw new ApplicationException("The certificate does not have a private key.");
        }

        /// <summary>
        /// Returns the full file path where the private key is located.
        /// </summary>
        /// <returns></returns>
        protected string GetPrivateKeyPath()
        {
            string cryptoPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData), @"Microsoft\Crypto\");
            string keyFile = GetPrivateKeyContainerName();
            string[] files = Directory.GetFiles(cryptoPath, keyFile, SearchOption.AllDirectories);

            if (files.Length > 0)
            {
                return files[0];
            }

            cryptoPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), @"Microsoft\Crypto\");
            files = Directory.GetFiles(cryptoPath, keyFile, SearchOption.AllDirectories);

            if (files.Length > 0)
            {
                return files[0];
            }

            throw new ApplicationException("Unable to find the filepath of the private key; it exists but is not accessible.");
        }

        /// <summary>
        /// 
        /// </summary>
        protected void BuildCertChain()
        {
            this.certChain = new List<X509ChainElement>();
            X509Chain chain = new X509Chain();
            chain.Build(this);

            for (int i = 0; i < chain.ChainElements.Count; i++)
            {
                this.certChain.Add(chain.ChainElements[i]);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        private void InternalConstructor()
        {
            GetCertificateExtensions();

            Oid oid = new Oid(this.GetKeyAlgorithm());
            this.keyAlgorithm = oid.FriendlyName;
            this.sha1 = new SHA1CryptoServiceProvider();

            if (this.keyAlgorithm.Equals("RSA", StringComparison.OrdinalIgnoreCase))
            {
                this.isRsa = true;
                this.publicRsa = this.PublicKey.Key as RSACryptoServiceProvider;
            }
            else if (this.keyAlgorithm.Equals("DSA", StringComparison.OrdinalIgnoreCase))
            {
                this.isRsa = false;
                this.publicDsa = this.PublicKey.Key as DSACryptoServiceProvider;
            }
            else
            {
                throw new ApplicationException(String.Format("The specified key algorithm, {0}, with ID {1} is currently unsupported.", this.keyAlgorithm, oid.Value));
            }

            if (this.HasPrivateKey)
            {
                try
                {
                    if (this.isRsa)
                    {
                        this.privateRsa = this.PrivateKey as RSACryptoServiceProvider;
                    }
                    else
                    {
                        this.privateDsa = this.PrivateKey as DSACryptoServiceProvider;
                    }

                    this.canUsePrivateKey = true;
                }
                catch (CryptographicException)
                {
                    //can't access key set...
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\CommonLib\Forms\ListViewExBase.cs ===
#region Using Directives

using System;
using System.Collections;
using System.Windows.Forms;
using System.Drawing;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Security.Permissions;
using LiveN.Test.Common.Win32;
using System.Runtime.InteropServices;

#endregion

namespace LiveN.Test.Common.Forms
{
	///////////////////////////////////////////////////////////////////////////////////////////////
	///	<summary>
	///	
	///	</summary>
	public class ListViewExBase	: System.Windows.Forms.ListView
	{
		#region Variable Declarations

		private System.ComponentModel.Container components;
		private ToolTip hoverText;
		private StringFormat format;
		private int hoverTextSubItemIndex;
		private int hoverTextItemIndex;
		private bool resizeLastColumn;
				
		#endregion

		#region Constructors
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public ListViewExBase()
		{
			InitializeComponent();

			this.hoverText = new ToolTip(this.components);
			this.hoverText.InitialDelay = 0;
			this.hoverText.ReshowDelay = 0;

			this.format = new StringFormat(StringFormat.GenericDefault);
			this.format.Alignment = StringAlignment.Near;
			this.format.LineAlignment = StringAlignment.Near;
			this.format.Trimming = StringTrimming.Character;
			this.format.FormatFlags = 0;

			base.FullRowSelect = true;
			base.View = View.Details;
			base.AllowColumnReorder = true;
		}
		#endregion
		
		#region Public Properties
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		[
			Category("Behavior"),
			Description("Indicates whether or not the last column of the ListView should be automatically resized to fit the size of the control."),
			Browsable(true),
			DefaultValue(false)
		]
		public bool AutoResizeLastColumn
		{
			get
			{
				return resizeLastColumn;
			}
			set
			{
				resizeLastColumn = value;
			}
		}
		#endregion

		#region Protected Methods
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="m"></param>
		[PermissionSet(SecurityAction.Demand, Name="FullTrust")]
		protected override void WndProc(ref Message m)
		{
			switch(m.Msg)
			{
				case (int)WindowsMessage.Paint:
				{
					if((this.resizeLastColumn) && (this.Columns.Count > 0))
					{
						this.Columns[this.Columns.Count - 1].Width = -2;
					}
					break;
				}
			}

			base.WndProc(ref m);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="e"></param>
		protected override void OnMouseMove(MouseEventArgs e)
		{
			ListViewItem row = this.GetItemAt(e.X, e.Y);
				
			if(row != null)
			{
				int start = e.X;
				int SPosition = 0;
				int EPosition = this.Columns[0].Width;
				int subItemSelected = 0;
				for(int i=1; i<=this.Columns.Count; i++)
				{
					if((start > SPosition) && (start < EPosition))
					{
						subItemSelected = i-1;
						break;
					}
					SPosition = EPosition;
					if(i < this.Columns.Count)
					{
						EPosition += this.Columns[i].Width;
					}		
				}
				
				bool show = (subItemSelected != this.hoverTextSubItemIndex);
				if((subItemSelected < row.SubItems.Count) && (show || (!show && (row.Index != this.hoverTextItemIndex))))
				{
					SizeF ts;

					using(Graphics g = this.CreateGraphics())
					{
						ts = g.MeasureString(row.SubItems[subItemSelected].Text, this.Font, Screen.PrimaryScreen.WorkingArea.Width - this.Left, format);
					}

					if(ts.Width > this.Columns[subItemSelected].Width - 6)	//only display tooltip if it's hidden... 6 is an arbitrary value!
					{
						this.hoverText.SetToolTip(this, row.SubItems[subItemSelected].Text);
					}
					else
					{
						this.hoverText.SetToolTip(this, "");
					}

					this.hoverTextItemIndex = row.Index;
					this.hoverTextSubItemIndex = subItemSelected;
				}
			}
			else
			{
				this.hoverText.SetToolTip(this, "");
				this.hoverTextItemIndex = 0;
				this.hoverTextSubItemIndex = 0;
			}

			base.OnMouseMove (e);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="e"></param>
		protected override void OnMouseLeave(EventArgs e)
		{
			this.hoverText.SetToolTip(this, "");
			base.OnMouseLeave(e);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		///	<summary>
		///	Clean up any resources being used.
		///	</summary>
		protected override void	Dispose(bool disposing)
		{
			if(disposing)
			{
				if(this.components != null)
				{
					this.components.Dispose();
				}

				if(this.format != null)
				{
					this.format.Dispose();
				}
			}

			base.Dispose(disposing);
		}
		#endregion

		#region Private Methods
		
			#region Initialization

				#region Component Designer generated code
		///////////////////////////////////////////////////////////////////////////////////////////////
		///	<summary>
		///	Required method	for	Designer support - do not modify 
		///	the	contents of	this method	with the code editor.
		///	</summary>
		private	void InitializeComponent()
		{
			components = new System.ComponentModel.Container();
		}
			#endregion

		

		#endregion

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\CommonLib\Forms\TextBoxTraceListener.cs ===
﻿using System;
using System.Collections;
using System.Diagnostics;
using System.Text;
using System.Windows.Forms;

namespace LiveN.Test.Common.Forms
{
    /// <summary>
    /// 
    /// </summary>
    public class TextBoxTraceListener: TraceListener
    {
        /// <summary>
        /// 
        /// </summary>
        public TextBoxTraceListener()
            : this(true)
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="showSource"></param>
        public TextBoxTraceListener(bool showSource)
        {

        }

        /// <summary>
        /// 
        /// </summary>
        public TextBox TextBox
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public bool ShowSource
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="eventCache"></param>
        /// <param name="source"></param>
        /// <param name="eventType"></param>
        /// <param name="id"></param>
        /// <param name="message"></param>
        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message)
        {
            if ((this.Filter != null) && !this.Filter.ShouldTrace(eventCache, source, eventType, id, message, null, null, null))
                return;

            this.WriteHeader(source, eventType, id);
            WriteLine(message);
            this.WriteFooter(eventCache);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="eventCache"></param>
        /// <param name="source"></param>
        /// <param name="eventType"></param>
        /// <param name="id"></param>
        /// <param name="format"></param>
        /// <param name="args"></param>
        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string format, params object[] args)
        {
            TraceEvent(eventCache, source, eventType, id, String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void WriteIndent()
        {
            this.NeedIndent = false;
            for (int i = 0; i < this.IndentLevel; i++)
            {
                for (int j = 0; j < this.IndentSize; j++)
                    this.Write("\t");
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="source"></param>
        /// <param name="type"></param>
        /// <param name="id"></param>
        protected virtual void WriteHeader(string source, TraceEventType type, int id)
        {
            StringBuilder header = new StringBuilder();
            if (this.ShowSource)
                header.AppendFormat("{0} ", source);
            header.AppendFormat("{0}: ", type);
            if (id != 0)
                header.AppendFormat("{0}: ", id);
            this.Write(header.ToString());
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="cache"></param>
        protected virtual void WriteFooter(TraceEventCache eventCache)
        {
            if (eventCache != null)
            {
                base.IndentLevel++;
                if (this.IsEnabled(TraceOptions.ProcessId))
                {
                    this.WriteLine("ProcessId=" + eventCache.ProcessId);
                }
                if (this.IsEnabled(TraceOptions.LogicalOperationStack))
                {
                    this.Write("LogicalOperationStack=");
                    Stack logicalOperationStack = eventCache.LogicalOperationStack;
                    bool flag = true;
                    foreach (object obj2 in logicalOperationStack)
                    {
                        if (!flag)
                        {
                            this.Write(", ");
                        }
                        else
                        {
                            flag = false;
                        }
                        this.Write(obj2.ToString());
                    }
                    this.WriteLine(string.Empty);
                }
                if (this.IsEnabled(TraceOptions.ThreadId))
                {
                    this.WriteLine("ThreadId=" + eventCache.ThreadId);
                }
                if (this.IsEnabled(TraceOptions.DateTime))
                {
                    //this POS is in UTC; convert to local
                    DateTime local = TimeZoneInfo.ConvertTimeFromUtc(eventCache.DateTime, TimeZoneInfo.Local);
                    this.WriteLine("DateTime=" + local.ToString("MM/dd/yyyy hh:mm:ss.ffff tt"));
                }
                if (this.IsEnabled(TraceOptions.Timestamp))
                {
                    this.WriteLine("Timestamp=" + eventCache.Timestamp);
                }
                if (this.IsEnabled(TraceOptions.Callstack))
                {
                    this.WriteLine("Callstack=" + eventCache.Callstack);
                }
                base.IndentLevel--;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="opts"></param>
        /// <returns></returns>
        protected bool IsEnabled(TraceOptions opts)
        {
            return ((opts & this.TraceOutputOptions) != TraceOptions.None);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public override void Write(string message)
        {
            WriteText(message);
        }

        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public override void WriteLine(string message)
        {
            WriteText(message + Environment.NewLine);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        private void WriteText(string message)
        {
            if (this.TextBox.InvokeRequired)
            {
                this.TextBox.BeginInvoke(new Action<string>(WriteText), message);
            }
            else
            {
                this.TextBox.AppendText(message);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\CommonLib\Web\RestException.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveN.Test.Common.Web
{
    /// <summary>
    /// 
    /// </summary>
    public class RestException: Exception
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="response"></param>
        public RestException(RestResponse response): this(response, String.IsNullOrEmpty(response.Body) ? response.ToString(): response.Body)
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="response"></param>
        /// <param name="message"></param>
        public RestException(RestResponse response, string message): this(response, message, null)
        {
            
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="response"></param>
        /// <param name="message"></param>
        /// <param name="innerException"></param>
        public RestException(RestResponse response, string message, Exception innerException): base(message, innerException)
        {
            this.Response = response;
        }

        /// <summary>
        /// 
        /// </summary>
        public RestResponse Response
        {
            get;
            protected set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return this.Response.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\CommonLib\Win32\Crypt32.cs ===
#region Using Directives

using System;
using System.Runtime.InteropServices;

#endregion

namespace LiveN.Test.Common.Win32
{
	#region Public Enums
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// 
	/// </summary>
	[Flags]
	public enum CryptProtectFlags
	{
		CryptProtectUIForbidden = 0x1,
		CryptProtectLocalMachine = 0x4,
		CryptProtectCredSync = 0x8,
		CryptProtectAudit = 0x10,
		CryptProtectNoRecovery = 0x20,
		CryptProtectVerifyProtection = 0x40,
		CryptProtectCredRegenerate = 0x80,
	}

	/// <summary>
	/// 
	/// </summary>
	public enum CertificateEncoding : int
	{
		X509AsnEncoding = 0x1,
		Pkcs7AsnEncoding = 0x00010000,
	}

	/// <summary>
	/// 
	/// </summary>
	public enum CertStoreAddDisposition : int
	{
		/// <summary>
		/// If a matching certificate or a link to a matching certificate exists in the store, the operation fails. The GetLastError function returns the CRYPT_E_EXISTS code.
		/// </summary>
		AddNew = 1,
		/// <summary>
		/// If a matching certificate or a link to a matching certificate exists, that existing certificate or link is used and properties from the new certificate are added. The function does not fail, but it does not add a new context. If ppCertContext is not NULL, the existing context is duplicated. 
		/// If a matching certificate or link to a matching certificate does not exist, a new certificate is added.
		/// </summary>
		AddUseExisting = 2,
		/// <summary>
		/// If a matching certificate or link to a matching certificate exists in the store, the existing certificate or link is deleted and a new certificate is created and added to the store. If a matching certificate or link to a matching certificate does not exist, a new certificate is created and added to the store.
		/// </summary>
		AddReplaceExisting = 3,
		/// <summary>
		/// The function makes no check for an existing matching certificate or link to a matching certificate. A new certificate is always added to the store. This can lead to duplicates in a store.
		/// </summary>
		AddAlways = 4,
		/// <summary>
		/// If a matching certificate exists in the store, that existing context is deleted before creating and adding the new context. The new context inherits properties from the existing certificate.
		/// </summary>
		AddReplaceExistingInheritProperties = 5,
		/// <summary>
		/// If a matching certificate or a link to a matching certificate exists, the function compares the NotBefore times on the certificates. If the existing certificate has a NotBefore time less than the NotBefore time on the new certificate, the old certificate or link is replaced just as with CERT_STORE_ADD_REPLACE_EXISTING. If the existing certificate has a NotBefore time greater than or equal to the NotBefore time on the certificate to be added, the function fails with the GetLastError function returning the CRYPT_E_EXISTS code. 
		/// If a matching certificate or a link to a matching certificate is not found in the store, a new certificate is added to the store.
		/// </summary>
		AddNewer = 6,
		/// <summary>
		/// The action is the same as for CERT_STORE_ADD_NEWER, except that if an older certificate is replaced, the properties of the older certificate are incorporated into the replacement certificate.
		/// </summary>
		AddNewerInheritProperties = 7,
	}
	#endregion

	#region Public Stucts

		#region DataBlob Struct
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	///		The CryptoAPI CRYPTOAPI_BLOB structure is used for an arbitrary array of
	///		bytes. It is declared in Wincrypt.h and provides flexibility for objects
	///		that can contain various data types.
	/// </summary>
	[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
	public struct DataBlob : IDisposable
	{
		#region Variable Declarations
		/// <summary>
		///		Count of bytes in the buffer pointed to by pbData.
		/// </summary>
		private int cbData;
		/// <summary>
		///		Pointer to a block of data bytes.
		/// </summary>
		private IntPtr pbData;

		#endregion

		#region Constructors
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		///		Initializes a new instance of DataBlob.
		/// </summary>
		/// <param name="data">Array of data to place in the DataBlob.</param>
		/// <remarks>
		///		Since the data must be passed to unmanaged code, this constructor
		///		copies the managed data to an unmanaged buffer and stores the
		///		pointer of the buffer.
		/// </remarks>
		public DataBlob(byte[] data)
		{
			cbData = data.Length;
			pbData = Marshal.AllocHGlobal(cbData);
			Marshal.Copy(data, 0, pbData, cbData);
		}
		#endregion

		#region Public Methods
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		///		Returns the data located in the buffer pointer pbData.
		///		This data is typically set by unmanaged code. The data is copied
		///		to a managed array, which is in turn passed to the calling code.
		/// </summary>
		/// <returns>The data located in the buffer pointer pbData.</returns>
		public byte[] GetData()
		{
			if (pbData == IntPtr.Zero)
				return null;
			else
			{
				byte[] data = new byte[cbData];
				Marshal.Copy(pbData, data, 0, cbData);
				return data;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		///		Frees the data buffer pointed to by the pbData member.
		/// </summary>
		/// <remarks>
		///		This structure supports Dispose for convenience, but calling
		///		an interface member (Dispose) will cause boxing. The Close
		///		method doesn't require boxing.
		/// </remarks>
		public void Close()
		{
			if (pbData != IntPtr.Zero)
			{
				Kernel32.ZeroMemory(pbData, cbData);
				Marshal.FreeHGlobal(pbData);
				pbData = IntPtr.Zero;
				cbData = 0;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		///		Frees the data buffer pointed to by the pbData member.
		/// </summary>
		/// <remarks>
		///		This structure supports Dispose for convenience, but calling
		///		an interface member (Dispose) will cause boxing. The Close
		///		method doesn't require boxing.
		/// </remarks>
		public void Dispose()
		{
			Close();
		}
		#endregion
	}
		#endregion

		#region CryptProtectPromptStruct
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	///		The CryptProtectPromptStruct structure provides the text of a prompt
	///		and information about when and where that prompt is to be displayed
	///		when using the CryptProtectData and CryptUnprotectData functions.
	/// </summary>
	[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
	public struct CryptProtectPromptStruct
	{
		/// <summary>
		///		Size of this structure in bytes.
		/// </summary>
		public int cbSize;
		/// <summary>
		///		DWORD flags that indicate when prompts to the user are to be displayed.
		/// </summary>
		public int dwPromptFlags;
		/// <summary>
		///		Window handle to the parent window.
		/// </summary>
		public IntPtr hwndApp;
		/// <summary>
		///		A string containing the text of a prompt to be displayed.
		/// </summary>
		public String szPrompt;
	}
		#endregion

	#endregion

	#region Crypt32 Class
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Summary description for Crypt32.
	/// </summary>
	public class Crypt32
	{
		//HRESULTs found in winerror.h
		/// <summary>
		/// The object or property already exists. (0x80092005)
		/// </summary>
		public const int CryptEExists = -2146885627;        //0x80092005
        public const int CryptENoKeyProperty = -2146885621; //0x8009200B;
        public const int CryptOaep = 0x00000040;
        public const int ProvRsaFull = 1;
        public const string MsBaseProvider = "Microsoft Base Cryptographic Provider v1.0";
        public const string MsEnhancedProvider = "Microsoft Enhanced Cryptographic Provider v1.0";
        public const int CryptNewKeyset = 0x00000008;
        public const int AlgClassDataEncrypt = (3 << 13);
        public const int AlgTypeBlock = (3 << 9);
        public const int AlgSid3Des = 3;
        public const int Calg3Des = (AlgClassDataEncrypt | AlgTypeBlock | AlgSid3Des);
        public const int _192BitKeySize = 0x00C00000;
        public const int CryptExportable = 0x00000001;
        public const int PlainTextKeyBlob = 0x8;

		#region Constructors
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		protected Crypt32()
		{
			
		}
		#endregion

		#region Public Methods
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		///		The CryptProtectData function performs encryption on the data in a
		///		DataBlob structure.
		/// </summary>
		/// <param name="pDataIn">
		///		Pointer to a DataBlob structure containing the plaintext to be encrypted.
		///	</param>
		/// <param name="szDataDescr">
		///		String with a readable description of the data to be encrypted. This 
		///		description string is included with the encrypted data. This parameter is 
		///		optional and can be set to NULL with Windows XP and later. It is required 
		///		and cannot be set to NULL before Windows XP.
		///	</param>
		/// <param name="pOptionalEntropy">
		///		Pointer to a DataBlob structure that contains a password or other
		///		additional entropy used to encrypt the data. The DataBlob structure used
		///		in the encryption phase must also be used in the decryption phase. This
		///		parameter can be set to NULL for no additional entropy.
		/// </param>
		/// <param name="pvReserved">Reserved for future use and must be set to NULL.</param>
		/// <param name="pPromptStruct">
		///		Pointer to a CryptProtectPromptStruct structure that provides information
		///		about where and when prompts are to be displayed and what the content of
		///		those prompts should be. The parameter is optional and can be set to NULL
		///		in both the encryption and decryption phases.
		/// </param>
		/// <param name="dwFlags">
		///		See the CRYPTPROTECT_UI_FORBIDDEN and CRYPTPROTECT_LOCAL_MACHINE constants.
		/// </param>
		/// <param name="pDataOut">
		///		Pointer to a DataBlob structure that receives the encrypted data.
		/// </param>
		/// <returns>
		///		If the function succeeds, the return value is TRUE.
		///		If the function fails, the return value is FALSE. For extended error
		///		information, call GetLastError.
		/// </returns>
		/// <remarks>
		///		Typically, only a user with the same logon credential as the 
		///		encrypter can decrypt the data. In addition, the encryption and 
		///		decryption usually must be done on the same computer.
		/// </remarks>
		[DllImport("Crypt32.dll", SetLastError=true, CharSet=CharSet.Unicode)]
		public static extern bool CryptProtectData(
			[In()]ref DataBlob pDataIn,
			[In()]string szDataDescr, 
			[In()]ref DataBlob pOptionalEntropy,
			[In()]IntPtr pvReserved, 
			[In()]ref CryptProtectPromptStruct pPromptStruct,
			[In()]int dwFlags, 
			ref DataBlob pDataOut);

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		///		The CryptUnprotectData function decrypts and does an integrity check of
		///		the data in a DataBlob structure. Usually, only a user with the same
		///		logon credentials as the encrypter can decrypt the data. In addition,
		///		the encryption and decryption must be done on the same computer.
		/// </summary>
		/// <param name="pDataIn">
		///		Pointer to a DataBlob structure that holds the encrypted data. The 
		///		DataBlob structure's cbData member holds the length of the pbData 
		///		member's byte string that contains the text to be encrypted.
		/// </param>
		/// <param name="szDataDescr">
		///		Pointer to a string readable description of the encrypted data included
		///		with the encrypted data is placed. This parameter is optional and can be
		///		set to NULL.
		/// </param>
		/// <param name="pOptionalEntropy">
		///		Pointer to a DataBlob structure containing a password or other additional
		///		entropy used when the data was encrypted. This parameter is optional and
		///		can be set to NULL; however, if an optional entropy DataBlob structure
		///		was used in the encryption phase, that same DataBlob structure must be
		///		used for the decryption phase.
		/// </param>
		/// <param name="pvReserved">Reserved for future use and must be set to NULL.</param>
		/// <param name="pPromptStruct">
		///		Pointer to a CryptProtectPromptStruct structure that provides information
		///		about where and when prompts are to be displayed and what the content of
		///		those prompts should be. This parameter is optional and can be set to NULL.
		/// </param>
		/// <param name="dwFlags">
		///		See the CRYPTPROTECT_UI_FORBIDDEN and CRYPTPROTECT_LOCAL_MACHINE constants.
		/// </param>
		/// <param name="pDataOut">
		///		Pointer to a DataBlob structure where the function stores the decrypted data.
		/// </param>
		/// <returns></returns>
		[DllImport("Crypt32.dll", SetLastError=true, CharSet=CharSet.Unicode)]
		public static extern bool CryptUnprotectData(
			[In()]ref DataBlob pDataIn,
			string szDataDescr,
			[In()]ref DataBlob pOptionalEntropy,
			[In()]IntPtr pvReserved, 
			[In()]ref CryptProtectPromptStruct pPromptStruct,
			[In()]int dwFlags, 
			ref DataBlob pDataOut);

		/// <summary>
		/// 
		/// </summary>
		/// <param name="hCertStore"></param>
		/// <param name="certEncodingType"></param>
		/// <param name="certEncoded"></param>
		/// <param name="certEncodedSize"></param>
		/// <param name="addDisposition"></param>
		/// <param name="certContext"></param>
		/// <returns></returns>
		[DllImport("Crypt32.dll", SetLastError = true)]
		public static extern bool CertAddEncodedCertificateToStore(
			[In] IntPtr hCertStore,
			[In] CertificateEncoding certEncodingType,
			[In] byte[] certEncoded,
			[In] int certEncodedSize,
		    [In] CertStoreAddDisposition addDisposition,
			[Out] IntPtr certContext);

		/// <summary>
		/// 
		/// </summary>
		/// <param name="certContext"></param>
		/// <returns></returns>
		[DllImport("Crypt32.dll", SetLastError = true)]
		public static extern bool CertDeleteCertificateFromStore([In] IntPtr certContext);

		/// <summary>
		/// 
		/// </summary>
		/// <param name="certContext"></param>
		/// <returns></returns>
		[DllImport("Crypt32.dll", SetLastError = true)]
		public static extern bool CertFreeCertificateContext([In] IntPtr certContext);

		/// <summary>
		/// 
		/// </summary>
		/// <param name="certEncodingType"></param>
		/// <param name="certEncoded"></param>
		/// <param name="certEncodedSize"></param>
		/// <returns></returns>
		[DllImport("Crypt32.dll", SetLastError = true)]
		public static extern IntPtr CertCreateCertificateContext(
			CertificateEncoding certEncodingType,
			byte[] certEncoded,
			int certEncodedSize);

		/// <summary>
		/// 
		/// </summary>
		/// <param name="hCertStore"></param>
		/// <param name="certContext"></param>
		/// <param name="addDisposition"></param>
		/// <param name="certContext"></param>
		/// <returns></returns>
		[DllImport("Crypt32.dll", SetLastError = true)]
		public static extern bool CertAddCertificateContextToStore(
			IntPtr hCertStore,
			IntPtr certContext,
			[In] CertStoreAddDisposition addDisposition,
		    [Out] IntPtr pCertContext);

        /// <summary>
        /// Duplicates a certificate context by incrementing its reference count
        /// </summary>
        /// <param name="certContext">Pointer to the CERT_CONTEXT structure to duplicate.</param>
        /// <returns>Currently, a copy is not made of the context, and the returned pointer to a context has the same value as the pointer to a context that was input. If the pointer passed into this function is NULL, NULL is returned.</returns>
        [DllImport("Crypt32.dll", SetLastError = true)]
        public static extern IntPtr CertDuplicateCertificateContext(IntPtr certContext);

        /// <summary>
        /// Duplicates a store handle by incrementing the store's reference count.
        /// </summary>
        /// <param name="certStoreContext">Handle to the certificate store to duplicate.</param>
        /// <returns>Currently, a copy is not made of the handle and the returned handle is the same as the handle that was input. If NULL is passed in, the called function will raise an access violation exception.</returns>
        [DllImport("Crypt32.dll", SetLastError = true)]
        public static extern IntPtr CertDuplicateStore(IntPtr certStoreContext);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="hCryptProv"></param>
        /// <param name="dwCertEncodingType"></param>
        /// <param name="pInfo"></param>
        /// <param name="phKey"></param>
        /// <returns></returns>
        [DllImport("Crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern bool CryptImportPublicKeyInfo(
            IntPtr hCryptProv,
            CertificateEncoding dwCertEncodingType,
            IntPtr pInfo,
            ref IntPtr phKey);

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pCert"></param>
        /// <param name="dwFlags"></param>
        /// <param name="pvReserved"></param>
        /// <param name="phCryptProv"></param>
        /// <param name="pdwKeySpec"></param>
        /// <param name="pfCallerFreeProv"></param>
        /// <returns></returns>
        [DllImport("Crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern bool CryptAcquireCertificatePrivateKey(
            IntPtr pCert,
            uint dwFlags,
            IntPtr pvReserved,
            out IntPtr phCryptProv,
            out uint pdwKeySpec,
            out bool pfCallerFreeProv);

		#endregion
	}
	#endregion	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\CommonLib\Web\RestResponse.cs ===
﻿using System;
using System.Collections.Generic;
using System.Net;
using System.Text;

namespace LiveN.Test.Common.Web
{
    /// <summary>
    /// 
    /// </summary>
    public class RestResponse
    {
        /// <summary>
        /// 
        /// </summary>
        public RestResponse()
        {
            this.Headers = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        }

        /// <summary>
        /// 
        /// </summary>
        public Uri ResponseUri
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public HttpStatusCode Status
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string ContentType
        {
            get
            {
                return this.Headers["Content-Type"];
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public string Body
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public Dictionary<string, string> Headers
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string StatusDescription
        {
            get;
            set;
        }        

        /// <summary>
        /// 
        /// </summary>
        public bool Succeeded
        {
            get
            {
                return ((this.Status == HttpStatusCode.OK )|| (this.Status == HttpStatusCode.Accepted));
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public bool CorrectContentType
        {
            get
            {
                return this.ContentType.Contains("application/xml");
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            StringBuilder trace = new StringBuilder();
            trace.AppendFormat("HTTP/1.1 {0} {1}\r\n", (int)this.Status, this.Status);
            
            foreach(string key in this.Headers.Keys)
                trace.AppendFormat("{0}: {1}\r\n", key, this.Headers[key]);

            trace.Append("\r\n" + this.Body);
            return trace.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\CommonLib\Win32\Kernel32.cs ===
#region Using Directives

using System;
using System.Runtime.InteropServices;
using System.Text;

#endregion

namespace LiveN.Test.Common.Win32
{
	#region Public Enums
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// 
	/// </summary>
	[Flags]
	public enum FormatMessageFlags
	{
		FormatMessageAllocateBuffer = 0x00000100,
		/// <summary>
		/// Ignores the arguments parameter of the FormatMessage function
		/// </summary>
		FormatMessageIgnoreInserts = 0x00000200,
		FormatMessageFromString = 0x00000800,
		/// <summary>
		/// Causes FormatMessage to search the system table of error codes
		/// </summary>
		FormatMessageFromSystem = 0x00001000,
		FormatMessageArgumentArray = 0x00002000,
	}
	#endregion

	#region Public Structs
	/// <summary>
	/// 
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct SecurityAttributes
	{
		public int Length;
		public IntPtr lpSecurityDescriptor;
		public bool bInheritHandle;
	}
	#endregion

	#region Kernel32 Class
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Summary description for Kernel32.
	/// </summary>
	public static class Kernel32
	{
		#region Constants

		public const int STD_INPUT_HANDLE = -10;
		public const int STD_ERROR_HANDLE = -12;

		#endregion

		#region Public Methods
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		///		Fills a memory buffer with zeroes.
		/// </summary>
		/// <param name="ptr">Pointer to the memory buffer to be filled with zeroes.</param>
		/// <param name="cnt">Number of bytes in the buffer.</param>
		[DllImport("kernel32.dll", EntryPoint="RtlZeroMemory")]
		public static extern void ZeroMemory([In()]IntPtr ptr, [In()]int cnt);

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		///		Formats and returns string messages
		/// </summary>
		/// <param name="dwFlags">See FORMAT_MESSAGE_IGNORE_INSERTS and FORMAT_MESSAGE_FROM_SYSTEM</param>
		/// <param name="lpSource">
		///		Pointer to source string, or module handle containing message specified by MessageId
		///	</param>
		/// <param name="dwMessageId">Identifier to the message</param>
		/// <param name="dwLanguageId">
		///		Language identifier used to return localized messages. Passing 0 causes FormatMessage
		///		to search for the neutral ID, followed by the current language ID (for the thread), 
		///		and then default user and system language ID, followed by the ID for English U.S.
		/// </param>
		/// <param name="lpBuffer">Pointer to the buffer to be filled with the resulting message</param>
		/// <param name="nSize">Size of the buffer pointed to by lpBuffer</param>
		/// <param name="Arguments">Optional insertion arguments</param>
		/// <returns></returns>
		[DllImport("kernel32.dll", SetLastError=true, EntryPoint="FormatMessageW", CharSet=CharSet.Auto)]
		public static extern int FormatMessage(
			[In()]int dwFlags,
			[In()]IntPtr lpSource,
			[In()]int dwMessageId,
			[In()]int dwLanguageId,
			StringBuilder lpBuffer,
			[In()]int nSize,
			[In()]IntPtr Arguments);

		/// <summary>
		/// 
		/// </summary>
		/// <param name="handle"></param>
		/// <returns></returns>
		[DllImport("kernel32.dll", CharSet = CharSet.Auto)]
		public static extern bool CloseHandle(IntPtr handle);

		/// <summary>
		/// 
		/// </summary>
		/// <param name="whichHandle"></param>
		/// <returns></returns>
		[DllImport("kernel32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
		public static extern IntPtr GetStdHandle(int handleType);

		/// <summary>
		/// 
		/// </summary>
		/// <param name="hReadPipe"></param>
		/// <param name="hWritePipe"></param>
		/// <param name="lpPipeAttributes"></param>
		/// <param name="nSize"></param>
		/// <returns></returns>
		[DllImport("kernel32.dll")]
		static extern bool CreatePipe(out IntPtr hReadPipe, out IntPtr hWritePipe, ref SecurityAttributes lpPipeAttributes, uint nSize);

		/// <summary>
		/// 
		/// </summary>
		/// <returns></returns>
		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		public static extern int GetConsoleOutputCP();

		#endregion
	}
	#endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\CommonLib\Web\RestRequest.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Runtime.Serialization;
using System.Security.Cryptography.X509Certificates;
using System.Text;

namespace LiveN.Test.Common.Web
{
    /// <summary>
    /// 
    /// </summary>
    public class RestRequest
    {
        //todo(michperr): static as a hack for the multiplayer tests.  Change to a delegate or something.
        public static string XmlContentType = "application/xml";

        public delegate KeyValuePair<string, string> XAuthorizationDelegate();

        public delegate KeyValuePair<string, string> XAuthorizationDelegateWithCookieName(string cookiename);

        public delegate KeyValuePair<string, string> XLocaleDelegate();

        public delegate KeyValuePair<string, string> XPlatformDelegate();

        public delegate KeyValuePair<string, string> XCannedDelegate();

        public const string RpsCookieName = "RPSSecAuth";

        public XAuthorizationDelegate AuthorizationDelegate
        {
            get;
            set;
        }

        public XAuthorizationDelegateWithCookieName AuthorizationDelegateWithCookieName
        {
            get;
            set;
        }

        public XLocaleDelegate LocaleDelegate
        {
            get;
            set;
        }

        public XPlatformDelegate PlatformDelegate
        {
            get;
            set;
        }

        public XCannedDelegate CannedDelegate
        {
            get;
            set;
        }

        public static int Timeout
        {
            get;
            set;
        }

        public virtual Dictionary<string, string> GetHttpHeaders()
        {
            return GetHttpHeaders(XmlContentType);
        }

        public virtual Dictionary<string, string> GetHttpHeaders(string contentType)
        {
            Dictionary<string, string> httpHeaders = new Dictionary<string, string>();

            if(contentType != null)
                httpHeaders.Add("Content-Type", contentType);

            //httpHeaders.Add("X-Locale", "EN-US");

            if (this.AuthorizationDelegate != null)
            {
                KeyValuePair<string, string> authzToken = this.AuthorizationDelegate();
                httpHeaders.Add(authzToken.Key, authzToken.Value);
            }

            if (this.LocaleDelegate != null)
            {
                KeyValuePair<string, string> xLocale = this.LocaleDelegate();
                httpHeaders.Add(xLocale.Key, xLocale.Value);
            }

            if (this.CannedDelegate != null)
            {
                KeyValuePair<string, string> xCanned = this.CannedDelegate();
                httpHeaders.Add(xCanned.Key, xCanned.Value);
            }

            return httpHeaders;
        }

        public virtual Dictionary<string, string> GetHttpHeaders(string contentType, string cookieName)
        {
            Dictionary<string, string> httpHeaders = new Dictionary<string, string>();

            if (contentType != null)
                httpHeaders.Add("Content-Type", contentType);

            //httpHeaders.Add("X-Locale", "EN-US");
            KeyValuePair<string, string> authzToken = new KeyValuePair<string, string>();

            if (this.AuthorizationDelegate != null)
            {
                authzToken = this.AuthorizationDelegate();
                httpHeaders.Add(authzToken.Key, authzToken.Value);
            }

            if (this.AuthorizationDelegateWithCookieName != null && String.IsNullOrEmpty(authzToken.Key))
            {
                authzToken = this.AuthorizationDelegateWithCookieName(cookieName);
                httpHeaders.Add(authzToken.Key, authzToken.Value);
            }

            if (this.LocaleDelegate != null)
            {
                KeyValuePair<string, string> xLocale = this.LocaleDelegate();
                httpHeaders.Add(xLocale.Key, xLocale.Value);
            }

            if (this.PlatformDelegate != null)
            {
                KeyValuePair<string, string> xPlatform = this.PlatformDelegate();
                httpHeaders.Add(xPlatform.Key, xPlatform.Value);
            }

            if (this.CannedDelegate != null)
            {
                KeyValuePair<string, string> xCanned = this.CannedDelegate();
                httpHeaders.Add(xCanned.Key, xCanned.Value);
            }

            return httpHeaders;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <returns></returns>
        public static RestResponse Get(string url)
        {
            return Get(url, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="httpHeaders"></param>
        /// <returns></returns>
        public static RestResponse Get(string url, Dictionary<string, string> httpHeaders, X509Certificate2 cert)
        {
            return SendRequest(url, "GET", httpHeaders, null, cert);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="httpHeaders"></param>
        /// <returns></returns>
        public static RestResponse Get(string url, Dictionary<string, string> httpHeaders)
        {
            return Get(url, httpHeaders, null);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        public static RestResponse Post(string url, string body)
        {
            return Post(url, null, body);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="httpHeaders"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        public static RestResponse Post(string url, Dictionary<string, string> httpHeaders, string body, X509Certificate2 cert)
        {
            return SendRequest(url, "POST", httpHeaders, body, cert);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="httpHeaders"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        public static RestResponse Post(string url, Dictionary<string, string> httpHeaders, string body)
        {
            return Post(url, httpHeaders, body, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <returns></returns>
        public static RestResponse Delete(string url)
        {
            return Delete(url, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="httpHeaders"></param>
        /// <returns></returns>
        public static RestResponse Delete(string url, Dictionary<string, string> httpHeaders, X509Certificate2 cert)
        {
            return SendRequest(url, "DELETE", httpHeaders, null, cert);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="httpHeaders"></param>
        /// <returns></returns>
        public static RestResponse Delete(string url, Dictionary<string, string> httpHeaders)
        {
            return Delete(url, httpHeaders, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        public static RestResponse Put(string url, string body)
        {
            return Put(url, null, body);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="httpHeaders"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        public static RestResponse Put(string url, Dictionary<string, string> httpHeaders, string body, X509Certificate2 cert)
        {
            return SendRequest(url, "PUT", httpHeaders, body, cert);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="httpHeaders"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        public static RestResponse Put(string url, Dictionary<string, string> httpHeaders, string body)
        {
            return Put(url, httpHeaders, body, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="obj"></param>
        /// <param name="objType"></param>
        /// <returns></returns>
        public static string SerializeObject(object obj)
        {
            using (MemoryStream mStream = new MemoryStream())
            using (StreamReader reader = new StreamReader(mStream))
            {
                DataContractSerializer dcs = new DataContractSerializer(obj.GetType());
                dcs.WriteObject(mStream, obj);
                mStream.Position = 0;               
                return reader.ReadToEnd();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="response"></param>
        /// <returns></returns>
        public static T DeserializeObject<T>(string response)
        {
            DataContractSerializer dcjs = new DataContractSerializer(typeof(T));
            using (MemoryStream mStream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(response)))
            {
                T obj = (T)dcjs.ReadObject(mStream);
                return obj;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="response"></param>
        public static void HandleResponse(RestResponse response)
        {
            //if (!response.CorrectContentType)
            //{
            //    TraceEx.TraceWarning(1000, "BUG!! incorrect Content-Type header found in response.  We always expect 'application/xml' but got '{0}' instead.", response.ContentType);
            //    throw new RestException(response, String.Format("Found incorrect Content-Type header in response.  Expected 'application/xml', but got '{0}' instead", response.ContentType));
            //}

            if (!response.Succeeded)
                throw new RestException(response);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="method"></param>
        /// <param name="httpHeaders"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        protected static RestResponse SendRequest(string url, string method, System.Collections.IDictionary httpHeaders, string body, X509Certificate2 cert)
        {
            return SendRequest(url, method, XmlContentType, httpHeaders, body, cert);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="method"></param>
        /// <param name="httpHeaders"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        protected static RestResponse SendRequest(string url, string method, System.Collections.IDictionary httpHeaders, string body)
        {
            return SendRequest(url, method, httpHeaders, body, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="method"></param>
        /// <param name="contentType"></param>
        /// <returns></returns>
        protected static RestResponse SendRequest(string url, string method, string contentType, System.Collections.IDictionary httpHeaders, string body, X509Certificate2 cert)
        {
            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);

            request.Method = method;
            request.ContentType = contentType;
            request.UserAgent = "MP Test";
            
            if(Timeout > 0)
                request.Timeout = Timeout;

            if (string.Equals(method, "PUT") || string.Equals(method, "POST"))
            {
                if (body != null)
                {
                    request.ContentLength = Encoding.UTF8.GetByteCount(body);
                }
                else
                {
                    request.ContentLength = 0;
                }
            }

            if (httpHeaders != null && httpHeaders.Count > 0)
            {
                foreach (object key in httpHeaders.Keys)
                    AddOrUpdateHttpHeader(request, key.ToString(), httpHeaders[key].ToString());                    
            }

            TraceEx.TraceVerbose(request.ToTraceString(body));

            if (body != null)
            {
                using (StreamWriter writer = new StreamWriter(request.GetRequestStream()))
                {
                    writer.Write(body);
                }
            }

            if (cert != null)
            {
                request.ClientCertificates.Add(cert);
            }

            HttpWebResponse response = null;
            RestResponse restResponse = new RestResponse();

            try
            {
                response = (HttpWebResponse)request.GetResponse();
                restResponse.ResponseUri = response.ResponseUri;
                restResponse.Status = response.StatusCode;
                restResponse.StatusDescription = response.StatusDescription;
                CopyHttpHeaders(response.Headers, restResponse.Headers);

                using (StreamReader reader = new StreamReader(response.GetResponseStream()))
                {
                    restResponse.Body = reader.ReadToEnd();
                }
            }
            catch (WebException e)
            {
                //non-HTTP 200 status code
                if (e.Status == WebExceptionStatus.ProtocolError)
                {
                    response = (HttpWebResponse)e.Response;
                    restResponse.ResponseUri = response.ResponseUri;
                    restResponse.Status = response.StatusCode;
                    restResponse.StatusDescription = response.StatusDescription;
                    CopyHttpHeaders(response.Headers, restResponse.Headers);

                    using (StreamReader reader = new StreamReader(response.GetResponseStream()))
                    {
                        restResponse.Body = reader.ReadToEnd();
                    }
                }
                else
                    throw;
            }
            finally
            {
                if (response != null)
                    response.Close();
            }

            TraceEx.TraceVerbose(response.ToTraceString(restResponse.Body));
            HandleResponse(restResponse);

            return restResponse;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="method"></param>
        /// <param name="contentType"></param>
        /// <param name="httpHeaders"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        protected static RestResponse SendRequest(string url, string method, string contentType, System.Collections.IDictionary httpHeaders, string body)
        {
            return SendRequest(url, method, contentType, httpHeaders, body, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="request"></param>
        /// <param name="key"></param>
        /// <param name="value"></param>
        protected static void AddOrUpdateHttpHeader(HttpWebRequest request, string key, string value)
        {
            switch (key.ToLower())
            {
                case "accept":
                    {
                        request.Accept = value;
                        break;
                    }
                case "connection":
                    {
                        request.Connection = value;
                        break;
                    }
                case "content-type":
                    {
                        request.ContentType = value;
                        break;
                    }
                case "referer":
                    {
                        request.Referer = value;
                        break;
                    }
                case "user-agent":
                    {
                        request.UserAgent = value;
                        break;
                    }
                default:
                    {
                        request.Headers[key] = value;
                        break;
                    }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="webHeaders"></param>
        /// <param name="httpHeaders"></param>
        protected static void CopyHttpHeaders(WebHeaderCollection webHeaders, Dictionary<string, string> httpHeaders)
        {
            if (webHeaders != null && webHeaders.Count > 0)
            {
                foreach (string key in webHeaders.Keys)
                    httpHeaders[key] = webHeaders[key];
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\CommonLib\Web\BasicHttpRequest.cs ===
using System;
using System.Net;
using System.Text;
using System.Xml;
using System.IO;
using System.Threading;
using System.Runtime.Serialization;

namespace LiveN.Test.Common.Web
{
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// Summary description for BasicRequest.
	/// </summary>
    /// 
    [Serializable]
	public class BasicHttpRequest
	{
		protected delegate string MakeStringRequestAndGetResponseDelegate(string request, Encoding encoding);
		protected delegate string MakeStreamRequestAndGetResponseDelegate(Stream request, Encoding encoding);

		protected HttpWebRequest webRequest = null;
		protected HttpWebResponse webResponse = null;
		protected string request = String.Empty;
		protected string response = String.Empty;
		protected byte[] rawRequest = null;
		[NonSerialized]
        protected Encoding encoding = null;
		protected WebException lastException = null;
		protected string url;

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="url"></param>
		public BasicHttpRequest(string url)
		{
			this.webRequest = (HttpWebRequest)WebRequest.Create(url);
			this.url = url;
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="uri"></param>
		public BasicHttpRequest(Uri uri)
		{
			this.webRequest = (HttpWebRequest)WebRequest.Create(uri);
			this.url = uri.ToString();
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public HttpWebRequest BaseHttpRequest
		{
			get
			{
				return this.webRequest;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public HttpWebResponse HttpResponse
		{
			get
			{
				return this.webResponse;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public string Request
		{
			get
			{
				return this.request;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public byte[] RawRequest
		{
			get
			{
				return this.rawRequest.Clone() as byte[];
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public string Response
		{
			get
			{
				return this.response;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public WebException LastException
		{
			get
			{
				return this.lastException;
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public virtual string Url
		{
			get
			{
				return this.url;
			}
			set
			{
				this.url = value;
				this.webRequest = CloneHttpWebRequest(this.webRequest, value);
			}
		}
		
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="request"></param>
		/// <param name="callback"></param>
		/// <param name="state"></param>
		/// <returns></returns>
		public virtual IAsyncResult BeginMakeRequest(string request, AsyncCallback callback, object state)
		{
			return BeginMakeRequest(request, Encoding.UTF8, callback, state);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="request"></param>
		/// <param name="encoding"></param>
		/// <param name="callback"></param>
		/// <param name="state"></param>
		/// <returns></returns>
		public virtual IAsyncResult BeginMakeRequest(string request, Encoding encoding, AsyncCallback callback, object state)
		{
			if((this.url == null) || (this.url.Length == 0))
			{
				throw new ApplicationException("Attempting to make a web request without specifying a valid Url.  Please provide a valid Url to send a request to.");
			}

			this.lastException = null;

			if(this.webResponse != null)
			{
				this.webResponse.Close();
				this.webResponse = null;
			}

			this.request = request;
			this.rawRequest = encoding.GetBytes(request);
			this.webRequest.ContentLength = this.rawRequest.Length;

			return this.webRequest.BeginGetRequestStream(callback, state);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="requestStream"></param>
		/// <param name="callback"></param>
		/// <param name="state"></param>
		/// <returns></returns>
		public virtual IAsyncResult BeginMakeRequest(Stream requestStream, AsyncCallback callback, object state)
		{
			return BeginMakeRequest(requestStream, Encoding.UTF8, callback, state);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="requestStream"></param>
		/// <param name="encoding"></param>
		/// <param name="callback"></param>
		/// <param name="state"></param>
		/// <returns></returns>
		public virtual IAsyncResult BeginMakeRequest(Stream requestStream, Encoding encoding, AsyncCallback callback, object state)
		{
			string request = String.Empty;
			using(StreamReader reader = new StreamReader(requestStream, encoding))
			{
				request = reader.ReadToEnd();
			}

			return BeginMakeRequest(request, encoding, callback, state);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="ar"></param>
		/// <param name="request"></param>
		/// <param name="encoding"></param>
		public virtual void EndMakeRequest(IAsyncResult ar)
		{
			using(Stream requestStream = this.webRequest.EndGetRequestStream(ar))
			{
				requestStream.Write(this.rawRequest, 0, this.rawRequest.Length);
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="request"></param>
		public virtual void MakeRequest(string request)
		{
			MakeRequest(request, Encoding.UTF8);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="request"></param>
		/// <param name="encoding"></param>
		public virtual void MakeRequest(string request, Encoding encoding)
		{
			if((this.url == null) || (this.url.Length == 0))
			{
				throw new ApplicationException("Attempting to make a web request without specifying a valid Url.  Please provide a valid Url to send a request to.");
			}

			this.lastException = null;

			if(this.webResponse != null)
			{
				this.webResponse.Close();
				this.webResponse = null;
			}

			this.request = request;
			this.rawRequest = encoding.GetBytes(request);

            try
            {
                this.webRequest.ContentLength = this.rawRequest.Length;
            }
            catch (InvalidOperationException)
            {
                //fix for times when a request fails and the underlying HttpWebRequest object can't be reused
                this.webRequest = CloneHttpWebRequest(this.webRequest, this.webRequest.RequestUri.ToString());
            }
			
			using(Stream requestStream = this.webRequest.GetRequestStream())
			{
				requestStream.Write(this.rawRequest, 0, this.rawRequest.Length);
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="stream"></param>
		public virtual void MakeRequest(Stream requestStream)
		{
			MakeRequest(requestStream, Encoding.UTF8);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="stream"></param>
		/// <param name="encoding"></param>
		public virtual void MakeRequest(Stream requestStream, Encoding encoding)
		{
			string request = String.Empty;
			using(StreamReader reader = new StreamReader(requestStream, encoding))
			{
				request = reader.ReadToEnd();
			}

			MakeRequest(request, encoding);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="callback"></param>
		/// <param name="state"></param>
		/// <returns></returns>
		public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, object state)
		{
			return BeginGetResponse(Encoding.UTF8, callback, state);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="callback"></param>
		/// <param name="state"></param>
		/// <returns></returns>
		public virtual IAsyncResult BeginGetResponse(Encoding encoding, AsyncCallback callback, object state)
		{
			this.encoding = encoding;
			return this.webRequest.BeginGetResponse(callback, state);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="ar"></param>
		/// <param name="encoding"></param>
		/// <returns></returns>
		public string EndGetResponse(IAsyncResult ar)
		{				
			try
			{
				GetResponseStream(this.webRequest.EndGetResponse(ar), this.encoding);
			}
			catch(WebException e)
			{
				if(e.Response != null)
				{
					GetResponseStream(e.Response, this.encoding);
				}
				else
				{
					this.lastException = e;
					throw;
				}
			}
						
			return this.response;
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <returns></returns>
		public virtual string GetResponse()
		{
			return GetResponse(Encoding.UTF8);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="encoding"></param>
		/// <returns></returns>
		public virtual string GetResponse(Encoding encoding)
		{
			try
			{
				GetResponseStream(this.webRequest.GetResponse(), encoding);
			}
			catch (WebException e)
			{
				if (e.Response != null)
				{
					GetResponseStream(e.Response, encoding);
				}
				else
				{
					this.lastException = e;
					throw;
				}
			}
			finally
			{
				this.webRequest = CloneHttpWebRequest(this.webRequest, null);
			}
							
			return this.response;
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="request"></param>
		/// <param name="callback"></param>
		/// <param name="state"></param>
		/// <returns></returns>
		public virtual IAsyncResult BeginMakeRequestAndGetResponse(string request, AsyncCallback callback, object state)
		{
			return BeginMakeRequestAndGetResponse(request, Encoding.UTF8, callback, state);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="request"></param>
		/// <param name="encoding"></param>
		/// <param name="callback"></param>
		/// <param name="state"></param>
		/// <returns></returns>
		public virtual IAsyncResult BeginMakeRequestAndGetResponse(string request, Encoding encoding, AsyncCallback callback, object state)
		{
			MakeStringRequestAndGetResponseDelegate beginAsync = new MakeStringRequestAndGetResponseDelegate(MakeRequestAndGetResponse);
			return beginAsync.BeginInvoke(request, encoding, callback, state);
			
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="request"></param>
		/// <param name="callback"></param>
		/// <param name="state"></param>
		/// <returns></returns>
		public virtual IAsyncResult BeginMakeRequestAndGetResponse(Stream request, AsyncCallback callback, object state)
		{
			return BeginMakeRequestAndGetResponse(request, Encoding.UTF8, callback, state);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="request"></param>
		/// <param name="encoding"></param>
		/// <param name="callback"></param>
		/// <param name="state"></param>
		/// <returns></returns>
		public virtual IAsyncResult BeginMakeRequestAndGetResponse(Stream request, Encoding encoding, AsyncCallback callback, object state)
		{
			MakeStreamRequestAndGetResponseDelegate beginAsync = new MakeStreamRequestAndGetResponseDelegate(MakeRequestAndGetResponse);
			return beginAsync.BeginInvoke(request, encoding, callback, state);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="ar"></param>
		/// <returns></returns>
		public virtual string EndMakeRequestAndGetResponse(IAsyncResult ar)
		{
			if(ar.AsyncState.GetType() == typeof(MakeStringRequestAndGetResponseDelegate))
			{
				MakeStringRequestAndGetResponseDelegate endAsync = (MakeStringRequestAndGetResponseDelegate)ar.AsyncState;
				return endAsync.EndInvoke(ar);
			}
			else
			{
				MakeStreamRequestAndGetResponseDelegate endAsync = (MakeStreamRequestAndGetResponseDelegate)ar.AsyncState;
				return endAsync.EndInvoke(ar);
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="request"></param>
		/// <returns></returns>
		public virtual string MakeRequestAndGetResponse(string request)
		{
			return MakeRequestAndGetResponse(request, Encoding.UTF8);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="request"></param>
		/// <param name="encoding"></param>
		/// <returns></returns>
		public virtual string MakeRequestAndGetResponse(string request, Encoding encoding)
		{
			MakeRequest(request, encoding);
			return GetResponse(encoding);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="requestStream"></param>
		/// <returns></returns>
		public virtual string MakeRequestAndGetResponse(Stream requestStream)
		{
			return MakeRequestAndGetResponse(requestStream, Encoding.UTF8);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="requestStream"></param>
		/// <param name="encoding"></param>
		/// <returns></returns>
		public virtual string MakeRequestAndGetResponse(Stream requestStream, Encoding encoding)
		{
			MakeRequest(requestStream, encoding);
			return GetResponse(encoding);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="response"></param>
		protected void GetResponseStream(WebResponse response, Encoding encoding)
		{
			this.webResponse = (HttpWebResponse)response;

			//if we don't do this, the app can run out of connections! Disposes of the underlying response stream...
			using(StreamReader reader = new StreamReader(this.webResponse.GetResponseStream(), encoding))
			{
				this.response = reader.ReadToEnd();
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="httpRequest"></param>
		protected static HttpWebRequest CloneHttpWebRequest(HttpWebRequest httpRequest, string newUrl)
		{
			if((httpRequest == null) || ((httpRequest.RequestUri == null) && String.IsNullOrEmpty(newUrl)))
			{
				throw new ApplicationException("Attempting to generate a new HttpWebRequest without specifying a valid Url.  Verify that the Url is valid and has been properly set.");
			}

			HttpWebRequest clone = (HttpWebRequest)WebRequest.Create((String.IsNullOrEmpty(newUrl) ? httpRequest.RequestUri.ToString() : newUrl));

			clone.AllowAutoRedirect = httpRequest.AllowAutoRedirect;
			clone.AllowWriteStreamBuffering = httpRequest.AllowWriteStreamBuffering;
			clone.AuthenticationLevel = httpRequest.AuthenticationLevel;
			clone.AutomaticDecompression = httpRequest.AutomaticDecompression;
			clone.CachePolicy = httpRequest.CachePolicy;
			clone.ClientCertificates.AddRange(httpRequest.ClientCertificates);
			clone.ConnectionGroupName = httpRequest.ConnectionGroupName;
			clone.ContentType = httpRequest.ContentType;
			clone.ContinueDelegate = httpRequest.ContinueDelegate;
			clone.CookieContainer = httpRequest.CookieContainer;
			clone.Credentials = httpRequest.Credentials;

            for (int i = 0; i < httpRequest.Headers.Keys.Count; i++)
            {
                try
                {
                    if (httpRequest.Headers.Keys[i].Equals("Host", StringComparison.OrdinalIgnoreCase)
                        || httpRequest.Headers.Keys[i].Equals("Proxy-Connection", StringComparison.OrdinalIgnoreCase)
                        || httpRequest.Headers.Keys[i].Equals("Connection", StringComparison.OrdinalIgnoreCase))
                    {
                        continue;
                    }
                    clone.Headers.Add(httpRequest.Headers.Keys[i], httpRequest.Headers[httpRequest.Headers.Keys[i]]);
                }
                catch
                {

                }
            }

			clone.ImpersonationLevel = httpRequest.ImpersonationLevel;
			clone.KeepAlive = clone.KeepAlive;
			clone.MaximumAutomaticRedirections = httpRequest.MaximumAutomaticRedirections;
			clone.MaximumResponseHeadersLength = httpRequest.MaximumResponseHeadersLength;
			clone.MediaType = httpRequest.MediaType;
			clone.Method = httpRequest.Method;
			clone.Pipelined = httpRequest.Pipelined;
			clone.PreAuthenticate = httpRequest.PreAuthenticate;
			clone.ProtocolVersion = httpRequest.ProtocolVersion;
			clone.Proxy = httpRequest.Proxy;
			clone.ReadWriteTimeout = httpRequest.ReadWriteTimeout;
			clone.SendChunked = httpRequest.SendChunked;
			clone.Timeout = httpRequest.Timeout;
			clone.TransferEncoding = httpRequest.TransferEncoding;
			clone.UnsafeAuthenticatedConnectionSharing = httpRequest.UnsafeAuthenticatedConnectionSharing;
			clone.UseDefaultCredentials = httpRequest.UseDefaultCredentials;
			clone.UserAgent = httpRequest.UserAgent;

			return clone;
		}
        public string GetHeaderString()
        {
            StringBuilder sb = new StringBuilder();
            
            //request line
            sb.Append(this.BaseHttpRequest.Method);
            sb.Append(" ");
            sb.Append(this.BaseHttpRequest.RequestUri.PathAndQuery.ToString());
            sb.Append(" ");
            sb.Append("HTTP/" + this.BaseHttpRequest.ProtocolVersion.ToString());
            sb.AppendLine();

            sb.AppendLine("Host: " + this.BaseHttpRequest.RequestUri.Host + ":" + this.BaseHttpRequest.RequestUri.Port);
            if (this.BaseHttpRequest.ContentLength != -1)
            {
                sb.AppendLine("Content-Length: " + this.BaseHttpRequest.ContentLength.ToString());
            }
            sb.AppendLine();

            return sb.ToString();
        }
        //this is only used in GETs for now, so there should be no body.
        public byte[] ToBytes()
        {
            string headers = GetHeaderString();
            int byte_count = Encoding.UTF8.GetByteCount(headers);
            byte[] ans = new byte[byte_count /* + (Content == null ? 0 : Content.Length) */];

            Encoding.UTF8.GetBytes(headers, 0, headers.Length, ans, 0);

            //todo(michperr): Spot for the content
            return ans;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\CommonLib\Win32\User32.cs ===
#region Using Directives

using System;
using System.Drawing;
using System.Runtime.InteropServices;
using Microsoft.Win32;

#endregion

namespace LiveN.Test.Common.Win32
{
	#region Enums
	
	
	public enum ScreenSaverMessages: int
	{
		SPI_GETSCREENSAVETIMEOUT = 14,
		SPI_SETSCREENSAVETIMEOUT = 15,
		SPI_GETSCREENSAVEACTIVE = 16,
		SPI_SETSCREENSAVEACTIVE = 17,
		SPI_GETSCREENSAVERRUNNING = 114,
		SC_SCREENSAVE = 0xF140
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// 
	/// </summary>
	public enum ListViewMessage: int
	{
		LVM_FIRST = 0x1000,
		LVM_GETCOLUMNORDERARRAY	= 0x103B
	}
	
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// 
	/// </summary>
	public enum WindowsMessage: int
	{
		Paint = 0xF,
		User = 0x0400,
		MouseMove = 0x200,
		LButtonDown = 0x201,
		LButtonUp = 0x202,
		LButtonDblClk = 0x203,
		RButtonUp = 0x205,
		TaskBarCreated = 0xC086,
		WM_HSCROLL = 0x114,
	    WM_VSCROLL = 0x115,
	    WM_SIZE = 0x05,
		WM_NOTIFY = 0x4E,
		WM_CLOSE = 0x10

	}
	
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// 
	/// </summary>
	public enum ShowWindow: int
	{
		/// <summary>Hides the window and activates another window.</summary>
		/// <remarks>See SW_HIDE</remarks>
		Hide = 0,
		/// <summary>Activates and displays a window. If the window is minimized 
		/// or maximized, the system restores it to its original size and 
		/// position. An application should specify this flag when displaying 
		/// the window for the first time.</summary>
		/// <remarks>See SW_SHOWNORMAL</remarks>
		ShowNormal = 1,
		/// <summary>Activates the window and displays it as a minimized window.</summary>
		/// <remarks>See SW_SHOWMINIMIZED</remarks>
		ShowMinimized = 2,
		/// <summary>Activates the window and displays it as a maximized window.</summary>
		/// <remarks>See SW_SHOWMAXIMIZED</remarks>
		ShowMaximized = 3,
		/// <summary>Maximizes the specified window.</summary>
		/// <remarks>See SW_MAXIMIZE</remarks>
		Maximize = 3,
		/// <summary>Displays a window in its most recent size and position. 
		/// This value is similar to "ShowNormal", except the window is not 
		/// actived.</summary>
		/// <remarks>See SW_SHOWNOACTIVATE</remarks>
		ShowNormalNoActivate = 4,
		/// <summary>Activates the window and displays it in its current size 
		/// and position.</summary>
		/// <remarks>See SW_SHOW</remarks>
		Show = 5,
		/// <summary>Minimizes the specified window and activates the next 
		/// top-level window in the Z order.</summary>
		/// <remarks>See SW_MINIMIZE</remarks>
		Minimize = 6,
		/// <summary>Displays the window as a minimized window. This value is 
		/// similar to "ShowMinimized", except the window is not activated.</summary>
		/// <remarks>See SW_SHOWMINNOACTIVE</remarks>
		ShowMinNoActivate = 7,
		/// <summary>Displays the window in its current size and position. This 
		/// value is similar to "Show", except the window is not activated.</summary>
		/// <remarks>See SW_SHOWNA</remarks>
		ShowNoActivate = 8,
		/// <summary>Activates and displays the window. If the window is 
		/// minimized or maximized, the system restores it to its original size 
		/// and position. An application should specify this flag when restoring 
		/// a minimized window.</summary>
		/// <remarks>See SW_RESTORE</remarks>
		Restore = 9,
		/// <summary>Sets the show state based on the SW_ value specified in the 
		/// STARTUPINFO structure passed to the CreateProcess function by the 
		/// program that started the application.</summary>
		/// <remarks>See SW_SHOWDEFAULT</remarks>
		ShowDefault = 10,
		/// <summary>Windows 2000/XP: Minimizes a window, even if the thread 
		/// that owns the window is hung. This flag should only be used when 
		/// minimizing windows from a different thread.</summary>
		/// <remarks>See SW_FORCEMINIMIZE</remarks>
		ForceMinimized = 11
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// 
	/// </summary>
	[Flags]
	public enum WindowPlacementOptions: int
	{
		SetMinPosition = 1,
		RestoreToMaximized = 2,
		AsyncWindowPlacement = 4,
	}
	#endregion

	#region Structs

		#region POINT Struct
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// 
	/// </summary>
	[StructLayout( LayoutKind.Sequential )]
	public struct POINT 
	{
		#region Variable Declarations

		public int X;
		public int Y;

		#endregion

		#region Constructors
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="x"></param>
		/// <param name="y"></param>
		public POINT(int x, int y) 
		{
			this.X = x;
			this.Y = y;
		}
		#endregion

		#region Public Methods
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="p"></param>
		/// <returns></returns>
		public static implicit operator Point(POINT p) 
		{
			return new Point(p.X, p.Y);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="p"></param>
		/// <returns></returns>
		public static implicit operator POINT(Point p) 
		{
			return new POINT(p.X, p.Y);
		}
		#endregion
	}
		#endregion

		#region RECT Struct
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// 
	/// </summary>
	[Serializable, StructLayout(LayoutKind.Sequential)]
	public struct RECT 
	{
		#region Variable Declarations

		public int left;
		public int top;
		public int right;
		public int bottom;

		#endregion

		#region Constructors
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="left"></param>
		/// <param name="top"></param>
		/// <param name="right"></param>
		/// <param name="bottom"></param>
		public RECT(int left, int top, int right, int bottom) 
		{
			this.left = left;
			this.top = top;
			this.right = right;
			this.bottom = bottom;
		}
		#endregion

		#region Public Properties
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public int Height
		{ 
			get { return this.bottom - this.top + 1; }
		}
		
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public int Width
		{
			get { return this.right - this.left + 1; }
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public Size Size
		{
			get { return new Size(Width, Height); }
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public Point Location
		{
			get { return new Point(left, top); }
		}
		#endregion

		#region Public Methods
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// Handy method for converting to a System.Drawing.Rectangle
		/// </summary>
		public Rectangle ToRectangle() 
		{
			return Rectangle.FromLTRB(left, top, right, bottom);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="rectangle"></param>
		/// <returns></returns>
		public static RECT FromRectangle(Rectangle rectangle) 
		{
			return new RECT(rectangle.Left, rectangle.Top, rectangle.Right, rectangle.Bottom);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <returns></returns>
		public override int GetHashCode() 
		{
			return left ^ ((top << 13) | (top >> 0x13))
				^ ((Width << 0x1a) | (Width >> 6))
				^ ((Height << 7) | (Height >> 0x19));
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="rect"></param>
		/// <returns></returns>
		public static implicit operator Rectangle(RECT rect) 
		{
			return Rectangle.FromLTRB(rect.left, rect.top, rect.right, rect.bottom);
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="rect"></param>
		/// <returns></returns>
		public static implicit operator RECT(Rectangle rect) 
		{
			return new RECT(rect.Left, rect.Top, rect.Right, rect.Bottom);
		}
		#endregion
	}
		#endregion

		#region WindowPlacement Struct
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// 
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public struct WindowPlacement
	{
		public uint length;
		public uint flags;
		public uint showCmd;
		public POINT ptMinPosition;
		public POINT ptMaxPosition;
		public RECT rcNormalPosition;
	}
		#endregion

		#region WM_Notify Struct
	//////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// MessageHeader for WM_NOTIFY
	/// </summary>
	public struct NMHDR 
	{ 
		public IntPtr hwndFrom; 
		public Int32  idFrom; 
		public Int32  code; 
	}
		#endregion

	#endregion

	#region User32 Class
	///////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>
	/// A wrapper class that contains p/invoke functions found in User32.dll.
	/// </summary>
	public static class User32
	{
		#region Private Constants

		public const int SC_SCREENSAVE = 0xF140;
		public const int WM_SYSCOMMAND = 0x0112;
		
		#endregion

		#region Public Methods
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// Gets the placement of a window, given a handle to it.
		/// </summary>
		/// <param name="hWnd"></param>
		/// <param name="lpwndpl"></param>
		/// <returns></returns>
		[DllImport("user32.dll")]
		public static extern bool GetWindowPlacement(IntPtr hWnd, out WindowPlacement lpwndpl);

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// Sets the placement of a window, given a handle to it and a specified, new WINDOWPLACENT.
		/// </summary>
		/// <param name="hWnd"></param>
		/// <param name="lpwndpl"></param>
		/// <returns></returns>
		[DllImport("user32.dll")]
		public static extern bool SetWindowPlacement(IntPtr hWnd, [In] ref WindowPlacement lpwndpl);

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// Sets the specified window handle in the foreground and activates it.
		/// </summary>
		/// <param name="hWnd"></param>
		/// <returns></returns>
		[DllImport("user32.dll")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool SetForegroundWindow(IntPtr hWnd);

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// Returns a handle to the current active, foreground window.
		/// </summary>
		/// <returns></returns>
		[DllImport("user32.dll")]
		public static extern IntPtr GetForegroundWindow();

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="hWnd"></param>
		/// <param name="nCmdShow"></param>
		/// <returns></returns>
		[DllImport("user32.dll", EntryPoint="ShowWindow", SetLastError=true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool ShowWindow(IntPtr windowHandle, ShowWindow showCommand);

		////////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="hWnd"></param>
		/// <param name="msg"></param>
		/// <param name="wPar"></param>
		/// <param name="lPar"></param>
		/// <returns></returns>
		[DllImport("user32.dll")]
		public static extern IntPtr SendMessage(IntPtr hWnd, int msg,	IntPtr wPar, IntPtr	lPar);
		
		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="uAction"></param>
		/// <param name="uParam"></param>
		/// <param name="lpvParam"></param>
		/// <param name="fuWinIni"></param>
		/// <returns></returns>
		[DllImport("user32.dll", CharSet = CharSet.Auto)]
		public static extern bool SystemParametersInfo(int uAction, int uParam, int lpvParam, int fuWinIni);

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="uAction"></param>
		/// <param name="uParam"></param>
		/// <param name="lpvParam"></param>
		/// <param name="fuWinIni"></param>
		/// <returns></returns>
		[DllImport("user32.dll", CharSet = CharSet.Auto)]
		public static extern bool SystemParametersInfo(int uAction, int uParam, ref bool lpvParam, int fuWinIni);

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <returns></returns>
		[DllImport("user32.dll")]
		public static extern long GetForgroundWindow();

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <returns></returns>
		[DllImport("user32.dll")]
        public extern static IntPtr GetDesktopWindow();

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <param name="hwnd"></param>
		/// <returns></returns>
		[DllImport("user32.dll")]
        public static extern IntPtr GetWindowDC(IntPtr hwnd);  

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public static void ActivateWindow(IntPtr windowHandle)
		{
			//Then, get the WindowPlacement, so we can decide the best way to 
			//activate the window correctly.
			WindowPlacement placement = new WindowPlacement();
			GetWindowPlacement(windowHandle, out placement);

			if(placement.showCmd == (uint)LiveN.Test.Common.Win32.ShowWindow.Minimize)
			{
				//if the window is minimized, then we need to restore it to its
				//previous size.  we also take into account whether it was 
				//previously maximized.
				ShowWindow showCmd = (placement.flags == (uint)WindowPlacementOptions.RestoreToMaximized) ? LiveN.Test.Common.Win32.ShowWindow.ShowMaximized : LiveN.Test.Common.Win32.ShowWindow.ShowNormal;
				ShowWindow(windowHandle, showCmd);
			}
			else
			{
				//if it's not minimized, then we just call SetForegroundWindow to 
				//bring it to the front.
				SetForegroundWindow(windowHandle);
			}
		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		///you can call SendMessage(User32.GetForegroundWindow(), (int)WindowsMessage.WM_CLOSE, 0 , 0);
		///to stop the current running screensaver but it will not work with one that requires a password. 
		/// </summary>
		public static void DisableScreenSaver()
		{
			if(!GetScreenSaverRunningStatus())
			{
				bool isActive = false;
				SystemParametersInfo((int)ScreenSaverMessages.SPI_GETSCREENSAVEACTIVE, 0, ref isActive, 0);
				if(isActive)
				{
					SystemParametersInfo((int)ScreenSaverMessages.SPI_SETSCREENSAVEACTIVE, 0, 0, 0);
				}
			}
            Registry.SetValue("HKEY_CURRENT_USER\\Control Panel\\Desktop", "ScreenSaveActive", "0", RegistryValueKind.String);

		}

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		public static void EnableScreenSaver()
		{
			if(!GetScreenSaverRunningStatus())
			{
				bool isActive = false;
				SystemParametersInfo((int)ScreenSaverMessages.SPI_GETSCREENSAVEACTIVE, 0, ref isActive, 0);
				if(!isActive)
				{
	
					SystemParametersInfo((int)ScreenSaverMessages.SPI_SETSCREENSAVEACTIVE, 1, 0, 0);
				}
			}
            Registry.SetValue("HKEY_CURRENT_USER\\Control Panel\\Desktop", "ScreenSaveActive", "1", RegistryValueKind.String);
        }

		///////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary>
		/// 
		/// </summary>
		/// <returns></returns>
		public static bool GetScreenSaverRunningStatus()
		{
			bool isRunning = false;
			SystemParametersInfo((int)ScreenSaverMessages.SPI_GETSCREENSAVERRUNNING, 0, ref isRunning, 0);
			return isRunning;
		}
		#endregion
	}
	#endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ContentProp\MediaType.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveN.Test.Content
{
    public enum MediaType : int
    {
        GameContent = 18,
        PointsBundle = 49,
        MobileGame = 58,
        MobilePDLC = 59,
        MobileGameConsumable = 60
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ContentProp\Common.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.mix.productmanagement.contracts.V1;
using xonline.mix.offermanagement.contracts.V1;
using System.Xml;
using System.IO;
using MIXTesting;
using System.Runtime.Serialization;

namespace LiveN.Test.Content
{
    public class Common
    {
        /// <summary>
        /// Xblob that the content will be propped to 
        /// </summary>
        public const string XBLOB = "slsnetxblob";

        static Common()
        {
            equivalentLocaleDictionary = new Dictionary<string, string[]>();
            equivalentLocaleDictionary.Add("en-US", new string[] { "en-US", "en-GB", "en-CA" });
            equivalentLocaleDictionary.Add("fr-FR", new string[] { "fr-CA", "fr-FR", "fr-CH" });
            equivalentLocaleDictionary.Add("it-IT", new string[] { "it-IT", "it-CH" });
            equivalentLocaleDictionary.Add("de-DE", new string[] { "de-DE", "de-CH" });
            equivalentLocaleDictionary.Add("es-ES", new string[] { "es-ES", "es-MX" });
            equivalentLocaleDictionary.Add("ja-JP", new string[] { "ja-JP" });
            equivalentLocaleDictionary.Add("zh-HK", new string[] { "zh-HK", "zh-TW" });
            equivalentLocaleDictionary.Add("ko-KR", new string[] { "ko-KR" });

            AppDomain.CurrentDomain.DomainUnload += new EventHandler(CurrentDomain_DomainUnload);
        }

        static void CurrentDomain_DomainUnload(object sender, EventArgs e)
        {
            mixFile.Serialize("mixfileOutput.xml");
        }

        private static Dictionary<string, string[]> equivalentLocaleDictionary;
        private static MixTestDataFile mixFile = new MixTestDataFile();
        private static Random rand = new Random();
        private static int counter = 0;

        public const string GameIdFormat = "01234567-89ab-cdef-0000-aaaa{0:00}000000";
        public const string ContentIdFormat = "01234567-89ab-cdef-0000-aaac{0:00}00{1:0000}";
        public const string PackageIdFormat = "01234567-89ab-cdef-0000-aaa{0}{1:00}00{2:0000}";
        public const string OfferIdFormat = "{0}-0000-4000-8000-0000584107f6";
        public const string OfferInstanceIdFormat = "{0}-{1:0000}-4000-8000-0000584107f6";
        public const string ImageIdFormat = "01234567-89ab-cdef-00{2:00}-aaae{0:00}00{1:0000}";
        public const string ImageFileIdFormat = "01234567-89ab-cdef-0{3:0}{2:00}-aafe{0:00}00{1:0000}";
        public const string UrlFormat = "http://pdlc.xboxlive.com/packages/{0}_{1}.pkg";
        public const int AssetIdBase = 60000000;

        public static void InitializeSTF(string catalogServer, string NPDBServer)
        {
            if (ServerTestFramework.Global.CurrentEnvironment == null)
            {
                // Build a new pseudo-STF.xml in memory
                XmlDocument configXML = new XmlDataDocument();

                var stringBuilder = new StringBuilder();
                var stringWriter = new StringWriter(stringBuilder);
                var xmlWriter = new XmlTextWriter(stringWriter);

                xmlWriter.WriteStartDocument();
                xmlWriter.WriteStartElement("stf");
                xmlWriter.WriteStartElement("config");
                xmlWriter.WriteStartElement("configenv");
                // Set npdb and environment to the environment name
                xmlWriter.WriteAttributeString("environment", catalogServer);
                xmlWriter.WriteAttributeString("npdbip", NPDBServer);
                xmlWriter.WriteAttributeString("npdbname", "npdb");
                xmlWriter.WriteEndElement();
                xmlWriter.WriteEndElement();
                xmlWriter.WriteEndElement();
                xmlWriter.WriteEndDocument();
                xmlWriter.Flush();

                /// Write out the XML's string stream to an XmlDoc
                var xmlDocument = new XmlDocument();
                xmlDocument.LoadXml(stringBuilder.ToString());

                // Initialize STF, set the environment and reset

                ServerTestFramework.Global.Initialize(xmlDocument);
                ServerTestFramework.Global.CurrentEnvironment = ServerTestFramework.Global.EnvironmentList[0];
                ServerTestFramework.Global.ResetEnvironment();
            }
        }

        public static void PropContentOffer(ContentOffer contentOffer)
        {
            PropProduct(contentOffer.GameContent);
            foreach (Image image in contentOffer.Images)
            {
                PropProduct(image);
            }

            PropOffer(contentOffer.Offer);
            if (contentOffer.OptionalSecondOffer != null)
            {
                PropOffer(contentOffer.Offer);
            }
        }

        public static void PropProduct(Product product)
        {
            ProductManagementWCFClient productClient = new ProductManagementWCFClient();
            productClient.ConfigureProduct(product);
            mixFile.AddProduct(ObjectToXml(product));
        }

        public static void PropOffer(Offer offer)
        {
            OfferManagementWCFClient offerClient = new OfferManagementWCFClient();
            offerClient.ConfigureOffer(offer);
            mixFile.AddOffer(ObjectToXml(offer));
        }

        public static Game CreateGame(int gameIndex, string[] locales)
        {
            string guid = string.Format(GameIdFormat, gameIndex);
            Game game = MIXTesting.Template.CreateGameTemplateV1() as Game;
            game.ProductId = new Guid(guid);
            game.GameTypeId = (int)MediaType.MobileGame;
            game.LiveTitleId = ComputeTitleId(guid);
            game.Executables = new ProductPackage[0];
            game.GameAttributes = new GameAttribute[0];
            game.GameLocalizedData = new GameLocalizedData[locales.Length];
            game.VideoPreviews = new VideoPreview[0];
            for (int i = 0; i < locales.Length; i++)
            {
                game.GameLocalizedData[i] = Common.CreateGameLocalizedData(locales[i]);
            }
            return game;
        }

        public static GameContent CreateGameContent(int gameIndex, int contentIndex, string[] locales, string titleFormat, int packageCount)
        {
            GameContent content = MIXTesting.Template.CreateGameContentTemplateV1() as GameContent;
            content.ProductId = new Guid(string.Format(ContentIdFormat, gameIndex, contentIndex));
            content.GameContentTypeId = (int)MediaType.MobilePDLC;
            content.GameRelationships = new GameRelationship[1];
            content.GameRelationships[0] = new GameRelationship()
            {
                GameId = new Guid(string.Format(GameIdFormat, gameIndex)),
                SortOrder = 0
            };

            content.LocalizedData = new LocalizedData[locales.Length];
            for (int i = 0; i < locales.Length; i++)
            {
                content.LocalizedData[i] = Common.CreateLocalizedData(locales[i], titleFormat);
                content.LocalizedData[i].TitleSort += (counter++).ToString();
            }

            content.Packages = new ProductPackage[packageCount];
            for (int i = 0; i < packageCount; i++)
            {
                content.Packages[i] = Common.CreatePackage(i, gameIndex, contentIndex, 1);
            }
            return content;
        }

        public static GameConsumable CreateGameConsumable(int gameIndex, int contentIndex, string[] locales, string titleFormat, int packageCount)
        {
            GameConsumable consumable = MIXTesting.Template.CreateGameConsumableTemplateV1() as GameConsumable;
            consumable.ProductId = new Guid(string.Format(ContentIdFormat, gameIndex, contentIndex));
            consumable.GameContentTypeId = (int)MediaType.MobileConsumable;
            consumable.AssetId = AssetIdBase + contentIndex;
            consumable.GameRelationships = new GameRelationship[1];
            consumable.GameRelationships[0] = new GameRelationship()
            {
                GameId = new Guid(string.Format(GameIdFormat, gameIndex)),
                SortOrder = 0
            };

            consumable.LocalizedData = new LocalizedData[locales.Length];
            for (int i = 0; i < locales.Length; i++)
            {
                consumable.LocalizedData[i] = Common.CreateLocalizedData(locales[i], titleFormat);
                consumable.LocalizedData[i].TitleSort += (counter++).ToString();
            }

            consumable.Packages = new ProductPackage[packageCount];
            for (int i = 0; i < packageCount; i++)
            {
                consumable.Packages[i] = Common.CreatePackage(i, gameIndex, contentIndex, 1);
            }
            return consumable;
        }

        public static Offer CreateOffer(Guid contentId, string[] countries, string titleFormat, Guid[] packageIds)
        {
            string prefix = contentId.ToString().Substring(contentId.ToString().Length - 8, 8);
            Offer offer = MIXTesting.Template.CreateOfferTemplateV1();
            offer.OfferId = new Guid(string.Format(OfferIdFormat, prefix));
            offer.ProductId = contentId;
            offer.OfferType = 1;
            offer.StoreIds = new int[] { 5 };
            offer.Name = string.Format(titleFormat, LocalizedStrings.MobileGame_en);
            offer.LiveOfferId = ComputeLiveOfferId(offer.OfferId);
            offer.OfferRelationShips = new OfferRelationShip[0];

            offer.Instances = new OfferInstance[countries.Length * 2];
            for (int i = 0; i < countries.Length; i++)
            {
                offer.Instances[i * 2] = Common.CreateOfferInstance(i * 2, prefix, countries[i], packageIds, 1);
                offer.Instances[i * 2 + 1] = Common.CreateOfferInstance(i * 2 + 1, prefix, countries[i], packageIds, 2);
            }
            return offer;
        }

        public static Offer CreateConsumableOffer(Guid contentId, string[] countries, string titleFormat, Guid[] packageIds)
        {
            Offer offer = CreateOffer(contentId, countries, titleFormat, packageIds);

            int index = 0;
            int baseQuantity = contentId.GetHashCode();
            foreach (OfferInstance offerInstance in offer.Instances)
            {
                foreach (OfferPackage offerPackage in offerInstance.Packages)
                {
                    offerPackage.Quantity = baseQuantity + index;
                    index++;
                }
            }
            return offer;
        }

        public static Image[] CreatePdlcImages(GameContent baseContent, int gameIndex, int contentIndex)
        {
            Image[] images = new Image[2];
            images[0] = CreateImage(baseContent, gameIndex, contentIndex, 14);
            images[1] = CreateImage(baseContent, gameIndex, contentIndex, 26);
            return images;
        }

        public static Image CreateImage(GameContent baseContent, int gameIndex, int contentIndex, int sizeId)
        {
            #region Base
            Image image = new Image();

            image.ProductId = new Guid(string.Format(ImageIdFormat, gameIndex, contentIndex, sizeId));
            image.VisibilityDate = baseContent.VisibilityDate;
            image.VisibilityStatus = baseContent.VisibilityStatus;

            #endregion

            #region LocalizedImageFiles

            image.LocalizedImageFiles = new LocalizedImageFile[baseContent.LocalizedData.Length];
            for (int i = 0; i < image.LocalizedImageFiles.Length; i++)
            {
                string url;
                if (sizeId == 14)
                {
                    url = "http://avatar.xboxlive.com/global/t.4d5307e6/icon/0/8000";
                }
                else
                {
                    url = "http://officeimg.vo.msecnd.net/en-us/templates/TT010256452.png";
                }
                image.LocalizedImageFiles[i] = new LocalizedImageFile();
                image.LocalizedImageFiles[i].Locale = baseContent.LocalizedData[i].Locale;
                image.LocalizedImageFiles[i].EquivalentLocales = baseContent.LocalizedData[i].EquivalentLocales;
                image.LocalizedImageFiles[i].FileUrl = url;
                image.LocalizedImageFiles[i].FormatId = 5;
                image.LocalizedImageFiles[i].LocalizedFileId = new Guid(string.Format(ImageFileIdFormat, gameIndex, contentIndex, sizeId, i));
                image.LocalizedImageFiles[i].SizeId = sizeId;
            }
            #endregion

            #region ProductRelationships

            image.ProductRelationships = new ProductRelationship[1];
            image.ProductRelationships[0] = new ProductRelationship();
            image.ProductRelationships[0].ProductId = baseContent.ProductId;
            image.ProductRelationships[0].RelationshipTypeId = 33;
            image.ProductRelationships[0].SortOrder = 0;

            #endregion

            return image;
        }

        public static ProductPackage CreatePackage(int packageIndex, int gameIndex, int contentIndex, int fileCount)
        {
            ProductPackage package = new ProductPackage();
            package.PackageId = new Guid(string.Format(PackageIdFormat, packageIndex, gameIndex, contentIndex));
            package.ClientTypes = new int[0];//new int[] { 11 };
            package.ContentId = new byte[20];
            package.Encryption = new Encryption();
            package.Encryption.PublicKey = new byte[284];
            package.Encryption.SymKey = new byte[16];
            package.Files = new xonline.mix.productmanagement.contracts.V1.File[fileCount];
            package.InstallSize = 100;
            package.PackageSize = 200;
            package.PackageType = 1;
            package.SupportedGameRegionMask = 255;

            rand.NextBytes(package.ContentId);
            rand.NextBytes(package.Encryption.PublicKey);
            rand.NextBytes(package.Encryption.SymKey);

            for (int i = 0; i < fileCount; i++)
            {
                package.Files[i] = new xonline.mix.productmanagement.contracts.V1.File();
                package.Files[i].FileUrl = "http://icanhascheezburger.files.wordpress.com/2011/01/9c11c75a-972a-4fac-a0c8-8ccdcb81731c.jpg"; // string.Format(UrlFormat, package.PackageId, i);
                package.Files[i].SortOrder = i;
            }
            return package;
        }

        public static OfferInstance CreateOfferInstance(int instanceIndex, string prefix, string countryCode, Guid[] packageIds, int paymentTypeId)
        {
            OfferInstance offerInstance = new OfferInstance();
            offerInstance.OfferInstanceId = new Guid(string.Format(OfferInstanceIdFormat, prefix, instanceIndex));
            offerInstance.CountryCode = countryCode;
            offerInstance.StartDate = DateTime.UtcNow.AddYears(-10).AddDays(counter++);
            offerInstance.EndDate = new DateTime(2099, 10, 29, 14, 7, 25, 613);
            offerInstance.PaymentPrice = 250.0000M;
            offerInstance.WholeSalePrice = 250.0000M;
            offerInstance.SuggestedRetailPrice = 250.0000M;
            switch (paymentTypeId)
            {
                case 1:
                    offerInstance.PaymentPriceCurrencyCode = "MPT";
                    offerInstance.PaymentTypeId = 1;
                    offerInstance.VisibilityLevelId = 1;
                    break;
                case 2:
                    offerInstance.PaymentPriceCurrencyCode = "MTK";
                    offerInstance.PaymentTypeId = 2;
                    offerInstance.VisibilityLevelId = 3;
                    break;
            }

            offerInstance.Packages = new OfferPackage[packageIds.Length];
            for (int i = 0; i < packageIds.Length; i++)
            {
                offerInstance.Packages[i] = new OfferPackage();
                offerInstance.Packages[i].PackageId = packageIds[i];
                offerInstance.Packages[i].ProviderId = 7;
                offerInstance.Packages[i].LicenseExtensionBits = 1;
                offerInstance.Packages[i].LicenseTypeId = 14;
                offerInstance.Packages[i].Quantity = 0;
                offerInstance.Packages[i].VisibilityStatusId = 3;
            }

            offerInstance.UserTypeIds = new int[] { 2, 3 };
            offerInstance.OfferProducts = new OfferProduct[0];
            offerInstance.ExternalOfferInstanceId = "ExternalOfferInstanceId";
            return offerInstance;
        }

        private static GameLocalizedData CreateGameLocalizedData(string locale)
        {
            GameLocalizedData locData = new GameLocalizedData();
            locData.CustomGenre = "Test.CustomGenre";
            locData.TitleSort = "Test.TitleSort";
            locData.DescriptionReduced = "Test.DescriptionReduced";
            locData.Publisher = "Test.Publisher";
            locData.Developer = "Test.Developer";
            locData.Locale = locale;
            locData.Title = GetLocalizedString(locale.Substring(0, 2));
            locData.TitleReduced = locData.Title.Length > 100 ? locData.Title.Substring(0, 100) : locData.Title;
            locData.Description = locData.Title;
            if (equivalentLocaleDictionary.ContainsKey(locale))
            {
                locData.EquivalentLocales = equivalentLocaleDictionary[locale];
            }
            else
            {
                locData.EquivalentLocales = new string[0];
            }
            return locData;
        }

        private static LocalizedData CreateLocalizedData(string locale, string titleFormat)
        {
            LocalizedData locData = new LocalizedData();
            locData.DescriptionReduced = "Test.DescriptionReduced";
            locData.Locale = locale;
            locData.Title = string.Format(titleFormat, GetLocalizedString(locale.Substring(0, 2)));
            locData.TitleReduced = locData.Title.Length > 50 ? locData.Title.Substring(0, 50) : locData.Title;
            locData.TitleSort = locData.TitleReduced;
            locData.Description = locData.Title;
            if (equivalentLocaleDictionary.ContainsKey(locale))
            {
                locData.EquivalentLocales = equivalentLocaleDictionary[locale];
            }
            else
            {
                locData.EquivalentLocales = new string[0];
            }
            return locData;
        }

        private static long ComputeLiveOfferId(Guid offerId)
        {
            return Convert.ToInt64("584107f6" + offerId.ToString().Substring(0, 8), 16);
        }

        private static uint ComputeTitleId(string productGuid)
        {
            return Convert.ToUInt32(productGuid.Substring(productGuid.Length - 8, 8), 16);
        }

        private static string GetLocalizedString(string language)
        {
            switch (language.ToLower())
            {
                case "en":
                    return LocalizedStrings.MobileGame_en;
                case "de":
                    return LocalizedStrings.MobileGame_de;
                case "es":
                    return LocalizedStrings.MobileGame_es;
                case "fr":
                    return LocalizedStrings.MobileGame_fr;
                case "it":
                    return LocalizedStrings.MobileGame_it;
                case "ja":
                    return LocalizedStrings.MobileGame_ja;
                case "ko":
                    return LocalizedStrings.MobileGame_ko;
                case "zh":
                    return LocalizedStrings.MobileGame_zh;
                default:
                    return "Undefined string for " + language;
            }
        }

        private static XmlDocument ObjectToXml(object obj)
        {
            DataContractSerializer serializer = new DataContractSerializer(obj.GetType());
            XmlWriterSettings settings = new XmlWriterSettings();
            settings.Encoding = new UTF8Encoding(false);
            settings.ConformanceLevel = ConformanceLevel.Document;
            settings.Indent = true;
            StringBuilder output = new StringBuilder();
            using (XmlWriter writer = XmlWriter.Create(output, settings))
            {
                serializer.WriteObject(writer, obj);
                writer.Flush();
                XmlDocument document = new XmlDocument();
                document.LoadXml(output.ToString());
                return document;
            }

        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ContentProp\LocalizedStrings.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4952
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace LiveN.Test.Content {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class LocalizedStrings {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal LocalizedStrings() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("LiveN.Test.Content.LocalizedStrings", typeof(LocalizedStrings).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to with long offer text Mobile Game 1 PDLC with long offer text Mobile Game 1 PDLC with long offer text.
        /// </summary>
        internal static string LongText_en {
            get {
                return ResourceManager.GetString("LongText_en", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to with long word &apos;Pneumonoultramicroscopicsilicovolcanoconiosis&apos; n offer text.
        /// </summary>
        internal static string LongWord_en {
            get {
                return ResourceManager.GetString("LongWord_en", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to bewegliches Spiel.
        /// </summary>
        internal static string MobileGame_de {
            get {
                return ResourceManager.GetString("MobileGame_de", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mobile Game.
        /// </summary>
        internal static string MobileGame_en {
            get {
                return ResourceManager.GetString("MobileGame_en", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to móvil gama.
        /// </summary>
        internal static string MobileGame_es {
            get {
                return ResourceManager.GetString("MobileGame_es", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to jeu mobile.
        /// </summary>
        internal static string MobileGame_fr {
            get {
                return ResourceManager.GetString("MobileGame_fr", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to gioco mobile.
        /// </summary>
        internal static string MobileGame_it {
            get {
                return ResourceManager.GetString("MobileGame_it", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 移動式ゲーム.
        /// </summary>
        internal static string MobileGame_ja {
            get {
                return ResourceManager.GetString("MobileGame_ja", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 이동할 수 있는 게임.
        /// </summary>
        internal static string MobileGame_ko {
            get {
                return ResourceManager.GetString("MobileGame_ko", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 流動比賽.
        /// </summary>
        internal static string MobileGame_zh {
            get {
                return ResourceManager.GetString("MobileGame_zh", resourceCulture);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ContentProp\MobileGameContentOffers61.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using xonline.mix.productmanagement.contracts.V1;
using xonline.mix.offermanagement.contracts.V1;

namespace LiveN.Test.Content
{
    /// <summary>
    /// Summary description for UnitTest1
    /// </summary>
    [TestClass]
    public class MobileGameContentOffers61
    {
        public TestContext TestContext { get; set; }

        private static int gameIndex = 61;
        private static Game baseGame;

        private const string TokenFormat = "MOBIL-GAME1-00TOK-PURCH-{0:00000}";

        public MobileGameContentOffers61()
        {
            baseGame = MobileGames.GetMobileGame(gameIndex);
        }

        #region Additional test attributes
        [ClassInitialize()]
        public static void MyClassInitialize(TestContext testContext)
        {
            Common.InitializeSTF(Common.XBLOB, Common.XBLOB);
        }        
        #endregion

        [TestMethod]
        public void ContentOffer_BVT_61000000()
        {
            ContentOffer contentOffer = GetContentOffer_BVT_61000000();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_BVT_61000000()
        {
            int contentIndex = 0;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC BVT for en-US";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        #region Durables 0-999
        #region Locale - 0
        [TestMethod]
        public void ContentOffer_Locale_EFIGS_Ja_61000001()
        {
            ContentOffer contentOffer = GetContentOffer_Locale_EFIGS_Ja_61000001();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Locale_EFIGS_Ja_61000001()
        {
            int contentIndex = 1;
            string[] locales = new string[] { "en-US", "fr-FR", "it-IT", "de-DE", "es-ES", "ja-JP", "zh-HK", "ko-KR" };
            string[] countries = new string[] { "US", "GB", "CA", "FR", "IT", "CH", "DE", "ES", "MX", "JP" };
            string titleFormat = "{0} PDLC with loc data in EFIGS+Japanese";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Locale_English_61000002()
        {
            ContentOffer contentOffer = GetContentOffer_Locale_English_61000002();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Locale_English_61000002()
        {
            int contentIndex = 2;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US", "GB" };
            string titleFormat = "{0} PDLC with English only";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Locale_French_61000003()
        {
            ContentOffer contentOffer = GetContentOffer_Locale_French_61000003();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Locale_French_61000003()
        {
            int contentIndex = 3;
            string[] locales = new string[] { "fr-FR" };
            string[] countries = new string[] { "FR" };
            string titleFormat = "{0} PDLC with French only";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Locale_Italian_61000004()
        {
            ContentOffer contentOffer = GetContentOffer_Locale_Italian_61000004();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Locale_Italian_61000004()
        {
            int contentIndex = 4;
            string[] locales = new string[] { "it-IT" };
            string[] countries = new string[] { "IT" };
            string titleFormat = "{0} PDLC with Italian only";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Locale_German_61000005()
        {
            ContentOffer contentOffer = GetContentOffer_Locale_German_61000005();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Locale_German_61000005()
        {
            int contentIndex = 5;
            string[] locales = new string[] { "de-DE" };
            string[] countries = new string[] { "DE" };
            string titleFormat = "{0} PDLC with German only";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Locale_Spanish_61000006()
        {
            ContentOffer contentOffer = GetContentOffer_Locale_Spanish_61000006();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Locale_Spanish_61000006()
        {
            int contentIndex = 6;
            string[] locales = new string[] { "es-ES" };
            string[] countries = new string[] { "ES", "MX" };
            string titleFormat = "{0} PDLC with Spanish only";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Locale_Japanese_61000007()
        {
            ContentOffer contentOffer = GetContentOffer_Locale_Japanese_61000007();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Locale_Japanese_61000007()
        {
            int contentIndex = 7;
            string[] locales = new string[] { "ja-JP" };
            string[] countries = new string[] { "JP" };
            string titleFormat = "{0} PDLC with Japanese only";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Locale_English_Gold_61000008()
        {
            ContentOffer contentOffer = GetContentOffer_Locale_English_Gold_61000008();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Locale_English_Gold_61000008()
        {
            int contentIndex = 8;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US", "GB" };
            string titleFormat = "{0} PDLC with English and Gold";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            foreach (OfferInstance instance in offer.Instances)
            {
                instance.UserTypeIds = new int[] { 2 };
            }
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Locale_French_Silver_61000009()
        {
            ContentOffer contentOffer = GetContentOffer_Locale_French_Silver_61000009();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Locale_French_Silver_61000009()
        {
            int contentIndex = 9;
            string[] locales = new string[] { "fr-FR" };
            string[] countries = new string[] { "FR" };
            string titleFormat = "{0} PDLC with French and Silver";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            foreach (OfferInstance instance in offer.Instances)
            {
                instance.UserTypeIds = new int[] { 3 };
            }
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Locale_English_Chinese_61000010()
        {
            ContentOffer contentOffer = GetContentOffer_Locale_English_Chinese_61000010();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Locale_English_Chinese_61000010()
        {
            int contentIndex = 10;
            string[] locales = new string[] { "en-HK", "zh-HK" };
            string[] countries = new string[] { "HK" };
            string titleFormat = "{0} PDLC with English and Chinese";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Locale_Japanese_Korean_61000011()
        {
            ContentOffer contentOffer = GetContentOffer_Locale_Japanese_Korean_61000011();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Locale_Japanese_Korean_61000011()
        {
            int contentIndex = 11;
            string[] locales = new string[] { "ja-JP", "ko-KR" };
            string[] countries = new string[] { "JP", "KR" };
            string titleFormat = "{0} PDLC with Japanese and Korean";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }
        #endregion

        #region Text Length - 100
        [TestMethod]
        public void ContentOffer_Text_LongTitle_61000101()
        {
            ContentOffer contentOffer = GetContentOffer_Text_LongTitle_61000101();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Text_LongTitle_61000101()
        {
            int contentIndex = 101;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC " + LocalizedStrings.LongText_en;
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Text_LongWord_61000102()
        {
            ContentOffer contentOffer = GetContentOffer_Text_LongWord_61000102();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Text_LongWord_61000102()
        {
            int contentIndex = 102;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC " + LocalizedStrings.LongWord_en;
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }
        #endregion

        #region Package - 200
        [TestMethod]
        public void ContentOffer_Package_SinglePkg_SingleFile_61000201()
        {
            ContentOffer contentOffer = GetContentOffer_Package_SinglePkg_SingleFile_61000201();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Package_SinglePkg_SingleFile_61000201()
        {
            int contentIndex = 201;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with Single Package Single File";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Package_SinglePkg_MultFile_61000202()
        {
            ContentOffer contentOffer = GetContentOffer_Package_SinglePkg_MultFile_61000202();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Package_SinglePkg_MultFile_61000202()
        {
            int contentIndex = 202;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with Single Package Multiple File";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.Packages[0] = Common.CreatePackage(0, gameIndex, contentIndex, 4);

            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Package_MultPkg_SingleFile_61000203()
        {
            ContentOffer contentOffer = GetContentOffer_Package_MultPkg_SingleFile_61000203();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Package_MultPkg_SingleFile_61000203()
        {
            int contentIndex = 203;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with Multiple Package Single File";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.Packages = new ProductPackage[3];

            for (int i = 0; i < content.Packages.Length; i++)
            {
                content.Packages[i] = Common.CreatePackage(i, gameIndex, contentIndex, 1);
            }

            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Package_MultPkg_MultFile_61000204()
        {
            ContentOffer contentOffer = GetContentOffer_Package_MultPkg_MultFile_61000204();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Package_MultPkg_MultFile_61000204()
        {
            int contentIndex = 204;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with Multiple Package Multiple File";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.Packages = new ProductPackage[3];

            for (int i = 0; i < content.Packages.Length; i++)
            {
                content.Packages[i] = Common.CreatePackage(i, gameIndex, contentIndex, 2);
            }

            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Package_None_61000205()
        {
            ContentOffer contentOffer = GetContentOffer_Package_None_61000205();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Package_None_61000205()
        {
            int contentIndex = 205;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with no package in offer instance";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, new Guid[0]);
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }
        #endregion

        #region Price - 300
        [TestMethod]
        public void ContentOffer_Price_0_61000301()
        {
            ContentOffer contentOffer = GetContentOffer_Price_0_61000301();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Price_0_61000301()
        {
            int contentIndex = 301;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with 0 points";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());

            foreach (OfferInstance offerInstance in offer.Instances)
            {
                offerInstance.PaymentPrice = 0;
            }
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Price_10000_61000302()
        {
            ContentOffer contentOffer = GetContentOffer_Price_10000_61000302();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Price_10000_61000302()
        {
            int contentIndex = 302;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with 10000 points";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());

            foreach (OfferInstance offerInstance in offer.Instances)
            {
                offerInstance.PaymentPrice = 10000;
            }
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        #endregion

        #region Category - 400
        [TestMethod]
        public void ContentOffer_Category_12001_61000401()
        {
            ContentOffer contentOffer = GetContentOffer_Category_12001_61000401();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Category_12001_61000401()
        {
            int contentIndex = 401;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with publisher bit 1";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.Categories = new int[] { 12001 };
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Category_12002_61000402()
        {
            ContentOffer contentOffer = GetContentOffer_Category_12002_61000402();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Category_12002_61000402()
        {
            int contentIndex = 402;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with publisher bit 2";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.Categories = new int[] { 12002 };
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Category_12003_61000403()
        {
            ContentOffer contentOffer = GetContentOffer_Category_12003_61000403();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Category_12003_61000403()
        {
            int contentIndex = 403;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with publisher bit 3";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.Categories = new int[] { 12003 };
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Category_12003_61000404()
        {
            ContentOffer contentOffer = GetContentOffer_Category_12003_61000404();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Category_12003_61000404()
        {
            int contentIndex = 404;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with publisher bit 4";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.Categories = new int[] { 12004 };
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }
        #endregion

        #region Visibility - 500
        [TestMethod]
        public void ContentOffer_Visibility_Unpublished_61000501()
        {
            ContentOffer contentOffer = GetContentOffer_Visibility_Unpublished_61000501();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Visibility_Unpublished_61000501()
        {
            int contentIndex = 501;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with Visibility Unpublished";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.VisibilityStatus = 1;
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Visibility_Staging_61000502()
        {
            ContentOffer contentOffer = GetContentOffer_Visibility_Staging_61000502();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Visibility_Staging_61000502()
        {
            int contentIndex = 502;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with Visibility Staging";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.VisibilityStatus = 2;
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Visibility_Live_61000503()
        {
            ContentOffer contentOffer = GetContentOffer_Visibility_Live_61000503();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Visibility_Live_61000503()
        {
            int contentIndex = 503;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with Visibility Live";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.VisibilityStatus = 3;
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Visibility_Withdrawn_61000504()
        {
            ContentOffer contentOffer = GetContentOffer_Visibility_Withdrawn_61000504();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Visibility_Withdrawn_61000504()
        {
            int contentIndex = 504;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with Visibility Withdrawn";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.VisibilityStatus = 4;
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Visibility_Deleted_61000505()
        {
            ContentOffer contentOffer = GetContentOffer_Visibility_Deleted_61000505();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Visibility_Deleted_61000505()
        {
            int contentIndex = 505;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with Visibility Deleted";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.VisibilityStatus = 5;
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Visibility_Future_61000506()
        {
            ContentOffer contentOffer = GetContentOffer_Visibility_Future_61000506();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Visibility_Future_61000506()
        {
            int contentIndex = 506;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with future release date";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.ReleaseDate = DateTime.Now.AddYears(1);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Visibility_Ended_61000507()
        {
            ContentOffer contentOffer = GetContentOffer_Visibility_Ended_61000507();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Visibility_Ended_61000507()
        {
            int contentIndex = 507;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with past offer instance end date";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());

            foreach (OfferInstance offerInstance in offer.Instances)
            {
                offerInstance.EndDate = DateTime.Now.AddMonths(-5);
            }
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Release_Past_61000508()
        {
            ContentOffer contentOffer = GetContentOffer_Release_Past_61000508();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Release_Past_61000508()
        {
            int contentIndex = 508;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with release date 2010/2/1";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.ReleaseDate = Convert.ToDateTime("2010-02-01 00:00:00.000");
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Release_Past_61000509()
        {
            ContentOffer contentOffer = GetContentOffer_Release_Past_61000509();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Release_Past_61000509()
        {
            int contentIndex = 509;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with release date 2010/3/1";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.ReleaseDate = Convert.ToDateTime("2010-03-01 00:00:00.000");
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Release_Past_61000510()
        {
            ContentOffer contentOffer = GetContentOffer_Release_Past_61000510();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Release_Past_61000510()
        {
            int contentIndex = 510;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with release date 2010/4/1";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.ReleaseDate = Convert.ToDateTime("2010-04-01 00:00:00.000");
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Release_Past_61000511()
        {
            ContentOffer contentOffer = GetContentOffer_Release_Past_61000511();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Release_Past_61000511()
        {
            int contentIndex = 511;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with release date 2010/5/1";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.ReleaseDate = Convert.ToDateTime("2010-05-01 00:00:00.000");
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Release_Past_61000512()
        {
            ContentOffer contentOffer = GetContentOffer_Release_Past_61000512();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Release_Past_61000512()
        {
            int contentIndex = 512;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with release date 2010/6/1";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.ReleaseDate = Convert.ToDateTime("2010-06-01 00:00:00.000");
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Release_Past_61000513()
        {
            ContentOffer contentOffer = GetContentOffer_Release_Past_61000513();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Release_Past_61000513()
        {
            int contentIndex = 513;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with past offer instance end date";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.ReleaseDate = Convert.ToDateTime("2010-07-01 00:00:00.000");
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }
        #endregion

        #region Store - 600
        [TestMethod]
        public void ContentOffer_Stores_All_61000601()
        {
            ContentOffer contentOffer = GetContentOffer_Stores_All_61000601();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Stores_All_61000601()
        {
            int contentIndex = 601;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC in all stores";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            offer.StoreIds = new int[] { 1, 2, 3, 4, 5 };
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Stores_NotMobile_61000602()
        {
            ContentOffer contentOffer = GetContentOffer_Stores_NotMobile_61000602();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Stores_NotMobile_61000602()
        {
            int contentIndex = 602;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC in non-mobile store";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            offer.StoreIds = new int[] { 1, 2, 3, 4 };
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }
        #endregion

        #region en-US offers - 900
        [TestMethod]
        public void ContentOffer_enUS_61000900()
        {
            ContentOffer contentOffer = GetContentOffer_enUS(0);
            Common.PropContentOffer(contentOffer);
        }

        [TestMethod]
        public void ContentOffer_enUS_61020901()
        {
            ContentOffer contentOffer = GetContentOffer_enUS(1);
            Common.PropContentOffer(contentOffer);
        }

        [TestMethod]
        public void ContentOffer_enUS_61000902()
        {
            ContentOffer contentOffer = GetContentOffer_enUS(2);
            Common.PropContentOffer(contentOffer);
        }

        [TestMethod]
        public void ContentOffer_enUS_61000903()
        {
            ContentOffer contentOffer = GetContentOffer_enUS(3);
            Common.PropContentOffer(contentOffer);
        }

        [TestMethod]
        public void ContentOffer_enUS_61000904()
        {
            ContentOffer contentOffer = GetContentOffer_enUS(4);
            Common.PropContentOffer(contentOffer);
        }

        [TestMethod]
        public void ContentOffer_enUS_61000905()
        {
            ContentOffer contentOffer = GetContentOffer_enUS(5);
            Common.PropContentOffer(contentOffer);
        }

        [TestMethod]
        public void ContentOffer_enUS_61000906()
        {
            ContentOffer contentOffer = GetContentOffer_enUS(6);
            Common.PropContentOffer(contentOffer);
        }

        [TestMethod]
        public void ContentOffer_enUS_61000907()
        {
            ContentOffer contentOffer = GetContentOffer_enUS(7);
            Common.PropContentOffer(contentOffer);
        }

        [TestMethod]
        public void ContentOffer_enUS_61000908()
        {
            ContentOffer contentOffer = GetContentOffer_enUS(8);
            Common.PropContentOffer(contentOffer);
        }

        [TestMethod]
        public void ContentOffer_enUS_61000909()
        {
            ContentOffer contentOffer = GetContentOffer_enUS(9);
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_enUS(int contentIndex)
        {
            contentIndex += 900;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC BVT for en-US #" + contentIndex.ToString();
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        #endregion
        #endregion

        #region Non-Mobile DLCs - 1000
        [TestMethod]
        public void ContentOffer_NonMobile_enUS_61001000()
        {
            ContentOffer contentOffer = GetContentOffer_enUS(0);
            Common.PropContentOffer(contentOffer);
        }

        [TestMethod]
        public void ContentOffer_NonMobile_enUS_61001001()
        {
            ContentOffer contentOffer = GetContentOffer_enUS(1);
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_NonMobile_enUS(int contentIndex)
        {
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} Non-mobile DLC BVT for en-US #" + contentIndex.ToString();
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex + 1000, locales, titleFormat, packageCount);
            content.GameContentTypeId = (int)MediaType.GameContent;
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }
        #endregion

        #region Consummables - 2000
        [TestMethod]
        public void ConsumableOffer_Locale_EFIGS_Ja_61002001()
        {
            ContentOffer contentOffer = GetConsumableOffer_Locale_EFIGS_Ja_61002001();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetConsumableOffer_Locale_EFIGS_Ja_61002001()
        {
            int contentIndex = 2001;
            string[] locales = new string[] { "en-US", "fr-FR", "it-IT", "de-DE", "es-ES", "ja-JP", "zh-HK", "ko-KR" };
            string[] countries = new string[] { "US", "GB", "CA", "FR", "IT", "CH", "DE", "ES", "MX", "JP" };
            string titleFormat = "{0} PDLC Consumable with loc data in EFIGS+Japanese";
            int packageCount = 1;

            GameContent content = Common.CreateGameConsumable(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateConsumableOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ConsumableOffer_Locale_EFIGS_Ja_61002002()
        {
            ContentOffer contentOffer = GetConsumableOffer_Locale_EFIGS_Ja_61002002();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetConsumableOffer_Locale_EFIGS_Ja_61002002()
        {
            int contentIndex = 2002;
            string[] locales = new string[] { "en-US", "fr-FR", "it-IT", "de-DE", "es-ES", "ja-JP", "zh-HK", "ko-KR" };
            string[] countries = new string[] { "US", "GB", "CA", "FR", "IT", "CH", "DE", "ES", "MX", "JP" };
            string titleFormat = "{0} PDLC Consumable with loc data in EFIGS+Japanese";
            int packageCount = 1;

            // Hack: trying to create 2 offers for the same content. Not complete yet..
            GameContent content1 = Common.CreateGameConsumable(gameIndex, contentIndex, locales, titleFormat, packageCount);
            GameContent content2 = Common.CreateGameConsumable(gameIndex, contentIndex + 1, locales, titleFormat, packageCount);
            Offer offer1 = Common.CreateConsumableOffer(content1.ProductId, countries, titleFormat, content1.Packages.Select(package => package.PackageId).ToArray());
            Offer offer2 = Common.CreateConsumableOffer(content2.ProductId, countries, titleFormat, content1.Packages.Select(package => package.PackageId).ToArray());
            offer2.ProductId = content1.ProductId;
            Image[] images = Common.CreatePdlcImages(content1, gameIndex, contentIndex);

            return new ContentOffer(content1, offer1, offer2, images, GetTokenString(contentIndex));
        }
        #endregion

        private static string GetTokenString(int contentIndex)
        {
            return string.Format(TokenFormat, contentIndex);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ContentProp\MobileGameContentOffers62.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using xonline.mix.productmanagement.contracts.V1;
using xonline.mix.offermanagement.contracts.V1;

namespace LiveN.Test.Content
{
    /// <summary>
    /// Summary description for UnitTest1
    /// </summary>
    [TestClass]
    public class MobileGameContentOffers62
    {
        public TestContext TestContext { get; set; }

        private static int gameIndex = 62;
        private static Game baseGame;

        private const string TokenFormat = "MOBIL-GAME1-00TOK-PURCH-{0:00000}";

        public MobileGameContentOffers62()
        {
            baseGame = MobileGames.GetMobileGame(gameIndex);
        }

        #region Additional test attributes
        [ClassInitialize()]
        public static void MyClassInitialize(TestContext testContext)
        {
            Common.InitializeSTF(Common.XBLOB, Common.XBLOB);
        }
        #endregion

        [TestMethod]
        public void ContentOffer_BVT_62000000()
        {
            ContentOffer contentOffer = GetContentOffer_BVT_62000000();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_BVT_62000000()
        {
            int contentIndex = 0;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC BVT for en-US";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        #region Durables 0-999
        #region Locale - 0
        [TestMethod]
        public void ContentOffer_Locale_EFIGS_Ja_62000001()
        {
            ContentOffer contentOffer = GetContentOffer_Locale_EFIGS_Ja_62000001();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Locale_EFIGS_Ja_62000001()
        {
            int contentIndex = 1;
            string[] locales = new string[] { "en-US", "fr-FR", "it-IT", "de-DE", "es-ES", "ja-JP", "zh-HK", "ko-KR" };
            string[] countries = new string[] { "US", "GB", "CA", "FR", "IT", "CH", "DE", "ES", "MX", "JP" };
            string titleFormat = "{0} PDLC with loc data in EFIGS+Japanese";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Locale_English_62000002()
        {
            ContentOffer contentOffer = GetContentOffer_Locale_English_62000002();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Locale_English_62000002()
        {
            int contentIndex = 2;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US", "GB" };
            string titleFormat = "{0} PDLC with English only";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Locale_French_62000003()
        {
            ContentOffer contentOffer = GetContentOffer_Locale_French_62000003();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Locale_French_62000003()
        {
            int contentIndex = 3;
            string[] locales = new string[] { "fr-FR" };
            string[] countries = new string[] { "FR" };
            string titleFormat = "{0} PDLC with French only";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Locale_Italian_62000004()
        {
            ContentOffer contentOffer = GetContentOffer_Locale_Italian_62000004();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Locale_Italian_62000004()
        {
            int contentIndex = 4;
            string[] locales = new string[] { "it-IT" };
            string[] countries = new string[] { "IT" };
            string titleFormat = "{0} PDLC with Italian only";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Locale_German_62000005()
        {
            ContentOffer contentOffer = GetContentOffer_Locale_German_62000005();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Locale_German_62000005()
        {
            int contentIndex = 5;
            string[] locales = new string[] { "de-DE" };
            string[] countries = new string[] { "DE" };
            string titleFormat = "{0} PDLC with German only";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Locale_Spanish_62000006()
        {
            ContentOffer contentOffer = GetContentOffer_Locale_Spanish_62000006();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Locale_Spanish_62000006()
        {
            int contentIndex = 6;
            string[] locales = new string[] { "es-ES" };
            string[] countries = new string[] { "ES", "MX" };
            string titleFormat = "{0} PDLC with Spanish only";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Locale_Japanese_62000007()
        {
            ContentOffer contentOffer = GetContentOffer_Locale_Japanese_62000007();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Locale_Japanese_62000007()
        {
            int contentIndex = 7;
            string[] locales = new string[] { "ja-JP" };
            string[] countries = new string[] { "JP" };
            string titleFormat = "{0} PDLC with Japanese only";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Locale_English_Gold_62000008()
        {
            ContentOffer contentOffer = GetContentOffer_Locale_English_Gold_62000008();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Locale_English_Gold_62000008()
        {
            int contentIndex = 8;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US", "GB" };
            string titleFormat = "{0} PDLC with English and Gold";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            foreach (OfferInstance instance in offer.Instances)
            {
                instance.UserTypeIds = new int[] { 2 };
            }
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Locale_French_Silver_62000009()
        {
            ContentOffer contentOffer = GetContentOffer_Locale_French_Silver_62000009();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Locale_French_Silver_62000009()
        {
            int contentIndex = 9;
            string[] locales = new string[] { "fr-FR" };
            string[] countries = new string[] { "FR" };
            string titleFormat = "{0} PDLC with French and Silver";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            foreach (OfferInstance instance in offer.Instances)
            {
                instance.UserTypeIds = new int[] { 3 };
            }
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Locale_English_Chinese_62000010()
        {
            ContentOffer contentOffer = GetContentOffer_Locale_English_Chinese_62000010();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Locale_English_Chinese_62000010()
        {
            int contentIndex = 10;
            string[] locales = new string[] { "en-HK", "zh-HK" };
            string[] countries = new string[] { "HK" };
            string titleFormat = "{0} PDLC with English and Chinese";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Locale_Japanese_Korean_62000011()
        {
            ContentOffer contentOffer = GetContentOffer_Locale_Japanese_Korean_62000011();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Locale_Japanese_Korean_62000011()
        {
            int contentIndex = 11;
            string[] locales = new string[] { "ja-JP", "ko-KR" };
            string[] countries = new string[] { "JP", "KR" };
            string titleFormat = "{0} PDLC with Japanese and Korean";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }
        #endregion

        #region Text Length - 100
        [TestMethod]
        public void ContentOffer_Text_LongTitle_62000101()
        {
            ContentOffer contentOffer = GetContentOffer_Text_LongTitle_62000101();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Text_LongTitle_62000101()
        {
            int contentIndex = 101;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC " + LocalizedStrings.LongText_en;
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Text_LongWord_62000102()
        {
            ContentOffer contentOffer = GetContentOffer_Text_LongWord_62000102();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Text_LongWord_62000102()
        {
            int contentIndex = 102;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC " + LocalizedStrings.LongWord_en;
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }
        #endregion

        #region Package - 200
        [TestMethod]
        public void ContentOffer_Package_SinglePkg_SingleFile_62000201()
        {
            ContentOffer contentOffer = GetContentOffer_Package_SinglePkg_SingleFile_62000201();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Package_SinglePkg_SingleFile_62000201()
        {
            int contentIndex = 201;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with Single Package Single File";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Package_SinglePkg_MultFile_62000202()
        {
            ContentOffer contentOffer = GetContentOffer_Package_SinglePkg_MultFile_62000202();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Package_SinglePkg_MultFile_62000202()
        {
            int contentIndex = 202;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with Single Package Multiple File";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.Packages[0] = Common.CreatePackage(0, gameIndex, contentIndex, 4);

            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Package_MultPkg_SingleFile_62000203()
        {
            ContentOffer contentOffer = GetContentOffer_Package_MultPkg_SingleFile_62000203();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Package_MultPkg_SingleFile_62000203()
        {
            int contentIndex = 203;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with Multiple Package Single File";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.Packages = new ProductPackage[3];

            for (int i = 0; i < content.Packages.Length; i++)
            {
                content.Packages[i] = Common.CreatePackage(i, gameIndex, contentIndex, 1);
            }

            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Package_MultPkg_MultFile_62000204()
        {
            ContentOffer contentOffer = GetContentOffer_Package_MultPkg_MultFile_62000204();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Package_MultPkg_MultFile_62000204()
        {
            int contentIndex = 204;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with Multiple Package Multiple File";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.Packages = new ProductPackage[3];

            for (int i = 0; i < content.Packages.Length; i++)
            {
                content.Packages[i] = Common.CreatePackage(i, gameIndex, contentIndex, 2);
            }

            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Package_None_62000205()
        {
            ContentOffer contentOffer = GetContentOffer_Package_None_62000205();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Package_None_62000205()
        {
            int contentIndex = 205;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with no package in offer instance";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, new Guid[0]);
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }
        #endregion

        #region Price - 300
        [TestMethod]
        public void ContentOffer_Price_0_62000301()
        {
            ContentOffer contentOffer = GetContentOffer_Price_0_62000301();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Price_0_62000301()
        {
            int contentIndex = 301;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with 0 points";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());

            foreach (OfferInstance offerInstance in offer.Instances)
            {
                offerInstance.PaymentPrice = 0;
            }
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Price_10000_62000302()
        {
            ContentOffer contentOffer = GetContentOffer_Price_10000_62000302();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Price_10000_62000302()
        {
            int contentIndex = 302;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with 10000 points";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());

            foreach (OfferInstance offerInstance in offer.Instances)
            {
                offerInstance.PaymentPrice = 10000;
            }
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        #endregion

        #region Category - 400
        [TestMethod]
        public void ContentOffer_Category_12001_62000401()
        {
            ContentOffer contentOffer = GetContentOffer_Category_12001_62000401();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Category_12001_62000401()
        {
            int contentIndex = 401;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with publisher bit 1";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.Categories = new int[] { 12001 };
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Category_12002_62000402()
        {
            ContentOffer contentOffer = GetContentOffer_Category_12002_62000402();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Category_12002_62000402()
        {
            int contentIndex = 402;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with publisher bit 2";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.Categories = new int[] { 12002 };
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Category_12003_62000403()
        {
            ContentOffer contentOffer = GetContentOffer_Category_12003_62000403();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Category_12003_62000403()
        {
            int contentIndex = 403;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with publisher bit 3";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.Categories = new int[] { 12003 };
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Category_12003_62000404()
        {
            ContentOffer contentOffer = GetContentOffer_Category_12003_62000404();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Category_12003_62000404()
        {
            int contentIndex = 404;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with publisher bit 4";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.Categories = new int[] { 12004 };
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }
        #endregion

        #region Visibility - 500
        [TestMethod]
        public void ContentOffer_Visibility_Unpublished_62000501()
        {
            ContentOffer contentOffer = GetContentOffer_Visibility_Unpublished_62000501();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Visibility_Unpublished_62000501()
        {
            int contentIndex = 501;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with Visibility Unpublished";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.VisibilityStatus = 1;
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Visibility_Staging_62000502()
        {
            ContentOffer contentOffer = GetContentOffer_Visibility_Staging_62000502();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Visibility_Staging_62000502()
        {
            int contentIndex = 502;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with Visibility Staging";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.VisibilityStatus = 2;
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Visibility_Live_62000503()
        {
            ContentOffer contentOffer = GetContentOffer_Visibility_Live_62000503();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Visibility_Live_62000503()
        {
            int contentIndex = 503;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with Visibility Live";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.VisibilityStatus = 3;
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Visibility_Withdrawn_62000504()
        {
            ContentOffer contentOffer = GetContentOffer_Visibility_Withdrawn_62000504();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Visibility_Withdrawn_62000504()
        {
            int contentIndex = 504;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with Visibility Withdrawn";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.VisibilityStatus = 4;
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Visibility_Deleted_62000505()
        {
            ContentOffer contentOffer = GetContentOffer_Visibility_Deleted_62000505();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Visibility_Deleted_62000505()
        {
            int contentIndex = 505;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with Visibility Deleted";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.VisibilityStatus = 5;
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Visibility_Future_62000506()
        {
            ContentOffer contentOffer = GetContentOffer_Visibility_Future_62000506();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Visibility_Future_62000506()
        {
            int contentIndex = 506;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with future release date";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.ReleaseDate = DateTime.Now.AddYears(1);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Visibility_Ended_62000507()
        {
            ContentOffer contentOffer = GetContentOffer_Visibility_Ended_62000507();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Visibility_Ended_62000507()
        {
            int contentIndex = 507;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with past offer instance end date";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());

            foreach (OfferInstance offerInstance in offer.Instances)
            {
                offerInstance.EndDate = DateTime.Now.AddMonths(-5);
            }
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Release_Past_62000508()
        {
            ContentOffer contentOffer = GetContentOffer_Release_Past_62000508();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Release_Past_62000508()
        {
            int contentIndex = 508;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with release date 2010/2/1";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.ReleaseDate = Convert.ToDateTime("2010-02-01 00:00:00.000");
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Release_Past_62000509()
        {
            ContentOffer contentOffer = GetContentOffer_Release_Past_62000509();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Release_Past_62000509()
        {
            int contentIndex = 509;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with release date 2010/3/1";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.ReleaseDate = Convert.ToDateTime("2010-03-01 00:00:00.000");
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Release_Past_62000510()
        {
            ContentOffer contentOffer = GetContentOffer_Release_Past_62000510();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Release_Past_62000510()
        {
            int contentIndex = 510;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with release date 2010/4/1";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.ReleaseDate = Convert.ToDateTime("2010-04-01 00:00:00.000");
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Release_Past_62000511()
        {
            ContentOffer contentOffer = GetContentOffer_Release_Past_62000511();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Release_Past_62000511()
        {
            int contentIndex = 511;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with release date 2010/5/1";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.ReleaseDate = Convert.ToDateTime("2010-05-01 00:00:00.000");
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Release_Past_62000512()
        {
            ContentOffer contentOffer = GetContentOffer_Release_Past_62000512();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Release_Past_62000512()
        {
            int contentIndex = 512;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with release date 2010/6/1";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.ReleaseDate = Convert.ToDateTime("2010-06-01 00:00:00.000");
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Release_Past_62000513()
        {
            ContentOffer contentOffer = GetContentOffer_Release_Past_62000513();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Release_Past_62000513()
        {
            int contentIndex = 513;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC with past offer instance end date";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            content.ReleaseDate = Convert.ToDateTime("2010-07-01 00:00:00.000");
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }
        #endregion

        #region Store - 600
        [TestMethod]
        public void ContentOffer_Stores_All_62000601()
        {
            ContentOffer contentOffer = GetContentOffer_Stores_All_62000601();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Stores_All_62000601()
        {
            int contentIndex = 601;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC in all stores";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            offer.StoreIds = new int[] { 1, 2, 3, 4, 5 };
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ContentOffer_Stores_NotMobile_62000602()
        {
            ContentOffer contentOffer = GetContentOffer_Stores_NotMobile_62000602();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_Stores_NotMobile_62000602()
        {
            int contentIndex = 602;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC in non-mobile store";
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            offer.StoreIds = new int[] { 1, 2, 3, 4 };
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }
        #endregion

        #region en-US offers - 900
        [TestMethod]
        public void ContentOffer_enUS_62000900()
        {
            ContentOffer contentOffer = GetContentOffer_enUS(0);
            Common.PropContentOffer(contentOffer);
        }

        [TestMethod]
        public void ContentOffer_enUS_62020901()
        {
            ContentOffer contentOffer = GetContentOffer_enUS(1);
            Common.PropContentOffer(contentOffer);
        }

        [TestMethod]
        public void ContentOffer_enUS_62000902()
        {
            ContentOffer contentOffer = GetContentOffer_enUS(2);
            Common.PropContentOffer(contentOffer);
        }

        [TestMethod]
        public void ContentOffer_enUS_62000903()
        {
            ContentOffer contentOffer = GetContentOffer_enUS(3);
            Common.PropContentOffer(contentOffer);
        }

        [TestMethod]
        public void ContentOffer_enUS_62000904()
        {
            ContentOffer contentOffer = GetContentOffer_enUS(4);
            Common.PropContentOffer(contentOffer);
        }

        [TestMethod]
        public void ContentOffer_enUS_62000905()
        {
            ContentOffer contentOffer = GetContentOffer_enUS(5);
            Common.PropContentOffer(contentOffer);
        }

        [TestMethod]
        public void ContentOffer_enUS_62000906()
        {
            ContentOffer contentOffer = GetContentOffer_enUS(6);
            Common.PropContentOffer(contentOffer);
        }

        [TestMethod]
        public void ContentOffer_enUS_62000907()
        {
            ContentOffer contentOffer = GetContentOffer_enUS(7);
            Common.PropContentOffer(contentOffer);
        }

        [TestMethod]
        public void ContentOffer_enUS_62000908()
        {
            ContentOffer contentOffer = GetContentOffer_enUS(8);
            Common.PropContentOffer(contentOffer);
        }

        [TestMethod]
        public void ContentOffer_enUS_62000909()
        {
            ContentOffer contentOffer = GetContentOffer_enUS(9);
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_enUS(int contentIndex)
        {
            contentIndex += 900;
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} PDLC BVT for en-US #" + contentIndex.ToString();
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        #endregion
        #endregion

        #region Non-Mobile DLCs - 1000
        [TestMethod]
        public void ContentOffer_NonMobile_enUS_62001000()
        {
            ContentOffer contentOffer = GetContentOffer_enUS(0);
            Common.PropContentOffer(contentOffer);
        }

        [TestMethod]
        public void ContentOffer_NonMobile_enUS_62001001()
        {
            ContentOffer contentOffer = GetContentOffer_enUS(1);
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetContentOffer_NonMobile_enUS(int contentIndex)
        {
            string[] locales = new string[] { "en-US" };
            string[] countries = new string[] { "US" };
            string titleFormat = "{0} Non-mobile DLC BVT for en-US #" + contentIndex.ToString();
            int packageCount = 1;

            GameContent content = Common.CreateGameContent(gameIndex, contentIndex + 1000, locales, titleFormat, packageCount);
            content.GameContentTypeId = (int)MediaType.GameContent;
            Offer offer = Common.CreateOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }
        #endregion

        #region Consummables - 2000
        [TestMethod]
        public void ConsumableOffer_Locale_EFIGS_Ja_62002001()
        {
            ContentOffer contentOffer = GetConsumableOffer_Locale_EFIGS_Ja_62002001();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetConsumableOffer_Locale_EFIGS_Ja_62002001()
        {
            int contentIndex = 2001;
            string[] locales = new string[] { "en-US", "fr-FR", "it-IT", "de-DE", "es-ES", "ja-JP", "zh-HK", "ko-KR" };
            string[] countries = new string[] { "US", "GB", "CA", "FR", "IT", "CH", "DE", "ES", "MX", "JP" };
            string titleFormat = "{0} PDLC Consumable with loc data in EFIGS+Japanese";
            int packageCount = 1;

            GameContent content = Common.CreateGameConsumable(gameIndex, contentIndex, locales, titleFormat, packageCount);
            Offer offer = Common.CreateConsumableOffer(content.ProductId, countries, titleFormat, content.Packages.Select(package => package.PackageId).ToArray());
            Image[] images = Common.CreatePdlcImages(content, gameIndex, contentIndex);

            return new ContentOffer(content, offer, images, GetTokenString(contentIndex));
        }

        [TestMethod]
        public void ConsumableOffer_Locale_EFIGS_Ja_62002002()
        {
            ContentOffer contentOffer = GetConsumableOffer_Locale_EFIGS_Ja_62002002();
            Common.PropContentOffer(contentOffer);
        }

        public static ContentOffer GetConsumableOffer_Locale_EFIGS_Ja_62002002()
        {
            int contentIndex = 2002;
            string[] locales = new string[] { "en-US", "fr-FR", "it-IT", "de-DE", "es-ES", "ja-JP", "zh-HK", "ko-KR" };
            string[] countries = new string[] { "US", "GB", "CA", "FR", "IT", "CH", "DE", "ES", "MX", "JP" };
            string titleFormat = "{0} PDLC Consumable with loc data in EFIGS+Japanese";
            int packageCount = 1;

            // Hack: trying to create 2 offers for the same content. Not complete yet..
            GameContent content1 = Common.CreateGameConsumable(gameIndex, contentIndex, locales, titleFormat, packageCount);
            GameContent content2 = Common.CreateGameConsumable(gameIndex, contentIndex + 1, locales, titleFormat, packageCount);
            Offer offer1 = Common.CreateConsumableOffer(content1.ProductId, countries, titleFormat, content1.Packages.Select(package => package.PackageId).ToArray());
            Offer offer2 = Common.CreateConsumableOffer(content2.ProductId, countries, titleFormat, content1.Packages.Select(package => package.PackageId).ToArray());
            offer2.ProductId = content1.ProductId;
            Image[] images = Common.CreatePdlcImages(content1, gameIndex, contentIndex);

            return new ContentOffer(content1, offer1, offer2, images, GetTokenString(contentIndex));
        }
        #endregion

        private static string GetTokenString(int contentIndex)
        {
            return string.Format(TokenFormat, contentIndex);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ContentProp\ContentOffer.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.mix.offermanagement.contracts.V1;
using xonline.mix.productmanagement.contracts.V1;

namespace LiveN.Test.Content
{
    public class ContentOffer
    {
        public ContentOffer(GameContent content, Offer offer, Image[] images, string token)
            : this(content, offer, null, images, token)
        { }

        public ContentOffer(GameContent content, Offer offer, Offer secondOffer, Image[] images, string token)
        {
            this.GameContent = content;
            this.Offer = offer;
            this.OptionalSecondOffer = secondOffer;
            this.Images = images;
            this.TokenString = token;
        }

        /// <summary>
        /// Holds the offer that's associated with the current entry
        /// </summary>
        public Offer Offer { get; private set; }

        public Offer OptionalSecondOffer { get; private set; }

        public Image[] Images { get; private set; }
        
        /// <summary>
        /// Holds the content that's associated with the current offer
        /// </summary>
        public GameContent GameContent { get; private set; }

        public string TokenString { get; private set; }

        public Guid OfferId
        {
            get
            {
                return this.Offer.OfferId;
            }
        }

        public int MediaTypeId
        {
            get
            {
                return this.GameContent.GameContentTypeId;
            }
        }

        public ProductPackage[] Packages
        {
            get
            {
                return this.GameContent.Packages;
            }
        }

        public uint AssetId
        {
            get
            {
                if (this.GameContent.GameContentTypeId == (int)MediaType.MobileConsumable && this.GameContent is GameConsumable)
                {
                    GameConsumable consumable = this.GameContent as GameConsumable;
                    return (uint)consumable.AssetId;
                }
                else
                {
                    return 0;
                }
            }
        }

        public string GetReducedTitle(string locale)
        {
            IEnumerable<string> titles = (from localizedData in this.GameContent.LocalizedData
                                          where localizedData.EquivalentLocales.Contains(locale)
                                          select localizedData.TitleReduced);

            if (titles.Count() == 0)
            {
                throw new Exception("There is no localized data for locale " + locale);
            }

            return titles.First();
        }

        public decimal GetPointsPrice(string countryCode, int paymentTypeId)
        {
            IEnumerable<decimal> prices = (from instance in this.Offer.Instances
                                                    where instance.CountryCode.Equals(countryCode, StringComparison.OrdinalIgnoreCase)
                                                    && instance.PaymentTypeId == paymentTypeId
                                                    select instance.PaymentPrice);

            if (prices.Count() == 0)
            {
                throw new Exception("There is no offer instance for country " + countryCode);
            }

            return prices.First();
        }

        public int GetQuantity(string countryCode)
        {
            IEnumerable<OfferInstance> instances = this.Offer.Instances.Where(i => i.CountryCode.Equals(countryCode, StringComparison.OrdinalIgnoreCase));

            if (instances.Count() == 0)
            {
                throw new Exception("There is no offer instance for country " + countryCode);
            }

            OfferInstance instance = instances.First();

            if (instance.Packages.Length == 0)
            {
                throw new Exception("There is no offer package for this instance: " + instance.OfferInstanceId);
            }

            return instance.Packages[0].Quantity;
        }

        /// <summary>
        /// Gets the OfferContext based off this Offer
        /// </summary>
        /// <returns>OfferContext for this offer</returns>
        public OfferContext GetOfferContext(string locale)
        {
            string []loc;
            string language;
            string countryCode;
            OfferContext offer = new OfferContext();

            loc = locale.Split('-');
            if (loc.Length != 2)
            {
                throw new ArgumentException("Invalid Locale '" + locale + "'. Locale must be [language]-[COUNTRY]. Example: en-US", "locale");
            }

            language = loc[0];
            countryCode = loc[1];
            offer.TitleId = this.GameContent.EffectiveLiveTitle;
            offer.OfferId = this.OfferId;
            offer.AssetId = this.AssetId;
            offer.BillingToken = this.TokenString;
            offer.ProductId = this.GameContent.ProductId;
            offer.GameContentTypeId = this.GameContent.GameContentTypeId;

            offer.AssetQuantity = (uint)this.GetQuantity(countryCode);

            offer.PointsPriceToken = this.GetPointsPrice(countryCode, (int)CatalogPaymentType.Token);
            offer.PointsPricePoints = this.GetPointsPrice(countryCode, (int)CatalogPaymentType.Points);
            
            if (this.Packages.Length > 0)
            {
                offer.MediaInstanceURLs = new List<string>();

                // Add the first url from each pack. All packs should have at least one url
                for (int i = 0; i < this.Packages.Length; i++)
                {
                    offer.MediaInstanceURLs.Add(this.Packages[i].Files[0].FileUrl);
                }
            }

            offer.Title = this.GetReducedTitle(string.Format("{0}-{1}", language, countryCode));

            return offer;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ContentProp\MobileGames.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using xonline.mix.productmanagement.contracts.V1;
using System.Xml;
using System.IO;

namespace LiveN.Test.Content
{
    /// <summary>
    /// Summary description for UnitTest1
    /// </summary>
    [TestClass]
    public class MobileGames
    {
        public TestContext TestContext { get; set; }
        #region Additional test attributes
        [ClassInitialize()]
        public static void MyClassInitialize(TestContext testContext)
        {
            Common.InitializeSTF(Common.XBLOB, Common.XBLOB);
        }
        
        #endregion

        [TestMethod]
        public void MobileGame_EFIGS_Ja_Zh_Ko_61000000()
        {
            Game game = GetMobileGame(61);
            Common.PropProduct(game);
        }

        [TestMethod]
        public void MobileGame_EFIGS_Ja_Zh_Ko_62000000()
        {
            Game game = GetMobileGame(62);
            Common.PropProduct(game);
        }

        public static Game GetMobileGame(int gameIndex)
        {
            string[] locales = new string[] { "en-US", "fr-FR", "it-IT", "de-DE", "es-ES", "ja-JP", "zh-HK", "ko-KR" };

            Game game = Common.CreateGame(gameIndex, locales);
            return game;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ContentProp\MixTestDataFile.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Serialization;
using System.Xml;
using System.IO;
using System.Runtime.Serialization;

namespace LiveN.Test.Content
{
    /// <summary>
    /// Class that describes the MIX data file used to ingest test content
    /// </summary>
    [XmlRootAttribute("MixTestDataFile", Namespace = "", IsNullable = false)]
    public class MixTestDataFile
    {
        private List<XmlDocument> products = new List<XmlDocument>();
        private List<XmlDocument> offers = new List<XmlDocument>();

        /// <summary>
        /// List of products included in the test data file
        /// </summary>
        [XmlArray("MixProductList"), XmlArrayItem(ElementName = "MixProductListItem", Type = typeof(XmlDocument))]
        public XmlDocument[] Products
        {
            get
            {
                return products.ToArray();
            }
            set
            {
                products = new List<XmlDocument>(value);
            }
        }

        /// <summary>
        /// List of offers included in the test data file
        /// </summary>
        [XmlArray("MixOfferList"), XmlArrayItem(ElementName = "MixOfferListItem", Type = typeof(XmlDocument))]
        public XmlDocument[] Offers
        {
            get
            {
                return offers.ToArray();
            }
            set
            {
                offers = new List<XmlDocument>(value);
            }
        }

        public void AddProduct(XmlDocument productXml)
        {
            this.products.Add(productXml);
        }

        public void AddOffer(XmlDocument offerXml)
        {
            this.offers.Add(offerXml);
        }

        /// <summary>
        /// Deserializes the file into a MixTestDataFile
        /// </summary>
        /// <param name="fileName">Path to the file</param>
        /// <returns>MixTestDataFile object that describes the content of the file</returns>
        public static MixTestDataFile Deserialize(string fileName)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(MixTestDataFile));
            using (FileStream fs = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read))
            {
                XmlReader reader = new XmlTextReader(fs);
                MixTestDataFile result = (MixTestDataFile)serializer.Deserialize(reader);
                return result;
            }
        }

        /// <summary>
        /// Serializes the current instance of MixTestDataFile into an xml
        /// </summary>
        /// <param name="fileName">Path to the xml file to generate</param>
        public void Serialize(string fileName)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(MixTestDataFile));
            using (var textWriter = new StreamWriter(fileName))
            {
                serializer.Serialize(textWriter, this);
            }
        }

        /// <summary>
        /// Deserializes from a given xml document to a type T
        /// </summary>
        /// <typeparam name="T">Type of the object</typeparam>
        /// <param name="xmlDoc">Source xml document</param>
        /// <returns></returns>
        private static T DeserializeFromXmlDoc<T>(XmlDocument xmlDoc) where T : class
        {
            try
            {
                XmlTextReader reader = new XmlTextReader(new StringReader(xmlDoc.OuterXml));
                DataContractSerializer serializer = new DataContractSerializer(typeof(T));
                return serializer.ReadObject(reader, true) as T;
            }
            catch (InvalidOperationException)
            {
            }
            catch (IOException)
            {
            }
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ContentProp\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("LiveN.Test.Content")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("b79b80f9-9304-4887-8e9b-e110aa92614f")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ContentProp\Template.cs ===
﻿using System;
using System.Xml;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using System.Xml.XPath;
using xonline.mix.productmanagement.contracts.V1;
using xonline.mix.offermanagement.contracts.V1;

namespace MIXTesting
{
    public class Template
    {
        enum GameTypes { Game = 1, GameConsumable = 24, AvatarItem = 47, Image = 14, GameContent = 18 };

        /// <summary>
        /// Process the input file, parse for the template to apply, generate template, and then save the proccessed file in the orignal location
        /// </summary>
        /// <param name="testCaseFilePath">path to file to be processed</param>
        public static void ProcessFileToApplyTemplate(string testCaseFilePath)
        {
            XElement input = XElement.Load(testCaseFilePath);
            input.Save(testCaseFilePath + ".original");
            ProcessMediaTemplate(input);
            ProcessOfferTemplate(input);
            input.Save(testCaseFilePath);
        }

        /// <summary>
        /// Process Media template
        /// </summary>
        /// <param name="input">the xml to apply template to</param>
        public static void ProcessMediaTemplate(XElement input)
        {
            ProcessTemplate(input, "MediaOperation", "Media");
        }
        /// <summary>
        /// Process Offer template
        /// </summary>
        /// <param name="input">the xml to apply template to</param>
        public static void ProcessOfferTemplate(XElement input)
        {
            ProcessTemplate(input, "OfferOperation", "ProcessedOffer");
        }

        /// <summary>
        /// Process the Media or Offer template, and send the list of media/ offer operation to ApplyTemplate
        /// </summary>
        /// <param name="input">the xml you wanted to process</param>
        /// <param name="operationKeyword">specifies which operation you want to process ("MediaOperation"/ "OfferOperation")</param>
        /// <param name="keyword">specifies which keyword to begin the replacement under ("Media"/ "ProcessedOffer")(</param>
        private static void ProcessTemplate(XElement input, string operationKeyword, string keyword)
        {
            XNamespace nameSpace = "http://schemas.datacontract.org/2004/07/MIXTesting";

            IEnumerable<XElement> operationList =

             operationList = input.Descendants(nameSpace + operationKeyword);

            foreach (XElement operation in operationList)
            {
                XElement template = operation.Element(nameSpace + "Template");
                if (template != null)
                {
                    ApplyTemplate(GetTemplate(template.Value), operation, keyword);
                }
            }
        }

        /// <summary>
        /// Reads the saves the input file as .templated, and then replace it with the original file
        /// </summary>
        /// <param name="testcaseFilePath">path to file to be reverted</param>
        public static void RevertProcessedFile(string testcaseFilePath)
        {
            System.IO.File.Copy(testcaseFilePath, testcaseFilePath + ".templated", true);
            System.IO.File.Copy(testcaseFilePath + ".original", testcaseFilePath, true);
        }
        /// <summary>
        /// Gets the appropiate Template with provided templateTag
        /// </summary>
        /// <param name="templateTag">tag to indicate which template to use</param>
        /// <returns>an Xelement representing the template requested</returns>
        public static XElement GetTemplate(string templateTag)
        {
            XmlDocument template;

            switch (templateTag)
            {
                case "GameV1":
                    template = DataContractSerialize.ObjectToXml(CreateGameTemplateV1());
                    break;

                case "LiveSubscriptionV1":
                    template = DataContractSerialize.ObjectToXml(CreateDefaultLiveSubscriptionV1());
                    break;

                case "GameConsumableV1":
                    template = DataContractSerialize.ObjectToXml(CreateGameConsumableTemplateV1());
                    break;

                case "AvatarItemV1":
                    template = DataContractSerialize.ObjectToXml(CreateAvatarItemTemplateV1());
                    break;
                case "ImageV1":
                    template = DataContractSerialize.ObjectToXml(CreateImageTemplateV1());
                    break;

                case "GameContentV1":
                    template = DataContractSerialize.ObjectToXml(CreateGameContentTemplateV1());
                    break;
                case "OfferV1":
                    template = DataContractSerialize.ObjectToXml(CreateOfferTemplateV1());
                    break;

                // extend here to allow more template options

                default:
                    throw new ArgumentException("Invalid Template");
            }
            return XElement.Load(new XmlNodeReader(template));

        }

        /// <summary>
        /// Applies template to each individual operation for media/ offer operation
        /// </summary>
        /// <param name="template">the template to apply</param>
        /// <param name="operation">specifies which operation you want to process ("MediaOperation"/ "OfferOperation")</param>
        /// <param name="keyword">specifies which keyword to begin the replacement under ("Media"/ "ProcessedOffer")(</param>
        public static void ApplyTemplate(XElement template, XElement operation, string keyword)
        {
            XNamespace nameSpace = "http://schemas.datacontract.org/2004/07/MIXTesting";
            XElement localTemplate = new XElement(template);
            XElement element = operation.Element(nameSpace + keyword);
            if (element == null)
            {
                throw new InvalidOperationException("There is no " + keyword + " in " + operation);
            }
            foreach (XElement overRide in element.Elements())
            {

                IEnumerable<XElement> toBeReplaced = from templateChild in localTemplate.Elements()
                                                     where templateChild.Name == overRide.Name
                                                     select templateChild;
                //only look in decendent if the element to be replaced is not found in the first level
                if (toBeReplaced.Count() == 0)
                {
                    toBeReplaced = from templateDecendent in localTemplate.Descendants()
                                   where templateDecendent.Name == overRide.Name
                                   select templateDecendent;
                }
                toBeReplaced.First().ReplaceWith(overRide);
            }
            operation.Element(nameSpace + keyword).ReplaceNodes(localTemplate.Elements());

        }

        #region Media Templates

        #region Game Template

        public static object CreateGameTemplateV1()
        {
            #region Base

            xonline.mix.productmanagement.contracts.V1.Game game = new xonline.mix.productmanagement.contracts.V1.Game();

            game.ProductId = Guid.NewGuid();
            game.VisibilityDate = Convert.ToDateTime("2010-01-01 00:00:00.000");
            game.ReleaseDate = Convert.ToDateTime("2010-01-01 00:00:00.000"); ;
            game.GeoCheckPolicy = false;
            game.GameTypeId = (int)GameTypes.Game;
            game.LiveTitleId = 6666661;
            game.VisibilityStatus = 3;
            game.Sku = "XBX-00005";

            #endregion

            #region Categories

            game.Categories = new int[] { 1001 };

            #endregion

            #region GameLocalizedData

            game.GameLocalizedData = new xonline.mix.productmanagement.contracts.V1.GameLocalizedData[1];
            game.GameLocalizedData[0] = new xonline.mix.productmanagement.contracts.V1.GameLocalizedData();
            game.GameLocalizedData[0].CustomGenre = "Test.CustomGenre";
            game.GameLocalizedData[0].Locale = "en-US";
            game.GameLocalizedData[0].Title = "Test.Title";
            game.GameLocalizedData[0].TitleSort = "Test.TitleSort";
            game.GameLocalizedData[0].TitleReduced = "Test.TitleReduced";
            game.GameLocalizedData[0].Description = "Test.Description";
            game.GameLocalizedData[0].DescriptionReduced = "Test.DescriptionReduced";
            game.GameLocalizedData[0].Publisher = "Test.Publisher";
            game.GameLocalizedData[0].Developer = "Test.Developer";

            #region EquivalentLocales

            game.GameLocalizedData[0].EquivalentLocales = new string[] { "en-US" };

            #endregion

            #endregion

            #region GameAttributes

            game.GameAttributes = new xonline.mix.productmanagement.contracts.V1.GameAttribute[1];
            game.GameAttributes[0] = new xonline.mix.productmanagement.contracts.V1.GameAttribute();
            game.GameAttributes[0].Attributes = new xonline.mix.contentingestion.contracts.V1.Attribute[1];
            game.GameAttributes[0].Attributes[0] = new xonline.mix.contentingestion.contracts.V1.Attribute();
            game.GameAttributes[0].Attributes[0].AttributeName = "offlinePlayersMax";
            game.GameAttributes[0].Attributes[0].Value = "2";
            game.GameAttributes[0].Country = "US";
            game.GameAttributes[0].EquivalentCountries = new string[] { "US" };

            #endregion

            #region Executables

            game.Executables = new xonline.mix.productmanagement.contracts.V1.ProductPackage[1];
            game.Executables[0] = new xonline.mix.productmanagement.contracts.V1.ProductPackage();
            game.Executables[0].PackageId = Guid.NewGuid();
            game.Executables[0].InstallSize = 100;
            game.Executables[0].PackageSize = 200;
            game.Executables[0].PackageType = 1;
            game.Executables[0].SupportedGameRegionMask = 255;
            game.Executables[0].Encryption = new Encryption();
            game.Executables[0].Encryption.PublicKey = new byte[284];
            game.Executables[0].Encryption.SymKey = new byte[16];
            game.Executables[0].Encryption = new Encryption();
            game.Executables[0].Encryption.SymKey = new byte[16];
            game.Executables[0].Encryption.PublicKey = new byte[284];
            game.Executables[0].ContentId = new byte[20];
            //if seed is not specified, system time will be used causing random to generate the same bytes if 2 calls are really close
            //use packageId hash as seed since contentId is related to packageId
            new Random(game.Executables[0].PackageId.GetHashCode()).NextBytes(game.Executables[0].ContentId);

            #region Files

            game.Executables[0].Files = new xonline.mix.productmanagement.contracts.V1.File[1];
            game.Executables[0].Files[0] = new xonline.mix.productmanagement.contracts.V1.File();
            game.Executables[0].Files[0].FileUrl = "http://test.fileurl.com/file.xex";
            game.Executables[0].Files[0].SortOrder = 1;

            #endregion

            #region ClientTypes

            game.Executables[0].ClientTypes = new int[] { 1 };

            #endregion

            #endregion

            #region Ratings and RatingDescriptors

            game.Ratings = new int[1];
            game.Ratings[0] = 0;

            game.RatingDescriptors = new int[1];
            game.RatingDescriptors[0] = 1;

            #endregion

            #region VideoPreviews

            game.VideoPreviews = new xonline.mix.productmanagement.contracts.V1.VideoPreview[1];
            game.VideoPreviews[0] = new xonline.mix.productmanagement.contracts.V1.VideoPreview();
            game.VideoPreviews[0].Country = "US";
            game.VideoPreviews[0].FileUrl = "http://test.videopreview.com/test.wmv";
            game.VideoPreviews[0].PackageId = Guid.NewGuid();

            #endregion

            return game;
        }


        #endregion

        #region GameContent Template

        public static object CreateGameContentTemplateV1()
        {
            #region Base

            xonline.mix.productmanagement.contracts.V1.Game baseGame = CreateGameTemplateV1() as xonline.mix.productmanagement.contracts.V1.Game;

            xonline.mix.productmanagement.contracts.V1.GameContent gameContent = new xonline.mix.productmanagement.contracts.V1.GameContent();

            gameContent.ProductId = Guid.NewGuid();
            gameContent.VisibilityDate = baseGame.VisibilityDate;
            gameContent.VisibilityStatus = baseGame.VisibilityStatus;
            gameContent.ReleaseDate = baseGame.ReleaseDate;
            gameContent.GeoCheckPolicy = false;
            gameContent.Sku = baseGame.Sku;
            gameContent.GameContentTypeId = (int)GameTypes.GameContent;

            gameContent.EffectiveLiveTitle = 6666662;
            gameContent.InheritRating = false;

            #endregion

            #region Categories

            gameContent.Categories = baseGame.Categories;

            #endregion

            #region GameRelationships

            gameContent.GameRelationships = new xonline.mix.productmanagement.contracts.V1.GameRelationship[1];
            gameContent.GameRelationships[0] = new xonline.mix.productmanagement.contracts.V1.GameRelationship();
            gameContent.GameRelationships[0].GameId = baseGame.ProductId;
            gameContent.GameRelationships[0].SortOrder = 0;

            #endregion

            #region LocalizedData

            gameContent.LocalizedData = new xonline.mix.productmanagement.contracts.V1.LocalizedData[1];
            gameContent.LocalizedData[0] = new xonline.mix.productmanagement.contracts.V1.LocalizedData();
            gameContent.LocalizedData[0].Description = baseGame.GameLocalizedData[0].Description;
            gameContent.LocalizedData[0].DescriptionReduced = baseGame.GameLocalizedData[0].DescriptionReduced;
            gameContent.LocalizedData[0].Locale = baseGame.GameLocalizedData[0].Locale;
            gameContent.LocalizedData[0].Title = baseGame.GameLocalizedData[0].Title;
            gameContent.LocalizedData[0].TitleReduced = baseGame.GameLocalizedData[0].TitleReduced;
            gameContent.LocalizedData[0].TitleSort = baseGame.GameLocalizedData[0].TitleSort;

            #region Equivalent Locales

            gameContent.LocalizedData[0].EquivalentLocales = baseGame.GameLocalizedData[0].EquivalentLocales;

            #endregion

            #endregion

            #region Packages

            gameContent.Packages = new xonline.mix.productmanagement.contracts.V1.ProductPackage[1];
            gameContent.Packages[0] = new xonline.mix.productmanagement.contracts.V1.ProductPackage();
            gameContent.Packages[0].ContentId = baseGame.Executables[0].ContentId;
            gameContent.Packages[0].ClientTypes = baseGame.Executables[0].ClientTypes;
            gameContent.Packages[0].Files = baseGame.Executables[0].Files;
            gameContent.Packages[0].InstallSize = baseGame.Executables[0].InstallSize;
            gameContent.Packages[0].PackageId = baseGame.Executables[0].PackageId;
            gameContent.Packages[0].PackageSize = baseGame.Executables[0].PackageSize;
            gameContent.Packages[0].PackageType = baseGame.Executables[0].PackageType;
            gameContent.Packages[0].SupportedGameRegionMask = baseGame.Executables[0].SupportedGameRegionMask;
            gameContent.Packages[0].Encryption = baseGame.Executables[0].Encryption;

            #endregion

            #region Ratings and RatingDescriptors

            gameContent.Ratings = baseGame.Ratings;

            gameContent.RatingDescriptors = baseGame.RatingDescriptors;

            #endregion

            return (gameContent);
        }

        #endregion

        #region Image Template

        public static object CreateImageTemplateV1()
        {
            #region Base

            xonline.mix.productmanagement.contracts.V1.Game baseGame = CreateGameTemplateV1() as xonline.mix.productmanagement.contracts.V1.Game;

            xonline.mix.productmanagement.contracts.V1.Image image = new xonline.mix.productmanagement.contracts.V1.Image();

            image.ProductId = Guid.NewGuid();
            image.VisibilityDate = baseGame.VisibilityDate;
            image.VisibilityStatus = baseGame.VisibilityStatus;

            #endregion

            #region LocalizedImageFiles

            image.LocalizedImageFiles = new xonline.mix.productmanagement.contracts.V1.LocalizedImageFile[1];
            image.LocalizedImageFiles[0] = new xonline.mix.productmanagement.contracts.V1.LocalizedImageFile();
            image.LocalizedImageFiles[0].Locale = baseGame.GameLocalizedData[0].Locale;
            image.LocalizedImageFiles[0].EquivalentLocales = baseGame.GameLocalizedData[0].EquivalentLocales;
            image.LocalizedImageFiles[0].FileUrl = "http://www.xbox.com/NR/rdonlyres/3EC74CDC-841C-4135-81F4-DFB1448C01EB/0/simbandofbugsxboxlivearcade001.jpg";
            image.LocalizedImageFiles[0].FormatId = 4;
            image.LocalizedImageFiles[0].LocalizedFileId = Guid.NewGuid();
            image.LocalizedImageFiles[0].SizeId = 27;

            #endregion

            #region ProductRelationships

            image.ProductRelationships = new ProductRelationship[1];
            image.ProductRelationships[0] = new ProductRelationship();
            image.ProductRelationships[0].ProductId = baseGame.ProductId;
            image.ProductRelationships[0].RelationshipTypeId = 33;
            image.ProductRelationships[0].SortOrder = 0;

            #endregion

            return (image);
        }

        #endregion

        #region GameConsumable Template


        public static GameConsumable CreateGameConsumableTemplateV1()
        {
            #region Base

            xonline.mix.productmanagement.contracts.V1.Game baseGame = CreateGameTemplateV1() as xonline.mix.productmanagement.contracts.V1.Game;

            xonline.mix.productmanagement.contracts.V1.GameConsumable gameConsumable = new xonline.mix.productmanagement.contracts.V1.GameConsumable();

            gameConsumable.ProductId = Guid.NewGuid();
            gameConsumable.VisibilityDate = baseGame.VisibilityDate;
            gameConsumable.VisibilityStatus = baseGame.VisibilityStatus;
            gameConsumable.ReleaseDate = baseGame.ReleaseDate;
            gameConsumable.GeoCheckPolicy = false;
            gameConsumable.Sku = baseGame.Sku;
            gameConsumable.GameContentTypeId = (int)GameTypes.GameConsumable;

            gameConsumable.EffectiveLiveTitle = 1627389952; // This is for titleID x61000000
            gameConsumable.InheritRating = false;

            gameConsumable.AssetId = 7777771;

            #endregion

            #region Categories

            gameConsumable.Categories = baseGame.Categories;

            #endregion

            #region GameRelationships

            gameConsumable.GameRelationships = new xonline.mix.productmanagement.contracts.V1.GameRelationship[1];
            gameConsumable.GameRelationships[0] = new xonline.mix.productmanagement.contracts.V1.GameRelationship();
            gameConsumable.GameRelationships[0].GameId = baseGame.ProductId;
            gameConsumable.GameRelationships[0].SortOrder = 0;

            #endregion

            #region LocalizedData

            gameConsumable.LocalizedData = new xonline.mix.productmanagement.contracts.V1.LocalizedData[1];
            gameConsumable.LocalizedData[0] = new xonline.mix.productmanagement.contracts.V1.LocalizedData();
            gameConsumable.LocalizedData[0].Description = baseGame.GameLocalizedData[0].Description;
            gameConsumable.LocalizedData[0].DescriptionReduced = baseGame.GameLocalizedData[0].DescriptionReduced;
            gameConsumable.LocalizedData[0].Locale = baseGame.GameLocalizedData[0].Locale;
            gameConsumable.LocalizedData[0].Title = baseGame.GameLocalizedData[0].Title;
            gameConsumable.LocalizedData[0].TitleReduced = baseGame.GameLocalizedData[0].TitleReduced;
            gameConsumable.LocalizedData[0].TitleSort = baseGame.GameLocalizedData[0].TitleSort;

            #region Equivalent Locales

            gameConsumable.LocalizedData[0].EquivalentLocales = baseGame.GameLocalizedData[0].EquivalentLocales;

            #endregion

            #endregion

            #region Packages

            gameConsumable.Packages = new xonline.mix.productmanagement.contracts.V1.ProductPackage[1];
            gameConsumable.Packages[0] = new xonline.mix.productmanagement.contracts.V1.ProductPackage();
            gameConsumable.Packages[0].ContentId = baseGame.Executables[0].ContentId;
            gameConsumable.Packages[0].ClientTypes = baseGame.Executables[0].ClientTypes;
            gameConsumable.Packages[0].Files = baseGame.Executables[0].Files;
            gameConsumable.Packages[0].InstallSize = baseGame.Executables[0].InstallSize;
            gameConsumable.Packages[0].PackageId = baseGame.Executables[0].PackageId;
            gameConsumable.Packages[0].PackageSize = baseGame.Executables[0].PackageSize;
            gameConsumable.Packages[0].PackageType = baseGame.Executables[0].PackageType;
            gameConsumable.Packages[0].SupportedGameRegionMask = baseGame.Executables[0].SupportedGameRegionMask;
            gameConsumable.Packages[0].Encryption = baseGame.Executables[0].Encryption;

            #endregion

            #region Ratings and RatingDescriptors

            gameConsumable.Ratings = baseGame.Ratings;

            gameConsumable.RatingDescriptors = baseGame.RatingDescriptors;

            #endregion

            return (gameConsumable);
        }

        #endregion

        #region AvatarItem Template


        public static object CreateAvatarItemTemplateV1()
        {
            #region Base

            xonline.mix.productmanagement.contracts.V1.GameConsumable baseGameConsumable = CreateGameConsumableTemplateV1() as xonline.mix.productmanagement.contracts.V1.GameConsumable;

            xonline.mix.productmanagement.contracts.V1.AvatarItem avatarItem = new xonline.mix.productmanagement.contracts.V1.AvatarItem();

            avatarItem.ProductId = Guid.NewGuid();
            avatarItem.VisibilityDate = baseGameConsumable.VisibilityDate;
            avatarItem.VisibilityStatus = baseGameConsumable.VisibilityStatus;
            avatarItem.ReleaseDate = baseGameConsumable.ReleaseDate;
            avatarItem.GeoCheckPolicy = false;
            avatarItem.Sku = baseGameConsumable.Sku;
            avatarItem.GameContentTypeId = (int)GameTypes.AvatarItem;

            avatarItem.EffectiveLiveTitle = 6666664;
            avatarItem.InheritRating = false;

            avatarItem.AssetId = Guid.NewGuid();
            avatarItem.BodyType = 1;

            #endregion

            #region Categories

            avatarItem.Categories = baseGameConsumable.Categories;

            #endregion

            #region GameRelationships

            avatarItem.GameRelationships = new xonline.mix.productmanagement.contracts.V1.GameRelationship[1];
            avatarItem.GameRelationships[0] = new xonline.mix.productmanagement.contracts.V1.GameRelationship();
            avatarItem.GameRelationships[0].GameId = baseGameConsumable.ProductId;
            avatarItem.GameRelationships[0].SortOrder = 0;

            #endregion

            #region LocalizedData

            avatarItem.LocalizedData = new xonline.mix.productmanagement.contracts.V1.LocalizedData[1];
            avatarItem.LocalizedData[0] = new xonline.mix.productmanagement.contracts.V1.LocalizedData();
            avatarItem.LocalizedData[0].Description = baseGameConsumable.LocalizedData[0].Description;
            avatarItem.LocalizedData[0].DescriptionReduced = baseGameConsumable.LocalizedData[0].DescriptionReduced;
            avatarItem.LocalizedData[0].Locale = baseGameConsumable.LocalizedData[0].Locale;
            avatarItem.LocalizedData[0].Title = baseGameConsumable.LocalizedData[0].Title;
            avatarItem.LocalizedData[0].TitleReduced = baseGameConsumable.LocalizedData[0].TitleReduced;
            avatarItem.LocalizedData[0].TitleSort = baseGameConsumable.LocalizedData[0].TitleSort;

            #region Equivalent Locales

            avatarItem.LocalizedData[0].EquivalentLocales = baseGameConsumable.LocalizedData[0].EquivalentLocales;

            #endregion

            #endregion

            #region Packages

            avatarItem.Packages = new xonline.mix.productmanagement.contracts.V1.ProductPackage[1];
            avatarItem.Packages[0] = new xonline.mix.productmanagement.contracts.V1.ProductPackage();
            avatarItem.Packages[0].ContentId = baseGameConsumable.Packages[0].ContentId;
            avatarItem.Packages[0].ClientTypes = baseGameConsumable.Packages[0].ClientTypes;
            avatarItem.Packages[0].Files = baseGameConsumable.Packages[0].Files;
            avatarItem.Packages[0].InstallSize = baseGameConsumable.Packages[0].InstallSize;
            avatarItem.Packages[0].PackageId = baseGameConsumable.Packages[0].PackageId;
            avatarItem.Packages[0].PackageSize = baseGameConsumable.Packages[0].PackageSize;
            avatarItem.Packages[0].PackageType = baseGameConsumable.Packages[0].PackageType;
            avatarItem.Packages[0].SupportedGameRegionMask = baseGameConsumable.Packages[0].SupportedGameRegionMask;
            avatarItem.Packages[0].Encryption = baseGameConsumable.Packages[0].Encryption;

            #endregion

            #region Ratings and RatingDescriptors

            avatarItem.Ratings = baseGameConsumable.Ratings;

            avatarItem.RatingDescriptors = baseGameConsumable.RatingDescriptors;

            #endregion

            return (avatarItem);
        }



        #endregion

        #region LiveSubscription

        public static LiveSubscription CreateDefaultLiveSubscriptionV1()
        {
            LiveSubscription liveSubscription = new LiveSubscription();
            liveSubscription.ProductId = new Guid();
            liveSubscription.BillingFrequency = 1;
            liveSubscription.IsCancelable = false;
            liveSubscription.GeoCheckPolicy = false;
            liveSubscription.Name = "default subscription";
            liveSubscription.SellType = 1;
            liveSubscription.ServiceComponentId = new Guid().ToString();
            liveSubscription.Sku = "DefaultSKU";
            liveSubscription.SubscriptionDuration = 30;
            liveSubscription.SubscriptionDurationType = 1;
            //need to provide the guid, otherwise, the deserilze would fail.
            liveSubscription.SubscriptionFamily = new Guid();
            liveSubscription.LocalizedData = new LocalizedData[1];
            liveSubscription.LocalizedData[0] = new LocalizedData();
            liveSubscription.LocalizedData[0].Description = "Default Description";
            liveSubscription.LocalizedData[0].DescriptionReduced = "DefaultDescriptionReduced";
            liveSubscription.LocalizedData[0].EquivalentLocales = new string[] { "en-US" };
            liveSubscription.LocalizedData[0].Locale = "en-US";
            liveSubscription.LocalizedData[0].Title = "Default Title";
            liveSubscription.LocalizedData[0].TitleReduced = "Default Title Reduced";
            liveSubscription.LocalizedData[0].TitleSort = "Default Title Sort";

            liveSubscription.ReleaseDate = Convert.ToDateTime("2008-01-01 00:00:00.000");
            liveSubscription.VisibilityDate = Convert.ToDateTime("2008-01-01 00:00:00.000"); ;
            liveSubscription.VisibilityStatus = 3;

            return liveSubscription;
        }
        #endregion

        #endregion



        #region Offer Template
        public static Offer CreateOfferTemplateV1()
        {
            #region base
            Offer newOffer = new Offer();
            newOffer.OfferId = System.Guid.NewGuid();
            newOffer.LiveOfferId = 1154240922855342083;
            newOffer.Name = "Test Offer";
            newOffer.ProductId = new Guid("00000000-0000-4000-8000-0000584107F6");
            #endregion

            #region Offer Instances
            newOffer.Instances = new OfferInstance[1];
            newOffer.Instances[0] = new OfferInstance();
            newOffer.Instances[0].CountryCode = "US";
            newOffer.Instances[0].StartDate = new DateTime(2000, 10, 29, 14, 7, 25, 613);
            newOffer.Instances[0].EndDate = new DateTime(2099, 10, 29, 14, 7, 25, 613);
            newOffer.Instances[0].OfferInstanceId = System.Guid.NewGuid();
            newOffer.Instances[0].PaymentPrice = 250.0000M;
            newOffer.Instances[0].WholeSalePrice = 250.0000M;
            newOffer.Instances[0].SuggestedRetailPrice = 250.0000M;
            newOffer.Instances[0].PaymentPriceCurrencyCode = "MPT";
            
            newOffer.Instances[0].PaymentTypeId = 1;
            newOffer.Instances[0].Packages = new OfferPackage[1];
            newOffer.Instances[0].Packages[0] = new OfferPackage();
            newOffer.Instances[0].Packages[0].PackageId = new Guid("BD58CC03-A4AA-4036-8099-590E34E4E065");
            newOffer.Instances[0].Packages[0].ProviderId = 7;
            newOffer.Instances[0].Packages[0].LicenseExtensionBits = 1;
            newOffer.Instances[0].Packages[0].LicenseTypeId = 14;
            newOffer.Instances[0].Packages[0].Quantity = 0;
            newOffer.Instances[0].Packages[0].VisibilityStatusId = 3;
            newOffer.Instances[0].UserTypeIds = new int[1];
            newOffer.Instances[0].UserTypeIds[0] = 3;
            newOffer.Instances[0].VisibilityLevelId = 1;
            newOffer.Instances[0].OfferProducts = new OfferProduct[1];
            newOffer.Instances[0].OfferProducts[0] = new OfferProduct();
            newOffer.Instances[0].OfferProducts[0].ProductId = new Guid("00000000-0000-4000-8000-0000584107F6");
            newOffer.Instances[0].OfferProducts[0].LicenseTypeId = 14;
            newOffer.Instances[0].OfferProducts[0].ProviderId = 7;
            newOffer.Instances[0].OfferProducts[0].VisibilityStatusId = 3;
            newOffer.Instances[0].ExternalOfferInstanceId = "ExternalOfferInstanceId";


            #endregion

            #region storeId and offerType
            newOffer.StoreIds = new int[1];
            newOffer.StoreIds[0] = 1;
            newOffer.OfferType = 1;
            #endregion

            #region OfferRelationships

            newOffer.OfferRelationShips = new OfferRelationShip[1];
            newOffer.OfferRelationShips[0] = new OfferRelationShip();
            newOffer.OfferRelationShips[0].RelatedOfferId = newOffer.OfferId;
            #endregion

            return newOffer;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\ManagedIdcrl.cs ===
#region Includes  
    using System;
    using System.Collections;
    using System.Text;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Drawing;
    using System.Security.Permissions;
    using System.Resources;
    using System.Globalization;
    using System.Security.Cryptography.X509Certificates;
using System.Threading;
#endregion

 #region Defines
    using HANDLE = System.IntPtr;
    using BYTE = System.Byte;
    using SHORT = System.Int16;
    using WORD = System.UInt16;
    using INT = System.Int32;
    using UINT = System.UInt32;
    using LONG = System.Int32;
    using BOOL = System.Boolean;
    using DWORD = System.UInt32;
    using ULONG = System.UInt32;
    using CHAR = System.Char;		//Decorate with ANSI. 
    using LPTSTR = System.String;
    using LPCTSTR = System.String;
    using LPSTR = System.String;	//or System.StringBuilder Decorate with ANSI. 
    using LPCSTR = System.String;	//or System.StringBuilder Decorate with ANSI. 
    using LPWSTR = System.String;	//or System.StringBuilder Decorate with Unicode. 
    using LPCWSTR = System.String;	//or System.StringBuilder Decorate with Unicode. 
    using FLOAT = System.Single;
    using DOUBLE = System.Double;
    using HCRYPTPROV = System.IntPtr;
    using HCERTSTORE = System.IntPtr;
    using PCCERT_CONTEXT = System.IntPtr;
    using ALG_ID = System.UInt32;
#endregion

namespace Microsoft.Passport.Test.Ppcrl
{

    #region NativeMethods
    class NativeMethods
    {
        #region Constructor
        private NativeMethods()
        {
            ///this class is intended to contain only static methods, 
            ///adding a private constructor to prevent the compiler 
            ///from generating a default constructor."
        }
        #endregion

        #region P/Invoke imports

        [DllImport("msidcrl40.dll", EntryPoint = "Initialize")]
        internal static extern int Initialize([In] ref System.Guid AppGuid, [In] int PpcrlVersion, [In] uint Flags);

        [DllImport("msidcrl40.dll", EntryPoint = "CreateIdentityHandle")]
        internal static extern int CreateIdentityHandle([In, Optional, MarshalAs(UnmanagedType.LPWStr)] string MemberName, [In] uint Flags, out IntPtr Identity);

        [DllImport("msidcrl40.dll", EntryPoint = "AuthIdentityToService")]
        internal static extern int AuthIdentityToService([In] IntPtr Identity, [In, MarshalAs(UnmanagedType.LPWStr)] string ServiceTarget, [In, Optional, MarshalAs(UnmanagedType.LPWStr)] string ServicePolicy, [In] uint TokenRequestFlags, out IntPtr Token, out uint ResultFlags, out IntPtr SessionKey, out uint SessionKeyLength);

        [DllImport("msidcrl40.dll", EntryPoint = "Uninitialize")]
        internal static extern int Uninitialize();

        [DllImport("msidcrl40.dll")]
        internal static extern int MoveAuthUIContext([In] IntPtr AuthContext, [In] System.Drawing.Point Position, [In] System.Drawing.Size NewSize);

        [DllImport("msidcrl40.dll")]
        internal static extern int DestroyPassportAuthUIContext([In] IntPtr AuthContext);

        [DllImport("msidcrl40.dll")]
        internal static extern int CreatePassportAuthUIContext(ref ManagedIDCRL.PassportCredUIInfo CredUIInfo, ref ManagedIDCRL.PassportCredCustomUI CredUICustomUI, out IntPtr AuthContext);

        [DllImport("msidcrl40.dll")]
        internal static extern int GetPreferredAuthUIContextSize([In] IntPtr Identity, out System.Drawing.Size Size);

        [DllImport("msidcrl40.dll", EntryPoint = "CloseIdentityHandle")]
        internal static extern int CloseIdentityHandle([In] IntPtr Identity);

        [DllImport("msidcrl40.dll")]
        internal static extern int LogonIdentityWithUI([In] IntPtr AuthContext, [In] IntPtr User, [In, MarshalAs(UnmanagedType.LPWStr)] string wszPolicy, [In] uint dwAuthFlags);

        [DllImport("msidcrl40.dll", EntryPoint = "GetAuthState")]
        internal static extern int GetAuthState([In] IntPtr Identity, out int AuthState, out int AuthRequired, out int RequestStatus, out IntPtr WebFlowUrl);

        [DllImport("msidcrl40.dll", EntryPoint = "PassportFreeMemory")]
        internal static extern int PassportFreeMemory([In, Out] IntPtr o);

        [DllImport("msidcrl40.dll", EntryPoint = "PersistCredential")]
        internal static extern int PersistCredential([In] IntPtr Identity, [In, MarshalAs(UnmanagedType.LPWStr)] string CredType);

        [DllImport("msidcrl40.dll", EntryPoint = "HasPersistedCredential")]
        internal static extern int HasPersistedCredential([In] IntPtr Identity, [In, MarshalAs(UnmanagedType.LPWStr)] string CredType, out long HasPersistentCred);

        [DllImport("msidcrl40.dll", EntryPoint = "EnumIdentitiesWithCachedCredentials")]
        internal static extern int EnumIdentitiesWithCachedCredentials([In, MarshalAs(UnmanagedType.LPWStr)] string CredType, out IntPtr EnumHandle);

        [DllImport("msidcrl40.dll", EntryPoint = "NextIdentity")]
        internal static extern int NextIdentity([In] IntPtr EnumHandle, ref IntPtr MemberName);

        [DllImport("msidcrl40.dll", EntryPoint = "SetIdentityProperty")]
        internal static extern int SetIdentityProperty([In] IntPtr Identity, ManagedIDCRL.PassportIdentityProperty Property, [In, MarshalAs(UnmanagedType.LPWStr)] string PropertyValue);

        [DllImport("msidcrl40.dll", EntryPoint = "GetIdentityProperty")]
        internal static extern int GetIdentityProperty([In] IntPtr Identity, ManagedIDCRL.PassportIdentityProperty Property, out IntPtr PropertyValue);

        [DllImport("msidcrl40.dll", EntryPoint = "GetIdentityPropertyByName")]
        internal static extern int GetIdentityPropertyByName([In] IntPtr Identity, [In, MarshalAs(UnmanagedType.LPWStr)] string PropertyName, out IntPtr PropertyValue);

        [DllImport("msidcrl40.dll", EntryPoint = "LogonIdentity")]
        internal static extern int LogonIdentity([In] IntPtr Identity, [In, MarshalAs(UnmanagedType.LPWStr)] string Policy, uint AuthFlags);

        [DllImport("msidcrl40.dll", EntryPoint = "InitializeEx")]
        internal static extern int InitializeEx([In] ref System.Guid AppGuid, [In] int PpcrlVersion, [In] uint Flags, [In, MarshalAs(UnmanagedType.LPArray)] ManagedIDCRL.IDCRL_OPTION[] pOptions, [In] uint dwOptions);

        [DllImport("msidcrl40.dll", EntryPoint = "InitializeApp")]
        internal static extern int InitializeApp([In, MarshalAs(UnmanagedType.LPWStr)] string AppID, [In] int PpcrlVersion, [In] uint Flags, [In, MarshalAs(UnmanagedType.LPArray)] ManagedIDCRL.IDCRL_OPTION[] pOptions, [In] uint dwOptions);

        [DllImport("msidcrl40.dll", EntryPoint = "SetIdcrlOptions")]
        internal static extern int SetIdcrlOptions([In, MarshalAs(UnmanagedType.LPArray)] ManagedIDCRL.IDCRL_OPTION[] pOptions, [In] uint dwOptions, [In] uint Flags);

        [DllImport("msidcrl40.dll", EntryPoint = "SetCredential")]
        internal static extern int SetCredential([In] IntPtr Identity, [In, MarshalAs(UnmanagedType.LPWStr)] string CredType, [In, MarshalAs(UnmanagedType.LPWStr)] string CredValue);

        [DllImport("msidcrl40.dll", EntryPoint = "BuildAuthTokenRequest")]
        internal static extern int BuildAuthTokenRequest([In] IntPtr Identity, [In, MarshalAs(UnmanagedType.LPWStr)] string Policy, uint AuthFlags, ref IntPtr RequestXML);

        [DllImport("msidcrl40.dll", EntryPoint = "GetWebAuthUrl")]
        internal static extern int GetWebAuthUrl([In] IntPtr Identity, [In, Optional, MarshalAs(UnmanagedType.LPWStr)] string TargetServiceName, [In, Optional, MarshalAs(UnmanagedType.LPWStr)] string ServicePolicy, [In, MarshalAs(UnmanagedType.LPWStr)] string AdditionalPostParams, [In, MarshalAs(UnmanagedType.LPWStr)] string SourceServiceName, out IntPtr WebAuthUrl, out IntPtr PostData);

        [DllImport("msidcrl40.dll", EntryPoint = "RemovePersistedCredential")]
        internal static extern int RemovePersistedCredential([In] IntPtr Identity, [In, MarshalAs(UnmanagedType.LPWStr)]string CredType);

        [DllImport("msidcrl40.dll", EntryPoint = "CloseEnumIdentitiesHandle")]
        internal static extern int CloseEnumIdentitiesHandle([In] IntPtr EnumHandle);

        [DllImport("msidcrl40.dll", EntryPoint = "BuildServiceTokenRequest")]
        internal static extern int BuildServiceTokenRequest([In] IntPtr Identity, [In, MarshalAs(UnmanagedType.LPWStr)] string ServiceTarget, [In, Optional, MarshalAs(UnmanagedType.LPWStr)] string ServicePolicy, uint TokenRequestFlags, string RequestXML);

        [DllImport("msidcrl40.dll", EntryPoint = "PutTokenResponseEx")]
        //internal static extern int PutTokenResponse([In] IntPtr User, [In, MarshalAs(UnmanagedType.LPWStr)] string ServiceTarget, [In, MarshalAs(UnmanagedType.LPWStr)] string Response, string Token, long ResultFlags, byte SessionKey, long SessionKeyLength);
        internal static extern int PutTokenResponseEx([In] IntPtr Identity, uint tokenType, [In, MarshalAs(UnmanagedType.LPWStr)] string Response);

        [DllImport("msidcrl40.dll", EntryPoint = "DeriveOfflineKey")]
        internal static extern int DeriveOfflineKey([In] IntPtr Identity, ManagedIDCRL.OfflineKeyMethod Method, ref object OfflineKeyParameters, ref object OfflineKeyMaterial, [In] IntPtr CryptProv, [In] IntPtr SessionKey);

        [DllImport("msidcrl40.dll", EntryPoint = "GetCertificate")]
        internal static extern int GetCertificate([In] IntPtr Identity, [In] ref ManagedIDCRL.RSTParams pcRSTParams, [In, Out] ref uint dwMinTTL, [In] uint dwRequestFlags, out PCCERT_CONTEXT pcertContext, out IntPtr ppbPOP, out uint pcbPOP, out PCCERT_CONTEXT ppCACertContext);

        [DllImport("msidcrl40.dll", EntryPoint = "GetAuthStateEx")]
        internal static extern int GetAuthStateEx([In] IntPtr Identity, [In, MarshalAs(UnmanagedType.LPWStr)] string ServiceTarget, out int AuthState, out int AuthRequired, out int RequestStatus, out IntPtr WebFlowUrl);

        [DllImport("msidcrl40.dll", EntryPoint = "AuthIdentityToServiceEx")]
        internal static extern int AuthIdentityToServiceEx([In] IntPtr Identity, [In] uint swRequestFlags, [In, MarshalAs(UnmanagedType.LPArray)] ManagedIDCRL.RSTParams[] pcRSTParams, [In] uint dwpcRSTParamsCount);

        [DllImport("msidcrl40.dll", EntryPoint = "LogonIdentityEx")]
        internal static extern int LogonIdentityEx([In] IntPtr Identity, [In, Optional, MarshalAs(UnmanagedType.LPWStr)] string authPolicy, [In] uint dwAuthFlags, [In, MarshalAs(UnmanagedType.LPArray)] ManagedIDCRL.RSTParams[] pcRSTParams, [In] uint dwpcRSTParamsCount);

        [DllImport("msidcrl40.dll", EntryPoint = "VerifyCertificate")]
        internal static extern int VerifyCertificate([In] PCCERT_CONTEXT pcertContext, [In, Out] ref uint dwMinTTL, [In] IntPtr pbPOP, [In] uint cbPOP, out PCCERT_CONTEXT ppCACertContext);

        [DllImport("msidcrl40.dll")]
        internal static extern int SetIdentityCallback([In] IntPtr Identity, ManagedIDCRL.CallBackDelegateWithData CallBackFunction, IntPtr callBackData);

        [DllImport("msidcrl40.dll")]
        internal static extern int CancelPendingRequest([In] IntPtr Identity);

        [DllImport("msidcrl40.dll", EntryPoint = "GetExtendedError")]
        internal static extern int GetExtendedError([In] IntPtr Identity, [In] IntPtr pReserved, out uint errorCategory, out uint errorCode, out IntPtr errorBlob);

        #region 4.0 APIs
        [DllImport("msidcrl40.dll", EntryPoint = "GetExtendedProperty")]
        internal static extern int GetExtendedProperty([In, MarshalAs(UnmanagedType.LPWStr)] string propertyName, out IntPtr propertyValue);

        [DllImport("msidcrl40.dll", EntryPoint = "SetExtendedProperty")]
        internal static extern int SetExtendedProperty([In, MarshalAs(UnmanagedType.LPWStr)] string propertyName, [In, MarshalAs(UnmanagedType.LPWStr)] string propertyValue);

        [DllImport("msidcrl40.dll", EntryPoint = "GetWebAuthUrlEx")]
        internal static extern int GetWebAuthUrlEx([In] IntPtr Identity, [In] uint webAuthFlag, [In, Optional, MarshalAs(UnmanagedType.LPWStr)] string TargetServiceName, [In, Optional, MarshalAs(UnmanagedType.LPWStr)] string ServicePolicy, [In, MarshalAs(UnmanagedType.LPWStr)] string AdditionalPostParams, out IntPtr WebAuthUrl, out IntPtr PostData);

        [DllImport("msidcrl40.dll", EntryPoint = "CacheAuthState")]
        internal static extern int CacheAuthState([In] IntPtr Identity, [In, MarshalAs(UnmanagedType.LPWStr)] string VirtualAppName, [In] uint Flags);

        [DllImport("msidcrl40.dll", EntryPoint = "RemoveAuthStateFromCache")]
        internal static extern int RemoveAuthStateFromCache([In, MarshalAs(UnmanagedType.LPWStr)] string username, [In, MarshalAs(UnmanagedType.LPWStr)] string VirtualAppName, [In] uint Flags);

        [DllImport("msidcrl40.dll", EntryPoint = "CreateIdentityHandleFromCachedAuthState")]
        internal static extern int CreateIdentityHandleFromCachedAuthState([In, MarshalAs(UnmanagedType.LPWStr)] string username, [In, MarshalAs(UnmanagedType.LPWStr)] string VirtualAppName, [In] uint Flags, out IntPtr identity);

        [DllImport("msidcrl40.dll", EntryPoint = "CreateIdentityHandleFromCachedAuthState")]
        internal static extern int CreateIdentityHandleFromCachedAuthState([In, MarshalAs(UnmanagedType.LPWStr)] string VirtualAppName, [In] uint Flags, out IntPtr identity);

        [DllImport("msidcrl40.dll", EntryPoint = "CreateIdentityHandleFromAuthState")]
        internal static extern int CreateIdentityHandleFromAuthState([In, MarshalAs(UnmanagedType.LPWStr)] string authToken, [In] uint flags, out IntPtr identity);

        [DllImport("msidcrl40.dll", EntryPoint = "ExportAuthState")]
        internal static extern int ExportAuthState([In] IntPtr identity, [In] uint flags, out IntPtr authToken);

        [DllImport("msidcrl40.dll", EntryPoint = "SetUserExtendedProperty")]
        internal static extern int SetUserExtendedProperty([In, MarshalAs(UnmanagedType.LPWStr)] string userName, [In, MarshalAs(UnmanagedType.LPWStr)] string propertyName, [In, MarshalAs(UnmanagedType.LPWStr)] string propertyValue);

        [DllImport("msidcrl40.dll", EntryPoint = "GetUserExtendedProperty")]
        internal static extern int GetUserExtendedProperty([In, MarshalAs(UnmanagedType.LPWStr)] string userName, [In, MarshalAs(UnmanagedType.LPWStr)] string propertyName, out IntPtr propertyValue);

        [DllImport("msidcrl40.dll", EntryPoint = "GetServiceConfig")]
        internal static extern int GetServiceConfig([In, MarshalAs(UnmanagedType.LPWStr)] string valueName, out IntPtr UrlValue);

        [DllImport("msidcrl40.dll", EntryPoint = "EncryptWithSessionKey")]
        internal static extern int EncryptWithSessionKey([In] IntPtr identity, [In, MarshalAs(UnmanagedType.LPWStr)] string serviceName, [In] ALG_ID algIdEncrypt, [In] ALG_ID algIdHash, [In] IntPtr data, [In] uint dataSize, out IntPtr cipher, out uint cipherSize);

        [DllImport("msidcrl40.dll", EntryPoint = "DecryptWithSessionKey")]
        internal static extern int DecryptWithSessionKey([In] IntPtr identity, [In, MarshalAs(UnmanagedType.LPWStr)] string serviceName, [In] ALG_ID algIdEncrypt, [In] ALG_ID algIdHash, [In] IntPtr cipher, [In] uint cipherSize, out IntPtr data, out uint dataSize);

        [DllImport("msidcrl40.dll", EntryPoint = "MigratePersistedCredentials")]
        internal static extern int MigratePersistedCredentials([In] ref System.Guid AppGuid, [In] bool keepOldCreds, out uint userCount);

        [DllImport("msidcrl40.dll", EntryPoint = "SetChangeNotificationCallback")]
        internal static extern int SetChangeNotificationCallback([In, MarshalAs(UnmanagedType.LPWStr)] string virtualApp, [In] uint reservedFlag, ManagedIDCRL.UserStateChangedCallback callBackFunction);

        [DllImport("msidcrl40.dll", EntryPoint = "RemoveChangeNotificationCallback")]
        internal static extern int RemoveChangeNotificationCallback();

        [DllImport("msidcrl40.dll", EntryPoint = "GetDeviceId")]
        internal static extern int GetDeviceId([In] int dwFlags, [In, MarshalAs(UnmanagedType.LPWStr)] string pvAdditionalParams, out IntPtr deviceId, out PCCERT_CONTEXT didCertContext);

        [DllImport("msidcrl40.dll", EntryPoint = "GenerateDeviceToken")]
        internal static extern int GenerateDeviceToken([In] int dwFlags, [In, MarshalAs(UnmanagedType.LPWStr)] string pvAdditionalParams, [In, MarshalAs(UnmanagedType.LPWStr)] string wszAudience, out IntPtr pwszDeviceToken);

        [DllImport("msidcrl40.dll", EntryPoint = "SetDeviceConsent")]
        internal static extern int SetDeviceConsent([In] int dwFlags, [In] int dwConsentSetting, [In, MarshalAs(UnmanagedType.LPWStr)] string pvAdditionalParams);

        [DllImport("msidcrl40.dll", EntryPoint = "CloseDeviceID")]
        internal static extern int CloseDeviceID([In] int dwFlags, [In, MarshalAs(UnmanagedType.LPWStr)] string pvAdditionalParams);

        [DllImport("msidcrl40.dll", EntryPoint = "GenerateCertToken")]
        internal static extern int GenerateCertToken([In] IntPtr hExternalIdentity, [In] uint dwFlags, out IntPtr certToken);

        [DllImport("msidcrl40.dll", EntryPoint = "EnumerateCertificates")]
        internal static extern int EnumerateCertificates([In] uint dwFlags, [In, MarshalAs(UnmanagedType.LPWStr)] string prgwszCSPs, [In, MarshalAs(UnmanagedType.LPWStr)] string prgwszThumbprints, out uint dwCerts, out IntPtr CertInfo);

        [DllImport("msidcrl40.dll", EntryPoint = "EnumerateDeviceID")]
        internal static extern int EnumerateDeviceID([In] int dwFlags, [In, MarshalAs(UnmanagedType.LPWStr)] string pvAdditionalParams, out uint dwCount, out IntPtr deviceId, out IntPtr didCertContext);

        [DllImport("msidcrl40.dll", EntryPoint = "CreateLinkedIdentityHandle")]
        internal static extern int CreateLinkedIdentityHandle([In] IntPtr Identity, [In] uint dwFlags, [In, MarshalAs(UnmanagedType.LPWStr)] string wszMemberName, out IntPtr LinkedIdentity);

        [DllImport("msidcrl40.dll", EntryPoint = "OpenAuthenticatedBrowser")]
        internal static extern int OpenAuthenticatedBrowser([In] IntPtr Identity, [In] uint webAuthFlag, [In, Optional, MarshalAs(UnmanagedType.LPWStr)] string TargetServiceName, [In, Optional, MarshalAs(UnmanagedType.LPWStr)] string ServicePolicy, [In, MarshalAs(UnmanagedType.LPWStr)] string AdditionalPostParams);

        [DllImport("msidcrl40.dll", EntryPoint = "GetAssertion")]
        internal static extern int GetAssertion([In] IntPtr Identity, [In] ref ManagedIDCRL.RSTParams pcRSTParams, [In, Out] ref uint dwMinTTL, [In] uint dwRequestFlags, out PCCERT_CONTEXT pcertContext, out IntPtr ppbPOP, out uint pcbPOP, out PCCERT_CONTEXT ppCACertContext);

        [DllImport("msidcrl40.dll", EntryPoint = "VerifyAssertion")]
        internal static extern int VerifyAssertion([In] PCCERT_CONTEXT pcertContext, [In, Out] ref uint dwMinTTL, [In] IntPtr pbPOP, [In] uint cbPOP, out PCCERT_CONTEXT ppCACertContext);
        #endregion

        #endregion
    }
    #endregion

    #region ManagedIDCRL
    /// <summary>
    /// ManagedIDCRL is a public class that exposes structures, properties and methods necessary to call the Native APIs in msidcrl.dll.     
    /// </summary>
    public class ManagedIDCRL
    {

        #region constructor
        public ManagedIDCRL()
        {
        }
        #endregion

        #region IDCRL structures

        #region PassportCredUIInfo
        /// <summary>
        ///  Describes the user interface for those API calls in which the client runtime library may need to create a user interface
        /// to interact with the user. (Currently only LogonIdentity.)
        /// This is an IDCRL structure
        /// </summary>
        [StructLayout(LayoutKind.Sequential, Pack = 4)]
        public struct PassportCredUIInfo
        {
            public IntPtr hwndParent;
            public System.Drawing.Point ptPosition;
            public System.Drawing.Size szSize;
            public bool bShow;
        };
        #endregion

        #region PassportCredCustomUI
        /// <summary>
        /// Describes customizations to the appearance of the user interface.
        /// This is an IDCRL structure
        /// </summary>
        [StructLayout(LayoutKind.Sequential, Pack = 4)]
        public struct PassportCredCustomUI
        {
            public uint cElements;
            public IntPtr customValues;

            public PassportCredCustomUI(uint cElements, IntPtr customValues)
            {
                this.cElements = cElements;
                this.customValues = customValues;
            }
        };
        #endregion

        #region Point
        /// <summary>
        /// This is an IDCRL structure
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        internal struct POINT
        {
            internal LONG x;
            internal LONG y;
            public POINT(LONG x, LONG y)
            {
                this.x = x;
                this.y = y;
            }
        };
        #endregion

        #region Size
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        internal struct SIZE
        {
            internal LONG cx;
            internal LONG cy;
            public SIZE(LONG cx, LONG cy)
            {
                this.cx = cx;
                this.cy = cy;
            }
        };

        #endregion


        /// <summary>
        /// Handle to the Indentity to the authenticated
        /// </summary>
        internal struct PassportIdentityHandle { };// * PassportIdentityHandle;

        /// <summary>
        /// Handle to the Authentication UI
        /// </summary>
        internal struct PassportUIAuthContextHandle { };// * PassportUIAuthContextHandle;

        /// <summary>
        /// Handle to the List of persistedIdentities obtained based on the Application GUID and the Persisted Cred Type
        /// </summary>
        public struct PassportEnumIdentitiesHandle { };// * PassportEnumIdentitiesHandle;

        /// <summary>
        ///  Callback notification for asynchronous identity activity. This is used for all UI-based authentications, and optionally for
        /// asynchronous ui-less authentications. This is called whenever the state of the identity is changed and the hosting application
        /// may want to react to this change. The hosting application can check the state of the identity
        /// to determine further action (see GetAuthState, below).
        ///  * RESULT
        ///  Any failed HRESULT will cause the library to discontinue anypending authentication. 
        ///  Any successful HRESULT will cause the library to continue this authentication if it is able.
        /// Return PPCRL_E_DISCONTINUE_AUTHENTICATION to explicitly stop a pending authentication for no other reason than
        /// control of flow.
        ///  IMPORTANT
        /// This may be called by any number of threads and could be called by multiple threads at the same time.
        /// The implementor should takecare to protect any resources accessed by this implementation
        /// from such clashes of access.
        /// </summary>
        /// <param name="Identity">The identity with state that has changed</param>
        /// <param name="CanContinue">The library can continue with the authentication.</param>
        public delegate DWORD CallBackDelegateWithData(IntPtr Identity, IntPtr ptr, bool CanContinue);

        /// <summary>
        /// UserStateChangedCallback 
        /// ADDED IN RELEASE
        ///     4.0
        /// DESCRIPTION
        ///   Callback notification for use state changes. This is called whenever
        ///   there is a change to the user state. E.g. user tile change, persisted
        ///   credentials change.
        /// 
        /// IMPORTANT
        ///    This may be called by any number of threads and could be called
        /// by multiple threads at the same time. The implementor should take
        ///   care to protect any resources accessed by this implementation
        ///    from such clashes of access.
        /// </summary>
        /// <param name="dwChangeID">Type of change, from NOTIFICATION_CHANGE_TYPE enum. This same ID is also provided in the IDSUserNotification struct.</param>
        /// <param name="changeData">Pointer to the notification data. Exact type depends on the change ID.</param>
        public delegate void UserStateChangedCallback(uint dwChangeID, IntPtr changeData);


        #region IDCRL_OPTION
        /// <summary>
        /// Holds an option for IDCRL initialization through InitializeEx API.
        /// m_dwId   : option id from IDCRL_OPTION_ID enum
        /// m_pValue : Option value passed in as a BYTE *. The actual data 
        /// structure will differ with the option id
        /// m_cbValue  : Byte size of the value
        /// This is an IDCRL structure
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct IDCRL_OPTION
        {
            public IDCRL_OPTION_ID m_dwId;
            public IntPtr m_pValue;
            public uint m_cbValue;
        };
        #endregion

        #region IDCRL_OPTIONS
        /// <summary>
        /// Holds all options for IDCRL initialization through InitializeEx API.
        /// m_dwCount : Number of options
        /// m_arrOptions : Array of options
        /// This is an IDCRL structure
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct IDCRL_OPTIONS
        {
            public uint m_dwCount;
            public IDCRL_OPTION m_arrOptions;
        };
        #endregion

        #region INTERNET_PROXY_INFO
        /// <summary>
        /// Contains information that is supplied with the INTERNET_OPTION_PROXY value in wininet to get or set proxy information 
        /// on a handle obtained from a call to the InternetOpen function.
        /// This is an IDCRL structure
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct INTERNET_PROXY_INFO
        {
            public uint dwAccessType;
            [MarshalAs(UnmanagedType.LPWStr)]
            public string proxyName;
            [MarshalAs(UnmanagedType.LPWStr)]
            public string ProxyBypassList;
        }
        #endregion

        #region RSTParams
        /// <summary>
        /// RSTParams - Request Security Token Params
        /// - added in IDCRL 3.2 to allow application to request multiple tokens
        ///  the structure to hold information related to request a service token
        /// This is an IDCRL structure
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct RSTParams
        {
            public uint cbSize;                                                   // size of the struct
            [MarshalAs(UnmanagedType.LPWStr)]
            public string serviceName;          // name of the service
            [MarshalAs(UnmanagedType.LPWStr)]
            public string servicePolicy;        // policy for issuing the token
            public uint tokenFlags;                                               // for SLC, use SERVICE_TOKEN_TYPE_X509V3 Otherwise, 0
            public uint tokenParams;            // Params - SLC, key size in bit,  otherwise, 0
        }
        #endregion

        #endregion

        #region ManagedWrapper Structures

        #region AuthState
        /// <summary>
        /// Holds all the return values from AuthIdentityToService and AuthIdentityToServiceEx
        /// token : ServiceTokens in the requested format
        /// resultFlags : Returns the errorcode incase the service tokens could not be obtained
        /// sessionKey :If the service token format supports it, this will return a session key to the hosting
        /// application that matches the symmetric session key inside the service token. 
        /// This key material is binary, so care should be taken to not utilize any manipulations that 
        /// may terminate on embedded null or non-printable characters.
        /// sessionKeyLength : Lengtth of the session key
        /// This is a managed wrapper structure
        /// </summary>
        public struct AuthState
        {
            internal string token;
            internal uint resultFlags;
            internal string sessionKey;
            internal uint sessionKeyLength;
            public string Token
            {
                get { return this.token; }
            }

            public uint ResultFlags
            {
                get { return this.resultFlags; }
            }
            public string SessionKey
            {
                get { return this.sessionKey; }
            }

            public uint SessionKeyLength
            {
                get { return this.sessionKeyLength; }
            }
        };
        #endregion

        #region LogonState

        /// <summary>
        /// Holds all the return values from GetAuthState and GetAuthStateEx
        /// AuthState : Authentication status
        /// AuthRequired : The authentication required (if any)
        /// RequestStatus : Status of the last request based on this identity
        /// WebFlowUrl : May optionally return a URL that the hosting application can take the user to in order 
        /// to explain and/or resolve theerror.
        /// This is a managed wrapper structure
        /// </summary>
        public struct LogonState
        {
            public int AuthState;
            public int AuthRequired;
            public int RequestStatus;
            public string WebFlowUrl;
        };
        #endregion

        #region MD5

        /// <summary>
        /// It holds the data returned by GetWebAuthUrl
        /// md5Url : The Url to the MD5 login Service
        /// postData : Blob of data that can be POSTed to the URL for authentication
        /// This is a managed wrapper structure
        /// </summary>
        public struct MD5Data
        {
            internal string md5Url;
            internal string postData;

            public string MD5Url
            {
                get { return this.md5Url; }
            }

            public string PostData
            {
                get { return this.postData; }
            }
        };
        #endregion

        #region SHA1
        /// <summary>
        /// It holds the data returned by GetWebAuthUrl
        /// Sha1Url : The Url to the MD5 login Service
        /// Sha1PostData : Blob of data that can be POSTed to the URL for authentication
        /// This is a managed wrapper structure
        /// </summary>
        public struct SHA1
        {
            internal string sha1Url;
            internal string sha1PostData;

            public string Sha1Url
            {
                get { return this.sha1Url; }
            }

            public string Sha1PostData
            {
                get { return this.sha1PostData; }
            }
        };
        #endregion

        #region CertSet
        /// <summary>
        /// This structure holds all the certbased information. It contains IntPtr to the ShortlivedCertificate and CA Certificate.
        /// It all contains X509Certificate instances of these certificate, IntPtrs to Proof of Possession(POP)and size of POP.
        /// This is a managed wrapper structure
        /// </summary>
        public struct CertSet
        {
            internal IntPtr ppcertContext;
            internal IntPtr ppCACertContext;
            internal uint popSize;              //these are left as intptrs b/c the application is not expected to use or manipulate them
            internal IntPtr popBlob;            //these are left as intptrs b/c the application is not expected to use or manipulate them
            internal X509Certificate x509Cert;
            internal X509Certificate x509CACert;
            internal X509Certificate2 x509Cert2;
            internal X509Certificate2 x509CACert2;


            internal string x509CertStr;
            internal string x509CACertStr;
            internal string popBlobStr;            //these are left as intptrs b/c the application is not expected to use or manipulate them

            public IntPtr PPCertContext
            {
                get { return this.ppcertContext; }
            }
            public IntPtr PPCACertContext
            {
                get { return this.ppCACertContext; }
            }

            public IntPtr PopBlob
            {
                get { return this.popBlob; }
            }

            public uint PopSize
            {
                get { return this.popSize; }
            }

            public X509Certificate X509Cert
            {
                get { return this.x509Cert; }
            }
            public X509Certificate X509CACert
            {
                get { return this.x509CACert; }
            }

            public X509Certificate2 X509Cert2
            {
                get { return this.x509Cert2; }
            }
            public X509Certificate2 X509CACert2
            {
                get { return this.x509CACert2; }
            }


            public string PopBlobStr
            {
                get { return this.popBlobStr; }
            }
            public string X509CertStr
            {
                get { return this.x509CertStr; }
            }
            public string X509CACertStr
            {
                get { return this.x509CACertStr; }
            }

            internal CertSet(IntPtr certContext, IntPtr popBlob, uint popSize, IntPtr caCertContext)
            {
                if(certContext != IntPtr.Zero)
                {
                    this.ppcertContext = certContext;
                    this.x509Cert = new X509Certificate(certContext);
                    this.x509CertStr = Marshal.PtrToStringUni(certContext);
                    
                    this.x509Cert2 = new X509Certificate2(certContext);
                }
                else
                {
                    this.ppcertContext = IntPtr.Zero;
                    this.x509Cert = new X509Certificate();
                    this.x509Cert2 = new X509Certificate2();
                    this.x509CertStr = string.Empty;
                }

                if(caCertContext != IntPtr.Zero)
                {
                    this.ppCACertContext = caCertContext;
                    this.x509CACert = (caCertContext == IntPtr.Zero) ? new X509Certificate() : new X509Certificate(caCertContext);
                    this.x509CACertStr = Marshal.PtrToStringUni(caCertContext);

                    this.x509CACert2 = (caCertContext == IntPtr.Zero) ? new X509Certificate2() : new X509Certificate2(caCertContext);

                }
                else
                {
                    this.ppCACertContext = IntPtr.Zero;
                    this.x509CACert = new X509Certificate();
                    this.x509CACertStr = string.Empty;
                    this.x509CACert2 = new X509Certificate2();
                }
                
                this.popBlob = popBlob;
                if (popBlob != IntPtr.Zero)
                {  
                    this.popBlobStr = Marshal.PtrToStringUni(popBlob);
                }
                else
                {
                    this.popBlobStr = string.Empty;
                }

                this.popSize = popSize;

            }
        }
        #endregion

        #region ExtendedError
        /// <summary>
        /// This is a managedWrapper structure. It returns the errorCategory. Errorcode and errorblob
        /// </summary>
        public struct ExtendedError
        {
            internal ManagedIDCRL.IDCRL_ERROR_CATEGORY category;
            internal uint errorCode;
            internal string errorBlob;

            public ManagedIDCRL.IDCRL_ERROR_CATEGORY Category
            {
                get { return this.category; }
            }

            public uint ErrorCode
            {
                get { return this.errorCode; }
            }

            public string ErrorBlob
            {
                get { return this.errorBlob; }
            }

        };
        #endregion

        #region Initialize_Options
        /// <summary>
        /// Holds all options for IDCRL initialization through InitializeEx API.
        /// optionType : option id from IDCRL_OPTION_ID enum
        /// proxyUserInfo : This could be the proxy user name or password depending on the IDCRL_OPTION_ID
        /// timeOut : The actual timeout value for the IDCRL_OPTION_ID
        /// proxyInfo :  instance to of INTERNET_PROXY_INFO struct
        /// This is an Managed Wrapper structure
        /// </summary>
        public struct Initialize_Options
        {
            public IDCRL_OPTION_ID optionType;
            [MarshalAs(UnmanagedType.LPWStr)]
            public string proxyUserInfo;
            public int[] timeOut;
            public INTERNET_PROXY_INFO proxyInfo;
        }

        #endregion
        #endregion


        #region Constants

        public const string PPCRL_CREDTYPE_PASSWORD = "ps:password";
        public const string PPCRL_CREDTYPE_MEMBERNAMEONLY = "ps:membernameonly";
        public const string PPCRL_CREDTYPE_VIRUTUALAPPPrefix = "ps:virtualapp=";
        public const string PPCRL_CREDTYPE_PIN = "ps:pin";
        public const string PPCRL_CREDTYPE_EID = "ps:eid";

        // properties names for GetIdentityPropertyByName 
        //public const string PPCRL_CREDPROPERTY_CID = "CID";
        //public const string PPCRL_CREDPROPERTY_USERTILEURL = "UserTileURL";

        public const string EXT_USER_PROPERTY_NAME_USERTILEURL = "UserTileUrl";
        public const string EXT_USER_PROPERTY_NAME_IDTILETIMESTAMP = "IDTileTimestamp";
        public const string EXT_USER_PROPERTY_VALUE_REMOVE = null;

        //These can be used with GetIdentityPropertyByName API
        public const string  PPCRL_CREDPROPERTY_MEMBER_NAME            = "MemberName";
	    public const string  PPCRL_CREDPROPERTY_PUIDSTR                = "PUID";
	    public const string  PPCRL_CREDPROPERTY_ONETIMECREDENTIAL      = "OneTimeCredential";
	    public const string  PPCRL_CREDPROPERTY_CID                    = "CID";
	    public const string  PPCRL_CREDPROPERTY_MAINBRANDID            = "MainBrandID";
        public const string  PCRL_CREDPROPERTY_BRANDIDLIST             = "BrandIDList";
	    public const string  PPCRL_CREDPROPERTY_ISWINLIVEUSER          = "IsWinLiveUser";
        public const string  PPCRL_CREDPROPERTY_EID                    = "EID";
        public const string  PPCRL_CREDPROPERTY_LINKID                 = "LinkId";
        public const string  PPCRL_CREDPROPERTY_LINKVER                = "LinkVer";
        public const string  PPCRL_CREDPROPERTY_LINKEDIDS              = "LinkedIds";

        public const int S_OK = 0;
        public const int Default_Flag = 0;

        // extended properties for all the users on the windows logon session
        public const string EXT_PROPERTY_NAME_PUBLICCOMPUTER = "PublicComputer";
        public const string EXT_PROPERTY_VALUE_TRUE = "1";
        public const string EXT_PROPERTY_VALUE_FALSE = "0";
        public const string EXT_PROPERTY_VALUE_REMOVE = null;

        #endregion

        #region Enums
        #region Internet Proxy Options from wininet.h
        /// <summary>
        /// The Internet Acess types in wininet
        /// </summary>
        public enum INTERNET_CONNECTION_OPTIONS
        {
            INTERNET_OPEN_TYPE_PRECONFIG = 0,   // use registry configuration
            INTERNET_OPEN_TYPE_DIRECT = 1,       // direct to net
            INTERNET_OPEN_TYPE_PROXY = 3,       // via named proxy
            INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY = 4,   // prevent using java/script/INS
        };
        #endregion
        /// <summary>
        /// IDCRL_OPTION_IDS enum : IDs of valid options that can be given to InitializeEx call
        /// </summary>
        public enum IDCRL_OPTION_ID : int
        {
            IDCRL_OPTION_ALL_BIT = 0x0000007F, // reserved
            IDCRL_OPTION_PROXY = 0x00000001, //INTERNET_OPTION_PROXY
            IDCRL_OPTION_CONNECT_TIMEOUT = 0x00000002, //INTERNET_OPTION_CONNECT_TIMEOUT
            IDCRL_OPTION_SEND_TIMEOUT = 0x00000004, //INTERNET_OPTION_SEND_TIMEOUT
            IDCRL_OPTION_RECEIVE_TIMEOUT = 0x00000008, //INTERNET_OPTION_RECEIVE_TIMEOUT
            IDCRL_OPTION_PROXY_PASSWORD = 0x00000010, //INTERNET_OPTION_PROXY_PASSWORD
            IDCRL_OPTION_PROXY_USERNAME = 0x00000020, //INTERNET_OPTION_PROXY_USERNAME
            IDCRL_OPTION_ENVIRONMENT = 0x00000040  //Point to the named environment
        };

        /// <summary>
        ///  Used for retrieving properties about a given identity handle.
        /// </summary>
        public enum PassportIdentityProperty
        {
            IDENTITY_MEMBER_NAME = 1,
            IDENTITY_PUIDSTR = 2,
            //IDENTITY_ONETIMECREDENTIAL = 3,
        };

        /// <summary>
        /// Flags controlling general behavior of the library passed in during the Initialize call. Normally the update
        /// mechanism operates periodically and automatically based on a time-out policy. These flags allow the hosting application
        /// to over-ride this behavior. They also allow the hosting application to indicate that it can operate in offline mode (an M2 feature).
        /// IDCRL 3.2: OFFLINE_MODE_ALLOWED is ignored, it will mean the same asIDCRL 3.2: SKIP_CONNECTION_CHECK: When this mode is set, IDCRL will
        ///  not check if a network and Internet connection is enabled before making network calls. In this case, you will get the default windows
        ///  dialog to establish a connection if you are not connected already. The default IDCRL behavior is to fail with an error if there is no
        ///  connection available or default connection is not established anduser has chosen to "Always dial my default connection" setting in IE.
        /// </summary>
        public enum UpdateFlag : uint
        {
            UPDATE_FLAG_ALL_BIT = 0x00000000F,            // reserved
            DEFAULT_UPDATE_POLICY = 0x00000000,
            OFFLINE_MODE_ALLOWED = 0x00000001,
            NO_UI = 0x00000002,
            SKIP_CONNECTION_CHECK = 0x00000004,
            SET_EXTENDED_ERROR = 0x00000008,
            SEND_VERSION = 0x00000010,  // reserved, don't use this flag
                                        // internal notes only:
                                        // Do NOT add it into UPDATE_FLAG_ALL_BIT, otherwise
                                        // partner applications using UPDATE_FLAG_ALL_BIT 
                                        // would automatically pick up this flag. 
                                        // We should also allow this flag in input flag checking
            UPDATE_DEFAULT = DEFAULT_UPDATE_POLICY // online, fall back to offline

        };

        /// <summary>
        /// LOGON_FLAG enum
        /// Flags that can be passed into the various LogonIdentity API's to control the authentication process.
        /// </summary>
        public enum LogonFlag : uint
        {
            LOGONIDENTITY_ALL_BIT = 0x000001FF, // reserved
            LOGONIDENTITY_DEFAULT = 0x00000000,
            LOGONIDENTITY_ALLOW_OFFLINE = 0x00000001,
            LOGONIDENTITY_FORCE_OFFLINE = 0x00000002,
            LOGONIDENTITY_CREATE_OFFLINE_HASH = 0x00000004,
            LOGONIDENTITY_ALLOW_PERSISTENT_COOKIES = 0x00000008,
            LOGONIDENTITY_USE_EID_AUTH = 0x00000010,
            LOGONIDENTITY_USE_LINKED_ACCOUNTS = 0x00000020,
            LOGONIDENTITY_FEDERATED = 0x00000040,
            LOGONIDENTITY_WLID = 0x00000080,
            LOGONIDENTITY_AUTO_PARTNER_REDIRECT = 0x00000100
        };

        /// <summary>
        /// IDENTITY_FLAG enum
        /// Flags controlling properties of a particular identity handle. May be combined and passed in to the
        /// dwFlags parameter to CreateIdentityHandle.
        /// </summary>
        public enum IdentityFlag : uint
        {
            IDENTITY_ALL_BIT = 1023, // reserved
            IDENTITY_SHARE_ALL = 255, // in 4.5 # Reverted to old flag bug 379909
            //IDENTITY_SHARE_ALL = 511, // Specific bit semantics are reserved - Changed in 5.0
            IDENTITY_LOAD_FROM_PERSISTED_STORE = 256, // this requires member name, and will do a look up in the persisted store
            IDENTITY_AUTHSTATE_ENCRYPTED = 512  // used by CreateIdentityHandleFromAuthState to indicate if the auth info is encrypted

        };

        /// <summary>
        /// Determines the algorithm to use to derive the offline key.
        /// </summary>
        internal enum OfflineKeyMethod
        {
            OFFLINE_KEY_PBKDF2_ON_PASSWORD = 1,
        };

        /// <summary>
        /// Used for retrieving properties about a given identity handle.
        /// </summary>
        public enum ServiceTokenFlags : uint
        {
            SERVICE_TOKEN_TYPE_LEGACY_PASSPORT = 0x00000001,  //Deprecated, use SERVICE_TOKEN_TYPE_PROPRIETARY
            SERVICE_TOKEN_TYPE_WEBSSO = 0x00000002,           //Deprecated, use SERVICE_TOKEN_TYPE_SAML
            SERVICE_TOKEN_TYPE_COMPACT_WEBSSO = 0x00000004,   //Deprecated, use SERVICE_TOKEN_TYPE_PROPRIETARY
            SERVICE_TOKEN_TYPE_ANY = 0x000000ff,             
            SERVICE_TOKEN_FROM_CACHE = 0x00010000,
            SERVICE_TOKEN_TYPE_X509V3 = 0x00000008,
            SERVICE_TOKEN_CERT_IN_MEMORY_PRIVATE_KEY = 0x00000010,
            SERVICE_TOKEN_REQUEST_TYPE_NONE = 0x00000000,
            SERVICE_TOKEN_TYPE_PROPRIETARY = SERVICE_TOKEN_TYPE_LEGACY_PASSPORT,
            SERVICE_TOKEN_TYPE_SAML = SERVICE_TOKEN_TYPE_WEBSSO, //Response only

        } ;

        /// <summary>
        /// CERTREQUESTFLAGS enum : flags for GetCertificate call.
        /// </summary>
        public enum CertRequestFlags : uint
        {
            CERT_FROM_CACHE = ServiceTokenFlags.SERVICE_TOKEN_FROM_CACHE,
            CERT_FROM_SERVER = 0x00020000

        };

        public enum ResponseType : uint
        {
            PPCRL_RESPONSE_TYPE_AUTH = 0x00000000,
            PPCRL_RESPONSE_TYPE_SERVICE = 0x00000001
        };

        public enum WebAuthOptions : uint
        {
            IDCRL_WEBAUTH_NONE = 0x00000000,
            IDCRL_WEBAUTH_REAUTH = 0x00000001,
            IDCRL_WEBAUTH_PERSISTENT = 0x00000002

        };

        public enum IDCRL_ERROR_CATEGORY : uint
        {
            IDCRL_REQUEST_BUILD_ERROR = 0x00000001,
            IDCRL_REQUEST_SEND_ERROR = 0x00000002,
            IDCRL_RESPONSE_RECEIVE_ERROR = 0x00000003,
            IDCRL_RESPONSE_READ_ERROR = 0x00000004,
            IDCRL_REPSONSE_PARSE_ERROR = 0x00000005,
            IDCRL_RESPONSE_SIG_DECRYPT_ERROR = 0x00000006,
            IDCRL_RESPONSE_PARSE_HEADER_ERROR = 0x00000007,
            IDCRL_RESPONSE_PARSE_TOKEN_ERROR = 0x00000008,
            IDCRL_RESPONSE_PUTCERT_ERROR = 0x00000009
        };
        ///<summary>
        /// ADDED IN RELEASE
        /// 4.0
        /// DESCRIPTION
        /// IDS_USER_ACCOUNT_CHANGE: Creds were persisted or removed.
        /// IDS_USER_PROPERTY_CHANGE: user property, extended property changed.
        /// </summary>
        public enum NOTIFICATION_CHANGE_TYPE : uint
        {
            NOTIFICATION_CHANGE_ALL_BIT = 0x000000003,  // reserved
            IDS_USER_ACCOUNT_CHANGE = 0x000000001,
            IDS_USER_PROPERTY_CHANGE = 0x000000002
        }
        /// <summary>
        /// NOTIFICATION_ACTION_TYPE enum
        /// ADDED IN RELEASE
        /// 4.0
        ///
        /// DESCRIPTION
        /// IDS_NOTIFY_ADD: notification target was added
        /// IDS_NOTIFY_UPDATE: notification target was updated
        /// IDS_NOTIFY_DELETE: notification target was deleted
        /// </summary>
        public enum NOTIFICATION_ACTION_TYPE : uint
        {
            IDS_NOTIFY_ACTION_ALL_BIT = 0x000000007,  // reserved
            IDS_NOTIFY_ACTION_ADD = 0x000000001,
            IDS_NOTIFY_ACTION_UPDATE = 0x000000002,
            IDS_NOTIFY_ACTION_DELETE = 0x000000004
        }

        /// IDCRL_SETOPTIONS_FLAG enum
        /// IDs of valid options that can be given to InitializeEx call
        public enum IDCRL_SETOPTIONS_FLAG : uint
        {
            IDCRL_SETOPTIONS_DEFAULT = 0x00000000,
            IDCRL_SETOPTIONS_SET = IDCRL_SETOPTIONS_DEFAULT,
            IDCRL_SETOPTIONS_RESET = 0x00000001
        }

        /// <summary>
        /// IDCRL_DEVICE_ID_OPTIONS Flag enum
        /// Flags passed to GetDeviceID and Generate DeviceToken APIs to change 
        /// behavior of deviceid
        /// </summary>
        public enum IDCRL_DEVICE_ID_OPTIONS : int
        {
            IDCRL_DEVICE_ID_FORCENEWPASSWORD = 1,
            IDCRL_DEVICE_ID_IMPERSONATE = 2,
            IDCRL_DEVICE_ID_KEYROLLOVER = 4,
            IDCRL_DEVICE_ID_PHYSICAL = 8,
            IDCRL_DEVICE_ID_LOGICAL = 0,
            IDCRL_DEVICE_ID_FROMCACHE = 16,
            IDCRL_DEVICE_ID_ACCESSCHECK = 32
        };

        /// <summary>
        /// IDCRL_DEVICE_CONSENT_OPTIONS Flag enum
        /// Flags passed to SetConsent API to change consent behavior
        /// </summary>
        public enum IDCRL_DEVICE_CONSENT_OPTIONS : int
        {
            IDCRL_DEVICE_ID_CONSENT_MIN = 0x00000000,
            IDCRL_DEVICE_ID_CONSENT_GRANT = 0x00000001,
            IDCRL_DEVICE_ID_CONSENT_REVOKE = 0x00000002,
            IDCRL_DEVICE_ID_CONSENT_REMOVE = 0x00000003,
            IDCRL_DEVICE_ID_CONSENT_MAX = 0x00000004,
        };

        #endregion
        /// <summary>
        /// IDSUserNotification
        ///
        /// ADDED IN RELEASE
        ///     4.0
        ///
        /// DESCRIPTION
        ///    Structure to the change data that is given to the application in the
        ///    UserStateChangeCallback.
        /// NOTE
        ///    Application must make a copy of string buffers before returning
        ///     from the callback because the memory will be freed by IDCRL as soon as 
        ///    the callback function returns 
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct IDSUserNotification
        {
            public uint type;             // This and dwChangeID in the callback are same
            public uint action;           // Add, update or delete
            [MarshalAs(UnmanagedType.LPWStr)]
            public string accountName;
            [MarshalAs(UnmanagedType.LPWStr)]
            public string credType;
        }

        /// <summary>
        /// IDSUserPropertyNotification
        /// ADDED IN RELEASE
        ///      4.0
        ///
        /// DESCRIPTION
        ///     Structure to the change data that is given to the application in the
        ///    UserStateChangeCallback.
        /// NOTE
        ///   Application must make a copy of string buffers before returning
        ///     from the callback because the memory will be freed by IDCRL as soon as 
        ///    the callback function returns.
        ///    If the property value is too large to pass in the notification,
        ///    fValueTooLarge flag will be set to True. Apps must call 
        ///    GetUserExtendedProperty to get the actual value in this case.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct IDSUserPropertyNotification
        {
            public uint type;             // This and dwChangeID in the callback are same
            public uint action;           // Add, update or delete
            bool bValueTooLarge;     // Property value is too large
            [MarshalAs(UnmanagedType.LPWStr)]
            public string accountName;
            [MarshalAs(UnmanagedType.LPWStr)]
            public string propertyName;
            [MarshalAs(UnmanagedType.LPWStr)]
            public string propertyValue;
        }


        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct IDCRLCertInfo
        {
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 36)]
            public char[] thumbprint;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 96)]
            public char[] description;
        }
        #region Interface Methods


        #region Initialize
        /// <summary>
        /// Initialize : Must be called before and return successfully before any other client runtime library functions are called.
        /// </summary>
        /// <param name="appGuid">A GUID that uniquely identifies the hosting application. This allows features such as customized user interfaces
        /// to match the hosting application's look and feel.</param>
        /// <param name="ppclrVersion">Binary version of the API</param>
        /// <param name="updateFlags">Initialization flags from the UPDATE_FLAG enum above.</param>
        /// <returns>Suceessful HResult</returns>        
        public int Initialize(ref System.Guid appGuid, int ppclrVersion, uint updateFlags)
        {
            int HResult = 0;
            HResult = NativeMethods.Initialize(ref appGuid, ppclrVersion, updateFlags);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            return HResult;

        }
        #endregion

        #region InitializeEx
        /// <summary> Must be called before and return successfully before any other
        /// client runtime library functions are called. This function supports
        /// setting some optional parameters that Initialize does not support.        
        /// </summary>
        /// <param name="appGuid">A GUID that uniquely identifies the hosting application. This allows features such as customized user interfaces
        /// to match the hosting application's look and feel.</param>
        /// <param name="ppcrlVersion">Binary version of the API</param>
        /// <param name="updateFlags">Initialization flags from the UPDATE_FLAG enum above.</param>
        /// <param name="options">Additional options to set. e.g. proxy information.</param>
        /// <param name="count">count of options in pOptions.</param>
        /// <returns>Suceessful HResult</returns>
        public int InitializeEx(ref System.Guid appGuid, int ppcrlVersion, uint updateFlags, IDCRL_OPTION[] options, uint count)
        {
            int HResult = 0;
            HResult = NativeMethods.InitializeEx(ref appGuid, ppcrlVersion, updateFlags, options, count);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            return HResult;
        }
        #endregion

        #region InitializeEx Overload with Proxy and InitializeEx options
        /// <summary> Must be called before and return successfully before any otherclient runtime library functions are called. 
        /// This function supports setting some optional parameters that Initialize does not support.
        /// This overloads takes an array of Initialize_Options and constructs an array of IDCRL_OPTIONS. 
        /// This saves the application from doing the marshalling.
        /// </summary>
        /// <param name="appGuid">A GUID that uniquely identifies the hosting application. This allows features such as customized user interfaces
        /// to match the hosting application's look and feel.</param>
        /// <param name="ppcrlVersion">Binary version of the API</param>
        /// <param name="updateFlags">Initialization flags from the UPDATE_FLAG enum above.</param>
        /// <param name="initOptions">Array of Initialize_Options for addittional options to set. </param>
        /// <returns></returns>
        public int InitializeEx(ref System.Guid appGuid, int ppcrlVersion, uint updateFlags, Initialize_Options[] initOptions)
        {

            int HResult = 0;
            IDCRL_OPTION[] arrOpts = new IDCRL_OPTION[initOptions.Length];
            IntPtr memPtr = IntPtr.Zero;
            GCHandle[] hBuffer = new GCHandle[initOptions.Length];
            int size = 0;
            for (int i = 0; i < initOptions.Length; i++)
            {
                switch (initOptions[i].optionType)
                {
                    case IDCRL_OPTION_ID.IDCRL_OPTION_PROXY:
                        {
                            size = Marshal.SizeOf(initOptions[i].proxyInfo);
                            byte[] buffer = new byte[size];

                            //Get a Ptr to the Proxy
                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();

                            Marshal.StructureToPtr(initOptions[i].proxyInfo, memPtr, true);

                            break;
                        }
                    case IDCRL_OPTION_ID.IDCRL_OPTION_PROXY_PASSWORD:
                        {
                            //create the src byte[]
                            byte[] proxyPasswd = Encoding.Unicode.GetBytes(initOptions[i].proxyUserInfo);

                            //set size 
                            size = proxyPasswd.Length;

                            //create destination buffer
                            byte[] buffer = new byte[proxyPasswd.Length];
                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();

                            Marshal.Copy(proxyPasswd, 0, memPtr, proxyPasswd.Length);

                            break;
                        }
                    case IDCRL_OPTION_ID.IDCRL_OPTION_PROXY_USERNAME:
                        {
                            //get the src byte[]
                            byte[] proxyUser = Encoding.Unicode.GetBytes(initOptions[i].proxyUserInfo);

                            //set size 
                            size = proxyUser.Length;

                            //get destination byte[]
                            byte[] buffer = new byte[proxyUser.Length];

                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();

                            Marshal.Copy(proxyUser, 0, memPtr, proxyUser.Length);
                            break;
                        }
                    case IDCRL_OPTION_ID.IDCRL_OPTION_CONNECT_TIMEOUT:
                        {
                            size = Marshal.SizeOf(initOptions[i].timeOut[0].GetType()) * initOptions[i].timeOut.Length;
                            byte[] buffer = new byte[size];

                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();
                            Marshal.Copy(initOptions[i].timeOut, 0, memPtr, initOptions[i].timeOut.Length);

                            break;
                        }
                    case IDCRL_OPTION_ID.IDCRL_OPTION_RECEIVE_TIMEOUT:
                        {
                            size = Marshal.SizeOf(initOptions[i].timeOut[0].GetType()) * initOptions[i].timeOut.Length;
                            byte[] buffer = new byte[size];

                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();
                            Marshal.Copy(initOptions[i].timeOut, 0, memPtr, initOptions[i].timeOut.Length);
                            break;
                        }
                    case IDCRL_OPTION_ID.IDCRL_OPTION_SEND_TIMEOUT:
                        {
                            size = Marshal.SizeOf(initOptions[i].timeOut[0].GetType()) * initOptions[i].timeOut.Length;
                            byte[] buffer = new byte[size];

                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();
                            Marshal.Copy(initOptions[i].timeOut, 0, memPtr, initOptions[i].timeOut.Length);
                            break;
                        }
                    case IDCRL_OPTION_ID.IDCRL_OPTION_ENVIRONMENT:
                        {
                            //create the src byte[]
                            byte[] enviornment = Encoding.Unicode.GetBytes(initOptions[i].proxyUserInfo);

                            //set size 
                            size = enviornment.Length;

                            //create destination buffer
                            byte[] buffer = new byte[enviornment.Length];
                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();

                            Marshal.Copy(enviornment, 0, memPtr, enviornment.Length);

                            break;
                        }
                    default:
                        {
                            memPtr = IntPtr.Zero;
                            size = 0;
                            break;
                        }
                }

                //populate the array that needs to be sent to the native code
                arrOpts[i].m_dwId = initOptions[i].optionType;
                arrOpts[i].m_pValue = memPtr;
                arrOpts[i].m_cbValue = (uint)size;

                //reset the memory and size
                memPtr = IntPtr.Zero;
                size = 0;

            }

            HResult = NativeMethods.InitializeEx(ref appGuid, ppcrlVersion, updateFlags, arrOpts, (uint)arrOpts.Length);

            for (int i = 0; i < initOptions.Length; i++)
            {
                arrOpts[i].m_pValue = IntPtr.Zero;
                if (hBuffer[i].IsAllocated)
                {
                    hBuffer[i].Free();
                }
            }

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            return HResult;
        }
        #endregion

        #region InitializeEx Overload with Proxy and InitializeEx options
        /// <summary> Must be called before and return successfully before any otherclient runtime library functions are called. 
        /// This function supports setting some optional parameters that Initialize does not support.
        /// This overloads takes an array of Initialize_Options and constructs an array of IDCRL_OPTIONS. 
        /// This saves the application from doing the marshalling.
        /// </summary>
        /// <param name="appGuid">A GUID that uniquely identifies the hosting application. This allows features such as customized user interfaces
        /// to match the hosting application's look and feel.</param>
        /// <param name="ppcrlVersion">Binary version of the API</param>
        /// <param name="updateFlags">Initialization flags from the UPDATE_FLAG enum above.</param>
        /// <param name="initOptions">Array of Initialize_Options for addittional options to set. </param>
        /// <returns></returns>
        public int InitializeEx(ref System.Guid appGuid, int ppcrlVersion, uint updateFlags, Initialize_Options[] initOptions, uint count)
        {
            int HResult = 0;
            IDCRL_OPTION[] arrOpts = new IDCRL_OPTION[initOptions.Length];
            IntPtr memPtr = IntPtr.Zero;
            GCHandle[] hBuffer = new GCHandle[initOptions.Length];
            int size = 0;
            for (int i = 0; i < initOptions.Length; i++)
            {
                switch (initOptions[i].optionType)
                {
                    case IDCRL_OPTION_ID.IDCRL_OPTION_PROXY:
                        {
                            size = Marshal.SizeOf(initOptions[i].proxyInfo);
                            byte[] buffer = new byte[size];

                            //Get a Ptr to the Proxy
                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();

                            Marshal.StructureToPtr(initOptions[i].proxyInfo, memPtr, true);

                            break;
                        }
                    case IDCRL_OPTION_ID.IDCRL_OPTION_PROXY_PASSWORD:
                        {
                            //create the src byte[]
                            byte[] proxyPasswd = Encoding.Unicode.GetBytes(initOptions[i].proxyUserInfo);

                            //set size 
                            size = proxyPasswd.Length;

                            //create destination buffer
                            byte[] buffer = new byte[proxyPasswd.Length];
                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();

                            Marshal.Copy(proxyPasswd, 0, memPtr, proxyPasswd.Length);

                            break;
                        }
                    case IDCRL_OPTION_ID.IDCRL_OPTION_PROXY_USERNAME:
                        {
                            //get the src byte[]
                            byte[] proxyUser = Encoding.Unicode.GetBytes(initOptions[i].proxyUserInfo);

                            //set size 
                            size = proxyUser.Length;

                            //get destination byte[]
                            byte[] buffer = new byte[proxyUser.Length];

                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();

                            Marshal.Copy(proxyUser, 0, memPtr, proxyUser.Length);
                            break;
                        }
                    case IDCRL_OPTION_ID.IDCRL_OPTION_CONNECT_TIMEOUT:
                        {
                            size = Marshal.SizeOf(initOptions[i].timeOut[0].GetType()) * initOptions[i].timeOut.Length;
                            byte[] buffer = new byte[size];

                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();
                            Marshal.Copy(initOptions[i].timeOut, 0, memPtr, initOptions[i].timeOut.Length);

                            break;
                        }
                    case IDCRL_OPTION_ID.IDCRL_OPTION_RECEIVE_TIMEOUT:
                        {
                            size = Marshal.SizeOf(initOptions[i].timeOut[0].GetType()) * initOptions[i].timeOut.Length;
                            byte[] buffer = new byte[size];

                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();
                            Marshal.Copy(initOptions[i].timeOut, 0, memPtr, initOptions[i].timeOut.Length);
                            break;
                        }
                    case IDCRL_OPTION_ID.IDCRL_OPTION_SEND_TIMEOUT:
                        {
                            size = Marshal.SizeOf(initOptions[i].timeOut[0].GetType()) * initOptions[i].timeOut.Length;
                            byte[] buffer = new byte[size];

                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();
                            Marshal.Copy(initOptions[i].timeOut, 0, memPtr, initOptions[i].timeOut.Length);
                            break;
                        }
                    case IDCRL_OPTION_ID.IDCRL_OPTION_ENVIRONMENT:
                        {
                            //create the src byte[]
                            byte[] enviornment = Encoding.Unicode.GetBytes(initOptions[i].proxyUserInfo);

                            //set size 
                            size = enviornment.Length;

                            //create destination buffer
                            byte[] buffer = new byte[enviornment.Length];
                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();

                            Marshal.Copy(enviornment, 0, memPtr, enviornment.Length);
                            break;
                        }
                    default:
                        {
                            memPtr = IntPtr.Zero;
                            size = 0;
                            break;
                        }
                }

                //populate the array that needs to be sent to the native code
                arrOpts[i].m_dwId = initOptions[i].optionType;
                arrOpts[i].m_pValue = memPtr;
                arrOpts[i].m_cbValue = (uint)size;

                //reset the memory and size
                memPtr = IntPtr.Zero;
                size = 0;

            }
            HResult = NativeMethods.InitializeEx(ref appGuid, ppcrlVersion, updateFlags, arrOpts, count);

            for (int i = 0; i < initOptions.Length; i++)
            {
                arrOpts[i].m_pValue = IntPtr.Zero;
                if (hBuffer[i].IsAllocated)
                {
                    hBuffer[i].Free();
                }
            }

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            return HResult;
        }
        #endregion

        #region InitializeApp Overload with Proxy and InitializeEx options
        /// <summary> Must be called before and return successfully before any otherclient runtime library functions are called. 
        /// This function supports setting some optional parameters that Initialize does not support.
        /// This overloads takes an array of Initialize_Options and constructs an array of IDCRL_OPTIONS. 
        /// This saves the application from doing the marshalling.
        /// </summary>
        /// <param name="appGuid">A GUID that uniquely identifies the hosting application. This allows features such as customized user interfaces
        /// to match the hosting application's look and feel.</param>
        /// <param name="ppcrlVersion">Binary version of the API</param>
        /// <param name="updateFlags">Initialization flags from the UPDATE_FLAG enum above.</param>
        /// <param name="initOptions">Array of Initialize_Options for addittional options to set. </param>
        /// <returns></returns>
        public int InitializeApp(string appID, int ppcrlVersion, uint updateFlags, Initialize_Options[] initOptions)
        {

            int HResult = 0;
            IDCRL_OPTION[] arrOpts = new IDCRL_OPTION[initOptions.Length];
            IntPtr memPtr = IntPtr.Zero;
            GCHandle[] hBuffer = new GCHandle[initOptions.Length];
            int size = 0;
            for (int i = 0; i < initOptions.Length; i++)
            {
                switch (initOptions[i].optionType)
                {
                    case IDCRL_OPTION_ID.IDCRL_OPTION_PROXY:
                        {
                            size = Marshal.SizeOf(initOptions[i].proxyInfo);
                            byte[] buffer = new byte[size];

                            //Get a Ptr to the Proxy
                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();

                            Marshal.StructureToPtr(initOptions[i].proxyInfo, memPtr, true);

                            break;
                        }
                    case IDCRL_OPTION_ID.IDCRL_OPTION_PROXY_PASSWORD:
                        {
                            //create the src byte[]
                            byte[] proxyPasswd = Encoding.Unicode.GetBytes(initOptions[i].proxyUserInfo);

                            //set size 
                            size = proxyPasswd.Length;

                            //create destination buffer
                            byte[] buffer = new byte[proxyPasswd.Length];
                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();

                            Marshal.Copy(proxyPasswd, 0, memPtr, proxyPasswd.Length);

                            break;
                        }
                    case IDCRL_OPTION_ID.IDCRL_OPTION_PROXY_USERNAME:
                        {
                            //get the src byte[]
                            byte[] proxyUser = Encoding.Unicode.GetBytes(initOptions[i].proxyUserInfo);

                            //set size 
                            size = proxyUser.Length;

                            //get destination byte[]
                            byte[] buffer = new byte[proxyUser.Length];

                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();

                            Marshal.Copy(proxyUser, 0, memPtr, proxyUser.Length);
                            break;
                        }
                    case IDCRL_OPTION_ID.IDCRL_OPTION_CONNECT_TIMEOUT:
                        {
                            size = Marshal.SizeOf(initOptions[i].timeOut[0].GetType()) * initOptions[i].timeOut.Length;
                            byte[] buffer = new byte[size];

                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();
                            Marshal.Copy(initOptions[i].timeOut, 0, memPtr, initOptions[i].timeOut.Length);

                            break;
                        }
                    case IDCRL_OPTION_ID.IDCRL_OPTION_RECEIVE_TIMEOUT:
                        {
                            size = Marshal.SizeOf(initOptions[i].timeOut[0].GetType()) * initOptions[i].timeOut.Length;
                            byte[] buffer = new byte[size];

                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();
                            Marshal.Copy(initOptions[i].timeOut, 0, memPtr, initOptions[i].timeOut.Length);
                            break;
                        }
                    case IDCRL_OPTION_ID.IDCRL_OPTION_SEND_TIMEOUT:
                        {
                            size = Marshal.SizeOf(initOptions[i].timeOut[0].GetType()) * initOptions[i].timeOut.Length;
                            byte[] buffer = new byte[size];

                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();
                            Marshal.Copy(initOptions[i].timeOut, 0, memPtr, initOptions[i].timeOut.Length);
                            break;
                        }
                    case IDCRL_OPTION_ID.IDCRL_OPTION_ENVIRONMENT:
                        {
                            //create the src byte[]
                            byte[] enviornment = Encoding.Unicode.GetBytes(initOptions[i].proxyUserInfo);

                            //set size 
                            size = enviornment.Length;

                            //create destination buffer
                            byte[] buffer = new byte[enviornment.Length];
                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();

                            Marshal.Copy(enviornment, 0, memPtr, enviornment.Length);

                            break;
                        }
                    default:
                        {
                            memPtr = IntPtr.Zero;
                            size = 0;
                            break;
                        }
                }

                //populate the array that needs to be sent to the native code
                arrOpts[i].m_dwId = initOptions[i].optionType;
                arrOpts[i].m_pValue = memPtr;
                arrOpts[i].m_cbValue = (uint)size;

                //reset the memory and size
                memPtr = IntPtr.Zero;
                size = 0;

            }
            HResult = NativeMethods.InitializeApp(appID, ppcrlVersion, updateFlags, arrOpts, (uint)arrOpts.Length);

            for (int i = 0; i < initOptions.Length; i++)
            {
                arrOpts[i].m_pValue = IntPtr.Zero;
                if (hBuffer[i].IsAllocated)
                {
                    hBuffer[i].Free();
                }
            }

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            return HResult;
        }
        #endregion


        #region SetIdcrlOptions Overload with Proxy and InitializeEx options
        /// <summary> Must be called before and return successfully before any otherclient runtime library functions are called. 
        /// This function supports setting some optional parameters that Initialize does not support.
        /// This overloads takes an array of Initialize_Options and constructs an array of IDCRL_OPTIONS. 
        /// This saves the application from doing the marshalling.
        /// </summary>
        /// <param name="appGuid">A GUID that uniquely identifies the hosting application. This allows features such as customized user interfaces
        /// to match the hosting application's look and feel.</param>
        /// <param name="ppcrlVersion">Binary version of the API</param>
        /// <param name="updateFlags">Initialization flags from the UPDATE_FLAG enum above.</param>
        /// <param name="initOptions">Array of Initialize_Options for addittional options to set. </param>
        /// <returns></returns>
        public int SetIdcrlOptions(Initialize_Options[] initOptions, uint updateFlags)
        {

            int HResult = 0;
            IDCRL_OPTION[] arrOpts = new IDCRL_OPTION[initOptions.Length];
            IntPtr memPtr = IntPtr.Zero;
            GCHandle[] hBuffer = new GCHandle[initOptions.Length];
            int size = 0;
            for (int i = 0; i < initOptions.Length; i++)
            {
                switch (initOptions[i].optionType)
                {
                    case IDCRL_OPTION_ID.IDCRL_OPTION_PROXY:
                        {
                            size = Marshal.SizeOf(initOptions[i].proxyInfo);
                            byte[] buffer = new byte[size];

                            //Get a Ptr to the Proxy
                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();

                            Marshal.StructureToPtr(initOptions[i].proxyInfo, memPtr, true);

                            break;
                        }
                    case IDCRL_OPTION_ID.IDCRL_OPTION_PROXY_PASSWORD:
                        {
                            //create the src byte[]
                            byte[] proxyPasswd = Encoding.Unicode.GetBytes(initOptions[i].proxyUserInfo);

                            //set size 
                            size = proxyPasswd.Length;

                            //create destination buffer
                            byte[] buffer = new byte[proxyPasswd.Length];
                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();

                            Marshal.Copy(proxyPasswd, 0, memPtr, proxyPasswd.Length);

                            break;
                        }
                    case IDCRL_OPTION_ID.IDCRL_OPTION_PROXY_USERNAME:
                        {
                            //get the src byte[]
                            byte[] proxyUser = Encoding.Unicode.GetBytes(initOptions[i].proxyUserInfo);

                            //set size 
                            size = proxyUser.Length;

                            //get destination byte[]
                            byte[] buffer = new byte[proxyUser.Length];

                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();

                            Marshal.Copy(proxyUser, 0, memPtr, proxyUser.Length);
                            break;
                        }
                    case IDCRL_OPTION_ID.IDCRL_OPTION_CONNECT_TIMEOUT:
                        {
                            size = Marshal.SizeOf(initOptions[i].timeOut[0].GetType()) * initOptions[i].timeOut.Length;
                            byte[] buffer = new byte[size];

                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();
                            Marshal.Copy(initOptions[i].timeOut, 0, memPtr, initOptions[i].timeOut.Length);

                            break;
                        }
                    case IDCRL_OPTION_ID.IDCRL_OPTION_RECEIVE_TIMEOUT:
                        {
                            size = Marshal.SizeOf(initOptions[i].timeOut[0].GetType()) * initOptions[i].timeOut.Length;
                            byte[] buffer = new byte[size];

                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();
                            Marshal.Copy(initOptions[i].timeOut, 0, memPtr, initOptions[i].timeOut.Length);
                            break;
                        }
                    case IDCRL_OPTION_ID.IDCRL_OPTION_SEND_TIMEOUT:
                        {
                            size = Marshal.SizeOf(initOptions[i].timeOut[0].GetType()) * initOptions[i].timeOut.Length;
                            byte[] buffer = new byte[size];

                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();
                            Marshal.Copy(initOptions[i].timeOut, 0, memPtr, initOptions[i].timeOut.Length);
                            break;
                        }
                    case IDCRL_OPTION_ID.IDCRL_OPTION_ENVIRONMENT:
                        {
                            //create the src byte[]
                            byte[] enviornment = Encoding.Unicode.GetBytes(initOptions[i].proxyUserInfo);

                            //set size 
                            size = enviornment.Length;

                            //create destination buffer
                            byte[] buffer = new byte[enviornment.Length];
                            hBuffer[i] = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                            memPtr = hBuffer[i].AddrOfPinnedObject();

                            Marshal.Copy(enviornment, 0, memPtr, enviornment.Length);

                            break;
                        }
                    default:
                        {
                            memPtr = IntPtr.Zero;
                            size = 0;
                            break;
                        }
                }

                //populate the array that needs to be sent to the native code
                arrOpts[i].m_dwId = initOptions[i].optionType;
                arrOpts[i].m_pValue = memPtr;
                arrOpts[i].m_cbValue = (uint)size;

                //reset the memory and size
                memPtr = IntPtr.Zero;
                size = 0;

            }
            HResult = NativeMethods.SetIdcrlOptions(arrOpts, (uint)arrOpts.Length, updateFlags);

            for (int i = 0; i < initOptions.Length; i++)
            {
                arrOpts[i].m_pValue = IntPtr.Zero;
                if (hBuffer[i].IsAllocated)
                {
                    hBuffer[i].Free();
                }
            }

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            return HResult;
        }
        #endregion

        #region Uninitialize
        /// <summary>
        ///  Must be called when shutting down the client runtime library. This will immediately invalidate any extant identity handles.
        /// </summary>
        /// <returns></returns>
        public int Uninitialize()
        {
            int HResult = 0;
            HResult = NativeMethods.Uninitialize();

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            return HResult;
        }
        #endregion

        #region CreateIdentityHandle
        /// <summary>
        ///  Used to create new identity handles, which then be authenticated with credentials and acquire authentication tokens.
        /// </summary>
        /// <param name="memberName">Member name to initialize the identity to. May be NULL and set later with SetIdentityProperty (or
        /// by the user if UI is being used).</param>
        /// <param name="identityFlags">Identity creation flags.</param>
        /// <param name="identity">New identity handle. May be passed to LogonIdentity, etc. Must be released with CloseIdentityHandle eventually.</param>
        /// <returns>successful HResult</returns>
        public int CreateIdentityHandle(string memberName, uint identityFlags, out int identity)
        {
            int HResult = 0;
            IntPtr hIdentity = IntPtr.Zero;
            identity = 0;
            HResult = NativeMethods.CreateIdentityHandle(memberName, identityFlags, out hIdentity);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            identity = hIdentity.ToInt32();
            return HResult;
        }


        #endregion

        #region AuthIdentityToService
        /// <summary>
        /// Using an authenticated identity, attempts to retrieve a service token for that identity to the specified resource. If additional
        /// user interface interaction is required from the user, this call may fail with an error code indicating that LogonIdentity
        ///  needs to be called to enhance the authentication state before
        ///  the service token can be granted (e.g., if a PIN needs to be collected).
        /// </summary>
        /// <param name="identity">Authenticated identity handle returned from LogonIdentity  ServiceTarget - URI representing the webservice. This is primarily
        /// to identity the resource and need not necessarily represent a real service URL.</param>
        /// <param name="serviceTarget">DNS Name or the service name</param>
        /// <param name="servicePolicy">Policy if the application knows it or can provide it directly. This may be provided by the hosting application directly or extract from the application-
        /// level challenge from an initial attempt to access the resource.</param>
        /// <param name="serviceTokenFlags">ServiceToken Flags to determine the type of token</param>
        /// <param name="authState">AuthState which will contain 
        /// 1. pcbSessionKey / pcbSessionKeyLength - If the service token format supports it, this will return a session key to the hosting application that matches the symmetric session key inside
        /// the service token. This key material is binary, so care should be taken to not utilize any manipulations that may terminate on embedded null or non-printable characters.</param>
        /// <returns>sucessful HRresult</returns>
        public int AuthIdentityToService(int identity, string serviceTarget, string servicePolicy, uint serviceTokenFlags, out AuthState authState)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);
            IntPtr token = IntPtr.Zero;
            uint resultFlags = 0;
            IntPtr sessionKey = IntPtr.Zero;
            uint sessionKeyLength = 0;

            HResult = NativeMethods.AuthIdentityToService(hIdentity, serviceTarget, servicePolicy, serviceTokenFlags, out token, out resultFlags, out sessionKey, out sessionKeyLength);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            else
            {
                authState = new AuthState();
                authState.token = (token == IntPtr.Zero) ? string.Empty : Marshal.PtrToStringUni(token);
                authState.resultFlags = resultFlags;
                authState.sessionKey = (sessionKey == IntPtr.Zero) ? string.Empty : Marshal.PtrToStringUni(sessionKey);
                authState.sessionKeyLength = sessionKeyLength;

                //release token
                this.InternalPassportFreeMemory(token);

                //release sessionKey
                this.InternalPassportFreeMemory(sessionKey);

                return HResult;
            }
        }

        # endregion

        #region LogonIdentity
        /// <summary>
        /// Fundamental call of the Passport client runtime library. Allows the creation of an authenticated identity. This version of the
        /// call allows credentials to be provided by the calling application.
        /// </summary>
        /// <param name="identity">Passport IdentityHandle returned by CreateIdentityHandle Call</param>
        /// <param name="servicePolicy">Param for future use. The managedWrapper always passes optional params. 
        /// The next version will handle optional params
        /// </param>
        /// <param name="logonFlags">From LOGON_FLAG enum above.</param>
        /// <returns>successful HResult</returns>
        public int LogonIdentity(int identity, string servicePolicy, uint logonFlags)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);

            HResult = NativeMethods.LogonIdentity(hIdentity, servicePolicy, logonFlags);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            return HResult;

        }
        # endregion

        #region LogonIdentityEx
        /// <summary> 
        /// Fundamental call of the Passport client runtime library. Allows the creation of an authenticated identity. This version of the
        /// call allows credentials to be provided by the calling application. Service tokens are requested with Ex version.
        /// the service tokens will be put in cache, use AuthIdentityToService with SERVICE_TOKEN_FROM_CACHE flag to retrieve from cache
        /// </summary>
        /// <param name="identity">Passport Identity handle obtained from CreateIdentityHandle call</param>
        /// <param name="authPolicy">Optional authPolicy.
        /// The next version will handle optional params</param>
        /// <param name="logonFlags">From LOGON_FLAG enum above.</param>
        /// <param name="rstParam">Struct to specify combinations of ServiceNames and policies with the addittional information</param>
        /// <param name="paramCount">Number of RSTParams elements. </param>
        /// <returns></returns>
        public int LogonIdentityEx(int identity, string authPolicy, uint logonFlags, RSTParams[] rstParam, uint paramCount)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);

            HResult = NativeMethods.LogonIdentityEx(hIdentity, authPolicy, logonFlags, rstParam, paramCount);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            return HResult;
        }
        # endregion

        #region SetCredential
        /// <summary> 
        /// Sets a specified credential on the given identity handle. 
        /// Any set credential will be used, as-needed, for all future authentication requests on this identity.        
        /// </summary>
        /// <param name="identity">Passport Identity Handle</param>
        /// <param name="credType">Credential type to set (from PPCRL_CREDTYPE_* definitions, above).</param>
        /// <param name="credValue">Credential to associate with the identity.</param>
        /// <returns>successful hr</returns>
        public int SetCredential(int identity, string credType, string credValue)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);

            HResult = NativeMethods.SetCredential(hIdentity, credType, credValue);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            return HResult;

        }
        # endregion

        #region GetAuthState
        /// <summary>
        /// Returns the authentication and request state associated with the given identity handle. This allows the calling
        /// application to determine not only the current authentication state, but the state of the last request made on behalf
        /// of this identity. The calling application can use this information to deal with the state/errors appropriately.
        /// </summary>
        /// <param name="identity">Passport Identity handle</param>
        /// <param name="state">LogonState struc definted above.  Returns the authentication status, the authentication required (if any), the status of the last request
        /// based on this identity, and may optionally return a URL that the hosting application can take the user to in order to explain and/or resolve the
        /// </param>
        /// <returns>Successful HResult</returns>
        public int GetAuthState(int identity, out LogonState state)
        {
            int authState = 0;
            int authRequired = 0;
            int requestStatus = 0;
            IntPtr webFlowUrl = IntPtr.Zero;

            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);

            HResult = NativeMethods.GetAuthState(hIdentity, out authState, out authRequired, out requestStatus, out webFlowUrl);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            else
            {
                state = new LogonState();
                state.AuthRequired = authRequired;
                state.AuthState = authState;
                state.RequestStatus = requestStatus;
                state.WebFlowUrl = (webFlowUrl == IntPtr.Zero) ? string.Empty : Marshal.PtrToStringUni(webFlowUrl);

                //release webflowurl
                this.InternalPassportFreeMemory(webFlowUrl);

                return HResult;
            }

        }
        # endregion

        #region AuthIdentityToServiceEx
        /// <summary>
        ///  Using an authenticated identity, attempts to retrieve a set of service tokens for that identity to the specified resources.
        /// If additional user interface interaction is required from the user, this call may fail with an error code indicating that LogonIdentity
        /// needs to be called to enhance the authentication state before the service token can be granted (e.g., if a PIN needs to be collected)
        /// </summary>
        /// <param name="identity">Authenticated identity handle returned from LogonIdentity</param>
        /// <param name="serviceTokenFlags"> the service tokens will be put in cache if async, use AuthIdentityToService with SERVICE_TOKEN_FROM_CACHE flag to retrieve from cache</param>
        /// <param name="rstParams">parameters for service tokens</param>
        /// <param name="rstParamCount">number of parameters</param>
        /// <returns>Sucessful HResult</returns>
        public int AuthIdentityToServiceEx(int identity, uint serviceTokenFlags, RSTParams[] rstParams, uint rstParamCount)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);

            HResult = NativeMethods.AuthIdentityToServiceEx(hIdentity, serviceTokenFlags, rstParams, rstParamCount);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            return HResult;
        }
        # endregion

        #region GetCertificate Overload return IntPtr PPCertContext
        /// <summary>
        /// Using an authenticated identity to get a certficate for this user for that identity to the specified service name.
        /// If additional user interface interaction is required from the user, this call may fail with an error code indicating that LogonIdentity
        /// needs to be called to enhance the authentication state before the service token can be granted (e.g., if a PIN needs to be collected).
        /// </summary>
        /// <param name="identity">Authenticated identity handle returned from LogonIdentity</param>
        /// <param name="pcRSTParams"> parameters for the certificate request</param>
        /// <param name="dwMinTTL">If getting from cache, as input, minimum acceptable TTL as output, actual remaining TTL. Has no effect for a
        /// new certificate request from network.</param>
        /// <param name="certRequestFlags">indicate if the cert should be from the cache</param>
        /// <param name="certContext">the cert context, this context can be used with cryto API for cert/public key/private key related operations.
        /// IDCRL maitains the private key for this cert.  It clears the private key when it requesing a new cert from passport.
        /// Application must call CertFreeCertificateContext and stop using the certcontext before the next GetCerficate call.</param>
        /// <returns>S_OK if successful
        /// PPCRL_S_OK_CLIENTTIME if successful but the clock skew is not set
        /// </returns>
        public int GetCertificate(int identity, RSTParams pcRSTParams, uint dwMinTTL, uint certRequestFlags, out PCCERT_CONTEXT certContext)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);
            IntPtr popBlobPtr = IntPtr.Zero;
            uint popSize = 0;
            certContext = IntPtr.Zero;
            IntPtr ppCACertContext = IntPtr.Zero;

            HResult = NativeMethods.GetCertificate(hIdentity, ref pcRSTParams, ref dwMinTTL, certRequestFlags, out certContext, out popBlobPtr, out popSize, out ppCACertContext);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            return HResult;

        }

        # endregion

        #region GetCertificate Overload return X509Certificate for Passport CertContext
        /// <summary>
        /// Using an authenticated identity to get a certficate for this user for that identity to the specified service name.
        /// If additional user interface interaction is required from the user, this call may fail with an error code indicating that LogonIdentity
        /// needs to be called to enhance the authentication state before the service token can be granted (e.g., if a PIN needs to be collected).
        /// </summary>
        /// <param name="identity">Authenticated identity handle returned from LogonIdentity</param>
        /// <param name="pcRSTParams"> parameters for the certificate request</param>
        /// <param name="dwMinTTL">If getting from cache, as input, minimum acceptable TTL as output, actual remaining TTL. Has no effect for a
        /// new certificate request from network.</param>
        /// <param name="certRequestFlags">indicate if the cert should be from the cache</param>
        /// <param name="cert">The wrapper initializes a X509Cert</param>
        /// <returns>S_OK if successful
        /// PPCRL_S_OK_CLIENTTIME if successful but the clock skew is not set
        /// </returns>
        public int GetCertificate(int identity, RSTParams pcRSTParams, uint dwMinTTL, uint certRequestFlags, out X509Certificate cert)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);
            IntPtr popBlobPtr = IntPtr.Zero;
            uint popSize = 0;
            IntPtr certContext = IntPtr.Zero;
            IntPtr ppCACertContext = IntPtr.Zero;

            HResult = NativeMethods.GetCertificate(hIdentity, ref pcRSTParams, ref dwMinTTL, certRequestFlags, out certContext, out popBlobPtr, out popSize, out ppCACertContext);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            cert = new X509Certificate(certContext);
            return HResult;

        }

        # endregion

        #region GetCertificate OverLoad to return IntPtr to Cert / CACert popBlob and popsize
        /// <summary>
        /// Using an authenticated identity to get a certficate for this user for that identity to the specified service name.
        /// If additional user interface interaction is required from the user, this call may fail with an error code indicating that LogonIdentity
        /// needs to be called to enhance the authentication state before the service token can be granted (e.g., if a PIN needs to be collected).
        /// </summary>
        /// <param name="identity">Authenticated identity handle returned from LogonIdentity</param>
        /// <param name="pcRSTParams"> parameters for the certificate request</param>
        /// <param name="dwMinTTL">If getting from cache, as input, minimum acceptable TTL as output, actual remaining TTL. Has no effect for a
        /// new certificate request from network.</param>
        /// <param name="certRequestFlags">indicate if the cert should be from the cache</param>
        /// <param name="certContext">the cert context, this context can be used withcryto API for cert/public key/private key related operations.
        /// IDCRL maitains the private key for this cert.  It clears the private key when it requesing a new cert from passport.
        /// Application must call CertFreeCertificateContext and stop using the certcontext before the next GetCerficate call.</param>
        /// <param name="popBlob">Optional parameter to receive the proof of possession blob. Applications can give this blob to VerifyCertificate API
        /// to perform POP check on the certificate. Application must free it with PassportFreeMemory API after using.</param>
        /// <param name="popBlobSize">If ppbPOP is not NULL, you must also pass this parameter to get the size of the POP blob.</param>
        /// <param name="ppCACertContext">Optional parameter to receive the CA certificate context. Application must free it with CertFreeCertificateContext
        /// API after using. The CA cert context may be expired in time but corresponds to the signature on the subject certificate.</param>
        /// <returns>S_OK if successful
        /// PPCRL_S_OK_CLIENTTIME if successful but the clock skew is not set
        /// </returns>
        public int GetCertificate(int identity, RSTParams pcRSTParams, uint dwMinTTL, uint certRequestFlags, out PCCERT_CONTEXT certContext, IntPtr popBlob, out uint popBlobSize, out PCCERT_CONTEXT ppCACertContext)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);
            popBlob = IntPtr.Zero;
            popBlobSize = 0;
            certContext = IntPtr.Zero;
            ppCACertContext = IntPtr.Zero;

            HResult = NativeMethods.GetCertificate(hIdentity, ref pcRSTParams, ref dwMinTTL, certRequestFlags, out certContext, out popBlob, out popBlobSize, out ppCACertContext);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            return HResult;

        }
        #endregion

        #region GetCertificate
        /// <summary>
        /// Using an authenticated identity to get a certficate for this user for that identity to the specified service name.
        /// If additional user interface interaction is required from the user, this call may fail with an error code indicating that LogonIdentity
        /// needs to be called to enhance the authentication state before the service token can be granted (e.g., if a PIN needs to be collected).
        /// </summary>
        /// <param name="identity">Authenticated identity handle returned from LogonIdentity</param>
        /// <param name="pcRSTParams"> parameters for the certificate request</param>
        /// <param name="dwMinTTL">If getting from cache, as input, minimum acceptable TTL as output, actual remaining TTL. Has no effect for a
        /// new certificate request from network.</param>
        /// <param name="certRequestFlags">indicate if the cert should be from the cache</param>
        /// <param name="certSet">CertSet contains IntPtr to cert, CACert also X509Cert instances of cert and CACert and popBlob and popSize. 
        /// The wrapper handles the marshalling of the certs</param>
        /// <returns>S_OK if successful
        /// PPCRL_S_OK_CLIENTTIME if successful but the clock skew is not set
        /// </returns>
        public int GetCertificate(int identity, RSTParams pcRSTParams, uint dwMinTTL, uint certRequestFlags, out CertSet certSet)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);
            IntPtr popBlob = IntPtr.Zero;
            uint popBlobSize = 0;
            IntPtr certContext = IntPtr.Zero;
            IntPtr ppCACertContext = IntPtr.Zero;

            HResult = NativeMethods.GetCertificate(hIdentity, ref pcRSTParams, ref dwMinTTL, certRequestFlags, out certContext, out popBlob, out popBlobSize, out ppCACertContext);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            //incase of PPCRL_REQUEST_S_IO_PENDING PPCRL_SUCCESS_CODE(0x47)
            if (HResult == 297031)
            {
                certSet = new CertSet();
            }
            else
            {
                certSet = new CertSet(certContext, popBlob, popBlobSize, ppCACertContext);
            }

            return HResult;

        }
        #endregion

        #region GetAssertion
        /// <summary>
        /// Using an authenticated identity to get a certficate for this user for that identity to the specified service name.
        /// If additional user interface interaction is required from the user, this call may fail with an error code indicating that LogonIdentity
        /// needs to be called to enhance the authentication state before the service token can be granted (e.g., if a PIN needs to be collected).
        /// </summary>
        /// <param name="identity">Authenticated identity handle returned from LogonIdentity</param>
        /// <param name="pcRSTParams"> parameters for the certificate request</param>
        /// <param name="dwMinTTL">If getting from cache, as input, minimum acceptable TTL as output, actual remaining TTL. Has no effect for a
        /// new certificate request from network.</param>
        /// <param name="certRequestFlags">indicate if the cert should be from the cache</param>
        /// <param name="certSet">CertSet contains IntPtr to cert, CACert also X509Cert instances of cert and CACert and popBlob and popSize. 
        /// The wrapper handles the marshalling of the certs</param>
        /// <returns>S_OK if successful
        /// PPCRL_S_OK_CLIENTTIME if successful but the clock skew is not set
        /// </returns>
        public int GetAssertion(int identity, RSTParams pcRSTParams, uint dwMinTTL, uint certRequestFlags, out CertSet certSet)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);
            IntPtr popBlob = IntPtr.Zero;
            uint popBlobSize = 0;
            IntPtr certContext = IntPtr.Zero;
            IntPtr ppCACertContext = IntPtr.Zero;

            HResult = NativeMethods.GetAssertion(hIdentity, ref pcRSTParams, ref dwMinTTL, certRequestFlags, out certContext, out popBlob, out popBlobSize, out ppCACertContext);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            //incase of PPCRL_REQUEST_S_IO_PENDING PPCRL_SUCCESS_CODE(0x47)
            if (HResult == 297031)
            {
                certSet = new CertSet();
            }
            else
            {
                certSet = new CertSet(certContext, popBlob, popBlobSize, ppCACertContext);
            }

            return HResult;

        }
        #endregion

        #region GetAuthStateEx
        /// <summary>
        /// Returns the authentication and request state associated with the given identity handle. This allows the calling
        /// application to determine not only the current authentication state, but the state of the last request made on behalf
        /// of this identity. The calling application can use this information to deal with the state/errors appropriately.
        /// The Ex version is used to query states for a particular service token
        /// </summary>
        /// <param name="identity">Passport Identity handle</param>
        /// <param name="serviceTarget">Token is retrieved based on serviceTarget. When wzServiceTarget == NULL, the states from last request is returned</param>
        /// <param name="state">LogonState struc definted above.  Returns the authentication status, the authentication required (if any), the status of the last request
        /// based on this identity, and may optionally return a URL that the hosting application can take the user to in order to explain and/or resolve the
        /// </param>
        /// <returns>Successful HResult</returns>
        public int GetAuthStateEx(int identity, string serviceTarget, out LogonState state)
        {
            int authState = 0;
            int authRequired = 0;
            int requestStatus = 0;
            IntPtr webFlowUrl = IntPtr.Zero;

            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);

            HResult = NativeMethods.GetAuthStateEx(hIdentity, serviceTarget, out authState, out authRequired, out requestStatus, out webFlowUrl);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            else
            {
                state = new LogonState();
                state.AuthState = authState;
                state.AuthRequired = authRequired;
                state.RequestStatus = requestStatus;
                state.WebFlowUrl = (webFlowUrl == IntPtr.Zero) ? string.Empty : Marshal.PtrToStringUni(webFlowUrl);

                //release webflowurl
                this.InternalPassportFreeMemory(webFlowUrl);

                return HResult;
            }

        }
        # endregion

        #region VerifyCertificate
        /// <summary>
        /// check if the cert can be chained back to one of the certs in config.
        /// </summary>
        /// <param name="pcertContext">Pointer to a cert context of the certificate you</param>
        /// <param name="dwMinTTL">As input, it is the minimum acceptable TTL, as output it is the actual remaining TTL.</param>
        /// <param name="popBlob">POP blob to verify</param>
        /// <param name="popSize">size of the pop blob in bytes</param>
        /// <param name="ppCACertContext">Optional parameter to receive the CA certificate context. 
        /// Application must free it with CertFreeCertificateContext API after using. 
        /// The CA cert context may be expired in time butcorresponds to the signature on the subject certificate.</param>
        /// <returns></returns>
        public int VerifyCertificate(PCCERT_CONTEXT pcertContext, ref uint dwMinTTL, IntPtr popBlob, uint popSize, out PCCERT_CONTEXT ppCACertContext)
        {
            int HResult = 0;
            ppCACertContext = IntPtr.Zero;
            HResult = NativeMethods.VerifyCertificate(pcertContext, ref dwMinTTL, popBlob, popSize, out ppCACertContext);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            return HResult;
        }
        #endregion

        #region VerifyCertificate
        /// <summary>
        /// check if the cert can be chained back to one of the certs in config.
        /// </summary>
        /// <param name="pcertContext">Pointer to a cert context of the certificate you</param>
        /// <param name="dwMinTTL">As input, it is the minimum acceptable TTL, as output it is the actual remaining TTL.</param>
        /// <param name="popBlob">POP blob to verify</param>
        /// <param name="popSize">size of the pop blob in bytes</param>
        /// <param name="ppCACert">instance of x509cert  
        /// Application must free it with CertFreeCertificateContext API after using. 
        /// The CA cert context may be expired in time butcorresponds to the signature on the subject certificate.</param>
        /// <returns></returns>
        public int VerifyCertificate(PCCERT_CONTEXT pcertContext, ref uint dwMinTTL, IntPtr popBlob, uint popSize, out X509Certificate ppCACert)
        {
            int HResult = 0;
            IntPtr ppCACertContext = IntPtr.Zero;
            HResult = NativeMethods.VerifyCertificate(pcertContext, ref dwMinTTL, popBlob, popSize, out ppCACertContext);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            ppCACert = new X509Certificate(ppCACertContext);

            return HResult;
        }
        #endregion

        #region VerifyCertificate
        /// <summary>
        /// check if the cert can be chained back to one of the certs in config.
        /// </summary>
        /// <param name="pcertContext">Pointer to a cert context of the certificate you</param>
        /// <param name="dwMinTTL">As input, it is the minimum acceptable TTL, as output it is the actual remaining TTL.</param>
        /// <param name="popBlob">POP blob to verify</param>
        /// <param name="popSize">size of the pop blob in bytes</param>
        /// <param name="ppCACert">instance of x509cert  
        /// Application must free it with CertFreeCertificateContext API after using. 
        /// The CA cert context may be expired in time butcorresponds to the signature on the subject certificate.</param>
        /// <returns></returns>
        public int VerifyCertificate(PCCERT_CONTEXT pcertContext, ref uint dwMinTTL, out X509Certificate ppCACert)
        {
            int HResult = 0;
            IntPtr ppCACertContext = IntPtr.Zero;
            IntPtr popBlob = IntPtr.Zero;
            uint popSize = 0;
            HResult = NativeMethods.VerifyCertificate(pcertContext, ref dwMinTTL, popBlob, popSize, out ppCACertContext);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            ppCACert = new X509Certificate(ppCACertContext);

            return HResult;
        }
        #endregion

        #region VerifyAssertion
        /// <summary>
        /// check if the cert can be chained back to one of the certs in config.
        /// </summary>
        /// <param name="pcertContext">Pointer to a cert context of the certificate you</param>
        /// <param name="dwMinTTL">As input, it is the minimum acceptable TTL, as output it is the actual remaining TTL.</param>
        /// <param name="popBlob">POP blob to verify</param>
        /// <param name="popSize">size of the pop blob in bytes</param>
        /// <param name="ppCACertContext">Optional parameter to receive the CA certificate context. 
        /// Application must free it with CertFreeCertificateContext API after using. 
        /// The CA cert context may be expired in time butcorresponds to the signature on the subject certificate.</param>
        /// <returns></returns>
        public int VerifyAssertion(PCCERT_CONTEXT pcertContext, ref uint dwMinTTL, IntPtr popBlob, uint popSize, out PCCERT_CONTEXT ppCACertContext)
        {
            int HResult = 0;
            ppCACertContext = IntPtr.Zero;
            HResult = NativeMethods.VerifyAssertion(pcertContext, ref dwMinTTL, popBlob, popSize, out ppCACertContext);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            return HResult;
        }
        #endregion

        #region SetIdentityCallback
        /// <summary>
        /// Associates a callback procedure with the identity for asynchronousfunctionality. Any identity without an associated callback will
        /// operate synchronously.
        /// </summary>
        /// <param name="identity">Passport Identity handle</param>
        /// <param name="CallbackFunction"></param>
        /// <returns></returns>
        public int SetIdentityCallback(int identity, CallBackDelegateWithData CallbackFunction)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);
            IntPtr callBackDataPtr = IntPtr.Zero;


            HResult = NativeMethods.SetIdentityCallback(hIdentity, CallbackFunction, callBackDataPtr);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            return HResult;
        }
        #endregion

        #region SetIdentityCallback With CallBackData
        /// <summary>
        /// Associates a callback procedure with the identity for asynchronousfunctionality. Any identity without an associated callback will
        /// operate synchronously.
        /// </summary>
        /// <param name="identity">Passport Identity handle</param>
        /// <param name="CallbackFunction"></param>
        /// <returns></returns>
        public int SetIdentityCallback(int identity, CallBackDelegateWithData CallbackFunction, IntPtr callBackData)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);

            HResult = NativeMethods.SetIdentityCallback(hIdentity, CallbackFunction, callBackData);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            return HResult;
        }
        #endregion


        #region SetChangeNotificationCallback
        /// <summary>
        /// Associates a callback procedure with the identity for asynchronousfunctionality. Any identity without an associated callback will
        /// operate synchronously.
        /// </summary>
        /// <param name="identity">Passport Identity handle</param>
        /// <param name="CallbackFunction">call back function</param>
        /// <returns></returns>
        public int SetChangeNotificationCallback(string virtualApp, uint flags, UserStateChangedCallback callback)
        {
            int HResult = 0;
            HResult = NativeMethods.SetChangeNotificationCallback(virtualApp, flags, callback);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            return HResult;
        }
        #endregion

        #region SetChangeNotificationCallback Overload
        /// <summary>
        /// Associates a callback procedure with the identity for asynchronousfunctionality. Any identity without an associated callback will
        /// operate synchronously. Default flag 0 will be passed to the function. and empty string will be passed to the function.
        /// </summary>
        /// <param name="CallbackFunction">call back function</param>
        /// <returns></returns>
        public int SetChangeNotificationCallback(UserStateChangedCallback callback)
        {
            int HResult = 0;
            HResult = NativeMethods.SetChangeNotificationCallback(String.Empty, 0, callback);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            return HResult;
        }
        #endregion

        #region SetChangeNotificationCallback Overload
        /// <summary>
        /// Associates a callback procedure with the identity for asynchronousfunctionality. Any identity without an associated callback will
        /// operate synchronously. Default flag 0 will be passed to the function. and empty string will be passed to the function.
        /// </summary>
        /// <param name="CallbackFunction">call back function</param>
        /// <returns></returns>
        public int RemoveChangeNotificationCallback()
        {
            int HResult = 0;
            HResult = NativeMethods.RemoveChangeNotificationCallback();

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            return HResult;
        }
        #endregion

        #region CancelPendingRequest
        /// <summary>
        /// Cancel the pending request, so callback function will not be called
        /// </summary>
        /// <param name="identity">Passport Identity Handle </param>
        /// <returns>successful HResult</returns>
        public int CancelPendingRequest(int identity)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);

            HResult = NativeMethods.CancelPendingRequest(hIdentity);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            return HResult;
        }
        #endregion

        #region CloseIdentityHandle
        /// <summary>
        /// Closes an identity handle previously opened with CreateIdentityHandle freeing any resources associated with the identity.
        /// </summary>
        /// <param name="identity">Identity handle to close.</param>
        /// <returns></returns>
        public int CloseIdentityHandle(int identity)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);

            HResult = NativeMethods.CloseIdentityHandle(hIdentity);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            return HResult;
        }
        #endregion

        #region PersistCredentials
        /// <summary>
        /// Stores, updates and/or deletes stored credentials.The persistent credential store is updated based on the
        /// credentials stored on the identity.
        /// </summary>
        /// <param name="identity">Identity from to persist credentials for.</param>
        /// <param name="credType">Credential type on the identity to persist.</param>
        /// <returns></returns>
        public int PersistCredential(int identity, string credType)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);

            HResult = NativeMethods.PersistCredential(hIdentity, credType);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            return HResult;

        }
        #endregion

        #region EnumIdentitiesWithCachedCredentials
        /// <summary>
        /// Enumerates stored credentials allowing the hosting application to determine which credentials are present.
        /// </summary>
        /// <param name="credType">If non-NULL and non-empty, specifies the credential type to limit iteration of. For example,
        /// if PPCRL_CREDTYPE_PASSWORD is passed here, only identitieswith cached passwords will be iterated. If NULL or an
        /// empty string is passed here, then all identities with any type of cached credential will be iterated.</param>
        /// <param name="credHandle">A enumeration handle that allows iteration through the identities.</param>
        /// <returns></returns>
        public int EnumIdentitiesWithCachedCredentials(string credType, out int credHandle)
        {
            int HResult = 0;
            IntPtr handle = IntPtr.Zero;
            credHandle = 0;
            HResult = NativeMethods.EnumIdentitiesWithCachedCredentials(credType, out handle);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            credHandle = handle.ToInt32();
            return HResult;


        }
        #endregion

        #region NextIdentity
        /// <summary>
        /// Returns the next identity for the given enumeration handle.
        /// NOTES Any strings returned as outputs must be freed with PassportFreeMemory.
        /// However, if the pointers are passed back in as outputs to a PPCRL call, any previous string will be correctly freed.
        /// </summary>
        /// <param name="enumHandle">Handle as returned from EnumIdentities* call</param>
        /// <returns>The member name with cached credentials</returns>
        public string NextIdentity(int enumHandle)
        {
            int HResult = 0;
            IntPtr memberName = new IntPtr();
            IntPtr ptr = new IntPtr(enumHandle);

            HResult = NativeMethods.NextIdentity(ptr, ref memberName);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            return Marshal.PtrToStringUni(memberName);

        }

        #endregion

        #region NextIdentity
        /// <summary>
        /// Returns the next identity for the given enumeration handle.
        /// NOTES Any strings returned as outputs must be freed with PassportFreeMemory.
        /// However, if the pointers are passed back in as outputs to a PPCRL call, any previous string will be correctly freed.
        /// </summary>
        /// <param name="enumHandle">Handle as returned from EnumIdentities* call</param>
        /// <returns>The member name with cached credentials</returns>
        public int NextIdentity(int enumHandle, out string userName)
        {
            int HResult = 0;
            IntPtr memberName = new IntPtr();
            IntPtr ptr = new IntPtr(enumHandle);

            HResult = NativeMethods.NextIdentity(ptr, ref memberName);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            userName = Marshal.PtrToStringUni(memberName);

            return HResult;
        }

        #endregion

        #region CloseEnumIdentitiesHandle
        /// <summary>
        /// Closes an identity iterator, freeing resource associated with it.
        /// </summary>
        /// <param name="enumHandle">The iterator to close</param>
        /// <returns></returns>
        public int CloseEnumIdentitiesHandle(int enumHandle)
        {
            int HResult = 0;
            IntPtr handle = new IntPtr(enumHandle);


            HResult = NativeMethods.CloseEnumIdentitiesHandle(handle);
            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            return HResult;
        }

        #endregion

        #region RemovePersistedCredential
        /// <summary>
        /// Removes credentials from persistent storage.Any previously persisted credential will be deleted from
        /// the store. Any transient credential left on the identity itself is left unchanged.
        /// </summary>
        /// <param name="identity">Identity from which to remove credentials</param>
        /// <param name="credType">Credential type to delete from the store</param>
        /// <returns></returns>
        public int RemovePersistedCredential(int identity, string credType)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);
            HResult = NativeMethods.RemovePersistedCredential(hIdentity, credType);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            return HResult;
        }

        #endregion

        #region GetIdentityPropertyByName OverLoad
        /// <summary>
        /// Retrieves the value of a property associated with an identity handle.
        /// Currently GetIdentityPropertyByName doesnot return successcode. But this overload can be used if the API 
        /// starts returning success codes
        /// </summary>
        /// <param name="identity">Passport Identity Handle</param>
        /// <param name="PropertyName">property Name ANID / BRANDID</param>
        /// <param name="strPropertyVal">Upon success, the value of the property will be stored on the wszPropertyValue buffer. 
        /// The buffer must be freed with a call to</param>
        /// <returns></returns>
        public int GetIdentityPropertyByName(int identity, string PropertyName, out string strPropertyVal)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);
            IntPtr propertyValPtr = IntPtr.Zero;
            strPropertyVal = String.Empty;

            HResult = NativeMethods.GetIdentityPropertyByName(hIdentity, PropertyName, out propertyValPtr);

            if (HResult < 0)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            strPropertyVal = Marshal.PtrToStringUni(propertyValPtr);
            return HResult;

        }
        #endregion

        #region GetIdentityPropertyByName OverLoad
        /// <summary>
        /// Retrieves the value of a property associated with an identity handle.
        /// </summary>
        /// <param name="identity">Passport Identity Handle</param>
        /// <param name="PropertyName">property Name ANID / BRANDID</param>
        /// <param name="strPropertyVal">Upon success, the value of the property will be stored on the wszPropertyValue buffer. 
        /// The buffer must be freed with a call to</param>
        /// <returns></returns>
        public string GetIdentityPropertyByName(int identity, string PropertyName)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);
            IntPtr propertyValPtr = IntPtr.Zero;
            string strPropertyVal = String.Empty;

            HResult = NativeMethods.GetIdentityPropertyByName(hIdentity, PropertyName, out propertyValPtr);

            if (HResult < 0)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            strPropertyVal = (propertyValPtr == IntPtr.Zero) ? string.Empty : Marshal.PtrToStringUni(propertyValPtr);
            return strPropertyVal;

        }
        #endregion

        #region GetIdentityProperty OverLoad
        /// <summary>
        /// Retrieves the value of a property associated with an identity handle.
        /// Currently GetIdentityproperty doesnot return successcode. But this overload can be used if the API 
        /// starts returning success codes
        /// </summary>
        /// <param name="identity">Passport Identity Handle</param>
        /// <param name="PropertyName">property Name ANID / BRANDID</param>
        /// <param name="strPropertyVal">Upon success, the value of the property will be stored on the szPropertyValue buffer. 
        /// The buffer must be freed with a callto</param>
        /// <returns></returns>
        public int GetIdentityProperty(int identity, PassportIdentityProperty PropertyName, out string strPropertyVal)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);
            IntPtr propertyValPtr = IntPtr.Zero;
            strPropertyVal = String.Empty;

            HResult = NativeMethods.GetIdentityProperty(hIdentity, PropertyName, out propertyValPtr);

            if (HResult < 0)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            strPropertyVal = Marshal.PtrToStringUni(propertyValPtr);
            return HResult;

        }
        #endregion

        #region GetIdentityProperty OverLoad
        /// <summary>
        /// Retrieves the value of a property associated with an identity handle.
        /// </summary>
        /// <param name="identity">Passport Identity Handle</param>
        /// <param name="PropertyName">property Name ANID / BRANDID</param>
        /// <param name="strPropertyVal">Upon success, the value of the property will be stored on the szPropertyValue buffer. 
        /// The buffer must be freed with a callto</param>
        /// <returns>PropertyValue</returns>
        public string GetIdentityProperty(int identity, PassportIdentityProperty PropertyName)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);
            IntPtr propertyValPtr = IntPtr.Zero;
            string strPropertyVal = String.Empty;

            HResult = NativeMethods.GetIdentityProperty(hIdentity, PropertyName, out propertyValPtr);

            if (HResult < 0)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            strPropertyVal = (propertyValPtr == IntPtr.Zero) ? string.Empty : Marshal.PtrToStringUni(propertyValPtr);

            //free property value
            this.InternalPassportFreeMemory(propertyValPtr);

            return strPropertyVal;

        }
        #endregion

        #region GetPreferredAuthUIContextSize
        /// <summary>
        /// Returns the preferred screen dimensions for an AuthUIContext. This may change depending upon the state of the identity handle
        /// (some error flows recommend a large window). Therefore the authentication and request states of the given identity
        /// will be taken into account.
        /// </summary>
        /// <param name="identity">Optional identity to return the preferred dimensions 
        /// for. Of a NULL handle is given, the preferred dimensions for initial authenticaiton are returned.</param>
        /// <param name="size">Returns the width and height that are preferred to perform an authentication with UI for the given identity.</param>
        /// <returns></returns>
        public int GetPreferredAuthUIContextSize(int identity, out Size size)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);
            size = new Size();
            HResult = NativeMethods.GetPreferredAuthUIContextSize(hIdentity, out size);

            if (HResult < 0)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            return HResult;

        }
        #endregion

        #region CreatePassportAuthUIContext
        /// <summary>
        /// Creates a UI context for the PPCRL to use its built-in user interface for credential collection and error handling when
        /// dealing with the user to authenticate.
        /// </summary>
        /// <param name="credUIInfo">describes the configurable attributes of the built-in user interface</param>
        /// <param name="credUICustomUI"></param>
        /// <param name="authUIContextHandle">Address to receive the auth context handle for the newly-created context.</param>
        /// <returns>Creates a UI authentication context that can be used when authenticating identities.</returns>
        public int CreatePassportAuthUIContext(ref PassportCredUIInfo credUIInfo, ref PassportCredCustomUI credUICustomUI, out int authUIContextHandle)
        {
            IntPtr authContext = IntPtr.Zero;
            int HResult = 0;
            authUIContextHandle = 0;
            HResult = NativeMethods.CreatePassportAuthUIContext(ref credUIInfo, ref credUICustomUI, out authContext);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            authUIContextHandle = authContext.ToInt32();
            return HResult;

        }

        #endregion

        #region DestroyPassportAuthUIContext
        /// <summary>
        /// Destroys a previously-allocated UI context, freeing the resources associated with it.
        /// </summary>
        /// <param name="authUIContextHandle"></param>
        /// <returns></returns>
        public int DestroyPassportAuthUIContext(int authUIContextHandle)
        {
            int HResult = 0;
            IntPtr authContext = new IntPtr(authUIContextHandle);
            HResult = NativeMethods.DestroyPassportAuthUIContext(authContext);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            return HResult;

        }

        #endregion

        #region LogonIdentityWithUI
        /// <summary>
        /// Requests an authentication using the client runtime's built-in user interface for credential collection and error handling.
        /// UI-based authentications are always asynchronous in nature (asthey depend on user input), so a valid call-back is required.
        /// This also means that this call always returns immediately to the caller, and the authentication process occurs over
        /// time as Windows messages are pumped and the library is able to interact with the user and the auth servers.
        /// </summary>
        /// <param name="authContext">The UI authentication context to be used for this authentication. This comes from
        /// CreatePassportAuthUIContext function, above.</param>
        /// <param name="identity">Identity handle to authenticate.</param>
        /// <param name="policy">Optional policy to apply to the authentication</param>
        /// <param name="logonFlags">lags controlling the authentication.</param>
        /// <returns>Upon success, the given identity handle will possess the appropriate authentication state based on the credentials
        /// presented. Service tokens are requested with Ex version. the service tokens will be put in cache, use AuthIdentityToService
        /// with SERVICE_TOKEN_FROM_CACHE flag to retrieve from cache</returns>
        public int LogonIdentityWithUI(int authContext, int identity, string policy, uint logonFlags)
        {
            IntPtr authUIContext = new IntPtr(authContext);
            IntPtr hIdentity = new IntPtr(identity);
            int HResult = 0;
            HResult = NativeMethods.LogonIdentityWithUI(authUIContext, hIdentity, policy, logonFlags);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            return HResult;

        }
        #endregion

        #region MoveAuthUIContext
        /// <summary>
        /// Allows a hosting application to change the size of an authentication UI context that has already been created. This
        /// is most useful to handling error flows, etc. where the size returned by GetPreferredAuthUIContextSize indicates a different
        /// size would be more appropriate. The authentication context is resized.
        /// </summary>
        /// <param name="authContext">Authentication context to resize and/or move</param>
        /// <param name="position"></param>
        /// <param name="newSize">New size for the authentication context</param>
        /// <returns></returns>
        public int MoveAuthUIContext(int authContext, Point position, Size newSize)
        {
            IntPtr authUIContext = new IntPtr(authContext);
            int HResult = 0;
            HResult = NativeMethods.MoveAuthUIContext(authUIContext, position, newSize);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            return HResult;

        }
        #endregion

        #region GetWebAuthUrl
        /// <summary>
        /// Get Url and post data for web authentication. E.g. for hotmail inbox.
        /// * NOTES :Calling application must set the following header:
        /// * Content-Type: application/x-www-form-urlencoded
        /// * for the POST request to be accepted by the login server.
        /// </summary>
        /// <param name="identity">Identity handle created previously</param>
        /// <param name="targetService">Reserved</param>
        /// <param name="policy">Reserved</param>
        /// <param name="additionalParams">Other params required for the call the coreparams computed by the API. For MD5, these include: ru, kv, svc, rru,
        /// id and sid.</param>
        /// <param name="sourceService">Service name used earlier to authenticate the user</param>
        /// <param name="md5data">This struct contains webAuthUrl Output param that holds the URL to post the data
        /// and pszPostData: Post data to be sent with the request, it includes the additional post params specified in szAdditionalPostParams</param>
        /// <returns>Upon success, the API will give a URL with a blob of data that can be POSTed to the URL for authentication</returns>
        public int GetWebAuthUrl(int identity, string targetService, string policy, string additionalParams, string sourceService, out MD5Data md5data)
        {
            IntPtr hIdentity = new IntPtr(identity);
            IntPtr webAuthUrl = IntPtr.Zero;
            IntPtr postData = IntPtr.Zero;
            md5data = new MD5Data();

            int HResult = 0;
            HResult = NativeMethods.GetWebAuthUrl(hIdentity, targetService, policy, additionalParams, sourceService, out webAuthUrl, out postData);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            if ((webAuthUrl != IntPtr.Zero) && (postData != IntPtr.Zero)) //removing this condition how to figure that the contents != NULL ?
            {
                md5data.md5Url = Marshal.PtrToStringUni(webAuthUrl);
                md5data.postData = Marshal.PtrToStringUni(postData);
            }

            this.InternalPassportFreeMemory(webAuthUrl);
            this.InternalPassportFreeMemory(postData);


            return HResult;

        }

        #endregion

        #region HasPersistedCredentials
        /// <summary>
        /// Returns whether or not the specified identity has a persisted credential of the specified type.
        /// </summary>
        /// <param name="identity">the identity to check persisted credentials of</param>
        /// <param name="CredType">the credential type to check for persistence</param>
        /// <param name="hasPersistedCred">Whether or not there is a persistent credential.</param>
        /// <returns></returns>
        public bool HasPersistedCredentials(int identity, string CredType)
        {
            IntPtr hIdentity = new IntPtr(identity);
            long HasPersistentCred = 0;
            int HResult = 0;
            HResult = NativeMethods.HasPersistedCredential(hIdentity, CredType, out HasPersistentCred);

            if (HResult != S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            bool persistedCred = (HasPersistentCred == 1) ? true : false;
            return persistedCred;

        }
        #endregion

        #region PassportFreeMemory
        /// <summary>
        /// Frees buffers allocated and returned by the client runtime library.
        /// </summary>
        /// <param name="buffer">memory location to Deallocated</param>
        /// <returns></returns>
        public int PassportFreeMemory(IntPtr buffer)
        {
            int HResult = 0;
            HResult = NativeMethods.PassportFreeMemory(buffer);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            return HResult;
        }
        #endregion

        #region SetIdentityProperty
        /// <summary>
        /// Sets the specified property on the identity. Note that not all properties may be settable.
        /// </summary>
        /// <param name="identity">Passport Idenityt Property</param>
        /// <param name="iProperty"></param>
        /// <param name="propertyValue"></param>
        /// <returns></returns>
        public int SetIdentityProperty(int identity, PassportIdentityProperty iProperty, string propertyValue)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);
            HResult = NativeMethods.SetIdentityProperty(hIdentity, iProperty, propertyValue);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            return HResult;
        }
        #endregion

        #region GetExtendedError
        /// <summary>
        /// Gives extended error information for certain IDCRL error conditions.
        /// Its functionality is similar to GetLastError system API at the identity handle scope.
        /// </summary>
        /// <param name="identity">Identity handle.</param>
        /// <param name="authToken"></param>
        /// <returns></returns>
        public int GetExtendedError(int identity, out ManagedIDCRL.IDCRL_ERROR_CATEGORY category, out uint errorCode, out string errorBlob)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);
            IntPtr pReserved = IntPtr.Zero;
            IntPtr errorPtr = IntPtr.Zero;
            uint errorCategory = 0;

            HResult = NativeMethods.GetExtendedError(hIdentity, pReserved, out errorCategory, out errorCode, out errorPtr);
            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            errorBlob = (errorPtr == IntPtr.Zero) ? string.Empty : Marshal.PtrToStringUni(errorPtr);
            switch (errorCategory)
            {
                case 0x00000001:
                    {
                        category = ManagedIDCRL.IDCRL_ERROR_CATEGORY.IDCRL_REQUEST_BUILD_ERROR;
                        break;
                    }
                case 0x00000002:
                    {
                        category = ManagedIDCRL.IDCRL_ERROR_CATEGORY.IDCRL_REQUEST_SEND_ERROR;
                        break;
                    }
                case 0x00000003:
                    {
                        category = ManagedIDCRL.IDCRL_ERROR_CATEGORY.IDCRL_RESPONSE_RECEIVE_ERROR;
                        break;
                    }
                case 0x00000004:
                    {
                        category = ManagedIDCRL.IDCRL_ERROR_CATEGORY.IDCRL_RESPONSE_READ_ERROR;
                        break;
                    }
                case 0x00000005:
                    {
                        category = ManagedIDCRL.IDCRL_ERROR_CATEGORY.IDCRL_REPSONSE_PARSE_ERROR;
                        break;
                    }
                case 0x00000006:
                    {
                        category = ManagedIDCRL.IDCRL_ERROR_CATEGORY.IDCRL_RESPONSE_SIG_DECRYPT_ERROR;
                        break;
                    }
                case 0x00000007:
                    {
                        category = ManagedIDCRL.IDCRL_ERROR_CATEGORY.IDCRL_RESPONSE_PARSE_HEADER_ERROR;
                        break;
                    }
                case 0x00000008:
                    {
                        category = ManagedIDCRL.IDCRL_ERROR_CATEGORY.IDCRL_RESPONSE_PARSE_TOKEN_ERROR;
                        break;
                    }
                case 0x00000009:
                    {
                        category = ManagedIDCRL.IDCRL_ERROR_CATEGORY.IDCRL_RESPONSE_PUTCERT_ERROR;
                        break;
                    }
                default:
                    {
                        category = ManagedIDCRL.IDCRL_ERROR_CATEGORY.IDCRL_RESPONSE_RECEIVE_ERROR;
                        break;
                    }
            }

            //release error ptr
            this.InternalPassportFreeMemory(errorPtr);

            return HResult;
        }
        #endregion

        #region GetExtendedError OverLoad
        /// <summary>
        /// Gives extended error information for certain IDCRL error conditions.
        /// Its functionality is similar to GetLastError system API at the identity handle scope.
        /// </summary>
        /// <param name="identity">Identity handle.</param>
        /// <param name="authToken"></param>
        /// <returns></returns>
        public int GetExtendedError(int identity, out ManagedIDCRL.ExtendedError extentedError)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);
            IntPtr pReserved = IntPtr.Zero;
            IntPtr errorPtr = IntPtr.Zero;
            uint errorCategory = 0;
            uint errorCode = 0;
            extentedError = new ExtendedError();
            try
            {
                HResult = NativeMethods.GetExtendedError(hIdentity, pReserved, out errorCategory, out errorCode, out errorPtr);
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
            }
            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            extentedError.errorBlob = (errorPtr == IntPtr.Zero) ? string.Empty : Marshal.PtrToStringUni(errorPtr);
            extentedError.errorCode = errorCode;
            switch (errorCategory)
            {
                case 0x00000001:
                    {
                        extentedError.category = ManagedIDCRL.IDCRL_ERROR_CATEGORY.IDCRL_REQUEST_BUILD_ERROR;
                        break;
                    }
                case 0x00000002:
                    {
                        extentedError.category = ManagedIDCRL.IDCRL_ERROR_CATEGORY.IDCRL_REQUEST_SEND_ERROR;
                        break;
                    }
                case 0x00000003:
                    {
                        extentedError.category = ManagedIDCRL.IDCRL_ERROR_CATEGORY.IDCRL_RESPONSE_RECEIVE_ERROR;
                        break;
                    }
                case 0x00000004:
                    {
                        extentedError.category = ManagedIDCRL.IDCRL_ERROR_CATEGORY.IDCRL_RESPONSE_READ_ERROR;
                        break;
                    }
                case 0x00000005:
                    {
                        extentedError.category = ManagedIDCRL.IDCRL_ERROR_CATEGORY.IDCRL_REPSONSE_PARSE_ERROR;
                        break;
                    }
                case 0x00000006:
                    {
                        extentedError.category = ManagedIDCRL.IDCRL_ERROR_CATEGORY.IDCRL_RESPONSE_SIG_DECRYPT_ERROR;
                        break;
                    }
                case 0x00000007:
                    {
                        extentedError.category = ManagedIDCRL.IDCRL_ERROR_CATEGORY.IDCRL_RESPONSE_PARSE_HEADER_ERROR;
                        break;
                    }
                case 0x00000008:
                    {
                        extentedError.category = ManagedIDCRL.IDCRL_ERROR_CATEGORY.IDCRL_RESPONSE_PARSE_TOKEN_ERROR;
                        break;
                    }
                case 0x00000009:
                    {
                        extentedError.category = ManagedIDCRL.IDCRL_ERROR_CATEGORY.IDCRL_RESPONSE_PUTCERT_ERROR;
                        break;
                    }
                default:
                    {
                        extentedError.category = ManagedIDCRL.IDCRL_ERROR_CATEGORY.IDCRL_RESPONSE_RECEIVE_ERROR;
                        break;
                    }
            }
            return HResult;
        }
        #endregion

        #region PassportFreeMemory
        private void InternalPassportFreeMemory(IntPtr o)
        {
            //since we are not returing the HResult in this case reuse it for PassportFreeMemory
            int HResult = NativeMethods.PassportFreeMemory(o);

            System.Diagnostics.StackTrace trace = new System.Diagnostics.StackTrace();
            string methodName = trace.GetFrame(1).GetMethod().Name;


            if (HResult < S_OK)
            {
                string innerExceptionMessage = "PassportFreeMemory Called from " + methodName + " threw an Exception " + HResult.ToString("X");
                Exception innerEx = new Exception(innerExceptionMessage);
                IDCRLException e = new IDCRLException(HResult, innerExceptionMessage, innerEx);
                throw e;
            }

        }
        #endregion


        #region Helper Functions
        public IntPtr ConvertStrToPtr(string str)
        {
            IntPtr memPtr = IntPtr.Zero;
            GCHandle hBuffer = new GCHandle();
            int size = 0;

            //create the src byte[]
            byte[] uniStr = Encoding.Unicode.GetBytes(str);

            //set size 
            size = uniStr.Length;

            //create destination buffer
            byte[] buffer = new byte[uniStr.Length];
            hBuffer = GCHandle.Alloc(buffer, GCHandleType.Pinned);
            memPtr = hBuffer.AddrOfPinnedObject();

            Marshal.Copy(uniStr, 0, memPtr, uniStr.Length);
            return memPtr;

        }
        #endregion

        #region 4.0 APIs
        #region CacheAuthState
        /// <summary>
        /// CacheAuthState - caches auth state for a virtual application. 
        /// Writes auth state block in cred manager for that virtual application.
        /// The Native API also takes a flag which is reserved for now. 
        /// This is a managedWrapper overload doesnot take have the flag as an input parameter but passes the default flag = 0 to the native API.
        /// the CacheAuthState API with input flag parameter can be used. The possbile Err
        /// </summary>
        /// <param name="identity">identity handle</param>
        /// <param name="virtualAppName">the name of the virtual application - suggest GUID</param>
        /// <param name="ErrorCodes Returned">E_INVALIDARG
        /// PPCRL_E_NO_MEMBER_NAME_SET
        /// PPCRL_E_UNABLE_TO_RETRIEVE_SERVICE_TOKEN
        /// PPCRL_E_AUTHBLOB_TOO_LARGE (64 * 256 bytes)</param>
        /// <returns>successful hr</returns>
        public int CacheAuthState(int identity, string virtualAppName)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);

            HResult = NativeMethods.CacheAuthState(hIdentity, virtualAppName, (uint)Default_Flag);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            return HResult;
        }
        #endregion

        #region CacheAuthState
        /// <summary>
        /// CacheAuthState - caches auth state for a virtual application. 
        /// Writes auth state block in cred manager for that virtual application.
        /// The Native API also takes a flag which is reserved for now.
        /// </summary>
        /// <param name="identity">identity handle</param>
        /// <param name="virtualAppName">the name of the virtual application - suggest GUID</param>
        /// <param name="flags">reserved</param>
        /// <param name="ErrorCodes Returned">E_INVALIDARG
        /// PPCRL_E_NO_MEMBER_NAME_SET
        /// PPCRL_E_UNABLE_TO_RETRIEVE_SERVICE_TOKEN
        /// PPCRL_E_AUTHBLOB_TOO_LARGE (64 * 256 bytes)</param>
        /// <returns>successful hr</returns>
        public int CacheAuthState(int identity, string virtualAppName, uint flags)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);

            HResult = NativeMethods.CacheAuthState(hIdentity, virtualAppName, flags);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            return HResult;
        }
        #endregion

        #region RemoveAuthStateFromCache
        /// <summary>
        /// Remove cached auth state for a virtual application.
        /// Its writes auth state block in cred manager under the virutal application
        /// </summary>
        /// <param name="username">identity handle - can be NULL, when NULL, user name is not checked, and all users removed under the same virtual app</param>
        /// <param name="virtualAppName">the name of the virtual application - can be NULL, when NULL, virtual app name is not checked, and all removed</param>
        /// <param name="ErrorCodes returned">PPCRL_E_AUTHBLOB_NOT_FOUND</param>
        /// <param name="flags">reserved</param>
        /// <returns>success hr</returns>
        public int RemoveAuthStateFromCache(string username, string virtualAppName, uint flags)
        {
            int HResult = 0;

            HResult = NativeMethods.RemoveAuthStateFromCache(username, virtualAppName, flags);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            return HResult;
        }
        #endregion

        #region RemoveAuthStateFromCache Overload without dwFlags
        /// <summary>
        /// Remove cached auth state for a virtual application.
        /// Its writes auth state block in cred manager under the virutal application. The reserve flag in the Native API is reserved.
        /// This is a managedWrapper overload doesnot take have the flag as an input parameter but passes the default flag = 0 to the native API.
        /// </summary>
        /// <param name="username">identity handle - can be NULL, when NULL, user name is not checked, and all users removed under the same virtual app</param>
        /// <param name="virtualAppName">the name of the virtual application - can be NULL, when NULL, virtual app name is not checked, and all removed</param>
        /// <param name="ErrorCodes returned">PPCRL_E_AUTHBLOB_NOT_FOUND</param>
        /// <returns>success hr</returns>
        public int RemoveAuthStateFromCache(string username, string virtualAppName)
        {
            int HResult = 0;

            HResult = NativeMethods.RemoveAuthStateFromCache(username, virtualAppName, (uint)Default_Flag);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            return HResult;
        }
        #endregion

        #region CreateIdentityHandleFromCachedAuthState
        /// <summary>
        /// creates an identity handle, and import the authtoken blob into cache
        /// </summary>
        /// <param name="username">the name of the user - NULL, any user</param>
        /// <param name="virtualAppName">the name of the virtual app - NULL, any app</param>
        /// <param name="flags">IDENTITY_FLAG</param>
        /// <param name="identity">This is an out param. The identity handle, this should be closed by: CloseIdentityHandle</param>
        /// <param name="ErrorCodes returned">E_INVALIDARG
        /// E_POINTER  -- when pihIdentity is NULL
        /// PP_E_CRL_ILLEGAL_IDENTITY_FLAG - 
        /// PP_E_CRL_NOT_INITIALIZED</param>
        /// <returns>successful hr</returns>
        public int CreateIdentityHandleFromCachedAuthState(string username, string virtualAppName, uint flags, out int identity)
        {
            int HResult = 0;
            IntPtr hIdentity = IntPtr.Zero;
            HResult = NativeMethods.CreateIdentityHandleFromCachedAuthState(username, virtualAppName, flags, out hIdentity);

            if (HResult < 0)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            identity = hIdentity.ToInt32();
            return HResult;


        }
        #endregion

        #region CreateIdentityHandleFromCachedAuthState
        /// <summary>
        /// creates an identity handle, and import the authtoken blob into cache
        /// </summary>
        /// <param name="virtualAppName">the name of the virtual app - NULL, any app</param>
        /// <param name="flags">IDENTITY_FLAG</param>
        /// <param name="identity">This is an out param. The identity handle, this should be closed by: CloseIdentityHandle</param>
        /// <param name="ErrorCodes returned">E_INVALIDARG
        /// E_POINTER  -- when pihIdentity is NULL
        /// PP_E_CRL_ILLEGAL_IDENTITY_FLAG - 
        /// PP_E_CRL_NOT_INITIALIZED</param>
        /// <returns>successful hr</returns>
        public int CreateIdentityHandleFromCachedAuthState(string virtualAppName, uint flags, out int identity)
        {
            int HResult = 0;
            IntPtr hIdentity = IntPtr.Zero;
            HResult = NativeMethods.CreateIdentityHandleFromCachedAuthState(virtualAppName, flags, out hIdentity);

            if (HResult < 0)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            identity = hIdentity.ToInt32();
            return HResult;
        }
        #endregion

        #region CreateIdentityHandleFromAuthState
        /// <summary>
        /// create an identity handle, and import  the authtoken blob. 
        /// Exception Thrown :
        /// E_INVALIDARG
        /// E_POINTER  -- when pihIdentity is NULL
        /// PP_E_CRL_ILLEGAL_IDENTITY_FLAG - 
        /// PP_E_CRL_NOT_INITIALIZED
        /// </summary>
        /// <param name="authToken">the auth token</param>
        /// <param name="flags">IDENTITY_FLAG</param>
        /// <param name="identity">the identity handle, this should be closed by: CloseIdentityHandle</param>        /// 
        /// </param>
        /// <returns>success hr</returns>
        public int CreateIdentityHandleFromAuthState(string authToken, uint flags, out int identity)
        {
            int HResult = 0;
            IntPtr hIdentity = IntPtr.Zero;

            HResult = NativeMethods.CreateIdentityHandleFromAuthState(authToken, flags, out hIdentity);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            identity = hIdentity.ToInt32();
            return HResult;
        }
        #endregion

        #region GetWebAuthUrlEx
        /// <summary>
        /// Get Url and post data for web authentication. E.g. for hotmail inbox.
        /// * NOTES :Calling application must set the following header:
        /// * Content-Type: application/x-www-form-urlencoded
        /// * for the POST request to be accepted by the login server.
        /// </summary>
        /// <param name="identity">Identity handle created previously</param>
        /// <param name="targetService">name of the target service</param>
        /// <param name="policy">policy for the service ticket</param>
        /// <param name="additionalParams">Other params required for the call the core params computed by the API. </param>
        /// <param name="pszWebAuthUrl">Output param that holds the URL to post the data  </param>
        /// <param name="pszPostData">Post data to be sent with the request, it includes the additional post params specified in szAdditionalPostParams</param>
        /// <returns>Upon success, the API will give a URL with a blob of data that can be POSTed to the URL for authentication, this is using PSHA1AuthE_INVALIDARG</returns>
        public int GetWebAuthUrlEx(int identity, ManagedIDCRL.WebAuthOptions authType, string targetService, string policy, string additionalParams, out SHA1 sha1Data)
        {
            IntPtr hIdentity = new IntPtr(identity);
            IntPtr webAuthUrl = IntPtr.Zero;
            IntPtr postData = IntPtr.Zero;
            sha1Data = new SHA1();

            int HResult = 0;
            HResult = NativeMethods.GetWebAuthUrlEx(hIdentity, (uint)authType, targetService, policy, additionalParams, out webAuthUrl, out postData);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            if ((webAuthUrl != IntPtr.Zero) && (postData != IntPtr.Zero)) //removing this condition how to figure that the contents != NULL ?
            {
                sha1Data.sha1Url = Marshal.PtrToStringUni(webAuthUrl);
                sha1Data.sha1PostData = Marshal.PtrToStringUni(postData);
            }

            this.InternalPassportFreeMemory(webAuthUrl);
            this.InternalPassportFreeMemory(postData);

            return HResult;

        }

        #endregion

        #region ExportAuthState
        /// <summary>
        /// Export AuthToken into a blob. Export authenticate token and its session key into an xml blob
        /// </summary>
        /// <param name="identity">identity handle</param>
        /// <param name="flags">reserved</param>
        /// <param name="authToken">returns AuthToken into a blob. should be free'ed with PassportFreeMemory</param>
        /// <param name="ErrorCodes Returned">PPCRL_E_NO_MEMBER_NAME_SET
        /// E_INVALIDARG
        /// PPCRL_E_UNABLE_TO_RETRIEVE_SERVICE_TOKEN
        /// PP_E_CRL_NOT_INITIALIZED</param>
        /// <returns>success hr</returns>
        public int ExportAuthState(int identity, uint flags, out string authToken)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);
            authToken = string.Empty;
            IntPtr state = IntPtr.Zero;

            HResult = NativeMethods.ExportAuthState(hIdentity, flags, out state);
            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            authToken = (state == IntPtr.Zero) ? string.Empty : Marshal.PtrToStringUni(state);
            return HResult;
        }
        #endregion

        #region ExportAuthState
        /// <summary>
        /// Export AuthToken into a blob. Export authenticate token and its session key into an xml blob
        /// This is a managedWrapper overload doesnot take have the flag as an input parameter but passes the default flag = 0 to the native API.
        /// </summary>
        /// <param name="identity">identity handle</param>
        /// <param name="flags">reserved</param>
        /// <param name="authToken">returns AuthToken into a blob. should be free'ed with PassportFreeMemory</param>
        /// <param name="ErrorCodes Returned">PPCRL_E_NO_MEMBER_NAME_SET
        /// E_INVALIDARG
        /// PPCRL_E_UNABLE_TO_RETRIEVE_SERVICE_TOKEN
        /// PP_E_CRL_NOT_INITIALIZED</param>
        /// <returns>success hr</returns>
        public int ExportAuthState(int identity, out string authToken)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);
            authToken = string.Empty;
            IntPtr state = IntPtr.Zero;

            HResult = NativeMethods.ExportAuthState(hIdentity, Default_Flag, out state);
            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            authToken = (state == IntPtr.Zero) ? string.Empty : Marshal.PtrToStringUni(state);

            //release error ptr
            this.InternalPassportFreeMemory(state);

            return HResult;
        }
        #endregion

        #region GetExtendedProperty
        /// <summary>
        /// GetExtendedProperty - get the value for a given property name - per windows logon property
        /// wszPropertyName: name of the property
        /// <param name="ErrorCodes returned">
        /// E_INVALIDARG
        /// E_OUTOFMEMORY
        /// PP_E_CRL_NOT_INITIALIZED
        /// Error from registry access API:RegOpenKeyEx RegGetValueEx</param>
        /// </summary>
        /// <param name="propertyName">name of the property</param>
        /// <returns>Property Value :value of the property, IDCRL allocates the buffer, and it 
        ///should be freed with PassportFreeMemory call</returns>
        public string GetExtendedProperty(string propertyName)
        {
            int HResult = 0;
            IntPtr value = IntPtr.Zero;
            string propertyValue = string.Empty;

            HResult = NativeMethods.GetExtendedProperty(propertyName, out value);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            propertyValue = (value == IntPtr.Zero) ? string.Empty : Marshal.PtrToStringUni(value);

            //release value ptr
            this.InternalPassportFreeMemory(value);

            return propertyValue;
        }
        #endregion

        #region SetExtendedProperty
        /// <summary>
        /// SetExtendedProperty - set name value pair - per windows logon property
        /// wszPropertyName: name of the property
        /// <param name="ErrorCodes returned">
        /// E_INVALIDARG
        /// Error from registry access API:RegOpenKeyEx RegGetValueEx</param>
        /// </summary>
        /// <param name="propertyName">name of the property</param>
        /// <param name="propertyName">name of the property</param>
        /// <returns>success code. Currently no successcode is returned</returns>
        public int SetExtendedProperty(string propertyName, string propertyValue)
        {
            int HResult = 0;

            HResult = NativeMethods.SetExtendedProperty(propertyName, propertyValue);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            return HResult;
        }
        #endregion

        #region GetUserExtendedProperty
        /// <summary>
        /// GetUserExtendedProperty - get the value for a given name - per windows logon property
        /// <param name="ErrorCodes returned">
        /// E_INVALIDARG
        /// Error from registry access API:RegOpenKeyEx RegGetValueEx
        /// PPCRL_E_USER_NOTFOUND</param>
        /// </summary>
        /// <param name="userName">memebername</param>
        /// <param name="property">name of the property</param>        
        /// <returns>property value</returns>
        public string GetUserExtendedProperty(string userName, string property)
        {
            int HResult = 0;
            IntPtr value = IntPtr.Zero;
            string propertyValue = string.Empty;

            HResult = NativeMethods.GetUserExtendedProperty(userName, property, out value);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            propertyValue = (value == IntPtr.Zero) ? string.Empty : Marshal.PtrToStringUni(value);

            //release error ptr
            this.InternalPassportFreeMemory(value);

            return propertyValue;
        }
        #endregion

        #region SetUserExtendedProperty
        /// <summary>
        /// SetExtendedProperty - set name value pair - per windows logon property
        /// wszPropertyName: name of the property
        /// <param name="ErrorCodes returned">
        /// E_INVALIDARG
        /// Error from registry access API:RegOpenKeyEx RegGetValueEx</param>
        /// </summary>
        /// <param name="propertyName">name of the property</param>
        /// <param name="propertyValue">value of the property, NULL or empty string will delete an existing value</param>
        /// <returns>success code. Currently no successcode is returned</returns>
        public int SetUserExtendedProperty(string username, string property, string propertyValue)
        {
            int HResult = 0;

            HResult = NativeMethods.SetUserExtendedProperty(username, property, propertyValue);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            return HResult;
        }
        #endregion

        #region GetServiceConfig
        /// <summary>
        /// GetServiceConfig - get config urls in the config xml
        /// </summary>
        /// <param name="valueName">name of the service</param>
        /// <param name="ErrorCodes returned">E_INVALIDARG
        /// S_FALSE : not found</param>
        /// <returns>Service Url</returns>
        public string GetServiceConfig(string valueName)
        {
            int HResult = 0;
            IntPtr url = IntPtr.Zero;
            string urlValue = string.Empty;

            HResult = NativeMethods.GetServiceConfig(valueName, out url);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            urlValue = (url == IntPtr.Zero) ? string.Empty : Marshal.PtrToStringUni(url);

            //call free memory on the url
            this.InternalPassportFreeMemory(url);

            return urlValue;
        }
        #endregion

        #region EncryptWithSessionKey
        /// <summary>
        ///  Call this to encrypt data blob with session key in the service token to the encrypted data to be sent to the target service
        /// </summary>
        /// <param name="identity">identity Handle</param>
        /// <param name="serviceName">service name of the session key to be used</param>
        /// <param name="algIdEncrypt">Algorithm ID for encryption</param>
        /// <param name="algIdHash">Algorithm Hash to be used for Encryption</param>
        /// <param name="data">data to be encrypted</param>
        /// <param name="cipherPtr">This out param is the pointer to the encrypted data</param>
        /// <param name="cipherSize">This out param will hold the size of the encrypted data</param>
        /// <returns>Suceessful HResult</returns>
        public int EncryptWithSessionKey(int identity, string serviceName, uint algIdEncrypt, uint algIdHash, string data, out IntPtr cipherPtr, out uint cipherSize)
        {
            IntPtr hIdentity = new IntPtr(identity);
            IntPtr memPtr = IntPtr.Zero;
            GCHandle hBuffer = new GCHandle();
            int dataSize = data.Length;

            int HResult = 0;
            //get ptr to the data to be encrypted
            byte[] buffer = new byte[data.Length];
            hBuffer = GCHandle.Alloc(buffer, GCHandleType.Pinned);
            memPtr = hBuffer.AddrOfPinnedObject();

            System.Text.ASCIIEncoding ascii = new ASCIIEncoding();
            byte[] temp = ascii.GetBytes(data);
            Marshal.Copy(temp, 0, memPtr, dataSize);

            cipherPtr = IntPtr.Zero;
            HResult = NativeMethods.EncryptWithSessionKey(hIdentity, serviceName, algIdEncrypt, algIdHash, memPtr, (uint)dataSize, out cipherPtr, out cipherSize);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            return HResult;
        }
        #endregion

        #region DecryptWithSessionKey
        ///  Call this to encrypt data blob with session key in the service token to the encrypted data to be sent to the target service
        /// </summary>
        /// <param name="identity">identity Handle</param>
        /// <param name="serviceName">service name of the session key to be used</param>
        /// <param name="algIdEncrypt">Algorithm ID for encryption</param>
        /// <param name="algIdHash">Algorithm Hash to be used for Encryption</param>
        /// <param name="cipherPtr">Pointer to the encrypted data</param>
        /// <param name="cipherSize">Size of the encrypted data</param>
        /// <param name="data">This out parameter will hold the decrypted data</param>
        /// <param name="dataSize">This out paramter will hold the size of the decrypted data</param>
        /// <returns>Suceessful HResult</returns>
        public int DecryptWithSessionKey(int identity, string serviceName, uint algIdEncrypt, uint algIdHash, IntPtr cipherPtr, uint cipherSize, out string data, out uint dataSize)
        {
            IntPtr hIdentity = new IntPtr(identity);
            IntPtr dataPtr = IntPtr.Zero;
            int HResult = 0;
            dataSize = 0;


            //get ptr to the data to be encrypted
            HResult = NativeMethods.DecryptWithSessionKey(hIdentity, serviceName, algIdEncrypt, algIdHash, cipherPtr, cipherSize, out dataPtr, out dataSize);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            byte[] buffer = new byte[dataSize];
            Marshal.Copy(dataPtr, buffer, 0, (int)dataSize);

            System.Text.ASCIIEncoding ascii = new System.Text.ASCIIEncoding();
            data = ascii.GetString(buffer);

            //free dataPtr 
            this.InternalPassportFreeMemory(dataPtr);

            return HResult;
        }
        #endregion

        #region Initialize
        /// <summary>
        /// Initialize : Must be called before and return successfully before any other client runtime library functions are called.
        /// </summary>
        /// <param name="appGuid">guid: the GUID of the app</param>
        /// <param name="keepOldCreds">If true, IDCRL will NOT delete old credentials after migrating to Credman store. 
        /// This is application for scenarios where a user may want to downgrade to a previous version of the app.
        /// Note: It is a security risk to preserve old credentials and apps should make the decision to keep or delete them carefully.</param>
        /// <param name="migrateUserCount">Number of users migrated.</param>
        /// <returns>Suceessful HResult</returns>        
        public int MigratePersistedCredentials(ref System.Guid appGuid, bool keepOldCreds, out uint migratedUserCount)
        {
            int HResult = 0;
            migratedUserCount = 0;
            HResult = NativeMethods.MigratePersistedCredentials(ref appGuid, keepOldCreds, out migratedUserCount);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            return HResult;

        }
        #endregion


        #endregion

        #region 5.0 APIs

        public int GetDeviceID(int dwFlags, string additionalParams, out string strDeviceId, out X509Certificate2 didCert)
        {
            PCCERT_CONTEXT didCertContext;
            int HResult = 0;
            didCert = null;
            IntPtr deviceIdPtr = IntPtr.Zero;
            strDeviceId = string.Empty;

            didCertContext = IntPtr.Zero;

            HResult = NativeMethods.GetDeviceId(dwFlags, additionalParams, out deviceIdPtr, out didCertContext);

            if (HResult == 0)
            {
                strDeviceId = Marshal.PtrToStringUni(deviceIdPtr);
                didCert = new X509Certificate2(didCertContext);
                //Console.WriteLine("SubjectName: " + didCert.Subject);
                //Console.WriteLine("IssueDate: " + didCert.GetEffectiveDateString());
                //Console.WriteLine("ExpiryDate: " + didCert.GetExpirationDateString());
                //Console.WriteLine("IssuerName: " + didCert.Issuer);
            }

            return HResult;
        }
        
        public int GetDeviceID(int dwFlags, string additionalParams, out string strDeviceId, out CertSet certSet)
        {
            PCCERT_CONTEXT didCertContext;
            int HResult = 0;
            certSet = new CertSet();
            IntPtr deviceIdPtr = IntPtr.Zero;
            strDeviceId = string.Empty;

            didCertContext = IntPtr.Zero;

            HResult = NativeMethods.GetDeviceId(dwFlags, additionalParams, out deviceIdPtr, out didCertContext);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            //get the devicename
            strDeviceId = Marshal.PtrToStringUni(deviceIdPtr);

            //release the deviceptr
            this.InternalPassportFreeMemory(deviceIdPtr);

            //incase of PPCRL_REQUEST_S_IO_PENDING PPCRL_SUCCESS_CODE(0x47)
            if (HResult == 297031)
            {
                certSet = new CertSet();
            }
            else
            {
                certSet = new CertSet(didCertContext, IntPtr.Zero, 0, IntPtr.Zero);
            }

            return HResult;
        }

        public int SetDeviceConsent(int dwFlags, int dwConsentSetting, string additionalParams)
        {

            int HResult = 0;
            HResult = NativeMethods.SetDeviceConsent(dwFlags, dwConsentSetting, additionalParams);
            return HResult;
        }

        // This method throws exception on failure. I needed to add this override because kalyans created methods 
        // which do not throw exception on failure. As an FxCop interop requirement we need to throw exception on failure. 
        // creating this override so existing cases do not break
        public int SetDeviceConsentExcpt(int dwFlags, int dwConsentSetting, string additionalParams)
        {

            int HResult = 0;
            HResult = NativeMethods.SetDeviceConsent(dwFlags, dwConsentSetting, additionalParams);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            return HResult;
        }

        public int CloseDeviceID(int dwFlags, string additionalParams)
        {

            int HResult = 0;
            HResult = NativeMethods.CloseDeviceID(dwFlags, additionalParams);
            //Console.WriteLine("CloseDeviceID returned: " + HResult);
            return HResult;
        }

        // This method throws exception on failure. I needed to add this override because kalyans created methods 
        // which do not throw exception on failure. As an FxCop interop requirement we need to throw exception on failure. 
        // creating this override so existing cases do not break
        public int CloseDeviceIDExcpt(int dwFlags, string additionalParams)
        {

            int HResult = 0;
            HResult = NativeMethods.CloseDeviceID(dwFlags, additionalParams);
            
            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            return HResult;
        }

        public int GenerateDeviceToken(int dwFlags, string additionalParams, string audience, out string strDeviceToken)
        {
            int HResult = 0;
            IntPtr deviceTokenPtr = IntPtr.Zero;
            strDeviceToken = string.Empty;
            
            HResult = NativeMethods.GenerateDeviceToken(dwFlags, additionalParams, audience, out deviceTokenPtr);
            /*
            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
             */

            if (HResult == 0)
            {
                strDeviceToken = Marshal.PtrToStringUni(deviceTokenPtr);

                this.InternalPassportFreeMemory(deviceTokenPtr);
            }
            return HResult;
        }

        // This method throws exception on failure. I needed to add this override because kalyans created methods 
        // which do not throw exception on failure. As an FxCop interop requirement we need to throw exception on failure. 
        // creating this override so existing cases do not break
        public int GenerateDeviceTokenExcpt(int dwFlags, string additionalParams, string audience, out string strDeviceToken)
        {
            int HResult = 0;
            IntPtr deviceTokenPtr = IntPtr.Zero;
            strDeviceToken = string.Empty;

            HResult = NativeMethods.GenerateDeviceToken(dwFlags, additionalParams, audience, out deviceTokenPtr);
            
            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            if (HResult == 0)
            {
                strDeviceToken = Marshal.PtrToStringUni(deviceTokenPtr);

                this.InternalPassportFreeMemory(deviceTokenPtr);
            }
            return HResult;
        }

        public int GenerateCertToken(int identity, uint dwFlags, ref string strCertToken)
        {

            int HResult = 0;
            IntPtr certTokenPtr = IntPtr.Zero;
            IntPtr hIdentity = new IntPtr(identity);

            HResult = NativeMethods.GenerateCertToken(hIdentity, dwFlags, out certTokenPtr);

            if (HResult == 0) strCertToken = Marshal.PtrToStringUni(certTokenPtr);

            //Console.WriteLine("GenerateCertToken returned: " + HResult);
            return HResult;
        }

        public int EnumerateCertificates(uint dwFlags, string prgwszCSPs, string prgwszThumbprints, ref IDCRLCertInfo[] idcrlCertInfo)
        {
            int HResult = 0;
            IntPtr CertInfo = IntPtr.Zero;
            uint dwCerts = 0;


            HResult = NativeMethods.EnumerateCertificates(dwFlags, prgwszCSPs, prgwszThumbprints, out dwCerts, out CertInfo);

            idcrlCertInfo = new IDCRLCertInfo[dwCerts];

            for (int i = 0; i < dwCerts; i++)
            {
                idcrlCertInfo[i] = (IDCRLCertInfo)Marshal.PtrToStructure(CertInfo, typeof(IDCRLCertInfo));

                string description = new string(idcrlCertInfo[i].description);
                string thumbPrint = new string(idcrlCertInfo[i].thumbprint);
                Console.WriteLine("\nDESC: " + description);
                Console.WriteLine("\nTP: " + thumbPrint);
                CertInfo = new IntPtr(CertInfo.ToInt64() + Marshal.SizeOf(idcrlCertInfo[i]));
            }

            return HResult;
        }

        public int EnumerateDeviceID(int dwFlags, string additionalParams, out string[] deviceIDs, out CertSet[] certSet)
        {
            int HResult = 0;
            uint certCount = 0;

            IntPtr deviceIdPtr; ;

            PCCERT_CONTEXT didCertContext;

            HResult = NativeMethods.EnumerateDeviceID(dwFlags, additionalParams, out certCount, out deviceIdPtr, out didCertContext);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            //create pointerarray
            IntPtr[] didArr = new IntPtr[certCount];
            IntPtr[] didContextArr = new IntPtr[certCount];

            Marshal.Copy(deviceIdPtr, didArr, 0, (int)certCount);
            Marshal.Copy(didCertContext, didContextArr, 0, (int)certCount);


            deviceIDs = new string[certCount];
            certSet = new CertSet[certCount];

            for (int i = 0; i < certCount; i++)
            {
                certSet[i] = new CertSet(didContextArr[i], IntPtr.Zero, 0, IntPtr.Zero);
                deviceIDs[i] = Marshal.PtrToStringUni(didArr[i]);
            }
            
            return HResult;
        }

        public int CreateLinkedIdentityHandle(int identity, uint dwFlags, string wszMemberName, out int linkedIdentity)
        {
            int HResult = 0;
            IntPtr hIdentity = new IntPtr(identity);
            IntPtr hLinkedIdentity = IntPtr.Zero;
            linkedIdentity = 0;
           
            HResult = NativeMethods.CreateLinkedIdentityHandle(hIdentity, dwFlags, wszMemberName, out hLinkedIdentity);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }
            linkedIdentity = hLinkedIdentity.ToInt32();
            return HResult;
        }

        #endregion

        #region OpenAuthenticatedBrowser
        /// <summary>
        /// Get Url and post data for web authentication.
        /// E.g. for hotmail inbox.Similar to GetWebAuthUrlEx, except it also opens the IE window
        /// </summary>
        /// <param name="identity">Identity handle created previously</param>
        /// <param name="targetService">name of the target service</param>
        /// <param name="policy">policy for the service ticket</param>
        /// <param name="additionalParams">Other params required for the call the core params computed by the API. </param>
        /// <returns>Upon success, the API will give a URL with a blob of data that can be POSTed to the URL for authentication, this is using PSHA1AuthE_INVALIDARG</returns>
        public int OpenAuthenticatedBrowser(int identity, ManagedIDCRL.WebAuthOptions authType, string targetService, string policy, string additionalParams)
        {
            IntPtr hIdentity = new IntPtr(identity);

            int HResult = 0;
            HResult = NativeMethods.OpenAuthenticatedBrowser(hIdentity, (uint)authType, targetService, policy, additionalParams);

            if (HResult < S_OK)
            {
                IDCRLException e = new IDCRLException(HResult);
                throw e;
            }

            return HResult;
        }

        #endregion


        #endregion

    }

    #endregion //managedidcrl

    #region IDCRLException
    /// <summary>
    /// IDCRLException Class wrappers errors returned by NativeMethod. The class returns Failed HR and the Name of the NativeMethod which 
    /// failed. 
    /// </summary>
    public class IDCRLException : System.Exception
    {
        #region State
        internal int errorCode;
        internal string errorMsg;
        internal string customMessage = "IDCRL Exception";
        #endregion

        #region Properties
        public int ErrorCode
        {
            get { return this.errorCode; }
        }

        public string ErrorMessage
        {
            get { return this.errorMsg; }
        }

        #endregion

        #region Constructors
        //when this constructor is called the caller needs to handle localiation
        public IDCRLException(string message) : base(message) { }

        //when this constructor is called the caller needs to handle localiation
        public IDCRLException(int errorcode, string message, Exception innerException)
            : base(message, innerException)
        {
            this.SetException(errorcode);
        }

        public IDCRLException(int errorcode)
        {
            this.SetException(errorcode);
        }

        private void SetException(int errorcode)
        {
            this.errorCode = errorcode;
            this.HResult = errorcode;
            //Resource Management will be added in VNext
            //this.errorMsg = this.GetString(this.customMessage);

            System.Diagnostics.StackTrace trace = new System.Diagnostics.StackTrace();

            string methodName = trace.GetFrame(2).GetMethod().Name;
            string msg = this.customMessage + " In Method: " + methodName + " \r\nIDCRL ErrorCode : " + errorcode.ToString("X");


            this.errorMsg = msg;
        }
        #endregion
    }
#endregion

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\EnvironmentAwareAuthCache.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Web;
using System.Web.Caching;
using System.Diagnostics;

using LiveNew.Test;

using LiveN.Test.Common;
using LiveN.Test.Framework;

namespace LiveN.Test
{
    /// <summary>
    /// Caches authorization information, on a per credential basis, to avoid repeat/superfluous authentications.
    /// Currently hardcoded to cache authorization data for 30 mins.
    /// </summary>
    public class EnvironmentAwareAuthCache
    {
        /// <summary>
        /// Authorization Cache this static class is based off of
        /// </summary>
        private AuthorizationCache AuthCache;

        /// <summary>
        /// Get or set the Environment this object uses to do it's communications
        /// </summary>
        private EnvironmentElement CurrentEnvironment
        {
            get
            {
                if (memberCurrentEnvironment != null)
                {
                    return memberCurrentEnvironment;
                }

                // Environment has not been specified, use the common one.
                return CurrentEnvironment;
            }
            set
            {
                memberCurrentEnvironment = value;
            }
        }
        private EnvironmentElement memberCurrentEnvironment = null;

        /// <summary>
        /// Create an AuthorizationCache based off the Current Environment Settings
        /// </summary>
        public EnvironmentAwareAuthCache()
        {
        }

        /// <summary>
        /// Create an AuthorizationCache based off the Current Environment Settings
        /// </summary>
        /// <param name="runEnvironment">Environment used to control where this instance will call</param>
        public EnvironmentAwareAuthCache(EnvironmentElement runEnvironment)
        {
            CurrentEnvironment = runEnvironment;

            AuthCache = new AuthorizationCache(CurrentEnvironment.StsSettings.StsUrl, CurrentEnvironment.StsSettings.ClientCertSubject, 30000);
        }

        /// <summary>
        /// Get a user's partner token based off the passed in Member namd and Password. Based off the default values stored within the Default configuration file (LiveN.EnvironmentSettings.config)
        /// </summary>
        public string GetPartnerToken(string UserEmail, string password, string audienceUri)
        {
            TitleElement title;

            // Set to the first environment title
            title = CurrentEnvironment.Titles[0];

            return GetPartnerToken(UserEmail, password, title, audienceUri);
        }

        /// <summary>
        /// Get a user's Partner Token based off the passed in Member namd and Password. Based off the default values stored within the Default configuration file (LiveN.EnvironmentSettings.config)
        /// </summary>
        public string GetPartnerToken(string UserEmail, string password, TitleElement title, string audienceUri)
        {
            string partnerToken = string.Empty;

            partnerToken = AuthCache.GetPartnerToken(
                                        UserEmail,
                                        password,
                                        CurrentEnvironment.WindowsLiveIDSettings.LiveIdServiceTarget,
                                        CurrentEnvironment.WindowsLiveIDSettings.Policy,
                                        CurrentEnvironment.WindowsLiveIDSettings.Environment,
                                        CurrentEnvironment.StsSettings.PlatformType,
                                        title.Id,
                                        title.Version,
                                        title.ClientVersion,
                                        audienceUri);

            return partnerToken;
        }

        /// <summary>
        /// Get a User Token based off the passed in Member namd and Password. Based off the default values stored within the Default configuration file (LiveN.EnvironmentSettings.config)
        /// </summary>
        public string GetUserToken(string UserEmail, string password, TitleElement title)
        {
            string userToken = string.Empty;

            userToken = AuthCache.GetUserToken(
                                        UserEmail,
                                        password,
                                        CurrentEnvironment.WindowsLiveIDSettings.LiveIdServiceTarget,
                                        CurrentEnvironment.WindowsLiveIDSettings.Policy,
                                        CurrentEnvironment.WindowsLiveIDSettings.Environment,
                                        CurrentEnvironment.StsSettings.PlatformType,
                                        title.Id,
                                        title.Version,
                                        title.ClientVersion);

            return userToken;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\OfferContext.cs ===
﻿using System;
using System.Collections.Generic;

namespace LiveN.Test
{
    /// <summary>
    /// Offer information required to purchase and verify an Offer
    /// </summary>
    public class OfferContext
    {
        /// <summary>
        /// Gets or sets the TitleId which represents which Game Title this offer belongs to
        /// </summary>
        public int TitleId { get; set; }

        /// <summary>
        /// Gets or sets the OfferId of the offer.
        /// </summary>
        public Guid OfferId { get; set; }

        /// <summary>
        /// Gets or sets the ProductId of the offer. (GameContent.ProductId == EmsOffer.MediaId == Xbox Offer id) Bug 11839
        /// </summary>
        public Guid ProductId { get; set; }

        /// <summary>
        /// Gets or sets the Title of the purchased offer.
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        ///  Gets or sets the Token that can be used to purchase this Offer
        /// </summary>
        public string BillingToken { get; set; }

        /// <summary>
        /// Gets or sets the GameContentTypeId of the offer. (GameContent.GameContentTypeId == EmsOffer.MediaType) Bug 11839
        /// </summary>
        public int GameContentTypeId { get; set; }        

        /// <summary>
        /// Gets or sets the MediaInstances of the offer
        /// </summary>
        public List<string> MediaInstanceURLs { get; set; }

        /// <summary>
        /// Gets or sets Number of points required to purchase this offer
        /// </summary>
        public decimal PointsPricePoints { get; set; }

        /// <summary>
        /// Gets or sets Number of points required to purchase this Token offer
        /// </summary>
        public decimal PointsPriceToken { get; set; }

        /// <summary>
        /// Gets or sets the AssetId of the offer (Consumables Only)
        /// </summary>
        public uint AssetId { get; set; }

        /// <summary>
        /// Gets or sets the Asset Quantity of the offer (Consumables Only)
        /// </summary>
        public uint AssetQuantity { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\XboxLiveAccount.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using LiveN.Test.Common;

namespace LiveN.Test.Framework
{
    /// <summary>
    /// 
    /// </summary>
    public class XboxLiveAccount: IEquatable<XboxLiveAccount>
    {
        private static char[] gamerTagChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 ".ToCharArray();        

        /// <summary>
        /// 
        /// </summary>
        public string MemberName
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Password
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string GamerTag
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public ulong Xuid
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(XboxLiveAccount other)
        {
            return this.MemberName.Equals(other.MemberName, StringComparison.InvariantCultureIgnoreCase);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static string GenerateRandomGamerTag()
        {
            return GenerateRandomGamerTag(10);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static string GenerateRandomGamerTag(int length)
        {
            StringBuilder gamerTag = new StringBuilder(length);
            gamerTag.Append(gamerTagChars[Utility.GlobalRandom.Next(51)]);  //first char can't be a number/space

            int i = 0;
            while (i < length)
            {
                char nextChar = gamerTagChars[Utility.GlobalRandom.Next(gamerTagChars.Length - 1)];
                if (nextChar == ' ' && gamerTag[gamerTag.Length - 1] == ' ') //can't have consecutive spaces
                    continue;
                gamerTag.Append(nextChar);
                i++;
            }

            return gamerTag.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\XboxLive.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;

using Microsoft.WindowsLive.Test.PassportInterface;
using LiveN.Test.Common;
using LiveN.Test.Framework.Web;
using LiveN.Test.Framework.Authorization;
using LiveN.Test.Framework.Configuration;

namespace LiveN.Test.Framework
{
    /// <summary>
    /// 
    /// </summary>
    public class XboxLive
    {
        private AuthorizationCache authCache;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="xuacsUrl"></param>
        /// <param name="xuacsClientCertSubject"></param>
        /// <param name="xuacsCreationTimeout"></param>
        /// <param name="stsUrl"></param>
        /// <param name="stsClientCertSubject"></param>
        /// <param name="liveIdServiceTarget"></param>
        /// <param name="policy"></param>
        /// <param name="environment"></param>
        /// <param name="platformType"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="clientVersion"></param>
        public XboxLive(
            string xuacsUrl,
            string xuacsClientCertSubject,
            int xuacsCreationTimeout,
            string stsUrl,
            string stsClientCertSubject,
            string liveIdServiceTarget,
            string policy,
            string environment,
            string platformType,
            string titleId,
            string titleVersion,
            string clientVersion)
        {
            this.authCache = new AuthorizationCache(stsUrl, stsClientCertSubject);

            this.XuacsProxy = new UserAccountProxy();
            this.XuacsProxy.Url = xuacsUrl;
            this.XuacsProxy.ClientCertificateSubject = xuacsClientCertSubject;
            this.XuacsCreationTimeout = xuacsCreationTimeout;

            this.LiveIdServiceTarget = liveIdServiceTarget;
            this.Policy = policy;
            this.Environment = environment;

            this.PlatformType = platformType;
            this.TitleId = titleId;
            this.TitleVersion = titleVersion;
            this.ClientVersion = clientVersion;
        }

        /// <summary>
        /// 
        /// </summary>
        public UserAccountProxy XuacsProxy
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        public int XuacsCreationTimeout
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string LiveIdServiceTarget
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Policy
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Environment
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string PlatformType
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string TitleId
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string TitleVersion
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string ClientVersion
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public XboxLiveAccount CreateWlidAndXblAccount()
        {
            PassportUser user = LiveID.CreateWindowsLiveID();
            string randomGamerTag = XboxLiveAccount.GenerateRandomGamerTag();
            return CreateXblAccount(user.MemberName, user.Password, randomGamerTag);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <param name="gamerTag"></param>
        /// <returns></returns>
        public XboxLiveAccount CreateWlidAndXblAccount(string memberName, string password, string gamerTag)
        {
           // LiveID.CreateWindowsLiveID(memberName, password);
            return CreateXblAccount(memberName, password, gamerTag);
        }

        /// <summary>
        /// Creates a new XBL account for an existing Windows Live ID account.
        /// </summary>
        public XboxLiveAccount CreateXblAccount(string memberName, string password, string gamerTag)
        {
            string loginTicket = "t=EwCYAZT6AAAUvKlGRhsFstWX+Epiy23voq6E7beAAESiCplsf3X/9VkpmN/5H8P6V2lP8q/P5xhe3As9wxxS92GGT3PG2TvaN8I4ChnKNPYMCPAoWxQsqGiHpkFw+aOpemo2sZ2n7vGFJFMCWiTVacSX9GGLMjXSGjAm3RQOxBlOn7BVR8XamOPRP+fhieP+zL0VHxZFxn/5EKvmpERZA2YAAAiGAukJzj4J8ugAG/814+d619wN2VRyNhH9l7V2625q38FrzKezj8gKoV5YAHj7ZnKt6a8dmPzBdwpTFJgnCuy+lZ8EpcDUp7V4/EqrioFBrqJpnINTesFNHNFpe3vfOh3Ala2cooFvk/KC7RK2ZbfUlrby9NZHBpnAyF3PnSt8k+CEWTYRrY7yFoqm+rl+EmUovqr9DzJCBZug6oe07Ejp89ERvMKzZE8Vk3q3tv5tKiZMV3vJN/D1DOfRYpjG2hYw/BIjQKIterehy4OkAWESfdgInHjIXOfawTY/rH5v11/je/eUDtZW/7Yta/Q+ISwRrCsB"; // this.authCache.GetLoginTicket(memberName, password, this.LiveIdServiceTarget, this.Policy, this.Environment);
            string machineToken = this.authCache.GetUserToken(memberName, password, this.LiveIdServiceTarget, this.Policy, this.Environment, this.PlatformType, this.TitleId, this.TitleVersion, this.ClientVersion);
            DateTime randomBDay = new DateTime(Utility.GlobalRandom.Next(1960, 1993), Utility.GlobalRandom.Next(1, 13), Utility.GlobalRandom.Next(1, 29));
            XboxLiveAccount xblAccount = new XboxLiveAccount() { MemberName = memberName, Password = password, GamerTag = gamerTag };

            //TODO: get enums for country/language id.  currently hardcoded for en-us
            Trace.TraceInformation("Creating Xbox Live Account (en-US) for {0} / {1}, with gamer tag {2}...", memberName, password, gamerTag);
            CreateMobileAccount(loginTicket, machineToken, gamerTag, 103, 1, randomBDay);
            xblAccount.Xuid = WaitForXblAccountCreation(memberName, password);
            return xblAccount;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="rpsTicket"></param>
        /// <param name="machineToken"></param>
        /// <param name="gamerTag"></param>
        /// <param name="countryId"></param>
        /// <param name="languageId"></param>
        /// <param name="birthDate"></param>
        public void CreateMobileAccount(string rpsTicket, string machineToken, string gamerTag, byte countryId, ushort languageId, DateTime birthDate)
        {
            //the API expects the 't=' and the '&p=' to be removed from the RPS ticket
            string trimmedTicket = rpsTicket.Remove(0, 2);
            trimmedTicket = trimmedTicket.Remove(trimmedTicket.Length - 3);
            byte[] rpsTicketBytes = Encoding.UTF8.GetBytes(trimmedTicket);

            try
            {
                ulong puid = ulong.Parse(Authorization.Authorization.GetPuid(machineToken));
                ulong machineId = ulong.Parse(Authorization.Authorization.GetMachineId(machineToken));
                TraceEx.TraceVerbose("Calling CreateMobileAccount with:\r\n\tPuid: {0}\r\n\tRPS ticket: {1}\r\n\tMachine ID: {2}\r\n\tGamer Tag: {3}\r\n\tCountry ID: {4}\r\n\tLanguage ID: {5}\r\n\tBirth Date:{6}", puid, rpsTicket, machineId, gamerTag, countryId, languageId, birthDate);
                this.XuacsProxy.StsToken = machineToken;
                this.XuacsProxy.CreateMobileAccount(puid, rpsTicketBytes, machineId, gamerTag, countryId, languageId, birthDate);
            }
            catch (Exception e)
            {
                throw new ApplicationException("Error creating XBL account.", e);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        public void AcceptTermsOfUse(string memberName, string password)
        {
            ulong puid;
            string loginTicket = this.authCache.GetLoginTicket(memberName, password, this.LiveIdServiceTarget, this.Policy, this.Environment, out puid);
            
            Trace.TraceInformation("Accepting terms of use for {0} / {1}...", memberName, password);
            //ulong puid = LiveID.GetUserPuid(memberName);
            AcceptTermsOfUse(puid, loginTicket);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="rpsTicket"></param>
        /// <param name="userToken"></param>
        public void AcceptTermsOfUse(ulong puid, string rpsTicket)
        {
            //the API expects the 't=' and the '&p=' to be removed from the RPS ticket
            string trimmedTicket = rpsTicket.Remove(0, 2);
            trimmedTicket = trimmedTicket.Remove(trimmedTicket.Length - 3);
            byte[] rpsTicketBytes = Encoding.UTF8.GetBytes(trimmedTicket);

            try
            {
                TraceEx.TraceVerbose("Calling AcceptTermsOfService with:\r\n\tPuid: {0}\r\n\tRPS ticket: {1}", puid, rpsTicket);
                this.XuacsProxy.RpsTicket = rpsTicket;
                this.XuacsProxy.AcceptTermsOfService(puid, rpsTicketBytes, ServiceTypeEnum.XboxLive);
            }
            catch (Exception e)
            {
                throw new ApplicationException("Error accepting terms of use.", e);
            }
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <returns></returns>
        private ulong WaitForXblAccountCreation(string memberName, string password)
        {
            string xuid;
            DateTime start = DateTime.Now;
            string loginTicket = authCache.GetLoginTicket(memberName, password, this.LiveIdServiceTarget, this.Policy, this.Environment);

            while (!Authorization.Authorization.IsUserSecurityToken(this.authCache.GetUserToken(memberName, password, this.LiveIdServiceTarget, this.Policy, this.Environment, this.PlatformType, this.TitleId, this.TitleVersion, this.ClientVersion), out xuid))
            {
                if (DateTime.Now.Subtract(start).TotalMilliseconds > this.XuacsCreationTimeout)
                    throw new ApplicationException(String.Format("Xbox Live account creation for {0} took longer than {1}ms.", memberName, this.XuacsCreationTimeout));
                Trace.TraceInformation("Waiting for Xbox Live account to be created for {0}...", memberName);
                System.Threading.Thread.Sleep(1000);
            }

            DateTime finish = DateTime.Now;
            Trace.TraceInformation("Successfully created Xbox Live Account for {0} / {1}!  Account creation took {2} seconds.", memberName, password, finish.Subtract(start).TotalSeconds);
            return ulong.Parse(xuid);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\Enums.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveN.Test
{
    /// <summary>
    /// Enum that describes the media types supported by Mobile PDLC
    /// </summary>
    /// <remarks>Subset from $DEPOT$\LEST_MAIN_DEV_PDLC\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\MediaTypes.cs</remarks>
    public enum MediaType : int
    {
        Unknown = 0,
        GameContent = 18, 
        ArcadeGame = 23,                // Arcade game. Represents the Full Arcade game
        GameConsumable = 24,
        AvatarItems = 47,
        PointsBundle = 49,
        MobileGame = 58,
        MobilePDLC = 59,
        MobileConsumable = 60
    }

    /// <summary>
    /// Enum that describes the payment types
    /// </summary>
    [Flags]
    public enum PurchasePaymentType : int
    {
        CreditCard = 1,
        Token = 2,
        Points = 4,
        Wholesale = 8,
        NoTokens = 13,
        All = 15,
        Untrusted = 65536,
    }

    public enum CatalogPaymentType : int
    {
        Points = 1,
        Token = 2,
        CreditCard = 3,
    }

    /// <summary>
    /// Enum that describes the marketplace store ids
    /// </summary>
    /// <remarks>Taken from $DEPOT$\LEST_MAIN_DEV\product\SharedSource\Leet.Live\Leet.Live.Livecache\DataAccess\PurchaseHistoryRequest.cs</remarks>
    public enum MarketplaceStore : uint
    {
        Xbox = 1,
        Zune = 2,
        GamesForWindows = 3,
        Zest = 4,
        Mobile = 5
    }

    /// <summary>
    /// Enum that describes the marketplace user types
    /// </summary>
    public enum UserType : int
    {
        XboxLiveGoldUser = 2,
        XboxLiveSilverUser = 3,
        XboxLiveFamilyGoldUser = 4
    }
    
    /// <summary>
    /// Enum that describes the marketplace platform types
    /// </summary>
    public enum PlatformType : uint
    {
        Xbox1 = 0,
        XboxCom = 1,
        Xbox360 = 2,
        Marketplace = 3,
        PC = 4,
        Mobile = 5,
        WebGames = 6,
    }

    public enum ConsoleType
    {
        Xbox360,
        WindowsPhone,
        WebGames,
    }

    /// <summary>
    /// Contains all the supported Locales
    /// </summary>
    public static class Locales
    {
        public const string en_US = "en-US";
        public const string fr_FR = "fr-FR";
        public const string ja_JP = "ja-JP";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\LiveID.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using System.Net;
using System.IO;
using System.Diagnostics;
using Microsoft.Win32;
using Microsoft.Passport.Test.Ppcrl;
using Microsoft.WindowsLive.Test.PassportInterface;
using LiveN.Test.Common;

namespace LiveN.Test.Framework
{
    public class LiveID
    {
        public const string XmlLoginTemplate = "<LoginRequest><ClientInfo name=\"MSN6=\" version=\"1.35=\"/><User><SignInName>{0}</SignInName><Password>{1}</Password><SavePassword>false</SavePassword></User><DAOption>0</DAOption><TargetOption>0</TargetOption></LoginRequest>";
        public const string RpsSecAuthCookieName = "RPSSecAuth";
        public const string RpsAuthCookieName = "RPSAuth";

        private static object idcrlLock = new object();
        private static Guid guid = new Guid("9F50F78D-771F-4dcc-B719-0FF313CAD504");
        private const int PPCRL_VERSION = 1;
        private const int SUCCESS_CODE = 0x48803;

        /// <summary>
        /// 
        /// </summary>
        static LiveID()
        {
            try
            {
                PassportInterface = new PassportInterface(Clusters.INT, Utility.CurrentDirectory);
            }
            catch //(Exception e)
            {
                // TODO: Removing becuase this always fails to initialize. TODO: One day figure out if anyone is even using this at all...
                // Trace.TraceWarning("Unable to initialize PassportInterface object.  Any user creation or IDSAPI functionality will fail.  This can safely be ignored if this functionality is not required.\r\n\r\n{0}", e.Message);
            }
        }

        /// <summary>
        /// Loads the interface to WLID.  Note: only works against WLID INT environment.
        /// </summary>
        public static PassportInterface PassportInterface
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <param name="siteDnsName"></param>
        /// <param name="policy"></param>
        /// <param name="environment"></param>
        /// <returns></returns>
        public static string GetLoginTicket(
            string username,
            string password,
            string siteDnsName,
            string policy,
            string environment)
        {
            ulong puid;
            return GetLoginTicket(username, password, siteDnsName, policy, environment, out puid);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <returns></returns>
        public static string GetLoginTicket(
            string username,
            string password,
            string siteDnsName,
            string policy,
            string environment,
            out ulong puid)
        {
            lock (idcrlLock)
            {
                ManagedIDCRL msidcrl;
                ManagedIDCRL.AuthState authState;
                ManagedIDCRL.LogonState logonState;
                int identity = 0;

                try
                {
                    msidcrl = new ManagedIDCRL();

                    //inialize IDCRL
                    ManagedIDCRL.Initialize_Options[] initOps = new ManagedIDCRL.Initialize_Options[1];
                    initOps[0].optionType = ManagedIDCRL.IDCRL_OPTION_ID.IDCRL_OPTION_ENVIRONMENT;
                    initOps[0].proxyUserInfo = environment;
                    msidcrl.InitializeEx(ref guid, PPCRL_VERSION, (uint)ManagedIDCRL.UpdateFlag.DEFAULT_UPDATE_POLICY, initOps);
                }
                catch (IDCRLException e)
                {
                    throw new Exception(String.Format("Unable to initialize IDCRL; error code {0} and error message '{1}' were returned. Verify that IDCRL is correctly installed.", e.ErrorCode, e.ErrorMessage), e);
                }
                catch (Exception e)
                {
                    throw new Exception("Unable to initialize IDCRL; verify that the client components are correctly installed.", e);
                }

                try
                {
                    msidcrl.CreateIdentityHandle(username, (uint)ManagedIDCRL.IdentityFlag.IDENTITY_SHARE_ALL, out identity);
                    msidcrl.SetCredential(identity, ManagedIDCRL.PPCRL_CREDTYPE_PASSWORD, password);
                    msidcrl.LogonIdentity(identity, null, (uint)ManagedIDCRL.LogonFlag.LOGONIDENTITY_DEFAULT);
                    msidcrl.GetAuthState(identity, out logonState);

                    if (logonState.AuthState != SUCCESS_CODE)
                    {
                        throw new Exception(String.Format("Login Failed: unable to login user '{0}'; request status={1}, auth state={2}.", username, logonState.RequestStatus.ToString(), logonState.AuthState.ToString()));
                    }

                    msidcrl.AuthIdentityToService(identity, siteDnsName, policy, (uint)ManagedIDCRL.ServiceTokenFlags.SERVICE_TOKEN_REQUEST_TYPE_NONE, out authState);
                    msidcrl.GetAuthState(identity, out logonState);
                    string hexPuid = msidcrl.GetIdentityPropertyByName(identity, ManagedIDCRL.PPCRL_CREDPROPERTY_PUIDSTR);
                    puid = ulong.Parse(hexPuid, System.Globalization.NumberStyles.HexNumber);
                }
                catch (IDCRLException e)
                {
                    throw new Exception(String.Format("Error logging in user '{0}' with IDCRL; error code {1} and error message '{2}' were returned. Verify that IDCRL is correctly installed.", username, e.ErrorCode, e.ErrorMessage), e);
                }
                catch (Exception e)
                {
                    throw new Exception(String.Format("Error generating ticket for user '{0}' for service '{1}' and policy '{2}'.", username, siteDnsName, policy), e);
                }
                finally
                {
                    msidcrl.CloseIdentityHandle(identity);
                    msidcrl.Uninitialize();
                }

                if (String.IsNullOrEmpty(authState.Token))
                {
                    throw new Exception(String.Format("Error generating ticket for user '{0}' for service '{1}' and policy '{2}'.", username, siteDnsName, policy));
                }

                return authState.Token;
            }
        }

        /// <summary>
        /// Removes all files cached by IDCRL.
        /// </summary>
        public static void ClearIDCRLCache()
        {
            string currentUserPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), @"Microsoft\IdentityCRL");
            string allUsersPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData), @"Microsoft\IdentityCRL");

            try
            {
                if (Directory.Exists(currentUserPath))
                {
                    DeleteDirectory(currentUserPath);
                }

                if (Directory.Exists(allUsersPath))
                {
                    DeleteDirectory(allUsersPath);
                }
            }
            catch (Exception e)
            {
                throw new Exception(String.Format("Error clearing IDCRL cache from '{0}' and/or '{1}'.", currentUserPath, allUsersPath), e);
            }
        }

        /// <summary>
        /// Recursively deletes a directory and all subdirectories/files.  This method also takes care of making sure that all file/directory
        /// attributes are normal, as File|Directory.Delete() will throw otherwise.
        /// </summary>
        /// <param name="path"></param>
        private static void DeleteDirectory(string path)
        {
            DirectoryInfo directory = new DirectoryInfo(path);
            foreach (FileSystemInfo info in directory.GetFileSystemInfos())
            {
                if (info is DirectoryInfo)
                {
                    info.Attributes = FileAttributes.Normal;
                    DeleteDirectory(info.FullName);
                }
                else
                {
                    info.Attributes = FileAttributes.Normal;
                    info.Delete();
                }
            }

            directory.Attributes = FileAttributes.Normal;
            directory.Delete();
        }

        /// <summary>
        /// 
        /// </summary>
        public static void ImportEnvironmentRegistryKeys()
        {
            RegistryKey idcrlKey = OpenOrCreateKey(Registry.LocalMachine, @"SOFTWARE\Microsoft\IdentityCRL");
            idcrlKey.SetValue("RemoteFile", "http://clientconfig.passport.net/PPCRLconfig.srf");
            RegistryKey environment = OpenOrCreateKey(idcrlKey, "Environment");
            CreateEnvironmentKey(environment, "Betaprep", "http://clientconfig-bp.passporttest.net/PPCRLconfig.srf");
            CreateEnvironmentKey(environment, "BRIM", "http://brimclientconfig.net.pp.test.microsoft.com/PPCRLconfig.srf");
            CreateEnvironmentKey(environment, "BVT", "http://clientconfig-bvt.net.pp.test.microsoft.com/PPCRLconfig.srf");
            CreateEnvironmentKey(environment, "Dev-C", "http://clientconfig-c.net.pdmsn.test.microsoft.com/PPCRLconfig.srf");
            CreateEnvironmentKey(environment, "Dev-D", "http://clientconfig-d.net.pdmsn.test.microsoft.com/PPCRLconfig.srf");
            CreateEnvironmentKey(environment, "Dev-E", "http://clientconfig-e.net.pdmsn.test.microsoft.com/PPCRLconfig.srf");
            CreateEnvironmentKey(environment, "INT", "http://clientconfig.passport-int.net/PPCRLconfig.srf");
            CreateEnvironmentKey(environment, "LH", "http://lhclientconfig.net.pp.test.microsoft.com/PPCRLconfig.srf");
            CreateEnvironmentKey(environment, "LOC", "http://loc-clientconfig.passporttest.net/PPCRLconfig.srf");
            CreateEnvironmentKey(environment, "PPE", "http://clientconfig.passport-ppe.net/PPCRLconfig.srf");
            CreateEnvironmentKey(environment, "Production", "http://clientconfig.passport.net/PPCRLconfig.srf");
            CreateEnvironmentKey(environment, "QFE", "http://qfe-clientconfig.passporttest.net/PPCRLconfig.srf");
            CreateEnvironmentKey(environment, "SP", "http://spclientconfig.net.pp.test.microsoft.com/PPCRLconfig.srf");
            CreateEnvironmentKey(environment, "Test", "http://clientconfig-test.net.pp.test.microsoft.com/PPCRLconfig.srf");
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="loginUrl"></param>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <returns></returns>
        public static string GetRpsAuthCookie(string loginUrl, string username, string password)
        {
            return GetRpsAuthCookie(loginUrl, username, password, RpsSecAuthCookieName);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="loginUrl"></param>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <returns></returns>
        public static string GetRpsAuthCookie(string loginUrl, string username, string password, string rpsCookieName)
        {
            HttpWebRequest loginRequest = (HttpWebRequest)WebRequest.Create(loginUrl);
            HttpWebResponse loginResponse = null;

            loginRequest.Method = "POST";
            loginRequest.CookieContainer = new CookieContainer();
            using (StreamWriter writer = new StreamWriter(loginRequest.GetRequestStream()))
            {
                writer.Write(String.Format(XmlLoginTemplate, username, password));
            }

            string loginResponseXml = null;
            string redirectUrl = null;

            try
            {
                loginResponse = (HttpWebResponse)loginRequest.GetResponse();
                using (StreamReader reader = new StreamReader(loginResponse.GetResponseStream()))
                {
                    loginResponseXml = reader.ReadToEnd();
                }

                redirectUrl = ParseLoginRedirect(loginResponseXml);
            }
            catch (WebException e)
            {
                if (e.Status == WebExceptionStatus.ProtocolError)
                {
                    loginResponse = (HttpWebResponse)e.Response;
                    using (StreamReader reader = new StreamReader(loginResponse.GetResponseStream()))
                    {
                        throw new ApplicationException(String.Format("Error returned from login server; HTTP status {0} ({1}).\r\n\r\n{2}", (int)loginResponse.StatusCode, loginResponse.StatusCode, reader.ReadToEnd()));
                    }
                }
                else
                    throw;
            }
            finally
            {
                if (loginResponse != null)
                    loginResponse.Close();
            }

            HttpWebRequest rpsCookieRequest = (HttpWebRequest)WebRequest.Create(redirectUrl);
            HttpWebResponse rpsCookieResponse = null;

            rpsCookieRequest.Method = "GET";
            rpsCookieRequest.AllowAutoRedirect = false;
            rpsCookieRequest.CookieContainer = loginRequest.CookieContainer;

            try
            {
                rpsCookieResponse = (HttpWebResponse)rpsCookieRequest.GetResponse();
                if (rpsCookieResponse.Cookies[rpsCookieName] == null)
                    throw new ApplicationException(String.Format("No RPS cookie ({0}) found in server response!", rpsCookieName));

                TraceEx.TraceVerbose("Successfully retrieved RPS cookie for {0}: {1}", username, rpsCookieResponse.Cookies[rpsCookieName]);
                return rpsCookieResponse.Cookies[rpsCookieName].Value;
            }
            catch (WebException e)
            {
                if (e.Status == WebExceptionStatus.ProtocolError)
                {
                    rpsCookieResponse = (HttpWebResponse)e.Response;
                    using (StreamReader reader = new StreamReader(rpsCookieResponse.GetResponseStream()))
                    {
                        throw new ApplicationException(String.Format("Error returned from server; HTTP status {0} ({1}).\r\n\r\n{2}", (int)loginResponse.StatusCode, loginResponse.StatusCode, reader.ReadToEnd()));
                    }
                }
                else
                    throw;
            }
            finally
            {
                if (rpsCookieResponse != null)
                    rpsCookieResponse.Close();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="response"></param>
        /// <returns></returns>
        private static string ParseLoginRedirect(string response)
        {
            XmlDocument loginXml = new XmlDocument();
            loginXml.LoadXml(response);

            XmlNode redirect = loginXml.SelectSingleNode("LoginResponse/Redirect");
            if (redirect == null)
                throw new ApplicationException(String.Format("Unable to find Redirect node in login server response: {0}", response));
            return redirect.InnerText;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="parent"></param>
        /// <param name="path"></param>
        /// <returns></returns>
        private static RegistryKey OpenOrCreateKey(RegistryKey parent, string path)
        {
            RegistryKey key = parent.OpenSubKey(path, true);
            if (key == null)
            {
                key = parent.CreateSubKey(path);
            }
            return key;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="parent"></param>
        /// <param name="environment"></param>
        /// <param name="remoteFile"></param>
        private static void CreateEnvironmentKey(RegistryKey parent, string environment, string remoteFile)
        {
            OpenOrCreateKey(parent, environment).SetValue("RemoteFile", remoteFile);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <returns></returns>
        public static ulong GetUserPuid(string memberName)
        {
            PassportUser user = PassportInterface.GetExistingUserByMemberName(memberName);
            return ((ulong)user.PUIDHigh << 32) + (uint)user.PUIDLow;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static PassportUser CreateWindowsLiveID()
        {
            PassportUser user = new PassportUser(Markets.en_US, Domains.Live, true, UserTypes.WindowsLive);
            return CreateWindowsLiveID(user);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <returns></returns>
        public static PassportUser CreateWindowsLiveID(string memberName, string password)
        {
            PassportUser user = new PassportUser(Markets.en_US, Domains.Live, true, UserTypes.WindowsLive);
            user.MemberName = memberName;
            user.Password = password;
            return CreateWindowsLiveID(user);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="user"></param>
        /// <returns></returns>
        public static PassportUser CreateWindowsLiveID(PassportUser user)
        {
            try
            {
                Trace.TraceInformation("Creating Windows Live ID for {0} / {1}...", user.MemberName, user.Password);
                return PassportInterface.CreateUser(user);
            }
            catch (Exception e)
            {
                throw new ApplicationException(String.Format("Error creating a new Windows Live ID for {0} / {1}; {2}.", user.MemberName, user.Password, e.Message), e);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\Authorization\Player.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveN.Test.Framework.Authorization
{
    /// <summary>
    /// 
    /// </summary>
    public class Player
    {
        /// <summary>
        /// 
        /// </summary>
        public ulong Xuid
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public byte Tier
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public byte Country
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\Authorization\CustomSignedXml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Web;
using System.Xml;
using System.Xml.Serialization;
using System.Security.Cryptography;
using System.Security.Cryptography.Xml;

namespace LiveN.Test.Framework.Authorization
{
    // http://blogs.msdn.com/shawnfa/archive/2004/04/05/108098.aspx
    // Searching for Custom ID Tags With Signed XML
    // Excerpt... The biggest limitation with doing this is that you must refer to the nodes that are being signed by ID, 
    // which for v1.1 and 1.0 of the framework was given by an attribute named "Id". The problem there is that 
    // the Id attribute may already have another use in your schema, and you cannot reuse them for creating node names. 
    // Another problem that may come up is that the XML being signed may be generated by a tool or program, 
    // and it's not possible for you to add Id tags. Whidbey reduces this limitation somewhat by also allowing 
    // "id" and "ID", but the fundamental problem still exists.

    // Nodes that are being referred to by ID are resolved in the GetIdElement method of the SignedXml class. 
    // By subclassing SignedXml and overriding this method, its possible to create your own id node resolver. 


    public class CustomSignedXml : SignedXml
    {
        public CustomSignedXml(XmlDocument doc) :
            base(doc)
        {
        }

        public override XmlElement GetIdElement(XmlDocument doc, string id)
        {
            // check to see if it's a standard ID reference
            XmlElement idElem = base.GetIdElement(doc, id);
            if (idElem != null)
                return idElem;

            idElem = doc.SelectSingleNode("//*[@AssertionID=\"" + id + "\"]") as XmlElement;
            return idElem;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\Authorization\OmittedTokenItems.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveN.Test.Framework.Authorization
{
    /// <summary>
    /// Items to be omitted from a user/partner token
    /// </summary>
    [Flags]
    public enum OmittedTokenItems: uint
    {
        None = 0,
        MajorVersion = 1,
        MinorVersion = 2,
        Issuer = 4,
        NotBefore = 8,
        NotOnOrAfter = 16,
        NotBeforeNotOnOrAfter = 32,
        Subject = 64,
        Audience = 128,
        Signature = 256,
        PlatformType = 512,
        DeviceId = 1024,
        ClientVersion = 2048,
        TitleId = 4096,
        TitleVersion = 8192,
        Xuid = 16384,
        Puid = 32768,
        CID = 65536,
        Gamertag = 131072,
        Tier = 262144,
        MachineId = 524288,
        Country = 1048576,
        Privledges = 2097152,
    };

    public static class OmittedTokenItemsExtensions
    {

        public static bool IsSet(this OmittedTokenItems items, OmittedTokenItems flags)
        {
            return (items & flags) == flags;
        }

        public static bool IsNotSet(this OmittedTokenItems items, OmittedTokenItems flags)
        {
            return (~items & flags) == flags;
        }

        public static OmittedTokenItems Set(this OmittedTokenItems items, OmittedTokenItems flags)
        {
            return items | flags;
        }

        public static OmittedTokenItems Clear(this OmittedTokenItems items, OmittedTokenItems flags)
        {
            return items & (~flags);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\FrameworkLib\Authorization\AuthorizationCache.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Web;
using System.Web.Caching;
using System.Diagnostics;
using LiveN.Test.Common;
using LiveN.Test.Framework.Configuration;

namespace LiveN.Test.Framework.Authorization
{
    /// <summary>
    /// Caches authorization information, on a per credential basis, to avoid repeat/superfluous authentications.
    /// Currently hardcoded to cache authorization data for 30 mins.
    /// </summary>
    public class AuthorizationCache
    {
        private static HttpRuntime httpRuntime;
        private static object syncLock = new object();
        private Authorization auth;

        /// <summary>
        /// 
        /// </summary>
        static AuthorizationCache()
        {
            //this ensures that the HttpRuntime cache is available,
            //irrespective of environment (console, web app, winform, etc.)
            if (httpRuntime == null)
            {
                lock (syncLock)
                {
                    if (httpRuntime == null)
                        httpRuntime = new HttpRuntime();
                }
            }

            try
            {
                TraceEx.TraceVerbose("Attempting to import IDCRL environment registry keys...");
                LiveID.ImportEnvironmentRegistryKeys();
            }
            catch { }

            try
            {
                TraceEx.TraceVerbose("Attempting to clear IDCRL cache...");
                LiveID.ClearIDCRLCache();
            }
            catch { }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsUrl"></param>
        /// <param name="clientCertSubject"></param>
        public AuthorizationCache(string stsUrl, string clientCertSubject)
            : this(stsUrl, clientCertSubject, 30000)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsUrl"></param>
        /// <param name="clientCertSubject"></param>
        /// <param name="timeout"></param>
        public AuthorizationCache(string stsUrl, string clientCertSubject, int timeout)
        {
            this.auth = new Authorization(stsUrl, clientCertSubject, timeout);
        }

        /// <summary>
        /// 
        /// </summary>
        public string StsUrl
        {
            get
            {
                return auth.StsUrl;
            }
            set
            {
                auth.StsUrl = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public string ClientCertificateSubject
        {
            get
            {
                return auth.ClientCertSubject;
            }
            set
            {
                auth.ClientCertSubject = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public int Timeout
        {
            get
            {
                return auth.Timeout;
            }
            set
            {
                auth.Timeout = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public static Cache AuthCache
        {
            get
            {
                return HttpRuntime.Cache;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <param name="target"></param>
        /// <param name="policy"></param>
        /// <param name="environment"></param>
        /// <returns></returns>
        public string GetLoginTicket(string username, string password, string target, string policy, string environment)
        {
            ulong puid;
            return GetLoginTicket(username, password, target, policy, environment, out puid);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <param name="target"></param>
        /// <param name="policy"></param>
        /// <param name="environment"></param>
        /// <returns></returns>
        public string GetLoginTicket(string username, string password, string target, string policy, string environment, out ulong puid)
        {
            string key = GetWlidTicketKey(username + target + policy);
            string cachedValue = AuthCache.Get(key) as string;
            string loginTicket;
            puid = 0;   //NOTE: no way that I know of to get puid from WLID cookies (RPSTicketGenerator)...

            if (cachedValue == null)
            {
                try
                {
                    loginTicket = auth.GetLoginTicket(
                        username,
                        password,
                        target,
                        policy,
                        environment,
                        out puid);
                }
                catch (Exception e)
                {
                    Trace.TraceWarning("Unable to get RPS ticket with IDCRL - {0}; retrying using RpsTicketGenerator...", e.Message);
                    loginTicket = auth.GetRpsCompactTicket(username, password, target, policy, environment);
                }

                TimeSpan cacheTime;
                switch (policy.ToLower())
                {
                    //NOTE: these values were taken from the WLID RPS Server documentati